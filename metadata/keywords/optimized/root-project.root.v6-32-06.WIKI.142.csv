quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,"ition at line 556 of file TInterpreter.h. ◆ IsVoidPointerType(). virtual Bool_t TInterpreter::IsVoidPointerType ; (; const void * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 559 of file TInterpreter.h. ◆ Load(). virtual Int_t TInterpreter::Load ; (; const char * ; filenam, . Bool_t ; system = kFALSE . ). pure virtual . Implemented in TCling. ◆ LoadEnums(). virtual void TInterpreter::LoadEnums ; (; TListOfEnums & ; cl); const. pure virtual . Implemented in TCling. ◆ LoadFile(). virtual int TInterpreter::LoadFile ; (; const char * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 259 of file TInterpreter.h. ◆ LoadFunctionTemplates(). virtual void TInterpreter::LoadFunctionTemplates ; (; TClass * ; cl); const. pure virtual . Implemented in TCling. ◆ LoadLibraryMap(). virtual Int_t TInterpreter::LoadLibraryMap ; (; const char * ; rootmapfile = nullptr). pure virtual . Implemented in TCling. ◆ LoadMacro(). virtual void TInterpreter::LoadMacro ; (; const char * ; filename, . EErrorCode * ; error = nullptr . ). pure virtual . Implemented in TCling. ◆ LoadText(). virtual Bool_t TInterpreter::LoadText ; (; const char * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 260 of file TInterpreter.h. ◆ MakeInterpreterValue(). virtual std::unique_ptr< TInterpreterValue > TInterpreter::MakeInterpreterValue ; (; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 278 of file TInterpreter.h. ◆ MapCppName(). virtual const char * TInterpreter::MapCppName ; (; const char * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 261 of file TInterpreter.h. ◆ MethodArgInfo_DefaultValue(). virtual const char * TInterpreter::MethodArgInfo_DefaultValue ; (; MethodArgInfo_t * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 516 of file TInterpreter.h. ◆ MethodArgInfo_Delete(). virtual void TInterpreter::MethodArgInfo_Delete ; (; MethodArgInfo_t * ; ); const. in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter.html:79072,Load,LoadMacro,79072,doc/master/classTInterpreter.html,https://root.cern,https://root.cern/doc/master/classTInterpreter.html,1,['Load'],['LoadMacro']
Performance,"ition of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:22435,cache,cache,22435,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['cache'],['cache']
Performance,"ition(). RooAddition(const char* name, const char* title, const RooArgSet& sumSet, Bool_t takeOwnerShip = kFALSE). RooAddition(const char* name, const char* title, const RooArgList& sumSet1, const RooArgList& sumSet2, Bool_t takeOwnerShip = kFALSE). RooAddition(const RooAddition& other, const char* name = 0). ~RooAddition(). Double_t evaluate() const; Calculate and return current value of self. Double_t defaultErrorLevel() const; Return the default error level for MINUIT error analysis; If the addition contains one or more RooNLLVars and; no RooChi2Vars, return the defaultErrorLevel() of; RooNLLVar. If the addition contains one ore more RooChi2Vars; and no RooNLLVars, return the defaultErrorLevel() of; RooChi2Var. If the addition contains neither or both; issue a warning message and return a value of 1. Bool_t setData(RooAbsData& data, Bool_t cloneData = kTRUE). void printMetaArgs(ostream& os) const. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& numVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate integral cache. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. TObject* clone(const char* newname) const; { return new RooAddition(*this, newname); }. const RooArgList& list1() const; { return _set ; }. const RooArgList& list() const; { return _set ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. » Last changed: Fri Dec 2 14:26:41 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddition.html:35347,cache,cache,35347,root/html532/RooAddition.html,https://root.cern,https://root.cern/root/html532/RooAddition.html,1,['cache'],['cache']
Performance,"itle"");; serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with the command:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json; Then, its representation will look like:; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 0,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. Name; Description. root.bin; binary data produced by object streaming with TBufferFile. root.json; ROOT JSON representation for object and objects members. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implemented). root.gif; GIF image. root.jpeg; JPEG image. exe.json; method execution in the object. exe.bin; method execution, return result in binary form. cmd.json; command execution. item.json; item (object) properties, specified on the server. multi.json; perform several requests at once. multi.bin; perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:14708,perform,perform,14708,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['perform'],['perform']
Performance,"itle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); virtual voidsetVal(Double_t value); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tvolume(const char* rangeName) const; virtual Double_tvolume(const RooAbsBinning& binning) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsRealLValue.html:30267,cache,cache,30267,root/html602/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsRealLValue.html,2,['cache'],['cache']
Performance,"itle, const RooArgList& fracSet); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRecursiveFraction.html:24324,cache,cache,24324,root/html602/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html,2,['cache'],['cache']
Performance,"itle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealSumPdf.html:41295,cache,cache,41295,root/html602/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html,8,['cache'],"['cache', 'caches']"
Performance,"itle="""") constPrint predefined help message of classifier.Definition Factory.cxx:1333; TMVA::Factory::fSilentFileBool_t fSilentFile! used in constructor without fileDefinition Factory.h:217; TMVA::Factory::fCorrelationsBool_t fCorrelations! enable to calculate correlationsDefinition Factory.h:215; TMVA::Factory::IsModelPersistenceBool_t IsModelPersistence() constDefinition Factory.h:152; TMVA::Factory::fOptionsTString fOptions! option string given by construction (presently only ""V"")Definition Factory.h:211; TMVA::Factory::MVectorstd::vector< IMethod * > MVectorDefinition Factory.h:84; TMVA::Factory::TrainAllMethodsvoid TrainAllMethods()Iterates through all booked methods and calls training.Definition Factory.cxx:1114; TMVA::Factory::VerboseBool_t Verbose(void) constDefinition Factory.h:134; TMVA::Factory::WriteDataInformationvoid WriteDataInformation(DataSetInfo &fDataSetInfo)Definition Factory.cxx:602; TMVA::Factory::BookMethodMethodBase * BookMethod(DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx:352; TMVA::Factory::TestAllMethodsvoid TestAllMethods()Evaluates all booked methods on the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::TrainAllMethodsForClassificationvoid TrainAllMethodsForClassification(void)Definition Factory.h:115; TMVA::Factory::fVerboseBool_t fVerbose! verbose modeDefinition Factory.h:213; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::Factory::EvaluateImportanceRandomTH1F * EvaluateImportanceRandom(DataLoader *loader, UInt_t nseeds, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2473; TMVA::Factory::GetImportanceTH1F * GetImportance(const int nbits, std::vector< Double_t > importances, std::vector< TString > va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:13300,load,loader,13300,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['load'],['loader']
Performance,"itor*fCurrentMonitorcurrently active monitor; TDSet*fDSetcurrent TDSet being validated; Int_tfDrawQueriesnumber of draw queries during this sessions; TList*fEnabledPackagesOnClientlist of packages enabled on client; Bool_tfEndMastertrue for a master in direct contact only with workers; TList*fFeedbacklist of names to be returned as feedback; map<TString,TProof::MD5Mod_t,less<TString>,allocator<pair<const TString,TProof::MD5Mod_t> > >fFileMapmap keeping track of a file's md5 and mod time; Bool_tfFinalizationRunning; THashList*fGlobalPackageDirListlist of directories containing global packages libs; TStringfGroupPROOF group of this user; TList*fInactiveSlaveslist of inactive slaves (good but not used for processing); TList*fInputDataInput data objects sent over via file; TStringfInputDataFileFile with input data objects; TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfIsWaitingtrue if queries have been enqueued; Int_tfLastAssignedMerger; TList*fLoadedMacrosList of loaded macros (just file names); TStringfLogFileNamename of the temp file for redirected logs; FILE*fLogFileRtemp file to read redirected logs; FILE*fLogFileWtemp file to redirect logs; Int_tfLogLevelserver debug logging level; Bool_tfLogToWindowOnlysend log to window only; TStringfMastermaster server ("""" if a master); used in the browser; Int_tfMaxDrawQueriesmax number of draw queries kept; TProofMergePrgfMergePrgMerging progress; TList*fMergers; Int_tfMergersCount; Bool_tfMergersSetIndicates, if the following variables have been initialized properly; TList*fNonUniqueMasterslist of all active masters with a nonunique file system; Int_tfNotIdleNumber of non-idle sub-nodes; Int_tfOtherQueriesnumber of queries in list from previous sessions; TStringfPackageDirpackage directory (used on client); TProofLockPath*fPackageLockpackage lock; TVirtualProofPlayer*fPlayercurrent player; PrintProgress_tfPrintProgressFunction function to display progress info in batch mode; TPluginHandler*fProgressDialo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:29292,load,loaded,29292,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['load'],['loaded']
Performance,"its are set.; 1152/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 1153/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 1154/// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; 1155/// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; 1156///; 1157///; 1158/// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; 1159/// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; 1171/// The chi-square is then computed as the sum of the quantity below at each data point:; 1172///; 1173/// \f[; 1174/// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; 1175/// \f]; 1176///; 1177/// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; 1178/// function `f(x)`.; 1179///; 1180/// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; 1181///; 1182/// The approach used to approximate the uncertainty in y because of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:40772,perform,performed,40772,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['perform'],['performed']
Performance,"its in the .fFlags field; as appropriate. For every TGHtmlBlock where the bit changes,; mark that block for redrawing. void LostSelection(); Clear selection. int SelectionSet(const char* startIx, const char* endIx); Set selection. void UpdateInsert(); Recompute the position of the insertion cursor based on the; position in fIns. int SetInsert(const char* insIx); Set the position of the insertion cursor. void SavePrimitive(ostream& out, Option_t* = """"); Save a html widget as a C++ statement(s) on output stream out. TGHtmlTextElement & operator=(const TGHtml& ). TGHtml(const TGWindow* p, int w, int h, int id = -1). Bool_t ProcessMessage(Long_t , Long_t , Long_t ). int GetTableRelief() const; { return fTableRelief; }. int GetRuleRelief() const; { return fRuleRelief; }. int GetRulePadding() const; { return fRulePadding; }. const char * GetBaseUri() const; { return fZBase; }. char * ResolveUri(const char* uri); User function to resolve URIs. TImage * LoadImage(const char* uri, int w = 0, int h = 0); User function to get an image from a URL. int IsVisited(const char* ); { return 0; }; User function to tell if a hyperlink has already been visited. { return kFALSE; }. int ProcessToken(TGHtmlElement* , const char* , int ); User function to process tokens of the given type. { return kFALSE; }. int ProcessFrame(); The HTML parser will invoke the following methods from time; to time to find out information it needs to complete formatting of; the document.; Method for handling <frameset> markup. { return kFALSE; }. TGFrame * ProcessApplet(TGHtmlInput* ); Method to process applets. { return 0; }. int FormCreate(TGHtmlForm* , const char* , const char* ); Called when parsing forms. { return kFALSE; }. int FormAction(TGHtmlForm* , int ); Called when user presses Submit. { return kFALSE; }. char * GetFontName(); Invoked to find font names. { return 0; }. char * ProcessScript(TGHtmlScript* ); Invoked for each <SCRIPT> markup. { return 0; }. const char * GetText() const; { return fZText",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHtml.html:40755,Load,LoadImage,40755,root/html602/TGHtml.html,https://root.cern,https://root.cern/root/html602/TGHtml.html,2,['Load'],['LoadImage']
Performance,"its { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Long64_tfBytesRead!track bytes read of main file; TH2D*fCpuTimeHist!histogram of cpu time spent processing packets; TDSet*fDSet!Saved pointer to the TDSet object; TStringfDataSet!Dataset string; Int_tfDataSetLen!Maximum size of the dataset string fDataSet ; Int_tfDataSetSize!# of files in the dataset ; Bool_tfDoHist!Fill histos; Bool_tfDoQuota!Save stats on SQL server for quota management; Bool_tfDoSlaveTrace!Full tracing in workers; Bool_tfDoTrace!Trace details in master; Bool_tfDoTraceRate!Trace processing rate in master; TH1D*fEventsHist!histogram of events processed per slave; TH2D*fLatencyHist!histogram of latency due to packet requests; TObjArrayfMonSenders!Monitoring engines; Bool_tfMonitorPerPacket!Whether to send the full entry per each packet ; TH1D*fNodeHist!histogram of slaves per file serving node; Long64_tfNumEvents!total number of events to be processed; TList*fOutput!Saved pointer to the output list ; TH1D*fPacketsHist!histogram of packets processed per slave; TPerfEvent*fPerfEvent!TPerfEvent used to fill tree; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run; static Long_tfgResMemMax! Max resident memory used by this process; static Long_tfgVirtMemMax! Max virtual memory used by this process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. ~TPerfStats(); Destructor. void SimpleEvent(TVirtualPerfStats::EEventType type); Simple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPerfStats.html:7136,latency,latency,7136,root/html532/TPerfStats.html,https://root.cern,https://root.cern/root/html532/TPerfStats.html,1,['latency'],['latency']
Performance,itsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. ←; THashList. ←; TSelectorList. Function documentation; Bool_t UnsetDirectory(TObject* obj); If the class of obj has the SetDirectory(TDirectory*) method; call it to unset the directory assiciation. The objects in the; selector list or owned by the list and not by the directory that; was active when they were created. Returns true in case of success. Bool_t CheckDuplicateName(TObject* obj); Check for duplicate object names in the list. If an object with; the same name is added then the merge function will fail that will; look up objects in different output lists by name. Returns true; in case name is uniqu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelectorList.html:10729,cache,cache,10729,root/html602/TSelectorList.html,https://root.cern,https://root.cern/root/html602/TSelectorList.html,2,['cache'],['cache']
Performance,"itsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfEnumsWithLock(TClass* cl = 0). ~TListOfEnumsWithLock(); Destructor. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfEnumsWithLock.html:10597,cache,cache,10597,root/html602/TListOfEnumsWithLock.html,https://root.cern,https://root.cern/root/html602/TListOfEnumsWithLock.html,2,['cache'],['cache']
Performance,"itsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClass! Context of this list. Not owned.; TExMap*fIds! Map from DeclId_t to TDataMember*; Bool_tfIsLoaded! Mark whether Load was executed.; ULong64_tfLastLoadMarker! Represent interpreter state when we last did a full load.; THashList*fUnloaded! Holder of TDataMember for unloaded DataMembers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfDataMembers(TClass* cl = 0); Constructor. ~TListOfDataMembers(); Destructor. void MapObject(TObject* obj); Add a pair<id, object> to the map of data members and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfDataMembers.html:10691,cache,cache,10691,root/html602/TListOfDataMembers.html,https://root.cern,https://root.cern/root/html602/TListOfDataMembers.html,2,['cache'],['cache']
Performance,"itsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClass! Context of this list. Not owned.; TExMap*fIds! Map from DeclId_t to TEnum*; Bool_tfIsLoaded! Mark whether Load was executed.; ULong64_tfLastLoadMarker! Represent interpreter state when we last did a full load.; THashList*fUnloaded! Holder of TEnum for unloaded Enums. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfEnums(TClass* cl = 0); Constructor. ~TListOfEnums(); Destructor. void MapObject(TObject* obj); Add pair<id, object> to the map of functions and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfEnums.html:10708,cache,cache,10708,root/html602/TListOfEnums.html,https://root.cern,https://root.cern/root/html602/TListOfEnums.html,2,['cache'],['cache']
Performance,"itsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClassContext of this list. Not owned.; TExMap*fIdsMap from DeclId_t to TFunction*; ULong64_tfLastLoadMarkerRepresent interpreter state when we last did a full load.; THashTablefOverloadsTLists of overloads.; THashList*fUnloadedHolder of TFunction for unloaded functions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfFunctionTemplates(TClass* cl); Constructor. ~TListOfFunctionTemplates(); Destructor. void MapObject(TObject* obj); Add pair<id, object> to the map of functions and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfFunctionTemplates.html:10651,cache,cache,10651,root/html602/TListOfFunctionTemplates.html,https://root.cern,https://root.cern/root/html602/TListOfFunctionTemplates.html,2,['cache'],['cache']
Performance,"itsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClassContext of this list. Not owned.; TExMap*fIdsMap from DeclId_t to TFunction*; ULong64_tfLastLoadMarkerRepresent interpreter state when we last did a full load.; THashTablefOverloadsTLists of overloads.; THashList*fUnloadedHolder of TFunction for unloaded functions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfFunctions(TClass* cl); Constructor. ~TListOfFunctions(); Destructor. void MapObject(TObject* obj); Add pair<id, object> to the map of functions and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfFunctions.html:10493,cache,cache,10493,root/html602/TListOfFunctions.html,https://root.cern,https://root.cern/root/html602/TListOfFunctions.html,2,['cache'],['cache']
Performance,"itten to disk when it is full. Branches, buffers, and leafs, are explained a little later in this chapter, but for now, it is important to realize that each object is not written individually, but rather collected and written a bunch at a time.; This is where the TTree takes advantage of compression and will produce a much smaller file than if the objects were written individually. Since the unit to be compressed is a buffer, and the TTree contains many same-class objects, the header of the objects can be compressed.; The TTree reduces the header of each object, but it still contains the class name. Using compression, the class name of each same-class object has a good chance of being compressed, since the compression algorithm recognizes the bit pattern representing the class name. Using a TTree and compression the header is reduced to about 4 bytes compared to the original 60 bytes. However, if compression is turned off, you will not see these large savings.; The TTree is also used to optimize the data access. A tree uses a hierarchy of branches, and each branch can be read independently from any other branch. Now, assume that Px and Py are data members of the event, and we would like to compute Px2 + Py2 for every event and histogram the result.; If we had saved the million events without a TTree we would have to:. read each event in its entirety into memory; extract the Px and Py from the event; compute the sum of the squares; fill a histogram. We would have to do that a million times! This is very time consuming, and we really do not need to read the entire event, every time. All we need are two little data members (Px and Py). On the other hand, if we use a tree with one branch containing Px and another branch containing Py, we can read all values of Px and Py by only reading the Px and Py branches. This makes the use of the TTree very attractive.; 12.2 A Simple TTree; This script builds a TTree from an ASCII file containing statistics about the staff at CERN. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:520997,optimiz,optimize,520997,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimize']
Performance,"itter::fUserFuncTObject * fUserFuncPointer to user theoretical function (a TF1*)Definition TVirtualFitter.h:44; TVirtualFitter::fMethodCallTMethodCall * fMethodCallPointer to MethodCall in case of interpreted function.Definition TVirtualFitter.h:45; TVirtualFitter::GetMaxIterationsstatic Int_t GetMaxIterations()static: Return the maximum number of iterations actually max number of function callsDefinition TVirtualFitter.cxx:218; TVirtualFitter::GetPrecisionstatic Double_t GetPrecision()static: Return the fit relative precisionDefinition TVirtualFitter.cxx:236; TVirtualFitter::fYlastInt_t fYlastLast bin on Y axis.Definition TVirtualFitter.h:36; TVirtualFitter::fXfirstInt_t fXfirstFirst bin on X axis.Definition TVirtualFitter.h:33; TVirtualFitter::fZfirstInt_t fZfirstFirst bin on Z axis.Definition TVirtualFitter.h:37; TVirtualFitter::fXlastInt_t fXlastLast bin on X axis.Definition TVirtualFitter.h:34; TVirtualFitter::SetCachevirtual Double_t * SetCache(Int_t npoints, Int_t psize)Initialize the cache array npoints is the number of points to be stored (or already stored) in the ca...Definition TVirtualFitter.cxx:281; TVirtualFitter::SetFCNvirtual void SetFCN(void(*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t))To set the address of the minimization objective function called by the native compiler (see function...Definition TVirtualFitter.cxx:267; TVirtualFitter::TVirtualFitterTVirtualFitter()Default constructor.Definition TVirtualFitter.cxx:72; TVirtualFitter::GetDefaultFitterstatic const char * GetDefaultFitter()static: return the name of the default fitterDefinition TVirtualFitter.cxx:200; TVirtualFitter::fCacheDouble_t * fCache[fCacheSize] Array of points data (fNpoints*fPointSize < fCacheSize words)Definition TVirtualFitter.h:42; TVirtualFitter::SetMaxIterationsstatic void SetMaxIterations(Int_t niter=5000)static: Set the maximum number of function calls for the minimization algorithm For example for MIGRA...Definition TVirtualFitter.cxx:298; TVirtualFitte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:14784,cache,cache,14784,doc/master/TVirtualFitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html,1,['cache'],['cache']
Performance,"ity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TParallelCoordSelect::(anonymous)kShowRanges; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. private:. TStringfTitleTitle of the selection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoordSelect(); Default constructor. TParallelCoordSelect(const char* title); Normal constructor. ~TParallelCoordSelect(); Destructor. void SetActivated(Bool_t on); Activate the selection. void SetShowRanges(Bool_t s); Show the ranges niddles. TParallelCoordSelect(). const char* GetTitle() const; {return fTitle.Data();}. void SetTitle(const char* title); {fTitle = title;}. » Author: Bastien Dalla Piazza 02/08/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/treeviewer:$Id$ » Last generated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TParallelCoordSelect.html:11238,cache,cache,11238,root/html602/TParallelCoordSelect.html,https://root.cern,https://root.cern/root/html602/TParallelCoordSelect.html,2,['cache'],['cache']
Performance,"ity; to delete this object.; The option default value is ""np"". see TTree::Draw for explanation of the other parameters. The created object is named ""principal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called everytime a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:106701,cache,cache,106701,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['cache'],['cache']
Performance,"ivar] == kForceMax) {; 657 ranges.push_back( new Interval( fCutRange[ivar]->GetMin(), fCutRange[ivar]->GetMax(), nbins ) );; 658 ranges.push_back( new Interval( fCutRange[ivar]->GetMax() - fCutRange[ivar]->GetMin(),; 659 fCutRange[ivar]->GetMax() - fCutRange[ivar]->GetMin(), nbins ) );; 660 }; 661 else {; 662 ranges.push_back( new Interval( fCutRange[ivar]->GetMin(), fCutRange[ivar]->GetMax(), nbins ) );; 663 ranges.push_back( new Interval( 0, fCutRange[ivar]->GetMax() - fCutRange[ivar]->GetMin(), nbins ) );; 664 }; 665 }; 666 ; 667 // create the fitter; 668 FitterBase* fitter = NULL;; 669 ; 670 switch (fFitMethod) {; 671 case kUseGeneticAlgorithm:; 672 fitter = new GeneticFitter( *this, TString::Format(""%sFitter_GA"", GetName()), ranges, GetOptions() );; 673 break;; 674 case kUseMonteCarlo:; 675 fitter = new MCFitter ( *this, TString::Format(""%sFitter_MC"", GetName()), ranges, GetOptions() );; 676 break;; 677 case kUseMinuit:; 678 fitter = new MinuitFitter ( *this, TString::Format(""%sFitter_MINUIT"", GetName()), ranges, GetOptions() );; 679 break;; 680 case kUseSimulatedAnnealing:; 681 fitter = new SimulatedAnnealingFitter( *this, TString::Format(""%sFitter_SA"", GetName()), ranges, GetOptions() );; 682 break;; 683 default:; 684 Log() << kFATAL << ""Wrong fit method: "" << fFitMethod << Endl;; 685 }; 686 ; 687 if (fInteractive) fitter->SetIPythonInteractive(&fExitFromTraining, &fIPyMaxIter, &fIPyCurrentIter);; 688 ; 689 fitter->CheckForUnusedOptions();; 690 ; 691 // perform the fit; 692 fitter->Run();; 693 ; 694 // clean up; 695 for (UInt_t ivar=0; ivar<ranges.size(); ivar++) delete ranges[ivar];; 696 delete fitter;; 697 ; 698 }; 699 // --------------------------------------------------------------------------; 700 else if (fFitMethod == kUseEventScan) {; 701 ; 702 Int_t nevents = Data()->GetNEvents();; 703 Int_t ic = 0;; 704 ; 705 // timing of MC; 706 Int_t nsamples = Int_t(0.5*nevents*(nevents - 1));; 707 Timer timer( nsamples, GetName() );; 708 fIPyMaxIter = nsamples;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:26611,perform,perform,26611,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['perform'],['perform']
Performance,"ivate:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCacheUnzip.html:17720,cache,cache,17720,root/html604/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html,1,['cache'],['cache']
Performance,ivatevirtual . declare SA options ; Implements TMVA::FitterBase.; Definition at line 72 of file MinuitFitter.cxx. ◆ DeclFileName(). static const char * TMVA::MinuitFitter::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 80 of file MinuitFitter.h. ◆ EstimatorFunction(). Double_t TMVA::MinuitFitter::EstimatorFunction ; (; std::vector< Double_t > & ; pars). virtual . performs the fit by calling Run(pars) ; Implements TMVA::IFitterTarget.; Definition at line 211 of file MinuitFitter.cxx. ◆ Init(). void TMVA::MinuitFitter::Init ; (; ). minuit-specific settings ; Definition at line 88 of file MinuitFitter.cxx. ◆ IsA(). virtual TClass * TMVA::MinuitFitter::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::FitterBase.; Definition at line 80 of file MinuitFitter.h. ◆ Run(). Double_t TMVA::MinuitFitter::Run ; (; std::vector< Double_t > & ; pars). virtual . performs the fit ; Implements TMVA::FitterBase.; Definition at line 129 of file MinuitFitter.cxx. ◆ Streamer(). virtual void TMVA::MinuitFitter::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TMVA::FitterBase. ◆ StreamerNVirtual(). void TMVA::MinuitFitter::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 80 of file MinuitFitter.h. Member Data Documentation. ◆ fBatch. Bool_t TMVA::MinuitFitter::fBatch. private . batch mode ; Definition at line 76 of file MinuitFitter.h. ◆ fErrorLevel. Int_t TMVA::MinuitFitter::fErrorLevel. private . minuit error level ; Definition at line 70 of file MinuitFitter.h. ◆ fFitStrategy. Int_t TMVA::MinuitFitter::fFitStrategy. private . minuit strategy level ; Definition at line 72 of file MinuitFitter.h. ◆ fMaxCalls. Int_t TMVA::MinuitFitter::fMaxCalls. private . (approximate) maximum number of function calls ; Definition at line 77 of file MinuitFitter.h. ◆ fMinWrap. MinuitWrapper* TMVA:,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MinuitFitter.html:18488,perform,performs,18488,doc/master/classTMVA_1_1MinuitFitter.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MinuitFitter.html,1,['perform'],['performs']
Performance,"ive function has not been set"");; 276 return false;; 277 }; 278 // look if FCN is of a known type and we can get retrieve the model function and data objects; 279 if (!fFunc || !fData); 280 ExamineFCN();; 281 // init the minimizer; 282 if (!DoInitMinimizer()); 283 return false;; 284 // perform the minimization; 285 return DoMinimization();; 286}; 287 ; 288bool Fitter::EvalFCN(); 289{; 290 // evaluate the FCN using the stored values in fConfig; 291 ; 292 if (fFunc && fResult->FittedFunction() == nullptr); 293 fFunc.reset();; 294 ; 295 if (!ObjFunction()) {; 296 MATH_ERROR_MSG(""Fitter::FitFCN"", ""Objective function has not been set"");; 297 return false;; 298 }; 299 // create a Fit result from the fit configuration; 300 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig);; 301 // evaluate one time the FCN; 302 double fcnval = (*ObjFunction())(fResult->GetParams());; 303 // update fit result; 304 fResult->fVal = fcnval;; 305 fResult->fNCalls++;; 306 return true;; 307}; 308 ; 309bool Fitter::DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy); 310{; 311 ; 312 // perform a chi2 fit on a set of binned data; 313 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 314 assert(data);; 315 ; 316 // check function; 317 if (!fFunc && !fFunc_v) {; 318 MATH_ERROR_MSG(""Fitter::DoLeastSquareFit"", ""model function is not set"");; 319 return false;; 320 } else {; 321 ; 322#ifdef DEBUG; 323 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[3].IsBound() << "" lower limit ""; 324 << Config().ParamsSettings()[3].LowerLimit() << "" upper limit ""; 325 << Config().ParamsSettings()[3].UpperLimit() << std::endl;; 326#endif; 327 ; 328 fBinFit = true;; 329 fDataSize = data->Size();; 330 // check if fFunc provides gradient; 331 if (!fUseGradient) {; 332 // do minimization without using the gradient; 333 if (fFunc_v) {; 334 return DoMinimization(std::make_unique<Chi2FCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, executionPolicy));; 335 } else {; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:10922,perform,perform,10922,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['perform'],['perform']
Performance,"ive index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame; static TProofProgressLog::ETextTypekGrep; static TProofProgressLog::ETextTypekRaw; static TProofProgressLog::ETextTypekStd. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display logs. 'grep' is set to kTRUE if it is invoked by pressing the; 'Filter' button. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void SetGrepView(); Sets the view of grep filters according to the value of checkboxes. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600). void SetUr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressLog.html:25434,Load,LoadFile,25434,root/html602/TProofProgressLog.html,https://root.cern,https://root.cern/root/html602/TProofProgressLog.html,4,['Load'],"['Load', 'LoadFile']"
Performance,"ive slaves.; If random is TRUE, and nodes is less than the number of available workers,; a random selection is done.; Returns -1 in case of error. void ShowData(); List contents of the data directory in the sandbox.; This is the place where files produced by the client queries are kept. void ClearData(UInt_t what = kUnregistered, const char* dsname = 0); Remove files for the data directory.; The option 'what' can take the values:; kPurge remove all files and directories under '~/data'; kUnregistered remove only files not in registered datasets (default); kDataset remove files belonging to dataset 'dsname'; User is prompt for confirmation, unless kForceClear is ORed with the option. Bool_t Prompt(const char* p); Prompt the question 'p' requiring an answer y,Y,n,N; Return kTRUE is the answer was y or Y, kFALSE in all other cases. void ClearDataProgress(Int_t r, Int_t t); Progress bar for clear data. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:59751,cache,caches,59751,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,['cache'],['caches']
Performance,"ive) and \p end (exclusive) to the TEntryList in a loop. It; 703/// is useful also in PyROOT to avoid having to do the same in a Python loop.; 704 ; 705void TEntryList::EnterRange(Long64_t start, Long64_t end, TTree *tree, UInt_t step); 706{; 707 for (auto entry = start; entry < end; entry += step) {; 708 this->Enter(entry, tree);; 709 }; 710}; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Remove entry \#entry from the list; 714/// - When tree = 0, removes from the current list; 715/// - When tree != 0, finds the list, corresponding to this tree; 716/// - When tree is a chain, the entry is assumed to be global index and the local; 717/// entry is recomputed from the treeoffset information of the chain; 718 ; 719bool TEntryList::Remove(Long64_t entry, TTree *tree); 720{; 721 if (entry < 0); 722 return false;; 723 if (!tree) {; 724 if (!fLists) {; 725 if (!fBlocks) return false;; 726 TEntryListBlock *block = nullptr;; 727 Long64_t nblock = entry/kBlockSize;; 728 block = (TEntryListBlock*)fBlocks->UncheckedAt(nblock);; 729 if (!block) return false;; 730 Long64_t blockindex = entry - nblock*kBlockSize;; 731 if (block->Remove(blockindex)){; 732 fN--;; 733 return true;; 734 }; 735 } else {; 736 if (!fCurrent) fCurrent = (TEntryList*)fLists->First();; 737 if (fCurrent->Remove(entry)){; 738 if (fLists); 739 fN--;; 740 return true;; 741 }; 742 }; 743 } else {; 744 Int_t localentry = tree->LoadTree(entry);; 745 SetTree(tree->GetTree());; 746 if (fCurrent){; 747 if (fCurrent->Remove(localentry)) {; 748 if (fLists); 749 fN--;; 750 return true;; 751 }; 752 }; 753 }; 754 return false;; 755}; 756 ; 757////////////////////////////////////////////////////////////////////////////////; 758/// Return the number of the entry \#index of this TEntryList in the TTree or TChain; 759/// See also Next().; 760 ; 761Long64_t TEntryList::GetEntry(Long64_t index); 762{; 763 ; 764 if ((index>=fN) || (index<0)) {; 765 return -1;; 766 }; 767 if (ind",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:25174,Load,LoadTree,25174,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"iven thread. ; Definition at line 999 of file TGeoManager.cxx. ◆ TopToMaster(). void TGeoManager::TopToMaster ; (; const Double_t * ; top, . Double_t * ; master . ); const. Convert coordinates from top volume frame to master. ; Definition at line 4265 of file TGeoManager.cxx. ◆ TransformVolumeToAssembly(). Int_t TGeoManager::TransformVolumeToAssembly ; (; const char * ; vname). Transform all volumes named VNAME to assemblies. The volumes must be virtual. ; Definition at line 1203 of file TGeoManager.cxx. ◆ UnbombTranslation(). void TGeoManager::UnbombTranslation ; (; const Double_t * ; tr, . Double_t * ; bombtr . ). Get the new 'unbombed' translation vector according current exploded view mode. ; Definition at line 1088 of file TGeoManager.cxx. ◆ UnlockGeometry(). void TGeoManager::UnlockGeometry ; (; ). static . Unlock current geometry. ; Definition at line 4048 of file TGeoManager.cxx. ◆ UpdateElements(). void TGeoManager::UpdateElements ; (; ). private . Update element flags when geometry is loaded from a file. ; Definition at line 4167 of file TGeoManager.cxx. ◆ ViewLeaves(). void TGeoManager::ViewLeaves ; (; Bool_t ; flag = kTRUE). Set visualization option (leaves only OR all volumes) ; Definition at line 2437 of file TGeoManager.cxx. ◆ Volume() [1/2]. TGeoVolume * TGeoManager::Volume ; (; const char * ; name, . const char * ; shape, . Int_t ; nmed, . Double_t * ; upar, . Int_t ; npar = 0 . ). Create a volume in GEANT3 style. . NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters . Definition at line 1401 of file TGeoManager.cxx. ◆ Volume() [2/2]. TGeoVolume * TGeoManager::Volume ; (; const char * ; name, . const char * ; shape, . Int_t ; nmed, . Float_t * ; upar, . Int_t ; npar = 0 . ). Create a volume in GEANT3 style. . NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters . Definition at li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:143538,load,loaded,143538,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['load'],['loaded']
Performance,"iven websocket id. ;  ; virtual TString GetDefaultPageContent ();  Provides content of default web page for registered web-socket handler Can be content of HTML page or file name, where content should be taken For instance, file:/home/user/test.htm or file:$jsrootsys/files/canvas.htm If not specified, default index.htm page will be shown Used by the webcanvas. ;  ; Int_t GetNumWS ();  Returns current number of websocket connections. ;  ; UInt_t GetWS (Int_t num=0);  Return websocket id with given sequential number Number of websockets returned with GetNumWS() method. ;  ; Bool_t HasWS (UInt_t wsid);  Return kTRUE if websocket with given ID exists. ;  ; TClass * IsA () const override;  ; Bool_t IsDisabled () const;  Returns true when processing of websockets is disabled, set shortly before handler need to be destroyed. ;  ; Bool_t IsSyncMode () const;  Returns processing mode of WS handler If sync mode is TRUE (default), all event processing and data sending performed in main thread All send functions are blocking and must be performed from main thread If sync mode is false, WS handler can be used from different threads and starts its own sending threads. ;  ; virtual Bool_t ProcessWS (THttpCallArg *arg)=0;  ; Int_t SendCharStarWS (UInt_t wsid, const char *str);  Send string via given websocket id. ;  ; Int_t SendHeaderWS (UInt_t wsid, const char *hdr, const void *buf, int len);  Send binary data with text header via given websocket id. ;  ; Int_t SendWS (UInt_t wsid, const void *buf, int len);  Send binary data via given websocket id. ;  ; void SetDisabled ();  Disable all processing of websockets, normally called shortly before destructor. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpWSHandler.html:3247,perform,performed,3247,doc/master/classTHttpWSHandler.html,https://root.cern,https://root.cern/doc/master/classTHttpWSHandler.html,2,['perform'],['performed']
Performance,"iver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TStringGetJobAd(); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidTProof::SendInputDataFile(); voidTProof::SetDSet(TDSet* dset); voidTProof::SetPlayer(TVirtualProofPlayer* player); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidTProof::ValidateDSet(TDSet* dset).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofCondor.html:20520,cache,cachedir,20520,root/html528/TProofCondor.html,https://root.cern,https://root.cern/root/html528/TProofCondor.html,1,['cache'],['cachedir']
Performance,"iver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTProofServ::DeletePlayer(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tTProofServ::Fork(); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; Int_tTProofServ::GetSessionStatus(); virtual voidTProofServ::HandleArchive(TMessage* mess, TString* slb = 0); virtual Int_tTProofServ::HandleCache(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleCheckFile(TMessage* mess, TString* slb = 0); virtual Int_tTProofServ::HandleDataSets(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleFork(TMessage* mess); virtual Int_tTProofServ::HandleLibIncPath(TMessage* mess); virtual voidTProofServ::HandleProcess(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleQueryList(TMessage* mess); virtual voidTProofServ::HandleRemove(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleRetrieve(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleSubmerger(TMessage* mess); virtual Int_tTProofServ::HandleWorkerLists(TMessage* mess); virtual voidTApplication::Help(const char* line); Bool_tTProofServ::IsIdle(); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); virtual voidTProofServ::MakePlayer(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual voidTProofServ::ProcessNext(TString* slb = 0); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh); Int_tTProofServ::SetupCommon(); Bool_tTProofServ::UnlinkDataDir(const char* path).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofServ.html:15469,Load,LoadGraphicsLibs,15469,root/html534/TXProofServ.html,https://root.cern,https://root.cern/root/html534/TXProofServ.html,2,['Load'],['LoadGraphicsLibs']
Performance,"ix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixTSym<Element> Determinant() const. void TMatrixTSym<Element> Determinant(Double_t& d1, Double_t& d2) const. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSym_float_.html:17630,Perform,Perform,17630,root/html528/TMatrixTSym_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSym_float_.html,4,['Perform'],['Perform']
Performance,"ix will be added, though in this case uniqueness of the names is not ensured and it can cause that file will be invalid. Loading geometry from a root file can be done in the same way as for any other ROOT object, but a static method is also provided:; TGeoManager::Import(const char *filename,const char *keyname="""",; Option_t *opt=""""); TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; Example:; // Writing to a file geometry definition ending with:; root[] gGeoManager->CloseGeometry();; // geometry is ready; root[] gGeoManager->Export(""MyGeom.root"");; // file MyGeom.root produced; root[] gGeoManager->Export(""MyGeom.C"");; // C++ macro MyGeom.C produced; root[] gGeoManager->Export(""MyGeom.gdml"");; // GDML file MyGeom.gdml produced; root[] myVolume->SaveAs(""MyVolume.C"");; // C++ macro for the branch starting; // with MyVolume; // Reading from a file; root[] gSystem->Load(""libGeom"");; root[] TGeoManager::Import(""MyGeom.root""); // geometry is ready; Note that not all-current information held by the modeller is written on the file. For instance, the painter and checker objects are not written, as well as the temporary current navigation properties: current node path, point or direction. On the other hand, all objects belonging to the geometrical hierarchy will always be written. The idea is to be able to retrieve the geometry in a ready state, ignoring what the state variables that can be always re-initialized. When the code is generated for a given TGeoVolume in the geometry, just the branch starting with that volume will be saved in the file. Executing the generated code will create a geometry that has MyVolume as top volume. In this case, only the materials/media/matrices used effectively in the MyVolume branch are exported to file.; Volumes can be made persistent in the same way the full geometry is. Exporting is straightf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:123165,Load,Load,123165,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['Load'],['Load']
Performance,"ix->RegisterYourself();; 1438 }; 1439 TIter next4(fMatrices);; 1440 index = 1;; 1441 while ((matrix = (TGeoMatrix *)next4())) {; 1442 matrix->SetUniqueID(index++);; 1443 matrix->ResetBit(TGeoMatrix::kGeoSavePrimitive);; 1444 }; 1445 TIter next5(fVolumes);; 1446 TGeoVolume *vol;; 1447 while ((vol = (TGeoVolume *)next5())); 1448 vol->UnmarkSaved();; 1449}; 1450 ; 1451////////////////////////////////////////////////////////////////////////////////; 1452/// Reset all attributes to default ones. Default attributes for visualization; 1453/// are those defined before closing the geometry.; 1454 ; 1455void TGeoManager::ClearAttributes(); 1456{; 1457 if (gPad); 1458 delete gPad;; 1459 gPad = nullptr;; 1460 SetVisOption(0);; 1461 SetVisLevel(3);; 1462 SetExplodedView(0);; 1463 SetBombFactors();; 1464 if (!gStyle); 1465 return;; 1466 TIter next(fVolumes);; 1467 TGeoVolume *vol = nullptr;; 1468 while ((vol = (TGeoVolume *)next())) {; 1469 if (!vol->IsVisTouched()); 1470 continue;; 1471 vol->SetVisTouched(kFALSE);; 1472 }; 1473}; 1474////////////////////////////////////////////////////////////////////////////////; 1475/// Closing geometry implies checking the geometry validity, fixing shapes; 1476/// with negative parameters (run-time shapes)building the cache manager,; 1477/// voxelizing all volumes, counting the total number of physical nodes and; 1478/// registering the manager class to the browser.; 1479 ; 1480void TGeoManager::CloseGeometry(Option_t *option); 1481{; 1482 if (fClosed) {; 1483 Warning(""CloseGeometry"", ""geometry already closed"");; 1484 return;; 1485 }; 1486 if (!fMasterVolume) {; 1487 Error(""CloseGeometry"", ""you MUST call SetTopVolume() first !"");; 1488 return;; 1489 }; 1490 if (!gROOT->GetListOfGeometries()->FindObject(this)); 1491 gROOT->GetListOfGeometries()->Add(this);; 1492 if (!gROOT->GetListOfBrowsables()->FindObject(this)); 1493 gROOT->GetListOfBrowsables()->Add(this);; 1494 // TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 1495 // TIter next(br",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:54981,cache,cache,54981,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['cache'],['cache']
Performance,"ix; static Bool_tfgSmoothinguse anti-aliasing (true when >8 planes, false otherwise); static Int_tfgSymbItaFontIdxSymbol italic font index; static Int_tfgTBlankWtrailing blanks width; static Int_tfgWidthstring width, used to compute X alignment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TTF(); Cleanup TTF environment. void Init(); Initialise the TrueType fonts interface. void Cleanup(); Cleanup. Is called by the gCleanupTTF destructor. Short_t CharToUnicode(UInt_t code); Map char to unicode. Returns 0 in case no mapping exists. void GetTextExtent(UInt_t& w, UInt_t& h, char* text); Get width (w) and height (h) when text is horizontal. void GetTextAdvance(UInt_t& a, char* text); Get advance (a) when text is horizontal. void GetTextExtent(UInt_t& w, UInt_t& h, wchar_t* text); Get width (w) and height (h) when text is horizontal. void LayoutGlyphs(); Compute the glyps positions, fgAscent and fgWidth (needed for alignment).; Perform the Glyphs transformation.; Compute the string control box.; If required take the ""kerning"" into account.; SetRotation and PrepareString should have been called before. void PrepareString(const char* string); Put the characters in ""string"" in the ""glyphs"" array. void PrepareString(const wchar_t* string); Put the characters in ""string"" in the ""glyphs"" array. void SetHinting(Bool_t state); Set hinting flag. void SetKerning(Bool_t state); Set kerning flag. void SetRotationMatrix(Float_t angle); Set the rotation matrix used to rotate the font outlines. void SetSmoothing(Bool_t state); Set smoothing (anti-aliasing) flag. Int_t SetTextFont(const char* fontname, Int_t italic = 0); Set text font to specified name.; font : font name; italic : the fonts should be slanted. Used for symbol font. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextFont(Font_t fontnumber); Set specified font.; List of the currently supported fonts (screen and PostS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTF.html:3318,Perform,Perform,3318,root/html534/TTF.html,https://root.cern,https://root.cern/root/html534/TTF.html,1,['Perform'],['Perform']
Performance,"ixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. Load the shared library:; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");. Creating. Create a thread instance (see also example RunMhs3.CorRunPi.C) with:; root[] TThread *th = new TThread(UserFun,UserArgs);; When called from the interpreter, this gives the name “UserFun” to the thread. This name can be used to retrieve the thread later. However, when called from compiled code, this method does not give any name to the thread. So give a name to the thread in compiled use:; root[] TThread *th = new TThread(""MyThread"", UserFun, UserArgs);; You can pass arguments to the thread function using the UserArgs-pointer. When you want to start a method of a class as a thread, you have to give the pointer to the class instance as UserArgs. Running. root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; With the mhs3 example, you should be able to see a canvas with two pads on it. Both pads keep histograms updated and filled by three different threads. With the CalcPi example, yo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1105901,Load,Load,1105901,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['Load'],['Load']
Performance,"ization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:43825,cache,cache,43825,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,2,['cache'],['cache']
Performance,"ization is needed whenever distribution parameters have been changed.; The default method used for multi-dimensional distributions is ""vnrou"" Note that some of the multi-dimensional continuous distribution methods like ""hitro"" are based on Markov-CHain sampler and they are much faster for sampling but require more time to converge. Furthermore, since they are Markov-Chain methods their generated sample values are correlated and cannot be used as i.i.d., one can instead use the obtained sample distribution. (see also the ROOT issue: #10222 ). ; Definition at line 92 of file TUnuran.cxx. ◆ InitBinomial(). bool TUnuran::InitBinomial ; (; unsigned int ; ntot, . double ; prob, . const std::string & ; method = ""dstd"" . ). Initialize method for the Binomial distribution. ; Used to generate poisson numbers for a constant parameters (n,p) of the Binomial distribution. Use after the method TUnuran::SampleDiscr to generate the numbers. The flag reinit perform a fast re-initialization when only the distribution parameters are changed in the subsequent calls. If the same TUnuran object is used to generate with other distributions it cannot be used. ; Definition at line 462 of file TUnuran.cxx. ◆ InitPoisson(). bool TUnuran::InitPoisson ; (; double ; mu, . const std::string & ; method = ""dstd"" . ). Initialize method for the Poisson distribution. ; Used to generate poisson numbers for a constant parameter mu of the Poisson distribution. Use after the method TUnuran::SampleDiscr to generate the numbers. The flag reinit perform a fast re-initialization when only the distribution parameters are changed in the subsequent calls. If the same TUnuran object is used to generate with other distributions it cannot be used. ; Definition at line 448 of file TUnuran.cxx. ◆ IsDistCont(). bool TUnuran::IsDistCont ; (; ); const. Return true for a univariate continuous distribution. ; Definition at line 390 of file TUnuran.cxx. ◆ IsDistDiscrete(). bool TUnuran::IsDistDiscrete ; (; ); const. Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnuran.html:10399,perform,perform,10399,doc/master/classTUnuran.html,https://root.cern,https://root.cern/doc/master/classTUnuran.html,1,['perform'],['perform']
Performance,"ization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; const RooArgSet*_nset! Normalization set to be used in evaluation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfProbability Density function; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooEffProd.html:39667,cache,cache,39667,root/html528/RooEffProd.html,https://root.cern,https://root.cern/root/html528/RooEffProd.html,2,['cache'],['cache']
Performance,"ization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyrlife; RooRealProxyrsf; RooRealProxysigma; RooRealProxyssf; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGExpModel.html:42002,cache,cache,42002,root/html526/RooGExpModel.html,https://root.cern,https://root.cern/root/html526/RooGExpModel.html,4,['cache'],['cache']
Performance,"ization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,bool>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html:45117,cache,cache,45117,root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html,2,['cache'],['cache']
Performance,"izationGradients(). template<typename AReal > . void TMVA::DNN::TReference< Real_t >::AddL2RegularizationGradients ; (; TMatrixT< AReal > & ; A, . const TMatrixT< AReal > & ; W, . AReal ; weightDecay . ). static . Definition at line 82 of file Regularization.hxx. ◆ AddRowWise(). template<typename AReal > . void TMVA::DNN::TReference< AReal >::AddRowWise ; (; TMatrixT< Scalar_t > & ; output, . const TMatrixT< Scalar_t > & ; biases . ). static . Add the vectors biases row-wise to the matrix output. ; Definition at line 30 of file Propagation.hxx. ◆ Backward(). template<typename AReal > . void TMVA::DNN::TReference< AReal >::Backward ; (; TMatrixT< Scalar_t > & ; activationGradientsBackward, . TMatrixT< Scalar_t > & ; weightGradients, . TMatrixT< Scalar_t > & ; biasGradients, . TMatrixT< Scalar_t > & ; df, . const TMatrixT< Scalar_t > & ; activationGradients, . const TMatrixT< Scalar_t > & ; weights, . const TMatrixT< Scalar_t > & ; activationBackward . ). static . Perform the complete backward propagation step. ; If the provided activationGradientsBackward matrix is not empty, compute the gradients of the objective function with respect to the activations of the previous layer (backward direction). Also compute the weight and the bias gradients. Modifies the values in df and thus produces only a valid result, if it is applied the first time after the corresponding forward propagation has been per- formed. ; Definition at line 40 of file Propagation.hxx. ◆ ConstAdd(). template<typename AReal > . void TMVA::DNN::TReference< AReal >::ConstAdd ; (; TMatrixT< AReal > & ; A, . AReal ; beta . ). static . Add the constant beta to all the elements of matrix A and write the result into A. ; Definition at line 48 of file Arithmetic.hxx. ◆ ConstMult(). template<typename AReal > . void TMVA::DNN::TReference< AReal >::ConstMult ; (; TMatrixT< AReal > & ; A, . AReal ; beta . ). static . Multiply the constant beta to all the elements of matrix A and write the result into A. ; Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html:20523,Perform,Perform,20523,doc/master/classTMVA_1_1DNN_1_1TReference.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html,1,['Perform'],['Perform']
Performance,"ize (default 65535);; TStringTNamed::fTitleobject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TSeqCollection*fSecContextsList of TSecContext with cleanup info; static UChar_tfgAcceptOptDefault accept options; static void*fgSrvAuthClupHook; static void*fgSrvAuthHook. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object for a named service. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object on a specified port. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TServerSocket.html:10505,queue,queue,10505,root/html528/TServerSocket.html,https://root.cern,https://root.cern/root/html528/TServerSocket.html,4,['queue'],['queue']
Performance,"ize = 128; chunk_size = 5_000; ; target = ""Type""; ; # Returns two TF.Dataset for training and validation batches.; ds_train, ds_valid = ROOT.TMVA.Experimental.CreateTFDatasets(; tree_name,; file_name,; batch_size,; chunk_size,; validation_split=0.3,; target=target,; ); ; # Get a list of the columns used for training; input_columns = ds_train.train_columns; num_features = len(input_columns); ; ##############################################################################; # AI example; ##############################################################################; ; # Define TensorFlow model; model = tf.keras.Sequential(; [; tf.keras.layers.Dense(; 300, activation=tf.nn.tanh, input_shape=(num_features,); ), # input shape required; tf.keras.layers.Dense(300, activation=tf.nn.tanh),; tf.keras.layers.Dense(300, activation=tf.nn.tanh),; tf.keras.layers.Dense(1, activation=tf.nn.sigmoid),; ]; ); loss_fn = tf.keras.losses.BinaryCrossentropy(); model.compile(optimizer=""adam"", loss=loss_fn, metrics=[""accuracy""]); ; # Train model; model.fit(ds_train, validation_data=ds_valid, epochs=2); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; Epoch 1/2; ; 1/Unknown - 9s 9s/step - loss: 0.5945 - accuracy: 0.7656␈",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBatchGenerator__TensorFlow_8py.html:1444,optimiz,optimizer,1444,doc/master/RBatchGenerator__TensorFlow_8py.html,https://root.cern,https://root.cern/doc/master/RBatchGenerator__TensorFlow_8py.html,1,['optimiz'],['optimizer']
Performance,"ize as fraction of domain size; RooFFTConvPdf::BufStrat_bufStratStrategy to fill the buffer; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager; RooSetProxy_cacheObsNon-convolution observables that are also cached; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFFTConvPdf.html:48403,cache,cache,48403,root/html602/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html602/RooFFTConvPdf.html,2,['cache'],['cache']
Performance,"ize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PeekDataCache() const; Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PopDataCache(); Pop and Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. void operator=(const TBuffer& ). Int_t Read(const char* name); { return TObject::Read(name); }. Int_t Write(const char* name, Int_t opt, Int_t bufs); { return TObject::Write(name, opt, bufs); }. Int_t Write(const char* name, Int_t opt, Int_t bufs) const; { return TObject::Write(name, opt, bufs); }. Int_t GetBufferVersion() const; { return fVersion; }. Bool_t IsReading() const; { return (fMode & kWrite) == 0; }. Bool_t IsWriting() const; { return (fMode & kWrite) != 0; }. void SetBufferOffset(Int_t offset = 0); { fBufCur = fBuffer+offset; }. char * Buffer() const; { return fBuffer; }. Int_t BufferSize() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBuffer.html:18602,cache,cache,18602,root/html530/TBuffer.html,https://root.cern,https://root.cern/root/html530/TBuffer.html,2,['cache'],['cache']
Performance,"ize for the TTree and this factor is used to give the cache size. If option is set to zero auto cache creation is disabled and the default cache size is the historical one (equivalent to factor 1.0). If set to non zero auto cache creation is enabled and both auto created and default sized caches will use the configured factor: 0.0 no automatic cache and greater than 0.0 to enable cache. This value can be overridden by the environment variable ROOT_TTREECACHE_SIZE.; The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling type. The prefill type may be: 0 for no prefilling and 1 to prefill all the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL; In particular the default can be set back to the same as in version 5 by setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill (or ROOT_TTREECACHE_PREFILL) both to zero.; TTree methods which are expected to modify a cache, like AddBranchToCache, will attempt to setup a cache of default size if one does not exist, irrespective of whether the auto cache creation is enabled. Additionally several methods giving control of the cache have changed return type from void to Int_t, to be able to return a code to indicate if there was an error.; Usually TTree::SetCacheSize will no longer reset the list of branches to be cached (either set or previously learnt) nor restart the learning phase. The learning phase is restarted when a new cache is created, e.g. after having removed a cache with SetCacheSize(0).; TSelectorDraw; The axis titles in case of a x:y:z plot with the option COLZ were not correct.; TParallelCoordVar; Change the format used to print the variables limit for ||-Coord to %g. It was %6.4f before.; Histogram Libraries; TFormula. New version of the TFormula class based on Cling. Formula expressions are now used to create functions which are passed to Cling to be Just In Time compiled. The expression is therefore compiled using Clang/LLVVM which will g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:13576,cache,cache,13576,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,3,['cache'],['cache']
Performance,"ize. Increasing the default has the benefit that when reading many small objects the map does not need to be resized too often (the system is always dynamic, even with the default everything will work, only the initial resizing will cost some time). This method can only be called directly after the creation of the TBuffer, before any reading is done. Globally this option can be changed using SetGlobalReadParam(). ; Implements TBuffer.; Definition at line 97 of file TBufferIO.cxx. ◆ SetWriteParam(). void TBufferIO::SetWriteParam ; (; Int_t ; mapsize). overridevirtual . Set the initial size of the hashtable used to store object and class references during writing. ; The default size is TBufferFile::kMapSize. Increasing the default has the benefit that when writing many small objects the hashtable does not get too many collisions (the system is always dynamic, even with the default everything will work, only a large number of collisions will cost performance). For optimal performance hashsize should always be a prime. This method can only be called directly after the creation of the TBuffer, before any writing is done. Globally this option can be changed using SetGlobalWriteParam(). ; Implements TBuffer.; Definition at line 117 of file TBufferIO.cxx. ◆ Streamer(). void TBufferIO::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TBuffer.; Reimplemented in TBufferJSON, TBufferText, TBufferSQL2, TBufferXML, TMessage, and TBufferSQL. ◆ StreamerNVirtual(). void TBufferIO::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 120 of file TBufferIO.h. ◆ TagStreamerInfo(). void TBufferIO::TagStreamerInfo ; (; TVirtualStreamerInfo * ; info). overridevirtual . Mark the classindex of the current file as using this TStreamerInfo. ; Implements TBuffer.; Reimplemented in TMessage.; Definition at line 350 of file TBufferIO.cxx. ◆ Void_Hash(). static R__ALWAYS_INLINE ULong_t TBufferIO::Void_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:40810,perform,performance,40810,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['perform'],['performance']
Performance,"izerRooCustomizer is a factory class to produce clones of a prototype composite PDF object with the same ...Definition RooCustomizer.h:36; RooCustomizer::setCloneBranchSetvoid setCloneBranchSet(RooArgSet &cloneBranchSet)Releases ownership of list of cloned branch nodes.Definition RooCustomizer.cxx:640; RooCustomizer::replaceArgvoid replaceArg(const RooAbsArg &orig, const RooAbsArg &subst)Replace any occurrence of arg 'orig' with arg 'subst'.Definition RooCustomizer.cxx:327; RooCustomizer::buildRooAbsArg * build(const char *masterCatState, bool verbose=false)Build a clone of the prototype executing all registered 'replace' rules and 'split' rules for the mas...Definition RooCustomizer.cxx:383; RooCustomizer::setOwningvoid setOwning(bool flag)If flag is true, make customizer own all created components.Definition RooCustomizer.h:45; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataHist::setvoid set(std::size_t binNumber, double weight, double wgtErr)Set bin content of bin that was last loaded with get(std::size_t).Definition RooDataHist.cxx:1754; RooDataHist::binVolumedouble binVolume(std::size_t i) constReturn bin volume of i-th bin.Definition RooDataHist.h:118; RooDataHist::getconst RooArgSet * get() const overrideGet bin centre of current bin.Definition RooDataHist.h:82; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFirstMomentDefinition RooFirstMoment.h:26; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFitResult::covarianceMatrixconst TMatrixDSym & covarianceMatrix() constReturn covariance matrix.Definition RooFitResult.cxx:1112; RooFitResult::reducedCovarianceMatrixTMatrixDSym reducedCovarianceMatrix(const RooArgList &params) constReturn a reduced covari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:241694,load,loaded,241694,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['load'],['loaded']
Performance,"j : 2.825e-02; : 5 : m_jlv : 1.999e-02; : 6 : m_jj : 3.834e-03; : 7 : m_lv : 3.699e-03; : -------------------------------; Factory : Train method: Likelihood for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ Likelihood ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 14000 events: 0.117 sec ; Likelihood : [dataset] : Evaluation of Likelihood on training sample (14000 events); : Elapsed ti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:17032,Perform,Performance,17032,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['Perform'],['Performance']
Performance,"j : 2.825e-02; : 5 : m_jlv : 1.999e-02; : 6 : m_jj : 3.834e-03; : 7 : m_lv : 3.699e-03; : -------------------------------; Factory : Train method: Likelihood for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ Likelihood ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 14000 events: 0.118 sec ; Likelihood : [dataset] : Evaluation of Likelihood on training sample (14000 events); : Elapsed ti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:16967,Perform,Performance,16967,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['Perform'],['Performance']
Performance,"j(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp, char* parent); voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_t_lastIndexLast slot accessed; Int_t_maxSizeMaximum size; RooNormSetCache*_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. Int_t setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Setter f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCacheManager_RooAbsCacheElement_.html:3569,cache,cache,3569,root/html526/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html526/RooCacheManager_RooAbsCacheElement_.html,1,['cache'],['cache']
Performance,"j); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. (unknown)(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load). » Author: Philippe Canal 24/06/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *; » Last changed: root/base:$Id: TClassGenerator.h 30751 2009-10-15 16:45:32Z pcanal $ » Last generated: 2010-09-23 20:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClassGenerator.html:5731,load,load,5731,root/html528/TClassGenerator.html,https://root.cern,https://root.cern/root/html528/TClassGenerator.html,4,['load'],['load']
Performance,"j); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. (unknown)(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load). » Author: Philippe Canal 24/06/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *; » Last changed: root/base:$Id: TClassGenerator.h 30751 2009-10-15 16:45:32Z pcanal $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClassGenerator.html:5800,load,load,5800,root/html530/TClassGenerator.html,https://root.cern,https://root.cern/root/html530/TClassGenerator.html,4,['load'],['load']
Performance,"j); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. (unknown)(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load). » Author: Philippe Canal 24/06/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *; » Last changed: root/base:$Id: TClassGenerator.h 30751 2009-10-15 16:45:32Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClassGenerator.html:5800,load,load,5800,root/html532/TClassGenerator.html,https://root.cern,https://root.cern/root/html532/TClassGenerator.html,4,['load'],['load']
Performance,"j);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TBufferText ();  Default constructor. ;  ;  TBufferText (TBuffer::EMode mode, TObject *parent=nullptr);  Normal constructor. ;  ;  Protected Member Functions inherited from TBufferIO;  TBufferIO ();  ;  TBufferIO (TBuffer::EMode mode);  constructor ;  ;  TBufferIO (TBuffer::EMode mode, Int_t bufsiz);  constructor ;  ;  TBufferIO (TBuffer::EMode mode, Int_t bufsiz, void *buf, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr);  constructor ;  ; virtual void CheckCount (UInt_t);  ; Long64_t GetObjectTag (const void *obj);  Returns tag for specified object from objects map (if exists) Returns 0 if object not included into objects map. ;  ; virtual void WriteObjectClass (const void *actualObjStart, const TClass *actualClass, Bool_t cacheReuse)=0;  ;  Protected Member Functions inherited from TBuffer;  TBuffer ();  ;  TBuffer (const TBuffer &)=delete;  ; void operator= (const TBuffer &)=delete;  ; Int_t Read (const char *name) override;  Read contents of object with specified name from the current directory. ;  ; Int_t Write (const char *name, Int_t opt, Int_t bufs) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name, Int_t opt, Int_t bufs) override;  Write this object to the current directory. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Attributes; static const char * fgDoubleFmt = ""%.14e"";  ! printf argument for doubles, either ""%f"" or ""%e"" or ""%10f"" and so on ;  ; static const char * fgFloatFmt = ""%e"";  ! printf argument for floats, either ""%f"" or ""%e"" or ""%10f"" and so on ;  ;  Static Protected Attributes inherited from TBufferIO; static Int_t fgMapSize = kMapSize;  Defau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferText.html:29754,cache,cacheReuse,29754,doc/master/classTBufferText.html,https://root.cern,https://root.cern/doc/master/classTBufferText.html,1,['cache'],['cacheReuse']
Performance,"j, and TEventIterTree. ◆ GetNextEvent(). virtual Long64_t TEventIter::GetNextEvent ; (; ). pure virtual . Implemented in TEventIterUnit, TEventIterObj, and TEventIterTree. ◆ GetNextPacket(). virtual Int_t TEventIter::GetNextPacket ; (; Long64_t & ; first, . Long64_t & ; num . ). pure virtual . Implemented in TEventIterUnit, TEventIterObj, and TEventIterTree. ◆ GetPackets(). TList * TEventIter::GetPackets ; (; ). inline . Definition at line 89 of file TEventIter.h. ◆ InvalidatePacket(). void TEventIter::InvalidatePacket ; (; ). virtual . Invalidated the current packet (if any) by setting the TDSetElement::kCorrupted bit. ; Definition at line 133 of file TEventIter.cxx. ◆ IsA(). TClass * TEventIter::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TEventIterUnit, TEventIterObj, and TEventIterTree.; Definition at line 93 of file TEventIter.h. ◆ LoadDir(). Int_t TEventIter::LoadDir ; (; ). protected . Load directory. ; Definition at line 163 of file TEventIter.cxx. ◆ PreProcessEvent(). virtual void TEventIter::PreProcessEvent ; (; Long64_t ; ). inlineprotectedvirtual . Reimplemented in TEventIterTree, and TEventIterObj.; Definition at line 74 of file TEventIter.h. ◆ StopProcess(). void TEventIter::StopProcess ; (; Bool_t ; abort). virtual . Set flag to stop the process. ; Definition at line 141 of file TEventIter.cxx. ◆ Streamer(). void TEventIter::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TEventIterUnit, TEventIterObj, and TEventIterTree. ◆ StreamerNVirtual(). void TEventIter::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 93 of file TEventIter.h. Member Data Documentation. ◆ fCur. Long64_t TEventIter::fCur. protected . Definition at line 64 of file TEventIter.h. ◆ fDir. TDirectory* TEventIter::fDir. protected . Definition at line 56 of file TEventIter.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEventIter.html:14476,Load,Load,14476,doc/master/classTEventIter.html,https://root.cern,https://root.cern/doc/master/classTEventIter.html,1,['Load'],['Load']
Performance,"jCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooListProxy_x; Double_t_z; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMultiVarGaussian.html:40076,cache,cache,40076,root/html528/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html528/RooMultiVarGaussian.html,2,['cache'],['cache']
Performance,"jCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TF1*func; RooListProxylist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooTFnPdfBinding.html:39044,cache,cache,39044,root/html528/RooTFnPdfBinding.html,https://root.cern,https://root.cern/root/html528/RooTFnPdfBinding.html,2,['cache'],['cache']
Performance,"ject && TestBit(kDeleteObject)){; 5029 ReleaseObject();; 5030 }; 5031 ; 5032 //; 5033 // Remember the pointer to the pointer to our object.; 5034 //; 5035 ; 5036 fAddress = (char*) addr;; 5037 if (fAddress != (char*)(&fObject)) {; 5038 fObject = nullptr;; 5039 }; 5040 ResetBit(kDeleteObject);; 5041 SetBit(kAddressSet);; 5042 ; 5043 //; 5044 // Do special stuff if we got called from a MakeClass class.; 5045 // Allow sub-branches to have independently set addresses.; 5046 //; 5047 ; 5048 if (TestBit(kDecomposedObj)) {; 5049 if (fID > -1) {; 5050 // We are *not* a top-level branch.; 5051 if (!info) {; 5052 // No streamer info, give up.; 5053 // FIXME: We should have an error message here.; 5054 fObject = fAddress;; 5055 } else {; 5056 // Compensate for the fact that the i/o routines; 5057 // will add the streamer offset to the address.; 5058 fObject = fAddress - info->TStreamerInfo::GetElementOffset(fID);; 5059 }; 5060 return;; 5061 }; 5062 }; 5063 ; 5064 //; 5065 // Check whether the container type is still the same; 5066 // to support schema evolution; what is written on the file; 5067 // may no longer match the class code which is loaded.; 5068 //; 5069 ; 5070 if (fType == 3) {; 5071 // split TClonesArray, counter/master branch.; 5072 TClass* clm = fClonesClass;; 5073 if (clm) {; 5074 // In case clm derives from an abstract class.; 5075 clm->BuildRealData();; 5076 clm->GetStreamerInfo();; 5077 }; 5078 TClass* newType = GetCurrentClass();; 5079 if (newType && (newType != TClonesArray::Class())) {; 5080 // The data type of the container has changed.; 5081 //; 5082 // Let's check if it is a compatible type:; 5083 bool matched = false;; 5084 if (newType->GetCollectionProxy()) {; 5085 TClass *content = newType->GetCollectionProxy()->GetValueClass();; 5086 if (clm == content) {; 5087 matched = true;; 5088 } else {; 5089 Warning(""SetAddress"", ""The type of %s was changed from TClonesArray to %s but the content do not match (was %s)!"", GetName(), newType->GetName(), GetClone",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:185990,load,loaded,185990,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['load'],['loaded']
Performance,"ject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; THashTable * fTable;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . Private Member Functions;  THashList (const THashList &)=delete;  ; THashList & operator= (const THashList &)=delete;  . Additional Inherited Members;  Public Types inherited from TList; typedef TListIter Iterator_t;  ;  Public Types inherited from TCollection; enum  { kInitCapacity = 16; , kInitHashTableCapacity = 17; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 ));",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:18568,cache,cache,18568,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['cache'],['cache']
Performance,"ject ; Reimplemented from TSystem.; Definition at line 254 of file TWinNTSystem.h. ◆ IsAbsoluteFileName(). Bool_t TWinNTSystem::IsAbsoluteFileName ; (; const char * ; dir). overridevirtual . Return true if dir is an absolute pathname. ; Reimplemented from TSystem.; Definition at line 2500 of file TWinNTSystem.cxx. ◆ IsPathLocal(). Bool_t TWinNTSystem::IsPathLocal ; (; const char * ; path). overridevirtual . Returns TRUE if the url in 'path' points to the local file system. ; This is used to avoid going through the NIC card for local operations. ; Reimplemented from TSystem.; Definition at line 2584 of file TWinNTSystem.cxx. ◆ Link(). int TWinNTSystem::Link ; (; const char * ; from, . const char * ; to . ). overridevirtual . Create a link from file1 to file2. ; Reimplemented from TSystem.; Definition at line 2768 of file TWinNTSystem.cxx. ◆ Load(). int TWinNTSystem::Load ; (; const char * ; module, . const char * ; entry = """", . Bool_t ; system = kFALSE . ). overridevirtual . Load a shared library. ; Returns 0 on successful loading, 1 in case lib was already loaded and -1 in case lib does not exist or in case of error. ; Reimplemented from TSystem.; Definition at line 4141 of file TWinNTSystem.cxx. ◆ LookupSID(). Long_t TWinNTSystem::LookupSID ; (; const char * ; lpszAccountName, . int ; what, . int & ; groupIdx, . int & ; memberIdx . ). private . Take the name and look up a SID so that we can get full domain/user information. ; Definition at line 3310 of file TWinNTSystem.cxx. ◆ MakeDirectory(). int TWinNTSystem::MakeDirectory ; (; const char * ; name). overridevirtual . Make a WinNT file system directory. ; Returns 0 in case of success and -1 if the directory could not be created (either already exists or illegal path name). ; Reimplemented from TSystem.; Definition at line 1913 of file TWinNTSystem.cxx. ◆ mkdir(). int TWinNTSystem::mkdir ; (; const char * ; name, . Bool_t ; recursive = kFALSE . ). overridevirtual . Make a file system directory. ; Returns 0 in case ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:61461,Load,Load,61461,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['Load'],['Load']
Performance,"ject associated with given name and given associated parameters with given values in cache. ; The cache will take ownership_of_object and is indexed under the given name (which does not need to be the name of cacheObject and with given set of dependent parameters with validity for the current values of those parameters. It can be retrieved later by callin retrieveObject() ; Definition at line 71 of file RooExpensiveObjectCache.cxx. ◆ retrieveObject(). const TObject * RooExpensiveObjectCache::retrieveObject ; (; const char * ; name, . TClass * ; tc, . const RooArgSet & ; params . ). Retrieve object from cache that was registered under given name with given parameters, if current parameter values match those that were stored in the registry for this object. ; The return object is owned by the cache instance. ; Definition at line 93 of file RooExpensiveObjectCache.cxx. ◆ setObj(). bool RooExpensiveObjectCache::setObj ; (; Int_t ; uid, . TObject * ; obj . ). Place new payload object in cache element with given unique ID. ; Cache will take ownership of provided object! ; Definition at line 148 of file RooExpensiveObjectCache.cxx. ◆ size(). Int_t RooExpensiveObjectCache::size ; (; ); const. inline . Definition at line 43 of file RooExpensiveObjectCache.h. ◆ Streamer(). void RooExpensiveObjectCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooExpensiveObjectCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 81 of file RooExpensiveObjectCache.h. Member Data Documentation. ◆ _map. std::map<TString,ExpensiveObject*> RooExpensiveObjectCache::_map. protected . Definition at line 78 of file RooExpensiveObjectCache.h. ◆ _nextUID. Int_t RooExpensiveObjectCache::_nextUID = 0. protected . Definition at line 76 of file RooExpensiveObjectCache.h. Libraries for RooExpensiveObjectCache:. [legend]; The documentation for this class was gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:15689,cache,cache,15689,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,1,['cache'],['cache']
Performance,"ject does not exist, it is created ; Note: There are two special version numbers: - 0: Use the class version from the currently loaded class library.; - -1: Assume no class library loaded (emulated class).; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4599 of file TClass.cxx. ◆ GetStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::GetStreamerInfoAbstractEmulated ; (; Int_t ; version = 0); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4709 of file TClass.cxx. ◆ GetStreamerInfoImpl(). TVirtualStreamerInfo * TClass::GetStreamerInfoImpl ; (; Int_t ; version, . Bool_t ; silent . ); const. private . Definition at line 4634 of file TClass.cxx. ◆ GetStreamerInfos(). const TObjArray * TClass::GetStreamerInfos ; (; ); const. inline . Definition at line 492 of file TClass.h. ◆ GetTypeInfo(). const std::type_info * TClass::GetTypeInfo ; (; ); const. inline . Definition at line 496 of file TClass.h. ◆ HasConsistentHashMember(). Bool_t TClass::HasConsistentHashMember ; (; ). inline . Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:92530,load,loaded,92530,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['loaded']
Performance,"ject does not exist, it is created ; Note: There are two special version numbers: - 0: Use the class version from the currently loaded class library.; - -1: Assume no class library loaded (emulated class).; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4666 of file TClass.cxx. ◆ GetStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::GetStreamerInfoAbstractEmulated ; (; Int_t ; version = 0); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4776 of file TClass.cxx. ◆ GetStreamerInfoImpl(). TVirtualStreamerInfo * TClass::GetStreamerInfoImpl ; (; Int_t ; version, . Bool_t ; silent . ); const. private . Definition at line 4701 of file TClass.cxx. ◆ GetStreamerInfos(). const TObjArray * TClass::GetStreamerInfos ; (; ); const. inline . Definition at line 492 of file TClass.h. ◆ GetTypeInfo(). const std::type_info * TClass::GetTypeInfo ; (; ); const. inline . Definition at line 496 of file TClass.h. ◆ HasConsistentHashMember(). Bool_t TClass::HasConsistentHashMember ; (; ). inline . Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:92531,load,loaded,92531,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['loaded']
Performance,ject named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedComps! Owned components; TIterator*_pdfIter! Iterator over PDF list; RooListProxy_pdfListList of component PDFs; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooSetProxy_refCoefNorm! Reference observable set for coefficient interpretation; TNamed*_refCoefRangeName! Reference range name for coefficient interpreation; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegrator,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:44646,cache,cache,44646,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,1,['cache'],['cache']
Performance,"ject obj. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position idx. Returns 0 if idx is out of range. ;  ; TObject * Before (const TObject *obj) const override;  Returns the object before object obj. ;  ; void Clear (Option_t *option) override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Delete all TDataMember object files. ;  ; TObject * FindObject (const char *name) const override;  Specialize FindObject to do search for the a enum just by name or create it if its not already in the list. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; TObject * First () const override;  Return the first object in the list. Returns 0 when list is empty. ;  ; TObjLink * FirstLink () const override;  ; Int_t GetLast () const override;  Returns index of last object in collection. ;  ; TEnum * GetObject (const char *) const override;  Return an object from the list of enums if and only if is has already been loaded in the list. ;  ; TObject ** GetObjectRef (const TObject *obj) const override;  Return address of pointer to obj. ;  ; Int_t GetSize () const override;  Return the capacity of the collection, i.e. ;  ; Int_t IndexOf (const TObject *obj) const override;  Return index of object in collection. ;  ; TClass * IsA () const override;  ; TObject * Last () const override;  Return the last object in the list. Returns 0 when list is empty. ;  ; TObjLink * LastLink () const override;  ; TIterator * MakeIterator (Bool_t dir=kIterForward) const override;  Return a list iterator. ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnumsWithLock.html:2722,load,loaded,2722,doc/master/classTListOfEnumsWithLock.html,https://root.cern,https://root.cern/doc/master/classTListOfEnumsWithLock.html,1,['load'],['loaded']
Performance,"ject of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - rat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:4926,cache,cache,4926,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"ject with name. ;  ; template<class T > ; T * Get (const char *namecycle);  See documentation of TDirectoryFile::Get(const char *namecycle) ;  ; TObject * Get (const char *namecycle) override;  Return pointer to object identified by namecycle. ;  ; Int_t GetBufferSize () const override;  Return the buffer size to create new TKeys. ;  ; const TDatime & GetCreationDate () const;  ; TDirectory * GetDirectory (const char *apath, Bool_t printError=false, const char *funcname=""GetDirectory"") override;  Find a directory named ""apath"". ;  ; TFile * GetFile () const override;  ; TKey * GetKey (const char *name, Short_t cycle=9999) const override;  Return pointer to key with name,cycle. ;  ; TList * GetListOfKeys () const override;  ; const TDatime & GetModificationDate () const;  ; Int_t GetNbytesKeys () const override;  ; Int_t GetNkeys () const override;  ; void * GetObjectChecked (const char *namecycle, const char *classname) override;  See documentation of TDirectoryFile::GetObjectCheck(const char *namecycle, const TClass *cl) ;  ; void * GetObjectChecked (const char *namecycle, const TClass *cl) override;  Return pointer to object identified by namecycle if and only if the actual object is a type suitable to be stored as a pointer to a ""expectedClass"" If expectedClass is null, no check is performed. ;  ; void * GetObjectUnchecked (const char *namecycle) override;  Return pointer to object identified by namecycle. ;  ; Long64_t GetSeekDir () const override;  ; Long64_t GetSeekKeys () const override;  ; Long64_t GetSeekParent () const override;  ; Bool_t IsModified () const override;  ; Bool_t IsWritable () const override;  ; TDirectory * mkdir (const char *name, const char *title="""", Bool_t returnExistingDirectory=kFALSE) override;  Create a sub-directory ""a"" or a hierarchy of sub-directories ""a/b/c/..."". ;  ; TFile * OpenFile (const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t neto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:14729,perform,performed,14729,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,15,['perform'],['performed']
Performance,"ject with name. ;  ; template<class T > ; T * Get (const char *namecycle);  See documentation of TDirectoryFile::Get(const char *namecycle) ;  ; TObject * Get (const char *namecycle) override;  Return pointer to object identified by namecycle. ;  ; Int_t GetBufferSize () const override;  Return the buffer size to create new TKeys. ;  ; const TDatime & GetCreationDate () const;  ; TDirectory * GetDirectory (const char *apath, Bool_t printError=false, const char *funcname=""GetDirectory"") override;  Find a directory named ""apath"". ;  ; TFile * GetFile () const override;  ; TKey * GetKey (const char *name, Short_t cycle=9999) const override;  Return pointer to key with name,cycle. ;  ; TList * GetListOfKeys () const override;  ; const TDatime & GetModificationDate () const;  ; Int_t GetNbytesKeys () const override;  ; Int_t GetNkeys () const override;  ; void * GetObjectChecked (const char *namecycle, const char *classname) override;  See documentation of TDirectoryFile::GetObjectCheck(const char *namecycle, const TClass *cl) ;  ; void * GetObjectChecked (const char *namecycle, const TClass *cl) override;  Return pointer to object identified by namecycle if and only if the actual object is a type suitable to be stored as a pointer to a ""expectedClass"" If expectedClass is null, no check is performed. ;  ; void * GetObjectUnchecked (const char *namecycle) override;  Return pointer to object identified by namecycle. ;  ; Long64_t GetSeekDir () const override;  ; Long64_t GetSeekKeys () const override;  ; Long64_t GetSeekParent () const override;  ; Bool_t IsModified () const override;  ; Bool_t IsWritable () const override;  ; void ls (Option_t *option="""") const override;  List Directory contents. ;  ; TDirectory * mkdir (const char *name, const char *title="""", Bool_t returnExistingDirectory=kFALSE) override;  Create a sub-directory ""a"" or a hierarchy of sub-directories ""a/b/c/..."". ;  ; TFile * OpenFile (const char *name, Option_t *option="""", const char *ftitle="""", Int_t c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace_1_1WSDir.html:4088,perform,performed,4088,doc/master/classRooWorkspace_1_1WSDir.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace_1_1WSDir.html,1,['perform'],['performed']
Performance,"ject with name. ;  ; template<class T > ; T * Get (const char *namecycle);  See documentation of TDirectoryFile::Get(const char *namecycle) ;  ; TObject * Get (const char *namecycle) override;  Return pointer to object identified by namecycle. ;  ; Int_t GetBufferSize () const override;  Return the buffer size to create new TKeys. ;  ; const TDatime & GetCreationDate () const;  ; TDirectory * GetDirectory (const char *apath, Bool_t printError=false, const char *funcname=""GetDirectory"") override;  Find a directory named ""apath"". ;  ; TFile * GetFile () const override;  ; TKey * GetKey (const char *name, Short_t cycle=9999) const override;  Return pointer to key with name,cycle. ;  ; TList * GetListOfKeys () const override;  ; const TDatime & GetModificationDate () const;  ; Int_t GetNbytesKeys () const override;  ; Int_t GetNkeys () const override;  ; void * GetObjectChecked (const char *namecycle, const char *classname) override;  See documentation of TDirectoryFile::GetObjectCheck(const char *namecycle, const TClass *cl) ;  ; void * GetObjectChecked (const char *namecycle, const TClass *cl) override;  Return pointer to object identified by namecycle if and only if the actual object is a type suitable to be stored as a pointer to a ""expectedClass"" If expectedClass is null, no check is performed. ;  ; void * GetObjectUnchecked (const char *namecycle) override;  Return pointer to object identified by namecycle. ;  ; Long64_t GetSeekDir () const override;  ; Long64_t GetSeekKeys () const override;  ; Long64_t GetSeekParent () const override;  ; TClass * IsA () const override;  ; Bool_t IsModified () const override;  ; Bool_t IsWritable () const override;  ; void ls (Option_t *option="""") const override;  List Directory contents. ;  ; TDirectory * mkdir (const char *name, const char *title="""", Bool_t returnExistingDirectory=kFALSE) override;  Create a sub-directory ""a"" or a hierarchy of sub-directories ""a/b/c/..."". ;  ; TFile * OpenFile (const char *name, Option_t *option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDirectoryFile.html:5696,perform,performed,5696,doc/master/classTDirectoryFile.html,https://root.cern,https://root.cern/doc/master/classTDirectoryFile.html,1,['perform'],['performed']
Performance,"ject& hnew) const; -*-*-*-*-*Copy this histogram structure to newth1*-*-*-*-*-*-*-*-*-*-*-*. Note that this function does not copy the list of associated functions.; Use TObject::Clone to make a full copy of an histogram. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the histogram to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*-*-*-*-*-*Compute distance from point px,py to a line*-*-*-*-*-*. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Bool_t Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. The function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1); -*-*-*-*-*-*-*-*-*Divide this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionally; compute binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:62225,Perform,Performs,62225,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,1,['Perform'],['Performs']
Performance,"ject();; 2687 c = base->GetClassPointer();; 2688 if (c) {; 2689 if (cl == c) return c;; 2690 c1 = c->GetBaseClass(cl);; 2691 if (c1) return c1;; 2692 }; 2693 lnk = lnk->Next();; 2694 }; 2695 return nullptr;; 2696}; 2697 ; 2698////////////////////////////////////////////////////////////////////////////////; 2699/// Return data member offset to the base class ""cl"".; 2700/// - Returns -1 in case ""cl"" is not a base class.; 2701/// - Returns -2 if cl is a base class, but we can't find the offset; 2702/// because it's virtual.; 2703/// Takes care of multiple inheritance.; 2704 ; 2705Int_t TClass::GetBaseClassOffsetRecurse(const TClass *cl); 2706{; 2707 // check if class name itself is equal to classname; 2708 if (cl == this) return 0;; 2709 ; 2710 if (!fBase.load()) {; 2711 if (fCanLoadClassInfo) LoadClassInfo();; 2712 // If the information was not provided by the root pcm files and; 2713 // if we can not find the ClassInfo, we have to fall back to the; 2714 // StreamerInfo; 2715 if (!fClassInfo) {; 2716 TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();; 2717 if (!sinfo) return -1;; 2718 TStreamerElement *element;; 2719 Int_t offset = 0;; 2720 ; 2721 TObjArray &elems = *(sinfo->GetElements());; 2722 Int_t size = elems.GetLast()+1;; 2723 for(Int_t i=0; i<size; i++) {; 2724 element = (TStreamerElement*)elems[i];; 2725 if (element->IsBase()) {; 2726 if (element->IsA() == TStreamerBase::Class()) {; 2727 TStreamerBase *base = (TStreamerBase*)element;; 2728 TClass *baseclass = base->GetClassPointer();; 2729 if (!baseclass) return -1;; 2730 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2731 if (subOffset == -2) return -2;; 2732 if (subOffset != -1) return offset+subOffset;; 2733 offset += baseclass->Size();; 2734 } else if (element->IsA() == TStreamerSTL::Class()) {; 2735 TStreamerSTL *base = (TStreamerSTL*)element;; 2736 TClass *baseclass = base->GetClassPointer();; 2737 if (!baseclass) return -1;; 2738 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:101586,load,load,101586,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,"['Load', 'load']","['LoadClassInfo', 'load']"
Performance,"ject();; 2754 c = base->GetClassPointer();; 2755 if (c) {; 2756 if (cl == c) return c;; 2757 c1 = c->GetBaseClass(cl);; 2758 if (c1) return c1;; 2759 }; 2760 lnk = lnk->Next();; 2761 }; 2762 return nullptr;; 2763}; 2764 ; 2765////////////////////////////////////////////////////////////////////////////////; 2766/// Return data member offset to the base class ""cl"".; 2767/// - Returns -1 in case ""cl"" is not a base class.; 2768/// - Returns -2 if cl is a base class, but we can't find the offset; 2769/// because it's virtual.; 2770/// Takes care of multiple inheritance.; 2771 ; 2772Int_t TClass::GetBaseClassOffsetRecurse(const TClass *cl); 2773{; 2774 // check if class name itself is equal to classname; 2775 if (cl == this) return 0;; 2776 ; 2777 if (!fBase.load()) {; 2778 if (fCanLoadClassInfo) LoadClassInfo();; 2779 // If the information was not provided by the root pcm files and; 2780 // if we can not find the ClassInfo, we have to fall back to the; 2781 // StreamerInfo; 2782 if (!fClassInfo) {; 2783 TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();; 2784 if (!sinfo) return -1;; 2785 TStreamerElement *element;; 2786 Int_t offset = 0;; 2787 ; 2788 TObjArray &elems = *(sinfo->GetElements());; 2789 Int_t size = elems.GetLast()+1;; 2790 for(Int_t i=0; i<size; i++) {; 2791 element = (TStreamerElement*)elems[i];; 2792 if (element->IsBase()) {; 2793 if (element->IsA() == TStreamerBase::Class()) {; 2794 TStreamerBase *base = (TStreamerBase*)element;; 2795 TClass *baseclass = base->GetClassPointer();; 2796 if (!baseclass) return -1;; 2797 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2798 if (subOffset == -2) return -2;; 2799 if (subOffset != -1) return offset+subOffset;; 2800 offset += baseclass->Size();; 2801 } else if (element->IsA() == TStreamerSTL::Class()) {; 2802 TStreamerSTL *base = (TStreamerSTL*)element;; 2803 TClass *baseclass = base->GetClassPointer();; 2804 if (!baseclass) return -1;; 2805 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:104337,load,load,104337,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,"['Load', 'load']","['LoadClassInfo', 'load']"
Performance,"ject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetCache(); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXNetFile.html:12320,cache,cacheDir,12320,root/html530/TXNetFile.html,https://root.cern,https://root.cern/root/html530/TXNetFile.html,1,['cache'],['cacheDir']
Performance,"ject. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for TTimeOutTimer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TTimeOutTimer(). TTimeOutTimer::TTimeOutTimer ; (; TMonitor * ; m, . Long_t ; ms . ). Definition at line 85 of file TMonitor.cxx. Member Function Documentation. ◆ Notify(). Bool_t TTimeOutTimer::Notify ; (; ). overridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Implements TSysEvtHandler.; Definition at line 93 of file TMonitor.cxx. Member Data Documentation. ◆ fMonitor. TMonitor* TTimeOutTimer::fMonitor. private . Definition at line 78 of file TMonitor.cxx. net/net/src/TMonitor.cxx. TTimeOutTimer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:37 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimeOutTimer.html:17836,load,load,17836,doc/master/classTTimeOutTimer.html,https://root.cern,https://root.cern/doc/master/classTTimeOutTimer.html,2,['load'],['load']
Performance,"ject. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Protected Member Functions; double evaluatePartition (std::size_t firstEvent, std::size_t lastEvent, std::size_t stepSize) const override;  Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize Throughout the calculation, we use Kahan's algorithm for summing to prevent loss of precision - this is a factor four more expensive than straight addition, but since evaluating the PDF is usually much more expensive than that, we tolerate the additional cost... ;  ;  Protected Member Functions inherited from RooAbsOptTestStatistic; virtual bool allowFunctionCache ();  ; void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true) override;  Driver function to propagate constant term optimizations in test statistic. ;  ; void initSlave (RooAbsReal &real, RooAbsData &indata, const RooArgSet &projDeps, const char *rangeName, const char *addCoefRangeName);  ; void optimizeCaching ();  This method changes the value caching logic for all nodes that depends on any of the observables as defined by the given dataset. ;  ; void optimizeConstantTerms (bool, bool=true);  Driver function to activate global constant term optimization. ;  ; void printCompactTreeHook (std::ostream &os, const char *indent="""") override;  Catch print hook function and forward to function clone. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursive) override;  Catch server redirect calls and forward to internal clone of function. ;  ; virtual RooArgSet requiredExtraObservables () const;  ; void runRecalculateCache (std::size",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:50489,optimiz,optimizations,50489,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['optimiz'],['optimizations']
Performance,"ject. Called via the TProof ctor. ; Definition at line 45 of file TSlave.cxx. ◆ TSlave() [3/3]. TSlave::TSlave ; (; ). protected . Default constructor used by derived classes. ; Definition at line 65 of file TSlave.cxx. ◆ ~TSlave(). TSlave::~TSlave ; (; ). override . Destroy slave. ; Definition at line 268 of file TSlave.cxx. Member Function Documentation. ◆ Class(). static TClass * TSlave::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSlave::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSlave::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 167 of file TSlave.h. ◆ Close(). void TSlave::Close ; (; Option_t * ; opt = """"). virtual . Close slave socket. ; Reimplemented in TSlaveLite.; Definition at line 276 of file TSlave.cxx. ◆ Compare(). Int_t TSlave::Compare ; (; const TObject * ; obj); const. overridevirtual . Used to sort slaves by performance index. ; Reimplemented from TObject.; Definition at line 309 of file TSlave.cxx. ◆ Create(). TSlave * TSlave::Create ; (; const char * ; url, . const char * ; ord, . Int_t ; perf, . const char * ; image, . TProof * ; proof, . Int_t ; stype, . const char * ; workdir, . const char * ; msd, . Int_t ; nwk = 1 . ). staticprivate . Static method returning the appropriate TSlave object for the remote server. ; Definition at line 441 of file TSlave.cxx. ◆ DeclFileName(). static const char * TSlave::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 167 of file TSlave.h. ◆ FlushSocket(). virtual void TSlave::FlushSocket ; (; ). inlineprotectedvirtual . Definition at line 105 of file TSlave.h. ◆ GetArchCompiler(). const char * TSlave::GetArchCompiler ; (; ); const. inline . Definition at line 147 of file TSlave.h. ◆ GetBytesRead(). Long64_t TSlave::GetBytesRead ; (; ); const. inline . Definition at line 136 of file TSl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlave.html:15887,perform,performance,15887,doc/master/classTSlave.html,https://root.cern,https://root.cern/doc/master/classTSlave.html,1,['perform'],['performance']
Performance,"ject. It might be emulated; 1778 // or interpreted; we now have more information available.; 1779 // Make that available.; 1780 if (existingCl->GetState() != TClass::kHasTClassInit) {; 1781 DictFuncPtr_t dict = gClassTable->GetDict(proto->GetName());; 1782 if (!dict) {; 1783 ::Error(""TCling::LoadPCM"", ""Inconsistent TClassTable for %s"", proto->GetName());; 1784 } else {; 1785 // This will replace the existing TClass.; 1786 TClass *ncl = (*dict)();; 1787 if (ncl); 1788 ncl->PostLoadCheck();; 1789 }; 1790 }; 1791 }; 1792 }; 1793 ; 1794 protoClasses->Clear(); // Ownership was transfered to TClassTable.; 1795 delete protoClasses;; 1796 }; 1797 ; 1798 TObjArray *dataTypes;; 1799 pcmFile.GetObject(""__Typedefs"", dataTypes);; 1800 if (dataTypes) {; 1801 for (auto typedf : *dataTypes); 1802 gROOT->GetListOfTypes()->Add(typedf);; 1803 dataTypes->Clear(); // Ownership was transfered to TListOfTypes.; 1804 delete dataTypes;; 1805 }; 1806}; 1807 ; 1808////////////////////////////////////////////////////////////////////////////////; 1809/// Tries to load a rdict PCM, issues diagnostics if it fails.; 1810 ; 1811void TCling::LoadPCM(std::string pcmFileNameFullPath); 1812{; 1813 SuspendAutoLoadingRAII autoloadOff(this);; 1814 SuspendAutoParsing autoparseOff(this);; 1815 assert(!pcmFileNameFullPath.empty());; 1816 assert(llvm::sys::path::is_absolute(pcmFileNameFullPath));; 1817 ; 1818 // Easier to work with the ROOT interfaces.; 1819 TString pcmFileName = pcmFileNameFullPath;; 1820 ; 1821 // Prevent the ROOT-PCMs hitting this during auto-load during; 1822 // JITting - which will cause recursive compilation.; 1823 // Avoid to call the plugin manager at all.; 1824 R__InitStreamerInfoFactory();; 1825 ; 1826 TDirectory::TContext ctxt;; 1827 llvm::SaveAndRestore<Int_t> SaveGDebug(gDebug);; 1828 if (gDebug > 5) {; 1829 gDebug -= 5;; 1830 ::Info(""TCling::LoadPCM"", ""Loading ROOT PCM %s"", pcmFileName.Data());; 1831 } else {; 1832 gDebug = 0;; 1833 }; 1834 ; 1835 if (llvm::sys::fs::is_symlink_f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:67998,load,load,67998,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance,"ject. ←; TSlave. ←. TSlaveLite. TXSlave. Function documentation; TSlave(const char* host, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t = 1); Create a PROOF slave object. Called via the TProof ctor. TSlave(); Default constructor used by derived classes. void Init(const char* host, Int_t port, Int_t stype); Init a PROOF slave object. Called via the TSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. Int_t SetupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. void Init(TSocket* s, Int_t stype); Init a PROOF slave object using the connection opened via s. Used to; avoid double opening when an attempt via TXSlave found a remote proofd. ~TSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t nwk = 1); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSlave.html:10060,perform,performance,10060,root/html602/TSlave.html,https://root.cern,https://root.cern/root/html602/TSlave.html,2,['perform'],['performance']
Performance,"ject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBitsROOT::v5::TFormula::fAlreadyFound! cache for information; Double_t*ROOT::v5::TFormula::fConst[fNconst] Array of fNconst formula constants; TString*ROOT::v5::TFormula::fExpr[fNoper] List of expressions; TString*ROOT::v5::TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tROOT::v5::TFormula::fNconstNumber of constants; Int_tROOT::v5::TFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); ROOT::v5::TFormula::TFuncGROOT::v5::TFormula::fOptimal!pointer to optimal function; Double_t*ROOT::v5::TFormula::fParams[fNpar] Array of fNp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__v5__TF1Data.html:13721,cache,cache,13721,root/html604/ROOT__v5__TF1Data.html,https://root.cern,https://root.cern/root/html604/ROOT__v5__TF1Data.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,ject::(anonymous)TObject::kSingleKey; static TGLCamera::EFrustumPlaneTGLCamera::kTop; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBasetranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTranstransformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenterdefault camera center; Double_tTGLCamera::fDollyDefaultdefault distnce from viewing centre; Double_tTGLCamera::fDollyDistanceunit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenterexternal camera center; Bool_tTGLCamera::fExternalCenteruse external center insead of scene center; TGLVector3TGLCamera::fFDCenterfixed default camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenteruse fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngleminimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); Bool_tTGLCamera::fWasArcBalledset when arc-ball rotation is used; static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfFOV; static Double_tfgFOVDefault; static UInt_tfgFOVDeltaSens; static Double_tfgFOVMax; static Double_tfgFOVMin. Class Charts. Inheritance; Inherited Members; Includes; Lib,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPerspectiveCamera.html:10363,cache,cached,10363,root/html602/TGLPerspectiveCamera.html,https://root.cern,https://root.cern/root/html602/TGLPerspectiveCamera.html,12,['cache'],['cached']
Performance,"ject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); Int_tCopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0, TList* wrks = 0); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); Int_tCreateSymLinks(TList* files, TList* wrks = 0); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*TProof::GetEnabledPackages() const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); TProofQueryResult*MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); voidTObject::MakeZombie(); virtual Int_tPollForNewWorkers(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofLite.html:21164,cache,cachedir,21164,root/html604/TProofLite.html,https://root.cern,https://root.cern/root/html604/TProofLite.html,1,['cache'],['cachedir']
Performance,"ject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE) const; voidgetCompIntList(const RooArgSet* nset, const RooArgSet* iset, RooAddModel::pRooArgList& compIntList, Int_t& code, const char* isetRangeName) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAddModel::CacheElem*getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddModel.html:33563,Cache,CacheElem,33563,root/html532/RooAddModel.html,https://root.cern,https://root.cern/root/html532/RooAddModel.html,1,['Cache'],['CacheElem']
Performance,"ject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TVirtualFitter&operator=(const TVirtualFitter& tvf). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tfCacheSizeSize of the fCache array; voidfFCN; TMethodCall*fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tfNpointsNumber of points to fit; TObject*fObjectFitpointer to object being fitted; Foption_tfOptionstruct with the fit options; Int_tfPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*fUserFuncpointer to user theoretical function (a TF1*); Int_tfXfirstfirst bin on X axis; Int_tfXlastlast bin on X axis; Int_tfYfirstfirst bin on Y axis; Int_tfYlastlast bin on Y axis; Int_tfZfirstfirst bin on Z axis; Int_tfZlastlast bin on Z axis; static TStringfgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tfgErrorDefError definition (default=1); static TVirtualFitter*fgFitterCurrent fitter (default TFitter); static Int_tfgMaxiterMaximum number of iterations; static Int_tfgMaxparMaximum number of fit parameters for current fitter; static Double_tfgPrecisionmaximum precision. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualFitter& operator=(const TVirtualFitter& tvf); assignment operator. ~TVirtualFitter(); Cleanup virtual fitter. TVirtualFitter * Fitter(TObject* obj, Int_t maxpar = 25); Static function returning a pointer to the current fitter.; If the fitter does not exist, the default TFitter is created.; Don't delete the returned fitter object, it will be re-used",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualFitter.html:8613,cache,cache,8613,root/html528/TVirtualFitter.html,https://root.cern,https://root.cern/root/html528/TVirtualFitter.html,4,['cache'],['cache']
Performance,"ject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModeTBuffer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creates buffer object to serialize data into json. ~TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBufferJSON.html:19490,cache,cache,19490,root/html602/TBufferJSON.html,https://root.cern,https://root.cern/root/html602/TBufferJSON.html,1,['cache'],['cache']
Performance,"ject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModeTBuffer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TBufferJSON.html:19632,cache,cache,19632,root/html604/TBufferJSON.html,https://root.cern,https://root.cern/root/html604/TBufferJSON.html,1,['cache'],['cache']
Performance,"ject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TDictionary::ESTLTypeTDictionary::kSet; static TObject::(anonymous)TObject::kSingleKey; static TDictionary::ESTLTypeTDictionary::kVector; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TClass*fClasspointer to the class (if any).; FuncTempInfo_t*fInfopointer to Interpreter function template info; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunctionTemplate(FuncTempInfo_t* info, TClass* cl); Default TFunctionTemplate ctor. TFunctionTemplate(const TFunctionTemplate& orig); Copy operator. TFunctionTemplate& operator=(const TFunctionTemplate& rhs); Assignment operator. ~TFunctionTemplate(); TFunctionTemplate dtor deletes adopted CINT FuncTempInfo. TObject * Clone(const char* newname = """") const; Clone method. Bool_t IsValid(); Return true if this function template object is pointing to a currently; loaded function. If a function is unloaded after the TFunction; is created, the TFunction will be set to be invalid. UInt_t GetTemplateNargs() const; Number of function arguments. UInt_t GetTemplateMinReqArgs() const; Number of function optional (default) arguments. Long_t Property() const; Get property description word. For meaning of bits see EProperty. TDictionary::DeclId_t GetDeclId() const. Bool_t Update(FuncTempInfo_t* info); Update the TFunctionTemplate to reflect the new info. This can be used to implement unloading (info == 0) and then reloading; (info being the 'new' decl address). » Author: Philippe Canal November 2013. » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta: » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFunctionTemplate.html:7670,load,loaded,7670,root/html602/TFunctionTemplate.html,https://root.cern,https://root.cern/root/html602/TFunctionTemplate.html,1,['load'],['loaded']
Performance,"ject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TProofChain::(anonymous)kOwnsChain; static TChain::(anonymous)TChain::kProofLite; static TChain::(anonymous)TChain::kProofUptodate; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Bool_tTChain::fCanDeleteRefs! If true, TProcessIDs are deleted when closing a file; TChain*fChainmother chain: needed for the browsing list; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofChain.html:24723,cache,cache,24723,root/html602/TProofChain.html,https://root.cern,https://root.cern/root/html602/TProofChain.html,2,['cache'],['cache']
Performance,"ject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tLoadBaskets(Long64_t maxmemory); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); voidLookup(Bool_t force = kFALSE); virtual voidLoop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tMerge(const char* name, Option_t* option = """"); virtual Long64_tMerge(TCollection* list, Option_t* option = """"); virtual Long64_tMerge(TFile* file, Int_t basketsize, Option_t* option = """"); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTTree::OptimizeBaskets(Int_t maxMemory = 10000000, Float_t minComp = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:11975,Optimiz,OptimizeBaskets,11975,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,2,['Optimiz'],['OptimizeBaskets']
Performance,"ject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTChain::LoadBaskets(Long64_t maxmemory); virtual Long64_tTChain::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); voidTChain::Lookup(Bool_t force = kFALSE); virtual voidTChain::Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTChain::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTChain::Merge(const char* name, Option_t* option = """"); virtual Long64_tTChain::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTChain::Merge(TCollection* list, TFileMergeInfo* info); virtual Long64_tTChain::Merge(TFile* file, Int_t basketsize, Option_t* option = """"); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofChain&operator=(const TProofChain&); virtual voidTTree::OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofChain.html:13057,Optimiz,OptimizeBaskets,13057,root/html602/TProofChain.html,https://root.cern,https://root.cern/root/html602/TProofChain.html,2,['Optimiz'],['OptimizeBaskets']
Performance,"ject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooAbsReal&pdf() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvolution.html:20033,optimiz,optimizeCacheMode,20033,root/html526/RooNumConvolution.html,https://root.cern,https://root.cern/root/html526/RooNumConvolution.html,2,['optimiz'],['optimizeCacheMode']
Performance,"ject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExpensiveObjectCache&operator=(const RooExpensiveObjectCache&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); voidprint() const; virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); voidTObject::ResetBit(UInt_t f); const TObject*retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); RooExpensiveObjectCache(); RooExpensiveObjectCache(const RooExpensiveObjectCache&); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tsetObj(Int_t uniqueID, TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; Int_tsize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExpensiveObjectCache.html:4392,cache,cacheObject,4392,root/html602/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html602/RooExpensiveObjectCache.html,2,['cache'],['cacheObject']
Performance,"ject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgusBG.html:28947,cache,cache,28947,root/html534/RooArgusBG.html,https://root.cern,https://root.cern/root/html534/RooArgusBG.html,163,['cache'],['cache']
Performance,"ject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetOptions(TString options); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:29247,cache,cache,29247,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,3,['cache'],['cache']
Performance,"ject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidsetNoRounding(bool flag = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooPoisson.html:28791,cache,cache,28791,root/html534/RooPoisson.html,https://root.cern,https://root.cern/root/html534/RooPoisson.html,3,['cache'],['cache']
Performance,"ject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidsetOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetProhibitServerRedirect(Bool_t flag); voidsetShapeDirty() const; voidsetStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetValueDirty() const; TIterator*shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&transientAttributes() const; voidtreeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidunRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*valueClientIterator() const; static voidverboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:13373,cache,cache,13373,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,1,['cache'],['cache']
Performance,"ject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidSetTestSignalEfficiency(Double_t effS); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCuts.html:14699,tune,tuneParameters,14699,root/html602/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCuts.html,2,['tune'],['tuneParameters']
Performance,"ject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidSetTestSignalEfficiency(Double_t effS); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodCuts.html:13940,tune,tuneParameters,13940,root/html534/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodCuts.html,1,['tune'],['tuneParameters']
Performance,"ject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidTMVA::MethodANNBase::SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodMLP.html:11593,tune,tuneParameters,11593,root/html528/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html,1,['tune'],['tuneParameters']
Performance,"ject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:15072,cache,cache,15072,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,1,['cache'],['cache']
Performance,"ject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(const char* rangeName, const char* stateNameList); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tRooAbsCategoryLValue::volume(const char* rangeName) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCategory.html:16785,cache,cache,16785,root/html532/RooCategory.html,https://root.cern,https://root.cern/root/html532/RooCategory.html,1,['cache'],['cache']
Performance,"ject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual~TClassGenerator(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TClassGenerator(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClassGenerator(); { }. virtual ~TClassGenerator(); { }. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load). » Author: Philippe Canal 24/06/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 13:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClassGenerator.html:6344,load,load,6344,root/html602/TClassGenerator.html,https://root.cern,https://root.cern/root/html602/TClassGenerator.html,4,['load'],['load']
Performance,"ject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual~TClassGenerator(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TClassGenerator(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClassGenerator(); { }. virtual ~TClassGenerator(); { }. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load). » Author: Philippe Canal 24/06/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClassGenerator.html:6344,load,load,6344,root/html604/TClassGenerator.html,https://root.cern,https://root.cern/root/html604/TClassGenerator.html,4,['load'],['load']
Performance,ject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TFormula::(anonymous)TFormula::kLinear; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TFormula::(anonymous)TFormula::kNormalized; static TObject::(anonymous)TObject::kNotDeleted; static TF1::(anonymous)TF1::kNotDraw; static TFormula::(anonymous)TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tTF1::fChisquareFunction fit chisquare; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TArrayDTF2::fContourArray to display contour levels; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF3.html:22799,cache,cache,22799,root/html602/TF3.html,https://root.cern,https://root.cern/root/html602/TF3.html,1,['cache'],['cache']
Performance,ject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TFormula::(anonymous)TFormula::kLinear; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TFormula::(anonymous)TFormula::kNormalized; static TObject::(anonymous)TObject::kNotDeleted; static TF1::(anonymous)TF1::kNotDraw; static TFormula::(anonymous)TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tTF1::fChisquareFunction fit chisquare; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TArrayDfContourArray to display contour levels; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is l,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF2.html:20460,cache,cache,20460,root/html602/TF2.html,https://root.cern,https://root.cern/root/html602/TF2.html,1,['cache'],['cache']
Performance,"ject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TFormula::(anonymous)TFormula::kLinear; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TFormula::(anonymous)TFormula::kNormalized; static TObject::(anonymous)TObject::kNotDeleted; static TF1::(anonymous)TF1::kNotDraw; static TFormula::(anonymous)TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Int_tfCaseprojection along X(0), or Y(1); Double_tTF1::fChisquareFunction fit chisquare; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TF2*fF2pointer to the mother TF2; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF12.html:18733,cache,cache,18733,root/html602/TF12.html,https://root.cern,https://root.cern/root/html602/TF12.html,1,['cache'],['cache']
Performance,"ject::kZombie. protected:. TVectorDfCloIndex; TVectorDfCupIndex; TVectorDfDdtemporary storage vectors; TVectorDfDq; TQpProbBase*fFactory; Int_tfMclo; Int_tfMcup; Int_tfMy; Int_tfMz; TVectorDfNomegaInvstores a critical diagonal matrix as a vector; Int_tfNxdimensions of the vectors in the general QP formulation; Int_tfNxlo; Int_tfNxupdimensions of the upper and lower bound vectors; TVectorDfRhsright-hand side of the system; TVectorDfXloIndex; TVectorDfXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance Chart:. TObject. ←; TQpLinSolverBase. ←. TQpLinSolverDens. TQpLinSolverSparse. Function documentation; TQpLinSolverBase(); Default constructor. TQpLinSolverBase(TQpProbBase* factory, TQpDataBase* data); Constructor. TQpLinSolverBase(const TQpLinSolverBase& another); Copy constructor. void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. The; actual factorization is performed by a routine specific to either the sparse; or dense case. void ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); Computes the diagonal matrices in the augmented system from the current set of variables. void Solve(TQpDataBase* prob, TQpVar* vars, TQpResidual* resids, TQpVar* step); Solves the system for a given set of residuals. Assembles the right-hand side appropriate; to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQpLinSolverBase.html:7602,perform,performed,7602,root/html602/TQpLinSolverBase.html,https://root.cern,https://root.cern/root/html602/TQpLinSolverBase.html,2,['perform'],['performed']
Performance,"ject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TDirectory; static Bool_t Cd1 (const char *path);  Change current directory to ""path"". ;  ; static SharedGDirectory_t & GetSharedLocalCurrentDirectory ();  Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  ;  Static Protected Attributes inherited from TWebFile; static Long64_t fgMaxFullCacheSize = 500000000;  ; static TUrl fgProxy;  size of the cached content ;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:46151,cache,cache,46151,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,2,['cache'],"['cache', 'cached']"
Performance,"ject; kDangerous enum valueTInterpreter; kFatal enum valueTInterpreter; kHasUUID enum valueTObject; kInconsistent enum valueTObject; kInvalidObject enum valueTObject; kIsOnHeap enum valueTObject; kIsReferenced enum valueTObject; kKnown enum valueTInterpreter; kMustCleanup enum valueTObject; kNoContextMenu enum valueTObject; kNoError enum valueTInterpreter; kNotDeleted enum valueTObject; kObjInCanvas enum valueTObject; kOnlyPrepStep enum valueTObjectprotected; kOverwrite enum valueTObject; kProcessing enum valueTInterpreter; kRecoverable enum valueTInterpreter; kSingleKey enum valueTObject; kUnknown enum valueTInterpreter; kWithClassDefInline enum valueTInterpreter; kWriteDelete enum valueTObject; kZombie enum valueTObject; Load(const char *filenam, Bool_t system=kFALSE)=0TInterpreterpure virtual; LoadEnums(TListOfEnums &cl) const =0TInterpreterpure virtual; LoadFile(const char *) constTInterpreterinlinevirtual; LoadFunctionTemplates(TClass *cl) const =0TInterpreterpure virtual; LoadLibraryMap(const char *rootmapfile=nullptr)=0TInterpreterpure virtual; LoadMacro(const char *filename, EErrorCode *error=nullptr)=0TInterpreterpure virtual; LoadText(const char *) constTInterpreterinlinevirtual; ls(Option_t *option="""") const overrideTNamedvirtual; MakeInterpreterValue() constTInterpreterinlinevirtual; MakeZombie()TObjectinlineprotected; MapCppName(const char *) constTInterpreterinlinevirtual; MayNotUse(const char *method) constTObject; MembersMap_t typedefTInterpreter; MethodArgInfo_DefaultValue(MethodArgInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_Delete(MethodArgInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_Factory() constTInterpreterinlinevirtual; MethodArgInfo_Factory(MethodInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_FactoryCopy(MethodArgInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_IsValid(MethodArgInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_Name(MethodArgInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_Nex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter-members.html:20932,Load,LoadLibraryMap,20932,doc/master/classTInterpreter-members.html,https://root.cern,https://root.cern/doc/master/classTInterpreter-members.html,1,['Load'],['LoadLibraryMap']
Performance,"jectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; BasketInfo & GetBasketInfo (size_t bi, size_t basketNumber);  Return the BasketInfo corresponding to the given branch and basket. ;  ; BasketInfo & GetBasketInfo (TBranch *b, size_t basketNumber);  Return the BasketInfo corresponding to the given branch and basket. ;  ; void SetFile (TFile *newfile) override;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::vector< std::vector< BasketInfo > > fBasketsInfo;  ; std::unordered_map< TBranch *, size_t > fBranchIndexCache;  ; Long64_t fBytesRead;  Number of bytes read. ;  ; Long64_t fBytesReadExtra;  Number of bytes (overhead) of the read-ahead cache. ;  ; Double_t fCompress;  Tree compression factor. ;  ; Double_t fCpuTime;  Cpu time. ;  ; Double_t fDiskTime;  Time spent in pure raw disk IO. ;  ; TFile * fFile;  ! Pointer to the file containing the Tree ;  ; TGraphErrors * fGraphIO;  Pointer to the graph with IO data. ;  ; TGraphErrors * fGraphTime;  Pointer to the graph with timestamp info. ;  ; TString fHostInfo;  Name of the host system, ROOT version and date. ;  ; TText * fHostInfoText;  Graphics Text object with the fHostInfo data. ;  ; TString fName;  Name of this TTreePerfStats. ;  ; Int_t fNleaves;  Number of leaves in the tree. ;  ; TPaveText * fPave;  Pointer to annotation pavetext. ;  ; Int_t fReadaheadSize;  Read-ahead cache size. ;  ; Int_t fReadCalls;  Number of read calls. ;  ; Double_t fRealNorm;  Real time scale factor for fGraphTime. ;  ; Double_t fRealTime;  Real time. ;  ; TGaxis * fRealTimeAxis;  Pointer to TGaxis object showing real-time. ;  ; TTree * fTree;  ! Pointe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePerfStats.html:17769,cache,cache,17769,doc/master/classTTreePerfStats.html,https://root.cern,https://root.cern/doc/master/classTTreePerfStats.html,1,['cache'],['cache']
Performance,"jectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; typedef std::vector< TStreamerInfo * > InfoList_t;  ;  Protected Types inherited from TBufferIO; enum  { kNullTag = 0; };  ;  Protected Types inherited from TBuffer; typedef std::vector< TVirtualArray * > CacheList_t;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TBufferFile ();  ;  TBufferFile (const TBufferFile &)=delete;  not implemented ;  ; Int_t CheckByteCount (UInt_t startpos, UInt_t bcnt, const TClass *clss, const char *classname);  Check byte count with current buffer position. ;  ; void CheckCount (UInt_t offset) override;  Check if offset is not too large (< kMaxMapCount) when writing. ;  ; UInt_t CheckObject (UInt_t offset, const TClass *cl, Bool_t readClass=kFALSE);  Check for object in the read map. ;  ; void operator= (const TBufferFile &)=delete;  not implemented ;  ; void WriteObjectClass (const void *actualObjStart, const TClass *actualClass, Bool_t cacheReuse) override;  Write object to I/O buffer. ;  ;  Protected Member Functions inherited from TBufferIO;  TBufferIO ();  ;  TBufferIO (TBuffer::EMode mode);  constructor ;  ;  TBufferIO (TBuffer::EMode mode, Int_t bufsiz);  constructor ;  ;  TBufferIO (TBuffer::EMode mode, Int_t bufsiz, void *buf, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr);  constructor ;  ; Long64_t GetObjectTag (const void *obj);  Returns tag for specified object from objects map (if exists) Returns 0 if object not included into objects map. ;  ;  Protected Member Functions inherited from TBuffer;  TBuffer ();  ;  TBuffer (const TBuffer &)=delete;  ; void operator= (const TBuffer &)=delete;  ; Int_t Read (const char *name) override;  Read contents of object with specified name from the current directory. ;  ; Int_t Write (const char *name, Int_t opt, Int_t bufs) const override;  Write this object to the current directory. ;  ; Int_t Write (cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:34967,cache,cacheReuse,34967,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['cache'],['cacheReuse']
Performance,"jected ""as is"" in the interpreter. The value of 'triggerFunc' is used to find the shared library location. ; Implements TInterpreter.; Definition at line 2010 of file TCling.cxx. ◆ RegisterPrebuiltModulePath(). bool TCling::RegisterPrebuiltModulePath ; (; const std::string & ; FullPath, . const std::string & ; ModuleMapName = ""module.modulemap"" . ); const. finalvirtual . Returnstrue if the module map was loaded, false on error or if the map was already loaded. ; Implements TInterpreter.; Definition at line 1906 of file TCling.cxx. ◆ RegisterRdictForLoadPCM(). void TCling::RegisterRdictForLoadPCM ; (; const std::string & ; pcmFileNameFullPath, . llvm::StringRef * ; pcmContent . ). private . Register Rdict data for future loading by LoadPCM;. ; Definition at line 1678 of file TCling.cxx. ◆ RegisterTClassUpdate(). void TCling::RegisterTClassUpdate ; (; TClass * ; oldcl, . DictFuncPtr_t ; dict . ). finalvirtual . Register classes that already existed prior to their dictionary loading and that already had a ClassInfo (and thus would not be refresh via UpdateClassInfo. ; Implements TInterpreter.; Definition at line 2384 of file TCling.cxx. ◆ RegisterTemporary() [1/2]. void TCling::RegisterTemporary ; (; const cling::Value & ; value). Register value as a temporary, extending its lifetime to that of the interpreter. ; This is needed for TCling's compatibility interfaces returning long - the address of the temporary objects. As such, ""simple"" types don't need to be stored; they are returned by value; only pointers / references / objects need to be stored. ; Definition at line 7701 of file TCling.cxx. ◆ RegisterTemporary() [2/2]. void TCling::RegisterTemporary ; (; const TInterpreterValue & ; value). Definition at line 7687 of file TCling.cxx. ◆ ReloadAllSharedLibraryMaps(). Int_t TCling::ReloadAllSharedLibraryMaps ; (; ). finalvirtual . Reload the library map entries coming from all the loaded shared libraries, after first unloading the current ones. ; In case of error -1 is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:126180,load,loading,126180,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['loading']
Performance,"jection; configurations can be cached. ; . Function Members (Methods); public:. virtual~RooCacheManager<vector<double,allocator<double> > >(); Int_tcacheSize() const; static TClass*Class(); virtual voidRooAbsCache::findConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); vector<double,allocator<double> >*getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); vector<double,allocator<double> >*getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); vector<double,allocator<double> >*getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(vector<double,allocator<double> >&); virtual TClass*IsA() const; Int_tlastIndex() const; const RooNameSet*nameSet1ByIndex(Int_t index) const; const RooNameSet*nameSet2ByIndex(Int_t index) const; RooCacheManager<vector<double,allocator<double> > >&operator=(const RooCacheManager<vector<double,allocator<double> > >&); virtual voidoperModeHook(); virtual voidRooAbsCache::optimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); RooCacheManager<vector<double,allocator<double> > >(Int_t maxSize = 10); RooCacheManager<vector<double,allocator<double> > >(RooAbsArg* owner, Int_t maxSize = 10); RooCacheManager<vector<double,allocator<double> > >(const RooCacheManager<vector<double,allocator<double> > >& other, RooAbsArg* owner = 0); Int_tsetObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); virtual voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_t_lastIndexLast slot accessed; Int_t_maxSizeMaxi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCacheManager_vector_double___.html:2136,optimiz,optimizeCacheMode,2136,root/html530/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html530/RooCacheManager_vector_double___.html,2,['optimiz'],['optimizeCacheMode']
Performance,"jects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Calculate the raw value of the function which is the effFunc value if cat==1 and it is (1-effFunc) if cat==0. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiBinomial.html:48818,cache,cached,48818,doc/master/classRooMultiBinomial.html,https://root.cern,https://root.cern/doc/master/classRooMultiBinomial.html,2,['cache'],"['cache', 'cached']"
Performance,"jects returned by func.; Examples:; root[] ROOT::TThreadExecutor pool; auto hists = pool.Map(CreateHisto, 10);; root[] ROOT::TThreadExecutor pool(2); auto squares = pool.Map([](int a) { return a*a; }, {1,2,3});; a#define a(i)Definition RSha256.hxx:99; ROOT::TThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel threads,...Definition TThreadExecutor.hxx:41; ROOT::TThreadExecutor::Mapauto Map(F func, unsigned nTimes, R redfunc, unsigned nChunks) -> std::vector< InvokeResult_t< F > >Execute a function nTimes in parallel, dividing the execution in nChunks and providing a result per c...Definition TThreadExecutor.hxx:289. ROOT::TThreadExecutor::MapReduce; This set of methods behaves exactly like Map, but takes an additional function as a third argument. This function is applied to the set of objects returned by the corresponding Map execution to ""squash"" them into a single object. This function should be independent of the size of the vector returned by Map due to optimization of the number of chunks.; If this function is a binary operator, the ""squashing"" will be performed in parallel. This is exclusive to ROOT::TThreadExecutor and not any other ROOT::TExecutorCRTP-derived classes.; An integer can be passed as the fourth argument indicating the number of chunks we want to divide our work in. This may be useful to avoid the overhead introduced when running really short tasks.; Examples:; root[] ROOT::TThreadExecutor pool; auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int> &v) { return std::accumulate(v.begin(), v.end(), 0); }); root[] ROOT::TThreadExecutor pool; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; ROOT::ExecutorUtils::ReduceObjectsMerge collection of TObjects.Definition PoolUtils.h:35; ROOT::TThreadExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc) -> InvokeResult_t< F >Execute a function nTimes in parallel (Map) and accumulate the resu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html:3218,optimiz,optimization,3218,doc/v632/classROOT_1_1TThreadExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html,2,['optimiz'],['optimization']
Performance,"jects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_nset! Normalization set to be passed along to contents; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFormulaVar(const char* name, const char* title, const char* formula, const RooArgList& dependents); Constructor wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormulaVar.html:35678,cache,cache,35678,root/html534/RooFormulaVar.html,https://root.cern,https://root.cern/root/html534/RooFormulaVar.html,2,['cache'],['cache']
Performance,"jects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:35660,Perform,Perform,35660,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,2,['Perform'],['Perform']
Performance,"jects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealIntegral.html:36495,Perform,Perform,36495,root/html530/RooRealIntegral.html,https://root.cern,https://root.cern/root/html530/RooRealIntegral.html,1,['Perform'],['Perform']
Performance,jects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooRealProxy_dgamma; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; RooRealProxy_f0; RooRealProxy_f1; RooRealProxy_f2; RooRealProxy_f3; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_lo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBDecay.html:43563,cache,cache,43563,root/html602/RooBDecay.html,https://root.cern,https://root.cern/root/html602/RooBDecay.html,2,['cache'],['cache']
Performance,"jitting argument of type short; [#6802] - Allow to pass Bearer token authentication header to Davix client; [#7345] - Issue building built-in libafterimage; [#6812] - root REPL problem with unsigned num assigned to a not declared item; [#7292] - compilation fails on xrootd: _STAT_VER was not declared; [#7481] - String parse error in RooSimPdfBuilder.cxx; [#7433] - Segmentation fault after quitting Cling in CUDA mode; [#7239] - [RF] Use integral of PDF curves for pull plots and residuals; [#7390] - Must not forward declare template specialization with enumerator as template arg; [#7454] - [RF][Docs] Breaking changes of batch computation interface not documented in release notes; [#7558] - AfterImage compilation broken with binutils 2.36; [#7507] - [tree] Possible error in TLeaf::GetLeafCounter; [#7361] - RooFit backend library: force to specific architecture; [#7362] - Incremental build problems; [#7319] - [Hist] Wrong computation in TH3::GetCovariance for diagonal elements; [#7206] - Unable to build with builtin_cling=OFF for LLVM 9; [#7157] - RooFFTConvPdf doesn’t work with RooProdPdf; [#7076] - RNTuple, parallel unzip tear down race condition; [#7021] - cling depends on exact macOS SDK headers; [#6953] - Missing documentation for ROOT.RDF.MakeNumpyDataFrame; [#6421] - Proposal to unify logging in Minuit2; [#7302] - TGraph copy constructor error; [#7212] - TMathText does not display with high value coordinates; [#6997] - Fill attribute is not fully reflected in THStack; [#6360] - [Docs] Missing figures in RDF tutorials 10[5,6,7] on doxygen; [#7093] - Race condition affecting (at least) TEnum::GetEnum; [#7054] - sporadic roottest-python-cmdLineUtils failures; [#6939] - Problems when TFile object is opened and closed on different threads.; [#6715] - [bug] Type overflow in TMessageHandler; [#7281] - Trailing dot dropped in top level branch name. Release 6.24/02; Published on June 28, 2021; RDataFrame. Scaling behavior at high core counts (32+ cores) has been improved ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:46319,race condition,race condition,46319,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['race condition'],['race condition']
Performance,"jority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : and can be changed by the user.; : ; : The other crucial parameter, the pruning strength (""PruneStrength""),; : is also related to overtraining. It is a regularisation parameter ; : that is used when determining after the training which splits ; : are considered statistically insignificant and are removed. The; : user is advised to carefully watch the BDT screen output for; : the comparison between efficiencies obtained on the training and; : the independent test sample. They should be equal within statistical; : errors, in order to minimize statistical fluctuations in different samples.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; BDTG : #events: (reweighted) sig: 16",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:32369,perform,performance,32369,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['perform'],['performance']
Performance,"just the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform rotation; with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& b); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TView3D.html:21879,Perform,Perform,21879,root/html528/TView3D.html,https://root.cern,https://root.cern/root/html528/TView3D.html,1,['Perform'],['Perform']
Performance,"just the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& ); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TView3D.html:22042,Perform,Perform,22042,root/html534/TView3D.html,https://root.cern,https://root.cern/root/html534/TView3D.html,3,['Perform'],['Perform']
Performance,"just the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& b); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TView3D.html:21950,Perform,Perform,21950,root/html530/TView3D.html,https://root.cern,https://root.cern/root/html530/TView3D.html,2,['Perform'],['Perform']
Performance,"k () override;  Intercept changes to cache operation mode and forward to cache elements. ;  ; void optimizeCacheMode (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  Intercept calls to perform automatic optimization of cache mode operation. ;  ; void printCompactTreeHook (std::ostream &, const char *) override;  Add details on cache contents when printing in tree mode. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Intercept server redirect calls. ;  ; void setClearOnRedirect (bool flag);  ; void sterilize () override;  Clear the cache payload but retain slot mapping w.r.t to normalization and integration sets. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooCacheManager< RooAbsCacheElement >;  RooCacheManager (const RooCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooCacheManager (Int_t maxSize=2);  Constructor for simple caches without RooAbsArg payload. ;  ;  RooCacheManager (RooAbsArg *owner, Int_t maxSize=2);  Constructor for simple caches with RooAbsArg derived payload. ;  ;  ~RooCacheManager () override;  Destructor. ;  ; Int_t cacheSize () const;  Return size of cache. ;  ; RooAbsCacheElement * getObj (const RooArgSet *nset, const RooArgSet *iset, Int_t *sterileIdx, const char *isetRangeName);  ; RooAbsCacheElement * getObj (const RooArgSet *nset, const RooArgSet *iset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Retrieve payload object indexed on nset,uset amd isetRangeName If sterileIdx is not null, it is set to the index of the sterile slot in cacse such a slot is recycled. ;  ; RooAbsCacheElement * getObj (const RooArgSet *nset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Getter function without integration set. ;  ; RooAbsCacheElement * getObjByIndex (Int_t index) const;  Retrieve payload object by slot index. ;  ; Int_t lastInd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:2631,cache,caches,2631,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['cache'],['caches']
Performance,"k flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Meetings. All ROOT-related meetings ca be found in ROOT's Indico category; the upcoming ones can be seen here to the right.; Weekly Developers Meetings; Developers get together on a weekly basis to discuss the plans and review the progress on Monday's at 16:00 CET. Indico category; Vidyo ROOT Team meeting. Experiments Planning Meetings; Experiments and core developers meet regularly to discuss the progress of open issues and future plans on Wednesdays at 16:00 CET. Indico category; Vidyo Room . Topical meetings; Several of the ROOT packages have dedicated meetings, for instance I/O, TMVA, RooFit, C++ Modules. These meetings, too, can be found in ROOT's Indico category. Root Meetings. ROOT Framework Meetings ; 78th ROOT Parallelism, Performance and Programming Model Meeting ; 07/02/2020 - ; CERN - ; 4/S-030 . ROOT Framework Meetings ; ROOT I/O Meeting ; 07/03/2020 - ; CERN - ; 32/1-A24 . ROOT Framework Meetings ; TMVA Developers Meeting ; 07/03/2020 . ROOT Framework Meetings ; Biweekly meeting: C++ Modules in ROOT ; 07/08/2020 . ROOT Framework Meetings ; ROOT I/O Meeting ; 07/10/2020 - ; CERN - ; 32/1-A24 .  ; 1 of 5; next ›. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. Contrib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/meetings.html:2599,Perform,Performance,2599,d/meetings.html,https://root.cern,https://root.cern/d/meetings.html,1,['Perform'],['Performance']
Performance,"k if the basket should be vetoed in the next round. ;  . Private Types; enum  EStates { kLoaded = 0; , kUsed = 1; , kVetoed = 2; , kSize = 3; };  . Private Member Functions; void SetState (Int_t basketNumber, EStates what);  Mark if the basket has been marked has the 'what' state. ;  ; bool TestState (Int_t basketNumber, EStates what) const;  Return true if the basket has been marked as having the 'what' state. ;  ; void UpdatePedestal (Int_t basketNumber);  Update the pedestal to be less or equal to basketNumber, shift the bits if needed. ;  . Private Attributes; Int_t fBasketPedestal {-1};  ; TBits fInfo;  . #include <TBranchCacheInfo.h>; Member Enumeration Documentation. ◆ EStates. enum ROOT::Internal::TBranchCacheInfo::EStates. private . EnumeratorkLoaded ; kUsed ; kVetoed ; kSize . Definition at line 37 of file TBranchCacheInfo.h. Member Function Documentation. ◆ AllUsed(). bool ROOT::Internal::TBranchCacheInfo::AllUsed ; (; ); const. inline . Return true if all the baskets that are marked loaded are also mark as used. ; Definition at line 109 of file TBranchCacheInfo.h. ◆ GetUnused(). void ROOT::Internal::TBranchCacheInfo::GetUnused ; (; std::vector< Int_t > & ; unused). inline . Return a set of unused basket, let's not re-read them. ; Definition at line 122 of file TBranchCacheInfo.h. ◆ HasBeenUsed(). bool ROOT::Internal::TBranchCacheInfo::HasBeenUsed ; (; Int_t ; basketNumber); const. inline . Return true if the basket has been marked as 'used'. ; Definition at line 76 of file TBranchCacheInfo.h. ◆ IsInCache(). bool ROOT::Internal::TBranchCacheInfo::IsInCache ; (; Int_t ; basketNumber); const. inline . Return true if the basket is currently in the cache. ; Definition at line 86 of file TBranchCacheInfo.h. ◆ IsVetoed(). bool ROOT::Internal::TBranchCacheInfo::IsVetoed ; (; Int_t ; basketNumber); const. inline . Return true if the basket is currently vetoed. ; Definition at line 105 of file TBranchCacheInfo.h. ◆ Print(). void ROOT::Internal::TBranchCacheInfo::Pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1TBranchCacheInfo.html:2285,load,loaded,2285,doc/master/classROOT_1_1Internal_1_1TBranchCacheInfo.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1TBranchCacheInfo.html,1,['load'],['loaded']
Performance,"k is from IncrementalExecutor::diagnoseUnresolvedSymbols; 6581 if ( ((TCling*)gCling)->LazyFunctionCreatorAutoload(errmessage)); 6582 return true;; 6583 }; 6584 ; 6585 return false;; 6586}; 6587 ; 6588////////////////////////////////////////////////////////////////////////////////; 6589/// Autoload a library based on a missing symbol.; 6590 ; 6591void* TCling::LazyFunctionCreatorAutoload(const std::string& mangled_name) {; 6592 std::string dlsym_mangled_name = ROOT::TMetaUtils::DemangleNameForDlsym(mangled_name);; 6593 ; 6594 // We have already loaded the library.; 6595 if (void* Addr = llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(dlsym_mangled_name)); 6596 return Addr;; 6597 ; 6598 const cling::DynamicLibraryManager &DLM = *GetInterpreterImpl()->getDynamicLibraryManager();; 6599 R__LOCKGUARD(gInterpreterMutex);; 6600 ; 6601 auto LibLoader = [](const std::string& LibName) -> bool {; 6602 if (gSystem->Load(LibName.c_str(), """", false) < 0) {; 6603 ::Error(""TCling__LazyFunctionCreatorAutoloadForModule"",; 6604 ""Failed to load library %s"", LibName.c_str());; 6605 return false;; 6606 }; 6607 return true; //success.; 6608 };; 6609 ; 6610 std::string libName = DLM.searchLibrariesForSymbol(mangled_name,; 6611 /*searchSystem=*/ true);; 6612 ; 6613 assert(!llvm::StringRef(libName).startswith(""libNew"") &&; 6614 ""We must not resolve symbols from libNew!"");; 6615 ; 6616 if (libName.empty()); 6617 return nullptr;; 6618 ; 6619 if (!LibLoader(libName)); 6620 return nullptr;; 6621 ; 6622 return llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(dlsym_mangled_name);; 6623}; 6624 ; 6625////////////////////////////////////////////////////////////////////////////////; 6626 ; 6627Bool_t TCling::IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl* nsDecl); 6628{; 6629 return fNSFromRootmaps.count(nsDecl) != 0;; 6630}; 6631 ; 6632////////////////////////////////////////////////////////////////////////////////; 6633/// Internal function. Actually do the update of the ClassInfo wh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:257187,load,load,257187,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance,"k mark.; chopt='C': labels are Centered on tick mark.; chopt='M': In the Middle of the divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer values for the labels. Input parameters:. A1,A2 : Old WMIN,WMAX .; binLow,binHigh : New WMIN,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGaxis.html:18136,optimiz,optimization,18136,root/html528/TGaxis.html,https://root.cern,https://root.cern/root/html528/TGaxis.html,5,['optimiz'],['optimization']
Performance,"k quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Float_t fCharge; //Charge of this track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track segment; };; 12.17.4 Writing the Tree; We create a simple tree with two branches both holding Event objects. One is split and the other is not. We also create a pointer to an Event object (event).; void tree4w() {; // check to see if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; // create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; // create a pointer to an Event object; Event *event = new Event();; // create two branches, split one; t4.Branch(""event_branch"", ""Event"", &event,16000,2);; t4.Branch(""event_not_split"", ""Event"", &event,16000,0);. // a local variable for the event type; char etype[20];. // fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:578816,load,load,578816,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"k(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Mar 10 17:13:51 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCacheElement.html:2145,optimiz,optimizeCacheMode,2145,root/html534/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html,5,"['cache', 'optimiz']","['cache', 'cacheList', 'optimization', 'optimizeCacheMode']"
Performance,"k(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; voidinitialize() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidloadDataSet(Bool_t firstCall) const; voidloadWeightSet() const; voidloopRange(vector<Double_t>& x, map<Int_t,Bool_t>& ibMap) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; voidmirrorDataSet() const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNDKeysPdf.html:37444,optimiz,optimizeDirtyHook,37444,root/html534/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html534/RooNDKeysPdf.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"k(newel);; 4612 } else {; 4613 toAdd.reserve(rule->GetTarget()->GetEntriesFast());; 4614 TObjString * objstr = (TObjString*)(rule->GetTarget()->At(0));; 4615 if (objstr) {; 4616 TString newName = objstr->String();; 4617 TString realDataName;; 4618 if ( TDataMember* dm = fClass->GetDataMember( newName ) ) {; 4619 TRealData::GetName(realDataName,dm);; 4620 newel = new TStreamerArtificial(realDataName,"""",; 4621 fClass->GetDataMemberOffset(newName),; 4622 TStreamerInfo::kArtificial,; 4623 fClass->GetDataMember( newName )->GetTypeName());; 4624 newel->SetReadFunc( rule->GetReadFunctionPointer() );; 4625 newel->SetReadRawFunc( rule->GetReadRawFunctionPointer() );; 4626 toAdd.push_back(newel);; 4627 } else {; 4628 // This would be a completely new member (so it would need to be cached); 4629 // TOBEDONE; 4630 }; 4631 for(Int_t other = 1; other < rule->GetTarget()->GetEntriesFast(); ++other) {; 4632 objstr = (TObjString*)(rule->GetTarget()->At(other));; 4633 if (objstr) {; 4634 newName = objstr->String();; 4635 if ( TDataMember* dm = fClass->GetDataMember( newName ) ) {; 4636 TRealData::GetName(realDataName,dm);; 4637 newel = new TStreamerArtificial(realDataName,"""",; 4638 fClass->GetDataMemberOffset(newName),; 4639 TStreamerInfo::kArtificial,; 4640 fClass->GetDataMember( newName )->GetTypeName());; 4641 toAdd.push_back(newel);; 4642 }; 4643 }; 4644 }; 4645 } // For each target of the rule; 4646 }; 4647 // Now find we with need to add them; 4648 TIter s_iter(rule->GetSource());; 4649 Int_t loc = -1;; 4650 while( TObjString *s = (TObjString*)s_iter() ) {; 4651 for(Int_t i = fElements->GetLast(); i >= 0 && (i+1) >= loc; --i) {; 4652 if (s->String() == fElements->UncheckedAt(i)->GetName()) {; 4653 if (loc == -1 || (i+1)>loc) {; 4654 loc = i+1;; 4655 }; 4656 }; 4657 }; 4658 }; 4659 if (loc == -1) {; 4660 // Verify if the last one is not 'skipped'.; 4661 for(Int_t i = fElements->GetLast(); i >= 0 && (i+1) >= loc; --i) {; 4662 if (((TStreamerElement *)fElements->UncheckedAt(i))->Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:187088,cache,cached,187088,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['cache'],['cached']
Performance,"k...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:59; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs resources that are taken by using the default error handler.Definition TErrorDefaultHandler.cxx:47; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::GetMacroPathTString & GetMacroPath()Definition TROOT.cxx:476; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:171947,multi-thread,multi-threading,171947,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"k...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs resources that are taken by using the default error handler.Definition TErrorDefaultHandler.cxx:47; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::GetMacroPathTString & GetMacroPath()Definition TROOT.cxx:476; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:172123,multi-thread,multi-threading,172123,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"k.h. ◆ Streamer(). void TEntryListBlock::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TEntryListBlock::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 80 of file TEntryListBlock.h. ◆ Transform(). void TEntryListBlock::Transform ; (; bool ; dir, . UShort_t * ; indexnew . ). protected . Transform the existing fIndices. . dir=0 - transform from bits to a list; dir=1 - tranform from a list to bits . Definition at line 563 of file TEntryListBlock.cxx. Member Data Documentation. ◆ fCurrent. UShort_t TEntryListBlock::fCurrent. protected . ! to fasten Contains() in list mode ; Definition at line 53 of file TEntryListBlock.h. ◆ fIndices. UShort_t* TEntryListBlock::fIndices. protected . [fN] ; Definition at line 49 of file TEntryListBlock.h. ◆ fLastIndexQueried. Int_t TEntryListBlock::fLastIndexQueried. protected . ! to optimize GetEntry() in a loop ; Definition at line 54 of file TEntryListBlock.h. ◆ fLastIndexReturned. Int_t TEntryListBlock::fLastIndexReturned. protected . ! to optimize GetEntry() in a loop ; Definition at line 55 of file TEntryListBlock.h. ◆ fN. Int_t TEntryListBlock::fN. protected . size of fIndices for I/O =fNPassed for list, fBlockSize for bits ; Definition at line 48 of file TEntryListBlock.h. ◆ fNPassed. Int_t TEntryListBlock::fNPassed. protected . number of entries in the entry list (if fPassing=0 - number of entries not in the entry list ; Definition at line 46 of file TEntryListBlock.h. ◆ fPassing. bool TEntryListBlock::fPassing. protected . 1 - stores entries that belong to the list 0 - stores entries that don't belong to the list ; Definition at line 51 of file TEntryListBlock.h. ◆ fType. Int_t TEntryListBlock::fType. protected . 0 - bits, 1 - list ; Definition at line 50 of file TEntryListBlock.h. Libraries for TEntryListBlock:. [legend]; The documentation for this class was generated from the following fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListBlock.html:18376,optimiz,optimize,18376,doc/master/classTEntryListBlock.html,https://root.cern,https://root.cern/doc/master/classTEntryListBlock.html,1,['optimiz'],['optimize']
Performance,"k; ## @param use_type; ## use_type = 0 use Simple RNN network; ## use_type = 1 use LSTM network; ## use_type = 2 use GRU; ## use_type = 3 build 3 different networks with RNN, LSTM and GRU; ; ; use_type = 1; ninput = 30; ntime = 10; batchSize = 100; maxepochs = 10; ; nTotEvts = 2000 # total events to be generated for signal or background; ; useKeras = True; ; useTMVA_RNN = True; useTMVA_DNN = True; useTMVA_BDT = False; ; tf_spec = importlib.util.find_spec(""tensorflow""); if tf_spec is None:; useKeras = False; ROOT.Warning(""TMVA_RNN_Classificaton"",""Skip using Keras since tensorflow is not installed""); ; ; rnn_types = [""RNN"", ""LSTM"", ""GRU""]; use_rnn_type = [1, 1, 1]; ; if 0 <= use_type < 3:; use_rnn_type = [0, 0, 0]; use_rnn_type[use_type] = 1; ; useGPU = True # use GPU for TMVA if available; ; useGPU = ""tmva-gpu"" in ROOT.gROOT.GetConfigFeatures(); useTMVA_RNN = (""tmva-cpu"" in ROOT.gROOT.GetConfigFeatures()) or useGPU; ; if useTMVA_RNN:; ROOT.Warning(; ""TMVA_RNN_Classification"",; ""TMVA is not build with GPU or CPU multi-thread support. Cannot use TMVA Deep Learning for RNN"",; ); ; archString = ""GPU"" if useGPU else ""CPU""; ; writeOutputFile = True; ; rnn_type = ""RNN""; ; if ""tmva-pymva"" in ROOT.gROOT.GetConfigFeatures():; TMVA.PyMethodBase.PyInitialize(); else:; useKeras = False; ; ; ; inputFileName = ""time_data_t10_d30.root""; ; fileDoesNotExist = ROOT.gSystem.AccessPathName(inputFileName); ; # if file does not exists create it; if fileDoesNotExist:; MakeTimeData(nTotEvts, ntime, ninput); ; ; inputFile = TFile.Open(inputFileName); if inputFile is None:; raise ROOT.Error(""Error opening input file %s - exit"", inputFileName.Data()); ; ; print(""--- RNNClassification : Using input file: {}"".format(inputFile.GetName())); ; # Create a ROOT output file where TMVA will store ntuples, histograms, etc.; outfileName = ""data_RNN_"" + archString + "".root""; outputFile = None; ; ; if writeOutputFile:; outputFile = TFile.Open(outfileName, ""RECREATE""); ; ; ## Declare Factory; ; # Create the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:53221,multi-thread,multi-thread,53221,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['multi-thread'],['multi-thread']
Performance,"k;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefProxy->Release();; 1733 fRefProxy = nullptr;; 1734 ; 1735 delete fStreamer;; 1736 delete fCollectionProxy;; 1737 delete fIsAMethod.load();; 1738 delete fSchemaRules;; 1739 if (fConversionStreamerInfo.load()) {; 1740 std::map<std::string, TObjArray*>::iterator it;; 1741 std::map<std::string, TObjArray*>::iterator end = (*fConversionStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:65539,load,load,65539,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"k;; 1740 }; 1741 }; 1742 }; 1743 ; 1744 // Not owning lists, don't call Delete(); 1745 // But this still need to be done first because the TList destructor; 1746 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1747 delete fStreamer; fStreamer =nullptr;; 1748 delete fAllPubData; fAllPubData =nullptr;; 1749 delete fAllPubMethod; fAllPubMethod=nullptr;; 1750 ; 1751 delete fPersistentRef.load();; 1752 ; 1753 if (fBase.load()); 1754 (*fBase).Delete();; 1755 delete fBase.load(); fBase = nullptr;; 1756 ; 1757 if (fData.load()); 1758 (*fData).Delete();; 1759 delete fData.load(); fData = nullptr;; 1760 ; 1761 if (fUsingData.load()); 1762 (*fUsingData).Delete();; 1763 delete fUsingData.load(); fUsingData = nullptr;; 1764 ; 1765 if (fEnums.load()); 1766 (*fEnums).Delete();; 1767 delete fEnums.load(); fEnums = nullptr;; 1768 ; 1769 if (fFuncTemplate); 1770 fFuncTemplate->Delete();; 1771 delete fFuncTemplate; fFuncTemplate = nullptr;; 1772 ; 1773 if (fMethod.load()); 1774 (*fMethod).Delete();; 1775 delete fMethod.load(); fMethod=nullptr;; 1776 ; 1777 if (fRealData); 1778 fRealData->Delete();; 1779 delete fRealData; fRealData=nullptr;; 1780 ; 1781 if (fStreamerInfo); 1782 fStreamerInfo->Delete();; 1783 delete fStreamerInfo; fStreamerInfo = nullptr;; 1784 ; 1785 if (fDeclFileLine >= -1); 1786 TClass::RemoveClass(this);; 1787 ; 1788 gCling->ClassInfo_Delete(fClassInfo);; 1789 fClassInfo=nullptr;; 1790 ; 1791 if (fClassMenuList); 1792 fClassMenuList->Delete();; 1793 delete fClassMenuList; fClassMenuList=nullptr;; 1794 ; 1795 fIsOffsetStreamerSet=kFALSE;; 1796 ; 1797 if ( fIsA ) delete fIsA;; 1798 ; 1799 if ( fRefProxy ) fRefProxy->Release();; 1800 fRefProxy = nullptr;; 1801 ; 1802 delete fStreamer;; 1803 delete fCollectionProxy;; 1804 delete fIsAMethod.load();; 1805 delete fSchemaRules;; 1806 if (fConversionStreamerInfo.load()) {; 1807 std::map<std::string, TObjArray*>::iterator it;; 1808 std::map<std::string, TObjArray*>::iterator end = (*fConversionStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:68290,load,load,68290,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"kBigNumber, Long64_t firstentry = 0); Process all entries in this chain, calling functions in filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success.; See TTree::Process. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Reset(Option_t* option = """"); -- Resets the state of this chain. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TChain.html:43833,Load,LoadTree,43833,root/html528/TChain.html,https://root.cern,https://root.cern/root/html528/TChain.html,2,"['Load', 'load']","['LoadTree', 'loads']"
Performance,"kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TBuffer &b); 2407{; 2408 if (b.IsReading()) {; 2409 b.ReadVersion(); //Version_t v = b.ReadVersion();; 2410 } else {; 2411 b.WriteVersion(TFile::IsA());; 2412 }; 2413}; 2414 ; 2415////////////////////////////////////////////////////////////////////////////////; 2416/// Increment statistics for buffer sizes of ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:84617,cache,cache,84617,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['cache'],['cache']
Performance,"kEntryChainSetupError problem in accessing a chain element, e.g. file without the tree . kEntryChainFileError problem in opening a chain's file . kEntryDictionaryError problem reading dictionary info from tree . kEntryBeyondEnd last entry loop has reached its end . kEntryBadReader One of the readers was not successfully initialized. . kIndexedFriendNoMatch A friend with TTreeIndex doesn't have an entry for this index. . kMissingBranchWhenSwitchingTree A branch was not found when switching to the next TTree in the chain. . kEntryUnknownError LoadTree return less than -6, likely a 'newer' error code. . Definition at line 152 of file TTreeReader.h. ◆ ELoadTreeStatus. enum TTreeReader::ELoadTreeStatus. EnumeratorkNoTree default state, no TTree is connected (formerly 'Zombie' state) . kLoadTreeNone Notify has not been called yet. . kInternalLoadTree Notify/LoadTree was last called from SetEntryBase. . kExternalLoadTree User code called LoadTree directly. . kMissingBranchFromTree Missing expected branch when loading new tree. . Definition at line 167 of file TTreeReader.h. ◆ EStatusBits. enum TTreeReader::EStatusBits. private . EnumeratorkBitIsChain our tree is a chain . kBitHaveWarnedAboutEntryListAttachedToTTree the tree had a TEntryList and we have warned about that . kBitSetEntryBaseCallingLoadTree SetEntryBase is in the process of calling TChain/TTree::LoadTree. . kBitIsExternalTree we do not own the tree . Definition at line 311 of file TTreeReader.h. Constructor & Destructor Documentation. ◆ TTreeReader() [1/4]. TTreeReader::TTreeReader ; (; ). Default constructor. Call SetTree to connect to a TTree. ; Definition at line 191 of file TTreeReader.cxx. ◆ TTreeReader() [2/4]. TTreeReader::TTreeReader ; (; TTree * ; tree, . TEntryList * ; entryList = nullptr, . bool ; warnAboutLongerFriends = true, . const std::vector< std::string > & ; suppressErrorsForMissingBranches = {} . ). Access data from tree. ; Parameters. treeThe TTree or TChain to read from ; entryListIt can ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:23389,load,loading,23389,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['load'],['loading']
Performance,"kFALSE) const; const char*makeFPName(const char* pfx, const RooArgSet& terms) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProduct.html:29493,optimiz,optimizeDirtyHook,29493,root/html534/RooProduct.html,https://root.cern,https://root.cern/root/html534/RooProduct.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"kFALSE) const; const char*makeFPName(const char* pfx, const RooArgSet& terms) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProduct.html:27064,optimiz,optimizeDirtyHook,27064,root/html526/RooProduct.html,https://root.cern,https://root.cern/root/html526/RooProduct.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tnumSets() const; RooAbsTestStatistic::GOFOpModeoperMode() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidprintCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tprocessEmptyDataSets() const; virtual Bool_tredirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:30634,optimiz,optimizeDirtyHook,30634,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tnumSets() const; RooAbsTestStatistic::GOFOpModeoperMode() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidprintCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tredirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsTestStatistic.html:27791,optimiz,optimizeDirtyHook,27791,root/html526/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsTestStatistic.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"kFALSE, Bool_t intNSet = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMoment.html:24440,cache,cache,24440,root/html602/RooMoment.html,https://root.cern,https://root.cern/root/html602/RooMoment.html,4,['cache'],['cache']
Performance,"kFALSE, TList* loadopts = 0, TList* workers = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackage(const char* package); Unload specified package.; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackageOnClient(const char* package); Unload a specific package on the client.; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::UnloadPackage; case). Keep in sync in case of changes. Int_t UnloadPackages(); Unload all packages.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:73316,load,loadopts,73316,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['load'],['loadopts']
Performance,"kFALSE;; 3003 ; 3004 if (build_loc.Length()==0) {; 3005 build_loc = lib_location;; 3006 } else {; 3007 // Removes an existing disk specification from the names; 3008 TRegexp disk_finder (""[A-z]:"");; 3009 Int_t pos = library.Index( disk_finder );; 3010 if (pos==0) library.Remove(pos,3);; 3011 pos = lib_location.Index( disk_finder );; 3012 if (pos==0) lib_location.Remove(pos,3);; 3013 ; 3014 if (flatBuildDir) {; 3015 AssignAndDelete( library, ConcatFileName( build_loc, libname_ext) );; 3016 } else {; 3017 AssignAndDelete( library, ConcatFileName( build_loc, library) );; 3018 }; 3019 ; 3020 Bool_t canWriteBuild_loc = !gSystem->AccessPathName(build_loc,kWritePermission);; 3021 TString build_loc_store( build_loc );; 3022 if (!flatBuildDir) {; 3023 AssignAndDelete( build_loc, ConcatFileName( build_loc, lib_location) );; 3024 }; 3025 ; 3026 if (gSystem->AccessPathName(build_loc,kFileExists)) {; 3027 mkdirFailed = (0 != mkdir(build_loc, true));; 3028 if (mkdirFailed && !canWriteBuild_loc) {; 3029 // The mkdir failed __and__ we can not write to the target directory,; 3030 // let make sure the error message will be about the target directory; 3031 build_loc = build_loc_store;; 3032 mkdirFailed = kFALSE;; 3033 } else if (!mkdirFailed && dirmode!=0) {; 3034 Chmod(build_loc,dirmode);; 3035 }; 3036 }; 3037 }; 3038 library = gSystem->UnixPathName(library);; 3039 ; 3040 // ======= Check if the library need to loaded or compiled; 3041 if (!gInterpreter->IsLibraryLoaded(library) && gInterpreter->IsLoaded(expFileName)) {; 3042 // the script has already been loaded in interpreted mode; 3043 // Let's warn the user and unload it.; 3044 ; 3045 if (withInfo) {; 3046 ::Info(""ACLiC"",""script has already been loaded in interpreted mode"");; 3047 ::Info(""ACLiC"",""unloading %s and compiling it"", filename);; 3048 }; 3049 ; 3050 if ( gInterpreter->UnloadFile( expFileName ) != 0 ) {; 3051 // We can not unload it.; 3052 return kFALSE;; 3053 }; 3054 }; 3055 ; 3056 // Calculate the -I lines; 3057 TStrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:102014,load,loaded,102014,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,['load'],['loaded']
Performance,"kHasNameMapNode@ kHasNameMapNodeDefinition TClass.h:105; TClass::kIgnoreTObjectStreamer@ kIgnoreTObjectStreamerDefinition TClass.h:97; TClass::kUnloaded@ kUnloadedDefinition TClass.h:98; TClass::kWarned@ kWarnedDefinition TClass.h:104; TClass::kStartWithTObject@ kStartWithTObjectDefinition TClass.h:103; TClass::kIsTObject@ kIsTObjectDefinition TClass.h:100; TClass::kIsForeign@ kIsForeignDefinition TClass.h:101; TClass::kReservedLoading@ kReservedLoadingDefinition TClass.h:93; TClass::fUsingDatastd::atomic< TListOfDataMembers * > fUsingDataDefinition TClass.h:203; TClass::GetMethodListTListOfFunctions * GetMethodList()Return (create an empty one if needed) the list of functions.Definition TClass.cxx:4355; TClass::GetReferenceProxyTVirtualRefProxy * GetReferenceProxy() constDefinition TClass.h:483; TClass::ResetMenuListvoid ResetMenuList()Resets the menu list to it's standard value.Definition TClass.cxx:4243; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TClass::WriteBufferInt_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""")Function called by the Streamer functions to serialize object at p to buffer b.Definition TClass.cxx:6779; TClass::LoadClassCustomstatic TClass * LoadClassCustom(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5801; TClass::GetHeapInstanceCountUInt_t GetHeapInstanceCount() constDefinition TClass.h:467; TClass::fImplFileLineShort_t fImplFileLineDefinition TClass.h:216; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCollectionCollection abstract base class.Definition TCollection.h:65; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDictionaryThis class defines an abstract interface that must be implemented by all classes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:80032,load,load,80032,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['load'],['load']
Performance,"kHasNameMapNode@ kHasNameMapNodeDefinition TClass.h:105; TClass::kIgnoreTObjectStreamer@ kIgnoreTObjectStreamerDefinition TClass.h:97; TClass::kUnloaded@ kUnloadedDefinition TClass.h:98; TClass::kWarned@ kWarnedDefinition TClass.h:104; TClass::kStartWithTObject@ kStartWithTObjectDefinition TClass.h:103; TClass::kIsTObject@ kIsTObjectDefinition TClass.h:100; TClass::kIsForeign@ kIsForeignDefinition TClass.h:101; TClass::kReservedLoading@ kReservedLoadingDefinition TClass.h:93; TClass::fUsingDatastd::atomic< TListOfDataMembers * > fUsingDataDefinition TClass.h:203; TClass::GetMethodListTListOfFunctions * GetMethodList()Return (create an empty one if needed) the list of functions.Definition TClass.cxx:4422; TClass::GetReferenceProxyTVirtualRefProxy * GetReferenceProxy() constDefinition TClass.h:483; TClass::ResetMenuListvoid ResetMenuList()Resets the menu list to it's standard value.Definition TClass.cxx:4310; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClass::WriteBufferInt_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""")Function called by the Streamer functions to serialize object at p to buffer b.Definition TClass.cxx:6846; TClass::LoadClassCustomstatic TClass * LoadClassCustom(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5868; TClass::GetHeapInstanceCountUInt_t GetHeapInstanceCount() constDefinition TClass.h:467; TClass::fImplFileLineShort_t fImplFileLineDefinition TClass.h:216; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCollectionCollection abstract base class.Definition TCollection.h:65; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDictionaryThis class defines an abstract interface that must be implemented by all classes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:79860,load,load,79860,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['load'],['load']
Performance,"kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:21598,cache,cache,21598,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,4,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; static RooCategorySharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:21779,cache,cache,21779,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,4,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPluginManager.html:9526,Load,LoadHandlersFromPluginDirs,9526,root/html528/TPluginManager.html,https://root.cern,https://root.cern/root/html528/TPluginManager.html,8,['Load'],"['Load', 'LoadHandlersFromPluginDirs']"
Performance,"kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_t_expectedDataAsimov?; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; RooDataSet*RooAbsGenContext::_genData! Data being generated; RooDataHist*_histHistogram; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; RooAbsPdf*_pdfPointer to cloned p.d.f; RooArgSet*_pdfSetSet owned all nodes of internal clone of p.d.f; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; const RooArgSet*_vars; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBinnedGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor. ~RooBinnedGenContext(); Destructor. D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBinnedGenContext.html:9049,load,load,9049,root/html602/RooBinnedGenContext.html,https://root.cern,https://root.cern/root/html602/RooBinnedGenContext.html,2,['load'],['load']
Performance,kNotEqual; kLess; kGreater; kLessThan; kGreaterThan; kNot; kcosh; ksinh; ktanh; kacosh; kasinh; katanh; kStringEqual; kStringNotEqual; kBitAnd; kBitOr; kLeftShift; kRightShift; kJumpIf; kJump; kexpo; kxexpo; kyexpo; kzexpo; kxyexpo; kgaus; kxgaus; kygaus; kzgaus; kxygaus; klandau; kxlandau; kylandau; kzlandau; kxylandau; kpol; kxpol; kypol; kzpol; kParameter; kConstant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tfChisquareFunction fit chisquare; void*fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorfFunctor! Functor object to wrap any C++ callable object; Double_t*fGamma!Array gamma.; TH1*fHistogram!Pointer to histogram used for visualisation; Double_t*fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:23114,cache,cache,23114,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['cache'],['cache']
Performance,"kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from RooAbsDataStore; RooArgSet _cachedVars;  ; bool _doDirtyProp = true;  Switch do (de)activate dirty state propagation when loading a data point. ;  ; RooArgSet _vars;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooTreeDataStore.h>. Inheritance diagram for RooTreeDataStore:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooTreeDataStore() [1/8]. RooTreeDataStore::RooTreeDataStore ; (; ). Definition at line 74 of file RooTreeDataStore.cxx. ◆ RooTreeDataStore() [2/8]. RooTreeDataStore::RooTreeDataStore ; (; TTree * ; t, . const RooArgSet & ; vars, . const char * ; wgtVarName = nullptr . ). Constructor to facilitate reading of legacy RooDataSets. ; Definition at line 81 of file RooTreeDataStore.cxx. ◆ RooTreeDataStore() [3/8]. RooTreeDataStore::RooTreeDataStore ; (; RooStringView ; name, . RooStringView",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:23417,load,loading,23417,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['load'],['loading']
Performance,"kObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); RooCachedPdf(); RooCachedPdf(const RooCachedPdf& other, const char* name = 0); RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedPdf.html:28281,cache,cacheObs,28281,root/html602/RooCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooCachedPdf.html,2,['cache'],['cacheObs']
Performance,"kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooMCStudy*_mcsPointer to RooMCStudy object module is attached to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsMCStudyModule(const char* name, const char* title); Constructor. RooAbsMCStudyModule(const RooAbsMCStudyModule& other); Copy constructor. Bool_t doInitializeInstance(RooMCStudy& ); Store reference to RooMCStudy object that this module relates to and call internal module; initialization function. virtual ~RooAbsMCStudyModule(); {}. Bool_t initializeInstance(); Initializer called immediately after attachment to RooMCStudy object and initialization of module base class. Bool_t initializeRun(Int_t ); Method called at the beginning of each RooMCStudy run. RooDataSet* finalizeRun(); Method called at the end of each RooMCStudy run. If a RooDataSet is returned, it must have a length equal to; the number of toy experiments performed and will merged with the fitpar dataset of RooMCStudy. Bool_t processBeforeGen(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsMCStudyModule.html:7701,perform,performed,7701,root/html526/RooAbsMCStudyModule.html,https://root.cern,https://root.cern/root/html526/RooAbsMCStudyModule.html,5,['perform'],['performed']
Performance,kPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. Bool_tfAutoFitwhen true canvas container keeps same size as canvas; Int_tfButtoncurrently pressed button; TRootContainer*fCanvasContainercontainer in canvas widget; Int_tfCanvasIDindex in fWindows array of TGX11; TGLayoutHints*fCanvasLayoutlayout for canvas widget; TGCanvas*fCanvasWindowcanvas widget; TGLayoutHints*fDockLayoutlayout hints for dockable frame widget; TGPopupMenu*fEditClearMenuclear cascade submenu; TGPopupMenu*fEditMenuedit menu; TVirtualPadEditor*fEditorpointer to currently loaded pad editor; TGCompositeFrame*fEditorFrameside frame for current pad editor; TGLayoutHints*fEditorLayoutlayout for editor frame; Bool_tfEmbeddedtrue if embedded in any other frame (e.g. in the browser); TGPopupMenu*fFileMenufile menu; TGPopupMenu*fFileSaveMenusave cascade submenu; TGPopupMenu*fHelpMenuhelp menu; TGHorizontal3DLine*fHorizontal1toolbar sepatator; TGLayoutHints*fHorizontal1Layoutlayout hints for separator; const TGPicture*fIconPicicon picture; TGCompositeFrame*fMainFramemain frame containing canvas and side frame; TGLayoutHints*fMainFrameLayoutlayout for main frame; TGMenuBar*fMenuBarmenubar; TGLayoutHints*fMenuBarHelpLayoutlayout hint for help menu in menubar; TGLayoutHints*fMenuBarItemLayoutlayout hints for menu in menubar; TGLayoutHints*fMenuBarLayoutmenubar layout hints; TGPopupMenu*fOptionMenuoption menu; TGSta,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootCanvas.html:23831,load,loaded,23831,root/html534/TRootCanvas.html,https://root.cern,https://root.cern/root/html534/TRootCanvas.html,1,['load'],['loaded']
Performance,"kRemoveFriend; static TTree::ELockStatusBitskSetBranchStatus. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAttMarker. ←; TTree. ←. TChain; ←. TProofChain. THbookTree. TNtuple. TNtupleD. TTreeSQL. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTree.html:37713,cache,cache,37713,root/html602/TTree.html,https://root.cern,https://root.cern/root/html602/TTree.html,1,['cache'],['cache']
Performance,"kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. static Int_tRooPrintable::_nameLength; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooClassFactory(); Default constructor. ~RooClassFactory(); Destructor. Bool_t makeAndCompilePdf(const char* name, const char* expression, const RooArgList& vars, const char* intExpression = 0). Bool_t makeAndCompileFunction(const char* name, const char* expression, const RooArgList& args, const char* intExpression = 0); Write, compile and load code for a RooAbsReal implementation with; class name 'name', taking all elements of 'vars' as constructor; arguments. The initial value expression is taken to be; 'expression' which can be any one-line C++ expression in terms of; variables that occur in 'vars'. You can add optional expressions; for analytical integrals to be advertised by your class in the; syntax; ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; where <intObsName> a name of the observable integrated over and; <CPPAnaIntExpression> is the C++ expression that calculates that; integral. RooAbsReal* makeFunctionInstance(const char* name, const char* expression, const RooArgList& vars, const char* intExpression = 0); Write, compile and load code and instantiate object for a; RooAbsReal implementation with class name 'name', taking all; elements of 'vars' as constructor arguments. The initial value; expression is taken to be 'expression' which can be any one-line; C++ exp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooClassFactory.html:9970,load,load,9970,root/html602/RooClassFactory.html,https://root.cern,https://root.cern/root/html602/RooClassFactory.html,2,['load'],['load']
Performance,"kSize = 1024*16); Create a THn / THnSparse object from a histogram deriving from TH1. THnBase* CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); Create a THnSparse (if ""sparse"") or THn from ""hn"", possibly; converting THn <-> THnSparse. void Add(const TH1* hist, Double_t c = 1.); Fill the THnBase with the bins of hist that have content; or error != 0. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribution. Bool_t IsInRange(Int_t* coord) const; Check whether bin coord is in range, as defined by TAxis::SetRange(). TObject* ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; Project all bins into a ndim-dimensional THn / THnSparse (whatever; *this is) or if (ndim < 4 and !wantNDim) a TH1/2/3 histogram,; keeping only axes in dim (specifying ndim dimensions).; If ""opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnBase.html:12223,Perform,Perform,12223,root/html534/THnBase.html,https://root.cern,https://root.cern/root/html534/THnBase.html,1,['Perform'],['Perform']
Performance,"kStandard; kVerbose; kTreeStructure; };. protected:. map<Int_t,std::pair<const RooArgSet*,const RooArgSet*> >_anaIntMap! Map for analytical integration codes; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedReal.html:32089,cache,cache,32089,root/html532/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedReal.html,7,['cache'],"['cache', 'caches']"
Performance,"kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TProfile::Classstatic TClass * Class(); TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TRandom::PoissonDvirtual Double_t PoissonD(Double_t mean)Generates a random number according to a Poisson law.Definition TRandom.cxx:461; TRandom::Poissonvirtual ULong64_t Poisson(Double_t mean)Generates a random integer N according to a Poisson law.Definition TRandom.cxx:404; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) constReturn true if string ends with the specified string.Definition TString.cxx:2244; TString::Clearvoid Clear()Clear stri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:466930,Load,LoadPlugin,466930,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['Load'],"['Load', 'LoadPlugin']"
Performance,"kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void(*)(Int_t&,Double_t*,Double_t&,Double_t*,Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for eac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFitter.html:16049,cache,cache,16049,root/html602/TFitter.html,https://root.cern,https://root.cern/root/html602/TFitter.html,2,['cache'],['cache']
Performance,"kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*specialGeneratorConfig() const; RooNumGenConfig*specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_ttraceEvalHook(Double_t value) const; Bool_ttraceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intverboseEval(); static voidverboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:33514,cache,cache,33514,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,1,['cache'],['cache']
Performance,"kTRUE);; 5752 fRootmapFiles = new TObjArray;; 5753 fRootmapFiles->SetOwner();; 5754 InitRootmapFile("".rootmap"");; 5755 }; 5756 ; 5757 // Prepare a list of all forward declarations for cling; 5758 // For some experiments it is easily as big as 500k characters. To be on the; 5759 // safe side, we go for 1M.; 5760 TUniqueString uniqueString(1048576);; 5761 ; 5762 // Load all rootmap files in the dynamic load path ((DY)LD_LIBRARY_PATH, etc.).; 5763 // A rootmap file must end with the string "".rootmap"".; 5764 TString ldpath = gSystem->GetDynamicPath();; 5765 if (ldpath != fRootmapLoadPath) {; 5766 fRootmapLoadPath = ldpath;; 5767#ifdef WIN32; 5768 TObjArray* paths = ldpath.Tokenize("";"");; 5769#else; 5770 TObjArray* paths = ldpath.Tokenize("":"");; 5771#endif; 5772 TString d;; 5773 for (Int_t i = 0; i < paths->GetEntriesFast(); i++) {; 5774 d = ((TObjString *)paths->At(i))->GetString();; 5775 // check if directory already scanned; 5776 Int_t skip = 0;; 5777 for (Int_t j = 0; j < i; j++) {; 5778 TString pd = ((TObjString *)paths->At(j))->GetString();; 5779 if (pd == d) {; 5780 skip++;; 5781 break;; 5782 }; 5783 }; 5784 if (!skip) {; 5785 void* dirp = gSystem->OpenDirectory(d);; 5786 if (dirp) {; 5787 if (gDebug > 3) {; 5788 Info(""LoadLibraryMap"", ""%s"", d.Data());; 5789 }; 5790 const char* f1;; 5791 while ((f1 = gSystem->GetDirEntry(dirp))) {; 5792 TString f = f1;; 5793 if (f.EndsWith("".rootmap"")) {; 5794 TString p;; 5795 p = d + ""/"" + f;; 5796 if (!gSystem->AccessPathName(p, kReadPermission)) {; 5797 if (!fRootmapFiles->FindObject(f) && f != "".rootmap"") {; 5798 if (gDebug > 4) {; 5799 Info(""LoadLibraryMap"", "" rootmap file: %s"", p.Data());; 5800 }; 5801 Int_t ret = ReadRootmapFile(p, &uniqueString);; 5802 ; 5803 if (ret == 0); 5804 fRootmapFiles->Add(new TNamed(gSystem->BaseName(f), p.Data()));; 5805 if (ret == -3) {; 5806 // old format; 5807 fMapfile->ReadFile(p, kEnvGlobal);; 5808 fRootmapFiles->Add(new TNamed(f, p));; 5809 }; 5810 }; 5811 // else {; 5812 // fprintf(stderr,""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:225387,Load,LoadLibraryMap,225387,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadLibraryMap']
Performance,"kTRUE, . TList * ; wrks = 0 . ). virtual . Load the specified macro on master, workers and, if notOnClient is kFALSE, on the client. ; The macro file is uploaded if new or updated. Additional files to be uploaded (or updated, if needed) can be specified after a comma, e.g. ""mymacro.C+,thisheader.h,thatheader.h"". If existing in the same directory, a header basename(macro).h or .hh, is also uploaded. The default is to load the macro also on the client; notOnClient can be used to avoid loading on the client. On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers only, and collection is not done; if uniqueWorkers is kFALSE, collection from the previous request is done, and broadcasting + collection from the other workers is done. The wrks arg can be used on the master to limit the set of workers. Returns 0 in case of success and -1 in case of error. ; Reimplemented in TProofLite.; Definition at line 8628 of file TProof.cxx. ◆ LoadPackage(). Int_t TProof::LoadPackage ; (; const char * ; package, . Bool_t ; notOnClient = kFALSE, . TList * ; loadopts = 0, . TList * ; workers = 0 . ). private . Load specified package. ; Executes the PROOF-INF/SETUP.C script on all active nodes. If notOnClient = true, don't load package on the client. The default is to load the package also on the client. The argument 'loadopts' specify a list of objects to be passed to the SETUP. The objects in the list must be streamable; the SETUP macro will be executed like this: SETUP.C(loadopts). Returns 0 in case of success and -1 in case of error. ; Definition at line 8069 of file TProof.cxx. ◆ LogMessage(). void TProof::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Log a message into the appropriate window by emitting a signal. ; Definition at line 6414 of file TProof.cxx. ◆ LogViewer(). void TProof::LogViewer ; (; const char * ; url = 0, . Int_t ; sessionidx = 0 . ). static . Start the log viewer window usign the plugin manager. ; Definition at line 12470 of file TPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:114900,Load,LoadPackage,114900,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['Load'],['LoadPackage']
Performance,"kTRUE;; 2498 }; 2499 if (siz != len) {; 2500 SetBit(kWriteError);; 2501 Error(""WriteBuffer"", ""error writing all requested bytes to file %s, wrote %ld of %d"",; 2502 GetName(), (Long_t)siz, len);; 2503 return kTRUE;; 2504 }; 2505 fBytesWrite += siz;; 2506 fgBytesWrite += siz;; 2507 ; 2508 if (gMonitoringWriter); 2509 gMonitoringWriter->SendFileWriteProgress(this);; 2510 ; 2511 return kFALSE;; 2512 }; 2513 return kTRUE;; 2514}; 2515 ; 2516////////////////////////////////////////////////////////////////////////////////; 2517/// Write buffer via cache. Returns 0 if cache is not active, 1 in case; 2518/// write via cache was successful, 2 in case write via cache failed.; 2519 ; 2520Int_t TFile::WriteBufferViaCache(const char *buf, Int_t len); 2521{; 2522 if (!fCacheWrite) return 0;; 2523 ; 2524 Int_t st;; 2525 Long64_t off = GetRelOffset();; 2526 if ((st = fCacheWrite->WriteBuffer(buf, off, len)) < 0) {; 2527 SetBit(kWriteError);; 2528 Error(""WriteBuffer"", ""error writing to cache"");; 2529 return 2;; 2530 }; 2531 if (st > 0) {; 2532 // fOffset might have been changed via TFileCacheWrite::WriteBuffer(), reset it; 2533 Seek(off + len);; 2534 return 1;; 2535 }; 2536 return 0;; 2537}; 2538 ; 2539////////////////////////////////////////////////////////////////////////////////; 2540/// Write FREE linked list on the file.; 2541/// The linked list of FREE segments (fFree) is written as a single data; 2542/// record.; 2543 ; 2544void TFile::WriteFree(); 2545{; 2546 //*-* Delete old record if it exists; 2547 if (fSeekFree != 0) {; 2548 MakeFree(fSeekFree, fSeekFree + fNbytesFree -1);; 2549 }; 2550 ; 2551 Bool_t largeFile = (fEND > TFile::kStartBigFile);; 2552 ; 2553 auto createKey = [this]() {; 2554 Int_t nbytes = 0;; 2555 TFree *afree;; 2556 TIter next (fFree);; 2557 while ((afree = (TFree*) next())) {; 2558 nbytes += afree->Sizeof();; 2559 }; 2560 if (!nbytes) return (TKey*)nullptr;; 2561 ; 2562 TKey *key = new TKey(fName,fTitle,IsA(),nbytes,this);; 2563 ; 2564 if (key->GetSeekKey(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:89722,cache,cache,89722,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"kTime);; 566 printf(""ReadUZRT = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/fRealTime);; 567 printf(""ReadUZCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/fCpuTime);; 568 printf(""ReadRT = %7.3f MBytes/s\n"",1e-6*fBytesRead/fRealTime);; 569 printf(""ReadCP = %7.3f MBytes/s\n"",1e-6*fBytesRead/fCpuTime);; 570 if (unzip) {; 571 printf(""ReadStrCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/(fCpuTime-fUnzipTime));; 572 printf(""ReadZipCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/fUnzipTime);; 573 }; 574 if (basket); 575 PrintBasketInfo(option);; 576}; 577 ; 578////////////////////////////////////////////////////////////////////////////////; 579/// Print the TTree basket information; 580 ; 581void TTreePerfStats::PrintBasketInfo(Option_t *option) const; 582{; 583 ; 584 TString opts(option);; 585 opts.ToLower();; 586 bool all = opts.Contains(""allbasketinfo"");; 587 ; 588 TFile *file = fTree->GetCurrentFile();; 589 if (!file); 590 return;; 591 ; 592 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 593 if (!cache); 594 return;; 595 ; 596 auto branches = cache->GetCachedBranches();; 597 for (size_t i = 0; i < fBasketsInfo.size(); ++i) {; 598 const char *branchname = branches->At(i)->GetName();; 599 ; 600 printf("" br=%zu %s read not cached: "", i, branchname);; 601 if (fBasketsInfo[i].empty()) {; 602 printf(""none"");; 603 } else; 604 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 605 if (fBasketsInfo[i][j].fMissed); 606 printf(""%zu "", j);; 607 }; 608 printf(""\n"");; 609 ; 610 printf("" br=%zu %s cached more than once: "", i, branchname);; 611 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 612 auto &info(fBasketsInfo[i][j]);; 613 if ((info.fLoaded + info.fLoadedMiss) > 1); 614 printf(""%zu[%d,%d] "", j, info.fLoaded, info.fLoadedMiss);; 615 }; 616 printf(""\n"");; 617 ; 618 printf("" br=%zu %s cached but not used: "", i, branchname);; 619 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 620 auto &info(fBasketsInfo[i][j]);; 621 if ((info.f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:20978,cache,cache,20978,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,3,['cache'],['cache']
Performance,"kUseEventScan,; 151 kUseMonteCarloEvents };; 152 ; 153 // efficiency calculation method; 154 // - kUseEventSelection: computes efficiencies from given data sample; 155 // - kUsePDFs : creates smoothed PDFs from data samples, and; 156 // uses this to compute efficiencies; 157 enum EEffMethod { kUseEventSelection = 0,; 158 kUsePDFs };; 159 ; 160 // improve the Monte Carlo by providing some additional information; 161 enum EFitParameters { kNotEnforced = 0,; 162 kForceMin,; 163 kForceMax,; 164 kForceSmart };; 165 ; 166 // general; 167 TString fFitMethodS; ///< chosen fit method (string); 168 EFitMethodType fFitMethod; ///< chosen fit method; 169 TString fEffMethodS; ///< chosen efficiency calculation method (string); 170 EEffMethod fEffMethod; ///< chosen efficiency calculation method; 171 std::vector<EFitParameters>* fFitParams; ///< vector for series of fit methods; 172 Double_t fTestSignalEff; ///< used to test optimized signal efficiency; 173 Double_t fEffSMin; ///< used to test optimized signal efficiency; 174 Double_t fEffSMax; ///< used to test optimized signal efficiency; 175 Double_t* fCutRangeMin; ///< minimum of allowed cut range; 176 Double_t* fCutRangeMax; ///< maximum of allowed cut range; 177 std::vector<Interval*> fCutRange; ///< allowed ranges for cut optimisation; 178 ; 179 // for the use of the binary tree method; 180 BinarySearchTree* fBinaryTreeS;; 181 BinarySearchTree* fBinaryTreeB;; 182 ; 183 // MC method; 184 Double_t** fCutMin; ///< minimum requirement; 185 Double_t** fCutMax; ///< maximum requirement; 186 Double_t* fTmpCutMin; ///< temporary minimum requirement; 187 Double_t* fTmpCutMax; ///< temporary maximum requirement; 188 TString* fAllVarsI; ///< what to do with variables; 189 ; 190 // relevant for all methods; 191 Int_t fNpar; ///< number of parameters in fit (default: 2*Nvar); 192 Double_t fEffRef; ///< reference efficiency; 193 std::vector<Int_t>* fRangeSign; ///< used to match cuts to fit parameters (and vice versa); 194 TRandom* fRan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8h_source.html:6490,optimiz,optimized,6490,doc/master/MethodCuts_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8h_source.html,1,['optimiz'],['optimized']
Performance,"kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsData(); Destructor. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:14384,cache,cachedVars,14384,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,2,['cache'],"['cache', 'cachedVars']"
Performance,"kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsData(); Destructor. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events ins",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:14426,cache,cachedVars,14426,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,2,['cache'],"['cache', 'cachedVars']"
Performance,"kWriteDefinition TBuffer.h:73; TBuffer::kRead@ kReadDefinition TBuffer.h:73; TBuffer::fBufMaxchar * fBufMaxDefinition TBuffer.h:53; TBuffer::ReadStdStringvirtual void ReadStdString(std::string &s)Definition TBuffer.h:292; TBuffer::fBufCurchar * fBufCurDefinition TBuffer.h:52; TBuffer::ReadStaticArrayvirtual Int_t ReadStaticArray(Short_t *h)=0; TBuffer::ClassEndvirtual void ClassEnd(const TClass *)=0; TBuffer::WriteLong64virtual void WriteLong64(Long64_t l)=0; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::AutoExpandvoid AutoExpand(Int_t size_needed)Automatically calculate a new size and expand the buffer to fit at least size_needed.Definition TBuffer.cxx:158; TBuffer::IsWritingBool_t IsWriting() constDefinition TBuffer.h:87; TBuffer::WriteCharvirtual void WriteChar(Char_t c)=0; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char *classname)=0; TBuffer::ReadFastArrayvirtual void ReadFastArray(Bool_t *b, Int_t n)=0; TBuffer::PeekDataCachevirtual TVirtualArray * PeekDataCache() constReturn the 'current' data cache area from the list of area to be used for temporarily store 'missing'...Definition TBuffer.cxx:371; TBuffer::ReadStaticArrayvirtual Int_t ReadStaticArray(ULong64_t *l)=0; TBuffer::ReadClassBuffervirtual Int_t ReadClassBuffer(const TClass *cl, void *pointer, const TClass *onfile_class=nullptr)=0; TBuffer::WriteBoolvirtual void WriteBool(Bool_t b)=0; TBuffer::ReadFastArrayvirtual void ReadFastArray(Short_t *h, Int_t n)=0; TBuffer::ReadArrayvirtual Int_t ReadArray(Long_t *&l)=0; TBuffer::WriteArrayvirtual void WriteArray(const Long_t *l, Int_t n)=0; TBuffer::ReadClassBuffervirtual Int_t ReadClassBuffer(const TClass *cl, void *pointer, Int_t version, UInt_t start, UInt_t count, const TClass *onfile_class=nullptr)=0; TBuffer::kMinimalSize@ kMinimalSizeDefinition TBuffer.h:78; TBuffer::kInitialSize@ kInitialSizeDefinition TBuffer.h:78; TBuffer::WriteUShortvirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8h_source.html:36300,cache,cache,36300,doc/master/TBuffer_8h_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html,1,['cache'],['cache']
Performance,"kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from RooAbsData; bool allClientsCached (RooAbsArg *, const RooArgSet &);  Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ;  ; virtual void attachCache (const RooAbsArg *newOwner, const RooArgSet &cachedVars);  Internal method – Attach dataset copied with cache contents to copied instances of functions. ;  ; virtual void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false);  Internal method – Cache given set of functions with data. ;  ; double corrcov (const RooRealVar &x, const RooRealVar &y, const char *cutSpec, const char *cutRange, bool corr) const;  Internal method to calculate single correlation and covariance elements. ;  ; RooFit::OwningPtr< TMatrixDSym > corrcovMatrix (const RooArgList &vars, const char *cutSpec, const char *cutRange, bool corr) const;  Return covariance matrix from data for given list of observables. ;  ; RooRealVar * dataRealVar (const char *methodname, const RooReal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeData.html:24906,cache,cached,24906,doc/master/classRooTreeData.html,https://root.cern,https://root.cern/doc/master/classRooTreeData.html,1,['cache'],['cached']
Performance,"kZombie. protected:. Int_t_arrSizeSize of the weight array; Bool_t*_binValid! Valid bins with current range definition; vector<vector<Double_t> >_binbounds! list of bin bounds per dimension; Double_t*_binv[_arrSize] Bin volume array; TIterator*RooAbsData::_cacheIter! Iterator over cached variables; Double_t_cache_sum! Cache for sum of entries ;; Int_t_cache_sum_valid! Is cache sum valid; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; Int_t_curIndexCurrent index; Double_t_curSumW2Current sum of weights^2; Double_t_curVolumeVolume of bin enclosing current coordinate; Double_t_curWeightWeight associated with the current coordinate; Double_t_curWgtErrHiError on weight associated with the current coordinate; Double_t_curWgtErrLoError on weight associated with the current coordinate; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; Double_t*_errHi[_arrSize] High-side error on weight array; Double_t*_errLo[_arrSize] Low-side error on weight array; vector<Int_t>_idxMultMultiplier jump table for index calculation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; vector<const RooAbsBinning*>_lvbins! List of used binnings associated with lvalues; vector<RooAbsLValue*>_lvvars! List of observables casted as RooAbsLValue; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; vector<Double_t>*_pbinv! Partial bin volume array; RooCacheManager<vector<Double_t> >_pbinvCacheMgr! Cache manager for arrays of partial bin volumes; TIterator*_realIter! Iterator over realVars; RooArgSet_realVarsReal dimensions of the dataset; Double_t*_sumw2[_arrSize] Sum of weights^2; RooArgSetRooAbsData::_varsDimensions of this data set; Double_t*_wgt[_arrSize] Weight array; static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inher",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataHist.html:19269,cache,cached,19269,root/html602/RooDataHist.html,https://root.cern,https://root.cern/root/html602/RooDataHist.html,10,"['Cache', 'cache']","['Cache', 'cache', 'cached']"
Performance,"k[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:22097,cache,cache,22097,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,1,['cache'],['cache']
Performance,"ke a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; void FadeView (Float_t alpha);  Draw a rectangle (background color and given alpha) across the whole viewport. ;  ; void InitGL ();  Initialise GL state. ;  ; void MakeCurrent () const;  Make GL context current. ;  ; void PostDraw ();  Perform GL work which must be done after each draw. ;  ; void PreDraw ();  Perform GL work which must be done before each draw. ;  ; void SetupCameras (Bool_t reset);  Setup cameras for current bounding box. ;  ; void SetupClipObject () override;  allow simple guide axes labels to be scaled relative to scene units ;  ; void SetViewport (const TGLRect &vp);  ; void SetViewport (Int_t x, Int_t y, Int_t width, Int_t height);  Set viewer viewport (window area) with bottom/left at (x,y), with dimensions 'width'/'height'. ;  ; void SwapBuffers () const;  Swap GL buffers. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TGLViewerBase; SceneInfoList_i FindScene (TGLSceneBase *scene);  Find scene-info corresponding to scene. ;  ; void SubRenderScenes (SubRender_foo render_foo);  Call sub-rendering function render_foo on all currently visible scenes. ;  ;  Protected Member Fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewer.html:30981,Perform,Perform,30981,doc/master/classTGLViewer.html,https://root.cern,https://root.cern/doc/master/classTGLViewer.html,1,['Perform'],['Perform']
Performance,"ke; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const TFileCacheRead& ). void AddBranch(TBranch* , Bool_t = kFALSE); {}. void AddBranch(const char* , Bool_t = kFALSE); {}. Int_t GetBufferSize() const; { return fBufferSize; }. Int_t GetUnzipBuffer(char** , Long64_t , Int_t , Bool_t* ); { return -1; }. Bool_t IsAsyncReading() const; { return fAsyncReading; }. Bool_t IsLearning() const; {return kFALSE;}. void SetSkipZip(Bool_t = kTRUE); {}. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFileCacheRead.h 31503 2009-12-02 10:36:50Z brun $ » Last generated: 2010-09-23 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheRead.html:8712,cache,cache,8712,root/html528/TFileCacheRead.html,https://root.cern,https://root.cern/root/html528/TFileCacheRead.html,1,['cache'],['cache']
Performance,"keRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2PdfBinding<double,double,int>&operator=(const RooCFunction2PdfBinding<double,double,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_double_int_.html:23524,optimiz,optimizeCacheMode,23524,root/html602/RooCFunction2PdfBinding_double_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_double_int_.html,4,['optimiz'],['optimizeCacheMode']
Performance,"keRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2PdfBinding<double,int,double>&operator=(const RooCFunction2PdfBinding<double,int,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_double_.html:23524,optimiz,optimizeCacheMode,23524,root/html602/RooCFunction2PdfBinding_double_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_double_.html,4,['optimiz'],['optimizeCacheMode']
Performance,"keZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tRooAbsTestStatistic::numSets() const; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::operMode() const; virtual voidRooAbsArg::operModeHook(); voidRooAbsOptTestStatistic::optimizeCaching(); voidRooAbsOptTestStatistic::optimizeConstantTerms(Bool_t, Bool_t = kTRUE); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidRooAbsOptTestStatistic::printCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tRooAbsTestStatistic::processEmptyDataSets() const; virtual Bool_tRooAbsOptTestStatistic::redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:32823,optimiz,optimizeDirtyHook,32823,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,9,['optimiz'],['optimizeDirtyHook']
Performance,"keZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tRooAbsTestStatistic::numSets() const; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::operMode() const; virtual voidRooAbsArg::operModeHook(); voidRooAbsOptTestStatistic::optimizeCaching(); voidRooAbsOptTestStatistic::optimizeConstantTerms(Bool_t, Bool_t = kTRUE); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidRooAbsOptTestStatistic::printCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tprocessEmptyDataSets() const; virtual Bool_tRooAbsOptTestStatistic::redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNLLVar.html:32293,optimiz,optimizeDirtyHook,32293,root/html534/RooNLLVar.html,https://root.cern,https://root.cern/root/html534/RooNLLVar.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"keZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tRooAbsTestStatistic::numSets() const; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::operMode() const; virtual voidRooAbsArg::operModeHook(); voidRooAbsOptTestStatistic::optimizeCaching(); voidRooAbsOptTestStatistic::optimizeConstantTerms(Bool_t, Bool_t = kTRUE); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidRooAbsOptTestStatistic::printCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tprocessEmptyDataSets() const; virtual Bool_tRooAbsOptTestStatistic::redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNLLVar.html:30387,optimiz,optimizeDirtyHook,30387,root/html532/RooNLLVar.html,https://root.cern,https://root.cern/root/html532/RooNLLVar.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"kedList& terms, const RooLinkedList& norms, const RooLinkedList& imps, const RooLinkedList& ints, const RooLinkedList& cross) const; Group product into terms that can be calculated independently. RooAbsReal* processProductTerm(const RooArgSet* nset, const RooArgSet* iset, const char* isetRangeName, const RooArgSet* term, const RooArgSet& termNSet, const RooArgSet& termISet, Bool_t& isOwned, Bool_t forceWrap = kFALSE) const; Calculate integrals of factorized product terms over observables iset while normalized; to observables in nset. const char* makeRGPPName(const char* pfx, const RooArgSet& term, const RooArgSet& iset, const RooArgSet& nset, const char* isetRangeName) const; Make an appropriate automatic name for a RooGenProdProj object in getPartIntList(). Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all observables for internal integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Determine which part (if any) of given integral can be performed analytically.; If any analytical integration is possible, return integration scenario code. RooProdPdf implements two strategies in implementing analytical integrals. First, PDF components whose entire set of dependents are requested to be integrated; can be dropped from the product, as they will integrate out to 1 by construction. Second, RooProdPdf queries each remaining component PDF for its analytical integration; capability of the requested set ('allVars'). It finds the largest common set of variables; that can be integrated by all remaining components. If such a set exists, it reconfirms that; each component is capable of analytically integrating the common set, and combines the components; individual integration codes into a single integration code valid for RooProdPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdPdf.html:49746,perform,performed,49746,root/html526/RooProdPdf.html,https://root.cern,https://root.cern/root/html526/RooProdPdf.html,1,['perform'],['performed']
Performance,"kelihood. ;  ; RooArgSet _paramAbsMin;  Parameter values at absolute minimum. ;  ; std::map< std::string, bool > _paramFixed;  Parameter constant status at last time of use. ;  ; bool _startFromMin = true;  Always start minimization for global minimum? ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProfileLL.html:56849,Cache,Cache,56849,doc/master/classRooProfileLL.html,https://root.cern,https://root.cern/doc/master/classRooProfileLL.html,1,['Cache'],['Cache']
Performance,"kelihoodFit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:229; ROOT::Fit::Fitter::LinearFitbool LinearFit(const BinData &data)Do a linear fit copying the input data.Definition Fitter.h:247; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const std::shared_ptr< BinData > &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit NOT copying the input data.Definition Fitter.h:179; ROOT::Fit::Fitter::EvalFCNbool EvalFCN()Perform a simple FCN evaluation.Definition Fitter.cxx:288; ROOT::Fit::Fitter::fExtObjFunctionconst ROOT::Math::IMultiGenFunction * fExtObjFunction! pointer to an external FCNDefinition Fitter.h:576; ROOT::Fit::Fitter::operator=Fitter & operator=(const Fitter &)=deleteAssignment operator (disabled, class is not copyable); ROOT::Fit::Fitter::FitFCNbool FitFCN()Perform a fit with the previously set FCN function.Definition Fitter.cxx:269; ROOT::Fit::Fitter::DoUpdateFitConfigvoid DoUpdateFitConfig()Definition Fitter.cxx:860; ROOT::Fit::Fitter::DoMinimizationbool DoMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)do minimizationDefinition Fitter.cxx:836; ROOT::Fit::Fitter::DoSetFCNbool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize, int fitType)Set Objective function.Definition Fitter.cxx:137; ROOT::Fit::Fitter::fDataSizeint fDataSizesize of data sets (need for Fumili or LM fitters)Definition Fitter.h:560; ROOT::Fit::Fitter::DoUnbinnedLikelihoodFitbool DoUnbinnedLikelihoodFit(bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)un-binned likelihood fitDefinition Fitter.cxx:440; ROOT::Fit::Fitter::SetDatavoid SetData(const Data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:30378,Perform,Perform,30378,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['Perform'],['Perform']
Performance,"ken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_double_.html:3955,optimiz,optimized,3955,root/html528/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_double_.html,12,['optimiz'],['optimized']
Performance,"kernel regression estimate. Arguments:; grin: input graph. option: the kernel to be used: ""box"", ""normal""; bandwidth: the bandwidth. The kernels are scaled so that their quartiles; (viewed as probability densities) are at +/- 0.25*bandwidth.; nout: If xout is not specified, interpolation takes place at equally; spaced points spanning the interval [min(x), max(x)], where; nout = max(nout, number of input data).; xout: an optional set of values at which to evaluate the fit. void BDRksmooth(Double_t* x, Double_t* y, Int_t n, Double_t* xp, Double_t* yp, Int_t np, Int_t kernel, Double_t bw); Smooth data with specified kernel*-*-; *-* =================================. Based on R function ksmooth: Translated to C++ by C. Stratowa; (R source file: ksmooth.c by B.D.Ripley Copyright (C) 1998). -. TGraph * SmoothLowess(TGraph* grin, Option_t* option = """", Double_t span = 0.67, Int_t iter = 3, Double_t delta = 0); Smooth data with Lowess smoother*-*-. This function performs the computations for the LOWESS smoother; (see the reference below). Lowess returns the output points; x and y which give the coordinates of the smooth. Arguments:; grin: Input graph. span: the smoother span. This gives the proportion of points in the plot; which influence the smooth at each value.; Larger values give more smoothness.; iter: the number of robustifying iterations which should be performed.; Using smaller values of iter will make lowess run faster.; delta: values of x which lie within delta of each other replaced by a; single value in the output from lowess.; For delta = 0, delta will be calculated. References:; Cleveland, W. S. (1979) Robust locally weighted regression and smoothing; scatterplots. J. Amer. Statist. Assoc. 74, 829-836.; Cleveland, W. S. (1981) LOWESS: A program for smoothing scatterplots; by robust locally weighted regression.; The American Statistician, 35, 54. void Lowess(Double_t* x, Double_t* y, Int_t n, Double_t* ys, Double_t span, Int_t iter, Double_t delta); Lowess reg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphSmooth.html:8895,perform,performs,8895,root/html528/TGraphSmooth.html,https://root.cern,https://root.cern/root/html528/TGraphSmooth.html,4,['perform'],['performs']
Performance,"kes no sense, we should warn and return nothing instead.; 4733 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4734 }; 4735 ; 4736 if (!sinfo) {; 4737 // Let's take the first available StreamerInfo as a start; 4738 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4739 for (Int_t i = -1; sinfo == nullptr && i < ninfos; ++i); 4740 sinfo = (TVirtualStreamerInfo *)fStreamerInfo->UncheckedAt(i);; 4741 }; 4742 ; 4743 if (sinfo) {; 4744 sinfo = dynamic_cast<TVirtualStreamerInfo *>(sinfo->Clone());; 4745 if (sinfo) {; 4746 sinfo->SetClass(nullptr);; 4747 sinfo->SetName(newname);; 4748 sinfo->BuildCheck();; 4749 sinfo->BuildOld();; 4750 sinfo->GetClass()->AddRule(TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4751 } else {; 4752 Error(""GetStreamerInfoAbstractEmulated"", ""could not create TVirtualStreamerInfo"");; 4753 }; 4754 }; 4755 }; 4756 return sinfo;; 4757}; 4758 ; 4759////////////////////////////////////////////////////////////////////////////////; 4760/// For the case where the requestor class is emulated and this class is abstract,; 4761/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4762/// representation whether or not the class is loaded.; 4763///; 4764/// If the object does not exist, it is created; 4765///; 4766/// Warning: If we create a new streamer info, whether or not the build; 4767/// optimizes is controlled externally to us by a global variable!; 4768/// Don't call us unless you have set that variable properly; 4769/// with TStreamer::Optimize()!; 4770///; 4771 ; 4772TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4773{; 4774 TVirtualStreamerInfo *sinfo = nullptr;; 4775 ; 4776 TString newname(GetName());; 4777 newname += ""@@emulated"";; 4778 ; 4779 R__LOCKGUARD(gInterpreterMutex);; 4780 ; 4781 TClass *emulated = TClass::GetClass(newname);; 4782 ; 4783 if (emulated); 4784 sinfo = emulated->FindStreamerInfo(checksum);; 4785 ; 4786 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:180946,load,loaded,180946,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"kes no sense, we should warn and return nothing instead.; 4800 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4801 }; 4802 ; 4803 if (!sinfo) {; 4804 // Let's take the first available StreamerInfo as a start; 4805 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4806 for (Int_t i = -1; sinfo == nullptr && i < ninfos; ++i); 4807 sinfo = (TVirtualStreamerInfo *)fStreamerInfo->UncheckedAt(i);; 4808 }; 4809 ; 4810 if (sinfo) {; 4811 sinfo = dynamic_cast<TVirtualStreamerInfo *>(sinfo->Clone());; 4812 if (sinfo) {; 4813 sinfo->SetClass(nullptr);; 4814 sinfo->SetName(newname);; 4815 sinfo->BuildCheck();; 4816 sinfo->BuildOld();; 4817 sinfo->GetClass()->AddRule(TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4818 } else {; 4819 Error(""GetStreamerInfoAbstractEmulated"", ""could not create TVirtualStreamerInfo"");; 4820 }; 4821 }; 4822 }; 4823 return sinfo;; 4824}; 4825 ; 4826////////////////////////////////////////////////////////////////////////////////; 4827/// For the case where the requestor class is emulated and this class is abstract,; 4828/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4829/// representation whether or not the class is loaded.; 4830///; 4831/// If the object does not exist, it is created; 4832///; 4833/// Warning: If we create a new streamer info, whether or not the build; 4834/// optimizes is controlled externally to us by a global variable!; 4835/// Don't call us unless you have set that variable properly; 4836/// with TStreamer::Optimize()!; 4837///; 4838 ; 4839TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4840{; 4841 TVirtualStreamerInfo *sinfo = nullptr;; 4842 ; 4843 TString newname(GetName());; 4844 newname += ""@@emulated"";; 4845 ; 4846 R__LOCKGUARD(gInterpreterMutex);; 4847 ; 4848 TClass *emulated = TClass::GetClass(newname);; 4849 ; 4850 if (emulated); 4851 sinfo = emulated->FindStreamerInfo(checksum);; 4852 ; 4853 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:183697,load,loaded,183697,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"ket*) fBaskets.UncheckedAt(0);; 2287 if (basket) basket->MoveEntries(dentries);; 2288 fEntries = maxEntries;; 2289 fEntryNumber = maxEntries;; 2290 //loop on sub branches; 2291 Int_t nb = fBranches.GetEntriesFast();; 2292 for (Int_t i = 0; i < nb; ++i) {; 2293 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 2294 branch->KeepCircular(maxEntries);; 2295 }; 2296}; 2297 ; 2298////////////////////////////////////////////////////////////////////////////////; 2299/// Baskets associated to this branch are forced to be in memory.; 2300/// You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; 2301/// the system that the total size of the imported baskets does not; 2302/// exceed maxmemory bytes.; 2303///; 2304/// The function returns the number of baskets that have been put in memory.; 2305/// This method may be called to force all baskets of one or more branches; 2306/// in memory when random access to entries in this branch is required.; 2307/// See also TTree::LoadBaskets to load all baskets of all branches in memory.; 2308 ; 2309Int_t TBranch::LoadBaskets(); 2310{; 2311 Int_t nimported = 0;; 2312 Int_t nbaskets = fWriteBasket;; 2313 TFile *file = GetFile(0);; 2314 if (!file) return 0;; 2315 TBasket *basket;; 2316 for (Int_t i=0;i<nbaskets;i++) {; 2317 basket = (TBasket*)fBaskets.UncheckedAt(i);; 2318 if (basket) continue;; 2319 basket = GetFreshBasket(i, nullptr);; 2320 if (fBasketBytes[i] == 0) {; 2321 fBasketBytes[i] = basket->ReadBasketBytes(fBasketSeek[i],file);; 2322 }; 2323 Int_t badread = basket->ReadBasketBuffers(fBasketSeek[i],fBasketBytes[i],file);; 2324 if (badread) {; 2325 Error(""Loadbaskets"",""Error while reading basket buffer %d of branch %s"",i,GetName());; 2326 return -1;; 2327 }; 2328 ++fNBaskets;; 2329 fBaskets.AddAt(basket,i);; 2330 nimported++;; 2331 }; 2332 return nimported;; 2333}; 2334 ; 2335////////////////////////////////////////////////////////////////////////////////; 2336/// Print TBranch parameters; 2337///; 2338/// If options co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:83786,Load,LoadBaskets,83786,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,2,"['Load', 'load']","['LoadBaskets', 'load']"
Performance,"key for object and converts data to buffer. ;  ; void Delete (const char *namecycle="""") override;  Delete object namecycle. ;  ; void Draw (Option_t *option="""") override;  Fill Graphics Structure and Paint. ;  ; virtual void DrawMap (const char *keys=""*"", Option_t *option="""");  Draw map of objects in this file. ;  ; void FillBuffer (char *&buffer) override;  Encode file output buffer. ;  ; TArchiveFile * GetArchive () const;  ; Long64_t GetArchiveOffset () const;  ; Int_t GetBestBuffer () const;  Return the best buffer size of objects on this file. ;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; virtual Int_t GetBytesToPrefetch () const;  Max number of bytes to prefetch. ;  ; virtual Long64_t GetBytesWritten () const;  Return the total number of bytes written so far to the file. ;  ; TFileCacheRead * GetCacheRead (const TObject *tree=nullptr) const;  Return a pointer to the current read cache. ;  ; TFileCacheWrite * GetCacheWrite () const;  Return a pointer to the current write cache. ;  ; TArrayC * GetClassIndex () const;  ; Int_t GetCompressionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual TString GetNewUrl ();  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header starting at a certain postion. ;  ; Long64_t GetRelOffset () const;  ; virtual Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:5416,cache,cache,5416,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['cache'],['cache']
Performance,"key for object and converts data to buffer. ;  ; void Delete (const char *namecycle="""") override;  Delete object namecycle. ;  ; void Draw (Option_t *option="""") override;  Fill Graphics Structure and Paint. ;  ; virtual void DrawMap (const char *keys=""*"", Option_t *option="""");  Draw map of objects in this file. ;  ; void FillBuffer (char *&buffer) override;  Encode file output buffer. ;  ; TArchiveFile * GetArchive () const;  ; Long64_t GetArchiveOffset () const;  ; Int_t GetBestBuffer () const;  Return the best buffer size of objects on this file. ;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; virtual Int_t GetBytesToPrefetch () const;  Max number of bytes to prefetch. ;  ; virtual Long64_t GetBytesWritten () const;  Return the total number of bytes written so far to the file. ;  ; TFileCacheRead * GetCacheRead (const TObject *tree=nullptr) const;  Return a pointer to the current read cache. ;  ; TFileCacheWrite * GetCacheWrite () const;  Return a pointer to the current write cache. ;  ; TArrayC * GetClassIndex () const;  ; Int_t GetCompressionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual const TUrl * GetEndpointUrl () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header starting at a certain postion. ;  ; Long64_t GetRelOffset () const;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetXNGFile.html:3970,cache,cache,3970,doc/master/classTNetXNGFile.html,https://root.cern,https://root.cern/doc/master/classTNetXNGFile.html,1,['cache'],['cache']
Performance,"keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetCache(); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:12162,cache,cacheDir,12162,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,1,['cache'],['cacheDir']
Performance,"king the Event Status entry in the root canvas Options menu, you will see exactly which is the selected node in the bottom right. Right-clicking when a volume is selected will open its context menu where several actions can be performed (e.g. drawing it).; Q: “OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?”; A: Once you have set a convenient global visualization option and level, what you need is just call the Draw() method of your interesting volume. You can do this either by interacting with the expanded tree of volumes in a ROOT browser (where the context menu of any volume is available), either by getting a pointer to it (e.g. by name): gGeoManager->GetVolume(""vol_name"")->Draw();; 18.7.2 Visualization Settings and Attributes; Supposing you now understand the basic things to do for drawing the geometry or parts of it, you still might be not happy and wishing to have more control on it. We will describe below how you can fine-tune some settings. Since the corresponding attributes are flags belonging to volume and node objects, you can change them at any time (even when the picture is already drawn) and see immediately the result.; 18.7.2.1 Colors and Line Styles; We have already described how to change the line colors for volumes. In fact, volume objects inherit from TAttLine class so the line style or width can also be changed:; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; 18.7.2.2 Visibility Settings; The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together. One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning by its own:; myVolumeContainer->SetVisibility(kFALSE);; A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1009028,tune,tune,1009028,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['tune'],['tune']
Performance,"king these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setData(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override this to be always true to force calculation of likelihood without parameters. { return kTRUE ; }. void seal(const char* notice = """"); { _sealed = kTRUE ; _sealNotice = notice ; }. Bool_t isSealed() const; { return _sealed ; }. const char* sealNotice() const; { return _sealNotice.Data() ; }. Bool_t allowFunctionCache(); { return kTRUE ; }. RooArgSet requiredExtraObservables() const; { return RooArgSet() ; }. » Last changed: Wed Dec 8 11:39:35 2010 » Last generated: 2010-12-08 11:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsOptTestStatistic.html:38759,cache,cacheUniqueSuffix,38759,root/html528/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsOptTestStatistic.html,1,['cache'],['cacheUniqueSuffix']
Performance,"kly generate many branches. Each branch has its own buffer in memory. In case of many branches (say more than 100), you should adjust the buffer size accordingly. A recommended buffer size is 32000 bytes if you have less than 50 branches. Around 16000 bytes if you have less than 100 branches and 4000 bytes if you have more than 500 branches. These numbers are recommended for computers with memory size ranging from 32MB to 256MB. If you have more memory, you should specify larger buffer sizes. However, in this case, do not forget that your file might be used on another machine with a smaller memory configuration.; 12.10.1.2 Performance Considerations when Splitting a Branch; A split branch is faster to read, but slightly slower to write. The reading is quicker because variables of the same type are stored consecutively and the type does not have to be read each time. It is slower to write because of the large number of buffers as described above. See ""; Performance Benchmarks"" for performance impact of split and non-split mode.; 12.10.1.3 Rules for Splitting; When splitting a branch, variables of different types are handled differently. Here are the rules that apply when splitting a branch. If a data member is a basic type, it becomes one branch of class TBranchElement.; A data member can be an array of basic types. In this case, one single branch is created for the array.; A data member can be a pointer to an array of basic types. The length can vary, and must be specified in the comment field of the data member in the class definition. See “Input/Output”.; Pointer data member are not split, except for pointers to a TClonesArray. The TClonesArray (pointed to) is split if the split level is greater than two. When the split level is one, the TClonesArray is not split.; If a data member is a pointer to an object, a special branch is created. The branch will be filled by calling the class Streamer function to serialize the object into the branch buffer.; If a data member",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:544699,Perform,Performance,544699,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['Perform', 'perform']","['Performance', 'performance']"
Performance,"l 'id'. ; The skipChecks flag controls the consistency checks performed inspecting the AST. In some cases, we explicitly alter the datamembers in the typesystem with respect to the AST and therefore we must not enforce consistency. ; Definition at line 273 of file TListOfDataMembers.cxx. ◆ Get() [2/2]. TDictionary * TListOfDataMembers::Get ; (; DeclId_t ; id). Return (after creating it if necessary) the TDataMember describing the data member corresponding to the Decl 'id'. ; Definition at line 216 of file TListOfDataMembers.cxx. ◆ GetClass(). TClass * TListOfDataMembers::GetClass ; (; ); const. inline . Definition at line 90 of file TListOfDataMembers.h. ◆ IsA(). TClass * TListOfDataMembers::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from THashList.; Definition at line 102 of file TListOfDataMembers.h. ◆ IsLoaded(). Bool_t TListOfDataMembers::IsLoaded ; (; ); const. inline . Definition at line 79 of file TListOfDataMembers.h. ◆ Load(). void TListOfDataMembers::Load ; (; ). Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection. ; Definition at line 399 of file TListOfDataMembers.cxx. ◆ MapObject(). void TListOfDataMembers::MapObject ; (; TObject * ; obj). private . Add a pair<id, object> to the map of data members and their ids. ; Definition at line 50 of file TListOfDataMembers.cxx. ◆ operator=(). TListOfDataMembers & TListOfDataMembers::operator= ; (; const TListOfDataMembers & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfDataMembers::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:30814,Load,Load,30814,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,1,['Load'],['Load']
Performance,"l () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:14719,cache,cache,14719,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['cache'],['cache']
Performance,"l () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:14720,cache,cache,14720,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cache']
Performance,"l (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackage(const char* package); Unload specified package.; Returns 0 in case of success an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:62600,load,load,62600,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,3,['load'],['load']
Performance,"l (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Roo2DKeysPdf.html:40159,cache,cache,40159,root/html528/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html528/Roo2DKeysPdf.html,18,['cache'],['cache']
Performance,"l -- RooRealVar::setRange(x) new range named 'SIG' created with bounds [0,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'SIG' created with bounds [0,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'FULL' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'FULL' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'fit_nll_model_modelData' created with bounds [-10,0]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_SB1' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'fit_nll_model_modelData_SB1' created with bounds [-10,0]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_SB2' created with bounds [-10,0]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'fit_nll_model_modelData_SB2' created with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf312__multirangefit_8C.html:6343,optimiz,optimization,6343,doc/master/rf312__multirangefit_8C.html,https://root.cern,https://root.cern/doc/master/rf312__multirangefit_8C.html,2,['optimiz'],['optimization']
Performance,"l . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 1035 of file RooRealIntegral.cxx. Member Data Documentation. ◆ _anaList. RooSetProxy RooRealIntegral::_anaList. protected . Set of observables over which is integrated/summed analytically. ; Definition at line 119 of file RooRealIntegral.h. ◆ _cacheAllNDim. Int_t RooRealIntegral::_cacheAllNDim. staticprotected . ! Cache all integrals with given numeric dimension ; Definition at line 145 of file RooRealIntegral.h. ◆ _cacheNum. bool RooRealIntegral::_cacheNum = false. protected . Cache integral if numeric. ; Definition at line 144 of file RooRealIntegral.h. ◆ _facList. RooSetProxy RooRealIntegral::_facList. protected . Set of observables on which function does not depends, which are integrated nevertheless. ; Definition at line 121 of file RooRealIntegral.h. ◆ _funcNormSet. std::unique_ptr<RooArgSet> RooRealIntegral::_funcNormSet. protected . Optional normalization set passed to function. ; Definition at line 124 of file RooRealIntegral.h. ◆ _function. RooRealProxy RooRealIntegral::_function. protected . Function being integrated. ; Definition at line 123 of file RooRealIntegral.h. ◆ _iconfig. RooNumIntConfig* RooRealIntegral::_iconfig = nullptr. protected . Definition at line 129 of file RooRealIntegral.h. ◆ _intList. RooSetProxy RooRealIntegral::_intList. protected . Set of continuous observables over which is integrated numerically. ; Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:75686,Cache,Cache,75686,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['Cache'],['Cache']
Performance,"l ; (; ); const. inline . Definition at line 65 of file GeneticPopulation.h. ◆ GetGenes(). TMVA::GeneticGenes * TMVA::GeneticPopulation::GetGenes ; (; Int_t ; index). gives back the ""Genes"" of the population with the given index. ; Definition at line 194 of file GeneticPopulation.cxx. ◆ GetPopulationSize(). Int_t TMVA::GeneticPopulation::GetPopulationSize ; (; ); const. inline . Definition at line 62 of file GeneticPopulation.h. ◆ GetRanges() [1/2]. std::vector< TMVA::GeneticRange * > & TMVA::GeneticPopulation::GetRanges ; (; ). inline . Definition at line 69 of file GeneticPopulation.h. ◆ GetRanges() [2/2]. const std::vector< TMVA::GeneticRange * > & TMVA::GeneticPopulation::GetRanges ; (; ); const. inline . Definition at line 66 of file GeneticPopulation.h. ◆ GiveHint(). void TMVA::GeneticPopulation::GiveHint ; (; std::vector< Double_t > & ; hint, . Double_t ; fitness = 0 . ). add an individual (a set of variables) to the population if there is a set of variables which is known to perform good, they can be given as a hint to the population ; Definition at line 310 of file GeneticPopulation.cxx. ◆ IsA(). virtual TClass * TMVA::GeneticPopulation::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 104 of file GeneticPopulation.h. ◆ Log(). MsgLogger & TMVA::GeneticPopulation::Log ; (; ); const. inlineprivate . Definition at line 100 of file GeneticPopulation.h. ◆ MakeChildren(). void TMVA::GeneticPopulation::MakeChildren ; (; ). Creates children out of members of the current generation. ; Children have a combination of the coefficients of their parents ; Definition at line 119 of file GeneticPopulation.cxx. ◆ MakeCopies(). void TMVA::GeneticPopulation::MakeCopies ; (; int ; number). Produces offspring which is are copies of their parents. ; Parameters:; int number : the number of the last individual to be copied . Definition at line 104 of file GeneticPopulation.cxx. ◆ MakeSex(). TMVA::GeneticGenes TMVA::GeneticPopulation::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1GeneticPopulation.html:6698,perform,perform,6698,doc/master/classTMVA_1_1GeneticPopulation.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1GeneticPopulation.html,1,['perform'],['perform']
Performance,"l > 99) level = 99;; 2324 if (fCompress < 0) {; 2325 // if the algorithm is not defined yet use 0 as a default; 2326 fCompress = level;; 2327 } else {; 2328 int algorithm = fCompress / 100;; 2329 if (algorithm >= ROOT::RCompressionSetting::EAlgorithm::kUndefined) algorithm = 0;; 2330 fCompress = 100 * algorithm + level;; 2331 }; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335/// Used to specify the compression level and algorithm.; 2336///; 2337/// See the TFile constructor for the details.; 2338 ; 2339void TFile::SetCompressionSettings(Int_t settings); 2340{; 2341 fCompress = settings;; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// Set a pointer to the read cache.; 2346///; 2347/// <b>This relinquishes ownership</b> of the previous cache, so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:82772,cache,cache,82772,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,4,['cache'],['cache']
Performance,"l Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTChain::LoadBaskets(Long64_t maxmemory); virtual Long64_tTChain::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); voidTChain::Lookup(Bool_t force = kFALSE); virtual voidTChain::Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTChain::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTChain::Merge(const char* name, Option_t* option = """"); virtual Long64_tTChain::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTChain::Merge(TCollection* list, TFileMergeInfo* info); virtual Long64_tTChain::Merge(TFile* file, Int_t basketsize, Option_t* option = """"); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTTree::OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofChain.html:12725,Optimiz,OptimizeBaskets,12725,root/html530/TProofChain.html,https://root.cern,https://root.cern/root/html530/TProofChain.html,3,['Optimiz'],['OptimizeBaskets']
Performance,"l Double_texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_textendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:14749,cache,cacheList,14749,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,4,['cache'],['cacheList']
Performance,"l Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidSetProxy(const char* url); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebFile.html:11555,cache,cache,11555,root/html528/TWebFile.html,https://root.cern,https://root.cern/root/html528/TWebFile.html,1,['cache'],['cache']
Performance,"l Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:13314,cache,cache,13314,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,1,['cache'],['cache']
Performance,"l Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tRecover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t, TFile::ERelativeTo = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); static voidTXMLSetup::SetNameSpaceBase(const char* namespacebase); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLFile.html:13722,cache,cacheDir,13722,root/html528/TXMLFile.html,https://root.cern,https://root.cern/root/html528/TXMLFile.html,1,['cache'],['cacheDir']
Performance,"l Long64_t SetEntries(Long64_t n = -1);; 656 virtual void SetEstimate(Long64_t nentries = 1000000);; 657 ROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &);; 658 virtual void SetFileNumber(Int_t number = 0);; 659 virtual void SetEventList(TEventList* list);; 660 virtual void SetEntryList(TEntryList* list, Option_t *opt="""");; 661 virtual void SetImplicitMT(bool enabled) { fIMTEnabled = enabled; }; 662 virtual void SetMakeClass(Int_t make);; 663 virtual void SetMaxEntryLoop(Long64_t maxev = kMaxEntries) { fMaxEntryLoop = maxev; } // *MENU*; 664 static void SetMaxTreeSize(Long64_t maxsize = 100000000000LL);; 665 virtual void SetMaxVirtualSize(Long64_t size = 0) { fMaxVirtualSize = size; } // *MENU*; 666 void SetName(const char* name) override; // *MENU*; 667 ; 668 /**; 669 * @brief Sets the address of the object to be notified when the tree is loaded.; 670 *; 671 * The method TObject::Notify is called for the given object when the tree; 672 * is loaded. Specifically this occurs in the TTree::LoadTree method. To; 673 * remove the notification call this method with nullptr:; 674 * @code tree->SetNotify(nullptr); @endcode; 675 *; 676 * If this is a TChain, `obj` is most often going to be a TNotifyLink.; 677 *; 678 * @param[in] obj Pointer to a TObject to be notified.; 679 */; 680 virtual void SetNotify(TObject* obj);; 681 ; 682 virtual void SetObject(const char* name, const char* title);; 683 virtual void SetParallelUnzip(bool opt=true, Float_t RelSize=-1);; 684 virtual void SetPerfStats(TVirtualPerfStats* perf);; 685 /**; 686 * \brief Sets the default maximum number of lines to be shown before `<CR>` when calling Scan().; 687 * \param n the maximum number of lines. Default=50, if 0, all entries of the Tree are shown; 688 * and there is no need to press `<CR>` or `q` to exit the function.; 689 * \see TTreePlayer::Scan for more details on how to redirect the output to an ASCII file; 690 */; 691 virtual void SetScanField(Int_t n = 50) { fScanField = n; } // *MENU*; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:37997,Load,LoadTree,37997,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['Load'],['LoadTree']
Performance,"l ROOT files; 1.9 JSROOT with THttpServer; 1.10 Data monitoring with JSROOT; 1.11 JSROOT API. JavaScript ROOT; *** Sergey Linev GSI, Darmstadt ***; 1 JavaScript ROOT; The JSROOT project allows: - reading of binary and JSON ROOT files in JavaScript; - drawing of different ROOT classes in web browsers; - reading and drawing TTree data; - using in node.js.; 1.1 Installing JSROOT; In most practical cases it is not necessary to install JSROOT - it can be used directly from project web sites https://root.cern/js/ and https://jsroot.gsi.de/.; When required, there are following alternatives to install JSROOT on other web servers:. download and unpack provided packages (recommended); use npm package manager and invoke npm install jsroot; clone master branch from repository. 1.2 Drawing objects in JSROOT; The main page of the JSROOT project provides the possibility to interactively open ROOT files and draw objects like histogram or canvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs’, ‘gridNxM’, ‘horizNMK’, ‘vertNMK’; browser - layout of the browser ‘fix’ (default), ‘float’, ‘no’ (hidden), ‘off’ (fully disabled); nobrowser - do not display file browser (same as browser=no); float - display floating browser (same as browser=float); status - configure status line ‘no’ (defaul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:1269,load,loading,1269,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['load'],['loading']
Performance,"l ROOT::Experimental::Internal::RVirtualCanvasPainter::AddPanel ; (; std::shared_ptr< ROOT::RWebWindow > ; ). inlinevirtual . Reimplemented in ROOT::Experimental::RCanvasPainter.; Definition at line 79 of file RVirtualCanvasPainter.hxx. ◆ CanvasUpdated(). virtual void ROOT::Experimental::Internal::RVirtualCanvasPainter::CanvasUpdated ; (; uint64_t ; , . bool ; , . CanvasCallback_t ;  . ). pure virtual . indicate that canvas changed, provides current version of the canvas ; Implemented in ROOT::Experimental::RCanvasPainter. ◆ Create(). std::unique_ptr< RVirtualCanvasPainter > RVirtualCanvasPainter::Create ; (; RCanvas & ; canv). static . Loads the plugin that implements this class. ; Definition at line 42 of file RVirtualCanvasPainter.cxx. ◆ DoWhenReady(). virtual void ROOT::Experimental::Internal::RVirtualCanvasPainter::DoWhenReady ; (; const std::string & ; , . const std::string & ; , . bool ; , . CanvasCallback_t ;  . ). pure virtual . perform special action when drawing is ready ; Implemented in ROOT::Experimental::RCanvasPainter. ◆ GetGenerator(). std::unique_ptr< RVirtualCanvasPainter::Generator > & RVirtualCanvasPainter::GetGenerator ; (; ). staticprotected . generator getter ; Definition at line 35 of file RVirtualCanvasPainter.cxx. ◆ GetWindowAddr(). virtual std::string ROOT::Experimental::Internal::RVirtualCanvasPainter::GetWindowAddr ; (; ); const. pure virtual . Implemented in ROOT::Experimental::RCanvasPainter. ◆ GetWindowUrl(). virtual std::string ROOT::Experimental::Internal::RVirtualCanvasPainter::GetWindowUrl ; (; bool ; remote). pure virtual . Implemented in ROOT::Experimental::RCanvasPainter. ◆ IsCanvasModified(). virtual bool ROOT::Experimental::Internal::RVirtualCanvasPainter::IsCanvasModified ; (; uint64_t ; ); const. pure virtual . return true if canvas modified since last painting ; Implemented in ROOT::Experimental::RCanvasPainter. ◆ NewDisplay(). virtual void ROOT::Experimental::Internal::RVirtualCanvasPainter::NewDisplay ; (; const std::str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RVirtualCanvasPainter.html:3602,perform,perform,3602,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RVirtualCanvasPainter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RVirtualCanvasPainter.html,1,['perform'],['perform']
Performance,"l RooAddition::setData ; (; RooAbsData & ; data, . bool ; cloneData = true . ). overridevirtual . Reimplemented from RooAbsReal.; Definition at line 241 of file RooAddition.cxx. ◆ Streamer(). void RooAddition::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooAddition::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 76 of file RooAddition.h. ◆ translate(). void RooAddition::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 160 of file RooAddition.cxx. Member Data Documentation. ◆ _cacheMgr. RooObjCacheManager RooAddition::_cacheMgr. mutableprotected . ! The cache manager ; Definition at line 72 of file RooAddition.h. ◆ _ownedList. RooArgList RooAddition::_ownedList. protected . List of owned components. ; Definition at line 63 of file RooAddition.h. ◆ _set. RooListProxy RooAddition::_set. protected . set of terms to be summed ; Definition at line 64 of file RooAddition.h. Libraries for RooAddition:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooAddition.h; roofit/roofitcore/src/RooAddition.cxx. RooAddition. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:42 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:67839,cache,cache,67839,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,1,['cache'],['cache']
Performance,"l TGeoVolume * MakeCopyVolume (TGeoShape *newshape);  make a copy of this volume build a volume with same name, shape and medium ;  ; TGeoVolume * MakeReflectedVolume (const char *newname="""") const;  Make a copy of this volume which is reflected with respect to XY plane. ;  ; Bool_t OptimizeVoxels ();  Perform an extensive sampling to find which type of voxelization is most efficient. ;  ; void Paint (Option_t *option="""") override;  paint volume ;  ; void Print (Option_t *option="""") const override;  Print volume info. ;  ; void PrintNodes () const;  print nodes ;  ; void PrintVoxels () const;  Print the voxels for this volume. ;  ; void RandomPoints (Int_t npoints=1000000, Option_t *option="""");  Draw random points in the bounding box of this volume. ;  ; void RandomRays (Int_t nrays=10000, Double_t startx=0, Double_t starty=0, Double_t startz=0, const char *target_vol=nullptr, Bool_t check_norm=kFALSE);  Random raytracing method. ;  ; void Raytrace (Bool_t flag=kTRUE);  Draw this volume with current settings and perform raytracing in the pad. ;  ; void RegisterYourself (Option_t *option="""");  Register the volume and all materials/media/matrices/shapes to the manager. ;  ; void Release ();  ; void RemoveNode (TGeoNode *node);  Remove an existing daughter. ;  ; TGeoNode * ReplaceNode (TGeoNode *nodeorig, TGeoShape *newshape=nullptr, TGeoMatrix *newpos=nullptr, TGeoMedium *newmed=nullptr);  Replace an existing daughter with a new volume having the same name but possibly a new shape, position or medium. ;  ; void ReplayCreation (const TGeoVolume *other);  Recreate the content of the other volume without pointer copying. ;  ; void ResetTransparency (Char_t transparency=-1);  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Save geometry having this as top volume as a C++ macro. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SelectVolume (Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:21135,perform,perform,21135,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,2,['perform'],['perform']
Performance,"l TObjString*TMacro::GetLineWith(const char* text) const; TList*TMacro::GetListOfLines() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Bool_tTMacro::Load() constMENU ; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEveMacro&operator=(const TEveMacro&); virtual voidTMacro::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTMacro::Print(Option_t* option = """") constMENU ; virtual Int_tTObject::Read(const char* name); virtual Int_tTMacro::ReadFile(const char* filename); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidResetRoot(); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveMacro.html:3060,Load,Load,3060,root/html602/TEveMacro.html,https://root.cern,https://root.cern/root/html602/TEveMacro.html,2,['Load'],['Load']
Performance,"l advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 1105 of file RooNDKeysPdf.cxx. ◆ getWeights(). TMatrixD RooNDKeysPdf::getWeights ; (; const int & ; k); const. Return evaluated weights. ; Definition at line 1291 of file RooNDKeysPdf.cxx. ◆ initialize(). void RooNDKeysPdf::initialize ; (; RooDataSet const & ; data). protected . initialization ; Definition at line 406 of file RooNDKeysPdf.cxx. ◆ IsA(). TClass * RooNDKeysPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 198 of file RooNDKeysPdf.h. ◆ loadDataSet(). void RooNDKeysPdf::loadDataSet ; (; bool ; firstCall, . RooDataSet const & ; data . ). protected . copy the dataset and calculate some useful variables ; Definition at line 476 of file RooNDKeysPdf.cxx. ◆ loadWeightSet(). void RooNDKeysPdf::loadWeightSet ; (; RooDataSet const & ; data). protected . Definition at line 696 of file RooNDKeysPdf.cxx. ◆ loopRange(). void RooNDKeysPdf::loopRange ; (; std::vector< double > & ; x, . std::vector< Int_t > & ; indices . ); const. protected . determine closest points to x, to loop over in evaluate() ; Definition at line 974 of file RooNDKeysPdf.cxx. ◆ mirrorDataSet(). void RooNDKeysPdf::mirrorDataSet ; (; ). protected . determine mirror dataset. ; mirror points are added around the physical boundaries of the dataset Two steps:; For each entry, determine if it should be mirrored (the mirror configuration).; For each mirror configuration, make the mirror points. . Definition at line 607 of file RooNDKeysPdf.cxx. ◆ setOptions(). void RooNDKeysPdf::setOptions ; (; ). protected ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNDKeysPdf.html:88036,load,loadDataSet,88036,doc/master/classRooNDKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooNDKeysPdf.html,1,['load'],['loadDataSet']
Performance,"l and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableTh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:26378,concurren,concurrent,26378,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"l arguments like in POSIX read(). ;  ; Long64_t SysSeek (Int_t, Long64_t, Int_t) final;  Interface to system lseek. ;  ; Int_t SysStat (Int_t, Long_t *, Long64_t *, Long_t *, Long_t *) final;  Return file stat information. ;  ; Int_t SysSync (Int_t) final;  Interface to system fsync. All arguments like in POSIX fsync(). ;  ; Int_t SysWrite (Int_t, const void *, Int_t) final;  Interface to system write. All arguments like in POSIX write(). ;  ;  Protected Member Functions inherited from TFile; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual void Init (Bool_t create);  Initialize a TFile object. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inherited from TDirectoryFile; void BuildDirectoryFile (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.) ;  ; void InitDirectoryFile (TClass *cl=nullptr);  Initialize the key associated with this directory (and the related data members. ;  ;  Protected Member Functions inherited from TDirectory;  TDirectory (const TDirectory &directory)=delete;  ; void BuildDirectory (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; Bool_t cd1 (const char *path);  flag to add histograms, graphs,etc to the directory ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.). ;  ; void FillFullPath (TString &buf) const;  Recursive method to fill full path for direct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:35514,cache,cache,35514,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['cache'],['cache']
Performance,"l as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same model parameter results in a number that is not easily interpreted.; If both regions correct their interpretation such that N_expected refers to the full range, it is interpreted easily, and consistent in both regions.; This requires that the likelihood model is extended using RooAddPdf in the form SumPdf = Nsig * sigPdf + Nbkg * bkgPdf. ; import ROOT; ; ROOT.gROOT.SetBatch(True); ; # PART 1: Background-only fits; # ----------------------------; ; # Build plain exponential model; x = ROOT.RooRealVar(""x"", ""x"", 10, 100); alpha = ROOT.RooRealVar(""alpha"", ""alpha"", -0.04, -0.1, -0.0); model = ROOT.RooExponential(""model"", ""Exponential model"", x, alpha); ; # Define side band regions and full range; x.setRange(""LEFT"", 10, 20); x.setRange(""RIGHT"", 60, 100); ; x.setRange(""FULL"", 10, 100); ; data = model.generate(x, 10000); ; # Construct an extended pdf, which me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html:1697,perform,performed,1697,doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,1,['perform'],['performed']
Performance,"l as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same model parameter results in a number that is not easily interpreted.; If both regions correct their interpretations such that N_expected refers to the full range, it is interpreted easily, and consistent in both regions.; This requires that the likelihood model is extended using RooAddPdf in the form SumPdf = Nsig * sigPdf + Nbkg * bkgPdf. ; #include ""RooRealVar.h""; #include ""RooExponential.h""; #include ""RooGaussian.h""; #include ""RooAddPdf.h""; #include ""RooDataSet.h""; #include ""RooPlot.h""; #include ""RooExtendPdf.h""; #include ""RooFitResult.h""; ; #include ""TCanvas.h""; ; void rf204b_extendedLikelihood_rangedFit(); {; using namespace RooFit;; ; // PART 1: Background-only fits; // ----------------------------; ; // Build plain exponential model; RooRealVar x(""x"", ""x"", 10, 100);; RooRealVar alpha(""alpha"", ""alpha"", -0.04, -0.1, -0.0);; RooExponential model(""mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html:1684,perform,performed,1684,doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,1,['perform'],['performed']
Performance,"l be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSize(Int_t buffsize); -- Reset the basket size for all sub-branches of this branch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetOffset(Int_t offset); Set offset of the object (to which the data member represented by this; branch belongs) inside its containing object (if any). void SetReadActionSequence(); Set the sequence of actions needed to read the data out of the buffer. void SetReadLeavesPtr(); Set the ReadLeaves pointer to execute the expected operations. void SetTargetClassName(const char* name); Set the name of the class of the in-memory object into which the data will; loaded. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void Streamer(TBuffer& b); -- Stream an object of class TBranchElement. Int_t Unroll(const char* name, TClass* cltop, TClass* cl, char* ptr, Int_t basketsize, Int_t splitlevel, Int_t btype); -- Split class cl into sub-branches of this branch. Create a sub-branch of this branch for each non-empty,; non-abstract base class of cl (unless we are a sub-branch; of a TClonesArray or an STL container, in which case we; do *not* create a sub-branch), and for each non-split data; member of cl. Note: We do *not* create sub-branches for base classes of cl; if we are a sub-branch of a TClonesArray or an STL container. Note: We do *not* create sub-branches for data members which; have a class type and which we are splitting.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchElement.html:30736,load,loaded,30736,root/html528/TBranchElement.html,https://root.cern,https://root.cern/root/html528/TBranchElement.html,1,['load'],['loaded']
Performance,"l be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void reserve(Int_t nEvt). void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kTRUE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void forceCacheUpdate(). void recalculateCache(const RooArgSet* , Int_t firstEvent, Int_t lastEvent, Int_t stepSize, Bool_t skipZeroWeights). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& ); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:15560,cache,cacheArgs,15560,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,9,"['Cache', 'cache']","['Cache', 'cache', 'cacheArgs']"
Performance,"l configuration for the TMVA session.; For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in the; option string; ; - note that we disable any pre-transformation of the input variables and we avoid computing correlations between; input variables; ***/; ; TMVA::Factory factory(; ""TMVA_CNN_Classification"", outputFile,; ""!V:ROC:!Silent:Color:AnalysisType=Classification:Transformations=None:!Correlations"");; ; /***; ; ## Declare DataLoader(s); ; The next step is to declare the DataLoader class that deals with input variables; ; Define the input variables that shall be used for the MVA training; note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; ; In this case the input data consists of an image of 16x16 pixels. Each single pixel is a branch in a ROOT TTree; ; **/; ; TMVA::DataLoader loader(""dataset"");; ; /***; ; ## Setup Dataset(s); ; Define input data file and signal and background trees; ; **/; ; std::unique_ptr<TFile> inputFile{TFile::Open(inputFileName)};; if (!inputFile) {; Error(""TMVA_CNN_Classification"", ""Error opening input file %s - exit"", inputFileName.Data());; return;; }; ; // --- Register the training and test trees; ; auto signalTree = inputFile->Get<TTree>(""sig_tree"");; auto backgroundTree = inputFile->Get<TTree>(""bkg_tree"");; ; if (!signalTree) {; Error(""TMVA_CNN_Classification"", ""Could not find signal tree in file '%s'"", inputFileName.Data());; return;; }; if (!backgroundTree) {; Error(""TMVA_CNN_Classification"", ""Could not find background tree in file '%s'"", inputFileName.Data());; return;; }; ; int nEventsSig = signalTree->GetEntries();; int nEventsBkg = backgroundTree->GetEntries();; ; // global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight);; loader.Add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:50684,load,loader,50684,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['load'],['loader']
Performance,"l curves. ;  ; void shiftCurveToZero ();  Find lowest point in curve and move all points in curve so that lowest point will go exactly through zero. ;  ;  Protected Member Functions inherited from TGraph; virtual Double_t ** Allocate (Int_t newsize);  Allocate internal data structures for newsize points. ;  ; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; virtual void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);  Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin != iend. ;  ; virtual Bool_t CopyPoints (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);  Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; virtual Bool_t DoMerge (const TGraph *g);  protected function to perform the merge operation of a graph ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; virtual void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE);  Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ; virtual void SwapPoints (Int_t pos1, Int_t pos2);  Swap points. ;  ; virtual void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low);  Upda",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCurve.html:36522,perform,perform,36522,doc/master/classRooCurve.html,https://root.cern,https://root.cern/doc/master/classRooCurve.html,1,['perform'],['perform']
Performance,"l datasets that match given uri. void ShowDataSets(const char* uri = """", const char* = 0); Shows datasets in locations that match the uri; By default shows the user's datasets and global ones. TFileCollection * GetDataSet(const char* uri, const char* = 0); Get a list of TFileInfo objects describing the files of the specified; dataset. Int_t RemoveDataSet(const char* uri, const char* = 0); Remove the specified dataset from the PROOF cluster.; Files are not deleted. Int_t VerifyDataSet(const char* uri, const char* = 0); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). void SendInputDataFile(); Make sure that the input data objects are available to the workers in a; dedicated file in the cache; the objects are taken from the dedicated list; and / or the specified file.; If the fInputData is empty the specified file is sent over.; If there is no specified file, a file named ""inputdata.root"" is created locally; with the content of fInputData and sent over to the master.; If both fInputData and the specified file are not empty, a copy of the file; is made locally and augmented with the content of fInputData. Int_t Remove(const char* ref, Bool_t all); Handle remove request. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TProofLite(const TProofLite& ). void operator=(const TProofLite& ). TProofLite(); { }. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); { return TProof::Process(fc, sel, o, nent, fst); }. Long64_t Process(const char* dsname, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0, TObject* enl = 0); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:31529,cache,cache,31529,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['cache'],['cache']
Performance,"l datasets that match given uri. void ShowDataSets(const char* uri = """", const char* = 0); Shows datasets in locations that match the uri; By default shows the user's datasets and global ones. TFileCollection * GetDataSet(const char* uri, const char* = 0); Get a list of TFileInfo objects describing the files of the specified; dataset. Int_t RemoveDataSet(const char* uri, const char* = 0); Remove the specified dataset from the PROOF cluster.; Files are not deleted. Int_t VerifyDataSet(const char* uri, const char* = 0); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). void SendInputDataFile(); Make sure that the input data objects are available to the workers in a; dedicated file in the cache; the objects are taken from the dedicated list; and / or the specified file.; If the fInputData is empty the specified file is sent over.; If there is no specified file, a file named ""inputdata.root"" is created locally; with the content of fInputData and sent over to the master.; If both fInputData and the specified file are not empty, a copy of the file; is made locally and augmented with the content of fInputData. Int_t Remove(const char* ref, Bool_t all); Handle remove request. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. void FindUniqueSlaves(); Add to the fUniqueSlave list the active slaves that have a unique; (user) file system image. This information is used to transfer files; only once to nodes that share a file system (an image). Submasters; which are not in fUniqueSlaves are put in the fNonUniqueMasters; list. That list is used to trigger the transferring of files to; the submaste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:31992,cache,cache,31992,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,2,['cache'],['cache']
Performance,"l definition of the TClass class. More...;  ; static UInt_t ClassTableHash (const char *name, UInt_t size);  ; int CompressionSettings (RCompressionSetting::EAlgorithm algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: More...;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). More...;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). More...;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). More...;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. More...;  ; void EnableThreadSafety ();  Enables the global mutex to make ROOT thread safe/aware. More...;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (ROOT::Internal::TStringView str, T &value);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. More...;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:7279,multi-thread,multi-threading,7279,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,3,['multi-thread'],['multi-threading']
Performance,"l estimation sum; Double_t_n16pow(_nEvents, -1/6); Int_t_nEvents; Double_t_norm; Double_t_sqrt2pi; Int_t_verbosedebug; Int_t_vverbosedebug; Double_t_widthScaleFactorallow manipulation of the bandwidth by a scale factor; Double_t*_x; Double_t_xMeanthe (x,y) mean and sigma are properties of the data, not of the PDF; Double_t_xSigma; Double_t_xoffset; Double_t*_y; Double_t_yMean; Double_t_ySigma; Double_t_yoffset. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Roo2DKeysPdf(const char* name, const char* title, RooAbsReal& xx, RooAbsReal& yy, RooDataSet& data, TString options = ""a"", Double_t widthScaleFactor = 1.0). Roo2DKeysPdf(const Roo2DKeysPdf& other, const char* name = 0). ~Roo2DKeysPdf(). Int_t loadDataSet(RooDataSet& data, TString options). void setOptions(TString options). void getOptions(void). Int_t calculateBandWidth(Int_t kernel = -999). Double_t evaluate() const; use the cacheing intrinsic in RFC to bypass the grid and remove; the grid and extrapolation approximation in the kernel estimation method; implementation - cheers Wouter :). Double_t evaluateFull(Double_t thisX, Double_t thisY) const. Double_t highBoundaryCorrection(Double_t thisVar, Double_t thisH, Double_t high, Double_t tVar) const. Double_t lowBoundaryCorrection(Double_t thisVar, Double_t thisH, Double_t low, Double_t tVar) const. Double_t g(Double_t var1, Double_t* _var1, Double_t sigma1, Double_t var2, Double_t* _var2, Double_t sigma2) const. Int_t getBandWidthType() const. Double_t getMean(const char* axis) const. Double_t getSigma(const char* axis) const. void writeToFile(char* outputFile, const char* name) const. void writeHistToFile(char* outputFile, const char* histName) const. void writeNTupleToFile(char* outputFile, const char* name) const. void PrintInfo(ostream& ) const. void setWidthScaleFactor(Double_t widthScaleFactor); { _widthScaleFactor = widthScaleFactor; }. TObject* clone(const char* newname) const; { return new Roo2DKeysPdf(*this,new",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Roo2DKeysPdf.html:41392,cache,cacheing,41392,root/html526/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html526/Roo2DKeysPdf.html,5,['cache'],['cacheing']
Performance,"l files.Definition TFile.cxx:4574; TFile::ReadBufferViaCacheInt_t ReadBufferViaCache(char *buf, Int_t len)Read buffer via cache.Definition TFile.cxx:1889; TFile::CreateKeyvirtual TKey * CreateKey(TDirectory *mother, const TObject *obj, const char *name, Int_t bufsize)Creates key for object and converts data to buffer.Definition TFile.cxx:1047; TFile::Mapvirtual void Map()Definition TFile.h:267; TFile::WriteFreevirtual void WriteFree()Write FREE linked list on the file.Definition TFile.cxx:2543; TFile::GetReadaheadSizestatic Int_t GetReadaheadSize()Static function returning the readahead buffer size.Definition TFile.cxx:4599; TFile::~TFile~TFile() overrideFile destructor.Definition TFile.cxx:563; TFile::ReadBuffersvirtual Bool_t ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf)Read the nbuf blocks described in arrays pos and len.Definition TFile.cxx:1821; TFile::GetFileCounterstatic Long64_t GetFileCounter()Definition TFile.cxx:4617; TFile::fCacheReadMapTMap * fCacheReadMap!Pointer to the read cache (if any)Definition TFile.h:99; TFile::fBEGINLong64_t fBEGINFirst used byte in file.Definition TFile.h:78; TFile::MakeProjectParProofInfInt_t MakeProjectParProofInf(const char *packname, const char *proofinfdir)Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.Definition TFile.cxx:3486; TFile::WriteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)Check if the ProcessID pidd is already in the file, if not, add it and return the index number in the...Definition TFile.cxx:3763; TFile::MakeProjectvirtual void MakeProject(const char *dirname, const char *classes=""*"", Option_t *option=""new"")Generate source code necessary to access the objects stored in the file.Definition TFile.cxx:2726; TFile::fArchiveOffsetLong64_t fArchiveOffset!Offset at which file starts in archiveDefinition TFile.h:101; TFile::kEternalTimeout@ kEternalTimeoutDefinition TFile.h:67; TFile::fNbytesInfoInt_t fNbytesInfoNumber of bytes for StreamerInfo record.Definition TFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:217999,cache,cache,217999,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"l fitting; # -------------------------------; ; # In parallel mode the likelihood calculation is split in N pieces,; # that are calculated in parallel and added a posteriori before passing; # it back to MINUIT.; ; # Use four processes and time results both in wall time and CPU time; model.fitTo(data, NumCPU=4, Timer=True, PrintLevel=-1); ; # Parallel MC projections; # ----------------------------------------------; ; # Construct signal, likelihood projection on (y,z) observables and; # likelihood ratio; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Calculate likelihood ratio for each event, subset of events with high; # signal likelihood; data.addColumn(llratio_func); dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame and plot data; frame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf603__multicpu_8py.html:2276,Perform,Perform,2276,doc/master/rf603__multicpu_8py.html,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html,1,['Perform'],['Perform']
Performance,"l geometry objects defined in a session; therefore, users must not try to control their deletion. It contains lists of media, materials, transformations, shapes and volumes. A special case is the one of geometrical transformations. When creating a matrix or a translation, this is by default owned by external objects. The manager class becomes owner of all transformations used for positioning volumes. In order to force the ownership for other transformations, one can use TGeoMatrix::RegisterYourself() method. Do not be therefore surprised that some transformations cannot be found by name when creating a composite shape for instance if you did not register them after creation.; Logical nodes (positioned volumes) are created and destroyed by the TGeoVolume class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The total number of physical instances of volumes triggers the caching mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:65059,cache,cache,65059,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['cache'],['cache']
Performance,"l geometry objects defined in a session; therefore, users must not try to control their deletion. It contains lists of media, materials, transformations, shapes and volumes. A special case is the one of geometrical transformations. When creating a matrix or a translation, this is by default owned by external objects. The manager class becomes owner of all transformations used for positioning volumes. In order to force the ownership for other transformations, one can use TGeoMatrix::RegisterYourself() method. Do not be therefore surprised that some transformations cannot be found by name when creating a composite shape for instance if you did not register them after creation.; Logical nodes (positioned volumes) are created and destroyed by the TGeoVolume class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The total number of physical instances of volumes triggers the caching mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions.; 18.5 Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:970125,cache,cache,970125,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['cache'],['cache']
Performance,"l in /usr/lib sometimes take priority); [#13041] - TVirtualFitter::GetFitter() unexpectedly returns NULL on macOS 12 and 13 with Xcode 14; [#13019] - LLVM assertion failure in HandleUnionActiveMemberChange; [#12993] - std::source_location not working in the interpreter; [#12959] - [ntuple] Distinguish between connecting a page sink and a page source in RColumn; [#12783] - [IO] Writing HistFactory model file twice gives strange results since ROOT 6.26.02; [#12770] - tmva/sofie_parsers does not build with latest Protobuf (22.x); [#12744] - wrong Python version found during build; [#12718] - A crash when trying to initialise a vector from a >1D numpy array in PyROOT; [#12685] - TEnum::GetEnum does NOT process typedefs; [#12644] - Can’t find cxxabi.h and build module ‘ROOT_Foundation_Stage1_NoRTTI’ when building from source on Macos; [#12631] - Unable to build master with external XROOTD; [#12621] - [I/O][RDF] Usage of xrootd from multi-thread event loops runs into severe bottlenecks; [#12592] - [doc] TProfile bin error documentation is not correct; [#12591] - Allow partial enablement of modules; [#12527] - MacOS build fails if configured without cocoa; [#12492] - The problem with building ROOT v6-26-10 in debug mode on ubuntu 20.04; [#12230] - Wrong conversion from Numpy Array to std.vector when using the wrong type; [#12091] - TSpline SaveAs not using equidistant and loss of precision; [#11924] - PyROOT: wrong overload resolution for C++ functions from python; [#11901] - Binary distribution for Ubutu 22.04 is broken (on WSL2); [#11750] - FindXROOTD adds libraries to link against irrespective of xrootd version used; [#11746] - TH2::Fill(const char namex, const char namey, Double_t w) doesn’t update fTsumwxy; [#11743] - CMake >= 3.24 fails to build LZMA: WARNING: ‘aclocal-1.15’ is missing on your system.; [#11673] - [ntuple] Consider making REntry::AddValue() publicly accessible; [#11667] - [cling] GetClassSharedLibs fails to find several classes; [#11653] - TFile plugin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:33771,multi-thread,multi-thread,33771,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,2,"['bottleneck', 'multi-thread']","['bottlenecks', 'multi-thread']"
Performance,"l integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,bool>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction4Binding_double_double_double_double_bool_.html:32661,cache,cache,32661,root/html526/RooCFunction4Binding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html526/RooCFunction4Binding_double_double_double_double_bool_.html,2,['cache'],['cache']
Performance,"l integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; vector<double>_low; static Int_tRooPrintable::_nameLength; double_nominal; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_paramIter! do not persist; RooListProxy_paramList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__LinInterpVar.html:32656,cache,cache,32656,root/html532/RooStats__HistFactory__LinInterpVar.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__LinInterpVar.html,2,['cache'],['cache']
Performance,"l match +; sub-pattern matches.; nMaxMatch is the maximum allowed number of matches.; pos contains the string indices of the matches. Its usage is; shown in the routine MatchS.; For meaning of mods see ParseMods(). TObjArray * MatchS(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Returns a TObjArray of matched substrings as TObjString's.; The TObjArray is owner of the objects and must be deleted by the user.; The first entry is the full matched pattern, followed by the subpatterns.; If a pattern was not matched, it will return an empty substring:. TObjArray *subStrL = TPRegexp(""(a|(z))(bc)"").MatchS(""abc"");; for (Int_t i = 0; i < subStrL->GetLast()+1; i++) {; const TString subStr = ((TObjString *)subStrL->At(i))->GetString();; cout << ""\"""" << subStr << ""\"" "";; }; cout << subStr << endl;. produces: ""abc"" ""a"" """" ""bc""; For meaning of mods see ParseMods(). Int_t SubstituteInternal(TString& s, const TString& replace, Int_t start, Int_t nMaxMatch0, Bool_t doDollarSubst); Perform pattern substitution with optional back-ref replacement; - protected method. Int_t Substitute(TString& s, const TString& replace, const TString& mods = """", Int_t start = 0, Int_t nMatchMax = 10); Substitute replaces the string s by a new string in which matching; patterns are replaced by the replacePattern string. The number of; substitutions are returned. TString s(""aap noot mies"");; const Int_t nrSub = TPRegexp(""(\\w*) noot (\\w*)"").Substitute(s,""$2 noot $1"");; cout << nrSub << "" \"""" << s << ""\"""" <<endl;. produces: 2 ""mies noot aap""; For meaning of mods see ParseMods(). Bool_t IsValid() const; Returns true if underlying PCRE structure has been successfully; generated via regexp compilation. Bool_t GetThrowAtCompileError(); Get value of static flag controlling whether exception should be thrown upon an; error during regular expression compilation by the PCRE engine. void SetThrowAtCompileError(Bool_t throwp); Set static flag controlling whether exception should",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPRegexp.html:5379,Perform,Perform,5379,root/html534/TPRegexp.html,https://root.cern,https://root.cern/root/html534/TPRegexp.html,1,['Perform'],['Perform']
Performance,"l our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Jun 30 14:29:56 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:49409,cache,cache,49409,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,3,['cache'],['cache']
Performance,"l platforms when the flagOpenGL.CanvasPreferGL is set to 1; in $ROOTSYS/etc/system.rootrc, or on Mac with the Cocoa backend. On the file output; it is visible with PDF, PNG, Gif, JPEG, SVG ... but not PostScript.; Marker style; The Marker style defines the markers' shape.; The marker style of any class inheriting from TAttMarker can; be changed using the method SetMarkerStyle and retrieved using the; method GetMarkerStyle.; The following list gives the currently supported markers (screen; and PostScript) style. Each marker style is identified by an integer number; (first column) corresponding to a marker shape (second column) and can be also; accessed via a global name (third column). Marker number Marker shape Marker name; 1 dot kDot; 2 + kPlus; 3 * kStar; 4 o kCircle; 5 x kMultiply; 6 small dot kFullDotSmall; 7 medium dot kFullDotMedium; 8 large scalable dot kFullDotLarge; 9 -->19 large scalable dot; 20 full circle kFullCircle; 21 full square kFullSquare; 22 full triangle up kFullTriangleUp; 23 full triangle down kFullTriangleDown; 24 open circle kOpenCircle; 25 open square kOpenSquare; 26 open triangle up kOpenTriangleUp; 27 open diamond kOpenDiamond; 28 open cross kOpenCross; 29 full star kFullStar; 30 open star kOpenStar; 31 *; 32 open triangle down; 33 full diamond; 34 full cross. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; TMarker marker;; marker.DisplayMarkerTypes();; return c;; }. Marker size; Various marker sizes are shown in the figure below. The default marker size=1; is shown in the top left corner. Marker sizes smaller than 1 can be; specified. The marker size does not refer to any coordinate systems, it is an; absolute value. Therefore the marker size is not affected by any change; in TPad's scale. A marker size equl to 1 correspond to 8 pixels.; That is, a square marker with size 1 will be drawn with a side equal to 8; pixels on the screen.; The marker size of any class inheriting from TAttMarker can; be changed usi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TAttMarker.html:2126,scalab,scalable,2126,root/html534/TAttMarker.html,https://root.cern,https://root.cern/root/html534/TAttMarker.html,6,['scalab'],['scalable']
Performance,"l pointing to the H1 data directory.; }; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33. Case B: Loop on all events; Root > chain.Draw(""h1analysisProxy.C""). Case C: Same as B, but in addition fill the event list with selected entries.; The event list is saved to a file ""elist.root"" by the Terminate function. To see the list of selected events, you can do elist->Print(""all""). The selection function has selected 7525 events out of the 283813 events in the chain of files. (2.65 per cent) Root > chain.Draw(""h1analysisProxy.C"","""",""fillList""); ; Case D: Process only entries in the event list; The event list is read from the file in elist.root generated by step C Root > chain.Draw(""h1analysisProxy.C"","""",""useList""); The commands executed with the 3 different methods B,C and D produce two canvases shown below: begin_html the Dstar plot end_html begin_html the Tau D0 plot end_html; ; TEntryList *elist;; Bool_t useList, fillList;; TH1F *hdmd;; TH2F *h2;; ; ; void h1analysisProxy_Begin(TTree *tree); {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the event list; ; //print the option specified in the Process function.; TString option = GetOption();; printf(""Starting (begin) h1analysis with process option: %s\n"",option.Data());; ; //process cases with event list; fillList = kFALSE;; useList = kFALSE;; if (fChain) fChain->SetEntryList(0);; delete gDirectory->GetList()->FindObject(""elist"");; ; // case when one creates/fills the event list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; elist = new TEntryList(""elist"",""H1 selection from Cut"");; // Add to the input list for processing in PROOF, if needed; if (fInput) {; fInput->Add(new TNamed(""fillList"",""""));; fInput->Add(elist);; }; } else elist = 0;; ; // case when one uses the event list generated in a previous call; if (option.Contains(""useList"")) {; useList = kTRUE;; if (fInput) {; tree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisProxy_8C.html:4406,perform,performs,4406,doc/master/h1analysisProxy_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisProxy_8C.html,1,['perform'],['performs']
Performance,"l sets the default TTreeCache prefilling type. The prefill type may be: 0 for no prefilling and 1 to prefill all the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL; In particular the default can be set back to the same as in version 5 by setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill (or ROOT_TTREECACHE_PREFILL) both to zero.; TTree methods which are expected to modify a cache, like AddBranchToCache, will attempt to setup a cache of default size if one does not exist, irrespective of whether the auto cache creation is enabled. Additionally several methods giving control of the cache have changed return type from void to Int_t, to be able to return a code to indicate if there was an error.; Usually TTree::SetCacheSize will no longer reset the list of branches to be cached (either set or previously learnt) nor restart the learning phase. The learning phase is restarted when a new cache is created, e.g. after having removed a cache with SetCacheSize(0).; TSelectorDraw; The axis titles in case of a x:y:z plot with the option COLZ were not correct.; TParallelCoordVar; Change the format used to print the variables limit for ||-Coord to %g. It was %6.4f before.; Histogram Libraries; TFormula. New version of the TFormula class based on Cling. Formula expressions are now used to create functions which are passed to Cling to be Just In Time compiled. The expression is therefore compiled using Clang/LLVVM which will give execution time as compiled code and in addition correctness of the result obtained.; This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as =ROOT::v5::TFormula=. Some of the TFormula member funtions available in version 5, such as =Analyze= and =AnalyzeFunction= are not available in the new TFormula class. On the other hand formula expressions which were valid in version 5 are still valid in TFormula version 6; TFormula is not anymore a base class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:14139,cache,cache,14139,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['cache'],['cache']
Performance,"l the rules that are about the given 'source' class.Definition TSchemaRuleSet.cxx:289; ROOT::Detail::TSchemaRuleSet::HasRuleWithSourceClassBool_t HasRuleWithSourceClass(const TString &source) constReturn True if we have any rule whose source class is 'source'.Definition TSchemaRuleSet.cxx:199; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::GetTargetconst TObjArray * GetTarget() constGet the target data members of this rule (i.e. the in memory data member).Definition TSchemaRule.cxx:520; TArrayCArray of chars or bytes (8 bits per element).Definition TArrayC.h:27; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; TBaseClass::GetDeltaInt_t GetDelta()Get offset from ""this"" to part of base class.Definition TBaseClass.cxx:75; TBaseClass::IsSTLContainerROOT::ESTLType IsSTLContainer()Return which type (if any) of STL container the data member is.Definition TBaseClass.cxx:101; TBaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBaseClass::GetTitleconst char * GetTitle() const overrideGet base class description (comment).Definition TBaseClass.cxx:92; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::ReadVersionvirtual Version_t ReadVersion(UInt_t *start=nullptr, UInt_t *bcnt=nullptr, const TClass *cl=nullptr)=0; TBuffer::ClassBeginvirtual void ClassBegin(const TClass *, Version_t=-1)=0; TBuffer::SetByteCountvirtual void SetByteCount(UInt_t cntpos, Bool_t packInVersion=kFALSE)=0; TBuffer::GetParentTObject * GetParent() constReturn pointer to parent of this buffer.Definition TBuffer.cxx:262; TBuffer::WriteObjectAnyvirtual Int_t WriteObjectAny(const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE)=0; TBuffer::ClassEndvirtual void ClassEnd(const TClass *)=0; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::ClassMem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:246913,load,load,246913,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['load']
Performance,"l the split level. ; Definition at line 817 of file TTree.cxx. ◆ ~TTree(). TTree::~TTree ; (; ). override . Destructor. ; Definition at line 920 of file TTree.cxx. ◆ TTree() [3/3]. TTree::TTree ; (; const TTree & ; tt). delete . Member Function Documentation. ◆ AddAllocationCount(). void TTree::AddAllocationCount ; (; UInt_t ; count). inline . Definition at line 337 of file TTree.h. ◆ AddBranchToCache() [1/2]. Int_t TTree::AddBranchToCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Add branch with name bname to the Tree cache. ; If bname=""*"" all branches are added to the cache. if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1059 of file TTree.cxx. ◆ AddBranchToCache() [2/2]. Int_t TTree::AddBranchToCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Add branch b to the Tree cache. ; if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file. When a TFriendElement TF is added to the list of friends of an existing TTree T, any variable from TF can be referenced in a query to T.; A tree keeps a list of friends. In the context of a tree (or a ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:69874,cache,cache,69874,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['cache'],['cache']
Performance,"l threads should be used for sending data; 146 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 147 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 148 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 149 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 150 ConnectionsList_t fConn; ///<! list of all accepted connections; 151 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 152 unsigned fConnLimit{1}; ///<! number of allowed active connections; 153 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 154 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 155 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 156 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 157 WebWindowConnectCallback_t fConnCallback; ///<! callback for connect event; 158 WebWindowDataCallback_t fDataCallback; ///<! main callback when data over channel 1 is arrived; 159 WebWindowConnectCallback_t fDisconnCallback; ///<! callback for disconnect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:7443,queue,queue,7443,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,5,"['Queue', 'queue']","['QueueEntry', 'queue']"
Performance,"l threads should be used for sending data; 149 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 150 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 151 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 152 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 153 ConnectionsList_t fConn; ///<! list of all accepted connections; 154 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 155 unsigned fConnLimit{1}; ///<! number of allowed active connections; 156 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 157 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 158 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 159 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 160 WebWindowConnectCallback_t fConnCallback; ///<! callback for connect event; 161 WebWindowDataCallback_t fDataCallback; ///<! main callback when data over channel 1 is arrived; 162 WebWindowConnectCallback_t fDisconnCallback; ///<! callback for disconnect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:7594,queue,queue,7594,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,5,"['Queue', 'queue']","['QueueEntry', 'queue']"
Performance,"l values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; RooIntegralMorph::MorphCacheElem*_cacheCurrent morph cache element in use; Bool_t_cacheAlphaIf true, both (x,alpha) are cached; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Preven",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:45283,cache,cache,45283,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,1,['cache'],['cache']
Performance,"l void SetCompressionSettings(Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault)Used to specify the compression level and algorithm.Definition TFile.cxx:2338; TFile::GetCompressionLevelInt_t GetCompressionLevel() constDefinition TFile.h:391; TFile::fgReadInfostatic Bool_t fgReadInfoif true (default) ReadStreamerInfo is called when opening a fileDefinition TFile.h:135; TFile::Initvirtual void Init(Bool_t create)Initialize a TFile object.Definition TFile.cxx:613; TFile::TFileTFile(const TFile &)=delete; TFile::GetRelOffsetLong64_t GetRelOffset() constDefinition TFile.h:251; TFile::SetReadCallsvirtual void SetReadCalls(Int_t readcalls=0)Definition TFile.h:290; TFile::AsyncOpenstatic TFileOpenHandle * AsyncOpen(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Submit an asynchronous open request.Definition TFile.cxx:4351; TFile::SetCacheWritevirtual void SetCacheWrite(TFileCacheWrite *cache)Set a pointer to the write cache.Definition TFile.cxx:2388; TFile::fOptionTString fOptionFile options.Definition TFile.h:91; TFile::GetNfreevirtual Int_t GetNfree() constDefinition TFile.h:238; TFile::GetENDvirtual Long64_t GetEND() constDefinition TFile.h:231; TFile::WriteBuffervirtual Bool_t WriteBuffer(const char *buf, Int_t len)Write a buffer to the file.Definition TFile.cxx:2476; TFile::SumBuffervoid SumBuffer(Int_t bufsize)Increment statistics for buffer sizes of objects in this file.Definition TFile.cxx:2417; TFile::GetCacheFileDirstatic const char * GetCacheFileDir()Get the directory where to locally stage/cache remote files.Definition TFile.cxx:4654; TFile::EAsyncOpenStatusEAsyncOpenStatusAsynchronous open request status.Definition TFile.h:64; TFile::kAOSSuccess@ kAOSSuccessDefinition TFile.h:65; TFile::kAOSNotAsync@ kAOSNotAsyncDefinition TFile.h:64; TFile::kAOSInProgress@ kAOSInProgressDefinition TFile.h:65; TFile::kAOSFailure@ kAOSFailureDefinition TF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:37593,cache,cache,37593,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,2,['cache'],['cache']
Performance,"l void TH1::SetEntries ; (; Double_t ; n). inlinevirtual . Definition at line 391 of file TH1.h. ◆ SetError(). void TH1::SetError ; (; const Double_t * ; error). virtual . Replace bin errors by values in array error. ; Definition at line 8951 of file TH1.cxx. ◆ SetHighlight(). void TH1::SetHighlight ; (; Bool_t ; set = kTRUE). virtual . Set highlight (enable/disable) mode for the histogram by default highlight mode is disable. ; Definition at line 4482 of file TH1.cxx. ◆ SetLabelColor(). void TH1::SetLabelColor ; (; Color_t ; color = 1, . Option_t * ; axis = ""X"" . ). virtual . Set axis labels color. ; axis specifies which axis (""x"",""y"",""z""), default = ""x"" if axis=""xyz"" set all 3 axes ; Definition at line 226 of file Haxis.cxx. ◆ SetLabelFont(). void TH1::SetLabelFont ; (; Style_t ; font = 62, . Option_t * ; axis = ""X"" . ). virtual . Set font number used to draw axis labels. ; font : Text font code = 10*fontnumber + precision Font numbers must be between 1 and 14 precision = 1 fast hardware fonts (steps in the size) precision = 2 scalable and rotatable hardware fonts; The default font number is 62. axis specifies which axis (""x"",""y"",""z""), default = ""x"" if axis=""xyz"" set all 3 axes ; Definition at line 249 of file Haxis.cxx. ◆ SetLabelOffset(). void TH1::SetLabelOffset ; (; Float_t ; offset = 0.005, . Option_t * ; axis = ""X"" . ). virtual . Set offset between axis and axis' labels. ; The offset is expressed as a percent of the pad height. axis specifies which axis (""x"",""y"",""z""), default = ""x"" if axis=""xyz"" set all 3 axes ; Definition at line 267 of file Haxis.cxx. ◆ SetLabelSize(). void TH1::SetLabelSize ; (; Float_t ; size = 0.02, . Option_t * ; axis = ""X"" . ). virtual . Set size of axis' labels. ; The size is expressed as a percent of the pad height. axis specifies which axis (""x"",""y"",""z""), default = ""x"" if axis=""xyz"" set all 3 axes ; Definition at line 285 of file Haxis.cxx. ◆ SetMaximum(). virtual void TH1::SetMaximum ; (; Double_t ; maximum = -1111). inlinevirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:213157,scalab,scalable,213157,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['scalab'],['scalable']
Performance,"l voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TH2GL(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2GL.html:2180,cache,cached,2180,root/html602/TH2GL.html,https://root.cern,https://root.cern/root/html602/TH2GL.html,2,['cache'],['cached']
Performance,"l voidInitBranches(Long64_t entry); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tTTree::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); char*MakeX(Int_t nvars); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTTree::OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THbookTree.html:12782,Optimiz,OptimizeBaskets,12782,root/html530/THbookTree.html,https://root.cern,https://root.cern/root/html530/THbookTree.html,3,['Optimiz'],['OptimizeBaskets']
Performance,"l voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidexpand(). Data Members; protected:. RooSetPair*_asArr! do not persist; RooHashTable*_htable! do not persist; RooNameSet_name1!; RooNameSet_name2!; Int_t_nreg; Int_t_regSize; TNamed*_set2RangeName!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNormSetCache(Int_t regSize); Construct normalization set manager with given initial size. RooNormSetCache(const RooNormSetCache& other); Copy constructor. ~RooNormSetCache(); Destructor. void clear(); Clear contents. void initialize(const RooNormSetCache& other); Initialize cache from contents of given other cache. void add(const RooArgSet* set1, const RooArgSet* set2 = 0); Add given pair of RooArgSet pointers to our store. void expand(); Expand registry size by doubling capacity. Bool_t autoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); If RooArgSets set1 and set2 or sets with similar contents have; been seen by this cache manager before return kFALSE If not,; return kTRUE. If sets have not been seen and doRefill is true,; update cache reference to current input sets. Int_t index(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0). Bool_t contains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0). Bool_t containsSet1(const RooArgSet* set1). const RooArgSet* lastSet1() const; { return _nreg>0?_asArr[_nreg-1]._set1:0 ; }. const RooArgSet* lastSet2() const; { return _nreg>0?_asArr[_nreg-1]._set2:0 ; }. const RooNameSet& nameSet1() const; { return _name1 ; }. const RooNameSet& nameSet2() const; { return _name2 ; }. Int_t entries() const; { return _nreg ; }. » Last changed: Mon Dec 7 13:48:27 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general plea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNormSetCache.html:3096,cache,cache,3096,root/html526/RooNormSetCache.html,https://root.cern,https://root.cern/root/html526/RooNormSetCache.html,1,['cache'],['cache']
Performance,"l voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; voidgetCompIntList(const RooArgSet* nset, const RooArgSet* iset, RooAddModel::pRooArgList& compIntList, Int_t& code, const char* isetRangeName) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAddModel::CacheElem*getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddModel.html:35662,Cache,CacheElem,35662,root/html602/RooAddModel.html,https://root.cern,https://root.cern/root/html602/RooAddModel.html,2,['Cache'],['CacheElem']
Performance,"l voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; voidgetCompIntList(const RooArgSet* nset, const RooArgSet* iset, RooAddModel::pRooArgList& compIntList, Int_t& code, const char* isetRangeName) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAddModel::CacheElem*getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:35673,Cache,CacheElem,35673,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,1,['Cache'],['CacheElem']
Performance,"l voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofLimitsFinder&operator=(const TProofLimitsFinder&); static voidTHLimitsFinder::Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static voidTHLimitsFinder::OptimizeLimits(Int_t nbins, Int_t& newbins, Double_t& xmin, Double_t& xmax, Bool_t isInteger); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTHLimitsFinder::SetLimitsFinder(THLimitsFinder* finder); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLimitsFinder.html:3926,Optimiz,Optimize,3926,root/html602/TProofLimitsFinder.html,https://root.cern,https://root.cern/root/html602/TProofLimitsFinder.html,2,['Optimiz'],['Optimize']
Performance,"l voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTFormula::IsLinear(); virtual Bool_tTFormula::IsNormalized(); Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Bool_tok(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); voidTFormula::Optimize(); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual voidTFormula::ProcessLinear(TString& replaceformula); virtual Int_tTObject::Read(const char* name); Bool_treCompile(const char* newFormula); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::Rese",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFormula.html:5656,Optimiz,Optimize,5656,root/html526/RooFormula.html,https://root.cern,https://root.cern/root/html526/RooFormula.html,2,['Optimiz'],['Optimize']
Performance,"l voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidsetAlwaysStartFromMin(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProfileLL.html:24717,cache,cache,24717,root/html534/RooProfileLL.html,https://root.cern,https://root.cern/root/html534/RooProfileLL.html,3,['cache'],['cache']
Performance,"l void IgnoreInterrupt (Bool_t ignore=kTRUE);  If ignore is true ignore the interrupt signal, else restore previous behaviour. ;  ; virtual void IgnoreSignal (ESignals sig, Bool_t ignore=kTRUE);  If ignore is true ignore the specified signal, else restore previous behaviour. ;  ; Bool_t InControl () const;  ; virtual Bool_t Init ();  Initialize the OS interface. ;  ; virtual void InnerLoop ();  Inner event loop. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsAbsoluteFileName (const char *dir);  Return true if dir is an absolute pathname. ;  ; virtual Bool_t IsFileInIncludePath (const char *name, char **fullpath=nullptr);  Return true if 'name' is a file that can be found in the ROOT include path or the current directory. ;  ; virtual Bool_t IsPathLocal (const char *path);  Returns TRUE if the url in 'path' points to the local file system. ;  ; virtual int Link (const char *from, const char *to);  Create a link from file1 to file2. ;  ; virtual void ListLibraries (const char *regexp="""");  List the loaded shared libraries. ;  ; virtual void ListSymbols (const char *module, const char *re="""");  List symbols in a shared library. ;  ; virtual int Load (const char *module, const char *entry="""", Bool_t system=kFALSE);  Load a shared library. ;  ; virtual UInt_t LoadAllLibraries ();  Load all libraries known to ROOT via the rootmap system. ;  ; virtual int MakeDirectory (const char *name);  Make a directory. ;  ; virtual int mkdir (const char *name, Bool_t recursive=kFALSE);  Make a file system directory. ;  ; virtual Long_t NextTimeOut (Bool_t mode);  Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms). ;  ; virtual void NotifyApplicationCreated ();  Hook to tell TSystem that the TApplication object has been created. ;  ; virtual TTime Now ();  Get current time in milliseconds since 0:00 Jan 1 1995. ;  ; virtual int OpenConnection (const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"");  Open a co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:12931,load,loaded,12931,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['load'],['loaded']
Performance,"l void IgnoreInterrupt (Bool_t ignore=kTRUE);  If ignore is true ignore the interrupt signal, else restore previous behaviour. ;  ; virtual void IgnoreSignal (ESignals sig, Bool_t ignore=kTRUE);  If ignore is true ignore the specified signal, else restore previous behaviour. ;  ; Bool_t InControl () const;  ; virtual Bool_t Init ();  Initialize the OS interface. ;  ; virtual void InnerLoop ();  Inner event loop. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsAbsoluteFileName (const char *dir);  Return true if dir is an absolute pathname. ;  ; virtual Bool_t IsFileInIncludePath (const char *name, char **fullpath=nullptr);  Return true if 'name' is a file that can be found in the ROOT include path or the current directory. ;  ; virtual Bool_t IsPathLocal (const char *path);  Returns TRUE if the url in 'path' points to the local file system. ;  ; virtual int Link (const char *from, const char *to);  Create a link from file1 to file2. ;  ; virtual void ListLibraries (const char *regexp="""");  List the loaded shared libraries. ;  ; virtual void ListSymbols (const char *module, const char *re="""");  List symbols in a shared library. ;  ; virtual int Load (const char *module, const char *entry="""", Bool_t system=kFALSE);  Load a shared library. ;  ; virtual UInt_t LoadAllLibraries ();  Load all libraries known to ROOT via the rootmap system. ;  ; virtual int mkdir (const char *name, Bool_t recursive=kFALSE);  Make a file system directory. ;  ; virtual Long_t NextTimeOut (Bool_t mode);  Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms). ;  ; virtual void NotifyApplicationCreated ();  Hook to tell TSystem that the TApplication object has been created. ;  ; virtual TTime Now ();  Get current time in milliseconds since 0:00 Jan 1 1995. ;  ; virtual int OpenConnection (const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"");  Open a connection to another host. ;  ; virtual void Openlog (const char *name,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetSystem.html:12603,load,loaded,12603,doc/master/classTNetSystem.html,https://root.cern,https://root.cern/doc/master/classTNetSystem.html,2,['load'],['loaded']
Performance,"l! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static TEveElement::EDestructTEveElement::kAnnihilate; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"); Constructor. void AfterNewEventLoaded(); Virtual function to be called after a new event is loaded.; It iterates over the list of registered commands; (fNewEventCommands) and executes them in given order. void AddNewEventCommand(const TString& cmd); Register a command to be executed on each new event. void RemoveNewEventCommand(const TString& cmd); Remove the first command equal to cmd. void ClearNewEventCommands(); Clear the list of commands to be executed on each new event. TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"). virtual ~TEveEventManager(); {}. std::vector<TString>& GetNewEventCommands(); { return fNewEventCommands; }. void Open(); {}. void GotoEvent(Int_t ); {}. void NextEvent(); {}. void PrevEvent(); {}. void Close(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveEventManager.html:21132,load,loaded,21132,root/html604/TEveEventManager.html,https://root.cern,https://root.cern/root/html604/TEveEventManager.html,1,['load'],['loaded']
Performance,"l! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static TEveElement::EDestructTEveElement::kAnnihilate; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"); Constructor. void AfterNewEventLoaded(); Virtual function to be called after a new event is loaded.; It iterates over the list of registered commands; (fNewEventCommands) and executes them in given order. void AddNewEventCommand(const TString& cmd); Register a command to be executed on each new event. void RemoveNewEventCommand(const TString& cmd); Remove the first command equal to cmd. void ClearNewEventCommands(); Clear the list of commands to be executed on each new event. TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"). virtual ~TEveEventManager(); {}. std::vector<TString>& GetNewEventCommands(); { return fNewEventCommands; }. void Open(); {}. void GotoEvent(Int_t ); {}. void NextEvent(); {}. void PrevEvent(); {}. void Close(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 14:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveEventManager.html:21132,load,loaded,21132,root/html602/TEveEventManager.html,https://root.cern,https://root.cern/root/html602/TEveEventManager.html,1,['load'],['loaded']
Performance,"l() ;; 1082 if (hdim==3) ccoutW(Plotting) << "" [z]="" << zvar->getVal() ;; 1083 ccoutW(Plotting) << std::endl ;; 1084 // RooAbsReal::printEvalErrors(ccoutW(Plotting),10) ;; 1085 result = 0 ;; 1086 }; 1087 RooAbsReal::clearEvalErrorLog() ;; 1088 ; 1089 hist->SetBinContent(hist->GetBin(xbin,ybin,zbin),result);; 1090 if (setError) {; 1091 hist->SetBinError(hist->GetBin(xbin,ybin,zbin),sqrt(result)) ;; 1092 }; 1093 ; 1094 //cout << ""bin "" << bin << "" -> ("" << xbin << "","" << ybin << "","" << zbin << "") = "" << result << std::endl;; 1095 }; 1096 RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::PrintErrors) ;; 1097 ; 1098 // cleanup; 1099 delete cloneSet;; 1100 ; 1101 return hist;; 1102}; 1103 ; 1104 ; 1105 ; 1106////////////////////////////////////////////////////////////////////////////////; 1107/// Fill a RooDataHist with values sampled from this function at the; 1108/// bin centers. If extendedMode is true, the p.d.f. values is multiplied; 1109/// by the number of expected events in each bin; 1110///; 1111/// An optional scaling by a given scaleFactor can be performed.; 1112/// Returns a pointer to the input RooDataHist, or zero; 1113/// in case of an error.; 1114///; 1115/// If correctForBinSize is true the RooDataHist; 1116/// is filled with the functions density (function value times the; 1117/// bin volume) rather than function value.; 1118///; 1119/// If showProgress is true; 1120/// a process indicator is printed on stdout in steps of one percent,; 1121/// which is mostly useful for the sampling of expensive functions; 1122/// such as likelihoods; 1123 ; 1124RooDataHist* RooAbsReal::fillDataHist(RooDataHist *hist, const RooArgSet* normSet, double scaleFactor,; 1125 bool correctForBinSize, bool showProgress) const; 1126{; 1127 // Do we have a valid histogram to use?; 1128 if(nullptr == hist) {; 1129 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillDataHist: no valid RooDataHist to fill"" << std::endl;; 1130 return nullptr;; 1131 }; 1132 ; 1133 // Call ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:44943,perform,performed,44943,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['perform'],['performed']
Performance,"l() to get valid connection URL"") std _R__DEPRECATED_LATER(""Use GetAddr() to get valid connection URL"") std void SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr)Set call-backs function for connect, data and disconnect events.Definition RWebWindow.cxx:1814; ROOT::RWebWindow::SetRequireAuthKeyvoid SetRequireAuthKey(bool on)Configure if authentication key in connection string is required.Definition RWebWindow.hxx:319; ROOT::RWebWindow::GenerateKeystd::string GenerateKey() constGenerate new unique key for the window.Definition RWebWindow.cxx:612; ROOT::RWebWindow::SetUseCurrentDirvoid SetUseCurrentDir(bool on=true)Configure if window can access local files via currentdir/ path of http server.Definition RWebWindow.hxx:327; ROOT::RWebWindow::fDisconnCallbackWebWindowConnectCallback_t fDisconnCallback! callback for disconnect eventDefinition RWebWindow.hxx:162; ROOT::RWebWindow::GetMaxQueueLengthunsigned GetMaxQueueLength() constReturn maximal queue length of data which can be held by window.Definition RWebWindow.hxx:307; ROOT::RWebWindow::EQueueEntryKindEQueueEntryKindDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Disconnect@ kind_DisconnectDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Connect@ kind_ConnectDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_None@ kind_NoneDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Data@ kind_DataDefinition RWebWindow.hxx:127; ROOT::RWebWindow::IsFileDialogMessagestatic bool IsFileDialogMessage(const std::string &msg)Check if this could be the message send by client to start new file dialog If returns true,...Definition RWebWindow.cxx:2005; ROOT::RWebWindowsManagerCentral instance to create and show web-based windows like Canvas or FitPanel.Definition RWebWindowsManager.hxx:40; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:44657,queue,queue,44657,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['queue'],['queue']
Performance,"l(). void ROOT::Math::Minimizer::SetPrintLevel ; (; int ; level). inline . set print level ; Definition at line 328 of file Minimizer.h. ◆ SetStrategy(). void ROOT::Math::Minimizer::SetStrategy ; (; int ; strategyLevel). inline . set the strategy ; Definition at line 344 of file Minimizer.h. ◆ SetTolerance(). void ROOT::Math::Minimizer::SetTolerance ; (; double ; tol). inline . set the tolerance ; Definition at line 337 of file Minimizer.h. ◆ SetUpperLimitedVariable(). virtual bool ROOT::Math::Minimizer::SetUpperLimitedVariable ; (; unsigned int ; ivar, . const std::string & ; name, . double ; val, . double ; step, . double ; upper . ). inlinevirtual . set a new upper limit variable (override if minimizer supports them ) ; Reimplemented in ROOT::Math::BasicMinimizer, TMinuitMinimizer, and ROOT::Minuit2::Minuit2Minimizer.; Definition at line 179 of file Minimizer.h. ◆ SetValidError(). void ROOT::Math::Minimizer::SetValidError ; (; bool ; on). inline . flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit) ; Definition at line 350 of file Minimizer.h. ◆ SetVariable(). virtual bool ROOT::Math::Minimizer::SetVariable ; (; unsigned int ; ivar, . const std::string & ; name, . double ; val, . double ; step . ). pure virtual . set a new free variable ; Implemented in TFumiliMinimizer, ROOT::Math::GeneticMinimizer, ROOT::Math::BasicMinimizer, TMinuitMinimizer, ROOT::Minuit2::Minuit2Minimizer, and TLinearMinimizer. ◆ SetVariableInitialRange(). virtual bool ROOT::Math::Minimizer::SetVariableInitialRange ; (; unsigned int ; , . double ; , . double ;  . ). inlinevirtual . set the initial range of an existing variable ; Definition at line 208 of file Minimizer.h. ◆ SetVariableLimits(). virtual bool ROOT::Math::Minimizer::SetVariableLimits ; (; unsigned int ; ivar, . double ; lower, . double ; upper . ). inlinevirtual . set the limits of an already existing variable ; Reimplemented in ROOT::Math::BasicMinimizer, TMinuitMinimizer, and ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html:32033,perform,perform,32033,doc/master/classROOT_1_1Math_1_1Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html,1,['perform'],['perform']
Performance,"l(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModecanNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddPdf.html:3033,Cache,CacheModecanNodeBeCached,3033,root/html602/RooAddPdf.html,https://root.cern,https://root.cern/root/html602/RooAddPdf.html,4,['Cache'],['CacheModecanNodeBeCached']
Performance,"l(TBuffer& ClassDef_StreamerNVirtual_b). private:. TQCanvasMenu(const TQCanvasMenu& c); TQCanvasMenu&operator=(const TQCanvasMenu&). Data Members; protected:. TObject*fCurrObjcurrent selected object; TQRootDialog*fDialogthe TQRootDialog which is used to prompt for; TListfMethodslist of Root metheds associated with the selected object; doublefMousePosXmouse position in user coordinate; doublefMousePosYmouse position in user coordinate; QWidget*fParent; QPopupMenu*fPopupQt popup menu; QWidget*fTabWinparents widgets; TCanvas*fcpointer to the ROOT canvas. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQCanvasMenu(QWidget* parent = 0, TCanvas* canvas = 0); ctor, create the popup menu. TQCanvasMenu(QWidget* parent, QWidget* tabWin, TCanvas* canvas); ctor, create the popup menu. ~TQCanvasMenu(); dtor. char * CreateDialogTitle(TObject* object, TMethod* method); Create title for dialog box retrieving argument values. char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). void Popup(TObject* obj, double x, double y, QMouseEvent* e); Perform the corresponding selected TObject popup; in the position defined; by x, y coordinates (in user coordinate system).; @param obj (TObject*); @param p (QPoint&). void Execute(int id); Slot defined to execute a method from a selected TObject; using TObject::Execute() function. void Dialog(TObject* obj, TMethod* method); Create dialog object with OK and Cancel buttons. This dialog; prompts for the arguments of ""method"". TQCanvasMenu(const TQCanvasMenu& c). TQCanvasMenu& operator=(const TQCanvasMenu& ); {return *this;}. » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id$ » Last generated: 2015-03-14 16:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQCanvasMenu.html:1994,Perform,Perform,1994,root/html534/TQCanvasMenu.html,https://root.cern,https://root.cern/root/html534/TQCanvasMenu.html,1,['Perform'],['Perform']
Performance,"l(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated() const; {return fAutoCreated;}. Bool_t IsEnabled() const; {return fEnabled;}. Bool_t IsLearning() const; {return fIsLearning;}. void SetAutoCreated(Bool_t val); {fAutoCreated = val;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:26367,cache,cache,26367,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['cache'],['cache']
Performance,"l(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSignalLike(); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*MethodBaseDir() const; virtual Bool_tMonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidPrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; virtual voidProcessOptions(); voidProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidReadStateFromFile(); voidReadStateFromStream(istream& tf); voidReadStateFromStream(TFile& rf); voidReadStateFromXMLString(const char* xmlstr); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBase.html:8827,Optimiz,OptimizeTuningParameters,8827,root/html528/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"l*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooSetProxydepsdependents of this p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProjectedPdf.html:44981,cache,cache,44981,root/html602/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html602/RooProjectedPdf.html,2,['cache'],['cache']
Performance,"l, TClass* newcl); voidWriteItems(int nElements, TBuffer& b). private:. TEmulatedCollectionProxy&operator=(const TEmulatedCollectionProxy&). Data Members; public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t); static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISTSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBOOL_t; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsAssociative; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsEmulated; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kNeedDelete. protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tTGenCollectionProxy::fCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tTGenCollectionProxy::fConstructContainer accessors: block construct; map<string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tTGenCollectionProxy::fDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*TGenCollectionProxy::fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tTGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::fFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::fFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::fFunctionDeleteI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEmulatedCollectionProxy.html:4865,cache,cache,4865,root/html602/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TEmulatedCollectionProxy.html,2,['cache'],['cache']
Performance,"l, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::vector< double > _coefThresh;  [_nComp] Array of coefficient thresholds ;  ; std::vector< std::unique_ptr< RooAbsGenContext > > _gcList;  List of component generator contexts. ;  ; bool _isModel;  Are we generating from a RooAddPdf or a RooAddModel. ;  ; Int_t _nComp;  Number of PDF components. ;  ; AddCacheElem * _pcache = nullptr;  ! RooAddPdf cache element ;  ; RooAbsPdf * _pdf;  Pointer to cloned p.d.f. ;  ; std::unique_ptr< RooArgSet > _pdfSet;  Set owned all nodes of internal clone of p.d.f. ;  ; std::unique_ptr< RooArgSet > _vars;  ;  Protected Attributes inherited from RooAbsGenContext; UInt_t _expectedEvents;  Number of expected events from extended p.d.f. ;  ; RooAbsPdf::ExtendMode _extendMode;  Extended mode capabilities of p.d.f. ;  ; RooDataSet * _genData = nullptr;  ! Data being generated ;  ; bool _isValid;  Is context in valid state? ;  ; Int_t _nextProtoIndex;  Next prototype event to load according to LUT. ;  ; TString _normRange;  Normalization range of pdf. ;  ; std::vector< Int_t > _protoOrder;  LUT with traversal order of prototype data. ;  ; const RooDataSet * _prototype;  Pointer to prototype dataset. ;  ; RooArgSet _protoVars;  Prototype observables. ;  ; RooArgSet _theEvent;  Pointer to observable event being generated. ;  ; bool _verbose;  Verbose messaging? ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 ))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddGenContext.html:16428,load,load,16428,doc/master/classRooAddGenContext.html,https://root.cern,https://root.cern/doc/master/classRooAddGenContext.html,1,['load'],['load']
Performance,"l, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_type index) const;  Return the legacy RooCatType corresponding to index. If it doesn't exist, create one. ;  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)activate associate tree branch ;  ; std::map< std::string, value_type > & stateNames ();  Access the map of state names to index numbers. ;  ; const std::map< std::string, value_type > & stateNames () const;  Access the map of state names to index numbers. ;  ; void syncCache (const RooArgSet *set=nullptr) override;  Explicitly synchronize RooAbsCategory internal cache. ;  ; virtual bool isValid (const RooCatType &value) const;  Check if given state is defined for this object. ;  ; const RooCatType * defineType (const char *label);  ; const RooCatType * defineType (const char *label, int index);  ; const RooCatType * defineTypeUnchecked (const char *label, value_type index);  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinningCategory.html:37066,cache,cache,37066,doc/master/classRooBinningCategory.html,https://root.cern,https://root.cern/doc/master/classRooBinningCategory.html,6,['cache'],['cache']
Performance,"l.Definition TTree.cxx:2652; TTree::FindBranchvirtual TBranch * FindBranch(const char *name)Return the branch that correspond to the path 'branchname', which can include the name of the tree or...Definition TTree.cxx:4841; TTree::SetBranchStatusvirtual void SetBranchStatus(const char *bname, bool status=true, UInt_t *found=nullptr)Set branch status to Process or DoNotProcess.Definition TTree.cxx:8534; TTree::EnableCachebool EnableCache()Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0).Definition TTree.cxx:2685; TTree::GetBranchvirtual TBranch * GetBranch(const char *name)Return pointer to the branch with the given name in this tree or its friends.Definition TTree.cxx:5294; TTree::GetBranchStylestatic Int_t GetBranchStyle()Static function returning the current branch style.Definition TTree.cxx:5395; TTree::fFriendsTList * fFriendspointer to list of friend elementsDefinition TTree.h:130; TTree::fIMTEnabledbool fIMTEnabled! true if implicit multi-threading is enabled for this treeDefinition TTree.h:142; TTree::GetBranchStatusvirtual bool GetBranchStatus(const char *branchname) constReturn status of branch with name branchname.Definition TTree.cxx:5380; TTree::fFriendLockStatusUInt_t fFriendLockStatus! Record which method is locking the friend recursionDefinition TTree.h:137; TTree::GetLeafImplvirtual TLeaf * GetLeafImpl(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:435679,multi-thread,multi-threading,435679,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"l.h. ◆ GetSize(). virtual Int_t TFFTComplexReal::GetSize ; (; ); const. inlinevirtual . Definition at line 42 of file TFFTComplexReal.h. ◆ GetTransformFlag(). Option_t * TFFTComplexReal::GetTransformFlag ; (; ); const. inlineoverridevirtual . Implements TVirtualFFT.; Definition at line 47 of file TFFTComplexReal.h. ◆ GetType(). Option_t * TFFTComplexReal::GetType ; (; ); const. inlineoverridevirtual . Implements TVirtualFFT.; Definition at line 45 of file TFFTComplexReal.h. ◆ Init(). void TFFTComplexReal::Init ; (; Option_t * ; flags, . Int_t ; , . const Int_t * ;  . ). overridevirtual . Creates the fftw-plan. ; NOTE: input and output arrays are overwritten during initialisation, so don't set any points, before running this function!!!!!; Arguments sign and kind are dummy and not need to be specified Possible flag_options:. ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found. This option should be chosen depending on how many transforms of the same size and type are going to be done. Planning is only done once, for the first transform of this size and type. ; Implements TVirtualFFT.; Definition at line 148 of file TFFTComplexReal.cxx. ◆ IsA(). TClass * TFFTComplexReal::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 66 of file TFFTComplexReal.h. ◆ IsInplace(). Bool_t TFFTComplexReal::IsInplace ; (; ); const. inlineoverridevirtual . Implements TVirtualFFT.; Definition at line 48 of file TFFTComplexReal.h. ◆ MapFlag(). UInt_t TFFTComplexReal::MapFlag ; (; Option_t * ; flag). protected . allowed options: ""ES"" - FFTW_ESTIMATE ""M"" - FFTW_MEASURE ""P"" - FFTW_PATIENT ""EX"" - FFTW_EXHAUSTIVE ; Definition at line 390 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFFTComplexReal.html:21534,perform,performance,21534,doc/master/classTFFTComplexReal.html,https://root.cern,https://root.cern/doc/master/classTFFTComplexReal.html,1,['perform'],['performance']
Performance,"l/numerical normalization for its implementations, error tracing and a MC generator interface ;  CCacheElemNormalization set with for above integral ;  CGenSpec;  CRooAbsProxyRooAbsProxy is the abstact interface for proxy classes ;  ►CRooAbsRealRooAbsReal is the common abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc ;  CEvalError;  CPlotOpt;  CRooAbsRealLValueRooAbsRealLValue is the common abstract base class for objects that represent a real value that may appear on the left hand side of an equation ('lvalue') ;  CRooAbsRootFinderRooAbsRootFinder is the abstract interface for finding roots of real-valued 1-dimensional function that implements the RooAbsFunc interface ;  CRooAbsSelfCachedPdfRooAbsSelfCachedPdf is an abstract base class for probability density functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate() ;  CRooAbsSelfCachedRealRooAbsSelfCachedReal is an abstract base class for functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate() ;  CRooAbsStringRooAbsString is the common abstract base class for objects that represent a string value ;  CRooAbsStudyRooAbsStudy is an abstract base class for RooStudyManager modules ;  CRooAbsTestStatisticRooAbsTestStatistic is the abstract base class for all test statistics ;  CRooAcceptRejectClass RooAcceptReject is a generic toy monte carlo generator implement the accept/reject sampling technique on any positively valued function ;  CRooAdaptiveGaussKronrodIntegrator1DRooAdaptiveGaussKronrodIntegrator1D implements the Gauss-Kronrod integration algorithm ;  CRooAdaptiveIntegratorNDRooAdaptiveIntegratorND implements an adaptive one-dimensional numerical integration algorithm ;  CRooAddGenContextRooAddGenContext is an efficie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:102456,cache,cached,102456,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['cache'],['cached']
Performance,"l::Internal::RFieldDescriptorBuilder;  A helper class for piece-wise construction of an RFieldDescriptor. More...;  ; class  ROOT::Experimental::RNTupleDescriptor::RFieldDescriptorIterable;  Used to loop over a field's child fields. More...;  ; class  ROOT::Experimental::Detail::RFieldVisitor;  Abstract base class for classes implementing the visitor design pattern. More...;  ; class  ROOT::Experimental::RNTupleDescriptor::RHeaderExtension;  Summarizes information about fields and the corresponding columns that were added after the header has been serialized. More...;  ; class  ROOT::Experimental::RNTupleProcessor::RIterator;  Iterator over the entries of an RNTuple, or vertical concatenation thereof. More...;  ; class  ROOT::Experimental::Internal::RMiniFileReader;  Read RNTuple data blocks from a TFile container, provided by a RRawFile. More...;  ; class  ROOT::RNTuple;  Representation of an RNTuple data set in a ROOT file. More...;  ; class  ROOT::Experimental::Detail::RNTupleAtomicCounter;  A thread-safe integral performance counter. More...;  ; class  ROOT::Experimental::Detail::RNTupleCalcPerf;  A metric element that computes its floating point value from other counters. More...;  ; class  ROOT::Experimental::RNTupleChainProcessor;  Processor specializiation for vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleClusterRange;  Used to loop over entries of collections in a single cluster. More...;  ; class  ROOT::Experimental::RNTupleCollectionView;  A view for a collection, that can itself generate new ntuple views for its nested fields. More...;  ; class  ROOT::Experimental::Internal::RNTupleCompressor;  Helper class to compress data blocks in the ROOT compression frame format. More...;  ; class  ROOT::Experimental::Internal::RNTupleDecompressor;  Helper class to uncompress data blocks in the ROOT compression frame format. More...;  ; class  ROOT::Experimental::RNTupleDescriptor;  The on-storage meta-data of an ntuple. Mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__NTuple.html:6585,perform,performance,6585,doc/master/group__NTuple.html,https://root.cern,https://root.cern/doc/master/group__NTuple.html,1,['perform'],['performance']
Performance,"l::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooRealProxy_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; int_l1; int_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; int_m1; int_m2; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooLegendre.html:30794,cache,cache,30794,root/html528/RooLegendre.html,https://root.cern,https://root.cern/root/html528/RooLegendre.html,2,['cache'],['cache']
Performance,"l::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooRealProxy_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; int_l1; int_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; int_m1; int_m2; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLegendre.html:31294,cache,cache,31294,root/html532/RooLegendre.html,https://root.cern,https://root.cern/root/html532/RooLegendre.html,1,['cache'],['cache']
Performance,"l::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsRealLValue.html:35850,cache,cache,35850,root/html530/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html530/RooAbsRealLValue.html,8,['cache'],['cache']
Performance,"l::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for function po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction2Binding_double_int_int_.html:35202,cache,cache,35202,root/html534/RooCFunction2Binding_double_int_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction2Binding_double_int_int_.html,2,['cache'],['cache']
Performance,"l::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for function po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_unsigned_int_double_.html:36799,cache,cache,36799,root/html602/RooCFunction2Binding_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_unsigned_int_double_.html,4,['cache'],['cache']
Performance,"l::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidapplyNLLWeightSquared(Bool_t flag); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidcalculate() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealMPFE.html:2997,cache,cacheUniqueSuffix,2997,root/html534/RooRealMPFE.html,https://root.cern,https://root.cern/root/html534/RooRealMPFE.html,1,['cache'],['cacheUniqueSuffix']
Performance,"l::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:26990,optimiz,optimizeCacheMode,26990,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,2,['optimiz'],['optimizeCacheMode']
Performance,"l::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooResolutionModel.html:23639,optimiz,optimizeCacheMode,23639,root/html530/RooResolutionModel.html,https://root.cern,https://root.cern/root/html530/RooResolutionModel.html,2,['optimiz'],['optimizeCacheMode']
Performance,"l::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooPolyVar&operator=(const RooPolyVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPolyVar.html:19300,optimiz,optimizeCacheMode,19300,root/html602/RooPolyVar.html,https://root.cern,https://root.cern/root/html602/RooPolyVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"l::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooProduct&operator=(const RooProduct&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProduct.html:19178,optimiz,optimizeCacheMode,19178,root/html602/RooProduct.html,https://root.cern,https://root.cern/root/html602/RooProduct.html,2,['optimiz'],['optimizeCacheMode']
Performance,"l::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooPullVar&operator=(const RooPullVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPullVar.html:19440,optimiz,optimizeCacheMode,19440,root/html602/RooPullVar.html,https://root.cern,https://root.cern/root/html602/RooPullVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"l::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealVar&operator=(const RooRealVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealVar.html:23231,optimiz,optimizeCacheMode,23231,root/html602/RooRealVar.html,https://root.cern,https://root.cern/root/html602/RooRealVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"l; : Evaluation done.; ==> Wrote root file: TMVARegCv.root; ==> TMVACrossValidationRegression is done!; (int) 0; ; #include <cstdlib>; #include <iostream>; #include <map>; #include <string>; ; #include ""TChain.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TSystem.h""; #include ""TROOT.h""; ; #include ""TMVA/Factory.h""; #include ""TMVA/DataLoader.h""; #include ""TMVA/Tools.h""; #include ""TMVA/TMVAGui.h""; #include ""TMVA/CrossValidation.h""; ; TFile * getDataFile(TString fname) {; TFile *input(0);; ; if (!gSystem->AccessPathName(fname)) {; input = TFile::Open(fname); // check if file in local directory exists; } else {; // if not: download from ROOT server; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_reg_example.root"", ""CACHEREAD"");; }; ; if (!input) {; std::cout << ""ERROR: could not open data file "" << fname << std::endl;; exit(1);; }; ; return input;; }; ; int TMVACrossValidationRegression(); {; // This loads the library; TMVA::Tools::Instance();; ; // --------------------------------------------------------------------------; ; // Create a ROOT output file where TMVA will store ntuples, histograms, etc.; TString outfileName(""TMVARegCv.root"");; TFile * outputFile = TFile::Open(outfileName, ""RECREATE"");; ; TString infileName(""./files/tmva_reg_example.root"");; TFile * inputFile = getDataFile(infileName);; ; TMVA::DataLoader *dataloader=new TMVA::DataLoader(""datasetcvreg"");; ; dataloader->AddVariable(""var1"", ""Variable 1"", ""units"", 'F');; dataloader->AddVariable(""var2"", ""Variable 2"", ""units"", 'F');; ; // Add the variable carrying the regression target; dataloader->AddTarget(""fvalue"");; ; TTree * regTree = (TTree*)inputFile->Get(""TreeR"");; dataloader->AddRegressionTree(regTree, 1.0);; ; // Individual events can be weighted; // dataloader->SetWeightExpression(""weight"", ""Regression"");; ; std::cout << ""--- TMVACrossValidationRegression: Using input file: "" << inputFile->GetName() << std::endl;; ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:15588,CACHE,CACHEREAD,15588,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,2,"['CACHE', 'load']","['CACHEREAD', 'loads']"
Performance,"l; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfInput p.d.f; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; const TNamed*_rangeNameName of subset range; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExtendPdf(); Default constructor. RooExtendPdf(const char* name, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooExtendPdf.html:42383,cache,cache,42383,root/html534/RooExtendPdf.html,https://root.cern,https://root.cern/root/html534/RooExtendPdf.html,2,['cache'],['cache']
Performance,"l; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooProdPdf.h>. Inheritance diagram for RooProdPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooProdPdf() [1/7]. RooProdPdf::RooProdPdf ; (; ). Default constructor. ; Definition at line 82 of file RooProdPdf.cxx. ◆ RooProdPdf() [2/7]. RooProdPdf::RooProdPdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; pdf1, . RooAbsPdf & ; pdf2, . double ; cutOff = 0.0 . ). Constructor with 2 PDFs (most frequent use case). ; The optional cutOff parameter can be used as a speed optimization if one or more of the PDF have sizable regions with very small values, which would pull the entire product of PDFs to zero in those regions.; After each PDF multiplication, the running product is compared with the cutOff parameter. If the running product is smaller than the cutOff value, the product series is terminated and remaining PDFs are not evaluated.; There is no magic value of the cutOff, the user should experiment to find the appropriate balance between speed and precision. If a cutoff is specified, the PDFs most likely to be small should be put first in the product. The default cutOff value is zero. ; Definition at line 108 of file RooProdPdf.cxx. ◆ RooProdPdf() [3/7]. RooProdPdf::RooProdPdf ; (; const char * ; name, . const char * ; title, . const RooArgList & ; inPdfList, . double ; cutOff = 0.0 . ). Constructor from a list of PDFs. ; The optional cutOff parameter can be used as a speed optimization if one or more of the PDF have sizable regions with very small values, which would pull the entire product of P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:80817,optimiz,optimization,80817,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['optimiz'],['optimization']
Performance,"l< T > BaseFunc;  . Public Member Functions;  ~IParametricGradFunctionMultiDimTempl () override;  Virtual Destructor (no operations) ;  ; virtual bool HasParameterHessian () const;  ; T operator() (const T *x) const;  ; T operator() (const T *x, const double *p) const;  ; T ParameterDerivative (const T *x, const double *p, unsigned int ipar=0) const;  Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. ;  ; T ParameterDerivative (const T *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; virtual bool ParameterG2 (const T *, const double *, T *) const;  Evaluate all the second derivatives (diagonal ones) of the function with respect to the parameters at a point x. ;  ; virtual void ParameterGradient (const T *x, const double *p, T *grad) const;  Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x. ;  ; void ParameterGradient (const T *x, T *grad) const;  Evaluate all derivatives using cached parameter values. ;  ; virtual bool ParameterHessian (const T *, const double *, T *) const;  Evaluate the all the Hessian (second derivatives matrix) of the function with respect to the parameters at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionMultiDimTempl< T >; T operator() (const T *x) const;  ; T operator() (const T *x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; virtual ~IBaseFunctionMultiDimTempl ()=default;  ; virtual IBaseFunctionMultiDimTempl< T > * Clone () const =0;  Clone a function. ;  ; virtual bool HasGradient () const;  ; virtual unsigned int NDim () const =0;  Retrieve the dimension of the function. ;  ; T operator() (const T *x) const;  Evaluate the function at a point x[]. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBasePa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html:2580,cache,cached,2580,doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html,1,['cache'],['cached']
Performance,"l=kFALSE);  Send remove request for the query specified by ref. ;  ; Int_t Remove (Int_t query, Bool_t all=kFALSE);  Send remove request for the qry-th query in fQueries. ;  ; void RemoveChain (TChain *chain);  Remove chain from data set. ;  ; Int_t RemoveDynamicPath (const char *libpath, Bool_t onClient=kFALSE);  Remove 'libpath' from the lib path search. ;  ; void RemoveFeedback (const char *name);  Remove object from feedback list. ;  ; Int_t RemoveIncludePath (const char *incpath, Bool_t onClient=kFALSE);  Remove 'incpath' from the inc path search. ;  ; void ResetProgressDialog (const char *sel, Int_t sz, Long64_t fst, Long64_t ent);  Reset progress dialog. ;  ; void ResetProgressDialogStatus ();  ; Int_t Retrieve (const char *queryref, const char *path=0);  Send retrieve request for the query specified by ref. ;  ; Int_t Retrieve (Int_t query, const char *path=0);  Send retrieve request for the qry-th query in fQueries. ;  ; Int_t SavePerfTree (const char *pf=0, const char *qref=0);  Save performance information from TPerfStats to file 'pf'. ;  ; void SendDataSetStatus (const char *msg, UInt_t n, UInt_t tot, Bool_t st);  Send or notify data set status. ;  ; Bool_t SendingLogToWindow () const;  ; void SendLogToWindow (Bool_t mode);  ; void SetActive (Bool_t=kTRUE);  ; virtual void SetAlias (const char *alias="""");  Set an alias for this session. ;  ; void SetDataPoolUrl (const char *url);  ; void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt);  Set draw feedback option. ;  ; void SetInputDataFile (const char *datafile);  Set the file to be used to optimally distribute the input data objects. ;  ; void SetLogLevel (Int_t level, UInt_t mask=TProofDebug::kAll);  Set server logging level. ;  ; void SetManager (TProofMgr *mgr);  Set manager and schedule its destruction after this for clean operations. ;  ; void SetMaxDrawQueries (Int_t max);  Set max number of draw queries whose results are saved. ;  ; Int_t SetParallel (Int_t nodes=-1, Bool_t random=kFALSE);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:16309,perform,performance,16309,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['perform'],['performance']
Performance,"l>{createIntegral(depList,*nset, *getIntegratorConfig(), RooNameReg::str(rangeName))}.release();; 460 ; 461 // Store it in the cache; 462 _normMgr.setObj(nset,iset,new CacheElem(*norm),rangeName) ;; 463 ; 464 // And return the newly created integral; 465 return norm ;; 466}; 467 ; 468 ; 469 ; 470////////////////////////////////////////////////////////////////////////////////; 471/// Verify that the normalization integral cached with this PDF; 472/// is valid for given set of normalization observables.; 473///; 474/// If not, the cached normalization integral (if any) is deleted; 475/// and a new integral is constructed for use with 'nset'.; 476/// Elements in 'nset' can be discrete and real, but must be lvalues.; 477///; 478/// For functions that declare to be self-normalized by overloading the; 479/// selfNormalized() function, a unit normalization is always constructed.; 480 ; 481bool RooAbsPdf::syncNormalization(const RooArgSet* nset, bool adjustProxies) const; 482{; 483 setActiveNormSet(nset);; 484 ; 485 // Check if data sets are identical; 486 CacheElem* cache = static_cast<CacheElem*>(_normMgr.getObj(nset)) ;; 487 if (cache) {; 488 ; 489 bool nintChanged = (_norm!=cache->_norm.get()) ;; 490 _norm = cache->_norm.get();; 491 ; 492 // In the past, this condition read `if (nintChanged && adjustProxies)`.; 493 // However, the cache checks if the nset was already cached **by content**,; 494 // and not by RooArgSet instance! So it can happen that the normalization; 495 // set object is different, but the integral object is the same, in which; 496 // case it would be wrong to not adjust the proxies. They always have to be; 497 // adjusted when the nset changed, which is always the case when; 498 // `syncNormalization()` is called.; 499 if (adjustProxies) {; 500 // Update dataset pointers of proxies; 501 const_cast<RooAbsPdf*>(this)->setProxyNormSet(nset) ;; 502 }; 503 ; 504 return nintChanged ;; 505 }; 506 ; 507 // Update dataset pointers of proxies; 508 if (adjustProx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:18369,Cache,CacheElem,18369,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,3,"['Cache', 'cache']","['CacheElem', 'cache']"
Performance,"lCollectionProxy.h:52; TVirtualCollectionProxy::GetTypevirtual EDataType GetType() const =0If the value type is a fundamental data type, return its type (see enumeration EDataType).; TVirtualCollectionProxy::GetValueClassvirtual TClass * GetValueClass() const =0If the value type is a user-defined class, return a pointer to the TClass representing the value type...; TVirtualCollectionProxy::HasPointersvirtual Bool_t HasPointers() const =0Return true if the content is of type 'pointer to'.; TVirtualIndexAbstract interface for Tree Index.Definition TVirtualIndex.h:30; TVirtualIndex::GetMajorNamevirtual const char * GetMajorName() const =0; TVirtualIndex::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const =0; TVirtualIndex::GetEntryNumberFriendvirtual Long64_t GetEntryNumberFriend(const TTree *)=0; TVirtualIndex::Appendvirtual void Append(const TVirtualIndex *, bool delaySort=false)=0; TVirtualIndex::GetMinorNamevirtual const char * GetMinorName() const =0; TVirtualIndex::SetTreevirtual void SetTree(TTree *T)=0; TVirtualIndex::GetNvirtual Long64_t GetN() const =0; TVirtualIndex::IsValidForvirtual bool IsValidFor(const TTree *parent)=0; TVirtualIndex::GetEntryNumberWithBestIndexvirtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const =0; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualTreePlayerAbstract base class defining the interface for the plugins that implement Draw, Scan,...Definition TVirtualTreePlayer.h:38; TVirtualTreePlayer::Scanvirtual Long64_t Scan(const char *varexp, const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry)=0; TVirtualTreePlayer::UpdateFormulaLeavesvirtual void UpdateFormulaLeaves()=0; TVirtualTreePlayer::DrawSelectvirtual Long64_t DrawSelect(const char *varexp, const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry)=0; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:469439,perform,performance,469439,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['perform'],['performance']
Performance,"lConfig requires a workspace to be set.; A ModelConfig holds sets of parameters of the likelihood function that have different interpretations:; Parameter of interest Parameters that are measured (i.e. fitted).; Nuisance parameters Parameters that are fitted, but their post-fit value is not interesting. Often, they might be constrained because external knowledge about them exists, e.g. from external measurements.; Constraint parameters No direct use in RooFit/RooStats. Can be used by the user for bookkeeping.; Observables Parameters that have been measured externally, i.e. they exist in a dataset. These are not fitted, but read during fitting from the entries of a dataset.; Conditional observables Observables that are not integrated when the normalisation of the PDF is calculated. See e.g. rf306_condpereventerrors in the RooFit tutorials.; Global observables Observables that to the fit look like ""constant"" values, i.e. they are not being fitted and they are not loaded from a dataset, but some knowledge exists that allows to set them to a specific value. Examples: – A signal efficiency measured in a Monte Carlo study. – When constraining a parameter \( b \), the target value ( \( b_0 \)) that this parameter is constrained to: ; \[; \mathrm{Constraint}_b = \mathrm{Gauss}(b_0 \, | \, b, 0.2); \]. External constraints Include given external constraints to likelihood by multiplying them with the original likelihood. . Definition at line 35 of file ModelConfig.h. Public Member Functions;  ModelConfig (const char *name, const char *title, RooWorkspace *ws=nullptr);  ;  ModelConfig (const char *name, RooWorkspace *ws=nullptr);  ;  ModelConfig (RooWorkspace *ws=nullptr);  ; ModelConfig * Clone (const char *name="""") const override;  clone ;  ; template<typename... CmdArgs_t> ; std::unique_ptr< RooAbsReal > createNLL (RooAbsData &data, CmdArgs_t const &...cmdArgs) const;  Wrapper around RooAbsPdf::createNLL(), where the pdf and some configuration options are retrieved from the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1ModelConfig.html:1635,load,loaded,1635,doc/master/classRooStats_1_1ModelConfig.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1ModelConfig.html,1,['load'],['loaded']
Performance,"lCoord::GetLineColor ; (; ). inline . Definition at line 92 of file TParallelCoord.h. ◆ GetLineWidth(). Width_t TParallelCoord::GetLineWidth ; (; ). inline . Definition at line 93 of file TParallelCoord.h. ◆ GetNbins(). Int_t TParallelCoord::GetNbins ; (; ). get the binning of the histograms. ; Definition at line 502 of file TParallelCoord.cxx. ◆ GetNentries(). Long64_t TParallelCoord::GetNentries ; (; ). inline . Definition at line 96 of file TParallelCoord.h. ◆ GetNvar(). UInt_t TParallelCoord::GetNvar ; (; ). inline . Definition at line 95 of file TParallelCoord.h. ◆ GetSelection(). TParallelCoordSelect * TParallelCoord::GetSelection ; (; const char * ; title). Get a selection from its title. ; Definition at line 510 of file TParallelCoord.cxx. ◆ GetSelectList(). TList * TParallelCoord::GetSelectList ; (; ). inline . Definition at line 97 of file TParallelCoord.h. ◆ GetTree(). TTree * TParallelCoord::GetTree ; (; ). return the tree if fTree is defined. ; If not, the method try to load the tree from fTreeFileName. ; Definition at line 522 of file TParallelCoord.cxx. ◆ GetVariable() [1/2]. Double_t * TParallelCoord::GetVariable ; (; const char * ; var). Get the variables values from its title. ; Definition at line 564 of file TParallelCoord.cxx. ◆ GetVariable() [2/2]. Double_t * TParallelCoord::GetVariable ; (; Int_t ; i). Get the variables values from its index. ; Definition at line 576 of file TParallelCoord.cxx. ◆ GetVarList(). TList * TParallelCoord::GetVarList ; (; ). inline . Definition at line 102 of file TParallelCoord.h. ◆ GetVertDisplay(). bool TParallelCoord::GetVertDisplay ; (; ); const. inline . Definition at line 103 of file TParallelCoord.h. ◆ GetWeightCut(). Int_t TParallelCoord::GetWeightCut ; (; ); const. inline . Definition at line 104 of file TParallelCoord.h. ◆ Init(). void TParallelCoord::Init ; (; ). private . Initialise the data members of TParallelCoord. ; Definition at line 585 of file TParallelCoord.cxx. ◆ IsA(). TClass * TParallelCoord::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParallelCoord.html:29476,load,load,29476,doc/master/classTParallelCoord.html,https://root.cern,https://root.cern/doc/master/classTParallelCoord.html,1,['load'],['load']
Performance,"lCreateMinimizer(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidResetLimits(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooArgSet*fBestFitParamssnapshot of the model parameters with best fit value (managed internally); Double_tfConfidenceLevelRequested confidence level (eg. 0.95 for 95% CL); auto_ptr<RooFunctor>fFunctor! transient pointer to functor class used by the minimizer; RooAbsReal*fLikelihoodRatiolikelihood ratio function used to make contours (managed internally); map<std::string,double>fLowerLimitsmap with cached lower bound values; auto_ptr<ROOT::Math::IMultiGenFunction>fMinFunc! transient pointer to the minimization function ; auto_ptr<ROOT::Math::Minimizer>fMinimizer! transient pointer to minimizer class used to find limits and contour; RooArgSetfParametersparameters of interest for this interval; map<std::string,double>fUpperLimitsmap with cached upper bound values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LikelihoodInterval(const char* name = 0); Default constructor with name and title. LikelihoodInterval(const char* name, RooAbsReal* , const RooArgSet* , RooArgSet* = 0); Alternate constructor taking a pointer to the profile likelihood ratio, parameter of interest and; optionally a snaphot of best parameter of interest for interval. ~LikelihoodInterval(); Destructor. Bool_t IsInInterval(const RooArgSet& ) const; This is the main method to satisfy the RooStats::ConfInterval interface.; It returns true if the parameter point is in the interval. RooArgSet* GetParameters() const; returns list of par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__LikelihoodInterval.html:7940,cache,cached,7940,root/html528/RooStats__LikelihoodInterval.html,https://root.cern,https://root.cern/root/html528/RooStats__LikelihoodInterval.html,8,['cache'],['cached']
Performance,"lCreateMinimizer(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidResetLimits(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooArgSet*fBestFitParamssnapshot of the model parameters with best fit value (managed internally); Double_tfConfidenceLevelRequested confidence level (eg. 0.95 for 95% CL); auto_ptr<RooFunctor>fFunctor! transient pointer to functor class used by the minimizer; RooAbsReal*fLikelihoodRatiolikelihood ratio function used to make contours (managed internally); map<std::string,double>fLowerLimitsmap with cached lower bound values; auto_ptr<ROOT::Math::IMultiGenFunction>fMinFunc! transient pointer to the minimization function ; auto_ptr<ROOT::Math::Minimizer>fMinimizer! transient pointer to minimizer class used to find limits and contour; RooArgSetfParametersparameters of interest for this interval; map<std::string,double>fUpperLimitsmap with cached upper bound values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LikelihoodInterval(const char* name); Default constructor with name and title. LikelihoodInterval(const char* name, RooAbsReal* , const RooArgSet* , RooArgSet* = 0); Alternate constructor taking a pointer to the profile likelihood ratio, parameter of interest and; optionally a snaphot of best parameter of interest for interval. ~LikelihoodInterval(); Destructor. Bool_t IsInInterval(const RooArgSet& ) const; This is the main method to satisfy the RooStats::ConfInterval interface.; It returns true if the parameter point is in the interval. RooArgSet* GetParameters() const; returns list of paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__LikelihoodInterval.html:7846,cache,cached,7846,root/html526/RooStats__LikelihoodInterval.html,https://root.cern,https://root.cern/root/html526/RooStats__LikelihoodInterval.html,2,['cache'],['cached']
Performance,"lDragManager&); virtual voidSetEditable(Bool_t); virtual voidSetPasteFrame(TGFrame* f); virtual voidSetSource(TGFrame* f); virtual voidSetTarget(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tStartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualDragManager(); TVirtualDragManager(const TVirtualDragManager&). protected:. virtual voidInit(). Data Members; protected:. EDragTypefDragTypedragging type; Bool_tfDraggingin dragging mode?; Bool_tfDroppingdrop is in progress; TGFrame*fFrameUnderframe under drag; Bool_tfMoveWaitingkTRUE if source is clicked but not moved; TGFrame*fPasteFrame; Bool_tfPastingpaste action is in progress; TGFrame*fSourceframe being dragged; TGFrame*fTargetdrop target. Class Charts. Inheritance Chart:. TVirtualDragManager. ←. TGuiBldDragManager. Function documentation; TVirtualDragManager(); Constructor. TVirtualDragManager * Instance(); Load plugin and create drag manager object. void Init(); Initialization. TVirtualDragManager(). virtual ~TVirtualDragManager(); {}. EDragType GetEDragType() const; { return fDragType; }. Bool_t IsMoveWaiting() const; { return fMoveWaiting; }. Bool_t IsDragging() const; { return fDragging; }. Bool_t IsDropping() const; { return fDropping; }. Bool_t IsPasting() const; { return fPasting; }. TGFrame * GetTarget() const; { return fTarget; }. TGFrame * GetSource() const; { return fSource; }. TGFrame * GetFrameUnder() const; { return fFrameUnder; }. TGFrame * GetPasteFrame() const; { return fPasteFrame; }. void SetTarget(TGFrame* f); { fTarget = f; }. void SetSource(TGFrame* f); { fSource = f; }. void SetPasteFrame(TGFrame* f); { fPasteFrame = f; }. Bool_t StartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); { return kFALSE; }. Bool_t EndDrag(); { return kFALSE; }. Bool_t Drop(); { return kFALSE; }. Bool_t Cancel(Bool_t = kTRUE); { return kFALSE; }. Bool_t HandleEvent(Event_t* ); { return kFALSE; }. Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualDragManager.html:2203,Load,Load,2203,root/html602/TVirtualDragManager.html,https://root.cern,https://root.cern/root/html602/TVirtualDragManager.html,2,['Load'],['Load']
Performance,"lErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_toffset() const; virtual Double_toffsetCarry() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:20428,optimiz,optimizeCacheMode,20428,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,1,['optimiz'],['optimizeCacheMode']
Performance,"lIndex = -1); make a little printout to the stream ""out"" of the individuals up to index ""untilIndex""; this means, .. write out the best ""untilIndex"" individuals. TH1F* VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max); give back a histogram with the distribution of the coefficients; parameters:; int bins : number of bins of the histogram; int min : histogram minimum; int max : maximum value of the histogram. vector<Double_t> VariableDistribution(Int_t varNumber); gives back all the values of coefficient ""varNumber"" of the current generation. void AddPopulation( GeneticPopulation *strangers ); add another population (strangers) to the one of this GeneticPopulation. void AddPopulation( GeneticPopulation &strangers ); add another population (strangers) to the one of this GeneticPopulation. void TrimPopulation(); trim the population to the predefined size. void GiveHint(vector<Double_t>& hint, Double_t fitness = 0); add an individual (a set of variables) to the population; if there is a set of variables which is known to perform good, they can be given as a hint to the population. void Sort(); sort the genepool according to the fitness of the individuals. GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0). Int_t GetPopulationSize() const; { return fGenePool.size(); }. Double_t GetFitness() const; { return fGenePool.size()>0? fGenePool[0].GetFitness() : 0; }. const std::vector<TMVA::GeneticGenes>& GetGenePool() const; { return fGenePool; }. const std::vector<TMVA::GeneticRange*>& GetRanges() const; { return fRanges; }. std::vector<TMVA::GeneticGenes>& GetGenePool(); { return fGenePool; }. std::vector<TMVA::GeneticRange*>& GetRanges(); { return fRanges; }. void NextGeneration(); {}. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__GeneticPopulation.html:5528,perform,perform,5528,root/html534/TMVA__GeneticPopulation.html,https://root.cern,https://root.cern/root/html534/TMVA__GeneticPopulation.html,1,['perform'],['perform']
Performance,"lIndex = -1); make a little printout to the stream ""out"" of the individuals up to index ""untilIndex""; this means, .. write out the best ""untilIndex"" individuals. TH1F* VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max); give back a histogram with the distribution of the coefficients; parameters:; int bins : number of bins of the histogram; int min : histogram minimum; int max : maximum value of the histogram. vector<Double_t> VariableDistribution(Int_t varNumber); gives back all the values of coefficient ""varNumber"" of the current generation. void AddPopulation( GeneticPopulation *strangers ); add another population (strangers) to the one of this GeneticPopulation. void AddPopulation( GeneticPopulation &strangers ); add another population (strangers) to the one of this GeneticPopulation. void TrimPopulation(); trim the population to the predefined size. void GiveHint(vector<Double_t>& hint, Double_t fitness = 0); add an individual (a set of variables) to the population; if there is a set of variables which is known to perform good, they can be given as a hint to the population. void Sort(); sort the genepool according to the fitness of the individuals. GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0). Int_t GetPopulationSize() const; { return fGenePool.size(); }. Double_t GetFitness() const; { return fGenePool.size()>0? fGenePool[0].GetFitness() : 0; }. const std::vector<TMVA::GeneticGenes>& GetGenePool() const; { return fGenePool; }. const std::vector<TMVA::GeneticRange*>& GetRanges() const; { return fRanges; }. std::vector<TMVA::GeneticGenes>& GetGenePool(); { return fGenePool; }. std::vector<TMVA::GeneticRange*>& GetRanges(); { return fRanges; }. void NextGeneration(); {}. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__GeneticPopulation.html:5579,perform,perform,5579,root/html604/TMVA__GeneticPopulation.html,https://root.cern,https://root.cern/root/html604/TMVA__GeneticPopulation.html,1,['perform'],['perform']
Performance,"lIndex = -1); make a little printout to the stream ""out"" of the individuals up to index ""untilIndex""; this means, .. write out the best ""untilIndex"" individuals. TH1F* VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max); give back a histogram with the distribution of the coefficients; parameters:; int bins : number of bins of the histogram; int min : histogram minimum; int max : maximum value of the histogram. vector<Double_t> VariableDistribution(Int_t varNumber); gives back all the values of coefficient ""varNumber"" of the current generation. void AddPopulation( GeneticPopulation *strangers ); add another population (strangers) to the one of this GeneticPopulation. void AddPopulation( GeneticPopulation &strangers ); add another population (strangers) to the one of this GeneticPopulation. void TrimPopulation(); trim the population to the predefined size. void GiveHint(vector<Double_t>& hint, Double_t fitness = 0); add an individual (a set of variables) to the population; if there is a set of variables which is known to perform good, they can be given as a hint to the population. void Sort(); sort the genepool according to the fitness of the individuals. GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0). Int_t GetPopulationSize() const; { return fGenePool.size(); }. Double_t GetFitness() const; { return fGenePool.size()>0? fGenePool[0].GetFitness() : 0; }. const std::vector<TMVA::GeneticGenes>& GetGenePool() const; { return fGenePool; }. const std::vector<TMVA::GeneticRange*>& GetRanges() const; { return fRanges; }. std::vector<TMVA::GeneticGenes>& GetGenePool(); { return fGenePool; }. std::vector<TMVA::GeneticRange*>& GetRanges(); { return fRanges; }. void NextGeneration(); {}. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__GeneticPopulation.html:5571,perform,perform,5571,root/html602/TMVA__GeneticPopulation.html,https://root.cern,https://root.cern/root/html602/TMVA__GeneticPopulation.html,1,['perform'],['perform']
Performance,"lIndex = -1); make a little printout to the stream ""out"" of the individuals up to index ""untilIndex""; this means, .. write out the best ""untilIndex"" individuals. TH1F* VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max); give back a histogram with the distribution of the coefficients; parameters:; int bins : number of bins of the histogram; int min : histogram minimum; int max : maximum value of the histogram. vector<Double_t> VariableDistribution(Int_t varNumber); gives back all the values of coefficient ""varNumber"" of the current generation. void AddPopulation( GeneticPopulation *strangers ); add another population (strangers) to the one of this GeneticPopulation. void AddPopulation( GeneticPopulation &strangers ); add another population (strangers) to the one of this GeneticPopulation. void TrimPopulation(); trim the population to the predefined size. void GiveHint(vector<Double_t>& hint, Double_t fitness = 0); add an individual (a set of variables) to the population; if there is a set of variables which is known to perform good, they can be given as a hint to the population. void Sort(); sort the genepool according to the fitness of the individuals. GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0). Int_t GetPopulationSize() const; { return fGenePool.size(); }. Double_t GetFitness() const; { return fGenePool.size()>0? fGenePool[0].GetFitness() : 0; }. const std::vector<TMVA::GeneticGenes>& GetGenePool() const; { return fGenePool; }. const std::vector<TMVA::GeneticRange*>& GetRanges() const; { return fRanges; }. std::vector<TMVA::GeneticGenes>& GetGenePool(); { return fGenePool; }. std::vector<TMVA::GeneticRange*>& GetRanges(); { return fRanges; }. void NextGeneration(); {}. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GeneticPopulation.h 31574 2009-12-05 18:23:21Z stelzer $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__GeneticPopulation.html:5509,perform,perform,5509,root/html528/TMVA__GeneticPopulation.html,https://root.cern,https://root.cern/root/html528/TMVA__GeneticPopulation.html,1,['perform'],['perform']
Performance,"lIndex = -1); make a little printout to the stream ""out"" of the individuals up to index ""untilIndex""; this means, .. write out the best ""untilIndex"" individuals. TH1F* VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max); give back a histogram with the distribution of the coefficients; parameters:; int bins : number of bins of the histogram; int min : histogram minimum; int max : maximum value of the histogram. vector<Double_t> VariableDistribution(Int_t varNumber); gives back all the values of coefficient ""varNumber"" of the current generation. void AddPopulation( GeneticPopulation *strangers ); add another population (strangers) to the one of this GeneticPopulation. void AddPopulation( GeneticPopulation &strangers ); add another population (strangers) to the one of this GeneticPopulation. void TrimPopulation(); trim the population to the predefined size. void GiveHint(vector<Double_t>& hint, Double_t fitness = 0); add an individual (a set of variables) to the population; if there is a set of variables which is known to perform good, they can be given as a hint to the population. void Sort(); sort the genepool according to the fitness of the individuals. GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0). Int_t GetPopulationSize() const; { return fGenePool.size(); }. Double_t GetFitness() const; { return fGenePool.size()>0? fGenePool[0].GetFitness() : 0; }. const std::vector<TMVA::GeneticGenes>& GetGenePool() const; { return fGenePool; }. const std::vector<TMVA::GeneticRange*>& GetRanges() const; { return fRanges; }. std::vector<TMVA::GeneticGenes>& GetGenePool(); { return fGenePool; }. std::vector<TMVA::GeneticRange*>& GetRanges(); { return fRanges; }. void NextGeneration(); {}. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GeneticPopulation.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or sug",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__GeneticPopulation.html:5509,perform,perform,5509,root/html530/TMVA__GeneticPopulation.html,https://root.cern,https://root.cern/root/html530/TMVA__GeneticPopulation.html,1,['perform'],['perform']
Performance,"lIndex = -1); make a little printout to the stream ""out"" of the individuals up to index ""untilIndex""; this means, .. write out the best ""untilIndex"" individuals. TH1F* VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max); give back a histogram with the distribution of the coefficients; parameters:; int bins : number of bins of the histogram; int min : histogram minimum; int max : maximum value of the histogram. vector<Double_t> VariableDistribution(Int_t varNumber); gives back all the values of coefficient ""varNumber"" of the current generation. void AddPopulation( GeneticPopulation *strangers ); add another population (strangers) to the one of this GeneticPopulation. void AddPopulation( GeneticPopulation &strangers ); add another population (strangers) to the one of this GeneticPopulation. void TrimPopulation(); trim the population to the predefined size. void GiveHint(vector<Double_t>& hint, Double_t fitness = 0); add an individual (a set of variables) to the population; if there is a set of variables which is known to perform good, they can be given as a hint to the population. void Sort(); sort the genepool according to the fitness of the individuals. GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0). Int_t GetPopulationSize() const; { return fGenePool.size(); }. Double_t GetFitness() const; { return fGenePool.size()>0? fGenePool[0].GetFitness() : 0; }. const std::vector<TMVA::GeneticGenes>& GetGenePool() const; { return fGenePool; }. const std::vector<TMVA::GeneticRange*>& GetRanges() const; { return fRanges; }. std::vector<TMVA::GeneticGenes>& GetGenePool(); { return fGenePool; }. std::vector<TMVA::GeneticRange*>& GetRanges(); { return fRanges; }. void NextGeneration(); {}. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GeneticPopulation.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__GeneticPopulation.html:5509,perform,perform,5509,root/html532/TMVA__GeneticPopulation.html,https://root.cern,https://root.cern/root/html532/TMVA__GeneticPopulation.html,1,['perform'],['perform']
Performance,"lIntegral ; (; const RooRealIntegral & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 710 of file RooRealIntegral.cxx. ◆ ~RooRealIntegral(). RooRealIntegral::~RooRealIntegral ; (; ). override . Definition at line 739 of file RooRealIntegral.cxx. Member Function Documentation. ◆ actualFuncNormSet(). RooArgSet const * RooRealIntegral::actualFuncNormSet ; (; ); const. inlineprotected . Definition at line 112 of file RooRealIntegral.h. ◆ addNumIntDep(). void RooRealIntegral::addNumIntDep ; (; RooAbsArg const & ; arg). private . Sort numeric integration variables in summation and integration lists. ; To be used during construction. ; Definition at line 1186 of file RooRealIntegral.cxx. ◆ anaIntVars(). const RooArgSet & RooRealIntegral::anaIntVars ; (; ); const. inline . Definition at line 49 of file RooRealIntegral.h. ◆ autoSelectDirtyMode(). void RooRealIntegral::autoSelectDirtyMode ; (; ). protected . Set appropriate cache operation mode for integral depending on cache operation mode of server objects. ; Definition at line 633 of file RooRealIntegral.cxx. ◆ Class(). static TClass * RooRealIntegral::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooRealIntegral::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooRealIntegral::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 150 of file RooRealIntegral.h. ◆ clone(). TObject * RooRealIntegral::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 37 of file RooRealIntegral.h. ◆ compileForNormSet(). std::unique_ptr< RooAbsArg > RooRealIntegral::compileForNormSet ; (; RooArgSet const & ; normSet, . RooFit::Detail::CompileContext & ; ctx . ); const. overridevirtual . Reimplemented from RooAbsArg.; Definition at line 1179 of file RooRealIntegral.cxx. ◆ createIntegral(). RooFit::OwningPtr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:66202,cache,cache,66202,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,2,['cache'],['cache']
Performance,"lIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedReal.html:2716,Cache,CacheModeRooAbsArg,2716,root/html534/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedReal.html,3,['Cache'],['CacheModeRooAbsArg']
Performance,"lNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,double>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction4Ref<VO,VI1,VI2,VI3,VI4> Streame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_double_.html:36919,cache,cache,36919,root/html602/RooCFunction4Binding_double_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_double_.html,4,['cache'],['cache']
Performance,"lPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxyc; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Heaviside(const char* name, const char* title, RooAbsReal& _x, RooAbsReal& _c). Heaviside(const RooStats::Heaviside& other, const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__Heaviside.html:34457,cache,cache,34457,root/html534/RooStats__Heaviside.html,https://root.cern,https://root.cern/root/html534/RooStats__Heaviside.html,2,['cache'],['cache']
Performance,"lProxy_pdf1First input p.d.f; RooRealProxy_pdf2Second input p.d.f; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Double_t_shift1; Double_t_shift2; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_xConvolution observable; RooRealProxy_xprimeInput function representing value of convolution observable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Librari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFFTConvPdf.html:46377,cache,cache,46377,root/html532/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html532/RooFFTConvPdf.html,3,['cache'],['cache']
Performance,"lSelector to be used for generate data for benchmarks; TStringfDataParList of par files to be loaded for data benchmarks; TStringfDataSelSelector to be used for data benchmarks; TStringfDataSetName of the dataset; Bool_tfDebugDebug switch; TPBHistType*fHistTypeType of histograms for CPU runs; Int_tfNFilesWrkNumber of files generated files per worker; Int_tfNHistNumber of histograms to be created in default CPU runs; Int_tfNtriesNumber of times a measurement is repeated; TFile*fOutFileOutput file; TStringfOutFileNameName of the output file; TProof*fProofProof; TProof*fProofDSProof to be used for dataset actions; TPBReadType*fReadTypeType of read (partial, full); TProofBenchRunCPU*fRunCPUInstance to run CPU scans; TProofBenchRunDataRead*fRunDSInstance to run data-read scans. private:. Bool_tfUnlinkOutfileWhether to remove empty output files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBench(const char* url, const char* outfile = ""<default>"", const char* proofopt = 0); Constructor: check PROOF and load selectors PAR. ~TProofBench(); Destructor. Int_t OpenOutFile(Bool_t wrt = kFALSE, Bool_t verbose = kTRUE); Set the otuput file; Return 0 on success, -1 on error. Int_t SetOutFile(const char* outfile, Bool_t verbose = kTRUE); Set the output file; Return 0 on success, -1 on error. void CloseOutFile(); Close output file. Int_t RunCPU(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1, Int_t step = -1); Perform the CPU run; Return 0 on success, -1 on error. Int_t RunCPUx(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1); Perform the CPU run scanning over the number of workers per node; Return 0 on success, -1 on error. void DrawCPU(const char* outfile, const char* opt = ""std:""); Draw the CPU speedup plot.; opt = 'std:' draw standard evt/s plot; 'stdx:' draw standard evt/s plot, 1 worker per node; 'norm:' draw normalized plot; 'normx:' draw normalized plot, 1 worker per node. Int_t RunDataSet(const char* dset ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofBench.html:7958,load,load,7958,root/html532/TProofBench.html,https://root.cern,https://root.cern/root/html532/TProofBench.html,1,['load'],['load']
Performance,"lSet with derived / dependant elements. ;  ; virtual void GetCellData (const CellId_t &id, CellData_t &data) const =0;  ; virtual void GetCellList (Float_t etaMin, Float_t etaMax, Float_t phi, Float_t phiRng, vCellId_t &out) const =0;  ; vCellId_t & GetCellsHighlighted ();  ; vCellId_t & GetCellsSelected ();  ; virtual Float_t GetEps () const;  ; virtual TAxis * GetEtaBins () const;  ; virtual void GetEtaLimits (Double_t &min, Double_t &max) const =0;  ; TString GetHighlightTooltip () override;  ; virtual Float_t GetMaxVal (Bool_t et) const;  ; Int_t GetNSlices () const;  ; virtual TAxis * GetPhiBins () const;  ; virtual void GetPhiLimits (Double_t &min, Double_t &max) const =0;  ; Color_t GetSliceColor (Int_t slice) const;  Get color for given slice. ;  ; Float_t GetSliceThreshold (Int_t slice) const;  Get threshold for given slice. ;  ; Char_t GetSliceTransparency (Int_t slice) const;  Get transparency for given slice. ;  ; Bool_t GetWrapTwoPi () const;  ; virtual void InvalidateUsersCellIdCache ();  Invalidate cell ids cache on back ptr references. ;  ; TClass * IsA () const override;  ; void PrintCellsSelected ();  Print selected cells info. ;  ; void ProcessSelection (vCellId_t &sel_cells, TGLSelectRecord &rec);  Process newly selected cells with given select-record. ;  ; virtual void Rebin (TAxis *ax, TAxis *ay, vCellId_t &in, Bool_t et, RebinData_t &out) const =0;  ; SliceInfo_t & RefSliceInfo (Int_t s);  ; virtual void SetEps (Float_t eps);  ; virtual void SetEtaBins (TAxis *ax);  ; virtual void SetPhiBins (TAxis *ax);  ; void SetSliceColor (Int_t slice, Color_t col);  Set color for given slice. ;  ; void SetSliceThreshold (Int_t slice, Float_t threshold);  Set threshold for given slice. ;  ; void SetSliceTransparency (Int_t slice, Char_t t);  Set transparency for given slice. ;  ; void SetWrapTwoPi (Bool_t w);  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UnHighlighted () override;  Virtual me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloData.html:4068,cache,cache,4068,doc/master/classTEveCaloData.html,https://root.cern,https://root.cern/doc/master/classTEveCaloData.html,1,['cache'],['cache']
Performance,"lShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. private:. Double_tfDz; TGLVector3fHighPlaneNorm; TGLVector3fLowPlaneNorm; Double_tfPhi1; Double_tfPhi2; Double_tfR1; Double_tfR2; Double_tfR3; Double_tfR4; Bool_tfSegMesh. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLCylinder(const TBuffer3DTube& buffer); Copy out relevant parts of buffer - we create and delete mesh; parts on demand in DirectDraw() and they are DL cached. ~TGLCylinder(); destructor. UInt_t DLOffset(Short_t lod) const; Return display-list offset for given LOD.; Calculation based on what is done in virtual QuantizeShapeLOD below. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Factor in scene/viewer LOD and quantize. void DirectDraw(TGLRnrCtx& rnrCtx) const; Debug tracing. ELODAxes SupportedLODAxes() const; Cylinders support LOD (tesselation quality) adjustment along; X/Y axes (round the cylinder radius), but not along length (Z). { return ELODAxes(kLODAxesX | kLODAxesY); }. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-03-13 19:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLCylinder.html:3976,cache,cached,3976,root/html534/TGLCylinder.html,https://root.cern,https://root.cern/root/html534/TGLCylinder.html,1,['cache'],['cached']
Performance,"lStreamerInfo::SetClassVersionvirtual void SetClassVersion(Int_t vers)=0; TVirtualStreamerInfo::GenEmulatedClassStreamervirtual TClassStreamer * GenEmulatedClassStreamer(const char *class_name, Bool_t silent)=0; TVirtualStreamerInfo::IsCompiledBool_t IsCompiled() constDefinition TVirtualStreamerInfo.h:163; TVirtualStreamerInfo::NewInfovirtual TVirtualStreamerInfo * NewInfo(TClass *cl)=0; TVirtualStreamerInfo::GetActualClassvirtual TClass * GetActualClass(const void *obj) const =0; TVirtualStreamerInfo::GetCheckSumvirtual UInt_t GetCheckSum() const =0; TVirtualStreamerInfo::GetOffsetvirtual Int_t GetOffset(const char *) const =0; TVirtualStreamerInfo::GetElementCounterStartstatic const char * GetElementCounterStart(const char *dmTitle)Given a comment/title declaring an array counter, for example:Definition TVirtualStreamerInfo.cxx:99; TVirtualStreamerInfo::Buildvirtual void Build(Bool_t isTransient=kFALSE)=0; TVirtualStreamerInfo::BuildCheckvirtual void BuildCheck(TFile *file=nullptr, Bool_t load=kTRUE)=0; TVirtualStreamerInfo::BuildForvirtual Bool_t BuildFor(const TClass *cl)=0; TVirtualStreamerInfo::kBase@ kBaseDefinition TVirtualStreamerInfo.h:91; TVirtualStreamerInfo::kCharStar@ kCharStarDefinition TVirtualStreamerInfo.h:91; TVirtualStreamerInfo::kAny@ kAnyDefinition TVirtualStreamerInfo.h:96; TVirtualStreamerInfo::kObject@ kObjectDefinition TVirtualStreamerInfo.h:96; TVirtualStreamerInfo::kTObject@ kTObjectDefinition TVirtualStreamerInfo.h:97; TVirtualStreamerInfo::kTNamed@ kTNamedDefinition TVirtualStreamerInfo.h:97; TVirtualStreamerInfo::GenExplicitProxyvirtual TVirtualCollectionProxy * GenExplicitProxy(const ::ROOT::Detail::TCollectionProxyInfo &info, TClass *cl)=0; TVirtualStreamerInfo::NewArrayvirtual void * NewArray(Long_t nElements, void *ary=nullptr)=0; TVirtualStreamerInfo::GenEmulatedProxyvirtual TVirtualCollectionProxy * GenEmulatedProxy(const char *class_name, Bool_t silent)=0; TVirtualStreamerInfo::SetClassvirtual void SetClass(TClass *cl)=0; TVirtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:371642,load,load,371642,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"lStreamerInfo::SetClassVersionvirtual void SetClassVersion(Int_t vers)=0; TVirtualStreamerInfo::GenEmulatedClassStreamervirtual TClassStreamer * GenEmulatedClassStreamer(const char *class_name, Bool_t silent)=0; TVirtualStreamerInfo::IsCompiledBool_t IsCompiled() constDefinition TVirtualStreamerInfo.h:173; TVirtualStreamerInfo::NewInfovirtual TVirtualStreamerInfo * NewInfo(TClass *cl)=0; TVirtualStreamerInfo::GetActualClassvirtual TClass * GetActualClass(const void *obj) const =0; TVirtualStreamerInfo::GetCheckSumvirtual UInt_t GetCheckSum() const =0; TVirtualStreamerInfo::GetOffsetvirtual Int_t GetOffset(const char *) const =0; TVirtualStreamerInfo::GetElementCounterStartstatic const char * GetElementCounterStart(const char *dmTitle)Given a comment/title declaring an array counter, for example:Definition TVirtualStreamerInfo.cxx:99; TVirtualStreamerInfo::Buildvirtual void Build(Bool_t isTransient=kFALSE)=0; TVirtualStreamerInfo::BuildCheckvirtual void BuildCheck(TFile *file=nullptr, Bool_t load=kTRUE)=0; TVirtualStreamerInfo::BuildForvirtual Bool_t BuildFor(const TClass *cl)=0; TVirtualStreamerInfo::kBase@ kBaseDefinition TVirtualStreamerInfo.h:117; TVirtualStreamerInfo::kCharStar@ kCharStarDefinition TVirtualStreamerInfo.h:117; TVirtualStreamerInfo::kAny@ kAnyDefinition TVirtualStreamerInfo.h:123; TVirtualStreamerInfo::kObject@ kObjectDefinition TVirtualStreamerInfo.h:123; TVirtualStreamerInfo::kTObject@ kTObjectDefinition TVirtualStreamerInfo.h:124; TVirtualStreamerInfo::kTNamed@ kTNamedDefinition TVirtualStreamerInfo.h:124; TVirtualStreamerInfo::GenExplicitProxyvirtual TVirtualCollectionProxy * GenExplicitProxy(const ::ROOT::Detail::TCollectionProxyInfo &info, TClass *cl)=0; TVirtualStreamerInfo::NewArrayvirtual void * NewArray(Long_t nElements, void *ary=nullptr)=0; TVirtualStreamerInfo::GenEmulatedProxyvirtual TVirtualCollectionProxy * GenEmulatedProxy(const char *class_name, Bool_t silent)=0; TVirtualStreamerInfo::SetClassvirtual void SetClass(TClass *cl)=0; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:374349,load,load,374349,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"lStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; UniqueId.h; RooAbsArgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsCacheElementAbstract base class for objects to be stored in RooAbsCache cache manager objects.Definition RooAbsCacheElement.h:26; RooAbsCacheElement::ActionActionDefinition RooAbsCacheElement.h:39; RooAbsCollectionAbstract container object that can hold multiple RooAbsArg objects.Definition RooAbsCollection.h:65; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsGenContextAbstract base class for generator contexts of RooAbsPdf objects.Definition RooAbsGenContext.h:26; RooAbsPdf::CacheElemNormalization set with for above integral.Definition RooAbsPdf.h:322; RooAbsPdf::CacheElem::_normstd::unique_ptr< RooAbsReal > _normDefinition RooAbsPdf.h:327; RooAbsPdf::CacheElem::~CacheElem~CacheElem() overrideDestructor of normalization cache element.Definition RooAbsPdf.cxx:2430; RooAbsPdf::CacheElem::CacheElemCacheElem(RooAbsReal &norm)Definition RooAbsPdf.h:324; RooAbsPdf::CacheElem::containedArgsRooArgList containedArgs(Action) overrideDefinition RooAbsPdf.h:326; RooAbsPdf::GenSpecDefinition RooAbsPdf.h:72; RooAbsPdf::GenSpec::_genContextstd::unique_ptr< RooAbsGenContext > _genContextDefinition RooAbsPdf.h:83; RooAbsPdf::GenSpec::~GenSpecvirtual ~GenSpec(); RooAbsPdf::GenSpec::_whatVarsRooArgSet _whatVarsDefinition RooAbsPdf.h:84; RooAbsPdf::GenSpec::_initbool _initDefinition RooAbsPdf.h:91; RooAbsPdf::GenSpec::_extendedbool _extendedDefinition RooAbsPdf.h:87; RooAbsPdf::GenSpec::GenSpecGenSpec(const GenSpec &other); RooAbsPdf::GenSpec::_nGenInt_t _nGenDefinition RooAbsPdf.h:86; RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8h_source.html:18658,Cache,CacheElemNormalization,18658,doc/master/RooAbsPdf_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html,1,['Cache'],['CacheElemNormalization']
Performance,"lTolerance(double eps) overrideSet the desired relative Error.Definition GaussIntegrator.h:65; ROOT::Math::GaussIntegrator::Integraldouble Integral(double a, double b) overrideReturns Integral of function between a and b.Definition GaussIntegrator.cxx:52; ROOT::Math::GaussIntegrator::IntegralUpdouble IntegralUp(double a) overrideReturns Integral of function on an upper semi-infinite interval.Definition GaussIntegrator.cxx:61; ROOT::Math::GaussIntegrator::SetFunctionvoid SetFunction(const IGenFunction &) overrideSet integration function (flag control if function must be copied inside).Definition GaussIntegrator.cxx:182; ROOT::Math::GaussIntegrator::IntegralLowdouble IntegralLow(double b) overrideReturns Integral of function on a lower semi-infinite interval.Definition GaussIntegrator.cxx:66; ROOT::Math::GaussIntegrator::Statusint Status() const overridereturn the status of the last integration - 0 in case of successDefinition GaussIntegrator.cxx:179; ROOT::Math::GaussLegendreIntegratorUser class for performing function integration.Definition GaussLegendreIntegrator.h:37; ROOT::Math::GaussLegendreIntegrator::GetWeightVectorsvoid GetWeightVectors(double *x, double *w) constReturns the arrays x and w containing the abscissa and weight of the Gauss-Legendre n-point quadratur...Definition GaussLegendreIntegrator.cxx:51; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorTypestatic IntegrationMultiDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:341; ROOT::Math::IntegratorMultiDimOptions::DefaultNCallsstatic unsigned int DefaultNCalls()Definition IntegratorOptions.cxx:370; ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:368; ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:158847,perform,performing,158847,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['perform'],['performing']
Performance,"lTypePtr) const;  ; bool IsUnsignedIntegerType (const void *QualTypePtr) const;  ; bool IsVoidPointerType (const void *QualTypePtr) const;  ; void * LazyFunctionCreatorAutoload (const std::string &mangled_name);  Autoload a library based on a missing symbol. ;  ; void LibraryLoaded (const void *dyLibHandle, const char *canonicalName);  ; bool LibraryLoadingFailed (const std::string &, const std::string &, bool, bool);  ; void LibraryUnloaded (const void *dyLibHandle, const char *canonicalName);  ; Int_t Load (const char *filenam, Bool_t system=kFALSE) final;  Load a library file in cling's memory. ;  ; void LoadEnums (TListOfEnums &cl) const final;  Create list of pointers to enums for TClass cl. ;  ; int LoadFile (const char *path) const final;  Load a source file or library called path into the interpreter. ;  ; virtual void LoadFunctionTemplates (TClass *cl) const final;  Create list of pointers to function templates for TClass cl. ;  ; Int_t LoadLibraryMap (const char *rootmapfile=nullptr) final;  Load map between class and library. ;  ; void LoadMacro (const char *filename, EErrorCode *error=nullptr) final;  Load a macro file in cling's memory. ;  ; Bool_t LoadText (const char *text) const final;  Load the declarations from text into the interpreter. ;  ; std::unique_ptr< TInterpreterValue > MakeInterpreterValue () const final;  ; const char * MapCppName (const char *) const final;  Interface to cling function. ;  ; const char * MethodArgInfo_DefaultValue (MethodArgInfo_t *marginfo) const final;  ; void MethodArgInfo_Delete (MethodArgInfo_t *marginfo) const final;  ; MethodArgInfo_t * MethodArgInfo_Factory () const final;  ; MethodArgInfo_t * MethodArgInfo_Factory (MethodInfo_t *minfo) const final;  ; MethodArgInfo_t * MethodArgInfo_FactoryCopy (MethodArgInfo_t *marginfo) const final;  ; bool MethodArgInfo_IsValid (MethodArgInfo_t *marginfo) const final;  ; const char * MethodArgInfo_Name (MethodArgInfo_t *marginfo) const final;  ; int MethodArgInfo_Next (Metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:24082,Load,LoadLibraryMap,24082,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,2,['Load'],"['Load', 'LoadLibraryMap']"
Performance,"lTypes>::value...>::value;; 3207 static_assert(areCopyConstructible, ""Columns of a type which is not copy constructible cannot be cached yet."");; 3208 ; 3209 RDFInternal::CheckTypesAndPars(sizeof...(ColTypes), columnListWithoutSizeColumns.size());; 3210 ; 3211 auto colHolders = std::make_tuple(Take<ColTypes>(columnListWithoutSizeColumns[S])...);; 3212 auto ds = std::make_unique<RLazyDS<ColTypes...>>(; 3213 std::make_pair(columnListWithoutSizeColumns[S], std::get<S>(colHolders))...);; 3214 ; 3215 RInterface<RLoopManager> cachedRDF(std::make_shared<RLoopManager>(std::move(ds), columnListWithoutSizeColumns));; 3216 ; 3217 return cachedRDF;; 3218 }; 3219 ; 3220 template <bool IsSingleColumn, typename F>; 3221 RInterface<Proxied, DS_t>; 3222 VaryImpl(const std::vector<std::string> &colNames, F &&expression, const ColumnNames_t &inputColumns,; 3223 const std::vector<std::string> &variationTags, std::string_view variationName); 3224 {; 3225 using F_t = std::decay_t<F>;; 3226 using ColTypes_t = typename TTraits::CallableTraits<F_t>::arg_types;; 3227 using RetType = typename TTraits::CallableTraits<F_t>::ret_type;; 3228 constexpr auto nColumns = ColTypes_t::list_size;; 3229 ; 3230 SanityChecksForVary<RetType>(colNames, variationTags, variationName);; 3231 ; 3232 const auto validColumnNames = GetValidatedColumnNames(nColumns, inputColumns);; 3233 CheckAndFillDSColumns(validColumnNames, ColTypes_t{});; 3234 ; 3235 auto retTypeName = RDFInternal::TypeID2TypeName(typeid(RetType));; 3236 if (retTypeName.empty()) {; 3237 // The type is not known to the interpreter, but we don't want to error out; 3238 // here, rather if/when this column is used in jitted code, so we inject a broken but telling type name.; 3239 const auto demangledType = RDFInternal::DemangleTypeIdName(typeid(RetType));; 3240 retTypeName = ""CLING_UNKNOWN_TYPE_"" + demangledType;; 3241 }; 3242 ; 3243 auto variation = std::make_shared<RDFInternal::RVariation<F_t, IsSingleColumn>>(; 3244 colNames, variationName, std::f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:183056,cache,cachedRDF,183056,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,2,['cache'],['cachedRDF']
Performance,"lVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; # than taking point at center of bin; fit2 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1, Integrate=True); fit2.Print(); ; # Overlay alternate fit result; f.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Draw the plot on a canvas; c = ROOT.TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf609_xychi2fit.png""); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.16828, estimated distance to minimum: 3.27623e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.5827e-02 +/- 6.43e-01; b 2.9994e-01 +/- 4.78e-01; c 1.0408e+00 +/- 1.04e-01; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2.77875, estimated distance to minimum: 0.000387499; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.9593e-02 +/- 3.62e-01; b 4.5829e-02 +/- 4.65e-01; c 1.0343e+00 +/- 5.76e-02; ; DateFebruary",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf609__xychi2fit_8py.html:2525,optimiz,optimization,2525,doc/master/rf609__xychi2fit_8py.html,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html,2,['optimiz'],['optimization']
Performance,lVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genFlavFrac!; Double_t_genFlavFracMix!; Double_t_genFlavFracUnmix!; Double_t_genMixFrac! do not persist; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_mistag; RooCategoryProxy_mixState; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBMixDecay.html:38983,cache,cache,38983,root/html526/RooBMixDecay.html,https://root.cern,https://root.cern/root/html526/RooBMixDecay.html,1,['cache'],['cache']
Performance,lVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genFlavFrac!; Double_t_genFlavFracMix!; Double_t_genFlavFracUnmix!; Double_t_genMixFrac! do not persist; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_mistag; RooCategoryProxy_mixState; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBMixDecay.html:39557,cache,cache,39557,root/html528/RooBMixDecay.html,https://root.cern,https://root.cern/root/html528/RooBMixDecay.html,3,['cache'],['cache']
Performance,"lX::ETextMode mode); Draw text using TrueType fonts. If TrueType fonts are not available the; text is drawn with TGX11::DrawText. RXImage * GetBackground(Int_t x, Int_t y, UInt_t w, UInt_t h); Get the background of the current window in an XImage. Bool_t IsVisible(Int_t x, Int_t y, UInt_t w, UInt_t h); Test if there is really something to render. void RenderString(Int_t x, Int_t y, TVirtualX::ETextMode mode); Perform the string rendering in the pad.; LayoutGlyphs should have been called before. void SetTextFont(Font_t fontnumber); Set specified font. Int_t SetTextFont(char* fontname, TVirtualX::ETextSetMode mode); Set text font to specified name.; mode : loading flag; mode=0 : search if the font exist (kCheck); mode=1 : search the font and load it if it exists (kLoad); font : font name. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextSize(Float_t textsize); Set current text size. FontStruct_t LoadQueryFont(const char* font_name); Parses an XLFD name and opens a font. void DeleteFont(FontStruct_t fs); Explicitely delete font structure obtained with LoadQueryFont(). void DeleteGC(GContext_t gc); Explicitely delete a graphics context. FontH_t GetFontHandle(FontStruct_t fs); Return handle to font described by font structure. FontStruct_t GetGCFont(GContext_t gc); Return the font associated with the graphics context gc. void MapGCFont(GContext_t gc, FontStruct_t font); Map the XftFont with the Graphics Context using it. Int_t TextWidth(FontStruct_t font, const char* s, Int_t len); Return length of string in pixels. Size depends on font. void GetFontProperties(FontStruct_t font, Int_t& max_ascent, Int_t& max_descent); Return some font properties. void DrawString(Drawable_t id, GContext_t gc, Int_t x, Int_t y, const char* s, Int_t len); Draw text string. TGX11TTF(const TGX11& org). virtual ~TGX11TTF(); { }. » Author: Olivier Couet 01/10/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last chan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGX11TTF.html:29009,Load,LoadQueryFont,29009,root/html604/TGX11TTF.html,https://root.cern,https://root.cern/root/html604/TGX11TTF.html,1,['Load'],['LoadQueryFont']
Performance,"l_t ShouldImport(TEveElement* el); Returns true if element el should be imported. Behaviour depends on the value of the fImportEmpty member:; false - el or any of its children must be projectable (default);; true - always import. void UpdateDependentElsAndScenes(TEveElement* root); Update dependent elements' bounding box and mark scenes; containing element root or its children as requiring a repaint. TEveElement* ImportElementsRecurse(TEveElement* el, TEveElement* parent); If el is TEveProjectable add projected instance else add plain; TEveElementList to parent. Call the same function on el's; children. Returns the projected replica of el. Can be 0, if el and none of; its children are projectable. TEveElement* ImportElements(TEveElement* el, TEveElement* ext_list = 0); Recursively import elements and apply projection to the newly; imported objects. If ext_list is not 0 the new element is also added to the list.; This simplifies construction of complex views where projected; elements are distributed into several scenes for optimization of; updates and rendering. Returns the projected replica of el. Can be 0, if el and none of; its children are projectable. TEveElement* SubImportElements(TEveElement* el, TEveElement* proj_parent); Recursively import elements and apply projection to the newly; imported objects. The proj_parent argument should be a projected replica of parent; of element 'el'. This allows to insert projected children of; a given element when they are added after the projection has; been already performed on the parent.; This is called from TEveElement::ProjectChild(). Returns the projected replica of el. Can be 0, if el and none of; its children are projectable. Int_t SubImportChildren(TEveElement* el, TEveElement* proj_parent); Recursively import childer elements of el and apply projection; to the newly imported objects. The proj_parent argument should be a projected replica of; element 'el'. This allows to insert projected children of; a given element ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveProjectionManager.html:23026,optimiz,optimization,23026,root/html528/TEveProjectionManager.html,https://root.cern,https://root.cern/root/html528/TEveProjectionManager.html,6,['optimiz'],['optimization']
Performance,"l_t TClass::IsVersioned ; (; ); const. inline . Definition at line 522 of file TClass.h. ◆ Load(). TClass * TClass::Load ; (; TBuffer & ; b). static . Load class description from I/O buffer and return class object. ; Definition at line 5715 of file TClass.cxx. ◆ LoadClass(). TClass * TClass::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent . ). static . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5749 of file TClass.cxx. ◆ LoadClassCustom(). TClass * TClass::LoadClassCustom ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5801 of file TClass.cxx. ◆ LoadClassDefault(). TClass * TClass::LoadClassDefault ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the TClassTable or the autoloader. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5771 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:102278,load,load,102278,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['load']
Performance,"l_t TClass::IsVersioned ; (; ); const. inline . Definition at line 522 of file TClass.h. ◆ Load(). TClass * TClass::Load ; (; TBuffer & ; b). static . Load class description from I/O buffer and return class object. ; Definition at line 5782 of file TClass.cxx. ◆ LoadClass(). TClass * TClass::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent . ). static . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5816 of file TClass.cxx. ◆ LoadClassCustom(). TClass * TClass::LoadClassCustom ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5868 of file TClass.cxx. ◆ LoadClassDefault(). TClass * TClass::LoadClassDefault ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the TClassTable or the autoloader. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5838 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:102279,load,load,102279,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['load']
Performance,"l_t TFilePrefetch::IsPrefetchFinished ; (; ); const. inline . Definition at line 82 of file TFilePrefetch.h. ◆ ReadAsync(). void TFilePrefetch::ReadAsync ; (; TFPBlock * ; block, . Bool_t & ; inCache . ). Read one block and insert it in prefetchBuffers list. ; Definition at line 106 of file TFilePrefetch.cxx. ◆ ReadBlock(). void TFilePrefetch::ReadBlock ; (; Long64_t * ; offset, . Int_t * ; len, . Int_t ; nblock . ). Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. ; Definition at line 214 of file TFilePrefetch.cxx. ◆ ReadBuffer(). Bool_t TFilePrefetch::ReadBuffer ; (; char * ; buf, . Long64_t ; offset, . Int_t ; len . ). Return a prefetched element. ; Definition at line 178 of file TFilePrefetch.cxx. ◆ ReadListOfBlocks(). void TFilePrefetch::ReadListOfBlocks ; (; ). Get blocks specified in prefetchBlocks. ; Definition at line 128 of file TFilePrefetch.cxx. ◆ SaveBlockInCache(). void TFilePrefetch::SaveBlockInCache ; (; TFPBlock * ; block). Save the block content in cache. ; Definition at line 474 of file TFilePrefetch.cxx. ◆ SetCache(). Bool_t TFilePrefetch::SetCache ; (; const char * ; path). Set the path of the cache directory. ; Definition at line 526 of file TFilePrefetch.cxx. ◆ SetFile(). void TFilePrefetch::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). Change the file. ; When prefetching is enabled we also need to:; make sure the async thread is not doing any work; clear all blocks from prefetching and read list; reset the file pointer . Definition at line 317 of file TFilePrefetch.cxx. ◆ Streamer(). void TFilePrefetch::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TFilePrefetch::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 84 of file TFilePrefetch.h. ◆ SumHex(). Int_t TFilePrefetch::SumHex ; (; const char * ; hex). Sum up individual hex values to ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFilePrefetch.html:17444,cache,cache,17444,doc/master/classTFilePrefetch.html,https://root.cern,https://root.cern/doc/master/classTFilePrefetch.html,1,['cache'],['cache']
Performance,"l_t bLoadLibs = kTRUE); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. static TApplication::EExitOnExceptionTApplication::kAbort; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TApplication::EStatusBitsTApplication::kDefaultApplication; static TApplication::EExitOnExceptionTApplication::kDontExit; static TApplication::EExitOnE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/PyROOT__TPyROOTApplication.html:11852,Load,LoadGraphicsLibs,11852,root/html602/PyROOT__TPyROOTApplication.html,https://root.cern,https://root.cern/root/html602/PyROOT__TPyROOTApplication.html,2,['Load'],['LoadGraphicsLibs']
Performance,"l_t flag) -- Constrols RooFit informational messages in likelihood construction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true). RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:49295,perform,performed,49295,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['perform'],['performed']
Performance,"l_t lock=kTRUE)=0; TInterpreter::Loadvirtual Int_t Load(const char *filenam, Bool_t system=kFALSE)=0; TInterpreter::TypeInfo_Factoryvirtual TypeInfo_t * TypeInfo_Factory(const char *) constDefinition TInterpreter.h:526; TInterpreter::CallFunc_GetWrapperCodevirtual std::string CallFunc_GetWrapperCode(CallFunc_t *func) const =0; TInterpreter::ClassInfo_Propertyvirtual Long_t ClassInfo_Property(ClassInfo_t *) constDefinition TInterpreter.h:429; TInterpreter::Evaluatevirtual int Evaluate(const char *, TInterpreterValue &)Definition TInterpreter.h:281; TInterpreter::CallFunc_SetArgvoid CallFunc_SetArg(CallFunc_t *func, Int_t param) constDefinition TInterpreter.h:342; TInterpreter::TypeInfo_Factoryvirtual TypeInfo_t * TypeInfo_Factory() constDefinition TInterpreter.h:525; TInterpreter::MethodInfo_NDefaultArgvirtual int MethodInfo_NDefaultArg(MethodInfo_t *) constDefinition TInterpreter.h:495; TInterpreter::LoadFunctionTemplatesvirtual void LoadFunctionTemplates(TClass *cl) const =0; TInterpreter::IsUnsignedIntegerTypevirtual Bool_t IsUnsignedIntegerType(const void *) constDefinition TInterpreter.h:556; TInterpreter::FunctionDeclId_IsMethodvirtual Bool_t FunctionDeclId_IsMethod(DeclId_t) constDefinition TInterpreter.h:562; TInterpreter::DataMemberInfo_Offsetvirtual Longptr_t DataMemberInfo_Offset(DataMemberInfo_t *) constDefinition TInterpreter.h:463; TInterpreter::ClassInfo_Factoryvirtual ClassInfo_t * ClassInfo_Factory(const char *) const =0; TInterpreter::TypedefInfo_Deletevirtual void TypedefInfo_Delete(TypedefInfo_t *) constDefinition TInterpreter.h:539; TInterpreter::CallFunc_Execvirtual void CallFunc_Exec(CallFunc_t *, void *) constDefinition TInterpreter.h:315; TInterpreter::MethodArgInfo_IsValidvirtual Bool_t MethodArgInfo_IsValid(MethodArgInfo_t *) constDefinition TInterpreter.h:513; TInterpreter::CallFunc_SetArgvirtual void CallFunc_SetArg(CallFunc_t *, Long64_t) const =0; TInterpreter::CheckClassInfovirtual ECheckClassInfo CheckClassInfo(const char *name, Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TInterpreter_8h_source.html:54610,Load,LoadFunctionTemplatesvirtual,54610,doc/master/TInterpreter_8h_source.html,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html,2,['Load'],"['LoadFunctionTemplates', 'LoadFunctionTemplatesvirtual']"
Performance,"l_t printError = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tRooAbsCategoryLValue::volume(const char* rangeName) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSuperCategory.html:16749,cache,cache,16749,root/html528/RooSuperCategory.html,https://root.cern,https://root.cern/root/html528/RooSuperCategory.html,2,['cache'],['cache']
Performance,"l_t random=kFALSE);  Tell PROOF how many slaves to use in parallel. ;  ; void SetParameter (const char *par, const char *value);  Set input list parameter. ;  ; void SetParameter (const char *par, Double_t value);  Set an input list parameter. ;  ; void SetParameter (const char *par, Int_t value);  Set an input list parameter. ;  ; void SetParameter (const char *par, Long64_t value);  Set an input list parameter. ;  ; void SetParameter (const char *par, Long_t value);  Set an input list parameter. ;  ; void SetPerfTree (const char *pf=""perftree.root"", Bool_t withWrks=kFALSE);  Enable/Disable saving of the performance tree. ;  ; void SetPrintProgress (PrintProgress_t pp);  ; void SetProgressDialog (Bool_t on=kTRUE);  Enable/Disable the graphic progress dialog. ;  ; void SetQueryMode (EQueryMode mode);  Change query running mode to the one specified by 'mode'. ;  ; void SetRealTimeLog (Bool_t on=kTRUE);  Switch ON/OFF the real-time logging facility. ;  ; virtual void ShowCache (Bool_t all=kFALSE);  List contents of file cache. ;  ; virtual void ShowData ();  List contents of the data directory in the sandbox. ;  ; void ShowDataSet (const char *dataset="""", const char *opt=""filter:SsCc"");  display meta-info for given dataset usi ;  ; virtual void ShowDataSetCache (const char *dataset=0);  Display the content of the dataset cache, if any (matching 'dataset', if defined). ;  ; void ShowDataSetQuota (Option_t *opt=0);  shows the quota and usage of all groups if opt contains ""U"" shows also distribution of usage on user-level ;  ; virtual void ShowDataSets (const char *uri="""", const char *optStr="""");  Shows datasets in locations that match the uri. ;  ; void ShowEnabledPackages (Bool_t all=kFALSE);  List which packages are enabled. ;  ; void ShowFeedback () const;  Show items in feedback list. ;  ; void ShowLog (const char *queryref);  Display on screen the content of the temporary log file for query in reference. ;  ; void ShowLog (Int_t qry=-1);  Display on screen the conte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:19298,cache,cache,19298,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['cache'],['cache']
Performance,"l_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2PdfBinding<double,int,int>&operator=(const RooCFunction2PdfBinding<double,int,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_int_.html:23506,optimiz,optimizeCacheMode,23506,root/html602/RooCFunction2PdfBinding_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_int_.html,4,['optimiz'],['optimizeCacheMode']
Performance,"l_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. const RooArgSet* getNative(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); throw(std::string(""RooVectorDataSore::loadValues() NOT IMPLEMENTED"")) ;. Bool_t changeObservableName(const char* from, const char* to). RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The return value points to the added element holding 'newVar's value; in the data collection. The element is always the corresponding fundamental; type of 'newVar' (e.g. a RooRealVar if 'newVar' is a RooFormulaVar). Note: This function is explicitly NOT intended as a speed optimization; opportunity for the user. Components of complex PDFs that can be; precalculated with the dataset are automatically identified as such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooVectorDataStore.html:13500,load,loadValues,13500,root/html532/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html532/RooVectorDataStore.html,8,['load'],['loadValues']
Performance,"l_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; Double_tlogErfC(Double_t x) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGExpModel.html:37875,optimiz,optimizeDirtyHook,37875,root/html602/RooGExpModel.html,https://root.cern,https://root.cern/root/html602/RooGExpModel.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"l_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; Double_tlastBinValue() const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooParametricStepFunction.html:36563,optimiz,optimizeDirtyHook,36563,root/html534/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html534/RooParametricStepFunction.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"l_tIsMoveWaiting() const; Bool_tIsPasting() const; TVirtualDragManager&operator=(const TVirtualDragManager&); virtual voidSetEditable(Bool_t); virtual voidSetPasteFrame(TGFrame* f); virtual voidSetSource(TGFrame* f); virtual voidSetTarget(TGFrame* f); virtual voidShowMembers(TMemberInspector&); virtual Bool_tStartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. virtual voidInit(). Data Members; protected:. EDragTypefDragTypedragging type; Bool_tfDraggingin dragging mode?; Bool_tfDroppingdrop is in progress; TGFrame*fFrameUnderframe under drag; Bool_tfMoveWaitingkTRUE if source is clicked but not moved; TGFrame*fPasteFrame; Bool_tfPastingpaste action is in progress; TGFrame*fSourceframe being dragged; TGFrame*fTargetdrop target. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualDragManager(); Constructor. TVirtualDragManager * Instance(); Load plugin and create drag manager object. void Init(); Initialization. TVirtualDragManager(). virtual ~TVirtualDragManager(); {}. EDragType GetEDragType() const; { return fDragType; }. Bool_t IsMoveWaiting() const; { return fMoveWaiting; }. Bool_t IsDragging() const; { return fDragging; }. Bool_t IsDropping() const; { return fDropping; }. Bool_t IsPasting() const; { return fPasting; }. TGFrame * GetTarget() const; { return fTarget; }. TGFrame * GetSource() const; { return fSource; }. TGFrame * GetFrameUnder() const; { return fFrameUnder; }. TGFrame * GetPasteFrame() const; { return fPasteFrame; }. void SetTarget(TGFrame* f); { fTarget = f; }. void SetSource(TGFrame* f); { fSource = f; }. void SetPasteFrame(TGFrame* f); { fPasteFrame = f; }. Bool_t StartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); { return kFALSE; }. Bool_t EndDrag(); { return kFALSE; }. Bool_t Drop(); { return kFALSE; }. Bool_t Cancel(Bool_t = kTRUE); { return kFALSE; }. Bool_t HandleEvent(Event_t* ); { return kFALSE; }. Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualDragManager.html:2157,Load,Load,2157,root/html534/TVirtualDragManager.html,https://root.cern,https://root.cern/root/html534/TVirtualDragManager.html,1,['Load'],['Load']
Performance,l_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_t_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry! carry of Kahan sum in evaluatePartition; Int_t_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpMode_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! Is object initialized ; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealMPFE**_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplit_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_t_nCPUNumber of processors to use in parallel calculation mode; Int_t_nEventsTotal number of events in test statistic calculation; Int_t_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:36155,cache,cache,36155,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,2,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"l_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_pidPID of child process; Int_t_pipeToClient[2]Pipe to client process; Int_t_pipeToServer[2]Pipe to server process; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_t_remoteEvalErrorLoggingState; RooArgList_saveVarsCopy of variables; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; static RooMPSentinel_sentinel; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooRealMPFE::State_state; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealMPFE.html:33227,cache,cache,33227,root/html526/RooRealMPFE.html,https://root.cern,https://root.cern/root/html526/RooRealMPFE.html,1,['cache'],['cache']
Performance,"l_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter!; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Double_t_totVolume! Total volume of space (product of ranges of observables); Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_unitNorm! Assume contents is unit normalized (for use as pdf cache); Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHistFunc(); Default constructor. RooHistFunc(const char* name, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistFunc.html:36951,cache,cache,36951,root/html602/RooHistFunc.html,https://root.cern,https://root.cern/root/html602/RooHistFunc.html,6,['cache'],['cache']
Performance,"l_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsReal(); Destructor. Bool_t operator==(Double_t value) const; Equality operator comparing to a Double_t. Bool_t operator==(const RooAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getVal(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of depe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:32303,cache,cache,32303,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,3,['cache'],"['cache', 'cached']"
Performance,"l_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsReal(); Destructor. Bool_t operator==(Double_t value) const; Equality operator comparing to a Double_t. Bool_t operator==(const RooAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getVal(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function sho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsReal.html:32416,cache,cache,32416,root/html530/RooAbsReal.html,https://root.cern,https://root.cern/root/html530/RooAbsReal.html,3,['cache'],"['cache', 'cached']"
Performance,"l_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooThresholdCategory.html:1556,Cache,CacheModeRooAbsArg,1556,root/html602/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html602/RooThresholdCategory.html,2,['Cache'],['CacheModeRooAbsArg']
Performance,"l_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofLimitsFinder&operator=(const TProofLimitsFinder&); static voidTHLimitsFinder::Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static voidTHLimitsFinder::OptimizeLimits(Int_t nbins, Int_t& newbins, Double_t& xmin, Double_t& xmax, Bool_t isInteger); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTHLimitsFinder::SetLimitsFinder(THLimitsFinder* finder); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLimitsFinder.html:4091,Optimiz,OptimizeLimits,4091,root/html602/TProofLimitsFinder.html,https://root.cern,https://root.cern/root/html602/TProofLimitsFinder.html,2,['Optimiz'],['OptimizeLimits']
Performance,"l_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tok() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFormulaVar.html:18645,optimiz,optimizeCacheMode,18645,root/html526/RooFormulaVar.html,https://root.cern,https://root.cern/root/html526/RooFormulaVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"l_tTTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidSetHbookFile(THb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THbookTree.html:16763,cache,cachesize,16763,root/html602/THbookTree.html,https://root.cern,https://root.cern/root/html602/THbookTree.html,1,['cache'],['cachesize']
Performance,"l_tTTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNtuple.html:16235,cache,cachesize,16235,root/html602/TNtuple.html,https://root.cern,https://root.cern/root/html602/TNtuple.html,3,['cache'],['cachesize']
Performance,"l_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TGFont (const char *name);  ;  TGFont (const TGFont &)=delete;  ; LayoutChunk_t * NewChunk (TGTextLayout *layout, int *maxPtr, const char *start, int numChars, int curX, int newX, int y) const;  Helper function for ComputeTextLayout(). ;  ; void operator= (const TGFont &)=delete;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Attributes; Int_t fBarHeight;  Height of underline or overstrike bar (used for simulating a native underlined or strikeout font). ;  ; FontAttributes_t fFA;  Actual font attributes obtained when the font was created. ;  ; FontMetrics_t fFM;  Cached font metrics. ;  ; FontH_t fFontH;  Font handle (derived from fontstruct) ;  ; FontStruct_t fFontStruct;  Low level graphics fontstruct. ;  ; TObjString * fNamedHash;  Pointer to the named object TGFont was based on. ;  ; Int_t fTabWidth;  Width of tabs in this font (pixels). ;  ; char fTypes [256];  Array giving types of all characters in the font, used when displaying control characters. ;  ; Int_t fUnderlineHeight;  Height of underline bar (used for drawing underlines on a non-underlined font). ;  ; Int_t fUnderlinePos;  Offset from baseline to origin of underline bar (used for drawing underlines on a non-underlined font). ;  ; Int_t fWidths [256];  Array giving widths of all possible characters in the font. ;  . Friends; class TGFontPool;  ; class TGTextLayout;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFont.html:12930,Cache,Cached,12930,doc/master/classTGFont.html,https://root.cern,https://root.cern/doc/master/classTGFont.html,1,['Cache'],['Cached']
Performance,"l_t IsAutoParsingSuspended () const =0;  ; virtual Bool_t IsErrorMessagesEnabled () const =0;  ; virtual Bool_t IsFloatingType (const void *) const;  ; virtual Bool_t IsIntegerType (const void *) const;  ; virtual Bool_t IsLibraryLoaded (const char *libname) const =0;  ; virtual Bool_t IsLoaded (const char *filename) const =0;  ; virtual Bool_t IsPointerType (const void *) const;  ; virtual Bool_t IsProcessLineLocked () const =0;  ; virtual Bool_t IsSameType (const void *, const void *) const;  ; virtual Bool_t IsSignedIntegerType (const void *) const;  ; virtual Bool_t IsUnsignedIntegerType (const void *) const;  ; virtual Bool_t IsVoidPointerType (const void *) const;  ; virtual Int_t Load (const char *filenam, Bool_t system=kFALSE)=0;  ; virtual void LoadEnums (TListOfEnums &cl) const =0;  ; virtual int LoadFile (const char *) const;  ; virtual void LoadFunctionTemplates (TClass *cl) const =0;  ; virtual Int_t LoadLibraryMap (const char *rootmapfile=nullptr)=0;  ; virtual void LoadMacro (const char *filename, EErrorCode *error=nullptr)=0;  ; virtual Bool_t LoadText (const char *) const;  ; virtual std::unique_ptr< TInterpreterValue > MakeInterpreterValue () const;  ; virtual const char * MapCppName (const char *) const;  ; virtual const char * MethodArgInfo_DefaultValue (MethodArgInfo_t *) const;  ; virtual void MethodArgInfo_Delete (MethodArgInfo_t *) const;  ; virtual MethodArgInfo_t * MethodArgInfo_Factory () const;  ; virtual MethodArgInfo_t * MethodArgInfo_Factory (MethodInfo_t *) const;  ; virtual MethodArgInfo_t * MethodArgInfo_FactoryCopy (MethodArgInfo_t *) const;  ; virtual Bool_t MethodArgInfo_IsValid (MethodArgInfo_t *) const;  ; virtual const char * MethodArgInfo_Name (MethodArgInfo_t *) const;  ; virtual int MethodArgInfo_Next (MethodArgInfo_t *) const;  ; virtual Long_t MethodArgInfo_Property (MethodArgInfo_t *) const;  ; virtual TypeInfo_t * MethodArgInfo_TypeInfo (MethodArgInfo_t *) const;  ; virtual const char * MethodArgInfo_TypeName (MethodArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter.html:18422,Load,LoadMacro,18422,doc/master/classTInterpreter.html,https://root.cern,https://root.cern/doc/master/classTInterpreter.html,1,['Load'],['LoadMacro']
Performance,"l_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual Int_t ReOpen (Option_t *mode);  Reopen a file with a different access mode. ;  ; virtual void Seek (Long64_t offset, ERelativeTo pos=kBeg);  Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetEND (Long64_t last);  ; virtual void SetOffset (Long64_t offset, ERelativeTo pos=kBeg);  Set position from where to start reading. ;  ; virtual void SetOption (Option_t *option="">"");  ; virtual void SetReadCalls (Int_t readcalls=0);  ; virtual void ShowStreamerInfo ();  Show the StreamerInfo of all classes written to this file. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:8820,cache,cache,8820,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,2,['cache'],['cache']
Performance,"la() constructor; [ROOT-11000] - rootcling fails for Gaudi classes; [ROOT-11001] - unable to create TChain on ROOT file; [ROOT-11005] - ROOT crashes when creating a TCanvas with gDebug=1; [ROOT-11009] - RDataFrame Silent “bugs” with assignment in Filter expressions; [ROOT-11013] - “Impossible code path” in TGenCollectionProxy.cxx when using rootcling; [ROOT-11015] - OpenGL rendering is incorrect for “pgon - pgon”; [ROOT-10830] - vector<string> behaviour in loops in PyROOT 6.20 vs 6.22; [ROOT-9559] - [DF] Treat indexed Friend trees; [ROOT-10832] - Make TH1::GetCumulative account for underflows and overflows; [ROOT-8013] - equalising roofit tutorials for easier digestion; [ROOT-8142] - Provide corrupt line when XML parsing fails; [ROOT-10022] - [DF] Add support for TBranchObjects (e.g. branches containing TH2F); [ROOT-10781] - Performance penalty from RooRealVar not allowing to use hash table on RooLinkedList member; [#6408] - Creating RooDataSet causes SegFault; [#6529] - segfault in RooWorkspace::import; [#6489] - Test Issue; [#6540] - Crash message should point to github; [#6479] - TMVA TMVAGui functions crash in batch mode; [#6553] - TMVA Provide support in MethodPyKeras for tensorflow.keras; [#6403] - [Hist] Bugs in TProfile,TProfile2D::LabelsOption; [#6527] - Double delete error with TTree::ChangeFile and a TFile on the stack; [#6455] - [DF] RDataSource does not early-quit event loops when all Ranges are exhausted; [#6435] - [DF] Jitted Min method breaks with RVec columns; [#6425] - Typo in void TEnv::SetValue(const char *name, double value) implementation; [#6406] - root7 is turned off by default even if the default C++ standard of the compiler is C++14 or above; [#6371] - [DF] Display doesn’t work with non-top-level TTree branches; [#6448] - Disable NDEBUG for PR builds; [#6482] - TClass::GetListOfFunctions() fails to enumerate using decls.; [#6393] - PyROOT cannot call templated ctors on Windows; [#6359] - python: /workspace/build/projects/ROOT-HEAD/src/ROOT/H",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:38483,Perform,Performance,38483,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['Perform'],['Performance']
Performance,"la); -; *-* Handling exponentiation; *-* Can handle multiple carets, eg.; *-* 2^3^4 will be treated like 2^(3^4); -. void HandleLinear(TString& formula); Handle Linear functions identified with ""@"" operator. void PreProcessFormula(TString& formula); -; *-* Preprocessing of formula; *-* Replace all ** by ^, and removes spaces.; *-* Handle also parametrized functions like polN,gaus,expo,landau; *-* and exponentiation.; *-* Similar functionality should be added here.; -. Bool_t PrepareFormula(TString& formula); prepare the formula to be executed; normally is called with fFormula. void ExtractFunctors(TString& formula); -; *-* Extracts functors from formula, and put them in fFuncs.; *-* Simple grammar:; *-* <function> := name(arg1,arg2...); *-* <variable> := name; *-* <parameter> := [number]; *-* <name> := String containing lower and upper letters, numbers, underscores; *-* <number> := Integer number; *-* Operators are omitted.; -. void ProcessFormula(TString& formula); -; *-* Iterates through funtors in fFuncs and performs the appropriate action.; *-* If functor has 0 arguments (has only name) can be:; *-* - variable; *-* * will be replaced with x[num], where x is an array containing value of this variable under num.; *-* - pre-defined formula; *-* * will be replaced with formulas body; *-* - constant; *-* * will be replaced with constant value; *-* - parameter; *-* * will be replaced with p[num], where p is an array containing value of this parameter under num.; *-* If has arguments it can be :; *-* - function shortcut, eg. sin; *-* * will be replaced with fullname of function, eg. sin -> TMath::Sin; *-* - function from cling environment, eg. TMath::BreitWigner(x,y,z); *-* * first check if function exists, and has same number of arguments, then accept it and set as found.; *-* If all functors after iteration are matched with corresponding action,; *-* it inputs C++ code of formula into cling, and sets flag that formula is ready to evaluate.; -. void SetPredefinedParam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFormula.html:13882,perform,performs,13882,root/html604/TFormula.html,https://root.cern,https://root.cern/root/html604/TFormula.html,1,['perform'],['performs']
Performance,"la); virtual voidTChain::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTChain::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTChain::SetCacheSize(Long64_t cacheSize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidSetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTChain::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* enlist, const Option_t*); virtual voidTChain::SetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofChain.html:16802,cache,cacheSize,16802,root/html602/TProofChain.html,https://root.cern,https://root.cern/root/html602/TProofChain.html,1,['cache'],['cacheSize']
Performance,"la::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tfNpyNumber of points along y used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF2.html:21563,optimiz,optimization,21563,root/html528/TF2.html,https://root.cern,https://root.cern/root/html528/TF2.html,4,['optimiz'],['optimization']
Performance,"la::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tfNpyNumber of points along y used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); TFormula::TFuncGTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF2.html:21908,optimiz,optimization,21908,root/html602/TF2.html,https://root.cern,https://root.cern/root/html602/TF2.html,1,['optimiz'],['optimization']
Performance,"label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_lowestOrder; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooPolyVar(); Default constructor. RooPolyVar(const char* name, const char* title, RooAbsReal& _x, const RooArgList& _coefList, Int_t lowestOrder = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPolyVar.html:36255,cache,cache,36255,root/html602/RooPolyVar.html,https://root.cern,https://root.cern/root/html602/RooPolyVar.html,4,['cache'],['cache']
Performance,"label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsHiddenReal(const char* name, const char* title, const char* unit = """"); Constructor. RooAbsHiddenReal(const char* name, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsHiddenReal.html:36615,cache,cache,36615,root/html602/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html,4,['cache'],['cache']
Performance,"label name). void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; Hook functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:23551,cache,cache,23551,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,1,['cache'],['cache']
Performance,"label name). void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:23742,cache,cache,23742,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,2,['cache'],['cache']
Performance,"labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TString_rangeName; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRangeBoolean(); Default constructor. RooRangeBoolean(const char* name, const char* title, RooAbsRealLValue& x, const char* rangeName). Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRangeBoolean.html:35980,cache,cache,35980,root/html602/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html,4,['cache'],['cache']
Performance,"labeled"" bins present between ""labeled"" bins they will not be removed ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 5245 of file TH1.cxx. ◆ LabelsInflate(). void TH1::LabelsInflate ; (; Option_t * ; ax = ""X""). virtual . Double the number of bins for axis. ; Refill histogram. This function is called by TAxis::FindBin(const char *label) ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 5315 of file TH1.cxx. ◆ LabelsOption(). void TH1::LabelsOption ; (; Option_t * ; option = ""h"", . Option_t * ; ax = ""X"" . ). virtual . Sort bins with labels or set option(s) to draw axis with labels. ; Parameters. [in]option; ""a"" sort by alphabetic order; "">"" sort by decreasing values; ""<"" sort by increasing values; ""h"" draw labels horizontal; ""v"" draw labels vertical; ""u"" draw labels up (end of label right adjusted); ""d"" draw labels down (start of label left adjusted). In case not all bins have labels sorting will work only in the case the first n consecutive bins have all labels and sorting will be performed on those label bins.; Parameters. [in]axaxis . Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 5382 of file TH1.cxx. ◆ LoggedInconsistency(). int TH1::LoggedInconsistency ; (; const char * ; name, . const TH1 * ; h1, . const TH1 * ; h2, . bool ; useMerge = false . ); const. protected . Definition at line 883 of file TH1.cxx. ◆ Merge() [1/2]. virtual Long64_t TH1::Merge ; (; TCollection * ; list). inlinevirtual . Reimplemented in TH2Poly, TProfile2Poly, TProfile, TProfile2D, and TProfile3D.; Definition at line 345 of file TH1.h. ◆ Merge() [2/2]. Long64_t TH1::Merge ; (; TCollection * ; li, . Option_t * ; opt . ). Add all histograms in the collection to this histogram. ; This function computes the min/max for the x axis, compute a new number of bins, if necessary, add bin contents, errors and statistics. If all histograms have bin labels, bins with identical labels will be merged, no matter what thei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:188228,perform,performed,188228,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['perform'],['performed']
Performance,"labelled axes. ;  ; virtual void mnpout (Int_t iuext, TString &chnam, Double_t &val, Double_t &err, Double_t &xlolim, Double_t &xuplim, Int_t &iuint) const;  Provides the user with information concerning the current status. ;  ; virtual void mnprin (Int_t inkode, Double_t fval);  Prints the values of the parameters at the time of the call. ;  ; virtual void mnpsdf ();  Calculates the eigenvalues of v to see if positive-def. ;  ; virtual void mnrazz (Double_t ynew, Double_t *pnew, Double_t *y, Int_t &jh, Int_t &jl);  Called only by MNSIMP (and MNIMPR) to add a new point. ;  ; virtual void mnrn15 (Double_t &val, Int_t &inseed);  This is a super-portable random number generator. ;  ; virtual void mnrset (Int_t iopt);  Resets function value and errors to UNDEFINED. ;  ; virtual void mnsave ();  Writes current parameter values and step sizes onto file ISYSSA. ;  ; virtual void mnscan ();  Scans the values of FCN as a function of one parameter. ;  ; virtual void mnseek ();  Performs a rough (but global) minimization by monte carlo search. ;  ; virtual void mnset ();  Interprets the commands that start with SET and SHOW. ;  ; virtual void mnsimp ();  Minimization using the simplex method of Nelder and Mead. ;  ; virtual void mnstat (Double_t &fmin, Double_t &fedm, Double_t &errdef, Int_t &npari, Int_t &nparx, Int_t &istat);  Returns concerning the current status of the minimization. ;  ; virtual void mntiny (Double_t epsp1, Double_t &epsbak);  To find the machine precision. ;  ; Bool_t mnunpt (TString &cfname);  Returns .TRUE. ;  ; virtual void mnvert (Double_t *a, Int_t l, Int_t m, Int_t n, Int_t &ifail);  Inverts a symmetric matrix. ;  ; virtual void mnwarn (const char *copt, const char *corg, const char *cmes);  Prints Warning messages. ;  ; virtual void mnwerr ();  Calculates the WERR, external parameter errors. ;  ; virtual Int_t Release (Int_t parNo);  release a parameter ;  ; virtual Int_t SetErrorDef (Double_t up);  To get the n-sigma contour the error def paramete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:21998,Perform,Performs,21998,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,2,['Perform'],['Performs']
Performance,"laceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/PiecewiseInterpolation.html:22811,cache,cache,22811,root/html528/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html528/PiecewiseInterpolation.html,46,['cache'],['cache']
Performance,"laceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; voidsetVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealMPFE.html:23314,cache,cache,23314,root/html528/RooRealMPFE.html,https://root.cern,https://root.cern/root/html528/RooRealMPFE.html,1,['cache'],['cache']
Performance,"lacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:20134,perform,perform,20134,root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,1,['perform'],['perform']
Performance,lag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedDataObs! Dataset observables we've agreed to own; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsOptTestStatistic.html:34942,cache,cache,34942,root/html530/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,lag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dgamma; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; RooRealProxy_f0; RooRealProxy_f1; RooRealProxy_f2; RooRealProxy_f3; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsAnaConvPdf::_modelOriginal model; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBDecay.html:42181,cache,cache,42181,root/html534/RooBDecay.html,https://root.cern,https://root.cern/root/html534/RooBDecay.html,3,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"lag set; RooFunctor*_ftor! Functor binding of RooAbsReal; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderDerivation order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; ROOT::Math::RichardsonDerivator*_rd! Derivator ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDerivative.html:32272,cache,cache,32272,root/html526/RooDerivative.html,https://root.cern,https://root.cern/root/html526/RooDerivative.html,2,['cache'],['cache']
Performance,"lag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; vector<Double_t>_realRefReference values for reals; RooListProxy_realSetList of reals to track ; TIterator*_realSetIter! do not persist; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooChangeTracker.html:33225,cache,cache,33225,root/html532/RooChangeTracker.html,https://root.cern,https://root.cern/root/html532/RooChangeTracker.html,2,['cache'],['cache']
Performance,"lag); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistPdf.html:31931,cache,cache,31931,root/html534/RooHistPdf.html,https://root.cern,https://root.cern/root/html534/RooHistPdf.html,1,['cache'],['cache']
Performance,"lag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Attributes; Long64_t fCurrent;  ; Long64_t fNum;  . Additional Inherited Members;  Public Types inherited from TEventIter; enum  EIterType { kData = 15; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TEventIter; Int_t LoadDir ();  Load directory. ;  ; virtual void PreProcessEvent (Long64_t);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TEventIter; Long64_t fCur;  ; TDirectory * fDir;  ; TDSet * fDSet;  ; TDSetElement * fElem;  ; Long64_t fElemCur;  ; Long64_t fElemFirst;  ; Long64_t fElemNum;  ; TEntryList * fEntryList;  current position in the eventList ;  ; Long64_t fEntryListPos;  entry list for processing ;  ; TEventList * fEventList;  ; Int_t fEventListPos;  eventList for processing ;  ; TFile * fFile;  ; TString fFilename;  ; Long64_t fFirst;  ; Long64_t fNum;  ; Long64_t fOldBytesRead;  ; TList * fPackets;  current position in the entrylist ;  ; TString fPath;  ; TSelector * fSel;  ; Bool_t fStop;  . #include <TEventIter.h>. In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEventIterUnit.html:11051,Load,LoadDir,11051,doc/master/classTEventIterUnit.html,https://root.cern,https://root.cern/doc/master/classTEventIterUnit.html,2,['Load'],"['Load', 'LoadDir']"
Performance,"lanced TTree, 10K branches,; 7123 // with 8K having baskets smaller than 512 bytes. To achieve good I/O performance ATLAS uses auto-flush 100,; 7124 // resulting in the smallest baskets being ~300-400 bytes, so this change increases their memory by about 8k*150B =~ 1MB,; 7125 // at the same time it significantly reduces the number of total baskets because it ensures that all 100 entries can be; 7126 // stored in a single basket (the old optimization tended to make baskets too small). In a toy example with fixed sized; 7127 // structures we found a factor of 2 fewer baskets needed in the new scheme.; 7128 // rounds up, increases basket size to ensure all entries fit into single basket as intended; 7129 newBsize = newBsize - newBsize%512 + 512;; 7130 }; 7131 if (newBsize < sizeOfOneEntry) newBsize = sizeOfOneEntry;; 7132 if (newBsize < bmin) newBsize = bmin;; 7133 if (newBsize > 10000000) newBsize = bmax;; 7134 if (pass) {; 7135 if (pDebug) Info(""OptimizeBaskets"", ""Changing buffer size from %6d to %6d bytes for %s\n"",oldBsize,newBsize,branch->GetName());; 7136 branch->SetBasketSize(newBsize);; 7137 }; 7138 newMemsize += newBsize;; 7139 // For this number to be somewhat accurate when newBsize is 'low'; 7140 // we do not include any space for meta data in the requested size (newBsize) even-though SetBasketSize will; 7141 // not let it be lower than 100+TBranch::fEntryOffsetLen.; 7142 newBaskets += 1+Int_t(totBytes/newBsize);; 7143 if (pass == 0) continue;; 7144 //Reset the compression level in case the compression factor is small; 7145 Double_t comp = 1;; 7146 if (branch->GetZipBytes() > 0) comp = totBytes/Double_t(branch->GetZipBytes());; 7147 if (comp > 1 && comp < minComp) {; 7148 if (pDebug) Info(""OptimizeBaskets"", ""Disabling compression for branch : %s\n"",branch->GetName());; 7149 branch->SetCompressionSettings(ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);; 7150 }; 7151 }; 7152 // coverity[divide_by_zero] newMemsize can not be zero as there is at least one lea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:280010,Optimiz,OptimizeBaskets,280010,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Optimiz'],['OptimizeBaskets']
Performance,"laps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; Bool_tok() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFormulaVar&operator=(const RooFormulaVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormulaVar.html:20172,optimiz,optimizeCacheMode,20172,root/html602/RooFormulaVar.html,https://root.cern,https://root.cern/root/html602/RooFormulaVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"laps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); PiecewiseInterpolation&operator=(const PiecewiseInterpolation&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; PiecewiseInterpolation(); PiecewiseInterpolation(const PiecewiseInterpolation& other, const char* name = 0); PiecewiseInterpolation(const char* name, const char* title, const RooAbsReal& nominal, const RooArgList& lowSet, const RooArgList& highSet, const RooArgList& paramSet, Bool_t takeOwnerShip = kFALSE); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/PiecewiseInterpolation.html:19301,optimiz,optimizeCacheMode,19301,root/html602/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html602/PiecewiseInterpolation.html,2,['optimiz'],['optimizeCacheMode']
Performance,"lar ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Dot ; (; const DisplacementVector3D< OtherCoords, OtherTag > & ; ); const. private . ◆ Dot() [2/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords > . Scalar ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Dot ; (; const DisplacementVector3D< OtherCoords, Tag > & ; v); const. inline . Return the scalar (dot) product of two displacement vectors. ; It is possible to perform the product for any type of vector coordinates, but they must have the same coordinate system tag ; Definition at line 403 of file DisplacementVector3D.h. ◆ Dot() [3/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherVector > . Scalar ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Dot ; (; const OtherVector & ; v); const. inline . Return the scalar (dot) product of two vectors. ; It is possible to perform the product for any classes implementing x(), y() and z() member functions ; Definition at line 412 of file DisplacementVector3D.h. ◆ Eta(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . Scalar ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Eta ; (; ); const. inline . Polar eta, converting if necessary from internal coordinate system. ; Definition at line 311 of file DisplacementVector3D.h. ◆ eta(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . Scalar ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::eta ; (; ); const. inline . Definition at line 526 of file DisplacementVector3D.h. ◆ GetCoordinates() [1/4]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class IT > . void ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::GetCoordinates ; (; IT ; begin); const. inline . get internal data into 3 Scalars starting at *begin ; Definition at line 236 of file DisplacementVector3D.h. ◆ GetCoordinates() [2/4]. template<class CoordSystem , class Tag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html:16533,perform,perform,16533,doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html,1,['perform'],['perform']
Performance,"lar those that must be executed before the library start being unloaded. ;  ; TObject * FindObject (const char *name) const override;  Returns address of a ROOT object if it exists. ;  ; TObject * FindObject (const TObject *obj) const override;  Find an object in one Root folder. ;  ; TObject * FindObjectAny (const char *name) const override;  Return a pointer to the first object with name starting at //root. ;  ; TObject * FindObjectAnyFile (const char *name) const override;  Scan the memory lists of all files for an object with name. ;  ; const char * FindObjectClassName (const char *name) const;  Returns class name of a ROOT object including CINT globals. ;  ; const char * FindObjectPathName (const TObject *obj) const;  Return path name of obj somewhere in the //root/... path. ;  ; TObject * FindSpecialObject (const char *name, void *&where);  Returns address and folder of a ROOT object if it exists. ;  ; TClass * FindSTLClass (const char *name, Bool_t load, Bool_t silent=kFALSE) const;  return a TClass object corresponding to 'name' assuming it is an STL container. ;  ; void ForceStyle (Bool_t force=kTRUE);  ; Bool_t FromPopUp () const;  ; TApplication * GetApplication () const;  ; Int_t GetBuiltDate () const;  ; Int_t GetBuiltTime () const;  ; TClass * GetClass (const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) const;  Return pointer to class with name. Obsolete, use TClass::GetClass directly. ;  ; TClass * GetClass (const std::type_info &typeinfo, Bool_t load=kTRUE, Bool_t silent=kFALSE) const;  Return pointer to class from its name. ;  ; TSeqCollection * GetClipboard () const;  ; TColor * GetColor (Int_t color) const;  Return address of color with index color. ;  ; const char * GetConfigFeatures () const;  ; const char * GetConfigOptions () const;  ; const char * GetCutClassName () const;  ; const char * GetDefCanvasName () const;  ; Bool_t GetEditHistograms () const;  ; Int_t GetEditorMode () const;  ; TFile * GetFile () const override;  ; TFile * Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:4762,load,load,4762,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,2,['load'],['load']
Performance,"lared if the user has requested a custom ...Definition rootcling_impl.cxx:728; GenerateNecessaryIncludesvoid GenerateNecessaryIncludes(std::ostream &dictStream, const std::string &includeForSource, const std::string &extraIncludes)Definition rootcling_impl.cxx:2862; StrcpyArgvoid StrcpyArg(string &dest, const char *original)Copy the command line argument, stripping MODULE/inc if necessary.Definition rootcling_impl.cxx:1963; gOptRootmapLibNamesstatic llvm::cl::list< std::string > gOptRootmapLibNames(""rml"", llvm::cl::ZeroOrMore, llvm::cl::desc(""Generate rootmap file.""), llvm::cl::cat(gRootclingOptions)); ParseRootMapFilevoid ParseRootMapFile(ifstream &file, map< string, string > &autoloads)Parse the rootmap and add entries to the autoload map.Definition rootcling_impl.cxx:627; gOptCxxModulestatic llvm::cl::opt< bool > gOptCxxModule(""cxxmodule"", llvm::cl::desc(""Generate a C++ module.""), llvm::cl::cat(gRootclingOptions)); GetExternalNamespaceAndContainedEntitiesstd::pair< std::string, std::string > GetExternalNamespaceAndContainedEntities(const std::string line)Performance is not critical here.Definition rootcling_impl.cxx:2356; AddPlatformDefinesvoid AddPlatformDefines(std::vector< std::string > &clingArgs)Definition rootcling_impl.cxx:2067; GenerateFwdDeclStringstatic std::string GenerateFwdDeclString(const RScanner &scan, const cling::Interpreter &interp)Generate the fwd declarations of the selected entities.Definition rootcling_impl.cxx:3302; gOptFailOnWarningsstatic llvm::cl::opt< bool > gOptFailOnWarnings(""failOnWarnings"", llvm::cl::desc(""Fail if there are warnings.""), llvm::cl::cat(gRootclingOptions)); CopyArgconst char * CopyArg(const char *original)If the argument starts with MODULE/inc, strip it to make it the name we can use in #includes.Definition rootcling_impl.cxx:1943; GetNonConstMemberNamestring GetNonConstMemberName(const clang::FieldDecl &m, const string &prefix="""")Return the name of the data member so that it can be used by non-const operation (so it ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:294145,Perform,Performance,294145,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['Perform'],['Performance']
Performance,"lass ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  ;  Static Public Member Functions inherited from RooAbsLValue; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; value_type evaluate () const override;  Evaluate the category state and return. ;  ; void recomputeShape () override;  This category's shape does not depend on others, and does not need recomputing. ;  ;  Protected Member Functions inherited from RooAbsCategoryLValue; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:41821,cache,cached,41821,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['cache'],['cached']
Performance,"lass *cl, Int_t s, Bool_t); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument, s, indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the rig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClonesArray.html:12950,perform,performance,12950,root/html526/TClonesArray.html,https://root.cern,https://root.cern/root/html526/TClonesArray.html,1,['perform'],['performance']
Performance,"lass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a composite frame. A composite frame has in addition to a TGFrame; also a layout manager and a list of child frames. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); Create a frame using an externally created window. For example; to register the root window (called by TGClient), or a window; created via TVirtualX::InitWindow() (id is obtained with TVirtualX::GetWindowID()). ~TGCompositeFrame(); Delete a composite frame. Bool_t IsEditable() const; Return kTRUE if frame is being edited. void SetEditable(Bool_t on = kTRUE); Switch ON/OFF edit mode.; If edit mode is ON it is possible:. 1. embed other ROOT GUI application (a la ActiveX). For example:; TGMainFrame *m = new TGMainFrame(gClient->GetRoot(), 500, 500);; m->SetEditable();; gSystem->Load(""$ROOTSYS/test/Aclock""); // load Aclock demo; Aclock a;; gROOT->Macro(""$ROOTSYS/tutorials/gui/guitest.C"");; m->SetEditable(0);; m->MapWindow();. void Cleanup(); Cleanup and delete all objects contained in this composite frame.; This will delete all objects added via AddFrame().; CAUTION: all objects (frames and layout hints) must be unique, i.e.; cannot be shared. void SetLayoutManager(TGLayoutManager* l); Set the layout manager for the composite frame.; The layout manager is adopted by the frame and will be deleted; by the frame. void SetLayoutBroken(Bool_t on = kTRUE); Set broken layout. No Layout method is called. void SetEditDisabled(UInt_t on = 1); Set edit disable flag for this frame and subframes. - if (on & kEditDisable) - disable edit for this frame and all subframes. void ChangeOptions(UInt_t options); Change composite frame options. Options is an OR of the EFrameTypes. void SetCleanup(Int_t mode = kLocalCleanup); Turn on automatic cleanup of child frames in dtor. if mod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGCompositeFrame.html:19687,Load,Load,19687,root/html528/TGCompositeFrame.html,https://root.cern,https://root.cern/root/html528/TGCompositeFrame.html,12,"['Load', 'load']","['Load', 'load']"
Performance,"lass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor. void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel..",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:18113,cache,cache,18113,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,4,['cache'],['cache']
Performance,"lass Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Private Types |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; TKDE Class ReferenceHistogram Library. ; Kernel Density Estimation class. ; The three main references are:; ""Scott DW, Multivariate Density Estimation. Theory, Practice and Visualization. New York: Wiley"",; ""Jann Ben - ETH Zurich, Switzerland -, Univariate kernel density estimation document for KDENS:; Stata module for univariate kernel density estimation.""; ""Hardle W, Muller M, Sperlich S, Werwatz A, Nonparametric and Semiparametric Models. Springer.""; ""Cranmer KS, Kernel Estimation in High-Energy; Physics. Computer Physics Communications 136:198-207,2001"" - e-Print Archive: hep ex/0011057. The algorithm is briefly described in (4). A binned version is also implemented to address the performance issue due to its data size dependance. ; Definition at line 37 of file TKDE.h. Classes; struct  KernelIntegrand;  ; class  TKernel;  . Public Types; enum  EBinning { kUnbinned; , kRelaxedBinning; , kForcedBinning; };  Data binning option. More...;  ; enum  EIteration { kAdaptive; , kFixed; };  Iteration types. They can be set using SetIteration() More...;  ; enum  EKernelType { ;   kGaussian; , kEpanechnikov; , kBiweight; , kCosineArch; , ;   kUserDefined; , kTotalKernels. };  Types of Kernel functions They can be set using the function SetKernelType() or as a string in the constructor. More...;  ; enum  EMirror { ;   kNoMirror; , kMirrorLeft; , kMirrorRight; , kMirrorBoth; , ;   kMirrorAsymLeft; , kMirrorRightAsymLeft; , kMirrorAsymRight; , kMirrorLeftAsymRight; , ;   kMirrorAsymBoth. };  Data ""mirroring"" option to address the probability ""spill out"" boundary effect They can be set using SetMirror() More...;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKDE.html:1016,perform,performance,1016,doc/master/classTKDE.html,https://root.cern,https://root.cern/doc/master/classTKDE.html,1,['perform'],['performance']
Performance,"lass ReferenceCore ROOT classes » Base ROOT classes. ; This class provides an interface to context sensitive popup menus. ; These menus pop up when the user hits the right mouse button, and are destroyed when the menu pops downs.; Context Menus are automatically generated by ROOT using the following convention: if the string // *MENU* is found in the comment field of a member function. This function will be added to the list of items in the menu.; The picture below shows a canvas with a pop-up menu. The picture below shows a canvas with a pop-up menu and a dialog box. Definition at line 44 of file TContextMenu.h. Public Member Functions;  TContextMenu (const char *name, const char *title=""Context sensitive popup menu"");  Create a context menu. ;  ; virtual ~TContextMenu ();  Destroy a context menu. ;  ; virtual void Action (TClassMenuItem *classmenuitem);  Action to be performed when this menu item is selected. ;  ; void Action (TMethod *method);  ; virtual void Action (TObject *object, TMethod *method);  Action to be performed when this menu item is selected. ;  ; virtual void Action (TObject *object, TToggle *toggle);  Action to be performed when this toggle menu item is selected. ;  ; void Action (TToggle *toggle);  ; virtual const char * CreateArgumentTitle (TMethodArg *argument);  Create string describing argument (for use in dialog box). ;  ; virtual const char * CreateDialogTitle (TObject *object, TFunction *method);  Create title for dialog box retrieving argument values. ;  ; virtual const char * CreatePopupTitle (TObject *object);  Create title for popup menu. ;  ; void Execute (const char *method, const char *params, Int_t *error=nullptr) override;  Execute method on this object with the given parameter string, e.g. ;  ; void Execute (const char *params);  ; void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr) override;  Execute method on this object with parameters stored in the TObjArray. ;  ; void Execute (TObjArray *params);  ; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTContextMenu.html:1366,perform,performed,1366,doc/master/classTContextMenu.html,https://root.cern,https://root.cern/doc/master/classTContextMenu.html,1,['perform'],['performed']
Performance,"lass RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__BuildConfig.html:1282,perform,performed,1282,root/html526/RooSimWSTool__BuildConfig.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__BuildConfig.html,4,['perform'],['performed']
Performance,"lass RooSimWSTool::ObjBuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimWSTool__ObjBuildConfig.html:1288,perform,performed,1288,root/html534/RooSimWSTool__ObjBuildConfig.html,https://root.cern,https://root.cern/root/html534/RooSimWSTool__ObjBuildConfig.html,3,['perform'],['performed']
Performance,"lass TGeoCompositeShape: public TGeoBBox. TGeoCompositeShape - class handling Boolean composition of shapes. Composite shapes are Boolean combination of two or more shape; components. The supported boolean operations are union (+), intersection (*); and subtraction. Composite shapes derive from the base TGeoShape class,; therefore providing all shape features : computation of bounding box, finding; if a given point is inside or outside the combination, as well as computing the; distance to entering/exiting. It can be directly used for creating volumes or; used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of; basic shape primitives. They have a binary tree internal structure, therefore; all shape-related geometry queries are signals propagated from top level down; to the final leaves, while the provided answers are assembled and interpreted; back at top. This CSG hierarchy is effective for small number of components,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCompositeShape.html:1284,perform,performance,1284,root/html528/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html528/TGeoCompositeShape.html,6,['perform'],['performance']
Performance,"lass TMVA::SeparationBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return the separation index (a measure for ""purity"" of the sample""). const TString& GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: SeparationBase.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__SeparationBase.html:1531,optimiz,optimized,1531,root/html532/TMVA__SeparationBase.html,https://root.cern,https://root.cern/root/html532/TMVA__SeparationBase.html,1,['optimiz'],['optimized']
Performance,"lass TMVA::SeparationBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return the separation index (a measure for ""purity"" of the sample""). const TString& GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: SeparationBase.h 40012 2011-06-27 16:03:11Z stelzer $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__SeparationBase.html:1531,optimiz,optimized,1531,root/html530/TMVA__SeparationBase.html,https://root.cern,https://root.cern/root/html530/TMVA__SeparationBase.html,1,['optimiz'],['optimized']
Performance,"lass describing current object ; Reimplemented from TObject.; Definition at line 361 of file h1analysis.h. ◆ Notify(). Bool_t h1analysis::Notify ; (; ). overridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 554 of file h1analysis.h. ◆ Process(). Bool_t h1analysis::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector. ◆ Reset(). void h1analysis::Reset ; (; ). Definition at line 37",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classh1analysis.html:21856,load,loaded,21856,doc/master/classh1analysis.html,https://root.cern,https://root.cern/doc/master/classh1analysis.html,1,['load'],['loaded']
Performance,"lass is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionMultiDim::BaseGradFunc, ROOT::Fit::Fitter::BaseGradFunc, ROOT::Math::MinimTransformFunction::BaseGradFunc, ROOT::Math::IMultiGradFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionMultiDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IGradientFunctionMultiDim.html:2365,Optimiz,Optimized,2365,root/html534/ROOT__Math__IGradientFunctionMultiDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientFunctionMultiDim.html,2,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance,"lass registered in fClassesToUpdate; 1979 ; 1980void TCling::ProcessClassesToUpdate(); 1981{; 1982 while (!fClassesToUpdate.empty()) {; 1983 TClass *oldcl = fClassesToUpdate.back().first;; 1984 // If somehow the TClass has already been loaded (maybe it was registered several time),; 1985 // we skip it. Otherwise, the existing TClass is in mode kInterpreted, kEmulated or; 1986 // maybe even kForwardDeclared and needs to replaced.; 1987 if (oldcl->GetState() != TClass::kHasTClassInit) {; 1988 // if (gDebug > 2) Info(""RegisterModule"", ""Forcing TClass init for %s"", oldcl->GetName());; 1989 DictFuncPtr_t dict = fClassesToUpdate.back().second;; 1990 fClassesToUpdate.pop_back();; 1991 // Calling func could manipulate the list so, let maintain the list; 1992 // then call the dictionary function.; 1993 TClass *ncl = dict();; 1994 if (ncl) ncl->PostLoadCheck();; 1995 } else {; 1996 fClassesToUpdate.pop_back();; 1997 }; 1998 }; 1999}; 2000////////////////////////////////////////////////////////////////////////////////; 2001/// Inject the module named ""modulename"" into cling; load all headers.; 2002/// headers is a 0-terminated array of header files to `#include` after; 2003/// loading the module. The module is searched for in all $LD_LIBRARY_PATH; 2004/// entries (or %PATH% on Windows).; 2005/// This function gets called by the static initialization of dictionary; 2006/// libraries.; 2007/// The payload code is injected ""as is"" in the interpreter.; 2008/// The value of 'triggerFunc' is used to find the shared library location.; 2009 ; 2010void TCling::RegisterModule(const char* modulename,; 2011 const char** headers,; 2012 const char** includePaths,; 2013 const char* payloadCode,; 2014 const char* fwdDeclsCode,; 2015 void (*triggerFunc)(),; 2016 const FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 2017 const char** classesHeaders,; 2018 Bool_t lateRegistration /*=false*/,; 2019 Bool_t hasCxxModule /*=false*/); 2020{; 2021 const bool fromRootCling = IsFromRootCling();; 2022",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:75874,load,load,75874,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance,"lass to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) ;  CMultPolicyMatrix-matrix multiplication policy ;  CNullTypeFunc1D;  COneDimMultiFunctionAdapterOneDimMultiFunctionAdapter class to wrap a multidimensional function in one dimensional one ;  COneDimParamFunctionAdapterOneDimParamFunctionAdapter class to wrap a multi-dim parameteric function in one dimensional one ;  CParamFunctionBase template class for all Parametric Functions ;  CParamFunctionBaseClass defining the signature for multi-dim parametric functions ;  ►CParamFunctorHandlerParamFunctor Handler class is responsible for wrapping any other functor and pointer to free C functions ;  CFuncEvaluator;  CFuncEvaluator< F *, T >;  CFuncEvaluator< F *const, T >;  CParamFunctorTemplParam Functor class for Multidimensional functions ;  ►CParamMemFunHandlerParamFunctor Handler to Wrap pointers to member functions ;  CMemFuncEvaluator;  CPlaceExpr;  CPlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  CPlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  CPlaceMatrixStructure to deal when a submatrix is placed in a matrix ;  CPlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  CPlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  CPlainParameters;  CPlusEqualsEvaluate the expression performing a += operation Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ;  CPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Specialization for symmetrix += general : NOT Allowed operation ;  CPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:51943,perform,performing,51943,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,8,['perform'],['performing']
Performance,"lass  RooAbsMoment;  ; class  RooAbsNumGenerator;  Abstract base class for MC event generator implementations like RooAcceptReject and RooFoam. More...;  ; class  RooAbsOptTestStatistic;  Abstract base class for test statistics objects that evaluate a function or PDF at each point of a given dataset. More...;  ; class  RooAbsPdf;  Abstract interface for all probability density functions. More...;  ; class  RooAbsProxy;  Abstract interface for proxy classes. More...;  ; class  RooAbsReal;  Abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc. More...;  ; class  RooAbsRealLValue;  Abstract base class for objects that represent a real value that may appear on the left hand side of an equation ('lvalue'). More...;  ; class  RooAbsSelfCached< Base_t >;  Abstract base class for functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate(). More...;  ; class  RooAbsStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooAbsTestStatistic;  Abstract base class for all test statistics. More...;  ; class  RooAcceptReject;  Generic Monte Carlo toy generator implement the accept/reject sampling technique on any positively valued function. More...;  ; class  RooAdaptiveGaussKronrodIntegrator1D;  Implements the Gauss-Kronrod integration algorithm. More...;  ; class  RooAdaptiveIntegratorND;  Adaptive one-dimensional numerical integration algorithm. More...;  ; class  RooAddGenContext;  Efficient implementation of the generator context specific for RooAddPdf PDFs. More...;  ; class  RooAddition;  Calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets. More...;  ; class  RooAddPdf;  Efficient implementation of a sum of PDFs of the form. More...;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:3650,cache,cached,3650,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['cache'],['cached']
Performance,"lass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:5880,load,load,5880,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,2,['load'],['load']
Performance,"lass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:5869,load,load,5869,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"lass). Data Members; public:. enum { kMapSize; kStreamedMemberWise; kNotDecompressed; kTextBasedStreaming; kUser1; kUser2; kUser3; };; enum TBuffer::EMode { kRead; kWrite; };; enum TBuffer::[unnamed] { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*fClassMapMap containing object,class pairs for reading; Int_tfDisplacementValue to be added to the map offsets; TStreamerInfo*fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>fInfoStackStack of pointers to the TStreamerInfos; TExMap*fMapMap containing object,offset pairs for reading/writing; Int_tfMapCountNumber of objects or classes in map; Int_tfMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tfPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferFile.html:16932,cache,cache,16932,root/html528/TBufferFile.html,https://root.cern,https://root.cern/root/html528/TBufferFile.html,4,['cache'],['cache']
Performance,"lass);; 615#endif; 616 }; 617 ; 618 ClassDefOverride(TClass,0) //Dictionary containing class information; 619};; 620 ; 621namespace ROOT {; 622namespace Internal {; 623template <typename T>; 624TClass *GetClassHelper(Bool_t, Bool_t, std::true_type); 625{; 626 return T::Class();; 627}; 628 ; 629template <typename T>; 630struct TClassGetClassHelper {; 631 static TClass *GetClass(Bool_t load, Bool_t silent) {; 632 return TClass::GetClass(typeid(T), load, silent);; 633 }; 634};; 635 ; 636template <typename F, typename S>; 637struct TClassGetClassHelper<std::pair<F, S> > {; 638 static TClass *GetClass(Bool_t load, Bool_t silent) {; 639 using pair_t = std::pair<F,S>;; 640 size_t hint_offset = offsetof(pair_t, second);; 641 return TClass::GetClass(typeid(std::pair<F, S>), load, silent, hint_offset, sizeof(std::pair<F,S>));; 642 }; 643};; 644 ; 645template <typename T>; 646TClass *GetClassHelper(Bool_t load, Bool_t silent, std::false_type); 647{; 648 return TClassGetClassHelper<T>::GetClass(load, silent);; 649}; 650 ; 651} // namespace Internal; 652} // namespace ROOT; 653 ; 654template <typename T>; 655TClass *TClass::GetClass(Bool_t load, Bool_t silent); 656{; 657 typename std::is_base_of<TObject, T>::type tag;; 658 return ROOT::Internal::GetClassHelper<T>(load, silent, tag);; 659}; 660 ; 661namespace ROOT {; 662 ; 663template <typename T> TClass *GetClass(T * /* dummy */) { return TClass::GetClass<T>(); }; 664template <typename T> TClass *GetClass(const T * /* dummy */) { return TClass::GetClass<T>(); }; 665 ; 666#ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION; 667 // This can only be used when the template overload resolution can distinguish between T* and T**; 668 template <typename T> TClass* GetClass( T** /* dummy */) { return TClass::GetClass<T>(); }; 669 template <typename T> TClass* GetClass(const T** /* dummy */) { return TClass::GetClass<T>(); }; 670 template <typename T> TClass* GetClass( T* const* /* dummy */) { return TClass::GetClass<T>(); }; 671 template <typena",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:32977,load,load,32977,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['load'],['load']
Performance,lass. ; See TList::GetObjectRef for the intended behavior. ; Reimplemented from TList.; Definition at line 271 of file TViewPubDataMembers.cxx. ◆ GetSize(). Int_t TViewPubDataMembers::GetSize ; (; ); const. overridevirtual . Return the total number of public data members(currently loaded in the list; of DataMembers) in this class and all its base classes. ; Reimplemented from TCollection.; Definition at line 281 of file TViewPubDataMembers.cxx. ◆ Last(). TObject * TViewPubDataMembers::Last ; (; ); const. overrideprotectedvirtual . Last is not allowed in this class. ; See TList::Last for the intended behavior. ; Reimplemented from TList.; Definition at line 310 of file TViewPubDataMembers.cxx. ◆ LastLink(). TObjLink * TViewPubDataMembers::LastLink ; (; ); const. overrideprotectedvirtual . LastLink is not allowed in this class. ; See TList::LastLink for the intended behavior. ; Reimplemented from TList.; Definition at line 320 of file TViewPubDataMembers.cxx. ◆ Load(). void TViewPubDataMembers::Load ; (; ). Load all the DataMembers known to the interpreter for the scope 'fClass' and all its bases classes. ; Definition at line 298 of file TViewPubDataMembers.cxx. ◆ MakeIterator(). TIterator * TViewPubDataMembers::MakeIterator ; (; Bool_t ; dir = kIterForward); const. overridevirtual . Return a list iterator. ; Reimplemented from TList.; Definition at line 122 of file TViewPubDataMembers.cxx. ◆ operator=(). TViewPubDataMembers & TViewPubDataMembers::operator= ; (; const TViewPubDataMembers & ; ). privatedelete . ◆ RecursiveRemove(). void TViewPubDataMembers::RecursiveRemove ; (; TObject * ; obj). overrideprotectedvirtual . RecursiveRemove is not allowed in this class. ; See TList::RecursiveRemove for the intended behavior. ; Reimplemented from TList.; Definition at line 330 of file TViewPubDataMembers.cxx. ◆ Remove() [1/2]. TObject * TViewPubDataMembers::Remove ; (; TObject * ; obj). overrideprotectedvirtual . Remove is not allowed in this class. ; See TList::Remove for ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTViewPubDataMembers.html:27381,Load,Load,27381,doc/master/classTViewPubDataMembers.html,https://root.cern,https://root.cern/doc/master/classTViewPubDataMembers.html,1,['Load'],['Load']
Performance,"lass.""); 949 << Endl;; 950 return nullptr;; 951 }; 952 ; 953 TMVA::ROCCurve *rocCurve = GetROC(datasetname, theMethodName, iClass, type);; 954 TGraph *graph = nullptr;; 955 ; 956 if (!rocCurve) {; 957 Log() << kFATAL; 958 << Form(""ROCCurve object was not created in Method = %s not found with Dataset = %s "", theMethodName.Data(),; 959 datasetname.Data()); 960 << Endl;; 961 return nullptr;; 962 }; 963 ; 964 graph = (TGraph *)rocCurve->GetROCCurve()->Clone();; 965 delete rocCurve;; 966 ; 967 if (setTitles) {; 968 graph->GetYaxis()->SetTitle(""Background rejection (Specificity)"");; 969 graph->GetXaxis()->SetTitle(""Signal efficiency (Sensitivity)"");; 970 graph->SetTitle(TString::Format(""Signal efficiency vs. Background rejection (%s)"", theMethodName.Data()).Data());; 971 }; 972 ; 973 return graph;; 974}; 975 ; 976////////////////////////////////////////////////////////////////////////////////; 977/// Generate a collection of graphs, for all methods for a given class. Suitable; 978/// for comparing method performance.; 979///; 980/// Argument iClass specifies the class to generate the ROC curve in a; 981/// multiclass setting. It is ignored for binary classification.; 982///; 983/// NOTE: The ROC curve is 1 vs. all where the given class is considered signal; 984/// and the others considered background. This is ok in binary classification; 985/// but in in multi class classification, the ROC surface is an N dimensional; 986/// shape, where N is number of classes - 1.; 987 ; 988TMultiGraph *TMVA::Factory::GetROCCurveAsMultiGraph(DataLoader *loader, UInt_t iClass, Types::ETreeType type); 989{; 990 return GetROCCurveAsMultiGraph((TString)loader->GetName(), iClass, type);; 991}; 992 ; 993////////////////////////////////////////////////////////////////////////////////; 994/// Generate a collection of graphs, for all methods for a given class. Suitable; 995/// for comparing method performance.; 996///; 997/// Argument iClass specifies the class to generate the ROC curve in a; 998/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:39839,perform,performance,39839,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['perform'],['performance']
Performance,"lass.h:488; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2722; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetStreamerInfosconst TObjArray * GetStreamerInfos() constDefinition TClass.h:492; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::AddAllvirtual void AddAll(const TCollection *col)Add all objects from collection col to this collection.Definition TCollection.cxx:195; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TIterDefinition TCollection.h:235; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayIterIterator of object array.Definition TObjArray.h:117; TObjArrayIter::NextTObject * Next() overrideReturn next object in array. Returns 0 when no more objects in array.Definition TObjArray.cxx:931; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the array",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRuleSet_8cxx_source.html:29491,load,load,29491,doc/master/TSchemaRuleSet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRuleSet_8cxx_source.html,1,['load'],['load']
Performance,"lass: %s, version: %d\n"", GetName(), fClassVersion);; 4665 }; 4666 if (HasDataMemberInfo() || fCollectionProxy) {; 4667 // If we do not have a StreamerInfo for this version and we do not; 4668 // have dictionary information nor a proxy, there is nothing to build!; 4669 sinfo->Build(silent);; 4670 }; 4671 } else {; 4672 if (!sinfo->IsCompiled()) {; 4673 // Streamer info has not been compiled, but exists.; 4674 // Therefore it was read in from a file and we have to do schema evolution?; 4675 // Or it didn't have a dictionary before, but does now?; 4676 sinfo->BuildOld();; 4677 }; 4678 }; 4679 ; 4680 // Cache the current info if we now have it.; 4681 if (version == fClassVersion); 4682 fCurrentInfo = sinfo;; 4683 ; 4684 // If the compilation succeeded, remember this StreamerInfo.; 4685 if (sinfo->IsCompiled()); 4686 fLastReadInfo = sinfo;; 4687 ; 4688 return sinfo;; 4689}; 4690 ; 4691////////////////////////////////////////////////////////////////////////////////; 4692/// For the case where the requestor class is emulated and this class is abstract,; 4693/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4694/// representation whether or not the class is loaded.; 4695///; 4696/// If the object does not exist, it is created; 4697///; 4698/// Note: There are two special version numbers:; 4699///; 4700/// - 0: Use the class version from the currently loaded class library.; 4701/// - -1: Assume no class library loaded (emulated class).; 4702///; 4703/// Warning: If we create a new streamer info, whether or not the build; 4704/// optimizes is controlled externally to us by a global variable!; 4705/// Don't call us unless you have set that variable properly; 4706/// with TStreamer::Optimize()!; 4707///; 4708 ; 4709TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4710{; 4711 TVirtualStreamerInfo *sinfo = nullptr;; 4712 ; 4713 TString newname(GetName());; 4714 newname += ""@@emulated"";; 4715 ; 4716",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:178306,load,loaded,178306,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"lass: %s, version: %d\n"", GetName(), fClassVersion);; 4732 }; 4733 if (HasDataMemberInfo() || fCollectionProxy) {; 4734 // If we do not have a StreamerInfo for this version and we do not; 4735 // have dictionary information nor a proxy, there is nothing to build!; 4736 sinfo->Build(silent);; 4737 }; 4738 } else {; 4739 if (!sinfo->IsCompiled()) {; 4740 // Streamer info has not been compiled, but exists.; 4741 // Therefore it was read in from a file and we have to do schema evolution?; 4742 // Or it didn't have a dictionary before, but does now?; 4743 sinfo->BuildOld();; 4744 }; 4745 }; 4746 ; 4747 // Cache the current info if we now have it.; 4748 if (version == fClassVersion); 4749 fCurrentInfo = sinfo;; 4750 ; 4751 // If the compilation succeeded, remember this StreamerInfo.; 4752 if (sinfo->IsCompiled()); 4753 fLastReadInfo = sinfo;; 4754 ; 4755 return sinfo;; 4756}; 4757 ; 4758////////////////////////////////////////////////////////////////////////////////; 4759/// For the case where the requestor class is emulated and this class is abstract,; 4760/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4761/// representation whether or not the class is loaded.; 4762///; 4763/// If the object does not exist, it is created; 4764///; 4765/// Note: There are two special version numbers:; 4766///; 4767/// - 0: Use the class version from the currently loaded class library.; 4768/// - -1: Assume no class library loaded (emulated class).; 4769///; 4770/// Warning: If we create a new streamer info, whether or not the build; 4771/// optimizes is controlled externally to us by a global variable!; 4772/// Don't call us unless you have set that variable properly; 4773/// with TStreamer::Optimize()!; 4774///; 4775 ; 4776TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4777{; 4778 TVirtualStreamerInfo *sinfo = nullptr;; 4779 ; 4780 TString newname(GetName());; 4781 newname += ""@@emulated"";; 4782 ; 4783",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:181057,load,loaded,181057,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"lass::GetDeclFileName() const; ROOT::DelFunc_tTClass::GetDelete() const; ROOT::DelArrFunc_tTClass::GetDeleteArray() const; ROOT::DesFunc_tTClass::GetDestructor() const; static DictFuncPtr_tTClass::GetDict(const char* cname); static DictFuncPtr_tTClass::GetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tTClass::GetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*TClass::GetFunctionTemplate(const char* name); UInt_tTClass::GetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tTClass::GetImplFileLine() const; const char*TClass::GetImplFileName() const; UInt_tTClass::GetInstanceCount() const; TVirtualIsAProxy*TClass::GetIsAProxy() const; TVirtualStreamerInfo*TClass::GetLastReadInfo() const; TList*TClass::GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*TClass::GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*TClass::GetListOfBases(); TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TClass::GetListOfDataMembers(Bool_t load = kTRUE); TList*TClass::GetListOfEnums(Bool_t load = kTRUE); TList*TClass::GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*TClass::GetListOfMethodOverloads(const char* name) const; TList*TClass::GetListOfMethods(Bool_t load = kTRUE); TList*TClass::GetListOfRealData() const; TList*TQObject::GetListOfSignals() const; voidTClass::GetMenuItems(TList* listitems); TList*TClass::GetMenuList() const; ROOT::MergeFunc_tTClass::GetMerge() const; TMethod*TClass::GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*TClass::GetMethodAllAny(const char* method); TMethod*TClass::GetMethodAny(const char* method); TMethod*TClass::GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:9746,load,load,9746,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,2,['load'],['load']
Performance,"lass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1957; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an collection using the Streamer facility.Definition TCollection.cxx:263; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:202731,load,load,202731,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['load'],['load']
Performance,"lassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition TClass.cxx:4478; TClass::GetMethodWithPrototypeTMethod * GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4523; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::IsATClass * IsA() const overrideDefinition TClass.h:618; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::GetNameconst char * GetName() const overrideReturn name of this collection.Definition TCollection.cxx:351; TCollection::fNameTString fNameDefinition TCollection.h:149; TCollection::Printvoid Print(Option_t *option="""") const overrideDefault print for collections, calls Print(option, 1).Definition TCollection.cxx:476; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TDataType::GetTypeInt_t GetType() constDefinition TDataType.h:68; TDataType::GetFullTypeNameconst char * GetFullTypeName() constGet full type description of typedef, e,g.: ""class TDirectory*"".Definition TDataType.cxx:175; TFunctionGlobal funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:39066,load,load,39066,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,1,['load'],['load']
Performance,"lass_Version(). static constexpr Version_t TClassGenerator::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 40 of file TClassGenerator.h. ◆ DeclFileName(). static const char * TClassGenerator::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 40 of file TClassGenerator.h. ◆ GetClass() [1/4]. virtual TClass * TClassGenerator::GetClass ; (; const char * ; classname, . Bool_t ; load . ). pure virtual . Implemented in TPyClassGenerator. ◆ GetClass() [2/4]. TClass * TClassGenerator::GetClass ; (; const char * ; classname, . Bool_t ; load, . Bool_t ; silent . ). virtual . Reimplemented in TPyClassGenerator.; Definition at line 25 of file TClassGenerator.cxx. ◆ GetClass() [3/4]. virtual TClass * TClassGenerator::GetClass ; (; const std::type_info & ; typeinfo, . Bool_t ; load . ). pure virtual . Implemented in TPyClassGenerator. ◆ GetClass() [4/4]. TClass * TClassGenerator::GetClass ; (; const std::type_info & ; typeinfo, . Bool_t ; load, . Bool_t ; silent . ). virtual . Reimplemented in TPyClassGenerator.; Definition at line 32 of file TClassGenerator.cxx. ◆ IsA(). TClass * TClassGenerator::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 40 of file TClassGenerator.h. ◆ Streamer(). void TClassGenerator::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TClassGenerator::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 40 of file TClassGenerator.h. Libraries for TClassGenerator:. [legend]; The documentation for this class was generated from the following files:; core/meta/inc/TClassGenerator.h; core/meta/src/TClassGenerator.cxx. TClassGenerator. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:23 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassGenerator.html:12163,load,load,12163,doc/master/classTClassGenerator.html,https://root.cern,https://root.cern/doc/master/classTClassGenerator.html,1,['load'],['load']
Performance,"lasses are not allowed.; Considering that a new/delete costs about 70 mus on a 300 MHz HP, O(10^9) new/deletes will save about 19 hours. NOTE 1; C/C++ offers the possibility of allocating and deleting memory. Forgetting to delete allocated memory is a programming error called a ""memory leak"", i.e. the memory of your process grows and eventually your program crashes. Even if you always delete the allocated memory, the recovered space may not be efficiently reused. The process knows that there are portions of free memory, but when you allocate it again, a fresh piece of memory is grabbed. Your program is free from semantic errors, but the total memory of your process still grows, because your program's memory is full of ""holes"" which reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in terms of CPU time.; Without entering into technical details, TClonesArray allows you to ""reuse"" the same portion of memory for new/delete avoiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the TClonesArray has to be reused, the Clear() method is used. To provide its benefits, each TClonesArray must be allocated once per process and disposed of (deleted) only when not needed any more.; So a job should see only one deletion for each TClonesArray, which should be Clear()ed during the job several times. Deleting a TClonesArray is a double waste. Not only you do not avoid memory fragmentation, but you worsen it because the TClonesArray itself is a rather heavy structure, and there is quite some code in the destructor, so you have more memory fragmentation and slower code. NOTE 2; When investigating misuse of TClonesArray, please make sure of the following:. Use Clear() or Clear(""C"") instead of Delete(). This will improve program execution time.; TClonesArray object classes containing pointers allocate memory. To avoid causing memory leaks, sp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:3271,perform,performance,3271,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['perform'],['performance']
Performance,"lassification or Regression"". ; Definition at line 60 of file OptimizeConfigParameters.cxx. ◆ ~OptimizeConfigParameters(). TMVA::OptimizeConfigParameters::~OptimizeConfigParameters ; (; ). virtual . the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it) ; Definition at line 96 of file OptimizeConfigParameters.cxx. Member Function Documentation. ◆ Class(). static TClass * TMVA::OptimizeConfigParameters::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::OptimizeConfigParameters::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::OptimizeConfigParameters::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file OptimizeConfigParameters.h. ◆ DeclFileName(). static const char * TMVA::OptimizeConfigParameters::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 100 of file OptimizeConfigParameters.h. ◆ EstimatorFunction(). Double_t TMVA::OptimizeConfigParameters::EstimatorFunction ; (; std::vector< Double_t > & ; pars). privatevirtual . return the estimator (from current FOM) for the fitting interface ; Implements TMVA::IFitterTarget.; Definition at line 307 of file OptimizeConfigParameters.cxx. ◆ GetBkgEffAtSigEff(). Double_t TMVA::OptimizeConfigParameters::GetBkgEffAtSigEff ; (; Double_t ; sigEff = 0.5). private . calculate the background efficiency for a given signal efficiency ; adapted by marc-.nosp@m.oliv.nosp@m.ier.b.nosp@m.ettl.nosp@m.er@ce.nosp@m.rn.c.nosp@m.h ; Definition at line 546 of file OptimizeConfigParameters.cxx. ◆ GetBkgRejAtSigEff(). Double_t TMVA::OptimizeConfigParameters::GetBkgRejAtSigEff ; (; Double_t ; sigEff = 0.5). private . calculate the background rejection for a given signal efficiency ; adapted by marc-.nosp@m.oliv.nosp@m.ier.b.nosp@m.ettl.nosp@m.er@ce.nosp@m.rn.c.nosp@m.h ; Definition at li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:5788,Optimiz,OptimizeConfigParameters,5788,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance,"lassification"", ""Error creating Keras model file - skip using Keras"");; } else {; // book PyKeras method only if Keras model could be created; Info(""TMVA_Higgs_Classification"", ""Booking tf.Keras Dense model"");; factory.BookMethod(; loader, TMVA::Types::kPyKeras, ""PyKeras"",; ""H:!V:VarTransform=None:FilenameModel=Higgs_model.h5:tf.keras:""; ""FilenameTrainedModel=Higgs_trained_model.h5:NumEpochs=20:BatchSize=100:""; ""GpuOptions=allow_growth=True""); // needed for RTX NVidia card and to avoid TF allocates all GPU memory; }; }; ; /**; ## Train Methods; ; Here we train all the previously booked methods.; ; */; ; factory.TrainAllMethods();; ; /**; ## Test all methods; ; Now we test and evaluate all methods using the test data set; */; ; factory.TestAllMethods();; ; factory.EvaluateAllMethods();; ; /// after we get the ROC curve and we display; ; auto c1 = factory.GetROCCurve(loader);; c1->Draw();; ; /// at the end we close the output file which contains the evaluation result of all methods and it can be used by TMVAGUI; /// to display additional plots; ; outputFile->Close();; ; ; }; Double_tdouble Double_tDefinition RtypesCore.h:59; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; gROOT#define gROOTDefinition TROOT.h:406; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TCutA specialized string object used for TTree selections.Definition TCut.h:25; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:69441,load,loader,69441,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['load'],['loader']
Performance,"lassification_Keras.root', 'RECREATE'); factory = TMVA.Factory('TMVAClassification', output,; '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); ; # Load data; if not isfile('tmva_class_example.root'):; call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); ; data = TFile.Open('tmva_class_example.root'); signal = data.Get('TreeS'); background = data.Get('TreeB'); ; dataloader = TMVA.DataLoader('dataset'); for branch in signal.GetListOfBranches():; dataloader.AddVariable(branch.GetName()); ; dataloader.AddSignalTree(signal, 1.0); dataloader.AddBackgroundTree(background, 1.0); dataloader.PrepareTrainingAndTestTree(TCut(''),; 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); ; # Generate model; ; # Define model; model = Sequential(); model.add(Dense(64, activation='relu', input_dim=4)); model.add(Dense(2, activation='softmax')); ; # Set loss and optimizer; model.compile(loss='categorical_crossentropy',; optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ]); ; # Store model to file; model.save('modelClassification.h5'); model.summary(); ; # Book methods; factory.BookMethod(dataloader, TMVA.Types.kFisher, 'Fisher',; '!H:!V:Fisher:VarTransform=D,G'); factory.BookMethod(dataloader, TMVA.Types.kPyKeras, 'PyKeras',; 'H:!V:VarTransform=D,G:FilenameModel=modelClassification.h5:FilenameTrainedModel=trainedModelClassification.h5:NumEpochs=20:BatchSize=32'); ; # Run training, test and evaluation; factory.TrainAllMethods(); factory.TestAllMethods(); factory.EvaluateAllMethods(); TCutA specialized string object used for TTree selections.Definition TCut.h:25; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::FactoryThis is the main MVA steering class.De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ClassificationKeras_8py.html:1728,optimiz,optimizer,1728,doc/master/ClassificationKeras_8py.html,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py.html,1,['optimiz'],['optimizer']
Performance,"last = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->StopCacheLearningPhase(); //<<<; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:6487,cache,cachesize,6487,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,24,"['Load', 'cache']","['LoadTree', 'cache', 'cachesize']"
Performance,"late. ;  ; file  rf710_roopoly.C;   Taylor expansion of RooFit functions using the taylorExpand function with RooPolyFunc ;  ; file  rf710_roopoly.py;   Taylor expansion of RooFit functions using the taylorExpand function ;  ; file  rf711_lagrangianmorph.C;   Morphing effective field theory distributions with RooLagrangianMorphFunc A morphing function as a function of one coefficient is setup and can be used to obtain the distribution for any value of the coefficient. ;  ; file  rf711_lagrangianmorph.py;   Morphing effective field theory distributions with RooLagrangianMorphFunc. ;  ; file  rf712_lagrangianmorphfit.C;   Performing a simple fit with RooLagrangianMorphFunc. ;  ; file  rf712_lagrangianmorphfit.py;   Performing a simple fit with RooLagrangianMorphFunc ;  ; file  rf801_mcstudy.C;   Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting ;  ; file  rf801_mcstudy.py;   Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting ;  ; file  rf802_mcstudy_addons.C;   Validation and MC studies: RooMCStudy - using separate fit and generator models, using the chi^2 calculator model Running a biased fit model against an optimal fit. ;  ; file  rf803_mcstudy_addons2.C;   Validation and MC studies: RooMCStudy - Using the randomizer and profile likelihood add-on models ;  ; file  rf804_mcstudy_constr.C;   Validation and MC studies: using RooMCStudy on models with constrains ;  ; file  rf901_numintconfig.C;   Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ;  ; file  rf901_numintconfig.py;   Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ;  ; file  rf902_numgenconfig.C;   Numeric algorithm tuning: configuration and customization of how MC sampling algorithms on specific pdfs are executed ;  ; file  rf902_numgenconfig.py;   Numeric algorithm tuning: configuration and cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:23023,perform,perform,23023,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['perform'],['perform']
Performance,"lateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. » Author: L. Moneta Wed Aug 30 11:05:19 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Fitter.h 36764 2010-11-19 10:02:00Z moneta $ » Last generated: 2010-11-19 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__Fitter.html:7825,perform,performing,7825,root/html528/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__Fitter.html,1,['perform'],['performing']
Performance,"lates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: http://root.cern.ch/root/html/examples/assembly.C.html.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; Note that components cannot be declared as “overlapping” and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. 18.4.3 Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in TGeo has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:960569,optimiz,optimizing,960569,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,"lation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Fri Dec 2 14:26:32 2011 » Last generated: 2011-12-02 14:26; This page has",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:45503,cache,cached,45503,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,1,['cache'],['cached']
Performance,"lation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Mon Jul 4 15:21:18 2011 » Last generated: 2011-07-04 15:21; This page has",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCachedPdf.html:44247,cache,cached,44247,root/html530/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html,1,['cache'],['cached']
Performance,"lation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Thu Sep 23 19:58:06 2010 » Last generated: 2010-09-23 19:58; This page ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:43687,cache,cached,43687,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,1,['cache'],['cached']
Performance,"lation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Mar 10 17:13:53 2015 » Last generated: 2015-03-10 17:13; This page ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedPdf.html:47010,cache,cached,47010,root/html534/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html,1,['cache'],['cached']
Performance,"lation will be paralellized over multiple processes. By default the data; is split with 'bulk' partitioning (each process calculates a contigious block of fraction 1/nCPU; of the data). For binned data this approach may be suboptimal as the number of bins with >0 entries; in each processing block many vary greatly thereby distributing the workload rather unevenly.; If interleave is set to true, the interleave partitioning strategy is used where each partition; i takes all bins for which (ibin % ncpu == i) which is more likely to result in an even workload.; If splitCutRange is true, a different rangeName constructed as rangeName_{catName} will be used; as range definition for each index state of a RooSimultaneous. RooAbsTestStatistic(const RooAbsTestStatistic& other, const char* name = 0); Copy constructor. ~RooAbsTestStatistic(); Destructor. Double_t evaluate() const; Calculates and return value of test statistic. If the test statistic; is calculated from on a RooSimultaneous, the test statistic calculation; is performed separately on each simultaneous p.d.f component and associated; data and then combined. If the test statistic calculation is parallelized; partitions are calculated in nCPU processes and a posteriori combined. Bool_t initialize(); One-time initialization of the test statistic. Setup; infrastructure for simultaneous p.d.f processing and/or; parallelized processing if requested. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Forward server redirect calls to component test statistics. void printCompactTreeHook(ostream& os, const char* indent = """"); Add extra information on component test statistics when printing; itself as part of a tree structure. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Forward constant term optimization management calls to component; test statistics. void setMPSet(Int_t setNum, Int_t numSets); S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:42912,perform,performed,42912,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,2,['perform'],['performed']
Performance,"lation.; 1823 // Avoid to call the plugin manager at all.; 1824 R__InitStreamerInfoFactory();; 1825 ; 1826 TDirectory::TContext ctxt;; 1827 llvm::SaveAndRestore<Int_t> SaveGDebug(gDebug);; 1828 if (gDebug > 5) {; 1829 gDebug -= 5;; 1830 ::Info(""TCling::LoadPCM"", ""Loading ROOT PCM %s"", pcmFileName.Data());; 1831 } else {; 1832 gDebug = 0;; 1833 }; 1834 ; 1835 if (llvm::sys::fs::is_symlink_file(pcmFileNameFullPath)); 1836 pcmFileNameFullPath = ROOT::TMetaUtils::GetRealPath(pcmFileNameFullPath);; 1837 ; 1838 auto pendingRdict = fPendingRdicts.find(pcmFileNameFullPath);; 1839 if (pendingRdict != fPendingRdicts.end()) {; 1840 llvm::StringRef pcmContent = pendingRdict->second;; 1841 TMemFile::ZeroCopyView_t range{pcmContent.data(), pcmContent.size()};; 1842 std::string RDictFileOpts = pcmFileNameFullPath + ""?filetype=pcm"";; 1843 TMemFile pcmMemFile(RDictFileOpts.c_str(), range);; 1844 ; 1845 cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());; 1846 LoadPCMImpl(pcmMemFile);; 1847 // Currently the module file are never unloaded (even if the library is; 1848 // unloaded) and, of course, never reloaded.; 1849 // Consequently, we must NOT remove the `pendingRdict` from the list; 1850 // of pending dictionary, otherwise if a library is unloaded and then; 1851 // reload we will be unable to update properly the TClass object; 1852 // (because we wont be able to load the rootpcm file by executing the; 1853 // above lines); 1854 ; 1855 return;; 1856 }; 1857 ; 1858 if (!llvm::sys::fs::exists(pcmFileNameFullPath)) {; 1859 ::Error(""TCling::LoadPCM"", ""ROOT PCM %s file does not exist"",; 1860 pcmFileNameFullPath.data());; 1861 if (!fPendingRdicts.empty()); 1862 for (const auto &rdict : fPendingRdicts); 1863 ::Info(""TCling::LoadPCM"", ""In-memory ROOT PCM candidate %s\n"",; 1864 rdict.first.c_str());; 1865 return;; 1866 }; 1867 ; 1868 if (!gROOT->IsRootFile(pcmFileName)) {; 1869 Fatal(""LoadPCM"", ""The file %s is not a ROOT as was expected\n"", pcmFileName.Data());; 1870 re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:69533,Load,LoadPCMImpl,69533,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadPCMImpl']
Performance,"lation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:51731,Load,LoadClass,51731,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['Load'],['LoadClass']
Performance,layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGCheckButton*fLogAxislogarithmic check box ; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; TGCheckButton*fMoreLogmore logarithmic labels check box; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; TGCheckButton*fNoExponentcheck box for No exponent choice; TGCheckButton*fOptimizetick optimization check box; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Int_tTGedFrame::fPrioritylocation in GedEditor; TGCheckButton*fRotatedcheck button for rotated title; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGNumberEntry*fTickLengthtick length number entry; TGCheckButton*fTicksBothcheck box setting ticks on both axis sides; Int_tfTicksFlagpositive/negative ticks' flag; TGTextEntry*fTitleaxis title input field; TGColorSelect*fTitleColorcolor selection widget; TGFontTypeComboBox*fTitleFonttitle font combo box; TGNumberEntry*fTitleOffsettitle offset number entry; Int_tfTitlePrecfont precision level; TGNumberEntry*fTitleSizetitle size number entry; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTG,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TAxisEditor.html:20392,optimiz,optimization,20392,root/html528/TAxisEditor.html,https://root.cern,https://root.cern/root/html528/TAxisEditor.html,4,['optimiz'],['optimization']
Performance,"lbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:157; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:624; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:176; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinition RWebWindow.hxx:165; ROOT::RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1107; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:60; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:300; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:736; ROOT::RWebWindow::HasConnectionbool HasConnection(unsigned connid=0, bool only_active=true) constreturns true if specified connection id existsDefinition RWebWindow.cxx:1413; ROOT::RWebWindow::GetWidthunsigned GetWidth() constreturns configured window width (0 - default) actual window width can be differentDefinition RWebWindow.hxx:278; ROOT::RWebWindow::fWindowThrdstd::thread fWindowThrd! special thread for that windowDefinition RWebWindow.hxx:163; ROOT::RWebWindow::ProvideQueueEntryvoid ProvideQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&arg)Provide data to user callback User callback must be executed in the window thread.Definition RWebWindow.cxx:421; ROOT::RWebWindow::HasKeybool ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:40525,queue,queue,40525,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['queue'],['queue']
Performance,"lbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:160; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:625; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:179; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinition RWebWindow.hxx:168; ROOT::RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1140; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:62; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:303; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:737; ROOT::RWebWindow::HasConnectionbool HasConnection(unsigned connid=0, bool only_active=true) constreturns true if specified connection id existsDefinition RWebWindow.cxx:1455; ROOT::RWebWindow::GetWidthunsigned GetWidth() constreturns configured window width (0 - default) actual window width can be differentDefinition RWebWindow.hxx:281; ROOT::RWebWindow::fWindowThrdstd::thread fWindowThrd! special thread for that windowDefinition RWebWindow.hxx:166; ROOT::RWebWindow::ProvideQueueEntryvoid ProvideQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&arg)Provide data to user callback User callback must be executed in the window thread.Definition RWebWindow.cxx:422; ROOT::RWebWindow::HasKeybool ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:40670,queue,queue,40670,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['queue'],['queue']
Performance,"lback_t)=0;  indicate that canvas changed, provides current version of the canvas ;  ; virtual void DoWhenReady (const std::string &, const std::string &, bool, CanvasCallback_t)=0;  perform special action when drawing is ready ;  ; virtual std::string GetWindowAddr () const =0;  ; virtual std::string GetWindowUrl (bool remote)=0;  ; virtual bool IsCanvasModified (uint64_t) const =0;  return true if canvas modified since last painting ;  ; virtual void NewDisplay (const std::string &where)=0;  ; virtual int NumDisplays () const =0;  ; virtual bool ProduceBatchOutput (const std::string &, int, int)=0;  produce file output in batch mode like png, jpeg, svg or pdf ;  ; virtual std::string ProduceJSON ()=0;  produce canvas JSON ;  ; virtual void Run (double tm=0.)=0;  run canvas functionality in caller thread, not needed when main thread is used ;  ; virtual void SetClearOnClose (const std::shared_ptr< void > &);  . Static Public Member Functions; static std::unique_ptr< RVirtualCanvasPainter > Create (RCanvas &canv);  Loads the plugin that implements this class. ;  . Static Protected Member Functions; static std::unique_ptr< Generator > & GetGenerator ();  generator getter ;  . #include <ROOT/RVirtualCanvasPainter.hxx>. Inheritance diagram for ROOT::Experimental::Internal::RVirtualCanvasPainter:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~RVirtualCanvasPainter(). RVirtualCanvasPainter::~RVirtualCanvasPainter ; (; ). virtualdefault . Default destructor. ; The implementation is here to pin the vtable. . Member Function Documentation. ◆ AddPanel(). virtual bool ROOT::Experimental::Internal::RVirtualCanvasPainter::AddPanel ; (; std::shared_ptr< ROOT::RWebWindow > ; ). inlinevirtual . Reimplemented in ROOT::Experimental::RCanvasPainter.; Definition at line 79 of file RVirtualCanvasPainter.hxx. ◆ CanvasUpdated(). virtual void ROOT::Experimental::Internal::RVirtualCanvasPainter::Ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RVirtualCanvasPainter.html:2005,Load,Loads,2005,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RVirtualCanvasPainter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RVirtualCanvasPainter.html,1,['Load'],['Loads']
Performance,"lbacks import ReduceLROnPlateau; model = Sequential(); model.add(Reshape((16, 16, 1), input_shape=(256,))); model.add(Conv2D(10, kernel_size=(3, 3), kernel_initializer=""TruncatedNormal"", activation=""relu"", padding=""same"")); model.add(Conv2D(10, kernel_size=(3, 3), kernel_initializer=""TruncatedNormal"", activation=""relu"", padding=""same"")); # stride for maxpool is equal to pool size; model.add(MaxPooling2D(pool_size=(2, 2))); model.add(Flatten()); model.add(Dense(64, activation=""tanh"")); # model.add(Dropout(0.2)); model.add(Dense(2, activation=""sigmoid"")); model.compile(loss=""binary_crossentropy"", optimizer=Adam(learning_rate=0.001), weighted_metrics=[""accuracy""]); model.save(""model_cnn.h5""); model.summary(); ; if not os.path.exists(""model_cnn.h5""):; raise FileNotFoundError(""Error creating Keras model file - skip using Keras""); else:; # book PyKeras method only if Keras model could be created; ROOT.Info(""TMVA_CNN_Classification"", ""Booking convolutional keras model""); factory.BookMethod(; loader,; TMVA.Types.kPyKeras,; ""PyKeras"",; H=True,; V=False,; VarTransform=None,; FilenameModel=""model_cnn.h5"",; FilenameTrainedModel=""trained_model_cnn.h5"",; NumEpochs=max_epochs,; BatchSize=100,; GpuOptions=""allow_growth=True"",; ) # needed for RTX NVidia card and to avoid TF allocates all GPU memory; ; ; ; ## Train Methods; ; factory.TrainAllMethods(); ; ## Test and Evaluate Methods; ; factory.TestAllMethods(); ; factory.EvaluateAllMethods(); ; ## Plot ROC Curve; ; c1 = factory.GetROCCurve(loader); c1.Draw(); ; # close outputfile to save output file; outputFile.Close(); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid win",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:15430,load,loader,15430,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['load'],['loader']
Performance,"lcomeMsg ; Definition at line 295 of file Factory.cxx. ◆ HasMethod(). Bool_t TMVA::Factory::HasMethod ; (; const TString & ; datasetname, . const TString & ; title . ); const. Checks whether a given method name is defined for a given dataset. ; Definition at line 586 of file Factory.cxx. ◆ IsA(). virtual TClass * TMVA::Factory::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::Configurable.; Definition at line 227 of file Factory.h. ◆ IsModelPersistence(). Bool_t TMVA::Factory::IsModelPersistence ; (; ); const. inline . Definition at line 152 of file Factory.h. ◆ IsSilentFile(). Bool_t TMVA::Factory::IsSilentFile ; (; ); const. inline . Definition at line 151 of file Factory.h. ◆ MakeClass(). void TMVA::Factory::MakeClass ; (; const TString & ; datasetname, . const TString & ; methodTitle = """" . ); const. virtual . Definition at line 1305 of file Factory.cxx. ◆ OptimizeAllMethods(). std::map< TString, Double_t > TMVA::Factory::OptimizeAllMethods ; (; TString ; fomType = ""ROCIntegral"", . TString ; fitType = ""FitGA"" . ). Iterates through all booked methods and sees if they use parameter tuning and if so does just that, i.e. calls ""Method::Train()"" for different parameter settings and keeps in mind the ""optimal one""... and that's the one that will later on be used in the main training loop. ; Definition at line 701 of file Factory.cxx. ◆ OptimizeAllMethodsForClassification(). void TMVA::Factory::OptimizeAllMethodsForClassification ; (; TString ; fomType = ""ROCIntegral"", . TString ; fitType = ""FitGA"" . ). inline . Definition at line 110 of file Factory.h. ◆ OptimizeAllMethodsForRegression(). void TMVA::Factory::OptimizeAllMethodsForRegression ; (; TString ; fomType = ""ROCIntegral"", . TString ; fitType = ""FitGA"" . ). inline . Definition at line 111 of file Factory.h. ◆ PrintHelpMessage(). void TMVA::Factory::PrintHelpMessage ; (; const TString & ; datasetname, . const TString & ; methodTitle = """" . ); const. Print prede",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:32979,Optimiz,OptimizeAllMethods,32979,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['Optimiz'],['OptimizeAllMethods']
Performance,"lculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProfileLL(); Default constructor; Should only be used by proof. RooProfileLL(const char* name, const char* title, RooAbsReal& nll, const RooArgSet& observables); Constructor of profile likelihood given input likelihood nll w.r.t; the given set of variables. The input log likelihood is minimized w.r.t; to all other variables of the likelihood at each evaluation and the; value of the global log likelihood minimum is always subtracted. RooProfileLL(const RooProfileLL& other, const char* name = 0); Copy constructor. ~RooProfileLL(); Destructor. const RooArgSet& bestFitParams() const. const RooArgSet& bestFitObs() const. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Optimized implementation of createProfile for profile likelihoods.; Return profile of original function in terms of stated parameters; of interest rather than profiling recursively. Double_t evaluate() const; Evaluate profile likelihood by minimizing likelihood w.r.t. all; parameters that are not considered observables of this profile; likelihood object. void validateAbsMin() const; Check that parameters and likelihood value for 'best fit' are still valid. If not,; because the best fit has never been calculated, or because constant parameters have; changed value or parameters have changed const/float status, the minimum is recalculated. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ). TObject* clone(const char* newname) const; { return new RooProfileLL(*this,newname); }. void setAlwaysStartFromMin(Bool_t flag); { _startFromMin = flag ; }. Bool_t alwaysStartFromMin() const; { return _startFromMin ; }. RooMinuit* minuit(); { return _minuit ; }. RooAbsReal& n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProfileLL.html:34699,Optimiz,Optimized,34699,root/html528/RooProfileLL.html,https://root.cern,https://root.cern/root/html528/RooProfileLL.html,3,['Optimiz'],['Optimized']
Performance,"lculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProfileLL(); Default constructor; Should only be used by proof. RooProfileLL(const char* name, const char* title, RooAbsReal& nll, const RooArgSet& observables); Constructor of profile likelihood given input likelihood nll w.r.t; the given set of variables. The input log likelihood is minimized w.r.t; to all other variables of the likelihood at each evaluation and the; value of the global log likelihood minimum is always subtracted. RooProfileLL(const RooProfileLL& other, const char* name = 0); Copy constructor. ~RooProfileLL(); Destructor. const RooArgSet& bestFitParams() const. const RooArgSet& bestFitObs() const. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Optimized implementation of createProfile for profile likelihoods.; Return profile of original function in terms of stated parameters; of interest rather than profiling recursively. void initializeMinimizer() const. Double_t evaluate() const; Evaluate profile likelihood by minimizing likelihood w.r.t. all; parameters that are not considered observables of this profile; likelihood object. void validateAbsMin() const; Check that parameters and likelihood value for 'best fit' are still valid. If not,; because the best fit has never been calculated, or because constant parameters have; changed value or parameters have changed const/float status, the minimum is recalculated. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ). TObject* clone(const char* newname) const; { return new RooProfileLL(*this,newname); }. void setAlwaysStartFromMin(Bool_t flag); { _startFromMin = flag ; }. Bool_t alwaysStartFromMin() const; { return _startFromMin ; }. MINIMIZER* minimizer()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProfileLL.html:37646,Optimiz,Optimized,37646,root/html534/RooProfileLL.html,https://root.cern,https://root.cern/root/html534/RooProfileLL.html,3,['Optimiz'],['Optimized']
Performance,"ld : Total Size=%11lld bytes File Size = %10lld *"",fEntries,totBytes,fZipBytes);; 2418 } else {; 2419 if (fWriteBasket > 0) {; 2420 Printf(""*Entries :%9lld : Total Size=%11lld bytes All baskets in memory *"",fEntries,totBytes);; 2421 } else {; 2422 Printf(""*Entries :%9lld : Total Size=%11lld bytes One basket in memory *"",fEntries,totBytes);; 2423 }; 2424 }; 2425 }; 2426 Printf(""*Baskets :%9d : Basket Size=%11d bytes Compression= %6.2f *"",fWriteBasket,fBasketSize,cx);; 2427 ; 2428 if (strncmp(option,""basketsInfo"",strlen(""basketsInfo""))==0) {; 2429 Int_t nbaskets = fWriteBasket;; 2430 for (Int_t i=0;i<nbaskets;i++) {; 2431 Printf(""*Basket #%4d entry=%6lld pos=%6lld size=%5d"",; 2432 i, fBasketEntry[i], fBasketSeek[i], fBasketBytes[i]);; 2433 }; 2434 }; 2435 ; 2436 Printf(""*............................................................................*"");; 2437 delete [] bline;; 2438 fgCount++;; 2439}; 2440 ; 2441////////////////////////////////////////////////////////////////////////////////; 2442/// Print the information we have about which basket is currently cached and; 2443/// whether they have been 'used'/'read' from the cache.; 2444 ; 2445void TBranch::PrintCacheInfo() const; 2446{; 2447 fCacheInfo.Print(GetName(), fBasketEntry);; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Loop on all leaves of this branch to read Basket buffer.; 2452 ; 2453void TBranch::ReadBasket(TBuffer&); 2454{; 2455 // fLeaves->ReadBasket(basket);; 2456}; 2457 ; 2458////////////////////////////////////////////////////////////////////////////////; 2459/// Loop on all leaves of this branch to read Basket buffer.; 2460 ; 2461void TBranch::ReadLeavesImpl(TBuffer& b); 2462{; 2463 for (Int_t i = 0; i < fNleaves; ++i) {; 2464 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 2465 leaf->ReadBasket(b);; 2466 }; 2467}; 2468 ; 2469////////////////////////////////////////////////////////////////////////////////; 2470/// Read zero leaves without",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:88510,cache,cached,88510,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,2,['cache'],"['cache', 'cached']"
Performance,"ld be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files, TList* wrks = 0); Create in each worker sandbox symlinks to the files in the list; Used to make the cache information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0, TList* wrks = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, consider the macro to be a selector; and try to load the selector and set it to the pointer.; The mask 'opt' is an or of ESendFileOpt:; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache; Return -1 in case of error, 0 otherwise. Int_t CleanupSandbox(); Remove old sessions dirs keep at most 'Proof.MaxOldSessions' (default 10). TList * GetListOfQueries(Option_t* opt = """"); Get the list",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:31765,Load,Load,31765,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,2,['Load'],['Load']
Performance,"ld formula base class f(x,y,z,par) //; 23// mantained for backward compatibility and TTree usage //; 24//////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TNamed.h""; 27#include ""TBits.h""; 28#include ""TObjArray.h""; 29 ; 30 ; 31const Int_t kMAXFOUND = 500;; 32const Int_t kTFOperMask = 0x7fffff;; 33const UChar_t kTFOperShift = 23;; 34 ; 35 ; 36 ; 37namespace ROOT {; 38 namespace v5 {; 39 ; 40 class TFormulaPrimitive;; 41 ; 42class TOperOffset {; 43 friend class TFormula;; 44public:; 45 enum {; 46 kVariable = 0,; 47 kParameter = 1,; 48 kConstant = 2; 49 };; 50 TOperOffset();; 51protected:; 52 Short_t fType0; // type of operand 0; 53 Short_t fOffset0; // offset of operand 0; 54 Short_t fType1; // type of operand 1; 55 Short_t fOffset1; // offset of operand 1; 56 Short_t fType2; // type of operand 2; 57 Short_t fOffset2; // offset of operand 2; 58 Short_t fType3; // type of operand 3; 59 Short_t fOffset3; // offset of operand 3; 60 Short_t fToJump; // where to jump in case of optimized boolen; 61 Short_t fOldAction; // temporary variable used during optimization; 62};; 63 ; 64 ; 65class TFormula : public TNamed {; 66 ; 67protected:; 68 ; 69 typedef Double_t (TObject::*TFuncG)(const Double_t*,const Double_t*) const;; 70 ; 71 Int_t fNdim; //Dimension of function (1=1-Dim, 2=2-Dim,etc); 72 Int_t fNpar; //Number of parameters; 73 Int_t fNoper; //Number of operators; 74 Int_t fNconst; //Number of constants; 75 Int_t fNumber; //formula number identifier; 76 Int_t fNval; //Number of different variables in expression; 77 Int_t fNstring; //Number of different constants character strings; 78 TString *fExpr; //[fNoper] List of expressions; 79private:; 80 Int_t *fOper; //[fNoper] List of operators. (See documentation for changes made at version 7); 81protected:; 82 Double_t *fConst; //[fNconst] Array of fNconst formula constants; 83 Double_t *fParams; //[fNpar] Array of fNpar parameters; 84 TString *fNames; //[fNpar] Array of parameter names; 8",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/v5_2TFormula_8h_source.html:1892,optimiz,optimized,1892,doc/master/v5_2TFormula_8h_source.html,https://root.cern,https://root.cern/doc/master/v5_2TFormula_8h_source.html,2,['optimiz'],"['optimization', 'optimized']"
Performance,"ld_loc, ConcatFileName( build_loc, lib_location) );; 3024 }; 3025 ; 3026 if (gSystem->AccessPathName(build_loc,kFileExists)) {; 3027 mkdirFailed = (0 != mkdir(build_loc, true));; 3028 if (mkdirFailed && !canWriteBuild_loc) {; 3029 // The mkdir failed __and__ we can not write to the target directory,; 3030 // let make sure the error message will be about the target directory; 3031 build_loc = build_loc_store;; 3032 mkdirFailed = kFALSE;; 3033 } else if (!mkdirFailed && dirmode!=0) {; 3034 Chmod(build_loc,dirmode);; 3035 }; 3036 }; 3037 }; 3038 library = gSystem->UnixPathName(library);; 3039 ; 3040 // ======= Check if the library need to loaded or compiled; 3041 if (!gInterpreter->IsLibraryLoaded(library) && gInterpreter->IsLoaded(expFileName)) {; 3042 // the script has already been loaded in interpreted mode; 3043 // Let's warn the user and unload it.; 3044 ; 3045 if (withInfo) {; 3046 ::Info(""ACLiC"",""script has already been loaded in interpreted mode"");; 3047 ::Info(""ACLiC"",""unloading %s and compiling it"", filename);; 3048 }; 3049 ; 3050 if ( gInterpreter->UnloadFile( expFileName ) != 0 ) {; 3051 // We can not unload it.; 3052 return kFALSE;; 3053 }; 3054 }; 3055 ; 3056 // Calculate the -I lines; 3057 TString includes = GetIncludePath();; 3058 includes.ReplaceAll(""-I "", ""-I"");; 3059 includes.Prepend(' ');; 3060 ; 3061 {; 3062 // I need to replace the -Isomerelativepath by -I../ (or -I..\ on NT); 3063 TRegexp rel_inc("" -I[^\""/\\\\$\\%-][^:\\s]+"");; 3064 Int_t len,pos;; 3065 pos = rel_inc.Index(includes,&len);; 3066 while( len != 0 ) {; 3067 TString sub = includes(pos,len);; 3068 sub.Remove(0,3); // Remove ' -I'; 3069 AssignAndDelete( sub, ConcatFileName( WorkingDirectory(), sub ) );; 3070 sub.Prepend("" -I\"""");; 3071 if (sub.EndsWith("" "")); 3072 sub.Chop(); // Remove trailing space (i.e between the -Is ...; 3073 sub.Append(""\"" "");; 3074 includes.Replace(pos,len,sub);; 3075 pos = rel_inc.Index(includes,&len);; 3076 }; 3077 }; 3078 {; 3079 // I need to replace the -I""so",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:102308,load,loaded,102308,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,lder(). Bool_t TBaseClass::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 64 of file TBaseClass.h. ◆ IsSTLContainer(). ROOT::ESTLType TBaseClass::IsSTLContainer ; (; ). Return which type (if any) of STL container the data member is. ; Definition at line 101 of file TBaseClass.cxx. ◆ operator=(). TBaseClass & TBaseClass::operator= ; (; const TBaseClass & ; ). privatedelete . ◆ Property(). Long_t TBaseClass::Property ; (; ); const. overridevirtual . Get property description word. For meaning of bits see EProperty. ; Implements TDictionary.; Definition at line 134 of file TBaseClass.cxx. ◆ SetClass(). void TBaseClass::SetClass ; (; TClass * ; cl). inline . Definition at line 67 of file TBaseClass.h. ◆ Streamer(). void TBaseClass::Streamer ; (; TBuffer & ; b). overridevirtual . Stream an object of TBaseClass. ; Triggers the calculation of the cache variables to store them. ; Reimplemented from TObject.; Definition at line 147 of file TBaseClass.cxx. ◆ StreamerNVirtual(). void TBaseClass::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 69 of file TBaseClass.h. Member Data Documentation. ◆ fClass. TClass* TBaseClass::fClass. private . Definition at line 51 of file TBaseClass.h. ◆ fClassPtr. TClassRef TBaseClass::fClassPtr. private . pointer to CINT base class info ; Definition at line 50 of file TBaseClass.h. ◆ fDelta. AtomicInt_t TBaseClass::fDelta. private . pointer to parent class ; Definition at line 52 of file TBaseClass.h. ◆ fInfo. BaseClassInfo_t* TBaseClass::fInfo. private . Definition at line 49 of file TBaseClass.h. ◆ fProperty. AtomicInt_t TBaseClass::fProperty. mutableprivate . Definition at line 53 of file TBaseClass.h. ◆ fSTLType. Int_t TBaseClass::fSTLType. private . Definition at line 54 of file TBaseClass.h. Libraries for TBaseClass:. [legend]; The documentation f,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBaseClass.html:17676,cache,cache,17676,doc/master/classTBaseClass.html,https://root.cern,https://root.cern/doc/master/classTBaseClass.html,1,['cache'],['cache']
Performance,"le ""ivar"" which is later used in GetVariableImportance() to calculate the relative variable importances. ;  ; virtual Bool_t HasAnalysisType (Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets);  BDT can handle classification with multiple classes and regression with one regression-target. ;  ; void InitEventSample ();  Initialize the event sample (i.e. reset the boost-weights... etc). ;  ; virtual TClass * IsA () const;  ; void MakeClassInstantiateNode (DecisionTreeNode *n, std::ostream &fout, const TString &className) const;  Recursively descends a tree and writes the node instance to the output stream. ;  ; void MakeClassSpecific (std::ostream &, const TString &) const;  Make ROOT-independent C++ class for classifier response (classifier-specific implementation). ;  ; void MakeClassSpecificHeader (std::ostream &, const TString &) const;  Specific class header. ;  ; virtual std::map< TString, Double_t > OptimizeTuningParameters (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");  Call the Optimizer with the set of parameters and ranges that are meant to be tuned. ;  ; void ProcessOptions ();  The option string is decoded, for available options see ""DeclareOptions"". ;  ; virtual void ReadWeightsFromStream (std::istream &)=0;  ; void ReadWeightsFromStream (std::istream &istr);  Read the weights (BDT coefficients). ;  ; virtual void ReadWeightsFromStream (TFile &);  ; void ReadWeightsFromXML (void *parent);  Reads the BDT from the xml file. ;  ; void Reset (void);  Reset the method, as if it had just been instantiated (forget all training etc.). ;  ; void SetAdaBoostBeta (Double_t b);  ; void SetBaggedSampleFraction (Double_t f);  ; void SetMaxDepth (Int_t d);  ; void SetMinNodeSize (Double_t sizeInPercent);  ; void SetMinNodeSize (TString sizeInPercent);  ; void SetNodePurityLimit (Double_t l);  ; void SetNTrees (Int_t d);  ; void SetShrinkage (Double_t s);  ; virtual void SetTuneParameters (std::map< TString, Double_t > tuneParameters);  Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:6629,Optimiz,OptimizeTuningParameters,6629,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,3,"['Optimiz', 'tune']","['OptimizeTuningParameters', 'Optimizer', 'tuned']"
Performance,"le ; (; Int_t ; x, . Int_t ; y, . UInt_t ; w, . UInt_t ; h . ). private . Test if there is really something to render. ; Definition at line 1408 of file TGWin32.cxx. ◆ KeysymToKeycode(). Int_t TGWin32::KeysymToKeycode ; (; UInt_t ; keysym). overridevirtual . Convert a keysym to the appropriate keycode. ; For example keysym is a letter and keycode is the matching keyboard key (which is dependend on the current keyboard mapping). ; Reimplemented from TVirtualX.; Definition at line 6740 of file TGWin32.cxx. ◆ ListFonts(). char ** TGWin32::ListFonts ; (; const char * ; fontname, . Int_t ; max, . Int_t & ; count . ). overridevirtual . Return list of font names matching ""fontname"". ; Reimplemented from TVirtualX.; Definition at line 7231 of file TGWin32.cxx. ◆ LoadQueryFont(). FontStruct_t TGWin32::LoadQueryFont ; (; const char * ; font_name). overridevirtual . Load font and query font. ; If font is not found 0 is returned, otherwise an opaque pointer to the FontStruct_t. Free the loaded font using DeleteFont(). ; Reimplemented from TVirtualX.; Definition at line 5385 of file TGWin32.cxx. ◆ Lock(). void TGWin32::Lock ; (; ). static . Definition at line 938 of file TGWin32.cxx. ◆ LookupString(). void TGWin32::LookupString ; (; Event_t * ; event, . char * ; buf, . Int_t ; buflen, . UInt_t & ; keysym . ). overridevirtual . Convert the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ; In buf a null terminated ASCII string is returned representing the string that is currently mapped to the key code. ; Reimplemented from TVirtualX.; Definition at line 6860 of file TGWin32.cxx. ◆ LowerWindow(). void TGWin32::LowerWindow ; (; Window_t ; id). overridevirtual . Lower window so it lays below all its siblings. ; Reimplemented from TVirtualX.; Definition at line 4714 of file TGWin32.cxx. ◆ MakeOpaqueColors(). void TGWin32::MakeOpaqueColors ; (; Int_t ; percent, . ULong_t * ; orgcolors, . In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:88479,load,loaded,88479,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['load'],['loaded']
Performance,"le Binary search tree including a volume search method. More...;  ; class  BinarySearchTreeNode;  Node for the BinarySearch or Decision Trees. More...;  ; class  BinaryTree;  Base class for BinarySearch and Decision Trees. More...;  ; class  CCPruner;  A helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) More...;  ; class  CCTreeWrapper;  ; class  ClassifierFactory;  This is the MVA factory. More...;  ; class  ClassInfo;  Class that contains all the information of a class. More...;  ; class  Config;  Singleton class for global configuration settings used by TMVA. More...;  ; class  Configurable;  ; class  ConvergenceTest;  Check for convergence. More...;  ; class  CostComplexityPruneTool;  A class to prune a decision tree using the Cost Complexity method. More...;  ; class  CrossEntropy;  Implementation of the CrossEntropy as separation criterion. More...;  ; class  CrossValidation;  Class to perform cross validation, splitting the dataloader into folds. More...;  ; class  CrossValidationFoldResult;  ; class  CrossValidationResult;  Class to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation. More...;  ; class  CvSplit;  ; class  CvSplitKFolds;  ; class  CvSplitKFoldsExpr;  ; class  DataInputHandler;  Class that contains all the data information. More...;  ; class  DataLoader;  ; class  DataSet;  Class that contains all the data information. More...;  ; class  DataSetFactory;  Class that contains all the data information. More...;  ; class  DataSetInfo;  Class that contains all the data information. More...;  ; class  DataSetManager;  Class that contains all the data information. More...;  ; class  DecisionTree;  Implementation of a Decision Tree. More...;  ; class  DecisionTreeNode;  ; struct  DeleteFunctor_t;  ; class  DTNodeTrainingInfo;  ; class  Envelope;  Abstract base class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA.html:1600,perform,perform,1600,doc/master/namespaceTMVA.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA.html,2,['perform'],['perform']
Performance,"le IFunction.h. ◆ DoDerivative(). virtual double ROOT::Math::IGradientFunctionOneDim::DoDerivative ; (; double ; x); const. privatepure virtual . Function to evaluate the derivative with respect each coordinate. To be implemented by the derived class. ; Implemented in ROOT::Math::WrappedTF1, ROOT::Math::GradFunctor1D, and ROOT::Math::Polynomial. ◆ FdF() [1/2]. void ROOT::Math::IGradientFunctionOneDim::FdF ; (; const double * ; x, . double & ; f, . double * ; df . ); const. inline . Compatibility method with multi-dimensional interface for Gradient and function evaluation. ; Definition at line 282 of file IFunction.h. ◆ FdF() [2/2]. virtual void ROOT::Math::IGradientFunctionOneDim::FdF ; (; double ; x, . double & ; f, . double & ; df . ); const. inlinevirtual . Optimized method to evaluate at the same time the function value and derivative at a point x. ; Often both value and derivatives are needed and it is often more efficient to compute them at the same time. Derived class should implement this method if performances play an important role and if it is faster to evaluate value and derivative at the same time. ; Reimplemented in ROOT::Math::WrappedTF1, and ROOT::Math::Polynomial.; Definition at line 275 of file IFunction.h. ◆ Gradient(). void ROOT::Math::IGradientFunctionOneDim::Gradient ; (; const double * ; x, . double * ; g . ); const. inline . Compatibility method with multi-dimensional interface for Gradient. ; Definition at line 269 of file IFunction.h. ◆ HasGradient(). bool ROOT::Math::IGradientFunctionOneDim::HasGradient ; (; ); const. inlineoverridevirtual . Reimplemented from ROOT::Math::IBaseFunctionOneDim.; Definition at line 284 of file IFunction.h. Libraries for ROOT::Math::IGradientFunctionOneDim:. [legend]; The documentation for this class was generated from the following file:; math/mathcore/inc/Math/IFunction.h. ROOTMathIGradientFunctionOneDim. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:21 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IGradientFunctionOneDim.html:4704,perform,performances,4704,doc/master/classROOT_1_1Math_1_1IGradientFunctionOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IGradientFunctionOneDim.html,1,['perform'],['performances']
Performance,"le RooAbsCategory.cxx. ◆ recomputeShape(). virtual void RooAbsCategory::recomputeShape ; (; ). protectedpure virtual . If a category depends on the shape of others, i.e. its state numbers or names depend on the states of other categories, this function has to be implemented to recompute _stateNames and _insertionOrder. ; If one of these two changes, setShapeDirty() has to be called to propagate this information to possible users of this category. ; Implemented in RooBinningCategory, RooCategory, RooMappedCategory, RooMultiCategory, RooSuperCategory, and RooThresholdCategory. ◆ retrieveLegacyState(). RooCatType * RooAbsCategory::retrieveLegacyState ; (; value_type ; index); const. protected . Return the legacy RooCatType corresponding to index. If it doesn't exist, create one. ; Definition at line 698 of file RooAbsCategory.cxx. ◆ setCachedValue(). void RooAbsCategory::setCachedValue ; (; double ; value, . bool ; notifyClients = true . ). finalprotectedvirtual . Overwrite the value stored in this object's cache. ; This can be used to fake a computation that resulted in value. Parameters. [in]valueValue to write. The argument is reinterpreted as a category state. If such a state does not exist, this will create undefined behaviour. ; [in]notifyClientsIf true, notify users of this object that its value changed. This is the default. . Reimplemented from RooAbsArg.; Definition at line 580 of file RooAbsCategory.cxx. ◆ setTreeBranchStatus(). void RooAbsCategory::setTreeBranchStatus ; (; TTree & ; t, . bool ; active . ). overrideprotectedvirtual . (De)activate associate tree branch ; Implements RooAbsArg.; Definition at line 534 of file RooAbsCategory.cxx. ◆ size(). std::size_t RooAbsCategory::size ; (; ); const. inline . Number of states defined. ; Definition at line 99 of file RooAbsCategory.h. ◆ stateNames() [1/2]. std::map< std::string, value_type > & RooAbsCategory::stateNames ; (; ). inlineprotected . Access the map of state names to index numbers. ; Triggers a recomp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:61489,cache,cache,61489,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['cache'],['cache']
Performance,"le RooAddPdf.cxx. ◆ getCoefRange(). const char * RooAddPdf::getCoefRange ; (; ); const. inline . Definition at line 83 of file RooAddPdf.h. ◆ getNormAndCache(). std::pair< const RooArgSet *, AddCacheElem * > RooAddPdf::getNormAndCache ; (; const RooArgSet * ; nset); const. private . Look up projection cache and per-PDF norm sets. ; If a PDF doesn't have a special norm set, use the defaultNorm. If defaultNorm == nullptr, use the member _normSet. ; Definition at line 458 of file RooAddPdf.cxx. ◆ getProjCache(). AddCacheElem * RooAddPdf::getProjCache ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset = nullptr . ); const. protected . Manager of cache with coefficient projections and transformations. ; Retrieve cache element for the computation of the PDF normalisation.; Parameters. [in]nsetCurrent normalisation set (integration over these variables yields 1). ; [in]isetIntegration set. Variables to be integrated over (if integrations are performed). If a cache element does not exist, create and fill it on the fly. The cache also contains; Supplemental normalization terms (in case not all added p.d.f.s have the same observables); Projection integrals to calculate transformed fraction coefficients when a frozen reference frame is provided; Projection integrals for similar transformations when a frozen reference range is provided. . Definition at line 406 of file RooAddPdf.cxx. ◆ getValV(). double RooAddPdf::getValV ; (; const RooArgSet * ; set = nullptr); const. overrideprotectedvirtual . Calculate and return the current value. ; Reimplemented from RooAbsPdf.; Definition at line 515 of file RooAddPdf.cxx. ◆ IsA(). TClass * RooAddPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 153 of file RooAddPdf.h. ◆ isBinnedDistribution(). bool RooAddPdf::isBinnedDistribution ; (; const RooArgSet & ; obs); const. overridevirtual . If all components that depend on obs are binned, so is th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddPdf.html:88707,cache,cache,88707,doc/master/classRooAddPdf.html,https://root.cern,https://root.cern/doc/master/classRooAddPdf.html,2,['cache'],['cache']
Performance,"le RooPolynomial.; For details, see the RooFit tutorial rf612_recoverFromInvalidParameters.C and arxiv:2012.02746.; Modernised RooDataHist; RooDataHist was partially modernised to improve const-correctness, to reduce side effects as well as its memory footprint, and to make it ready for RooFit’s faster batch evaluations. Derived classes that directly access protected members might need to be updated. This holds especially for direct accesses to _curWeight, _curWeightErrLo, etc, which have been removed. (It doesn’t make sense to write to these members from const functions when the same information can be retrieved using an index access operator of an array.) All similar accesses in derived classes should be replaced by the getters get_curWeight() or better get_wgt(i), which were also supported in ROOT <v6.24. More details on what happened:. Reduced side effects. This code produces undefined behaviour because the side effect of get(i), i.e., loading the new weight into _curWeight is not guaranteed to happen before weight() is called:. processEvent(dataHist.get(i), dataHist.weight()); // Dangerous! Order of evaluation is not guaranteed.; With the modernised interface, one would use:; processEvent(dataHist.get(i), dataHist.weight(i));; To modernise old code, one should replace patterns like h.get(i); h.func() by h.func(i);. One may #define R__SUGGEST_NEW_INTERFACE to switch on deprecation warnings for the functions in question. Similarly, the bin content can now be set using an index, making prior loading of a certain coordinate unnecessary:; for (int i=0 ; i<hist->numEntries() ; i++) {; - hist->get(i) ;; - hist->set(hist->weight() / sum);; + hist->set(i, hist->weight(i) / sum, 0.);; }. More const correctness. calcTreeIndex() doesn’t rely on side effects, any more. Instead of overwriting the internal coordinates with new values:. // In a RooDataHist subclass:; _vars = externalCoordinates;; auto index = calcTreeIndex();. // Or from the outside:; auto index = dataHist.get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:23040,load,loading,23040,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['load'],['loading']
Performance,"le TBufferIO.h. ◆ TagStreamerInfo(). void TBufferIO::TagStreamerInfo ; (; TVirtualStreamerInfo * ; info). overridevirtual . Mark the classindex of the current file as using this TStreamerInfo. ; Implements TBuffer.; Reimplemented in TMessage.; Definition at line 350 of file TBufferIO.cxx. ◆ Void_Hash(). static R__ALWAYS_INLINE ULong_t TBufferIO::Void_Hash ; (; const void * ; ptr). inlinestaticprotected . Return hash value for provided object. ; Definition at line 53 of file TBufferIO.h. ◆ WriteClones(). Int_t TBufferIO::WriteClones ; (; TClonesArray * ; a, . Int_t ; nobjects . ). overridevirtual . Interface to TStreamerInfo::WriteBufferClones. ; Implements TBuffer.; Definition at line 385 of file TBufferIO.cxx. ◆ WriteObject() [1/3]. template<class T > . Int_t TBuffer::WriteObject ; (; const T * ; objptr, . Bool_t ; cacheReuse = kTRUE . ). inline . Definition at line 159 of file TBuffer.h. ◆ WriteObject() [2/3]. virtual void TBuffer::WriteObject ; (; const TObject * ; obj, . Bool_t ; cacheReuse . ). virtual . Implements TBuffer. ◆ WriteObject() [3/3]. void TBufferIO::WriteObject ; (; const TObject * ; obj, . Bool_t ; cacheReuse = kTRUE . ). overridevirtual . Write object to I/O buffer. ; Implements TBuffer.; Definition at line 530 of file TBufferIO.cxx. ◆ WriteObjectAny(). Int_t TBufferIO::WriteObjectAny ; (; const void * ; obj, . const TClass * ; ptrClass, . Bool_t ; cacheReuse = kTRUE . ). overridevirtual . Write object to I/O buffer. ; This function assumes that the value in 'obj' is the value stored in a pointer to a ""ptrClass"". The actual type of the object pointed to can be any class derived from ""ptrClass"". Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). If 'cacheReuse' is true (default) upon seeing an object address a second time, we record the offset where its was written the first time rather than streaming the object a second time. If 'cacheReuse' is false, we always stream the object. This allows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:42473,cache,cacheReuse,42473,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['cache'],['cacheReuse']
Performance,"le TCling.cxx. ◆ HasASTFileOnDisk(). static bool HasASTFileOnDisk ; (; clang::Module * ; M, . const clang::Preprocessor & ; PP, . std::string * ; FullFileName = nullptr . ). static . Checks if there is an ASTFile on disk for the given module M. ; Definition at line 1065 of file TCling.cxx. ◆ hasParsedRootmapForLibrary(). static bool hasParsedRootmapForLibrary ; (; llvm::StringRef ; lib). static . Definition at line 7252 of file TCling.cxx. ◆ hasPrecomputedLibraryDeps(). static bool hasPrecomputedLibraryDeps ; (; llvm::StringRef ; lib). static . Definition at line 7273 of file TCling.cxx. ◆ IsFromRootCling(). static bool IsFromRootCling ; (; ). static . Definition at line 1058 of file TCling.cxx. ◆ IsTupleAscending(). static ETupleOrdering IsTupleAscending ; (; ). static . Definition at line 3923 of file TCling.cxx. ◆ loadGlobalModuleIndex(). static GlobalModuleIndex * loadGlobalModuleIndex ; (; cling::Interpreter & ; interp). static . Definition at line 1080 of file TCling.cxx. ◆ LoadModule(). static bool LoadModule ; (; const std::string & ; ModuleName, . cling::Interpreter & ; interp . ). static . Returnstrue if the module was loaded. ; Definition at line 1030 of file TCling.cxx. ◆ LoadModules(). static void LoadModules ; (; const std::vector< std::string > & ; modules, . cling::Interpreter & ; interp . ). static . Loads the C++ modules that we require to run any ROOT program. ; This is just supposed to make a C++ module from a modulemap available to the interpreter. ; Definition at line 1052 of file TCling.cxx. ◆ PrintDlError(). static void PrintDlError ; (; const char * ; dyLibName, . const char * ; modulename . ). static . Definition at line 1964 of file TCling.cxx. ◆ R__InitStreamerInfoFactory(). static bool R__InitStreamerInfoFactory ; (; ). static . Helper to initialize TVirtualStreamerInfo's factor early. ; Use static initialization to insure only one TStreamerInfo is created. ; Definition at line 1664 of file TCling.cxx. ◆ RegisterCxxModules(). static void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx.html:14901,Load,LoadModule,14901,doc/master/TCling_8cxx.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html,1,['Load'],['LoadModule']
Performance,"le TFoamVect.cxx. ◆ operator+=(). TFoamVect & TFoamVect::operator+= ; (; const TFoamVect & ; Shift). unary addition operator +=; adding vector c*=x, ; Definition at line 130 of file TFoamVect.cxx. ◆ operator-(). TFoamVect TFoamVect::operator- ; (; const TFoamVect & ; p2). subtraction operator -; difference of 2 vectors; c=a-b, a=a-b, NEVER USE IT, VERY SLOW!!! ; Definition at line 169 of file TFoamVect.cxx. ◆ operator-=(). TFoamVect & TFoamVect::operator-= ; (; const TFoamVect & ; Shift). unary subtraction operator -= ; Definition at line 143 of file TFoamVect.cxx. ◆ operator=() [1/3]. TFoamVect & TFoamVect::operator= ; (; const TFoamVect & ; Vect). substitution operator ; Definition at line 86 of file TFoamVect.cxx. ◆ operator=() [2/3]. TFoamVect & TFoamVect::operator= ; (; Double_t ; x). Loading in double prec. number, sometimes can be useful. ; Definition at line 191 of file TFoamVect.cxx. ◆ operator=() [3/3]. TFoamVect & TFoamVect::operator= ; (; Double_t ; Vect[]). Loading in ordinary double prec. vector, sometimes can be useful. ; Definition at line 180 of file TFoamVect.cxx. ◆ operator[](). Double_t & TFoamVect::operator[] ; (; Int_t ; n). [] is for access to elements as in ordinary matrix like a[j]=b[j] (Perhaps against some strict rules but rather practical.) Range protection is built in, consequently for substitution one should use rather use a=b than explicit loop! ; Definition at line 109 of file TFoamVect.cxx. ◆ Print(). void TFoamVect::Print ; (; Option_t * ; option); const. overridevirtual . Printout of all vector components on ""std::cout"". ; Reimplemented from TObject.; Definition at line 203 of file TFoamVect.cxx. ◆ Streamer(). void TFoamVect::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TFoamVect::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 35 of file TFoamVect.h. Member Data Documentation. ◆ fCoords. Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFoamVect.html:14474,Load,Loading,14474,doc/master/classTFoamVect.html,https://root.cern,https://root.cern/doc/master/classTFoamVect.html,1,['Load'],['Loading']
Performance,"le TGLOrthoCamera.h. Constructor & Destructor Documentation. ◆ TGLOrthoCamera() [1/2]. TGLOrthoCamera::TGLOrthoCamera ; (; ). Construct kXOY orthographic camera. ; Definition at line 38 of file TGLOrthoCamera.cxx. ◆ TGLOrthoCamera() [2/2]. TGLOrthoCamera::TGLOrthoCamera ; (; EType ; type, . const TGLVector3 & ; hAxis, . const TGLVector3 & ; vAxis . ). Construct orthographic camera. ; Definition at line 52 of file TGLOrthoCamera.cxx. ◆ ~TGLOrthoCamera(). TGLOrthoCamera::~TGLOrthoCamera ; (; ). override . Destroy orthographic camera. ; Definition at line 66 of file TGLOrthoCamera.cxx. Member Function Documentation. ◆ Apply(). void TGLOrthoCamera::Apply ; (; const TGLBoundingBox & ; sceneBox, . const TGLRect * ; pickRect = nullptr . ); const. overridevirtual . Apply the camera to the current GL context, setting the viewport, projection and modelview matrices. ; After this vertices etc can be directly entered in the world frame. This also updates the cached frustum values, enabling all the projection, overlap tests etc defined in TGLCamera to be used.; Arguments are:; 'box' - view volume box - ignored for ortho camera. Assumed to be same as one passed to Setup().; 'pickRect' - optional picking rect. If non-null, restrict drawing to this viewport rect. . Implements TGLCamera.; Definition at line 246 of file TGLOrthoCamera.cxx. ◆ Class(). static TClass * TGLOrthoCamera::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGLOrthoCamera::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGLOrthoCamera::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 95 of file TGLOrthoCamera.h. ◆ Configure(). void TGLOrthoCamera::Configure ; (; Double_t ; zoom, . Double_t ; dolly, . Double_t ; center[3], . Double_t ; hRotate, . Double_t ; vRotate . ). overridevirtual . Configure the camera state. . zoom - set directly (default = 0.78);; dolly - add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLOrthoCamera.html:22087,cache,cached,22087,doc/master/classTGLOrthoCamera.html,https://root.cern,https://root.cern/doc/master/classTGLOrthoCamera.html,1,['cache'],['cached']
Performance,"le TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:137965,cache,cache,137965,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['cache'],['cache']
Performance,"le TTree.cxx. ◆ Merge() [2/2]. Long64_t TTree::Merge ; (; TCollection * ; li, . TFileMergeInfo * ; info . ). virtual . Merge the trees in the TList into this tree. ; If info->fIsFirst is true, first we clone this TTree info the directory info->fOutputDirectory and then overlay the new TTree information onto this TTree object (so that this TTree object is now the appropriate to use for further merging).; Returns the total number of entries in the merged tree. ; Reimplemented in TChain.; Definition at line 6927 of file TTree.cxx. ◆ MergeTrees(). TTree * TTree::MergeTrees ; (; TList * ; li, . Option_t * ; options = """" . ). static . Static function merging the trees in the TList into a new tree. ; Trees in the list can be memory or disk-resident trees. The new tree is created in the current directory (memory if gROOT). ; Definition at line 6851 of file TTree.cxx. ◆ MoveReadCache(). void TTree::MoveReadCache ; (; TFile * ; src, . TDirectory * ; dir . ). protected . Move a cache from a file to the current file in dir. ; if src is null no operation is done, if dir is null or there is no current file the cache is deleted. ; Definition at line 6983 of file TTree.cxx. ◆ Notify(). bool TTree::Notify ; (; ). overridevirtual . Function called when loading a new class library. ; Reimplemented from TObject.; Definition at line 7033 of file TTree.cxx. ◆ operator=(). TTree & TTree::operator= ; (; const TTree & ; tt). delete . ◆ OptimizeBaskets(). void TTree::OptimizeBaskets ; (; ULong64_t ; maxMemory = 10000000, . Float_t ; minComp = 1.1, . Option_t * ; option = """" . ). virtual . This function may be called after having filled some entries in a Tree. ; Using the information in the existing branch buffers, it will reassign new branch buffer sizes to optimize time and memory.; The function computes the best values for branch buffer sizes such that the total buffer sizes is less than maxMemory and nearby entries written at the same time. In case the branch compression factor for the dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:184804,cache,cache,184804,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['cache'],['cache']
Performance,"le beta_pdf(double x, double a, double b)Probability density function of the beta distribution.Definition PdfFuncMathCore.h:82; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; TMath::ErfDouble_t Erf(Double_t x)Computation of the error function erf(x).Definition TMath.cxx:190; rf105_funcbindingDefinition rf105_funcbinding.py:1; ; RooCFunction1Binding<double,double>::erf[ function=TMath::Erf x=x ] = 0; RooCFunction3PdfBinding<double,double,double,double>::beta[ function=(0x7fb320797e70) x=x2 y=a z=b ] = 0.934689; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Fitting -- RooAbsPdf::fitTo(beta_over_beta_Int[x2]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_beta_over_beta_Int[x2]_betaData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); RooTFnBinding::fa1[ TFn={fa1=sin(x)/x} obs=(x3) ] = -0.0547936; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf105_funcbinding.C. tutorialsroofitrf105_funcbinding.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf105__funcbinding_8C.html:6266,optimiz,optimization,6266,doc/master/rf105__funcbinding_8C.html,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8C.html,2,['optimiz'],['optimization']
Performance,"le for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Bool_t valid() const; { return kTRUE ; }. Double_t sumEntries(const char* cutSpec = 0, const char* cutRange = 0) const. Bool_t isWeighted() const; Do events in dataset have weights?. Bool_t isNonPoissonWeighted() const; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsData.html:35428,cache,cached,35428,root/html530/RooAbsData.html,https://root.cern,https://root.cern/root/html530/RooAbsData.html,1,['cache'],['cached']
Performance,"le for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Double_t weightSquared() const. Bool_t valid() const; { return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsData.html:36005,cache,cached,36005,root/html534/RooAbsData.html,https://root.cern,https://root.cern/root/html534/RooAbsData.html,3,['cache'],['cached']
Performance,"le for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& b); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Bool_t valid() const; { return kTRUE ; }. Double_t sumEntries() const. Double_t sumEntries",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsData.html:35797,cache,cached,35797,root/html532/RooAbsData.html,https://root.cern,https://root.cern/root/html532/RooAbsData.html,1,['cache'],['cached']
Performance,"le for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Bool_t valid() const; { return kTRUE ; }. Double_t sumEntries(const char* cutSpec = 0, const char* cutRange = 0) const. Bool_t isWeighted() const; Do events in dataset have weights?. Bool_t isNonPoissonWeighted() const; Do events in dataset have non-integer weights?. void Print(Option_t* options = 0) const; Printing interface (human readable). Double_t mean(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:34917,cache,cached,34917,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,1,['cache'],['cached']
Performance,"le for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store(); { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Bool_t valid() const; { return kTRUE ; }. Double_t sumEntries(const char* cutSpec = 0, const char* cutRange = 0) const. Bool_t isWeighted() const; Do events in dataset have weights?. Bool_t isNonPoissonWeighted() const; Do events in dataset have non-integer weights?. void Print(Option_t* options = 0) const; Printing interface (human readable). Double_t mean(RooRea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:34763,cache,cached,34763,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,1,['cache'],['cached']
Performance,"le inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:35086,load,load,35086,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,1,['load'],['load']
Performance,"le lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; 836 * <tr><td> `SumCoefRange(const char* name)` <td> Set the range in which to interpret the coefficients of RooAddPdf components; 837 * <tr><td> `NumCPU(int num, int istrat)` <td> Parallelize NLL calculation on num CPUs; 838 * <table>; 839 * <tr><th> Strategy <th> Effect; 840 * <tr><td> 0 = RooFit::BulkPartition - *default* <td> Divide events in N equal chunks; 841 * <tr><td> 1 = RooFit::Interleave <td> Process event i%N in process N. Recommended for binned data with; 842 * a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; 843 * <tr><td> 2 = RooFit::SimComponents <td> Process each component likelihood of a RooSimultaneous fully in a single process; 844 * and distribute components over processes. This approach can be beneficial if normalization calculation time; 845 * dominates the total computation time of a component (since the normalization calculation must be performed; 846 * in each process in strategies 0 and 1. However beware that if the RooSimultaneous components do not share many; 847 * parameters this strategy is inefficient: as most minuit-induced likelihood calculations involve changing; 848 * a single parameter, only 1 of the N processes will be active most of the time if RooSimultaneous components; 849 * do not share many parameters; 850 * <tr><td> 3 = RooFit::Hybrid <td> Follow strategy 0 for all RooSimultaneous components, except those with less than; 851 * 30 dataset entries, for which strategy 2 is followed.; 852 * </table>; 853 * <tr><td> `EvalBackend(std::string const&)` <td> Choose a likelihood evaluation backend:; 854 * <table>; 855 * <tr><th> Backend <th> Description; 856 * <tr><td> **cpu** - *default* <td> New vectorized evaluation mode, using faster math functions and auto-vectorisation.; 857 * Since ROOT 6.23, this is the default if `EvalBackend()` is not passed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:34966,perform,performed,34966,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['perform'],['performed']
Performance,"le that some columns do not contain any pages. ; The page source may load more columns than the minimal necessary set from columns. To indicate which columns have been loaded, LoadClusters()must mark them withSetColumnAvailable(). That includes the ones from thecolumnsthat don't have pages; otherwise subsequent requests for the cluster would assume an incomplete cluster and trigger loading again. LoadClusters()` is typically called from the I/O thread of a cluster pool, i.e. the method runs concurrently to other methods of the page source. ; Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ LoadPage() [1/2]. ROOT::Experimental::Internal::RPageRef ROOT::Experimental::Internal::RPageSource::LoadPage ; (; ColumnHandle_t ; columnHandle, . NTupleSize_t ; globalIndex . ). virtual . Allocates and fills a page that contains the index-th element. ; The default implementation searches the page and calls LoadPageImpl(). Returns a default-constructed RPage for suppressed columns. ; Reimplemented in ROOT::Experimental::Internal::RPageSourceFriends.; Definition at line 319 of file RPageStorage.cxx. ◆ LoadPage() [2/2]. ROOT::Experimental::Internal::RPageRef ROOT::Experimental::Internal::RPageSource::LoadPage ; (; ColumnHandle_t ; columnHandle, . RClusterIndex ; clusterIndex . ). virtual . Another version of LoadPage that allows to specify cluster-relative indexes. ; Returns a default-constructed RPage for suppressed columns. ; Reimplemented in ROOT::Experimental::Internal::RPageSourceFriends.; Definition at line 353 of file RPageStorage.cxx. ◆ LoadPageImpl(). virtual RPageRef ROOT::Experimental::Internal::RPageSource::LoadPageImpl ; (; ColumnHandle_t ; columnHandle, . const RClusterInfo & ; clusterInfo, . ClusterSize_t::ValueType ; idxInCluster . ). protectedpure virtual . Implemented in ROOT::Experimental::Internal::RPageSourceDaos, ROOT::Experimental::Internal::RPage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:15187,Load,LoadPageImpl,15187,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['Load'],['LoadPageImpl']
Performance,le to calculate Delta(-logL) significance w.r.t given null hypothesis; RooDataHist Binned data set; RooDataHistSliceIter Iterator over a one-dimensional slice of a RooDataHist; RooDataProjBinding RealFunc/Dataset binding for data projection of a real function; RooDataSet Unbinned data set; RooDataWeightedAverage Optimized calculator of data weighted average of a RooAbsReal; RooDecay General decay function p.d.f ; RooDerivative Representation of derivative of any RooAbsReal; RooDirItem Base class for RooFit objects that are listed TDirectories; RooDouble Container class for Double_t; RooDstD0BG D*-D0 mass difference background PDF; RooEffGenContext Context for generating a dataset from a PDF; RooEffProd Product operator p.d.f of (PDF x efficiency) implementing optimized generator context; RooEfficiency Generic PDF defined by string expression and list of variables; RooEllipse 2-dimensional contour; RooErrorVar RooAbsRealLValue representation of an error of a RooRealVar; RooExpensiveObjectCache Singleton class that serves as session repository for expensive objects; RooExpensiveObjectCache::ExpensiveObject Cache element containing expensive object and parameter values for which object is valid; RooExponential Exponential PDF; RooExtendPdf Wrapper p.d.f adding an extended likelihood term to an existing p.d.f; RooExtendedBinding Your description goes here...; RooExtendedTerm Meta-p.d.f flat in all observables introducing only extended ML term; RooFFTConvPdf Convolution operator p.d.f based on numeric Fourier transforms; RooFIter ; RooFactoryWSTool RooFit class code and instance factory ; RooFirstMoment Representation of moment in a RooAbsReal in a given RooRealVar; RooFit ; RooFitResult Container class for fit result; RooFitShortHand ; RooFoamGenerator Context for generating a dataset from a PDF using the TFoam class; RooFormula TFormula derived class interfacing with RooAbsArg objects; RooFormulaVar Real-valued function of other RooAbsArgs calculated by a TFormula expr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:35100,optimiz,optimized,35100,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,"['Cache', 'optimiz']","['Cache', 'optimized']"
Performance,"le to calculate Delta(-logL) significance w.r.t given null hypothesis; RooDataHist Binned data set; RooDataHistSliceIter Iterator over a one-dimensional slice of a RooDataHist; RooDataProjBinding RealFunc/Dataset binding for data projection of a real function; RooDataSet Unbinned data set; RooDataWeightedAverage Optimized calculator of data weighted average of a RooAbsReal; RooDecay General decay function p.d.f ; RooDerivative Representation of derivative of any RooAbsReal; RooDirItem Base class for RooFit objects that are listed TDirectories; RooDouble Container class for Double_t; RooDstD0BG D*-D0 mass difference background PDF; RooEffGenContext Context for generating a dataset from a PDF; RooEffProd Product operator p.d.f of (PDF x efficiency) implementing optimized generator context; RooEfficiency Generic PDF defined by string expression and list of variables; RooEllipse 2-dimensional contour; RooErrorVar RooAbsRealLValue representation of an error of a RooRealVar; RooExpensiveObjectCache Singleton class that serves as session repository for expensive objects; RooExpensiveObjectCache::ExpensiveObject Cache element containing expensive object and parameter values for which object is valid; RooExponential Exponential PDF; RooExtendPdf Wrapper p.d.f adding an extended likelihood term to an existing p.d.f; RooExtendedTerm Meta-p.d.f flat in all observables introducing only extended ML term; RooFFTConvPdf Convolution operator p.d.f based on numeric Fourier transforms; RooFIter ; RooFactoryWSTool RooFit class code and instance factory ; RooFit ; RooFitResult Container class for fit result; RooFitShortHand ; RooFoamGenerator Context for generating a dataset from a PDF using the TFoam class; RooFormula TFormula derived class interfacing with RooAbsArg objects; RooFormulaVar Real-valued function of other RooAbsArgs calculated by a TFormula expression; RooFracRemainder Utility function calculating remainder fraction, i.e. 1-sum_i(a_i); RooFunctor Export RooAbsReal as func",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:34682,optimiz,optimized,34682,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,2,"['Cache', 'optimiz']","['Cache', 'optimized']"
Performance,"le to calculate Delta(-logL) significance w.r.t given null hypothesis; RooDataHist Binned data set; RooDataHistSliceIter Iterator over a one-dimensional slice of a RooDataHist; RooDataProjBinding RealFunc/Dataset binding for data projection of a real function; RooDataSet Unbinned data set; RooDataWeightedAverage Optimized calculator of data weighted average of a RooAbsReal; RooDecay General decay function p.d.f ; RooDerivative Representation of derivative of any RooAbsReal; RooDirItem Base class for RooFit objects that are listed TDirectories; RooDouble Container class for Double_t; RooDstD0BG D*-D0 mass difference background PDF; RooEffGenContext Context for generating a dataset from a PDF; RooEffProd Product operator p.d.f of (PDF x efficiency) implementing optimized generator context; RooEfficiency Generic PDF defined by string expression and list of variables; RooEllipse 2-dimensional contour; RooErrorVar RooAbsRealLValue representation of an error of a RooRealVar; RooExpensiveObjectCache Singleton class that serves as session repository for expensive objects; RooExpensiveObjectCache::ExpensiveObject Cache element containing expensive object and parameter values for which object is valid; RooExponential Exponential PDF; RooExtendPdf Wrapper p.d.f adding an extended likelihood term to an existing p.d.f; RooExtendedTerm Meta-p.d.f flat in all observables introducing only extended ML term; RooFFTConvPdf Convolution operator p.d.f based on numeric Fourier transforms; RooFactoryWSTool RooFit class code and instance factory ; RooFit ; RooFitResult Container class for fit result; RooFitShortHand ; RooFoamGenerator Context for generating a dataset from a PDF using the TFoam class; RooFormula TFormula derived class interfacing with RooAbsArg objects; RooFormulaVar Real-valued function of other RooAbsArgs calculated by a TFormula expression; RooFracRemainder Utility function calculating remainder fraction, i.e. 1-sum_i(a_i); RooFunctor Export RooAbsReal as functor; RooFun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:32950,optimiz,optimized,32950,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,8,"['Cache', 'optimiz']","['Cache', 'optimized']"
Performance,"le to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.001 # The preskimmed dataset contains only 0.01 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.2f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; else: dataset_path = ""root://eospublic.cern.ch//eos/root-eos/reduced_atlas_opendata/w""; ; # Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.; files = json.load(open(os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe/df105_WBosonAnalysis.json""))); processes = files.keys(); df = {}; xsecs = {}; sumws = {}; samples = []; for p in processes:; for d in files[p]:; # Construct the dataframes; folder = d[0] # Folder name; sample = d[1] # Sample name; xsecs[sample] = d[2] # Cross-section; sumws[sample] = d[3] # Sum of weights; num_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; bool GoodElectronOrMuon(int type, float pt, float eta, fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:2547,load,load,2547,doc/master/df105__WBosonAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html,1,['load'],['load']
Performance,"le with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TFunctionTemplate * GetFunctionTemplate(const char* name). TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. TListOfFunctions * GetGlobalFunctions(); Internal routine returning, and creating if necessary, the list; of global function. TCollection * GetListOfFunctionOverloads(const char* name) const; Return the collection of functions named ""name"". TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name.; If params != 0 it will also resolve overloading other it returns the first; name match.; If params == 0 and load is true force reading of all currently defined; global functions from Cling.; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfEnums(Bool_t load = kFALSE). TCollection * GetListOfFunctionTemplates(). TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:27529,load,load,27529,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance,"le() constChecks status of element table.Definition TGeoElement.cxx:1286; TGeoElementTable::Printvoid Print(Option_t *option="""") const overridePrint table of elements.Definition TGeoElement.cxx:1398; TGeoElementTable::ImportElementsRNvoid ImportElementsRN()Creates the list of radionuclides.Definition TGeoElement.cxx:1247; TGeoElementTable::ElementRNMap_tstd::map< Int_t, TGeoElementRN * > ElementRNMap_tDefinition TGeoElement.h:408; TGeoElementTable::GetElementTGeoElement * GetElement(Int_t z)Definition TGeoElement.h:435; TGeoElementTable::AddElementvoid AddElement(const char *name, const char *title, Int_t z, Double_t a)Add an element to the table. Obsolete.Definition TGeoElement.cxx:1058; TGeoElementTable::fNelementsRNInt_t fNelementsRNDefinition TGeoElement.h:402; TGeoElementTable::GetElementsRNTObjArray * GetElementsRN() constDefinition TGeoElement.h:438; TGeoElementTable::FindIsotopeTGeoIsotope * FindIsotope(const char *name) constFind existing isotope by name. Not optimized for a big number of isotopes.Definition TGeoElement.cxx:1358; TGeoElementTable::BuildDefaultElementsvoid BuildDefaultElements()Creates the default element table.Definition TGeoElement.cxx:1123; TGeoElementTable::GetNelementsInt_t GetNelements() constDefinition TGeoElement.h:442; TGeoElementTable::TGeoElementTableTGeoElementTable()default constructorDefinition TGeoElement.cxx:980; TGeoElementTable::FindElementTGeoElement * FindElement(const char *name) constSearch an element by symbol or full name Exact matching.Definition TGeoElement.cxx:1334; TGeoElementBase class for chemical elements.Definition TGeoElement.h:36; TGeoElement::fADouble_t fADefinition TGeoElement.h:43; TGeoElement::NInt_t N() constDefinition TGeoElement.h:69; TGeoElement::GetSpecificActivityvirtual Double_t GetSpecificActivity() constDefinition TGeoElement.h:79; TGeoElement::fNisotopesInt_t fNisotopesDefinition TGeoElement.h:42; TGeoElement::fRadTsaiDouble_t fRadTsaiDefinition TGeoElement.h:47; TGeoElement::IsDefinedBool_t Is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoElement_8h_source.html:34465,optimiz,optimized,34465,doc/master/TGeoElement_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoElement_8h_source.html,1,['optimiz'],['optimized']
Performance,"le());; 424 }; 425 ; 426 MethodBase *method = dynamic_cast<MethodBase *>(im);; 427 if (method == 0); 428 return 0; // could not create method; 429 ; 430 // set fDataSetManager if MethodCategory (to enable Category to create datasetinfo objects) // DSMTEST; 431 if (method->GetMethodType() == Types::kCategory) { // DSMTEST; 432 MethodCategory *methCat = (dynamic_cast<MethodCategory *>(im)); // DSMTEST; 433 if (!methCat) { // DSMTEST; 434 Log() << kFATAL << ""Method with type kCategory cannot be casted to MethodCategory. /Factory""; 435 << Endl; // DSMTEST; 436 return nullptr;; 437 }; 438 if (fModelPersistence); 439 methCat->SetWeightFileDir(fileDir);; 440 methCat->SetModelPersistence(fModelPersistence);; 441 methCat->fDataSetManager = loader->GetDataSetInfo().GetDataSetManager(); // DSMTEST; 442 methCat->SetFile(fgTargetFile);; 443 methCat->SetSilentFile(IsSilentFile());; 444 } // DSMTEST; 445 ; 446 if (!method->HasAnalysisType(fAnalysisType, loader->GetDataSetInfo().GetNClasses(),; 447 loader->GetDataSetInfo().GetNTargets())) {; 448 Log() << kWARNING << ""Method "" << method->GetMethodTypeName() << "" is not capable of handling "";; 449 if (fAnalysisType == Types::kRegression) {; 450 Log() << ""regression with "" << loader->GetDataSetInfo().GetNTargets() << "" targets."" << Endl;; 451 } else if (fAnalysisType == Types::kMulticlass) {; 452 Log() << ""multiclass classification with "" << loader->GetDataSetInfo().GetNClasses() << "" classes."" << Endl;; 453 } else {; 454 Log() << ""classification with "" << loader->GetDataSetInfo().GetNClasses() << "" classes."" << Endl;; 455 }; 456 return 0;; 457 }; 458 ; 459 if (fModelPersistence); 460 method->SetWeightFileDir(fileDir);; 461 method->SetModelPersistence(fModelPersistence);; 462 method->SetAnalysisType(fAnalysisType);; 463 method->SetupMethod();; 464 method->ParseOptions();; 465 method->ProcessSetup();; 466 method->SetFile(fgTargetFile);; 467 method->SetSilentFile(IsSilentFile());; 468 ; 469 // check-for-unused-options is performed; may b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:18338,load,loader,18338,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"le();; 94 return fSample->GetMetaData().GetS(key);; 95 }; 96 ; 97 /// @brief Check whether the sample name contains the given substring.; 98 bool Contains(std::string_view substr) const; 99 {; 100 // C++14 needs the conversion from std::string_view to std::string; 101 return fID.find(std::string(substr)) != std::string::npos;; 102 }; 103 ; 104 /// @brief Check whether the sample name is empty.; 105 ///; 106 /// This is the case e.g. when using a RDataFrame with no input data, constructed as `RDataFrame(nEntries)`.; 107 bool Empty() const {; 108 return fID.empty();; 109 }; 110 ; 111 /// @brief Return a string representation of the sample name.; 112 ///; 113 /// The representation is of the form ""<filename>/<treename>"" if the input data comes from a TTree or a TChain.; 114 const std::string &AsString() const; 115 {; 116 return fID;; 117 }; 118 ; 119 /// @brief Return the entry range in the sample that is being taken into consideration.; 120 ///; 121 /// Multiple multi-threading tasks might process different entry ranges of the same sample.; 122 std::pair<ULong64_t, ULong64_t> EntryRange() const { return fEntryRange; }; 123 ; 124 /// @brief Return the number of entries of this sample that is being taken into consideration.; 125 ULong64_t NEntries() const { return fEntryRange.second - fEntryRange.first; }; 126 ; 127 bool operator==(const RSampleInfo &other) const { return fID == other.fID; }; 128 bool operator!=(const RSampleInfo &other) const { return !(*this == other); }; 129};; 130 ; 131/// The type of a data-block callback, registered with an RDataFrame computation graph via e.g. \ref; 132/// ROOT::RDF::RInterface< Proxied, DS_t >::DefinePerSample ""DefinePerSample()"" or by certain actions (e.g. \ref; 133/// ROOT::RDF::RInterface<Proxied,DataSource>::Snapshot ""Snapshot()"").; 134using SampleCallback_t = std::function<void(unsigned int, const ROOT::RDF::RSampleInfo &)>;; 135 ; 136} // namespace RDF; 137} // namespace ROOT; 138 ; 139#endif; RSample.hxx; ULong64_tunsigne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSampleInfo_8hxx_source.html:4314,multi-thread,multi-threading,4314,doc/master/RSampleInfo_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RSampleInfo_8hxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"le* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ParameterGradient(const double* x, const double* p, double* grad) const. Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const. Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(x, p, ipar). void ParameterGradient(const double* x, double* grad) const. Evaluate all derivatives using cached parameter values. return ParameterGradient(x, Parameters(), grad). double ParameterDerivative(const double* x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. virtual ~IParametricGradFunctionOneDim(). Virtual Destructor (no operations). {}. void ParameterGradient(double x, const double* p, double* grad) const. Evaluate the derivatives of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency if needed. double ParameterDerivative(double x, const double* p, unsigned int ipar = 0) const. Partial derivative with respect a parameter. double ParameterDerivative(double x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IParametricGradFunctionOneDim.html:3898,cache,cached,3898,root/html602/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IParametricGradFunctionOneDim.html,1,['cache'],['cached']
Performance,"le* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ParameterGradient(const double* x, const double* p, double* grad) const. Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const. Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(x, p, ipar). void ParameterGradient(const double* x, double* grad) const. Evaluate all derivatives using cached parameter values. return ParameterGradient(x, Parameters(), grad). double ParameterDerivative(const double* x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. virtual ~IParametricGradFunctionOneDim(). Virtual Destructor (no operations). {}. void ParameterGradient(double x, const double* p, double* grad) const. Evaluate the derivatives of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency if needed. double ParameterDerivative(double x, const double* p, unsigned int ipar = 0) const. Partial derivative with respect a parameter. double ParameterDerivative(double x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IParametricGradFunctionOneDim.html:3189,cache,cached,3189,root/html534/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricGradFunctionOneDim.html,1,['cache'],['cached']
Performance,"le* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ParameterGradient(const double* x, const double* p, double* grad) const. Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const. Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(x, p, ipar). void ParameterGradient(const double* x, double* grad) const. Evaluate all derivatives using cached parameter values. return ParameterGradient(x, Parameters(), grad). double ParameterDerivative(const double* x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. virtual ~IParametricGradFunctionOneDim(). Virtual Destructor (no operations). {}. void ParameterGradient(double x, const double* p, double* grad) const. Evaluate the derivatives of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency if needed. double ParameterDerivative(double x, const double* p, unsigned int ipar = 0) const. Partial derivative with respect a parameter. double ParameterDerivative(double x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IParametricGradFunctionOneDim.html:3898,cache,cached,3898,root/html604/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IParametricGradFunctionOneDim.html,1,['cache'],['cached']
Performance,"le* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ParameterGradient(const double* x, const double* p, double* grad) const. Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const. Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(x, p, ipar). void ParameterGradient(const double* x, double* grad) const. Evaluate all derivatives using cached parameter values. return ParameterGradient(x, Parameters(), grad). double ParameterDerivative(const double* x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. virtual ~IParametricGradFunctionOneDim(). Virtual Destructor (no operations). {}. void ParameterGradient(double x, const double* p, double* grad) const. Evaluate the derivatives of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency if needed. double ParameterDerivative(double x, const double* p, unsigned int ipar = 0) const. Partial derivative with respect a parameter. double ParameterDerivative(double x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IParametricGradFunctionOneDim.html:3187,cache,cached,3187,root/html528/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IParametricGradFunctionOneDim.html,3,['cache'],['cached']
Performance,"le* p, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; virtual voidParameterGradient(double x, const double* par, double* grad) const; virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; static voidSetDerivPrecision(double eps); virtual voidSetParameters(const double* p); ROOT::Math::WrappedTF1WrappedTF1(); ROOT::Math::WrappedTF1WrappedTF1(TF1& f); ROOT::Math::WrappedTF1WrappedTF1(const ROOT::Math::WrappedTF1& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const; virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Data Members; private:. TF1*fFuncpointer to ROOT function; boolfLinearflag for linear functions ; vector<double>fParamscached vector with parameter values; boolfPolynomialflag for polynomial functions ; doublefX[1]! cached vector for x value (needed for TF1::EvalPar signature) ; static doublefgEpsepsilon used in derivative calculation h ~ eps |x|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedTF1(); {}. WrappedTF1( TF1 & f ). constructor from a TF1 function pointer. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. WrappedTF1(const WrappedTF1 & rhs). Copy constructor. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(uns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__WrappedTF1.html:2409,cache,cached,2409,root/html526/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__WrappedTF1.html,1,['cache'],['cached']
Performance,"le, TNetFile, TWebFile, and TNetXNGFile.; Definition at line 1720 of file TFile.cxx. ◆ ReadBufferAsync(). Bool_t TFile::ReadBufferAsync ; (; Long64_t ; offs, . Int_t ; len . ). virtual . Reimplemented in TDavixFile.; Definition at line 5208 of file TFile.cxx. ◆ ReadBuffers(). Bool_t TFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). virtual . Read the nbuf blocks described in arrays pos and len. ; The value pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer. This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented in TDavixFile, TDCacheFile, TNetFile, TS3WebFile, TWebFile, and TNetXNGFile.; Definition at line 1821 of file TFile.cxx. ◆ ReadBufferViaCache(). Int_t TFile::ReadBufferViaCache ; (; char * ; buf, . Int_t ; len . ). protected . Read buffer via cache. ; Returns 0 if the requested block is not in the cache, 1 in case read via cache was successful, 2 in case read via cache failed. ; Definition at line 1889 of file TFile.cxx. ◆ ReadFree(). void TFile::ReadFree ; (; ). virtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 1925 of file TFile.cxx. ◆ ReadProcessID(). TProcessID * TFile::ReadProcessID ; (; UShort_t ; pidf). virtual . The TProcessID with number pidf is read from this file. ; If the object is not already entered in the gROOT list, it is added. ; Definition at line 1951 of file TFile.cxx. ◆ ReadStreamerInfo(). void TFile::ReadStreamerInfo ; (; ). virtual . Read the list of StreamerInfo from this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see TFile",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFile.html:87470,cache,cache,87470,doc/master/classTFile.html,https://root.cern,https://root.cern/doc/master/classTFile.html,3,['cache'],['cache']
Performance,"le, by the Draw(); method. It allows the same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TEnum * Get(TListOfEnums::DeclId_t id, const char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the dec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfEnums.html:13586,load,loaded,13586,root/html602/TListOfEnums.html,https://root.cern,https://root.cern/root/html602/TListOfEnums.html,1,['load'],['loaded']
Performance,"le, true if the removal of background before; deconvolution is desired� ; fDeconIterations-number; of iterations in deconvolution operation; fMarkov-logical; variable, if it is true, first the source spectrum is replaced by new spectrum; calculated using Markov chains method ; fAverWindow-width of averaging smoothing window ;  ; References:; [1] M.A. Mariscotti: A method for; identification of peaks in the presence of background and its application to; spectrum analysis. NIM 50 (1967), 309-320.; [2] �M.; Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3] Z.K. Silagadze, A new; algorithm for automatic photopeak searches. NIM A 376 (1996), 451.;  ; Example of peak searching method;  ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the destination spectrum. Based on the output data one can tune the; parameters. ; Example 1 � script Search3.c:;  . Fig. 1 Three-dimensional; spectrum with 5 peaks (, threshold=5%, 3 iterations steps in; the deconvolution);  . Fig. 2 Spectrum from Fig. 1; after background elimination and deconvolution;  ; Script:; // Example to illustrate high; resolution peak searching function (class TSpectrum3).; // To execute this example,; do; // root > .x Search3.C; void Search3() {; �� Int_t i, j, k, nfound;; �� Int_t nbinsx = 32;; �� Int_t nbinsy = 32;; �� Int_t nbinsz =; 32;�� ; �� Int_t xmin� = 0;; �� Int_t xmax� =; nbinsx;; �� Int_t ymin� = 0;; �� Int_t ymax� =; nbinsy;�� ; �� Int_t zmin� = 0;; �� Int_t zmax� = nbinsz;����� ; �� Double_t*** source = new; Double_t**[nbinsx];; �� Double_t*** dest = new Double_t; **[nbinsx];����� ; �� for(i=0;i<nbinsx;i++){; ����� source[i]=new Double_t*; [nbinsy];; �����; for(j=0;j<nbinsy;j++); �������� source[i][j]=new; Double_t[nbinsz];; �� }�� ������� ; �� for(i=0;i<nbinsx;i++){; ����� dest[i]=new Double_t*;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum3.html:34971,tune,tune,34971,root/html602/TSpectrum3.html,https://root.cern,https://root.cern/root/html602/TSpectrum3.html,2,['tune'],['tune']
Performance,"le, true if the removal of background before; deconvolution is desired� ; fDeconIterations-number; of iterations in deconvolution operation; fMarkov-logical; variable, if it is true, first the source spectrum is replaced by new spectrum; calculated using Markov chains method ; fAverWindow-width of averaging smoothing window ;  ; References:; [1] M.A. Mariscotti: A method for; identification of peaks in the presence of background and its application to; spectrum analysis. NIM 50 (1967), 309-320.; [2] �M.; Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3] Z.K. Silagadze, A new; algorithm for automatic photopeak searches. NIM A 376 (1996), 451.;  ; Example of peak searching method;  ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the destination spectrum. Based on the output data one can tune the; parameters. ; Example 1 � script Search3.c:;  . Fig. 1 Three-dimensional; spectrum with 5 peaks (, threshold=5%, 3 iterations steps in; the deconvolution);  . Fig. 2 Spectrum from Fig. 1; after background elimination and deconvolution;  ; Script:; // Example to illustrate high; resolution peak searching function (class TSpectrum3).; // To execute this example,; do; // root > .x Search3.C; void Search3() {; �� Int_t i, j, k, nfound;; �� Int_t nbinsx = 32;; �� Int_t nbinsy = 32;; �� Int_t nbinsz =; 32;�� ; �� Int_t xmin� = 0;; �� Int_t xmax� =; nbinsx;; �� Int_t ymin� = 0;; �� Int_t ymax� =; nbinsy;�� ; �� Int_t zmin� = 0;; �� Int_t zmax� = nbinsz;����� ; �� float *** source = new; float **[nbinsx];; �� float *** dest = new float; **[nbinsx];����� ; �� for(i=0;i<nbinsx;i++){; ����� source[i]=new float*; [nbinsy];; �����; for(j=0;j<nbinsy;j++); �������� source[i][j]=new; float [nbinsz];; �� }�� ������� ; �� for(i=0;i<nbinsx;i++){; ����� dest[i]=new float*; [nbinsy];; �����",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum3.html:34121,tune,tune,34121,root/html528/TSpectrum3.html,https://root.cern,https://root.cern/root/html528/TSpectrum3.html,4,['tune'],['tune']
Performance,"le, true if the removal of; background before deconvolution is desired� ; deconIterations-number of iterations in; deconvolution operation; markov-logical variable, if it is true,; first the source spectrum is replaced by new spectrum calculated using Markov; chains method ; averWindow-width of; averaging smoothing window ;  ; References:; [1]; M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [2]; �M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3]; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; (1996), 451. . Examples of peak searching; method;  ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the destination spectrum. Based on the output data one can tune the; parameters. ; Example 8 � script Src.c:. Fig.; 20 Two-dimensional spectrum with found peaks denoted by markers (,; threshold=5%, 3 iterations steps in the deconvolution). Fig.; 21 Spectrum from Fig. 20 after background elimination and deconvolution; Script:; // Example to illustrate high resolution peak searching; function (class TSpectrum).; // To execute this example, do; // root > .x Src.C;  ; #include <TSpectrum2>;  ; void Src() {; �� Int_t i, j, nfound;; �� Double_t nbinsx = 64;; �� Double_t nbinsy = 64;�� ; �� Double_t xmin� = 0;; �� Double_t xmax� = (Double_t)nbinsx;; �� Double_t ymin� = 0;; �� Double_t ymax� = (Double_t)nbinsy;�� ; �� Double_t** source = new Double_t*[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����������������������������������� source[i]=new; Double_t[nbinsy];; �� Double_t** dest = new Double_t*[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����������������������������������� dest[i]=new; Double_t[nbinsy];; �� TH2F *search = new TH2F(""search"",""High; res",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2.html:39478,tune,tune,39478,root/html602/TSpectrum2.html,https://root.cern,https://root.cern/root/html602/TSpectrum2.html,2,['tune'],['tune']
Performance,"le, true if the removal of; background before deconvolution is desired� ; deconIterations-number of iterations in; deconvolution operation; markov-logical variable, if it is true,; first the source spectrum is replaced by new spectrum calculated using Markov; chains method ; averWindow-width of; averaging smoothing window ;  ; References:; [1]; M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [2]; �M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3]; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; (1996), 451. . Examples of peak searching; method;  ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the destination spectrum. Based on the output data one can tune the; parameters. ; Example 8 � script Src.c:. Fig.; 20 Two-dimensional spectrum with found peaks denoted by markers (,; threshold=5%, 3 iterations steps in the deconvolution). Fig.; 21 Spectrum from Fig. 20 after background elimination and deconvolution; Script:; // Example to illustrate high resolution peak searching; function (class TSpectrum).; // To execute this example, do; // root > .x Src.C;  ; #include <TSpectrum2>;  ; void Src() {; �� Int_t i, j, nfound;; �� Double_t nbinsx = 64;; �� Double_t nbinsy = 64;�� ; �� Double_t xmin� = 0;; �� Double_t xmax� = (Double_t)nbinsx;; �� Double_t ymin� = 0;; �� Double_t ymax� = (Double_t)nbinsy;�� ; �� Float_t ** source = new float *[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����������������������������������� source[i]=new; float[nbinsy];; �� Float_t ** dest = new float *[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����������������������������������� dest[i]=new; float[nbinsy];; �� TH2F *search = new TH2F(""search"",""High; resolution pe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2.html:38638,tune,tune,38638,root/html528/TSpectrum2.html,https://root.cern,https://root.cern/root/html528/TSpectrum2.html,4,['tune'],['tune']
Performance,le. ; Definition at line 123 of file RooAddModel.h. ◆ _codeReg. RooAICRegistry RooAddModel::_codeReg = 10. mutableprotected . ! Registry of component analytical integration codes ; Definition at line 116 of file RooAddModel.h. ◆ _coefCache. std::vector<double> RooAddModel::_coefCache. mutableprotected . ! Transient cache with transformed values of coefficients ; Definition at line 99 of file RooAddModel.h. ◆ _coefErrCount. Int_t RooAddModel::_coefErrCount. mutableprotected . ! Coefficient error counter ; Definition at line 125 of file RooAddModel.h. ◆ _coefList. RooListProxy RooAddModel::_coefList. protected . List of coefficients. ; Definition at line 119 of file RooAddModel.h. ◆ _haveLastCoef. bool RooAddModel::_haveLastCoef = false. protected . Flag indicating if last PDFs coefficient was supplied in the constructor. ; Definition at line 122 of file RooAddModel.h. ◆ _intCacheMgr. RooObjCacheManager RooAddModel::_intCacheMgr. mutableprotected . ! Manager of cache with integrals ; Definition at line 114 of file RooAddModel.h. ◆ _ownedComps. RooArgSet RooAddModel::_ownedComps. mutableprotected . ! Owned components ; Definition at line 127 of file RooAddModel.h. ◆ _pdfList. RooListProxy RooAddModel::_pdfList. protected . List of component PDFs. ; Definition at line 118 of file RooAddModel.h. ◆ _projCacheMgr. RooObjCacheManager RooAddModel::_projCacheMgr. mutableprotected . ! Manager of cache with coefficient projections and transformations ; Definition at line 102 of file RooAddModel.h. ◆ _refCoefNorm. RooSetProxy RooAddModel::_refCoefNorm. mutableprotected . ! Reference observable set for coefficient interpretation ; Definition at line 96 of file RooAddModel.h. ◆ _refCoefRangeName. TNamed* RooAddModel::_refCoefRangeName = nullptr. mutableprotected . ! Reference range name for coefficient interpretation ; Definition at line 97 of file RooAddModel.h. ◆ _snormList. RooArgList* RooAddModel::_snormList {nullptr}. mutableprotected . ! List of supplemental normalization fa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:92181,cache,cache,92181,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['cache'],['cache']
Performance,"le. This is useful in case you do not use the TObject fBits and fUniqueIDdata members. You gain space on the file, and you do not loose functionality if you do not use the fBits and fUniqueID.See “The Role of TObject” on the use of fBits and fUniqueID.; 11.3.10 Streaming a TClonesArray; When writing a TClonesArray it bypasses by default the Streamerof the member class and uses a more efficient internal mechanism to write the members to the file. You can override the default and specify that the member class Streameris used by setting the TClonesArray::BypassStreamer bit to false:; TClonesArray *fTracks;; fTracks->BypassStreamer(kFALSE); // use the member Streamer; When the kBypassStreamer bit is set, the automatically generated Streamercan call directly the method TClass::WriteBuffer. Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However, the drawback is when a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfoof the class in the array being optimized, one cannot later use the TClonesArray with split > 0. For example, there is a problem with the following scenario: a class Foo has a TClonesArray of Bar objects the Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance. In a new program, T1 is read and a new Tree T2 is created with the object Foo in split > 1.; When the T2branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:477149,optimiz,optimized,477149,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimized']
Performance,"le2D(). WarningThe Live Visualization feature is only supported for the Dask backend. Performance tips and parallel execution; As pointed out before in this document, RDataFrame can transparently perform multi-threaded event loops to speed up the execution of its actions. Users have to call ROOT::EnableImplicitMT() before constructing the RDataFrame object to indicate that it should take advantage of a pool of worker threads. Each worker thread processes a distinct subset of entries, and their partial results are merged before returning the final values to the user. There are no guarantees on the order in which threads will process the batches of entries. In particular, note that this means that, for multi-thread event loops, there is no guarantee on the order in which Snapshot() will write entries: they could be scrambled with respect to the input dataset. The values of the special rdfentry_ column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; WarningBy default, RDataFrame will use as many threads as the hardware supports, using up all the resources on a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use ROOT::EnableImplicitMT(i); replacing i with the number of CPUs/slots that were allocated for this job. Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops. User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate() will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define() expressions will often be pure in the functional programming sense (no side-effects, no dependency on external state)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:45889,multi-thread,multi-thread,45889,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['multi-thread'],['multi-thread']
Performance,"le3D::GetBinError ); 137/// possible values for the options are documented in TProfile3D::SetErrorOption; 138///; 139/// see also TProfile::BuildOptions for a detailed description; 140 ; 141void TProfile3D::BuildOptions(Double_t tmin, Double_t tmax, Option_t *option); 142{; 143 SetErrorOption(option);; 144 ; 145 // create extra profile data structure (bin entries/ y^2 and sum of weight square); 146 TProfileHelper::BuildArray(this);; 147 ; 148 fTmin = tmin;; 149 fTmax = tmax;; 150 fScaling = kFALSE;; 151 fTsumwt = fTsumwt2 = 0;; 152}; 153 ; 154////////////////////////////////////////////////////////////////////////////////; 155/// Copy constructor.; 156 ; 157TProfile3D::TProfile3D(const TProfile3D &profile3d) : TH3D(); 158{; 159 profile3d.TProfile3D::Copy(*this);; 160}; 161 ; 162TProfile3D &TProfile3D::operator=(const TProfile3D &profile3d); 163{; 164 if (this != &profile3d); 165 profile3d.TProfile3D::Copy(*this);; 166 return *this;; 167}; 168 ; 169////////////////////////////////////////////////////////////////////////////////; 170/// Performs the operation: `this = this + c1*f1` .; 171 ; 172Bool_t TProfile3D::Add(TF1 *, Double_t , Option_t*); 173{; 174 Error(""Add"",""Function not implemented for TProfile3D"");; 175 return kFALSE;; 176}; 177 ; 178////////////////////////////////////////////////////////////////////////////////; 179/// Performs the operation: `this = this + c1*h1` .; 180 ; 181Bool_t TProfile3D::Add(const TH1 *h1, Double_t c1); 182{; 183 if (!h1) {; 184 Error(""Add"",""Attempt to add a non-existing profile"");; 185 return kFALSE;; 186 }; 187 if (!h1->InheritsFrom(TProfile3D::Class())) {; 188 Error(""Add"",""Attempt to add a non-profile2D object"");; 189 return kFALSE;; 190 }; 191 ; 192 return TProfileHelper::Add(this, this, h1, 1, c1);; 193}; 194 ; 195////////////////////////////////////////////////////////////////////////////////; 196/// Replace contents of this profile3D by the addition of h1 and h2.; 197///; 198/// `this = c1*h1 + c2*h2`; 199 ; 200Bool_t TProf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:6844,Perform,Performs,6844,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['Perform'],['Performs']
Performance,"le: ; WebGui.HttpPort: 8088; or specify range of http ports, which can be used: WebGui.HttpPortMin: 8800; WebGui.HttpPortMax: 9800; By default range [8800..9800] is used; One also can bind HTTP server socket to loopback address, In that case only connection from localhost will be available: WebGui.HttpLoopback: yes; Or one could specify hostname which should be used for binding of server socket WebGui.HttpBind: hostname | ipaddress; To use secured protocol, following parameter should be specified WebGui.UseHttps: yes; WebGui.ServerCert: sertificate_filename.pem; Alternatively, one can specify unix socket to handle requests: WebGui.UnixSocket: /path/to/unix/socket; WebGui.UnixSocketMode: 0700; Typically one used unix sockets together with server mode like root --web=server:/tmp/root.socket and then redirect it via ssh tunnel (e.g. using rootssh) to client node; All incoming requests processed in THttpServer in timer handler with 10 ms timeout. One may decrease value to improve latency or increase value to minimize CPU load WebGui.HttpTimer: 10; To processing incoming http requests and websockets, THttpServer allocate 10 threads One have to increase this number if more simultaneous connections are expected: WebGui.HttpThrds: 10; One also can configure usage of special thread of processing of http server requests WebGui.HttpThrd: no; Extra threads can be used to send data to different clients via websocket (default no) WebGui.SenderThrds: no; If required, one could change websocket timeouts (default is 10000 ms) WebGui.HttpWSTmout: 10000; By default, THttpServer created in restricted mode which only allows websocket handlers and processes only very few other related http requests. For security reasons such mode should be always enabled. Only if it is really necessary to process all other kinds of HTTP requests, one could specify no for following parameter (default yes): WebGui.WSOnly: yes; In some applications one may need to force longpoll websocket emulations from the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:8474,latency,latency,8474,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,4,"['latency', 'load']","['latency', 'load']"
Performance,"le: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; TCut mycutb = """"; // for example: TCut mycutb = ""abs(var1)<0.5"";; ; // Tell the factory how to use the training and testing events; //; // If no numbers of events are given, half of the events in the tree are used; // for training, and the other half for testing:; // loader->PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; // To also specify the number of testing events, use:; ; loader->PrepareTrainingAndTestTree( mycuts, mycutb,; ""nTrain_Signal=7000:nTrain_Background=7000:SplitMode=Random:NormMode=NumEvents:!V"" );; ; /***; ## Booking Methods; ; Here we book the TMVA methods. We book first a Likelihood based on KDE (Kernel Density Estimation), a Fischer discriminant, a BDT; and a shallow neural network; ; */; ; ; // Likelihood (""naive Bayes estimator""); if (useLikelihood) {; factory.BookMethod(loader, TMVA::Types::kLikelihood, ""Likelihood"",; ""H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; }; // Use a kernel density estimator to approximate the PDFs; if (useLikelihoodKDE) {; factory.BookMethod(loader, TMVA::Types::kLikelihood, ""LikelihoodKDE"",; ""!H:!V:!TransformOutput:PDFInterpol=KDE:KDEtype=Gauss:KDEiter=Adaptive:KDEFineFactor=0.3:KDEborder=None:NAvEvtPerBin=50"" );; ; }; ; // Fisher discriminant (same as LD); if (useFischer) {; factory.BookMethod(loader, TMVA::Types::kFisher, ""Fisher"", ""H:!V:Fisher:VarTransform=None:CreateMVAPdfs:PDFInterpolMVAPdf=Spline2:NbinsMVAPdf=50:NsmoothMVAPdf=10"" );; }; ; //Boosted Decision Trees; if (useBDT) {; factory.BookMethod(loader,TMVA::Types::kBDT, ""BDT"",; ""!V:NTrees=200:MinNodeSize=2.5%:MaxDepth=2:BoostType=AdaBoost:AdaBoostBeta=0.5:UseBaggedBoost:BaggedSampleFraction=0.5:SeparationType=GiniIndex:nCuts=20"" );; }; ; //Multi-Layer Perceptron (Neural Network); if (useMLP) {; factory.BookMethod(loader, TMVA::Types::kMLP, ""MLP"",; ""!H:!V:NeuronType=tanh:VarTransform=N:NCycles=100:HiddenLayers=N+5:Te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:61821,load,loader,61821,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['load'],['loader']
Performance,"le::Open. TFile::Open will recognize that you are trying to open an XML file and return a TXMLFile object. When a XML file is open in write mode, one can use the normal TObject::Write to write an object in the file.; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; The canvas can be saved as a XML file format via File menu / Save or Save As menu entries. One can do also:; canvas->Print(""Example.xml"");; 12 Trees; 12.1 Why Should You Use a Tree?; In the “Input/Output” chapter, we saw how objects can be saved in ROOT files. In case you want to store large quantities of same-class objects, ROOT has designed the TTree and TNtuple classes specifically for that purpose. The TTree class is optimized to reduce disk space and enhance access speed. A TNtuple is a TTree that is limited to only hold floating-point numbers; a TTree on the other hand can hold all kind of data, such as objects or arrays in addition to all the simple types.; When using a TTree, we fill its branch buffers with leaf data and the buffers are written to disk when it is full. Branches, buffers, and leafs, are explained a little later in this chapter, but for now, it is important to realize that each object is not written individually, but rather collected and written a bunch at a time.; This is where the TTree takes advantage of compression and will produce a much smaller file than if the objects were written individually. Since the unit to be compressed is a buffer, and the TTree contains many same-class objects, the header of the objects can be compressed.; The TTree reduces the header of each object, but it still contains the class name. Using compression, the class name of each same-class object has a good chance o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:519663,optimiz,optimized,519663,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimized']
Performance,"le::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. Bool_t GetReadStreamerInfo(); static function to get the value of fgReadInfo.; See TFile::SetReadStreamerInfo for more documentation. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:48574,cache,cache,48574,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,2,['cache'],['cache']
Performance,"le::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:44064,cache,cache,44064,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,4,['cache'],['cache']
Performance,"le::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTreeDataStore.html:11781,cache,cached,11781,root/html602/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html602/RooTreeDataStore.html,8,"['cache', 'load']","['cache', 'cached', 'loading']"
Performance,"le::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); RooGenericPdf(); RooGenericPdf(const RooGenericPdf& other, const char* name = 0); RooGenericPdf(const char* name, const char* title, const RooArgList& dependents); RooGenericPdf(const char* name, const char* title, const char* formula, const RooArgList& dependents); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenericPdf.html:28066,cache,cache,28066,root/html602/RooGenericPdf.html,https://root.cern,https://root.cern/root/html602/RooGenericPdf.html,2,['cache'],['cache']
Performance,"le::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenericPdf.html:26237,cache,cache,26237,root/html526/RooGenericPdf.html,https://root.cern,https://root.cern/root/html526/RooGenericPdf.html,2,['cache'],['cache']
Performance,"le::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGenericPdf.html:26881,cache,cache,26881,root/html532/RooGenericPdf.html,https://root.cern,https://root.cern/root/html532/RooGenericPdf.html,1,['cache'],['cache']
Performance,"le::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenericPdf.html:28336,cache,cache,28336,root/html534/RooGenericPdf.html,https://root.cern,https://root.cern/root/html534/RooGenericPdf.html,1,['cache'],['cache']
Performance,"le::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGenericPdf.html:26796,cache,cache,26796,root/html530/RooGenericPdf.html,https://root.cern,https://root.cern/root/html530/RooGenericPdf.html,1,['cache'],['cache']
Performance,"le< const std::vector< Event * > &, const DataSetInfo & > TMVAInput_tDefinition DataLoader.h:40; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gConfigConfig & gConfig(); TMVA::gToolsTools & gTools(); TMVA::fetchValueTmpTString fetchValueTmp(const std::map< TString, TString > &keyValueMap, TString key)Definition MethodDL.cxx:75; TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMVA::TTrainingSettingsAll of the options that can be specified in the training string.Definition MethodDL.h:72; TMVA::TTrainingSettings::batchSizesize_t batchSizeDefinition MethodDL.h:73; TMVA::TTrainingSettings::optimizerParamsstd::map< TString, double > optimizerParamsDefinition MethodDL.h:84; TMVA::TTrainingSettings::optimizerNameTString optimizerNameDefinition MethodDL.h:79; TMVA::TTrainingSettings::optimizerDNN::EOptimizer optimizerDefinition MethodDL.h:78; TMVA::TTrainingSettings::maxEpochssize_t maxEpochsDefinition MethodDL.h:76; TMVA::TTrainingSettings::momentumDouble_t momentumDefinition MethodDL.h:81; TMVA::TTrainingSettings::weightDecayDouble_t weightDecayDefinition MethodDL.h:82; TMVA::TTrainingSettings::testIntervalsize_t testIntervalDefinition MethodDL.h:74; TMVA::TTrainingSettings::regularizationDNN::ERegularization regularizationDefinition MethodDL.h:77; TMVA::TTrainingSettings::convergenceStepssize_t convergenceStepsDefinition MethodDL.h:75; TMVA::TTrainingSettings::dropoutProbabilitiesstd::vector< Double_t > dropoutProbabilitiesDefinition MethodDL.h:83; TMVA::TTrainingSettings::learningRateDouble_t learningRateDefinition MethodDL.h:80; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; t1auto * t1Definition textangle.C:20; Functions.h; Types.h; outputstatic void output(). tmvatmvasrcMethodDL.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:121510,optimiz,optimizerDNN,121510,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,2,['optimiz'],"['optimizerDNN', 'optimizerDefinition']"
Performance,leCacheRead::fBIsSorted; Bool_tTFileCacheRead::fBIsTransferred; Int_t*TFileCacheRead::fBLen; Int_tTFileCacheRead::fBNb; Int_tTFileCacheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos; Long64_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:16671,cache,cache,16671,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,2,['cache'],['cache']
Performance,leCacheRead::fBIsTransferred; Int_t*TFileCacheRead::fBLen[fBNb]; Int_tTFileCacheRead::fBNb; Int_tTFileCacheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos[fBNb]; Long64_t*TFileCacheRead::fBSeek[fBNseek]; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache i,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCacheUnzip.html:12222,cache,cache,12222,root/html602/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html,2,['cache'],['cache']
Performance,leCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:18553,cache,cache,18553,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['cache'],['cache']
Performance,"leException(Int_t sig); 591{; 592 if (TROOT::Initialized()) {; 593 if (gException) {; 594 gInterpreter->RewindDictionary();; 595 gInterpreter->ClearFileBusy();; 596 }; 597 if (fExitOnException == kExit); 598 gSystem->Exit(128 + sig);; 599 else if (fExitOnException == kAbort); 600 gSystem->Abort();; 601 else; 602 Throw(sig);; 603 }; 604 gSystem->Exit(128 + sig);; 605}; 606 ; 607////////////////////////////////////////////////////////////////////////////////; 608/// Set the exit on exception option. Setting this option determines what; 609/// happens in HandleException() in case an exception (kSigBus,; 610/// kSigSegmentationViolation, kSigIllegalInstruction or kSigFloatingException); 611/// is trapped. Choices are: kDontExit (default), kExit or kAbort.; 612/// Returns the previous value.; 613 ; 614TApplication::EExitOnException TApplication::ExitOnException(TApplication::EExitOnException opt); 615{; 616 EExitOnException old = fExitOnException;; 617 fExitOnException = opt;; 618 return old;; 619}; 620 ; 621/////////////////////////////////////////////////////////////////////////////////; 622/// The function generates and executes a command that loads the Doxygen URL in; 623/// a browser. It works for Mac, Windows and Linux. In the case of Linux, the; 624/// function also checks if the DISPLAY is set. If it isn't, a warning message; 625/// and the URL will be displayed on the terminal.; 626///; 627/// \param[in] url web page to be displayed in a browser; 628 ; 629void TApplication::OpenInBrowser(const TString &url); 630{; 631 // We check what operating system the user has.; 632#ifdef R__MACOSX; 633 // Command for opening a browser on Mac.; 634 TString cMac(""open "");; 635 // We generate the full command and execute it.; 636 cMac.Append(url);; 637 gSystem->Exec(cMac);; 638#elif defined(R__WIN32); 639 // Command for opening a browser on Windows.; 640 TString cWindows(""start \""\"" "");; 641 cWindows.Append(url);; 642 gSystem->Exec(cWindows);; 643#else; 644 // Command for open",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:21373,load,loads,21373,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['load'],['loads']
Performance,"leImplicitMT(num_threads);; }; #endif; ; TMVA::Config::Instance();; ; std::cout << ""Running with nthreads = "" << ROOT::GetThreadPoolSize() << std::endl;; ; TString inputFileName = ""time_data_t10_d30.root"";; ; bool fileExist = !gSystem->AccessPathName(inputFileName);; ; // if file does not exists create it; if (!fileExist) {; MakeTimeData(nTotEvts,ntime, ninput);; }; ; ; auto inputFile = TFile::Open(inputFileName);; if (!inputFile) {; Error(""TMVA_RNN_Classification"", ""Error opening input file %s - exit"", inputFileName.Data());; return;; }; ; ; std::cout << ""--- RNNClassification : Using input file: "" << inputFile->GetName() << std::endl;; ; // Create a ROOT output file where TMVA will store ntuples, histograms, etc.; TString outfileName(TString::Format(""data_RNN_%s.root"", archString.Data()));; TFile *outputFile = nullptr;; if (writeOutputFile) outputFile = TFile::Open(outfileName, ""RECREATE"");; ; /**; ## Declare Factory; ; Create the Factory class. Later you can choose the methods; whose performance you'd like to investigate.; ; The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to; pass; ; - The first argument is the base of the name of all the output; weightfiles in the directory weight/ that will be created with the; method parameters; ; - The second argument is the output file for the training results; ; - The third argument is a string option defining some general configuration for the TMVA session.; For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in; the option string; ; **/; ; // Creating the factory object; TMVA::Factory *factory = new TMVA::Factory(""TMVAClassification"", outputFile,; ""!V:!Silent:Color:DrawProgressBar:Transformations=None:!Correlations:""; ""AnalysisType=Classification:ModelPersistence"");; TMVA::DataLoader *dataloader = new TMVA::DataLoader(""dataset"");; ; TTree *signalTree = (TTree *)inputFile->Get(""sgn"");; TTree *background = (TTree *)i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:62386,perform,performance,62386,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['perform'],['performance']
Performance,leInfoClass for type info of MVA input variable ;  CVariableNormalizeTransformLinear interpolation class ;  CVariablePCATransformLinear interpolation class ;  CVariableRearrangeTransformRearrangement of input variables ;  CVariableTransformBaseLinear interpolation class ;  CVarTransformHandler;  CVolumeVolume for BinarySearchTree ;  ►NTStreamerInfoActions;  ►CTActionSequence;  CSequencePtr;  CTConfigurationBase class of the Configurations ;  CTConfiguredAction;  CTIDNode;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  CTNestedIDs;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CBalancerInfo;  Cbasic_string_view;  CBasicRNNLayerGeneric implementation ;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CClassificationClass to perform two class classification ;  CClassificationResultClass to save the results of the classifier ;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  CGraphCreatorHelperHelper class that provides the operation graph nodes ;  CGraphNodeClass used to create the ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:94852,perform,perform,94852,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['perform'],['perform']
Performance,"leInfoENTupleInfoListing of the different options that can be printed by RNTupleReader::GetInfo()Definition RNTupleReader.hxx:43; ROOT::Experimental::ENTupleInfo::kMetrics@ kMetrics. Definition at line 364 of file RNTupleReader.hxx. ◆ end(). RIterator ROOT::Experimental::RNTupleReader::end ; (; ). inline . Definition at line 343 of file RNTupleReader.hxx. ◆ GetCollectionView() [1/2]. RNTupleCollectionView ROOT::Experimental::RNTupleReader::GetCollectionView ; (; DescriptorId_t ; fieldId). inline . Definition at line 337 of file RNTupleReader.hxx. ◆ GetCollectionView() [2/2]. RNTupleCollectionView ROOT::Experimental::RNTupleReader::GetCollectionView ; (; std::string_view ; fieldName). inline . Raises an exception if: . there is no field with the given name or,; the field is not a collection . Definition at line 327 of file RNTupleReader.hxx. ◆ GetDescriptor(). const ROOT::Experimental::RNTupleDescriptor & ROOT::Experimental::RNTupleReader::GetDescriptor ; (; ). Returns a cached copy of the page source descriptor. ; The returned pointer remains valid until the next call to LoadEntry or to any of the views returned from the reader. ; Definition at line 230 of file RNTupleReader.cxx. ◆ GetDirectAccessView() [1/2]. template<typename T > . RNTupleDirectAccessView< T > ROOT::Experimental::RNTupleReader::GetDirectAccessView ; (; DescriptorId_t ; fieldId). inline . Definition at line 317 of file RNTupleReader.hxx. ◆ GetDirectAccessView() [2/2]. template<typename T > . RNTupleDirectAccessView< T > ROOT::Experimental::RNTupleReader::GetDirectAccessView ; (; std::string_view ; fieldName). inline . Definition at line 311 of file RNTupleReader.hxx. ◆ GetDisplayReader(). ROOT::Experimental::RNTupleReader * ROOT::Experimental::RNTupleReader::GetDisplayReader ; (; ). private . Definition at line 201 of file RNTupleReader.cxx. ◆ GetEntryRange(). RNTupleGlobalRange ROOT::Experimental::RNTupleReader::GetEntryRange ; (; ). inline . Returns an iterator over the entry indices of the RNTupl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html:9043,cache,cached,9043,doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,1,['cache'],['cached']
Performance,"leKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGMimeTypes.h>. Inheritance diagram for TGMimeTypes:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGMimeTypes() [1/2]. TGMimeTypes::TGMimeTypes ; (; const TGMimeTypes & ; gmt). protected . Copy constructor. ; Definition at line 157 of file TGMimeTypes.cxx. ◆ TGMimeTypes() [2/2]. TGMimeTypes::TGMimeTypes ; (; TGClient * ; client, . const char * ; filename . ). Create a mime type cache. ; Read the mime types file ""filename"" and built a list of mime types. ; Definition at line 45 of file TGMimeTypes.cxx. ◆ ~TGMimeTypes(). TGMimeTypes::~TGMimeTypes ; (; ). override . Delete mime type pool. ; Definition at line 147 of file TGMimeTypes.cxx. Member Function Documentation. ◆ AddType(). void TGMimeTypes::AddType ; (; const char * ; type, . const char * ; pat, . const char * ; icon, . const char * ; sicon, . const char * ; action . ). Add a mime type to the list of mime types. ; Definition at line 315 of file TGMimeTypes.cxx. ◆ Class(). static TClass * TGMimeTypes::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGMimeTypes::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGMimeTypes::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 71 of file TGMimeTypes.h. ◆ DeclFileName(). static const char * TGMimeTypes::DeclFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGMimeTypes.html:11610,cache,cache,11610,doc/master/classTGMimeTypes.html,https://root.cern,https://root.cern/doc/master/classTGMimeTypes.html,1,['cache'],['cache']
Performance,"leLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_lenLength of _value; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; char*_value[_len] Value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Lib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsString.html:17801,cache,caches,17801,root/html532/RooAbsString.html,https://root.cern,https://root.cern/root/html532/RooAbsString.html,2,['cache'],"['cache', 'caches']"
Performance,"leName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Types; typedef RooArgList * pRooArgList;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Return specialized context to efficiently generate toy events from RooAddModels. ;  ; void getCompIntList (const RooArgSet *nset, const RooArgSet *iset, pRooArgList &compIntList, Int_t &code, const char *isetRangeName) const;  Check if this configuration was created before. ;  ; AddCacheElem * getProjCache (const RooArgSet *nset, const RooArgSet *iset=nullptr) const;  Retrieve cache element with for calculation of p.d.f value with normalization set nset and integrated over iset in range 'rangeName'. ;  ; void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false) override;  Interface function used by test statistics to freeze choice of observables for interpretation of fraction coefficients. ;  ; void selectNormalizationRange (const char *rangeName=nullptr, bool force=false) override;  Interface function used by test statistics to freeze choice of range for interpretation of fraction coefficients. ;  ; void updateCoefficients (AddCacheElem &cache, const RooArgSet *nset) const;  Update the coefficient values in the given cache element: calculate new remainder fraction, normalize fractions obtained from extended ML terms to unity, and multiply the various range and dimensional corrections needed in the current use context. ;  ;  Protected Member Functions inherited from RooResolutionModel; bool redirectServersH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:62733,cache,cache,62733,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['cache'],['cache']
Performance,"leName;; 1070 if (!HSOpts.PrebuiltModulePaths.empty()); 1071 // Load the module from *only* in the prebuilt module path.; 1072 ModuleFileName = PP.getHeaderSearchInfo().getPrebuiltModuleFileName(M->Name);; 1073 if (FullFileName); 1074 *FullFileName = ModuleFileName;; 1075 ; 1076 return !ModuleFileName.empty();; 1077}; 1078 ; 1079static bool HaveFullGlobalModuleIndex = false;; 1080static GlobalModuleIndex *loadGlobalModuleIndex(cling::Interpreter &interp); 1081{; 1082 CompilerInstance &CI = *interp.getCI();; 1083 Preprocessor &PP = CI.getPreprocessor();; 1084 auto ModuleManager = CI.getASTReader();; 1085 assert(ModuleManager);; 1086 // StringRef ModuleIndexPath = HSI.getModuleCachePath();; 1087 // HeaderSearch& HSI = PP.getHeaderSearchInfo();; 1088 // HSI.setModuleCachePath(TROOT::GetSharedLibDir().Data());; 1089 std::string ModuleIndexPath = TROOT::GetSharedLibDir().Data();; 1090 if (ModuleIndexPath.empty()); 1091 return nullptr;; 1092 // Get an existing global index. This loads it if not already loaded.; 1093 ModuleManager->resetForReload();; 1094 ModuleManager->loadGlobalIndex();; 1095 GlobalModuleIndex *GlobalIndex = ModuleManager->getGlobalIndex();; 1096 ; 1097 // For finding modules needing to be imported for fixit messages,; 1098 // we need to make the global index cover all modules, so we do that here.; 1099 if (!GlobalIndex && !HaveFullGlobalModuleIndex) {; 1100 ModuleMap &MMap = PP.getHeaderSearchInfo().getModuleMap();; 1101 bool RecreateIndex = false;; 1102 for (ModuleMap::module_iterator I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1103 Module *TheModule = I->second;; 1104 // We want the index only of the prebuilt modules.; 1105 if (!HasASTFileOnDisk(TheModule, PP)); 1106 continue;; 1107 LoadModule(TheModule->Name, interp);; 1108 RecreateIndex = true;; 1109 }; 1110 if (RecreateIndex) {; 1111 cling::Interpreter::PushTransactionRAII deserRAII(&interp);; 1112 clang::GlobalModuleIndex::UserDefinedInterestingIDs IDs;; 1113 ; 1114 struct Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:39202,load,loads,39202,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['load'],"['loaded', 'loads']"
Performance,"leOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3Binding<double,unsigned int,double,double>&operator=(const RooCFunction3Binding<double,unsigned int,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html:19886,optimiz,optimizeCacheMode,19886,root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"leOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFunctor1DBinding&operator=(const RooFunctor1DBinding&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctor1DBinding.html:19742,optimiz,optimizeCacheMode,19742,root/html602/RooFunctor1DBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctor1DBinding.html,2,['optimiz'],['optimizeCacheMode']
Performance,"leOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::Heaviside&operator=(const RooStats::Heaviside&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__Heaviside.html:19435,optimiz,optimizeCacheMode,19435,root/html602/RooStats__Heaviside.html,https://root.cern,https://root.cern/root/html602/RooStats__Heaviside.html,2,['optimiz'],['optimizeCacheMode']
Performance,"leOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUnblindCPAsymVar&operator=(const RooUnblindCPAsymVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindCPAsymVar.html:19820,optimiz,optimizeCacheMode,19820,root/html602/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html602/RooUnblindCPAsymVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"leOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUnblindPrecision&operator=(const RooUnblindPrecision&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindPrecision.html:19817,optimiz,optimizeCacheMode,19817,root/html602/RooUnblindPrecision.html,https://root.cern,https://root.cern/root/html602/RooUnblindPrecision.html,2,['optimiz'],['optimizeCacheMode']
Performance,"leOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); RooAbsCategory&operator=(const RooAbsCategory&); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategory.html:11259,optimiz,optimizeCacheMode,11259,root/html602/RooAbsCategory.html,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html,2,['optimiz'],['optimizeCacheMode']
Performance,"leReader.hxx>; using ROOT::Experimental::RNTupleReader;; ; #include <iostream>; ; auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; auto pt = ntuple->GetView<float>(""pt"");; ; for (auto i : ntuple->GetEntryRange()) {; std::cout << i << "": "" << pt(i) << ""\n"";; }; ptTPaveText * ptDefinition entrylist_figure1.C:7. Definition at line 269 of file RNTupleReader.hxx. ◆ GetView() [5/6]. template<typename T > . RNTupleView< T > ROOT::Experimental::RNTupleReader::GetView ; (; std::string_view ; fieldName, . std::shared_ptr< T > ; objPtr . ). inline . Definition at line 275 of file RNTupleReader.hxx. ◆ GetView() [6/6]. template<typename T > . RNTupleView< T > ROOT::Experimental::RNTupleReader::GetView ; (; std::string_view ; fieldName, . T * ; rawPtr . ). inline . Definition at line 281 of file RNTupleReader.hxx. ◆ InitPageSource(). void ROOT::Experimental::RNTupleReader::InitPageSource ; (; bool ; enableMetrics). private . Definition at line 46 of file RNTupleReader.cxx. ◆ LoadEntry() [1/2]. void ROOT::Experimental::RNTupleReader::LoadEntry ; (; NTupleSize_t ; index). inline . Analogous to Fill(), fills the default entry of the model. ; Returns false at the end of the ntuple. On I/O errors, raises an exception. ; Definition at line 219 of file RNTupleReader.hxx. ◆ LoadEntry() [2/2]. void ROOT::Experimental::RNTupleReader::LoadEntry ; (; NTupleSize_t ; index, . REntry & ; entry . ). inline . Fills a user provided entry after checking that the entry has been instantiated from the ntuple model. ; Definition at line 229 of file RNTupleReader.hxx. ◆ Open() [1/4]. std::unique_ptr< ROOT::Experimental::RNTupleReader > ROOT::Experimental::RNTupleReader::Open ; (; const RNTuple & ; ntuple, . const RNTupleReadOptions & ; options = RNTupleReadOptions() . ). static . Definition at line 102 of file RNTupleReader.cxx. ◆ Open() [2/4]. std::unique_ptr< ROOT::Experimental::RNTupleReader > ROOT::Experimental::RNTupleReader::Open ; (; std::string_view ; ntupleName, . std::string_vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html:13130,Load,LoadEntry,13130,doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,1,['Load'],['LoadEntry']
Performance,"leRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf407_latextablesDefinition rf407_latextables.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; \begin{tabular}{lc}; $\verb+a0+ $ & $ 0.6\pm 0.2$\\; $\verb+a1+ $ & $ 0.2\pm 0.2$\\; $\verb+alpha+ $ & $ -1.00$\\; $\verb+bkgfrac+ $ & $ 0.45\pm 0.03$\\; $\verb+mean+ $ & $ 5$\\; $\verb+sig1frac+ $ & $ 0.71\pm 0.06$\\; $\verb+sigma1+ $ & $ 0.5$\\; $\verb+sigma2+ $ & $ 1$\\; \end{tabular}; \begin{tabular}{lc|lc}; $\verb+a0+ $ & $ 0.6\pm 0.2$ & $\verb+mean+ $ & $ 5$\\; $\verb+a1+ $ & $ 0.2\pm 0.2$ & $\verb+sig1frac+ $ & $ 0.71\pm 0.06$\\; $\verb+alpha+ $ & $ -1.00$ & $\verb+sigma1+ $ & $ 0.5$\\; $\verb+bkgfrac+ $ & $ 0.45\pm 0.03$ & $\verb+sigma2+ $ & $ 1$\\; \end{tabular}; \begin{tabular}{lcc}; $\verb+a0+ $ & $ 0.6\pm 0.2$ & $ 0.5$\\; $\verb+a1+ $ & $ 0.2\pm 0.2$ & $ 0.2$\\; $\verb+alpha+ $ & $ -1.00$ & $-1.00$\\; $\verb+bkgfrac+ $ & $ 0.45\pm 0.03$ & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf407__latextables_8C.html:5560,optimiz,optimization,5560,doc/master/rf407__latextables_8C.html,https://root.cern,https://root.cern/doc/master/rf407__latextables_8C.html,2,['optimiz'],['optimization']
Performance,"leStager; 1 do not hard check the staged status; (example: use fopt = -101 to check the staged status of all the files, or fopt = 110; to re-check the stage status of all the files marked as staged). If 'dbg' is true, some information about the ongoing operations is reguraly; printed; this can be useful when processing very large datasets, an operation; which can take a very long time. The int 'sopt' controls what is done on the selected files (this is effective only; if ropt is 0 or 2 - see below):; -1 no action (fopt = 2 and sopt = -1 touches all staged files); 0 do the full process: open the files and fill the meta-information; in the TFileInfo object, including the end-point URL; 1 only locate the files, by updating the end-point URL (uses TFileStager::Locate; which is must faster of an TFile::Open); 2 issue a stage request on the files. The int 'ropt' controls which actions are performed:; 0 do the full process: get list of files to process and process them; 1 get the list of files to be scanned and return it in flist; 2 process the files in flist (according to sopt); When defined flist is under the responsability the caller. If avgsz > 0 it is used for the final update of the dataset global counters. If 'mss' is defined use it to initialize the stager (instead of the Url in the; TFileInfo objects). If maxfiles > 0, select for processing a maximum of 'filesmax' files (but if fopt is 1 or 2; all files marked as 'staged' are still open or touched). Return code; 1 dataset was not changed; 2 dataset was changed. The number of touched, opened and disappeared files are returned in the respective; variables, if these are defined. Bool_t CheckStagedStatus(TFileInfo* fileInfo, Int_t fopt, Int_t maxfiles, Int_t newstagedfiles, TFileStager* stager, Bool_t createStager, Bool_t dbg, Bool_t& changed, Bool_t& touched, Bool_t& disappeared); Check stage status of the file described by ""fileInfo"".; fopt is same as ""fopt"" in TDataSetManager::ScanDataSet, which is repeated below:; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDataSetManager.html:19847,perform,performed,19847,root/html534/TDataSetManager.html,https://root.cern,https://root.cern/root/html534/TDataSetManager.html,3,['perform'],['performed']
Performance,"leStager; 1 do not hard check the staged status; (example: use fopt = -101 to check the staged status of all the files, or fopt = 110; to re-check the stage status of all the files marked as staged). If 'dbg' is true, some information about the ongoing operations is reguraly; printed; this can be useful when processing very large datasets, an operation; which can take a very long time. The int 'sopt' controls what is done on the selected files (this is effective only; if ropt is 0 or 2 - see below):; -1 no action (fopt = 2 and sopt = -1 touches all staged files); 0 do the full process: open the files and fill the meta-information; in the TFileInfo object, including the end-point URL; 1 only locate the files, by updating the end-point URL (uses TFileStager::Locate; which is must faster of an TFile::Open); 2 issue a stage request on the files. The int 'ropt' controls which actions are performed:; 0 do the full process: get list of files to process and process them; 1 get the list of files to be scanned and return it in flist; 2 process the files in flist (according to sopt); When defined flist is under the responsability the caller. If avgsz > 0 it is used for the final update of the dataset global counters. If 'mss' is defined use it to initialize the stager (instead of the Url in the; TFileInfo objects). If maxfiles > 0, select for processing a maximum of 'filesmax' files (but if fopt is 1 or 2; all files marked as 'staged' are still open or touched). Return code; 1 dataset was not changed; 2 dataset was changed. The number of touched, opened and disappeared files are returned in the respective; variables, if these are defined. Int_t ScanFile(TFileInfo* fileinfo, Bool_t notify); Open the file described by 'fileinfo' to extract the relevant meta-information.; Return 0 if OK, -2 if the file cannot be open, -1 if it is corrupted. Int_t FillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); Navigate the directory 'd' (and its subdirectories) looking for TTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManager.html:19350,perform,performed,19350,root/html528/TDataSetManager.html,https://root.cern,https://root.cern/root/html528/TDataSetManager.html,3,['perform'],['performed']
Performance,"leTypeTFile::kWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMemFile.html:19492,cache,cache,19492,root/html602/TMemFile.html,https://root.cern,https://root.cern/root/html602/TMemFile.html,24,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"le_t *params). void SetParName(Int_t ipar, const char* name); Set name of parameter number ipar. void SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10""); Set up to 11 parameter names. void Streamer(TBuffer& b, const TClass* onfile_class); Stream a class object. void Streamer(TBuffer& ); Stream a class object. void Streamer(TBuffer& b, Int_t version, UInt_t start, UInt_t count, const TClass* onfile_class = 0); specialized streamer function being able to read old TF1 versions as TF1Old in memory. void Convert(UInt_t fromVersion); Convert the fOper of a TFormula version fromVersion to the current in memory version. void MakePrimitive(const char* expr, Int_t pos); MakePrimitive; find TFormulaPrimitive replacement for some operands. void Optimize(); MI include. Optimize formula; 1.) Minimize the number of operands; a.) several operanands are glued togther; b.) some primitive functions glued together - exemp. (x+y) => PlusXY(x,y); c.) maximize number of standard calls minimizing number of jumps in Eval cases; d.) variables, parameters and constants are mapped - using fOperOfssets0; Eval procedure use direct acces to data (only one corresponding case statement in eval procedure). pdata[operand={Var,Par,Const}][offset]; pdata[fOperOffsets0[i]][fOperOffset1[i+1]]; 2.) The fastest evaluation function is chosen at the end; a.) fOptimal := pointer to the fastest function for given evaluation string; switch(GetActionOptimized(0)){; case kData : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive0; break;}; case kUnary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive1; break;}; case kBinary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive2; break;}; case kThree : {fOptimal= (TFormulaPrimitive::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__v5__TFormula.html:31867,Optimiz,Optimize,31867,root/html604/ROOT__v5__TFormula.html,https://root.cern,https://root.cern/root/html604/ROOT__v5__TFormula.html,1,['Optimiz'],['Optimize']
Performance,"le_t fWeightTree weight (see TTree::SetWeight)Definition TTree.h:90; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetListOfBranchesvirtual TObjArray * GetListOfBranches()Definition TTree.h:528; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::LoadTreevirtual Long64_t LoadTree(Long64_t entry)Set current entry.Definition TTree.cxx:6473; TTree::GetAliasvirtual const char * GetAlias(const char *aliasName) constReturns the expanded value of the alias. Search in the friends if any.Definition TTree.cxx:5226; TTree::GetMinimumvirtual Double_t GetMinimum(const char *columname)Return minimum of column with name columname.Definition TTree.cxx:6275; TTree::RemoveFriendvirtual void RemoveFriend(TTree *)Remove a friend from the list of friends.Definition TTree.cxx:7977; TTree::Browsevoid Browse(TBrowser *) overrideBrowse content of the TTree.Definition TTree.cxx:2609; TTree::LoadTreeFriendvirtual Long64_t LoadTreeFriend(Long64_t entry, TTree *T)Load entry on behalf of our master tree, we may use an index.Definition TTree.cxx:6557; TTree::WriteInt_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0) overrideWrite this object to the current directory.Definition TTree.cxx:9753; TTree::fNotifyTObject * fNotifyObject to be notified when loading a Tree.Definition TTree.h:120; TTree::GetListOfClonesvirtual TList * GetListOfClones()Definition TTree.h:527; TTree::fCacheSizeLong64_t fCacheSize! Maximum size of file buffersDefinition TTree.h:105; TTree::fClonesTList * fClones! List of cloned trees which share our addressesDefinition TTree.h:135; TTree::Classstatic TClass * Class(); TTree::kLoadTree@ kLoadTreeDefinition TTree.h:221; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::GetListOfFriendsvirtual TList * GetListOfFriends() constDefinition TTree.h:530; TTree::fReadEntryLong64_t fReadEntry! Number of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:150494,Load,LoadTreeFriendvirtual,150494,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,3,['Load'],"['Load', 'LoadTreeFriend', 'LoadTreeFriendvirtual']"
Performance,"le_t lo, Double_t hi) const; Create a new RooPlot on the heap with a drawing frame initialized for this; object, but no plot contents. Use x.frame() as the first argument to a; y.plotOn(...) method, for example. The caller is responsible for deleting; the returned object. RooPlot * frame(Int_t nbins) const; Create a new RooPlot on the heap with a drawing frame initialized for this; object, but no plot contents. Use x.frame() as the first argument to a; y.plotOn(...) method, for example. The caller is responsible for deleting; the returned object. The current fit range may not be open ended or empty. RooPlot * frame() const; Create a new RooPlot on the heap with a drawing frame initialized for this; object, but no plot contents. Use x.frame() as the first argument to a; y.plotOn(...) method, for example. The caller is responsible for deleting; the returned object. The current fit range may not be open ended or empty. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy cache of another RooAbsArg to our cache. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Structure printing. void randomize(const char* rangeName = 0); Set a new value sampled from a uniform distribution over the fit range.; Prints a warning and does nothing if the fit range is not finite. void setBin(Int_t ibin, const char* rangeName = 0); Set value to center of bin 'ibin' of binning 'rangeName' (or of; default binning if no range is specified). void setBin(Int_t ibin, const RooAbsBinning& binning); Set value to center of bin 'ibin' of binning 'binning'. void randomize(const RooAbsBinning& binning); Set a new value sampled from a uniform distribution over the fit range.; Prints a warning and does nothing if the fit range is not finite. void setBinFast(Int_t ibin, const RooAbsBinning& binning); Set value to center of bin 'ibin' of binning 'rangeName' (or of; default binning if no range is specified). B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsRealLValue.html:40883,cache,cache,40883,root/html532/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html532/RooAbsRealLValue.html,8,['cache'],['cache']
Performance,"le_t xmax = 0.98999999999999999, Double_t ymax = 0.94999999999999996, const RooCmdArg* formatCmd = 0); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsPdf::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; static voidRooAbsPdf::raiseEvalError(); Int_t*RooAbsPdf::randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; virtual Bool_tRooAbsPdf::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidselectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidselectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tRooAbsPdf::syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateCoefficients(RooAddPdf::CacheElem& cache, const RooArgSet* nset) const. Data Members; public:. static RooAbsArg::OperModeR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddPdf.html:39052,Cache,CacheElem,39052,root/html602/RooAddPdf.html,https://root.cern,https://root.cern/root/html602/RooAddPdf.html,4,"['Cache', 'cache']","['CacheElem', 'cache']"
Performance,"le_t* dir, Int_t& iz) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns number of segments on each mesh circle segment. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polycone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Z divisions can be; performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to; volume that was divided. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetRmin(Int_t ipl) const; Returns Rmin for Z segment IPL. Double_t GetRmax(Int_t ipl) const; Returns Rmax for Z segment IPL. Double_t GetZ(Int_t ipl) const; Returns Z for segment IPL. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSegment(const Double_t* point, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPcon.html:15606,perform,performed,15606,root/html534/TGeoPcon.html,https://root.cern,https://root.cern/root/html534/TGeoPcon.html,3,['perform'],['performed']
Performance,"le_t* local, Double_t* master) const; --- point/vector reference frame conversion. {GetCurrentNavigator()->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {GetCurrentNavigator()->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {GetCurrentNavigator()->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {GetCurrentNavigator()->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {GetCurrentNavigator()->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {GetCurrentNavigator()->MasterToLocalBomb(master, local);}. TGeoVolume * GetVolume(const char* name) const; TGeoShape *GetShape(const char *name) const;. Int_t GetNNodes(); {if (!fNNodes) CountNodes(); return fNNodes;}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}. {return GetCurrentNavigator()->GetCache();}. void SetAnimateTracks(Bool_t flag = kTRUE); {fIsGeomReading=flag;}. Int_t PushPath(Int_t startlevel = 0); --- stack manipulation. {return GetCurrentNavigator()->PushPath(startlevel);}. Bool_t PopPath(); {return GetCurrentNavigator()->PopPath();}. Bool_t PopPath(Int_t index); {return GetCurrentNavigator()->PopPath(index);}. Int_t PushPoint(Int_t startlevel = 0); {return GetCurrentNavigator()->PushPoint(startlevel);}. Bool_t PopPoint(); {return GetCurrentNavigator()->PopPoint();}. Bool_t PopPoint(Int_t index); {return GetCurrentNavigator()->PopPoint(index);}. void PopDummy(Int_t ipop = 9999); {return GetCurrentNavigator()->PopDummy(ipop);}. TGeoParallelWorld * GetParallelWorld() const; {return fParallelWorld;}. Bool_t IsParallelWorldNav() const; {return fUsePWNav;}. » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:80945,cache,cache,80945,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,6,['cache'],['cache']
Performance,"le_t* local, Double_t* master) const; --- point/vector reference frame conversion. {GetCurrentNavigator()->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {GetCurrentNavigator()->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {GetCurrentNavigator()->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {GetCurrentNavigator()->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {GetCurrentNavigator()->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {GetCurrentNavigator()->MasterToLocalBomb(master, local);}. TGeoVolume * GetVolume(const char* name) const; TGeoShape *GetShape(const char *name) const;. Int_t GetNNodes(); {if (!fNNodes) CountNodes(); return fNNodes;}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}. {return GetCurrentNavigator()->GetCache();}. void SetAnimateTracks(Bool_t flag = kTRUE); {fIsGeomReading=flag;}. Int_t PushPath(Int_t startlevel = 0); --- stack manipulation. {return GetCurrentNavigator()->PushPath(startlevel);}. Bool_t PopPath(); {return GetCurrentNavigator()->PopPath();}. Bool_t PopPath(Int_t index); {return GetCurrentNavigator()->PopPath(index);}. Int_t PushPoint(Int_t startlevel = 0); {return GetCurrentNavigator()->PushPoint(startlevel);}. Bool_t PopPoint(); {return GetCurrentNavigator()->PopPoint();}. Bool_t PopPoint(Int_t index); {return GetCurrentNavigator()->PopPoint(index);}. void PopDummy(Int_t ipop = 9999); {return GetCurrentNavigator()->PopDummy(ipop);}. » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoManager.h 41744 2011-11-03 10:55:33Z agheata $ » Last generated: 2011-11-03 20:17; This page has been automatically generat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoManager.html:78976,cache,cache,78976,root/html532/TGeoManager.html,https://root.cern,https://root.cern/root/html532/TGeoManager.html,2,['cache'],['cache']
Performance,"le_t* params); virtual const char*ROOT::v5::TFormula::GetParName(Int_t ipar) const; virtual Int_tROOT::v5::TFormula::GetParNumber(const char* name) const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInteger(Bool_t fast = kTRUE) const; virtual Bool_tROOT::v5::TFormula::IsLinear() const; virtual Bool_tROOT::v5::TFormula::IsNormalized() const; Bool_tTObject::IsOnHeap() const; Bool_tIsQuickLoad() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsString() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); voidROOT::v5::TFormula::Optimize(); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidROOT::v5::TFormula::Print(Option_t* option = """") constMENU ; virtual char*PrintValue(Int_t mode = 0) const; virtual char*PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeFormula.html:7258,Optimiz,Optimize,7258,root/html604/TTreeFormula.html,https://root.cern,https://root.cern/root/html604/TTreeFormula.html,1,['Optimiz'],['Optimize']
Performance,"le_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; whe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCacheUnzip.html:16893,optimiz,optimize,16893,root/html534/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html,1,['optimiz'],['optimize']
Performance,"le_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:12833,optimiz,optimize,12833,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,3,['optimiz'],['optimize']
Performance,"lean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; vector<Bool_t>_constChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry!; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealMPFE.html:34709,cache,cache,34709,root/html534/RooRealMPFE.html,https://root.cern,https://root.cern/root/html534/RooRealMPFE.html,3,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"lean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:43080,cache,cache,43080,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,3,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"lean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsMoment.html:34920,cache,cache,34920,root/html602/RooAbsMoment.html,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html,6,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"lean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSyst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:172134,cache,cachepath,172134,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,4,['cache'],"['cachepath', 'cachesize']"
Performance,"leanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TCollection; enum  EStatusBits { kIsOwner = (1ULL << ( 14 )); , kUseRWLock = (1ULL << ( 16 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObjArray; Bool_t BoundsOk (const char *where, Int_t at) const;  ; Int_t GetAbsLast () const;  Return absolute index to last object in array. ;  ; void Init (Int_t s, Int_t lowerBound);  Initialize a TObjArray. ;  ; Bool_t OutOfBoundsError (const char *where, Int_t i) const;  Generate an out-of-bounds error. Always returns false. ;  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TObjArray; TObject ** fCont;  ; Int_t fLast;  ; Int_t fLowerBound;  Array contents. ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <RooAbsArg.h>. Inheritance diagram for RooRefArray:. This browser is not ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRefArray.html:18538,perform,perform,18538,doc/master/classRooRefArray.html,https://root.cern,https://root.cern/doc/master/classRooRefArray.html,1,['perform'],['perform']
Performance,"leanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TCollection; enum  EStatusBits { kIsOwner = (1ULL << ( 14 )); , kUseRWLock = (1ULL << ( 16 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObjArray; Bool_t BoundsOk (const char *where, Int_t at) const;  ; Int_t GetAbsLast () const;  Return absolute index to last object in array. ;  ; void Init (Int_t s, Int_t lowerBound);  Initialize a TObjArray. ;  ; Bool_t OutOfBoundsError (const char *where, Int_t i) const;  Generate an out-of-bounds error. Always returns false. ;  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TObjArray; TObject ** fCont;  ; Int_t fLast;  ; Int_t fLowerBound;  Array contents. ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <TGeoNavigator.h>. Inheritance diagram for TGeoNavigatorArray:. This brow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigatorArray.html:19024,perform,perform,19024,doc/master/classTGeoNavigatorArray.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigatorArray.html,1,['perform'],['perform']
Performance,"leanup in this composite frame and all child composite frames (hierarchical); Attention! Hierarchical cleaning is dangerous and must be used with caution. There are many GUI components (in ROOT and in user code) which do not use Clean method in destructor (""custom deallocation""). Adding such component to GUI container which is using hierarchical cleaning will produce seg. violation when container is deleted. The reason is double deletion: first when Clean method is invoked, then at ""custom deallocation"". We are going to correct all ROOT code to make it to be consistent with hierarchical cleaning scheme. ; Reimplemented from TGFrame.; Definition at line 1072 of file TGFrame.cxx. ◆ SetEditable(). void TGCompositeFrame::SetEditable ; (; Bool_t ; on = kTRUE). overridevirtual . Switch ON/OFF edit mode. ; If edit mode is ON it is possible:. embed other ROOT GUI application (a la ActiveX). For example: TGMainFrame *m = new TGMainFrame(gClient->GetRoot(), 500, 500); m->SetEditable(); gSystem->Load(""$ROOTSYS/test/Aclock""); // load Aclock demo Aclock a; gROOT->Macro(""$ROOTSYS/tutorials/gui/guitest.C""); m->SetEditable(0); m->MapWindow(); ; Reimplemented from TGWindow.; Reimplemented in TRootContainer, and TRootEmbeddedContainer.; Definition at line 948 of file TGFrame.cxx. ◆ SetEditDisabled(). void TGCompositeFrame::SetEditDisabled ; (; UInt_t ; on = 1). overridevirtual . Set edit disable flag for this frame and subframes. . if (on & kEditDisable) - disable edit for this frame and all subframes. . Reimplemented from TGWindow.; Definition at line 1022 of file TGFrame.cxx. ◆ SetLayoutBroken(). void TGCompositeFrame::SetLayoutBroken ; (; Bool_t ; on = kTRUE). overridevirtual . Set broken layout. No Layout method is called. ; Reimplemented from TGFrame.; Definition at line 1012 of file TGFrame.cxx. ◆ SetLayoutManager(). void TGCompositeFrame::SetLayoutManager ; (; TGLayoutManager * ; l). virtual . Set the layout manager for the composite frame. ; The layout manager is adopted by t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCompositeFrame.html:46081,Load,Load,46081,doc/master/classTGCompositeFrame.html,https://root.cern,https://root.cern/doc/master/classTGCompositeFrame.html,2,"['Load', 'load']","['Load', 'load']"
Performance,"learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:3527,cache,cache,3527,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,"lect = true;  ; bool _restartNumIntEngine = false;  ! ;  ; RooArgSet _saveInt;  ! ;  ; RooArgSet _saveSum;  ! ;  ; RooListProxy _sumCat;  ! ;  ; RooSetProxy _sumList;  Set of discrete observable over which is summed numerically. ;  ; bool _valid = false;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:59088,Cache,Cache,59088,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['Cache'],['Cache']
Performance,"lect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 253 of file RooMappedCategory.cxx. ◆ printMultiline(). void RooMappedCategory::printMultiline ; (; std::ostream & ; os, . Int_t ; contents, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Print info about this object to the specified stream. ; In addition to the info from RooAbsArg::printStream() we add: Shape : label, index, defined types . Reimplemented from RooAbsCategory.; Definition at line 166 of file RooMappedCategory.cxx. ◆ readFromStream(). bool RooMappedCategory::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Read object contents from stream (dummy for now) ; Reimplemented from RooAbsCategory.; Definition at line 192 of file RooMappedCategory.cxx. ◆ recomputeShape(). void RooMappedCategory::recomputeShape ; (; ). overrideprotectedvirtual . When the input category changes states, the cached state mappings are invalidated. ; Implements RooAbsCategory.; Definition at line 311 of file RooMappedCategory.cxx. ◆ setDefCat(). void RooMappedCategory::setDefCat ; (; value_type ; defCat). inlineprivate . Definition at line 89 of file RooMappedCategory.h. ◆ Streamer(). void RooMappedCategory::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsCategory. ◆ StreamerNVirtual(). void RooMappedCategory::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 91 of file RooMappedCategory.h. ◆ writeToStream(). void RooMappedCategory::writeToStream ; (; std::ostream & ; os, . bool ; compact . ); const. overridevirtual . Write object contents to ostream. ; Reimplemented from RooAbsCategory.; Definition at line 280 of file RooMappedCategory.cxx. Friends And Related Symbol Documentation. ◆ RooMappedCategoryCache. friend class RooMappedCategoryCache. friend . Definition at line 86 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:48914,cache,cached,48914,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,1,['cache'],['cached']
Performance,"lectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumRunningInt.html:34236,cache,cache,34236,root/html530/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html530/RooNumRunningInt.html,1,['cache'],['cache']
Performance,"lected input is incomplete.; 154 virtual Int_t GetMore() const = 0;; 155 virtual TClass *GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent = kFALSE) = 0;; 156 virtual TClass *GenerateTClass(ClassInfo_t *classinfo, Bool_t silent = kFALSE) = 0;; 157 virtual Int_t GenerateDictionary(const char *classes, const char *includes = nullptr, const char *options = nullptr) = 0;; 158 virtual char *GetPrompt() = 0;; 159 virtual const char *GetSharedLibs() = 0;; 160 virtual const char *GetClassSharedLibs(const char *cls, bool skipCore = true) = 0;; 161 virtual const char *GetSharedLibDeps(const char *lib, bool tryDyld = false) = 0;; 162 virtual const char *GetIncludePath() = 0;; 163 virtual const char *GetSTLIncludePath() const { return """"; }; 164 virtual TObjArray *GetRootMapFiles() const = 0;; 165 virtual void Initialize() = 0;; 166 virtual void ShutDown() = 0;; 167 virtual void InspectMembers(TMemberInspector&, const void* obj, const TClass* cl, Bool_t isTransient) = 0;; 168 virtual Bool_t IsLoaded(const char *filename) const = 0;; 169 virtual Bool_t IsLibraryLoaded(const char *libname) const = 0;; 170 virtual Bool_t HasPCMForLibrary(const char *libname) const = 0;; 171 virtual Int_t Load(const char *filenam, Bool_t system = kFALSE) = 0;; 172 virtual void LoadMacro(const char *filename, EErrorCode *error = nullptr) = 0;; 173 virtual Int_t LoadLibraryMap(const char *rootmapfile = nullptr) = 0;; 174 virtual Int_t RescanLibraryMap() = 0;; 175 virtual Int_t ReloadAllSharedLibraryMaps() = 0;; 176 virtual Int_t UnloadAllSharedLibraryMaps() = 0;; 177 virtual Int_t UnloadLibraryMap(const char *library) = 0;; 178 virtual Longptr_t ProcessLine(const char *line, EErrorCode *error = nullptr) = 0;; 179 virtual Longptr_t ProcessLineSynch(const char *line, EErrorCode *error = nullptr) = 0;; 180 virtual void PrintIntro() = 0;; 181 virtual bool RegisterPrebuiltModulePath(const std::string& FullPath,; 182 const std::string& ModuleMapName = ""module.modulemap"") const = 0;; 183",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TInterpreter_8h_source.html:6291,Load,Load,6291,doc/master/TInterpreter_8h_source.html,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html,3,['Load'],"['Load', 'LoadLibraryMap', 'LoadMacro']"
Performance,"lecting all available ones. ; Can construct and insert new TFunction-s. ; Definition at line 233 of file TListOfFunctionTemplates.cxx. ◆ GetListForObject() [2/2]. TList * TListOfFunctionTemplates::GetListForObject ; (; const TObject * ; obj); const. virtual . Return the set of overloads for function obj, collecting all available ones. ; Can construct and insert new TFunction-s. ; Definition at line 242 of file TListOfFunctionTemplates.cxx. ◆ GetListForObjectNonConst(). TList * TListOfFunctionTemplates::GetListForObjectNonConst ; (; const char * ; name). private . Return the set of overloads for this name, collecting all available ones. ; Can construct and insert new TFunction-s. ; Definition at line 194 of file TListOfFunctionTemplates.cxx. ◆ IsA(). TClass * TListOfFunctionTemplates::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from THashList.; Definition at line 87 of file TListOfFunctionTemplates.h. ◆ Load(). void TListOfFunctionTemplates::Load ; (; ). Load all the functions known to the interpreter for the scope 'fClass' into this collection. ; Definition at line 356 of file TListOfFunctionTemplates.cxx. ◆ MapObject(). void TListOfFunctionTemplates::MapObject ; (; TObject * ; obj). private . Add pair<id, object> to the map of functions and their ids. ; Definition at line 53 of file TListOfFunctionTemplates.cxx. ◆ operator=(). TListOfFunctionTemplates & TListOfFunctionTemplates::operator= ; (; const TListOfFunctionTemplates & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfFunctionTemplates::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctionTemplates.html:29843,Load,Load,29843,doc/master/classTListOfFunctionTemplates.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctionTemplates.html,1,['Load'],['Load']
Performance,"lection of TTrees, which can be located also in different files. . Files; file  InternalTreeUtils.hxx;  ; file  RFriendInfo.hxx;  . Namespaces; namespace  ROOT::Internal::TreeUtils;  Namespace hosting functions and classes to retrieve tree information for internal use. ;  . Classes; struct  ROOT::TreeUtils::RFriendInfo;  Information about friend trees of a certain TTree or TChain object. More...;  ; class  TBasket;  Manages buffers for branches of a Tree. More...;  ; class  TBasketSQL;  Implement TBasket for a SQL backend. More...;  ; class  TBranch;  A TTree is a list of TBranches. More...;  ; class  TBranchClones;  A Branch for the case of an array of clone objects. More...;  ; class  TBranchElement;  A Branch for the case of an object. More...;  ; class  TBranchObject;  A Branch for the case of an object. More...;  ; class  TBranchRef;  A branch containing and managing a TRefTable for TRef autoloading. More...;  ; class  TBranchSTL;  A Branch handling STL collection of pointers (vectors, lists, queues, sets and multisets) while storing them in split mode. More...;  ; class  TBufferSQL;  Implement TBuffer for a SQL backend. More...;  ; class  TChain;  A chain is a collection of files containing TTree objects. More...;  ; class  TChainElement;  A TChainElement describes a component of a TChain. More...;  ; class  TCollectionMethodBrowsable;  TCollectionMethodBrowsable extends TCollectionPropertyBrowsable by showing all methods of the collection itself. More...;  ; class  TCollectionPropertyBrowsable;  A tiny browser helper object (and its generator) for adding a virtual (as in ""not actually part of the class"", not in C++ virtual) ""@size()"" method to a collection. More...;  ; class  TCut;  A specialized string object used for TTree selections. More...;  ; class  TEntryList;  A List of entry numbers in a TTree or TChain. More...;  ; class  TEntryListArray;  A list of entries and subentries in a TTree or TChain. More...;  ; class  TEntryListBlock;  Used by TEntryList ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tree.html:1856,queue,queues,1856,doc/master/group__tree.html,https://root.cern,https://root.cern/doc/master/group__tree.html,1,['queue'],['queues']
Performance,"lection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TQCommand*fCurrentthe latest executed command; TObjLink*fCursorcurrent position in history stack; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; UInt_tfLimitmaximum number of commands can be located in stack; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*fLogBooklisting of all actions during execution; Bool_tfLoggingkTRUE if logging is ON; Int_tTQCommand::fNRargsnumber of redo arguments; Int_tTQCommand::fNUargsnumber of undo arguments; TStringTQCommand::fNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tTQCommand::fNewDeletekTRUE if Redo/Undo methods are new/delete; void*TQCommand::fObjectobject to which undo/redo actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:17667,cache,cache,17667,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,2,['cache'],['cache']
Performance,lectionProxy; static TObject::EStatusBitsTObject::kMustCleanup; static TTree::ESetBranchAddressStatuskNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatuskVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*fAliasesList of aliases for expressions based on the tree branches.; Long64_tfAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tfAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*fBranchRefBranch supporting the TRefTable (if any); TObjArrayfBranchesList of Branches; Bool_tfCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tfCacheSize! Maximum size of file buffers; Bool_tfCacheUserSet! true if the cache setting was explicitly given by user; Long64_tfChainOffset! Offset of 1st entry of this Tree in a TChain; TList*fClones! List of cloned trees which share our addresses; Long64_t*fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfDebug! Debug level; Long64_tfDebugMax! Last entry number to debug; Long64_tfDebugMin! First entry number to debug; Int_tfDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesNumber of entries; TEntryList*fEntryList! Pointer to event selection list (if one); Long64_tfEstimateNumber of entries to estimate histogram limits; TEventList*fEventList! Pointer to event selection list (if one); Int_tfFileNumber! current file number (if f,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:32925,cache,cache,32925,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,2,['cache'],['cache']
Performance,"lector.h. ◆ GetOutputList(). virtual TList * TSelector::GetOutputList ; (; ); const. inlinevirtual . Reimplemented in TSelEvent, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TSelHist, RooProofDriverSelector, TSelectorEntries, h1analysis, and h1analysisTreeReader.; Definition at line 69 of file TSelector.h. ◆ GetSelector(). TSelector * TSelector::GetSelector ; (; const char * ; filename). static . The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector. ; If filename is of the form file.C, the file will be interpreted. If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded. The corresponding binary file and shared library will be deleted at the end of the function. If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded.; The static function returns a pointer to a TSelector object ; Definition at line 142 of file TSelector.cxx. ◆ GetStatus(). virtual Long64_t TSelector::GetStatus ; (; ); const. inlinevirtual . Definition at line 58 of file TSelector.h. ◆ ImportOutput(). void TSelector::ImportOutput ; (; TList * ; output). virtual . Imports the content of 'output' in the internal output list. ; Existing content in the output list is discarded (unless found also in 'output'). In particular, if 'output' is nullptr or empty, reset the internal list. On return, the content of 'output' is cleared to avoid double deletion issues. (The caller is responsible of 'output' as container: its content is transferred under the selector ownership). ; Definition at line 270 of file TSelector.cxx. ◆ Init(). virtual void TSelector::Init ; (; TTree * ; ). inlinevirtual . Reimplemented in TSelVerifyDataSet, TSelHandleDataSet, TProofDraw, TProofDrawHist, TProofDrawEventList, TProofDrawEntryList, TProofDrawProfile, TPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:18475,load,loaded,18475,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['load'],['loaded']
Performance,"led from SetEntryBase; 171 kExternalLoadTree, ///< User code called LoadTree directly.; 172 kMissingBranchFromTree ///< Missing expected branch when loading new tree; 173 };; 174 ; 175 static constexpr const char *const fgEntryStatusText[kEntryUnknownError + 1] = {; 176 ""valid entry"",; 177 ""the tree does not exist"",; 178 ""the tree entry number does not exist"",; 179 ""cannot access chain element"",; 180 ""problem in opening a chain's file"",; 181 ""problem reading dictionary info from tree"",; 182 ""last entry loop has reached its end"",; 183 ""one of the readers was not successfully initialized"",; 184 ""A friend with TTreeIndex doesn't have an entry for this index"",; 185 ""A branch was not found when switching to the next TTree in the chain"",; 186 ""LoadTree return less than -6, likely a 'newer' error code""};; 187 ; 188 TTreeReader();; 189 ; 190 TTreeReader(TTree *tree, TEntryList *entryList = nullptr, bool warnAboutLongerFriends = true,; 191 const std::vector<std::string> &suppressErrorsForMissingBranches = {});; 192 TTreeReader(const char* keyname, TDirectory* dir, TEntryList* entryList = nullptr);; 193 TTreeReader(const char *keyname, TEntryList *entryList = nullptr) : TTreeReader(keyname, nullptr, entryList) {}; 194 ; 195 ~TTreeReader() override;; 196 ; 197 void SetTree(TTree* tree, TEntryList* entryList = nullptr);; 198 void SetTree(const char* keyname, TEntryList* entryList = nullptr) {; 199 SetTree(keyname, nullptr, entryList);; 200 }; 201 void SetTree(const char* keyname, TDirectory* dir, TEntryList* entryList = nullptr);; 202 ; 203 bool IsChain() const { return TestBit(kBitIsChain); }; 204 ; 205 bool IsInvalid() const { return fLoadTreeStatus == kNoTree; }; 206 ; 207 TTree* GetTree() const { return fTree; }; 208 TEntryList* GetEntryList() const { return fEntryList; }; 209 ; 210 ///\{ \name Entry setters; 211 ; 212 /// Move to the next entry (or index of the TEntryList if that is set).; 213 ///; 214 /// \return false if the previous entry was already the last entry. Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:6335,load,loading,6335,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,2,"['Load', 'load']","['LoadTree', 'loading']"
Performance,"led name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cranmer. void graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Write the GraphViz representation of the expression tree headed by; this RooAbsArg object to the given ostream. Based on concept developed by Kyle Cranmer. void graphVizAddConn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:33583,cache,cache,33583,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,3,['cache'],['cache']
Performance,"led name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter, bool useTitle, bool useLatex); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cranmer. void graphVizTree(ostream& os, const char* delimiter, bool useTitle, bool useLatex); Write the GraphViz representation of the expression tree headed by; this RooAbsArg object to the given ostream. Based on concept developed by Kyle Cranmer. void graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >& lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:33330,cache,cache,33330,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,1,['cache'],['cache']
Performance,"led, see below), filename must contain a valid class implementation derived from TSelector, where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts, a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the slave servers.; Process(): called for each event, in this function you decide what to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF called only on the slave servers.; Terminate(): called at the end of the loop on the tree, a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted. If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded. NOTE 1; It may be more interesting to invoke directly the other Process function accepting a TSelector* as argument.eg MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; TSelector::Processvirtual bool Process(Long64_t)The Process() function is ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:40571,load,loaded,40571,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['load'],['loaded']
Performance,"left,right""); expo.plotOn(plotFrameWithNormRange, LineColor=""r"", Range=""full"", NormRange=""left,right"", LineStyle=10); ; plotFrameWithNormRange.Draw(); ; canvas.Draw(); ; canvas.SaveAs(""rf212_plottingInRanges_blinding.png""); [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'full' created with bounds [1,30]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'left' created with bounds [1,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'right' created with bounds [20,30]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_expo_expoData_left' created with bounds [1,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_expo_expoData_right' created with bounds [20,30]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(expo_over_expo_Int[x|left,right]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_expo_over_expo_Int[x|left,right]_expoData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'full', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'left', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'right', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'left'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) p.d.f. curve is normalized using explicit choice of ranges 'left,right'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'right'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) p.d.f. curve is normalize",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html:5227,optimiz,optimization,5227,doc/master/rf212__plottingInRanges__blinding_8py.html,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html,2,['optimiz'],['optimization']
Performance,"leg2.AddEntry(0, """", """"); leg2.AddEntry(""morph_dh_cHq3=0.25"", ""c_{Hq^{(3)}}=0.25"", ""L""); leg2.AddEntry(0, """", """"); leg2.AddEntry(""morph_dh_cHq3=0.5"", ""c_{Hq^{(3)}}=0.5"", ""L""); leg2.AddEntry(0, """", """"); leg2.Draw(); ; c1.cd(3); ROOT.gPad.SetLeftMargin(0.12); ROOT.gPad.SetRightMargin(0.18); ROOT.gStyle.SetNumberContours(255); ROOT.gStyle.SetPalette(ROOT.kGreyScale); ROOT.gStyle.SetOptStat(0); ROOT.TColor.InvertPalette(); ROOT.gPad.SetLogz(); hh_data.GetYaxis().SetTitle(""c_{Hq^{(3)}}""); hh_data.GetYaxis().SetRangeUser(0, 0.5); hh_data.GetZaxis().SetTitleOffset(1.8); hh_data.Draw(""COLZ""); c1.SaveAs(""rf711_lagrangianmorph.png""); [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x97df860; [#0] PROGRESS:Caching -- current storage has size 3; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(morph_dh_cHq3=0.01): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#1] INFO:InputArguments -- RooAbsData::plotOn(dh_SM_NPsq0) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:InputArguments -- RooAbsData::plotOn(dh_cHq3_NPsq1) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 24931.9 will supersede previous event count of 10852.3 for normalization of PDF projections; [#1] INFO:InputArguments -- RooAbsData::plotOn(dh_cHq3_NPsq2) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 29789.2 will supersede previous event count ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html:6245,cache,cache,6245,doc/master/rf711__lagrangianmorph_8py.html,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html,1,['cache'],['cache']
Performance,"lem*getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); virtual TStringhistNameSuffix() const; Bool_tRooAbsArg::inhibitDirty() const; virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:37096,optimiz,optimizeDirtyHook,37096,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"lement (const char *name, const char *title, Int_t offset, Int_t dtype, const char *typeName);  Create a TStreamerElement object. ;  ; virtual ~TStreamerElement ();  TStreamerElement dtor. ;  ; virtual Bool_t CannotSplit () const;  Returns true if the element cannot be split, false otherwise. ;  ; Int_t GetArrayDim () const;  ; Int_t GetArrayLength () const;  ; TClass * GetClass () const;  ; virtual TClass * GetClassPointer () const;  Returns a pointer to the TClass of this element. ;  ; virtual Int_t GetExecID () const;  Returns the TExec id for the EXEC instruction in the comment field of a TRef data member. ;  ; Double_t GetFactor () const;  ; virtual const char * GetFullName () const;  Return element name including dimensions, if any Note that this function stores the name into a static array. ;  ; virtual const char * GetInclude () const;  ; Int_t GetMaxIndex (Int_t i) const;  ; virtual ULongptr_t GetMethod () const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; virtual Int_t GetSize () const;  Returns size of this element in bytes. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual void Init (TVirtualStreamerInfo *obj=nullptr);  Initliaze the element. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldForm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerArtificial.html:2188,cache,cached,2188,doc/master/classTStreamerArtificial.html,https://root.cern,https://root.cern/doc/master/classTStreamerArtificial.html,2,['cache'],['cached']
Performance,"lement list is up to date; 824 if (!TestBit(kProofUptodate)); 825 SetProof(true, true);; 826 fProofChain->SetEventList(fEventList);; 827 fProofChain->SetEntryList(fEntryList);; 828 return fProofChain->Draw(varexp, selection, option, nentries, firstentry);; 829 }; 830 ; 831 return TChain::Draw(varexp, selection.GetTitle(), option, nentries, firstentry);; 832}; 833 ; 834////////////////////////////////////////////////////////////////////////////////; 835/// Process all entries in this chain and draw histogram corresponding to; 836/// expression varexp.; 837/// Returns -1 in case of error or number of selected events in case of success.; 838 ; 839Long64_t TChain::Draw(const char* varexp, const char* selection,; 840 Option_t* option,Long64_t nentries, Long64_t firstentry); 841{; 842 if (fProofChain) {; 843 // Make sure the element list is up to date; 844 if (!TestBit(kProofUptodate)); 845 SetProof(true, true);; 846 fProofChain->SetEventList(fEventList);; 847 fProofChain->SetEntryList(fEntryList);; 848 return fProofChain->Draw(varexp, selection, option, nentries, firstentry);; 849 }; 850 GetPlayer();; 851 if (LoadTree(firstentry) < 0) return 0;; 852 return TTree::Draw(varexp,selection,option,nentries,firstentry);; 853}; 854 ; 855////////////////////////////////////////////////////////////////////////////////; 856/// See TTree::GetReadEntry().; 857 ; 858TBranch* TChain::FindBranch(const char* branchname); 859{; 860 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 861 // Make sure the element list is up to date; 862 if (!TestBit(kProofUptodate)); 863 SetProof(true, true);; 864 return fProofChain->FindBranch(branchname);; 865 }; 866 if (fTree) {; 867 return fTree->FindBranch(branchname);; 868 }; 869 LoadTree(0);; 870 if (fTree) {; 871 return fTree->FindBranch(branchname);; 872 }; 873 return nullptr;; 874}; 875 ; 876////////////////////////////////////////////////////////////////////////////////; 877/// See TTree::GetReadEntry().; 878 ; 879TLeaf* TChain::FindLeaf(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:32712,Load,LoadTree,32712,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"lement__SetTree(this,fFriends);; 9568 ; 9569 if (fTreeIndex) {; 9570 fTreeIndex->SetTree(this);; 9571 }; 9572 if (fIndex.fN) {; 9573 Warning(""Streamer"", ""Old style index in this tree is deleted. Rebuild the index via TTree::BuildIndex"");; 9574 fIndex.Set(0);; 9575 fIndexValues.Set(0);; 9576 }; 9577 if (fEstimate <= 10000) {; 9578 fEstimate = 1000000;; 9579 }; 9580 ; 9581 if (fNClusterRange) {; 9582 // The I/O allocated just enough memory to hold the; 9583 // current set of ranges.; 9584 fMaxClusterRange = fNClusterRange;; 9585 }; 9586 ; 9587 // Throughs calls to `GetCacheAutoSize` or `EnableCache` (for example; 9588 // by TTreePlayer::Process, the cache size will be automatically; 9589 // determined unless the user explicitly call `SetCacheSize`; 9590 fCacheSize = 0;; 9591 fCacheUserSet = false;; 9592 ; 9593 ResetBit(kMustCleanup);; 9594 return;; 9595 }; 9596 //====process old versions before automatic schema evolution; 9597 Stat_t djunk;; 9598 Int_t ijunk;; 9599 TNamed::Streamer(b);; 9600 TAttLine::Streamer(b);; 9601 TAttFill::Streamer(b);; 9602 TAttMarker::Streamer(b);; 9603 b >> fScanField;; 9604 b >> ijunk; fMaxEntryLoop = (Long64_t)ijunk;; 9605 b >> ijunk; fMaxVirtualSize = (Long64_t)ijunk;; 9606 b >> djunk; fEntries = (Long64_t)djunk;; 9607 b >> djunk; fTotBytes = (Long64_t)djunk;; 9608 b >> djunk; fZipBytes = (Long64_t)djunk;; 9609 b >> ijunk; fAutoSave = (Long64_t)ijunk;; 9610 b >> ijunk; fEstimate = (Long64_t)ijunk;; 9611 if (fEstimate <= 10000) fEstimate = 1000000;; 9612 fBranches.Streamer(b);; 9613 if (fBranchRef) fBranchRef->SetTree(this);; 9614 TBranch__SetTree(this,fBranches);; 9615 fLeaves.Streamer(b);; 9616 fSavedBytes = fTotBytes;; 9617 if (R__v > 1) fIndexValues.Streamer(b);; 9618 if (R__v > 2) fIndex.Streamer(b);; 9619 if (R__v > 3) {; 9620 TList OldInfoList;; 9621 OldInfoList.Streamer(b);; 9622 OldInfoList.Delete();; 9623 }; 9624 fNClusterRange = 0;; 9625 fDefaultEntryOffsetLen = 1000;; 9626 ResetBit(kMustCleanup);; 9627 b.CheckByteCount(R__s, R__",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:368196,cache,cache,368196,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"lementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 91 of file RooProofDriverSelector.cxx. ◆ Process(). bool RooProofDriverSelector::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector.; Definition at line 66 of file RooProofDriverSelector.cxx. ◆ SetInputList(). void RooProofDriverSelector::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 35 of file RooProofDriverSelector.h. ◆ SetObject(). void RooProofDrive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProofDriverSelector.html:15774,load,loaded,15774,doc/master/classRooProofDriverSelector.html,https://root.cern,https://root.cern/doc/master/classRooProofDriverSelector.html,1,['load'],['loaded']
Performance,"lemented from RooAbsReal.; Definition at line 92 of file RooBernstein.cxx. ◆ evaluate(). double RooBernstein::evaluate ; (; ); const. overrideprivatevirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 78 of file RooBernstein.cxx. ◆ fillBuffer(). void RooBernstein::fillBuffer ; (; ); const. private . Definition at line 68 of file RooBernstein.cxx. ◆ getAnalyticalIntegral(). Int_t RooBernstein::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 98 of file RooBernstein.cxx. ◆ IsA(). TClass * RooBernstein::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 53 of file RooBernstein.h. ◆ selectNormalizationRange(). void RooBernstein::selectNormalizationRange ; (; const char * ; rangeName = nullptr, . bool ; force = false . ). overridevirtual . Force use of a given normalisation range. ; Needed for functions or PDFs (e.g. RooAddPdf) whose shape depends on the choice of normalisation. ; Reimplemented from RooAbsReal.; Definition at line 61 of file RooBernstein.cxx. ◆ Streamer(). void RooBernstein::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooBernstein::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 53 of file RooBernstein.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBernstein.html:78104,perform,performed,78104,doc/master/classRooBernstein.html,https://root.cern,https://root.cern/doc/master/classRooBernstein.html,1,['perform'],['performed']
Performance,"lemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:50219,cache,cache,50219,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['cache'],['cache']
Performance,"lemented from TFileCacheRead.; Definition at line 2128 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2145 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2160 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2170 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2187 of file TTreeCache.cxx. ◆ S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:50289,cache,cache,50289,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cache']
Performance,"lemented in ROOT::RWebWindowWSHandler.; Definition at line 56 of file THttpWSHandler.h. ◆ ProcessWS(). virtual Bool_t THttpWSHandler::ProcessWS ; (; THttpCallArg * ; arg). pure virtual . Implemented in ROOT::RWebWindowWSHandler. ◆ RemoveEngine(). void THttpWSHandler::RemoveEngine ; (; std::shared_ptr< THttpWSEngine > & ; engine, . Bool_t ; terminate = kFALSE . ). private . Remove and destroy WS connection. ; Definition at line 157 of file THttpWSHandler.cxx. ◆ RunSendingThrd(). Int_t THttpWSHandler::RunSendingThrd ; (; std::shared_ptr< THttpWSEngine > ; engine). private . Send data stored in the buffer. ; Returns:. 0 - when operation was executed immediately; 1 - when send operation will be performed in different thread . Definition at line 268 of file THttpWSHandler.cxx. ◆ SendCharStarWS(). Int_t THttpWSHandler::SendCharStarWS ; (; UInt_t ; wsid, . const char * ; str . ). Send string via given websocket id. ; Returns:. -1 - in case of error,; 0 - when operation was executed immediately,; 1 - when send operation will be performed in different thread, . Definition at line 476 of file THttpWSHandler.cxx. ◆ SendHeaderWS(). Int_t THttpWSHandler::SendHeaderWS ; (; UInt_t ; wsid, . const char * ; hdr, . const void * ; buf, . int ; len . ). Send binary data with text header via given websocket id. ; Returns:. -1 - in case of error,; 0 - when operation was executed immediately,; 1 - when send operation will be performed in different thread, . Definition at line 431 of file THttpWSHandler.cxx. ◆ SendWS(). Int_t THttpWSHandler::SendWS ; (; UInt_t ; wsid, . const void * ; buf, . int ; len . ). Send binary data via given websocket id. ; Returns:. -1 - in case of error; 0 - when operation was executed immediately; 1 - when send operation will be performed in different thread . Definition at line 386 of file THttpWSHandler.cxx. ◆ SetDisabled(). void THttpWSHandler::SetDisabled ; (; ). inline . Disable all processing of websockets, normally called shortly before destructor. ; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpWSHandler.html:23502,perform,performed,23502,doc/master/classTHttpWSHandler.html,https://root.cern,https://root.cern/doc/master/classTHttpWSHandler.html,1,['perform'],['performed']
Performance,"lements (TEveElement *el=nullptr);  Propagate visualization parameters from element el (defaulting to this) to all elements (children). ;  ; virtual void PropagateVizParamsToProjecteds ();  Propagate visualization parameters to dependent elements. ;  ; virtual TEveTrans * PtrMainTrans (Bool_t create=kTRUE);  Return pointer to main transformation. ;  ; void RecheckImpliedSelections ();  Call this if it is possible that implied-selection or highlight has changed for this element or for implied-selection this element is member of and you want to maintain consistent selection state. ;  ; const List_t & RefChildren () const;  ; virtual TEveTrans & RefMainTrans ();  Return reference to main transformation. ;  ; virtual void RemoveElement (TEveElement *el);  Remove el from the list of children. ;  ; virtual void RemoveElementLocal (TEveElement *el);  Perform additional local removal of el. ;  ; virtual void RemoveElements ();  Remove all elements. ;  ; virtual void RemoveElementsLocal ();  Perform additional local removal of all elements. ;  ; virtual Bool_t RemoveFromListTree (TGListTree *ltree, TGListTreeItem *parent_lti);  Remove element from list-tree 'ltree' where its parent item is 'parent_lti'. ;  ; virtual Int_t RemoveFromListTrees (TEveElement *parent);  Remove element from all list-trees where 'parent' is the user-data of the parent list-tree-item. ;  ; virtual void RemoveParent (TEveElement *re);  Remove re from the list of parents. ;  ; void ResetAllCSCBits ();  ; void ResetCSCBits (UChar_t f);  ; void SaveVizParams (std::ostream &out, const TString &tag, const TString &var);  Save visualization parameters for this element with given tag. ;  ; virtual void SelectElement (Bool_t state);  Set element's selection state. Stamp appropriately. ;  ; void SetCompound (TEveCompound *c);  ; void SetCSCBits (UChar_t f);  ; void SetDestroyOnZeroRefCnt (Bool_t d);  Sets the state of flag determining if the element will be destroyed when reference count reaches zero. ;  ; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveArrow.html:13191,Perform,Perform,13191,doc/master/classTEveArrow.html,https://root.cern,https://root.cern/doc/master/classTEveArrow.html,51,['Perform'],['Perform']
Performance,"lements RooAbsReal.; Definition at line 59 of file RooLandau.cxx. ◆ generateEvent(). void RooLandau::generateEvent ; (; Int_t ; code). overridevirtual . Interface for generation of an event using the algorithm corresponding to the specified code. ; The meaning of each code is defined by the getGenerator() implementation. The default implementation does nothing. ; Reimplemented from RooAbsPdf.; Definition at line 118 of file RooLandau.cxx. ◆ getAnalyticalIntegral(). Int_t RooLandau::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 86 of file RooLandau.cxx. ◆ getGenerator(). Int_t RooLandau::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ; A code of zero indicates that we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented from RooAbsPdf.; Definition at line 81 of file RooLandau.cxx. ◆ IsA(). TClass * RooLandau::IsA ; (; ); const. inlineoverridevirtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLandau.html:77518,perform,performed,77518,doc/master/classRooLandau.html,https://root.cern,https://root.cern/doc/master/classRooLandau.html,1,['perform'],['performed']
Performance,"lements TBuffer.; Definition at line 3171 of file TBufferXML.cxx. ◆ GetIOVersion(). Int_t TBufferXML::GetIOVersion ; (; ); const. inline . Definition at line 65 of file TBufferXML.h. ◆ IncrementLevel(). void TBufferXML::IncrementLevel ; (; TVirtualStreamerInfo * ; info). finalvirtual . Function is called from TStreamerInfo WriteBuffer and ReadBuffer functions and indent new level in xml structure. ; This call indicates, that TStreamerInfo functions starts streaming object data of correspondent class ; Implements TBuffer.; Definition at line 855 of file TBufferXML.cxx. ◆ IsA(). TClass * TBufferXML::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TBufferText.; Definition at line 332 of file TBufferXML.h. ◆ PerformPostProcessing(). void TBufferXML::PerformPostProcessing ; (; ). protected . Function is converts TObject and TString structures to more compact representation. ; Definition at line 1203 of file TBufferXML.cxx. ◆ PerformPreProcessing(). void TBufferXML::PerformPreProcessing ; (; const TStreamerElement * ; elem, . XMLNodePointer_t ; elemnode . ). protected . Function is unpack TObject and TString structures to be able read them from custom streamers of this objects. ; Definition at line 1321 of file TBufferXML.cxx. ◆ PopStack(). TXMLStackObj * TBufferXML::PopStack ; (; ). protected . Remove one level from xml stack. ; Definition at line 312 of file TBufferXML.cxx. ◆ ProcessPointer(). Bool_t TBufferXML::ProcessPointer ; (; const void * ; ptr, . XMLNodePointer_t ; node . ). protected . Add ""ptr"" attribute to node, if ptr is null or if ptr is pointer on object, which is already saved in buffer Automatically add ""ref"" attribute to node, where referenced object is stored. ; Definition at line 523 of file TBufferXML.cxx. ◆ PushStack(). TXMLStackObj * TBufferXML::PushStack ; (; XMLNodePointer_t ; current, . Bool_t ; simple = kFALSE . ). protected . Add new level to xml stack. ; Definition at line 298 of file TBu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferXML.html:62712,Perform,PerformPreProcessing,62712,doc/master/classTBufferXML.html,https://root.cern,https://root.cern/doc/master/classTBufferXML.html,1,['Perform'],['PerformPreProcessing']
Performance,"lements are passed as an argument to func. ; redfuncReduction function to combine the results of the calls to func into partial results, and these into a final result. Must return the same type as func and should be callable with const std::vector<T> where T is the output of func. ; nChunksNumber of chunks to split the input data for processing. . ReturnsA value result of ""reducing"" the vector returned by the Map operation into a single object. ; Definition at line 305 of file TExecutor.hxx. ◆ MapReduce() [2/5]. template<class F , class INTEGER , class R , class Cond > . auto ROOT::Internal::TExecutor::MapReduce ; (; F ; func, . ROOT::TSeq< INTEGER > ; args, . R ; redfunc, . unsigned ; nChunks . ); -> InvokeResult_t<F, INTEGER>. Execute a function over a sequence of indexes (Map) and accumulate the results into a single value (Reduce). ; Benefits from partial reduction into nChunks intermediate results if the execution policy is multithreaded. Otherwise, it ignores the nChunks argument and performs a normal MapReduce operation.; Parameters. funcFunction to be executed. Must take an element of the sequence passed assecond argument as a parameter. ; argsSequence of indexes to execute func on. ; redfuncReduction function to combine the results of the calls to func into partial results, and these into a final result. Must return the same type as func and should be callable with std::vector<T> where T is the output of func. ; nChunksNumber of chunks to split the input data for processing. . ReturnsA value result of ""reducing"" the vector returned by the Map operation into a single object. ; Definition at line 236 of file TExecutor.hxx. ◆ MapReduce() [3/5]. template<class F , class T , class R , class Cond > . auto ROOT::Internal::TExecutor::MapReduce ; (; F ; func, . std::initializer_list< T > ; args, . R ; redfunc, . unsigned ; nChunks . ); -> InvokeResult_t<F, T>. Execute a function over the elements of an initializer_list (Map) and accumulate the results into a single ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1Internal_1_1TExecutor.html:16263,perform,performs,16263,doc/v632/classROOT_1_1Internal_1_1TExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1Internal_1_1TExecutor.html,2,['perform'],['performs']
Performance,"lent=kFALSE) constReturn pointer to class with name. Obsolete, use TClass::GetClass directly.Definition TROOT.cxx:1518; TROOT::fSelectPadTVirtualPad * fSelectPadCurrently selected pad.Definition TROOT.h:139; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2979; TROOT::GetGlobalFunctionsTListOfFunctions * GetGlobalFunctions()Internal routine returning, and creating if necessary, the list of global function.Definition TROOT.cxx:1663; TROOT::fInterruptBool_t fInterruptTrue if macro should be interrupted.Definition TROOT.h:134; TROOT::fMustCleanBool_t fMustCleanTrue if object destructor scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, Bool_t check=kFALSE)Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore,...Definition TROOT.cxx:2183; TROOT::GetGlobalFunctionTFunction * GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1685; TROOT::AddClassvoid AddClass(TClass *cl)Add a class to the list and map of classes.Definition TROOT.cxx:1025; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2941; TROOT::FindSpecialObjectTObject * FindSpecialObject(const char *name, void *&where)Returns address and folder of a ROOT object if it exists.Definition TROOT.cxx:1367; TROOT::RemoveTObject * Remove(TObject *) overrideRemove an object from the in-memory list.Definition TROOT.cxx:2618; TROOT::InitSystemvoid InitSystem()Operating System interface.Definition TROOT.cxx:1978; TROOT::ProcessLineFastLongptr_t ProcessLineFast(const char *line, Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:157938,Load,LoadClass,157938,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,2,['Load'],['LoadClass']
Performance,"lent=kFALSE) constReturn pointer to class with name. Obsolete, use TClass::GetClass directly.Definition TROOT.cxx:1518; TROOT::fSelectPadTVirtualPad * fSelectPadCurrently selected pad.Definition TROOT.h:139; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::GetGlobalFunctionsTListOfFunctions * GetGlobalFunctions()Internal routine returning, and creating if necessary, the list of global function.Definition TROOT.cxx:1663; TROOT::fInterruptBool_t fInterruptTrue if macro should be interrupted.Definition TROOT.h:134; TROOT::fMustCleanBool_t fMustCleanTrue if object destructor scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, Bool_t check=kFALSE)Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore,...Definition TROOT.cxx:2183; TROOT::GetGlobalFunctionTFunction * GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1685; TROOT::AddClassvoid AddClass(TClass *cl)Add a class to the list and map of classes.Definition TROOT.cxx:1025; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2945; TROOT::FindSpecialObjectTObject * FindSpecialObject(const char *name, void *&where)Returns address and folder of a ROOT object if it exists.Definition TROOT.cxx:1367; TROOT::RemoveTObject * Remove(TObject *) overrideRemove an object from the in-memory list.Definition TROOT.cxx:2618; TROOT::InitSystemvoid InitSystem()Operating System interface.Definition TROOT.cxx:1978; TROOT::ProcessLineFastLongptr_t ProcessLineFast(const char *line, Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:158114,Load,LoadClass,158114,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['Load'],['LoadClass']
Performance,"lepton is found.; for(auto i = 0; i < type.size(); i++) {; if(!goodlep[i]) continue;; if (type[i] == 11 && abs(lep_eta[i]) < 2.47 && (abs(lep_eta[i]) < 1.37 || abs(lep_eta[i]) > 1.52) && abs(trackd0pv[i] / tracksigd0pv[i]) < 5) {; const ROOT::Math::PtEtaPhiEVector p(lep_pt[i], lep_eta[i], lep_phi[i], lep_e[i]);; if (abs(z0[i] * sin(p.Theta())) < 0.5) {; if (idx == -1) idx = i;; else return -1; // Accept only events with exactly one good lepton; }; }; if (type[i] == 13 && abs(lep_eta[i]) < 2.5 && abs(trackd0pv[i] / tracksigd0pv[i]) < 3) {; const ROOT::Math::PtEtaPhiEVector p(lep_pt[i], lep_eta[i], lep_phi[i], lep_e[i]);; if (abs(z0[i] * sin(p.Theta())) < 0.5) {; if (idx == -1) idx = i;; else return -1; // Accept only events with exactly one good lepton; }; }; }; return idx;; }; """"""); ; for s in samples:; # Select events with electron or muon trigger and with a missing transverse energy above 30 GeV; df[s] = df[s].Filter(""trigE || trigM"")\; .Filter(""met_et > 30000""); ; # Perform preselection of highly isolated leptons; df[s] = df[s].Define(""goodlep"", ""lep_isTightID && lep_pt > 35000 && lep_ptcone30 / lep_pt < 0.1 && lep_etcone20 / lep_pt < 0.1"")\; .Filter(""ROOT::VecOps::Sum(goodlep) > 0""); ; # Find a single good lepton, otherwise return -1 as index; df[s] = df[s].Define(""idx_lep"", ""FindGoodLepton(goodlep, lep_type, lep_pt, lep_eta, lep_phi, lep_E, lep_trackd0pvunbiased, lep_tracksigd0pvunbiased, lep_z0)"")\; .Filter(""idx_lep != -1""); ; # Compute transverse mass of the W boson using the missing transverse energy and the good lepton; # Use only events with a transverse mass of the reconstructed W boson larger than 60 GeV; df[s] = df[s].Define(""mtw"", ""sqrt(2 * lep_pt[idx_lep] * met_et * (1 - cos(lep_phi[idx_lep] - met_phi)))"")\; .Filter(""mtw > 60000""); ; # Perform preselection of jets; df[s] = df[s].Filter(""ROOT::VecOps::Sum(jet_pt > 30000 && abs(jet_eta) < 2.5) > 0""); ; # Select events with two good jets and one b-jet and find the indices in the collections; df[s] = df[s]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:4810,Perform,Perform,4810,doc/master/df107__SingleTopAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html,1,['Perform'],['Perform']
Performance,"ler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # done with cached method; Note that if you do not discard the bound method, a reference to the histogram will remain outstanding, and it will not be deleted when it should be. It is therefore important to delete the method when you’re done with it.; 19.1.8 Use of Python Functions; It is possible to mix Python functions with ROOT and perform such operations as plotting and fitting of histograms with them. In all cases, the procedure consists of instantiating a ROOT TF1, TF2, or TF3 with the Python function and working with that ROOT object. There are some memory issues, so it is for example not yet possible to delete a TF1 instance and then create another one with the same name. In addition, the Python function, once used for instantiating the TF1, is never deleted.; Instead of a Python function, you can also use callable instances (e.g., an instance of a class that has implemented the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1064888,cache,cache,1064888,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['cache'],['cache']
Performance,"ler version identifier string; 3898 ; 3899const char *TSystem::GetBuildCompilerVersionStr() const; 3900{; 3901 return fBuildCompilerVersionStr;; 3902}; 3903 ; 3904////////////////////////////////////////////////////////////////////////////////; 3905/// Return the build node name.; 3906 ; 3907const char *TSystem::GetBuildNode() const; 3908{; 3909 return fBuildNode;; 3910}; 3911 ; 3912////////////////////////////////////////////////////////////////////////////////; 3913/// Return the path of the build directory.; 3914 ; 3915const char *TSystem::GetBuildDir() const; 3916{; 3917 if (fBuildDir.Length()==0) {; 3918 if (!gEnv) return """";; 3919 const_cast<TSystem*>(this)->fBuildDir = gEnv->GetValue(""ACLiC.BuildDir"","""");; 3920 }; 3921 return fBuildDir;; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Return the debug flags.; 3926 ; 3927const char *TSystem::GetFlagsDebug() const; 3928{; 3929 return fFlagsDebug;; 3930}; 3931 ; 3932////////////////////////////////////////////////////////////////////////////////; 3933/// Return the optimization flags.; 3934 ; 3935const char *TSystem::GetFlagsOpt() const; 3936{; 3937 return fFlagsOpt;; 3938}; 3939 ; 3940////////////////////////////////////////////////////////////////////////////////; 3941/// AclicMode indicates whether the library should be built in; 3942/// debug mode or optimized. The values are:; 3943/// - TSystem::kDefault : compile the same as the current ROOT; 3944/// - TSystem::kDebug : compiled in debug mode; 3945/// - TSystem::kOpt : optimized the library; 3946 ; 3947TSystem::EAclicMode TSystem::GetAclicMode() const; 3948{; 3949 return fAclicMode;; 3950}; 3951 ; 3952////////////////////////////////////////////////////////////////////////////////; 3953/// Return the command line use to make a shared library.; 3954/// See TSystem::CompileMacro for more details.; 3955 ; 3956const char *TSystem::GetMakeSharedLib() const; 3957{; 3958 return fMakeSharedLib;; 3959}; 39",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:133310,optimiz,optimization,133310,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"lerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** Break *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:2293,multi-thread,multi-threaded,2293,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['multi-thread'],['multi-threaded']
Performance,"les ...; 1650 ; 1651 LoadLibraryMap();; 1652 SetClassAutoLoading(true);; 1653}; 1654 ; 1655void TCling::ShutDown(); 1656{; 1657 fIsShuttingDown = true;; 1658 ResetGlobals();; 1659}; 1660 ; 1661////////////////////////////////////////////////////////////////////////////////; 1662/// Helper to initialize TVirtualStreamerInfo's factor early.; 1663/// Use static initialization to insure only one TStreamerInfo is created.; 1664static bool R__InitStreamerInfoFactory(); 1665{; 1666 // Use lambda since SetFactory return void.; 1667 auto setFactory = []() {; 1668 TVirtualStreamerInfo::SetFactory(new TStreamerInfo());; 1669 return kTRUE;; 1670 };; 1671 static bool doneFactory = setFactory();; 1672 return doneFactory; // avoid unused variable warning.; 1673}; 1674 ; 1675////////////////////////////////////////////////////////////////////////////////; 1676/// Register Rdict data for future loading by LoadPCM;; 1677 ; 1678void TCling::RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent); 1679{; 1680 if (IsFromRootCling()); 1681 return;; 1682 ; 1683 if (llvm::sys::fs::exists(pcmFileNameFullPath)) {; 1684 ::Error(""TCling::RegisterRdictForLoadPCM"", ""Rdict '%s' is both in Module extension and in File system."", pcmFileNameFullPath.c_str());; 1685 return;; 1686 }; 1687 ; 1688 // The pcmFileNameFullPath must be resolved already because we cannot resolve; 1689 // a link to a non-existent file.; 1690 fPendingRdicts[pcmFileNameFullPath] = *pcmContent;; 1691}; 1692 ; 1693////////////////////////////////////////////////////////////////////////////////; 1694/// Tries to load a PCM from TFile; returns true on success.; 1695 ; 1696void TCling::LoadPCMImpl(TFile &pcmFile); 1697{; 1698 auto listOfKeys = pcmFile.GetListOfKeys();; 1699 ; 1700 // This is an empty pcm; 1701 if (listOfKeys && ((listOfKeys->GetSize() == 0) || // Nothing here, or; 1702 ((listOfKeys->GetSize() == 1) && // only one, and; 1703 !strcmp(((TKey *)listOfKeys->At(0))->GetName(), ""EMPTY"")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:62794,load,loading,62794,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,"['Load', 'load']","['LoadPCM', 'loading']"
Performance,"les allow to select the classes for which the dictionaries must be created: a third method is available. This is represented by the ROOT::Meta::Selection namespace. The idea behind this technique is that all the classes which are located in this special namespace are automatically selected for dictionary generation. All the properties and annotations allowed by LinkDef and selection XML files are possible. For a detailed documentation of the features of the ROOT::Meta::Selection namespace, refer to its online documentation.; 15.7 Adding a Class with ACLiC; Step 1: Define your class; #include ""TObject.h"". // define the ABC class and make it inherit from TObject so that; // we can write ABC to a ROOT file; class ABC : public TObject {. public:; Float_t a, b, c, p;; ABC() : a(0), b(0), c(0), p(0){};. // Define the class for the dictionary; ClassDef (ABC,1); };. // Call the ClassImp macro to give the ABC class RTTI and; // full I/O capabilities. #if !defined(__CLING__); ClassImp(ABC);; #endif; Step 2: Load the ABC class in the script.; // Check if ABC is already loaded; if (!TClass::GetDict(""ABC"")) {; gROOT->ProcessLine("".L ABCClass.C++"");; }. // Use the Class; ABC *v = new ABC;; v->p = (sqrt((v->a * v->a)+ (v->b * v->b)+(v->c * v->c)));; 16 Collection Classes; Collections are a key feature of the ROOT system. Many, if not most, of the applications you write will use collections. If you have used parameterized C++ collections or polymorphic collections before, some of this material will be review. However, much of this chapter covers aspects of collections specific to the ROOT system. When you have read this chapter, you will know. How to create instances of collections; The difference between lists, arrays, hash tables, maps, etc.; How to add and remove elements of a collection; How to search a collection for a specific element; How to access and modify collection elements; How to iterate over a collection to access collection elements; How to manage memory for collecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:838691,Load,Load,838691,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Load'],['Load']
Performance,"les on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_mode; static Int_tRooPrintable::_nameLength; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt!",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:31684,cache,cache,31684,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,3,['cache'],['cache']
Performance,"lesvector of variable settings and tranformation function; vector<double>fXinternal cached of external values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinimTransformFunction(const ROOT::Math::IMultiGradFunction* f, const vector<ROOT::Math::EMinimVariableType>& types, const vector<double>& values, const map<unsigned int,std::pair<double,double> >& bounds). Constructor from a IMultiGradFunction interface (which is managed by the class); vector specifying the variable types (free, bounded or fixed, defined in enum EMinimVariableTypes ); variable values (used for the fixed ones) and a map with the bounds (for the bounded variables). unsigned int NDim() const; method inherited from IFunction interface. { return fIndex.size(); }. unsigned int NTot() const; { return fFunc->NDim(); }. IMultiGenFunction * Clone() const; clone: not supported (since auto_ptr used in the fVariables). const double * Transformation(const double* x) const; transform from internal to external; result is cached also inside the class. Transformation(x, &fX[0]). void InvTransformation(const double* xext, double* xint) const; inverse transformation (external -> internal). void InvStepTransformation(const double* x, const double* sext, double* sint) const; inverse transformation for steps (external -> internal) at external point x. void GradientTransformation(const double* x, const double* gExt, double* gInt) const; transform gradient vector (external -> internal) at internal point x. void MatrixTransformation(const double* x, const double* covInt, double* covExt) const; transform covariance matrix (internal -> external) at internal point x; use row storages for matrices m(i,j) = rep[ i * dim + j]. const IMultiGradFunction * OriginalFunction() const; return original function. { return fFunc; }. double DoEval(const double* x) const; function evaluation. double DoDerivative(const double* x, unsigned int icoord) const; calculate derivatives. MinimTransformF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__MinimTransformFunction.html:3218,cache,cached,3218,root/html534/ROOT__Math__MinimTransformFunction.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__MinimTransformFunction.html,1,['cache'],['cached']
Performance,"lete (*itrMethod);; 335 }; 336 methods->clear();; 337 delete methods;; 338 }; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342 ; 343void TMVA::Factory::SetVerbose(Bool_t v); 344{; 345 fVerbose = v;; 346}; 347 ; 348////////////////////////////////////////////////////////////////////////////////; 349/// Book a classifier or regression method.; 350 ; 351TMVA::MethodBase *; 352TMVA::Factory::BookMethod(TMVA::DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption); 353{; 354 if (fModelPersistence); 355 gSystem->MakeDirectory(loader->GetName()); // creating directory for DataLoader output; 356 ; 357 TString datasetname = loader->GetName();; 358 ; 359 if (fAnalysisType == Types::kNoAnalysisType) {; 360 if (loader->GetDataSetInfo().GetNClasses() == 2 && loader->GetDataSetInfo().GetClassInfo(""Signal"") != NULL &&; 361 loader->GetDataSetInfo().GetClassInfo(""Background"") != NULL) {; 362 fAnalysisType = Types::kClassification; // default is classification; 363 } else if (loader->GetDataSetInfo().GetNClasses() >= 2) {; 364 fAnalysisType = Types::kMulticlass; // if two classes, but not named ""Signal"" and ""Background""; 365 } else; 366 Log() << kFATAL << ""No analysis type for "" << loader->GetDataSetInfo().GetNClasses() << "" classes and ""; 367 << loader->GetDataSetInfo().GetNTargets() << "" regression targets."" << Endl;; 368 }; 369 ; 370 // booking via name; the names are translated into enums and the; 371 // corresponding overloaded BookMethod is called; 372 ; 373 if (fMethodsMap.find(datasetname) != fMethodsMap.end()) {; 374 if (GetMethod(datasetname, methodTitle) != 0) {; 375 Log() << kFATAL << ""Booking failed since method with title <"" << methodTitle << ""> already exists ""; 376 << ""in with DataSet Name <"" << loader->GetName() << ""> "" << Endl;; 377 }; 378 }; 379 ; 380 Log() << kHEADER << ""Booking method: "" << gTools().Color(""bold""); 381 << methodTitle; 382 // << gTools().Color(""reset"")<<"" DataSet Name: ""<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:14348,load,loader,14348,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"lete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooThresholdCategory&operator=(const RooThresholdCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooThresholdCategory.html:11355,optimiz,optimizeCacheMode,11355,root/html602/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html602/RooThresholdCategory.html,2,['optimiz'],['optimizeCacheMode']
Performance,"lete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static TStringfgDefaultdefault transformer; static TVirtualFFT*fgFFTcurrent transformer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualFFT(); destructor. TVirtualFFT* FFT(Int_t ndim, Int_t* n, Option_t* option); Returns a pointer to the FFT of requested size and type.; Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -option : consists of 3 parts - flag option and an option to create a new TVirtualFFT; 1) transform type option:; Available transform types are:; C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; see class description for details; 2) flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transfor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualFFT.html:10231,perform,performance,10231,root/html528/TVirtualFFT.html,https://root.cern,https://root.cern/root/html528/TVirtualFFT.html,4,['perform'],['performance']
Performance,"lete[] newth2p.fIsEmpty;; 229 delete[] newth2p.fCompletelyInside;; 230 // allocate arrays; 231 newth2p.fCells = new TList [fNCells];; 232 newth2p.fIsEmpty = new Bool_t [fNCells]; // Empty partition; 233 newth2p.fCompletelyInside = new Bool_t [fNCells]; // Cell is completely inside bin; 234 // Initializes the flags; 235 for (int i = 0; i<fNCells; i++) {; 236 newth2p.fIsEmpty[i] = fIsEmpty[i];; 237 newth2p.fCompletelyInside[i] = fCompletelyInside[i];; 238 }; 239 // need to use Clone to copy the contained bin list; 240 delete newth2p.fBins; // in case there was something before there; 241 if (!fBins) {; 242 newth2p.fBins = nullptr;; 243 }; 244 else {; 245 newth2p.fBins = dynamic_cast<TList *>(fBins->Clone());; 246 if (!newth2p.fBins); 247 Error(""Copy"",""Error cloning the TH2Poly bin list"");; 248 else {; 249 // add bins in the fCells partition. We need to add the TH2PolyBin objects; 250 // of the new copied histograms. For this we call AddBinToPartition; 251 // we could probably optimize this by implementing a copy of the partition; 252 for (auto bin : *(newth2p.fBins)) {; 253 newth2p.AddBinToPartition(dynamic_cast<TH2PolyBin*>(bin));; 254 }; 255 }; 256 }; 257 // copy overflow contents; 258 for(int i = 0; i < kNOverflow; i++ ) {; 259 newth2p.fOverflow[i] = fOverflow[i];; 260 }; 261 // copy other data members; 262 newth2p.fFloat = fFloat;; 263 newth2p.fNewBinAdded = fNewBinAdded;; 264 newth2p.fBinContentChanged = fBinContentChanged;; 265}; 266 ; 267 ; 268////////////////////////////////////////////////////////////////////////////////; 269/// Create appropriate histogram bin.; 270/// e.g. TH2Poly creates TH2PolyBin,; 271/// TProfile2Poly creates TProfile2PolyBin; 272/// This is done so that TH2Poly::AddBin does not have to be duplicated,; 273/// but only create needs to be reimplemented for additional histogram types; 274 ; 275TH2PolyBin *TH2Poly::CreateBin(TObject *poly); 276{; 277 if (!poly) return nullptr;; 278 ; 279 if (fBins == nullptr) {; 280 fBins = new TList();; 281",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:10272,optimiz,optimize,10272,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['optimiz'],['optimize']
Performance,"leted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:2062,cache,cached,2062,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['cache'],['cached']
Performance,"letteEditor ; (; ). overridevirtual . Start palette editor. ; Reimplemented from TAttImage.; Definition at line 2252 of file TASImage.cxx. ◆ Streamer(). void TASImage::Streamer ; (; TBuffer & ; b). overridevirtual . Streamer for ROOT I/O. ; Reimplemented from TObject.; Definition at line 6175 of file TASImage.cxx. ◆ StreamerNVirtual(). void TASImage::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 211 of file TASImage.h. ◆ Tile(). void TASImage::Tile ; (; UInt_t ; width, . UInt_t ; height . ). overridevirtual . Tile the original image. ; Reimplemented from TImage.; Definition at line 1987 of file TASImage.cxx. ◆ TypeFromMagicNumber(). const char * TASImage::TypeFromMagicNumber ; (; const char * ; file). private . Guess the file type from the first byte of file. ; Definition at line 402 of file TASImage.cxx. ◆ UnZoom(). void TASImage::UnZoom ; (; ). overridevirtual . Un-zoom the image to original size. ; UnZoom() - performs undo for Zoom,Crop,Scale actions ; Reimplemented from TImage.; Definition at line 2049 of file TASImage.cxx. ◆ Vectorize(). Double_t * TASImage::Vectorize ; (; UInt_t ; max_colors = 256, . UInt_t ; dither = 4, . Int_t ; opaque_threshold = 1 . ). overridevirtual . Reduce color-depth of an image and fills vector of ""scientific data"" [0...1]. ; Colors are reduced by allocating color cells to most used colors first, and then approximating other colors with those allocated.; Parameters. [in]max_colors- maximum size of the colormap. ; [in]dither- number of bits to strip off the color data ( 0...7 ) ; [in]opaque_threshold- alpha channel threshold at which pixel should be treated as opaque . Reimplemented from TImage.; Definition at line 2832 of file TASImage.cxx. ◆ WriteImage(). void TASImage::WriteImage ; (; const char * ; file, . EImageFileTypes ; type = TImage::kUnknown . ). overridevirtual . Write image to specified file. ; If there is no file extension or if the file extension is unknown, the type argument",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:77886,perform,performs,77886,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['perform'],['performs']
Performance,"lg %lg"", Option_t* option = """"); Graph2D constructor reading input from filename; filename is assumed to contain at least three columns of numbers.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. TGraph2D(const TGraph2D& ); Graph2D copy constructor.; copy everything apart from the list of contained functions. ~TGraph2D(); TGraph2D destructor. TGraph2D& operator=(const TGraph2D& ); Graph2D operator ""="". void Build(Int_t n); Creates the 2D graph basic data structure. void Browse(TBrowser* ); Browse. void Clear(Option_t* option = """"); Free all memory allocated by this object. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the graph to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes distance from point px,py to a graph. void Draw(Option_t* option = """"); Specific drawing options can be used to paint a TGraph2D:. ""TRI"" : The Delaunay triangles are drawn using filled area.; An hidden surface drawing technique is used. The surface is; painted with the current fill area color. The edges of each; triangles are painted with the current line color.; ""TRIW"" : The Delaunay triangles are drawn as wire frame; ""TRI1"" : The Delaunay triangles are painted with color levels. The edges; of each triangles are painted with the current line color.; ""TRI2"" : the Delaunay triangles are painted with color levels.; ""P"" : Draw a marker at each vertex; ""P0"" : Draw a circle at each vertex. Each circle background is white.; ""PCOL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraph2D.html:19909,Perform,Perform,19909,root/html534/TGraph2D.html,https://root.cern,https://root.cern/root/html534/TGraph2D.html,3,['Perform'],['Perform']
Performance,"lgorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120) The new code features many changes compared to the Fortran version.; Control parameters are:. \( minpts \): Minimum number of function evaluations requested. Must not exceed maxpts. if minpts < 1 minpts is set to \( 2^n +2n(n+1) +1 \) where n is the function dimension; \( maxpts \): Maximum number of function evaluations to be allowed. \( maxpts >= 2^n +2n(n+1) +1 \) if \( maxpts<minpts \), \( maxpts \) is set to \( 10minpts \); \( epstol \), \( epsrel \) : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the absolute error is less than the absolute tolerance; The class computes in addition to the integral of the function in the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code: 0. Normal exit. . At least minpts and at most maxpts calls to the function were performed.; maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the specified value of maxpts.; size is too small for the specified number MAXPTS of function evaluations.; n<2 or n>15. Method:; An integration rule of degree seven is used together with a certain strategy of subdivision. For a more detailed description of the method see References. Notes:; 1..Multi-dimensional integration is time-consuming. For each rectangular subregion, the routine requires function evaluations. Careful programming of the integrand might result in substantial saving of time. 2..Numerical integration usually works best for smooth functions. Some analysis or suitable transformations of the integral prior to numerical work may contribute to numerical efficiency. References:. A.C. Genz and A.A. Malik, Remarks on algorithm 006: An adaptiv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html:1561,perform,performed,1561,doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,1,['perform'],['performed']
Performance,"lgorithm is practically using all navigation features, producing ray-traced pictures is also a geometry validation check. Ray tracing can be activated at volume level as the normal Draw(). Ray-traced view in a pad; myVolume->Raytrace(); Once ray-tracing a view, this can be zoomed or rotated as a usual one. Objects on the screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible.; Clipping Ray-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):. TGeoShape *clip1, *clip2, ... One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; gGeoManager->SetClippingShape(clip1); One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);; Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom.C example looks clipped with a tube. Ray-tracing example with box-clipping. Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information. Physical Nodes; Physical nodes are the actual ""touchable"" objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:114184,Perform,Perform,114184,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['Perform'],['Perform']
Performance,"lgorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Math::IntegrationOneDim::TypeGetType(const char* name); doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); doubleIntegral(double a, double b); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral<double>(double& f, const vector<double>& pts); doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IntegratorOneDim.html:1385,perform,performances,1385,root/html602/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IntegratorOneDim.html,2,['perform'],['performances']
Performance,"lgorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); doubleIntegral(double a, double b); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); doubleIntegralLow(double b); doubleIntegralLow(const ROOT::Math::IGenFunction& f, double b); do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html:1383,perform,performances,1383,root/html526/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html,1,['perform'],['performances']
Performance,"lgorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Math::IntegrationOneDim::TypeGetType(const char* name); doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); doubleIntegral(double a, double b); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:1383,perform,performances,1383,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,4,['perform'],['performances']
Performance,"lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:34206,load,loaded,34206,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,3,['load'],['loaded']
Performance,"library location.; 2270 clang::Preprocessor &PP = TheSema.getPreprocessor();; 2271 std::string ModuleMapName;; 2272 if (isACLiC); 2273 ModuleMapName = ModuleName + "".modulemap"";; 2274 else; 2275 ModuleMapName = ""module.modulemap"";; 2276 RegisterPrebuiltModulePath(llvm::sys::path::parent_path(dyLibName).str(),; 2277 ModuleMapName);; 2278 ; 2279 // FIXME: We should only complain for modules which we know to exist. For example, we should not complain about; 2280 // modules such as GenVector32 because it needs to fall back to GenVector.; 2281 cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());; 2282 ModuleWasSuccessfullyLoaded = LoadModule(ModuleName, *fInterpreter);; 2283 if (!ModuleWasSuccessfullyLoaded) {; 2284 // Only report if we found the module in the modulemap.; 2285 clang::HeaderSearch &headerSearch = PP.getHeaderSearchInfo();; 2286 clang::ModuleMap &moduleMap = headerSearch.getModuleMap();; 2287 if (moduleMap.findModule(ModuleName)); 2288 Info(""TCling::RegisterModule"", ""Module %s in modulemap failed to load."", ModuleName.c_str());; 2289 }; 2290 }; 2291 ; 2292 if (gIgnoredPCMNames.find(modulename) == gIgnoredPCMNames.end()) {; 2293 llvm::SmallString<256> pcmFileNameFullPath(dyLibName);; 2294 // The path dyLibName might not be absolute. This can happen if dyLibName; 2295 // is linked to an executable in the same folder.; 2296 llvm::sys::fs::make_absolute(pcmFileNameFullPath);; 2297 llvm::sys::path::remove_filename(pcmFileNameFullPath);; 2298 llvm::sys::path::append(pcmFileNameFullPath,; 2299 ROOT::TMetaUtils::GetModuleFileName(modulename));; 2300 LoadPCM(pcmFileNameFullPath.str().str());; 2301 }; 2302 ; 2303 { // scope within which diagnostics are de-activated; 2304 // For now we disable diagnostics because we saw them already at; 2305 // dictionary generation time. That won't be an issue with the PCMs.; 2306 ; 2307 clangDiagSuppr diagSuppr(TheSema.getDiagnostics());; 2308 ; 2309#if defined(R__MUST_REVISIT); 2310#if R__MUST_REVISIT(6,2); 231",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:88633,load,load,88633,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance,"lic Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/roofit/roofitcore/src/RooRealMPFE.h>. Inheritance diagram for RooRealMPFE:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ Message. enum RooRealMPFE::Message. protected . EnumeratorSendReal ; SendCat ; Calculate ; Retrieve ; ReturnValue ; Terminate ; ConstOpt ; Verbose ; LogEvalError ; ApplyNLLW2 ; EnableOffset ; CalculateNoOffset . Definition at line 62 of file RooRealMPFE.h. ◆ State. enum RooRealMPFE::State. protected . EnumeratorInitialize ; Client ; Server ; Inline . Definition at line 59 of file RooRealMPFE.h. Constructor & Destructor Documentation. ◆ RooRealMPFE() [1/2]. RooRealMPFE::RooRealMPFE ; (; const char * ; name, . const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:62877,cache,cache,62877,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,1,['cache'],['cache']
Performance,"lic Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAbsCachedReal.h>. Inheritance diagram for RooAbsCachedReal:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ CacheElem. using RooAbsCachedReal::CacheElem = FuncCacheElem. protected . Definition at line 89 of file RooAbsCachedReal.h. Constructor & Destructor Documentation. ◆ RooAbsCachedReal() [1/3]. RooAbsCachedReal::RooAbsCachedReal ; (; ). inline . Definition at line 27 of file RooAbsCachedReal.h. ◆ RooAbsCachedReal() [2/3]. RooAbsCachedReal::RooAbsCachedReal ; (; const char * ; name, . const char * ; title, . Int_t ; ipOrder = 0 . ). Constructor. ; Definition at line 50 of file RooAbsCachedReal.cxx. ◆ RooAbsCachedReal() [3/3]. RooAbsCachedReal::RooAbsCachedReal ; (; const RooAbsCachedReal & ; other, . const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:61773,cache,cache,61773,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,1,['cache'],['cache']
Performance,"lic Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t getCacheAllNumeric ();  Return minimum dimensions of numeric integration for which values are cached. ;  ; static void setCacheAllNumeric (Int_t ndim);  Global switch to cache all integral values that integrate at least ndim dimensions numerically. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:46420,cache,cache,46420,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['cache'],['cache']
Performance,"lic Member Functions |; Protected Attributes |; List of all members ; TFunctionTemplate Class Reference. ; Dictionary for function template This class describes one single function template. ; Definition at line 26 of file TFunctionTemplate.h. Public Member Functions;  TFunctionTemplate (const TFunctionTemplate &orig);  Copy operator. ;  ;  TFunctionTemplate (FuncTempInfo_t *info, TClass *cl);  Default TFunctionTemplate ctor. ;  ; virtual ~TFunctionTemplate ();  TFunctionTemplate dtor deletes adopted CINT FuncTempInfo. ;  ; TObject * Clone (const char *newname="""") const override;  Clone method. ;  ; Long_t ExtraProperty () const;  Get the properties not already defined in Property.See TDictionary's EFunctionProperty. ;  ; DeclId_t GetDeclId () const;  ; UInt_t GetTemplateMinReqArgs () const;  Number of function optional (default) arguments. ;  ; UInt_t GetTemplateNargs () const;  Number of function arguments. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsValid ();  Return true if this function template object is pointing to a currently loaded function. ;  ; TFunctionTemplate & operator= (const TFunctionTemplate &rhs);  Assignment operator. ;  ; Long_t Property () const override;  Get property description word. For meaning of bits see EProperty. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool Update (FuncTempInfo_t *info);  Update the TFunctionTemplate to reflect the new info. ;  ;  Public Member Functions inherited from TDictionary;  TDictionary ();  ;  TDictionary (const char *name);  ;  TDictionary (const TDictionary &dict);  ; virtual ~TDictionary ();  ; void CreateAttributeMap ();  ; TDictAttributeMap * GetAttributeMap () const;  ; TDictionary & operator= (const TDictionary &other);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFunctionTemplate.html:1247,load,loaded,1247,doc/master/classTFunctionTemplate.html,https://root.cern,https://root.cern/doc/master/classTFunctionTemplate.html,1,['load'],['loaded']
Performance,"lic Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  Factory (TString theJobName, TFile *theTargetFile, TString theOption="""");  Standard constructor. ;  ;  Factory (TString theJobName, TString theOption="""");  Constructor. ;  ; virtual ~Factory ();  Destructor. ;  ; MethodBase * BookMethod (DataLoader *, TMVA::Types::EMVA, TString, TString, TMVA::Types::EMVA, TString);  ; MethodBase * BookMethod (DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""");  Book a classifier or regression method. ;  ; MethodBase * BookMethod (DataLoader *loader, Types::EMVA theMethod, TString methodTitle, TString theOption="""");  Books MVA method. ;  ; void DeleteAllMethods (void);  Delete methods. ;  ; void EvaluateAllMethods (void);  Iterates over all MVAs that have been booked, and calls their evaluation methods. ;  ; void EvaluateAllVariables (DataLoader *loader, TString options="""");  Iterates over all MVA input variables and evaluates them. ;  ; TH1F * EvaluateImportance (DataLoader *loader, VIType vitype, Types::EMVA theMethod, TString methodTitle, const char *theOption="""");  Evaluate Variable Importance. ;  ; IMethod * GetMethod (const TString &datasetname, const TString &title) const;  Returns pointer to MVA that corresponds to given method title. ;  ; TGraph * GetROCCurve (DataLoader *loader, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:1621,load,loader,1621,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance,"lic:. virtual~SdivSqrtSplusB(); static TClass*Class(); const TString&TMVA::SeparationBase::GetName(); virtual Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SdivSqrtSplusB&operator=(const TMVA::SdivSqrtSplusB&); TMVA::SdivSqrtSplusBSdivSqrtSplusB(); TMVA::SdivSqrtSplusBSdivSqrtSplusB(const TMVA::SdivSqrtSplusB& g); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Index = S/sqrt(S+B) (statistical significance). Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. SdivSqrtSplusB(); constructor for the ""statistical significance"" index. { fName = ""StatSig""; }. SdivSqrtSplusB(const TMVA::SdivSqrtSplusB& g); copy constructor. {}. virtual ~SdivSqrtSplusB(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__SdivSqrtSplusB.html:1742,optimiz,optimized,1742,root/html534/TMVA__SdivSqrtSplusB.html,https://root.cern,https://root.cern/root/html534/TMVA__SdivSqrtSplusB.html,1,['optimiz'],['optimized']
Performance,"lic:; 121 ; 122 enum EWeightFileType { kROOT=0, kTEXT };; 123 ; 124 // default constructor; 125 MethodBase( const TString& jobName,; 126 Types::EMVA methodType,; 127 const TString& methodTitle,; 128 DataSetInfo& dsi,; 129 const TString& theOption = """" );; 130 ; 131 // constructor used for Testing + Application of the MVA, only (no training),; 132 // using given weight file; 133 MethodBase( Types::EMVA methodType,; 134 DataSetInfo& dsi,; 135 const TString& weightFile );; 136 ; 137 // default destructor; 138 virtual ~MethodBase();; 139 ; 140 // declaration, processing and checking of configuration options; 141 void SetupMethod();; 142 void ProcessSetup();; 143 virtual void CheckSetup(); // may be overwritten by derived classes; 144 ; 145 // ---------- main training and testing methods ------------------------------; 146 ; 147 // prepare tree branch with the method's discriminating variable; 148 void AddOutput( Types::ETreeType type, Types::EAnalysisType analysisType );; 149 ; 150 // performs classifier training; 151 // calls methods Train() implemented by derived classes; 152 void TrainMethod();; 153 ; 154 // optimize tuning parameters; 155 virtual std::map<TString,Double_t> OptimizeTuningParameters(TString fomType=""ROCIntegral"", TString fitType=""FitGA"");; 156 virtual void SetTuneParameters(std::map<TString,Double_t> tuneParameters);; 157 ; 158 virtual void Train() = 0;; 159 ; 160 // store and retrieve time used for training; 161 void SetTrainTime( Double_t trainTime ) { fTrainTime = trainTime; }; 162 Double_t GetTrainTime() const { return fTrainTime; }; 163 ; 164 // store and retrieve time used for testing; 165 void SetTestTime ( Double_t testTime ) { fTestTime = testTime; }; 166 Double_t GetTestTime () const { return fTestTime; }; 167 ; 168 // performs classifier testing; 169 virtual void TestClassification();; 170 virtual Double_t GetKSTrainingVsTest(Char_t SorB, TString opt=""X"");; 171 ; 172 // performs multiclass classifier testing; 173 virtual void TestMulticlass(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:5021,perform,performs,5021,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['perform'],['performs']
Performance,"lication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); Create a TApplication derived for use with interactive ROOT from python. A; set of standard, often used libs is loaded if bLoadLibs is true (default). Bool_t CreatePyROOTApplication(Bool_t bLoadLibs = kTRUE); Create a TPyROOTApplication. Returns false if gApplication is not null. Bool_t InitROOTGlobals(); Setup the basic ROOT globals gBenchmark, gStyle, gProgname, if not already; set. Always returns true. Bool_t InitCINTMessageCallback(); Install CINT message callback which will turn CINT error message into; python exceptions. Always returns true. Bool_t InitROOTMessageCallback(); Install ROOT message handler which will turn ROOT error message into; python exceptions. Always returns true. virtual ~TPyROOTApplication(); { }. » Last changed: Mon Dec 7 13:43:16 2009 » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/PyROOT__TPyROOTApplication.html:13083,load,loaded,13083,root/html526/PyROOT__TPyROOTApplication.html,https://root.cern,https://root.cern/root/html526/PyROOT__TPyROOTApplication.html,1,['load'],['loaded']
Performance,"lice(const Double_t* point, const Double_t* dir, Int_t iphi, Double_t sstart, Int_t& ipl, Double_t& snext, Double_t stepmax) const; Check crossing of a given pgon slice, from a starting point inside the slice. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the polygone. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polygone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Phi divisions are; allowed only if nedges%ndiv=0 and create polygone ""segments"" with nedges/ndiv edges.; Z divisions can be performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to volume that was divided. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; Inspect the PGON parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Rpg(Double_t z, Int_t ipl, Bool_t inner, Double_t& a, Double_t& b) const; Computes projected pgon radius (inner or outer) corresponding to a given Z; value. Fills corresponding coefficients of:; Rpg(z) = a + b*z; Note: ipl must be in range [0,fNz-2]. Double_t Rproj(Double_t z, const Double_t* point, const Double_t* dir, Double_t cphi, Double_t sphi, Double_t& a, Double_t& b) const; Computes projected distance at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:18837,perform,performed,18837,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,3,['perform'],['performed']
Performance,"licitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (ROOT::Internal::TStringView str, T &value);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; UInt_t GetImplicitMTPoolSize ();  Returns the size of the pool used for implicit multi-threading. ;  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of includes specified in the shema rules. ;  ; UInt_t GetThreadPoolSize ();  Returns the size of ROOT's thread pool. ;  ; bool HasValidDataMembers (SchemaRuleMap_t &rule, MembersTypeMap_t &members, std::string &error_string);  Check if given rule contains references to valid data members. ;  ; Bool_t IsImplicitMTEnabled ();  Returns true if the implicit multi-threading in ROOT is enabled. ;  ; template<class T > ; TSeq< T > MakeSeq (T begin, T end, T step=1);  ; template<class T > ; TSeq< T > MakeSeq (T end);  ; bool ParseRule (std::string command, ROOT::Internal::MembersMap_t &result, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:8814,multi-thread,multi-threading,8814,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,2,['multi-thread'],['multi-threading']
Performance,"lid_col_y = df.FilterMissing(""x"");; auto display_x = df_valid_col_x.Display<int>({""x""});; auto display_y = df_valid_col_y.Display<int>({""y""});; NoteSee FilterAvailable() if you want to discard the entries in case there is a missing value instead. ; Definition at line 388 of file RInterface.hxx. ◆ Foreach(). template<typename Proxied , typename DataSource = void> . template<typename F > . void ROOT::RDF::RInterface< Proxied, DataSource >::Foreach ; (; F ; f, . const ColumnNames_t & ; columns = {} . ). inline . Execute a user-defined function on each entry (instant action). ; Parameters. [in]fFunction, lambda expression, functor class or any other callable object performing user defined calculations. ; [in]columnsNames of the columns/branches in input to the user function. The callable f is invoked once per entry. This is an instant action: upon invocation, an event loop as well as execution of all scheduled actions is triggered. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT). Example usage:; myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});. Definition at line 1611 of file RInterface.hxx. ◆ ForeachSlot(). template<typename Proxied , typename DataSource = void> . template<typename F > . void ROOT::RDF::RInterface< Proxied, DataSource >::ForeachSlot ; (; F ; f, . const ColumnNames_t & ; columns = {} . ). inline . Execute a user-defined function requiring a processing slot index on each entry (instant action). ; Parameters. [in]fFunction, lambda expression, functor class or any other callable object performing user defined calculations. ; [in]columnsNames of the columns/branches in input to the user function. Same as Foreach, but the user-defined function takes an extra unsigned int as its first parameter, the processing slot index. This slot index will be assigned a different value, 0 to poolSize - 1, for each thread of execution. This is meant as a h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:76591,multi-thread,multi-threading,76591,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['multi-thread'],['multi-threading']
Performance,"lied.; \(A_{ij}/= \nu_j\), divide each matrix row by vector v. If the second argument is “M”, the row is multiplied. 14.4.5 Miscellaneous Operators. Format; Output; Description. A.Zero(); TMatrixX; \(A_{ij} = 0\). A.Abs(); TMatrixX; \(A_{ij} = |A_{ij}|\). A.Sqr(); TMatrixX; \(A_{ij} = A_{ij}^2\). A.Sqrt(); TMatrixX; \(A_{ij} = \sqrt{(A_{ij})}\). A.UnitMatrix(); TMatrixX; \(A_{ij} = 1\) for i ==j else 0. A.Randomize (alpha,beta,seed); TMatrixX; \(A_{ij} = (\beta-\alpha)\bigcup(0,1)+\alpha\) a random matrix is generated with elements uniformly distributed between \(\alpha\) and \(\beta\). A.T(); TMatrixX; \(A_{ij} = A_{ji}\). A.Transpose(B); TMatrixX; \(A_{ij} = B_{ji}\). A.Invert(&det); TMatrixX; Invert matrix A. If the optional pointer to the Double_t argument det is supplied, the matrix determinant is calculated. A.InvertFast(&det); TMatrixX; like Invert but for matrices i =(6x6)a faster but less accurate Cramer algorithm is used. A.Rank1Update(v,alpha); TMatrixX; Perform with vector v a rank 1 operation on the matrix: \(A = A + \alpha.\nu.\nu^T\). A.RandomizePD(alpha,beta,seed)`; TMatrixX; \(A_{ij} = (\beta-\alpha)\bigcup(0,1)+\alpha\) a random symmetric positive-definite matrix is generated with elements uniformly distributed between \(\alpha\) and \(\beta\). Output TMatrixX indicates that the returned matrix is of the same type as A, being TMatrixD, TMatrixDSym or TMatrixDSparse. Next table shows miscellaneous operations for TMatrixD. Format; Output; Description. A.Rank1Update(v1,v2,alpha); TMatrixD; Perform with vector v1 and v2, a rank 1 operation on the matrix: \(A = A + \alpha.\nu.\nu2^T\). 14.5 Matrix Views; Another way to access matrix elements is through the matrix-view classes, TMatrixDRow, TMatrixDColumn, TMatrixDDiag and TMatrixDSub (each has also a const version which is obtained by simply appending const to the class name). These classes create a reference to the underlying matrix, so no memory management is involved. The next table shows how the clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:783119,Perform,Perform,783119,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Perform'],['Perform']
Performance,"lient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0, TList* wrks = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, consider the macro to be a selector; and try to load the selector and set it to the pointer.; The mask 'opt' is an or of ESendFileOpt:; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache; Return -1 in case of error, 0 otherwise. Int_t CleanupSandbox(); Remove old sessions dirs keep at most 'Proof.MaxOldSessions' (default 10). TList * GetListOfQueries(Option_t* opt = """"); Get the list of queries. Bool_t RegisterDataSet(const char* dsName, TFileCollection* ds, const char* opt = """"); Register the 'dataSet' on the cluster under the current; user, group and the given 'dataSetName'.; Fails if a dataset named 'dataSetName' already exists, unless 'optStr'; contains 'O', in which case the old dataset is overwritten.; If 'optStr' contains 'V' the dataset files are verified (default no; verification).; Returns kTRUE on success. Int_t SetDataSetTreeName(const char* dataset, const char* treename); Set/Change the name of the default tree. The tree name may contain; subdir specification in the form ""subdir/name"".; Returns 0 on success, -1 otherwise. Bool_t ExistsDataSet(const char* uri); Returns kTRUE if 'dataset' describe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:32460,cache,cache,32460,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,4,['cache'],['cache']
Performance,lient objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TMatrixDSym*_corrMat; TMatrixDSym*_covMat; Double_t_d; RooDataSet&_data; vector<std::vector<Double_t> >_dataPts; vector<TVectorD>_dataPtsR; RooArgSet_dataVars; Bool_t_debug; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; TVectorD*_dx; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_fixedShape; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooNDKeysPdf::BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Double_t_maxWeight; vector<Double_t>_mean; Double_t_minWeight; Bool_t_mirror; Double_t_n; Int_t_nDim; Int_t_nEvents; Double_t_nEventsBMSW; Double_t_nEventsBW; Int_t_nEventsM; Double_t_nEventsW; Double_t_nSigma; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNDKeysPdf.html:43055,cache,cache,43055,root/html534/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html534/RooNDKeysPdf.html,2,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"lies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. 18.4.3 Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in TGeo has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as ‘volumes-inside-volumes’, the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.; Rotation: \(\left|\begin{array}{cccc} r_{11} & r_{12} & r_{13} & 0 \\ r_{21} & r_{22} & r_{23} & 0 \\ r_{31} & r_{32} & r_{33} & 0 \\ 0 & 0 & 0 & 1 \end{array} \right|\) Translati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:961536,perform,perform,961536,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['perform']
Performance,"lihood methods to \( N_{var} \) dimensions, where \( N_{var} \) is the number of input variables used in the MVA. More...;  ; class  TMVA::MethodRuleFit;  J Friedman's RuleFit method. More...;  ; class  TMVA::MethodSVM;  SMO Platt's SVM classifier with Keerthi & Shavade improvements. More...;  ; class  TMVA::MethodTMlpANN;  This is the TMVA TMultiLayerPerceptron interface class. More...;  ; class  TMVA::MinuitFitter;  /Fitter using MINUIT More...;  ; class  TMVA::MinuitWrapper;  Wrapper around MINUIT. More...;  ; class  TMVA::MisClassificationError;  Implementation of the MisClassificationError as separation criterion. More...;  ; class  TMVA::MsgLogger;  ostringstream derivative to redirect and format output More...;  ; class  TMVA::kNN::Node< T >;  This file contains binary tree and global function template that searches tree for k-nearest neigbors. More...;  ; class  TMVA::Node;  Node for the BinarySearch or Decision Trees. More...;  ; class  TMVA::OptimizeConfigParameters;  ; class  TMVA::OptionBase;  Class for TMVA-option handling. More...;  ; class  TMVA::OptionMap;  class to storage options for the differents methods More...;  ; class  TMVA::PDEFoam;  Implementation of PDEFoam. More...;  ; class  TMVA::PDEFoamCell;  ; class  TMVA::PDEFoamDecisionTree;  This PDEFoam variant acts like a decision tree and stores in every cell the discriminant. More...;  ; class  TMVA::PDEFoamDecisionTreeDensity;  This is a concrete implementation of PDEFoam. More...;  ; class  TMVA::PDEFoamDensityBase;  This is an abstract class, which provides an interface for a PDEFoam density estimator. More...;  ; class  TMVA::PDEFoamDiscriminant;  This PDEFoam variant stores in every cell the discriminant. More...;  ; class  TMVA::PDEFoamDiscriminantDensity;  This is a concrete implementation of PDEFoam. More...;  ; class  TMVA::PDEFoamEvent;  This PDEFoam variant stores in every cell the sum of event weights and the sum of the squared event weights. More...;  ; class  TMVA::PDEFoamEventDen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__TMVA.html:8277,Optimiz,OptimizeConfigParameters,8277,doc/master/group__TMVA.html,https://root.cern,https://root.cern/doc/master/group__TMVA.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance,"likelihood construction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true). RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:50029,perform,performed,50029,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,3,['perform'],['performed']
Performance,"likelihood terms. ; Possible answers are in the enumerator RooAbsPdf::ExtendMode. This default implementation always returns CanNotBeExtended. ; Reimplemented from RooAbsPdf.; Definition at line 2352 of file RooProdPdf.cxx. ◆ forceAnalyticalInt(). bool RooFixedProdPdf::forceAnalyticalInt ; (; const RooAbsArg & ; dep); const. inlineoverridevirtual . Reimplemented from RooAbsReal.; Definition at line 2360 of file RooProdPdf.cxx. ◆ getAnalyticalIntegral(). Int_t RooFixedProdPdf::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 2366 of file RooProdPdf.cxx. ◆ getAnalyticalIntegralWN(). Int_t RooFixedProdPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ; For certain operator p.d.f it is useful to overload this function rather than analyticalIntegralWN() as the additional normalization information may be useful in determining a more efficient decomposition of the requested integral. ; Reimplemented from RooAbsReal.; Definition at line 2361 of file RooProdPdf.cxx. ◆ initialize(). void RooFixedProdPdf::initialize ; (; ). inlineprivate . Definition at line 2380 of file RooProdPdf.cxx. ◆ selfNormalized(). bool RooFixedProdPdf::selfNormalized ; (; ); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFixedProdPdf.html:77789,perform,performed,77789,doc/master/classRooFixedProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooFixedProdPdf.html,1,['perform'],['performed']
Performance,"line . Definition at line 250 of file TROOT.h. ◆ GetListOfProofs(). TSeqCollection * TROOT::GetListOfProofs ; (; ); const. inline . Definition at line 253 of file TROOT.h. ◆ GetListOfSecContexts(). TSeqCollection * TROOT::GetListOfSecContexts ; (; ); const. inline . Definition at line 252 of file TROOT.h. ◆ GetListOfSockets(). TSeqCollection * TROOT::GetListOfSockets ; (; ); const. inline . Definition at line 239 of file TROOT.h. ◆ GetListOfSpecials(). TSeqCollection * TROOT::GetListOfSpecials ; (; ); const. inline . Definition at line 246 of file TROOT.h. ◆ GetListOfStreamerInfo(). TSeqCollection * TROOT::GetListOfStreamerInfo ; (; ); const. inline . Definition at line 249 of file TROOT.h. ◆ GetListOfStyles(). TSeqCollection * TROOT::GetListOfStyles ; (; ); const. inline . Definition at line 241 of file TROOT.h. ◆ GetListOfTasks(). TSeqCollection * TROOT::GetListOfTasks ; (; ); const. inline . Definition at line 247 of file TROOT.h. ◆ GetListOfTypes(). TCollection * TROOT::GetListOfTypes ; (; Bool_t ; load = kFALSE). Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ; The list is populated on demand. Calling gROOT->GetListOfTypes()->FindObject(nameoftype);; will return the TDataType corresponding to 'nameoftype'. If the TDataType is not already in the list itself and the type does exist, a new TDataType will be created and added to the list.; Calling gROOT->GetListOfTypes()->ls(); // or Print(); list only the typedefs that have been previously accessed through the list (plus the builtins types). ; Definition at line 1865 of file TROOT.cxx. ◆ GetMacroDir(). const TString & TROOT::GetMacroDir ; (; ). static . Get the macro directory in the installation. Static utility function. ; Definition at line 3094 of file TROOT.cxx. ◆ GetMacroPath(). const char * TROOT::GetMacroPath ; (; ). static . Get macro search path. Static utility function. ; Definition at line 2762 of file TROOT.cxx. ◆ GetNclasses(). Int_t TROOT::GetNclasses ; (; ); cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:58840,load,load,58840,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,1,['load'],['load']
Performance,"line . Definition at line 250 of file TROOT.h. ◆ GetListOfProofs(). TSeqCollection * TROOT::GetListOfProofs ; (; ); const. inline . Definition at line 253 of file TROOT.h. ◆ GetListOfSecContexts(). TSeqCollection * TROOT::GetListOfSecContexts ; (; ); const. inline . Definition at line 252 of file TROOT.h. ◆ GetListOfSockets(). TSeqCollection * TROOT::GetListOfSockets ; (; ); const. inline . Definition at line 239 of file TROOT.h. ◆ GetListOfSpecials(). TSeqCollection * TROOT::GetListOfSpecials ; (; ); const. inline . Definition at line 246 of file TROOT.h. ◆ GetListOfStreamerInfo(). TSeqCollection * TROOT::GetListOfStreamerInfo ; (; ); const. inline . Definition at line 249 of file TROOT.h. ◆ GetListOfStyles(). TSeqCollection * TROOT::GetListOfStyles ; (; ); const. inline . Definition at line 241 of file TROOT.h. ◆ GetListOfTasks(). TSeqCollection * TROOT::GetListOfTasks ; (; ); const. inline . Definition at line 247 of file TROOT.h. ◆ GetListOfTypes(). TCollection * TROOT::GetListOfTypes ; (; Bool_t ; load = kFALSE). Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ; The list is populated on demand. Calling gROOT->GetListOfTypes()->FindObject(nameoftype);; will return the TDataType corresponding to 'nameoftype'. If the TDataType is not already in the list itself and the type does exist, a new TDataType will be created and added to the list.; Calling gROOT->GetListOfTypes()->ls(); // or Print(); list only the typedefs that have been previously accessed through the list (plus the builtins types). ; Definition at line 1865 of file TROOT.cxx. ◆ GetMacroDir(). const TString & TROOT::GetMacroDir ; (; ). static . Get the macro directory in the installation. Static utility function. ; Definition at line 3098 of file TROOT.cxx. ◆ GetMacroPath(). const char * TROOT::GetMacroPath ; (; ). static . Get macro search path. Static utility function. ; Definition at line 2762 of file TROOT.cxx. ◆ GetNclasses(). Int_t TROOT::GetNclasses ; (; ); cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:58809,load,load,58809,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,1,['load'],['load']
Performance,"line . Partial derivative with respect a parameter. ; Definition at line 386 of file IParamFunction.h. ◆ ParameterDerivative() [4/4]. double ROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative ; (; double ; x, . unsigned int ; ipar = 0 . ); const. inline . Evaluate partial derivative using cached parameter values. ; Definition at line 394 of file IParamFunction.h. ◆ ParameterGradient() [1/4]. void ROOT::Math::IParametricGradFunctionOneDim::ParameterGradient ; (; const double * ; x, . const double * ; p, . double * ; grad . ); const. inline . Compatibility interface with multi-dimensional functions. ; Definition at line 369 of file IParamFunction.h. ◆ ParameterGradient() [2/4]. void ROOT::Math::IParametricGradFunctionOneDim::ParameterGradient ; (; const double * ; x, . double * ; grad . ); const. inline . Evaluate all derivatives using cached parameter values (multi-dim like interface) ; Definition at line 377 of file IParamFunction.h. ◆ ParameterGradient() [3/4]. virtual void ROOT::Math::IParametricGradFunctionOneDim::ParameterGradient ; (; double ; x, . const double * ; p, . double * ; grad . ); const. inlinevirtual . Evaluate the derivatives of the function with respect to the parameters at a point x. ; It is optional to be implemented by the derived classes for better efficiency if needed ; Reimplemented in ROOT::Math::WrappedTF1.; Definition at line 351 of file IParamFunction.h. ◆ ParameterGradient() [4/4]. void ROOT::Math::IParametricGradFunctionOneDim::ParameterGradient ; (; double ; x, . double * ; grad . ); const. inline . Evaluate all derivatives using cached parameter values. ; Definition at line 361 of file IParamFunction.h. Libraries for ROOT::Math::IParametricGradFunctionOneDim:. [legend]; The documentation for this class was generated from the following file:; math/mathcore/inc/Math/IParamFunction.h. ROOTMathIParametricGradFunctionOneDim. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html:7832,cache,cached,7832,doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html,1,['cache'],['cached']
Performance,"line 100 of file LikelihoodInterval.h. ◆ fConfidenceLevel. double RooStats::LikelihoodInterval::fConfidenceLevel. private . Requested confidence level (eg. 0.95 for 95% CL) ; Definition at line 102 of file LikelihoodInterval.h. ◆ fFunctor. std::shared_ptr<RooFunctor> RooStats::LikelihoodInterval::fFunctor. private . ! transient pointer to functor class used by the minimizer ; Definition at line 106 of file LikelihoodInterval.h. ◆ fLikelihoodRatio. RooAbsReal* RooStats::LikelihoodInterval::fLikelihoodRatio. private . likelihood ratio function used to make contours (managed internally) ; Definition at line 101 of file LikelihoodInterval.h. ◆ fLowerLimits. std::map<std::string, double> RooStats::LikelihoodInterval::fLowerLimits. private . map with cached lower bound values ; Definition at line 103 of file LikelihoodInterval.h. ◆ fMinFunc. std::shared_ptr<ROOT::Math::IMultiGenFunction> RooStats::LikelihoodInterval::fMinFunc. private . ! transient pointer to the minimization function ; Definition at line 107 of file LikelihoodInterval.h. ◆ fMinimizer. std::shared_ptr<ROOT::Math::Minimizer > RooStats::LikelihoodInterval::fMinimizer. private . ! transient pointer to minimizer class used to find limits and contour ; Definition at line 105 of file LikelihoodInterval.h. ◆ fParameters. RooArgSet RooStats::LikelihoodInterval::fParameters. private . parameters of interest for this interval ; Definition at line 99 of file LikelihoodInterval.h. ◆ fUpperLimits. std::map<std::string, double> RooStats::LikelihoodInterval::fUpperLimits. private . map with cached upper bound values ; Definition at line 104 of file LikelihoodInterval.h. Libraries for RooStats::LikelihoodInterval:. [legend]; The documentation for this class was generated from the following files:; roofit/roostats/inc/RooStats/LikelihoodInterval.h; roofit/roostats/src/LikelihoodInterval.cxx. RooStatsLikelihoodInterval. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:54 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1LikelihoodInterval.html:24759,cache,cached,24759,doc/master/classRooStats_1_1LikelihoodInterval.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1LikelihoodInterval.html,1,['cache'],['cached']
Performance,"line 107 of file TMethod.cxx. ◆ GetListOfMethodArgs(). TList * TMethod::GetListOfMethodArgs ; (; ). virtual . Returns methodarg list and additionally updates fDataMember in TMethod by calling FindDataMember();. ; Definition at line 307 of file TMethod.cxx. ◆ Getter(). virtual const char * TMethod::Getter ; (; ); const. inlinevirtual . Definition at line 59 of file TMethod.h. ◆ GetterMethod(). TMethodCall * TMethod::GetterMethod ; (; ). virtual . Return call environment for the getter method in case this is a *TOGGLE method (for the context menu). ; Definition at line 264 of file TMethod.cxx. ◆ IsA(). TClass * TMethod::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFunction.; Definition at line 68 of file TMethod.h. ◆ IsMenuItem(). EMenuItemKind TMethod::IsMenuItem ; (; ); const. inline . Definition at line 56 of file TMethod.h. ◆ IsValid(). Bool_t TMethod::IsValid ; (; ). overridevirtual . Return true if this function object is pointing to a currently loaded function. ; If a function is unloaded after the TMethod is created, the TMethod will be set to be invalid. ; Reimplemented from TFunction.; Definition at line 277 of file TMethod.cxx. ◆ operator=(). TMethod & TMethod::operator= ; (; const TMethod & ; rhs). Assignment operator. ; Definition at line 68 of file TMethod.cxx. ◆ SetMenuItem() [1/2]. void TMethod::SetMenuItem ; (; const char * ; docstring). private . Set the menu item as prescribed in the doctstring. ; Definition at line 319 of file TMethod.cxx. ◆ SetMenuItem() [2/2]. virtual void TMethod::SetMenuItem ; (; EMenuItemKind ; menuItem). inlinevirtual . Definition at line 64 of file TMethod.h. ◆ SetterMethod(). TMethodCall * TMethod::SetterMethod ; (; ). virtual . Return call environment for this method in case this is a *TOGGLE method which takes a single boolean or integer argument. ; Definition at line 295 of file TMethod.cxx. ◆ Streamer(). void TMethod::Streamer ; (; TBuffer & ; R__b). overridevi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethod.html:20422,load,loaded,20422,doc/master/classTMethod.html,https://root.cern,https://root.cern/doc/master/classTMethod.html,1,['load'],['loaded']
Performance,"line 169 of file TGeoNavigator.cxx. Member Function Documentation. ◆ BuildCache(). void TGeoNavigator::BuildCache ; (; Bool_t ; dummy = kFALSE, . Bool_t ; nodeid = kFALSE . ). Builds the cache for physical nodes and global matrices. ; Definition at line 182 of file TGeoNavigator.cxx. ◆ cd(). Bool_t TGeoNavigator::cd ; (; const char * ; path = """"). Browse the tree of nodes starting from top node according to pathname. ; Changes the path accordingly. The path is changed to point to the top node in case of failure. ; Definition at line 210 of file TGeoNavigator.cxx. ◆ CdDown() [1/2]. void TGeoNavigator::CdDown ; (; Int_t ; index). Make a daughter of current node current. ; Can be called only with a valid daughter index (no check). Updates cache accordingly. ; Definition at line 313 of file TGeoNavigator.cxx. ◆ CdDown() [2/2]. void TGeoNavigator::CdDown ; (; TGeoNode * ; node). Make a daughter of current node current. ; Can be called only with a valid daughter node (no check). Updates cache accordingly. ; Definition at line 333 of file TGeoNavigator.cxx. ◆ CdNext(). void TGeoNavigator::CdNext ; (; ). Do a cd to the node found next by FindNextBoundary. ; Definition at line 405 of file TGeoNavigator.cxx. ◆ CdNode(). void TGeoNavigator::CdNode ; (; Int_t ; nodeid). Change current path to point to the node having this id. ; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons) ; Definition at line 301 of file TGeoNavigator.cxx. ◆ CdTop(). void TGeoNavigator::CdTop ; (; ). Make top level node the current node. ; Updates the cache accordingly. Determine the overlapping state of current node. ; Definition at line 386 of file TGeoNavigator.cxx. ◆ CdUp(). void TGeoNavigator::CdUp ; (; ). Go one level up in geometry. ; Updates cache accordingly. Determine the overlapping state of current node. ; Definition at line 352 of file TGeoNavigator.cxx. ◆ CheckPath(). Bool_t TGeoNavigator::CheckPath ; (; const char * ; path); const. Check if a geometry path is vali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:23926,cache,cache,23926,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['cache'],['cache']
Performance,"line 3162 of file TWinNTSystem.cxx. ◆ IsA(). TClass * TWinNTSystem::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSystem.; Definition at line 254 of file TWinNTSystem.h. ◆ IsAbsoluteFileName(). Bool_t TWinNTSystem::IsAbsoluteFileName ; (; const char * ; dir). overridevirtual . Return true if dir is an absolute pathname. ; Reimplemented from TSystem.; Definition at line 2500 of file TWinNTSystem.cxx. ◆ IsPathLocal(). Bool_t TWinNTSystem::IsPathLocal ; (; const char * ; path). overridevirtual . Returns TRUE if the url in 'path' points to the local file system. ; This is used to avoid going through the NIC card for local operations. ; Reimplemented from TSystem.; Definition at line 2584 of file TWinNTSystem.cxx. ◆ Link(). int TWinNTSystem::Link ; (; const char * ; from, . const char * ; to . ). overridevirtual . Create a link from file1 to file2. ; Reimplemented from TSystem.; Definition at line 2768 of file TWinNTSystem.cxx. ◆ Load(). int TWinNTSystem::Load ; (; const char * ; module, . const char * ; entry = """", . Bool_t ; system = kFALSE . ). overridevirtual . Load a shared library. ; Returns 0 on successful loading, 1 in case lib was already loaded and -1 in case lib does not exist or in case of error. ; Reimplemented from TSystem.; Definition at line 4141 of file TWinNTSystem.cxx. ◆ LookupSID(). Long_t TWinNTSystem::LookupSID ; (; const char * ; lpszAccountName, . int ; what, . int & ; groupIdx, . int & ; memberIdx . ). private . Take the name and look up a SID so that we can get full domain/user information. ; Definition at line 3310 of file TWinNTSystem.cxx. ◆ MakeDirectory(). int TWinNTSystem::MakeDirectory ; (; const char * ; name). overridevirtual . Make a WinNT file system directory. ; Returns 0 in case of success and -1 if the directory could not be created (either already exists or illegal path name). ; Reimplemented from TSystem.; Definition at line 1913 of file TWinNTSystem.cxx. ◆ mkdir(). int TW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:61323,Load,Load,61323,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['Load'],['Load']
Performance,"line 85 of file CpuMatrix.cxx. ◆ InitializeOneVector(). template<typename AReal > . void TMVA::DNN::TCpuMatrix< AReal >::InitializeOneVector ; (; size_t ; n). static . Definition at line 98 of file CpuMatrix.cxx. ◆ Map(). template<typename AFloat > . template<typename Function_t > . void TMVA::DNN::TCpuMatrix< AFloat >::Map ; (; Function_t & ; f). inline . Map the given function over the matrix elements. ; Executed in parallel using TThreadExecutor. ; Definition at line 212 of file CpuMatrix.h. ◆ MapFrom(). template<typename AFloat > . template<typename Function_t > . void TMVA::DNN::TCpuMatrix< AFloat >::MapFrom ; (; Function_t & ; f, . const TCpuMatrix< AFloat > & ; A . ). inline . Same as maps but takes the input values from the matrix A and writes the results in this matrix. ; Definition at line 241 of file CpuMatrix.h. ◆ operator TMatrixT(). template<typename AReal > . TMVA::DNN::TCpuMatrix< AReal >::operator TMatrixT. Convert to a TMatrixT<AFloat_t> object. ; Performs a deep copy of the matrix elements. ; Definition at line 59 of file CpuMatrix.cxx. ◆ operator()() [1/2]. template<typename AFloat > . AFloat & TMVA::DNN::TCpuMatrix< AFloat >::operator() ; (; size_t ; i, . size_t ; j . ). inline . Definition at line 162 of file CpuMatrix.h. ◆ operator()() [2/2]. template<typename AFloat > . AFloat TMVA::DNN::TCpuMatrix< AFloat >::operator() ; (; size_t ; i, . size_t ; j . ); const. inline . Return matrix element in row i and column j. ; Definition at line 161 of file CpuMatrix.h. ◆ operator=() [1/3]. template<typename AFloat > . TCpuMatrix & TMVA::DNN::TCpuMatrix< AFloat >::operator= ; (; const TCpuMatrix< AFloat > & ; ). default . ◆ operator=() [2/3]. template<typename AFloat > . TCpuMatrix< AFloat > & TMVA::DNN::TCpuMatrix< AFloat >::operator= ; (; const TMatrixT< AFloat > & ; ). copy from a TMAtrixT . ; Deep copy without re-creating a new buffer . ◆ operator=() [3/3]. template<typename AFloat > . TCpuMatrix & TMVA::DNN::TCpuMatrix< AFloat >::operator= ; (; TCpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpuMatrix.html:8822,Perform,Performs,8822,doc/master/classTMVA_1_1DNN_1_1TCpuMatrix.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpuMatrix.html,1,['Perform'],['Performs']
Performance,"line 926 of file RooTreeDataStore.cxx. ◆ reduce(). std::unique_ptr< RooAbsDataStore > RooTreeDataStore::reduce ; (; RooStringView ; name, . RooStringView ; title, . const RooArgSet & ; vars, . const RooFormulaVar * ; cutVar, . const char * ; cutRange, . std::size_t ; nStart, . std::size_t ; nStop . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 179 of file RooTreeDataStore.cxx. ◆ reset(). void RooTreeDataStore::reset ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 935 of file RooTreeDataStore.cxx. ◆ Reset(). void RooTreeDataStore::Reset ; (; Option_t * ; option = nullptr). Interface function to TTree::Reset. ; Definition at line 1104 of file RooTreeDataStore.cxx. ◆ resetBuffers(). void RooTreeDataStore::resetBuffers ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 1058 of file RooTreeDataStore.cxx. ◆ resetCache(). void RooTreeDataStore::resetCache ; (; ). overridevirtual . Remove tree with values of cached observables and clear list of cached observables. ; Implements RooAbsDataStore.; Definition at line 1018 of file RooTreeDataStore.cxx. ◆ restoreAlternateBuffers(). void RooTreeDataStore::restoreAlternateBuffers ; (; ). Definition at line 1069 of file RooTreeDataStore.cxx. ◆ row(). const RooArgSet & RooTreeDataStore::row ; (; ). inline . Definition at line 139 of file RooTreeDataStore.h. ◆ setArgStatus(). void RooTreeDataStore::setArgStatus ; (; const RooArgSet & ; set, . bool ; active . ). overridevirtual . Activate or deactivate the branch status of the TTree branch associated with the given set of dataset observables. ; Implements RooAbsDataStore.; Definition at line 999 of file RooTreeDataStore.cxx. ◆ setBranchBufferSize(). void RooTreeDataStore::setBranchBufferSize ; (; Int_t ; size). inlineprivate . Definition at line 152 of file RooTreeDataStore.h. ◆ setExternalWeightArray(). void RooTreeDataStore::setExternalWeightArray ; (; const double * ; arrayWgt, . const double * ; arrayWgtErrLo, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:36151,cache,cached,36151,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,2,['cache'],['cached']
Performance,"line axis and tick marks. void SetLabelColor(Color_t color = 1, Float_t alpha = 1.); Set color of labels. void SetLabelFont(Style_t font = 62); Set labels' font. void SetLabelOffset(Float_t offset = 0.0050000000000000001); Set distance between the axis and the labels; The distance is expressed in per cent of the pad width. void SetLabelSize(Float_t size = 0.040000000000000001); Set size of axis labels; The size is expressed in per cent of the pad width. void SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE); Set the number of divisions for this axis. if optim = kTRUE (default), the number of divisions will be; optimized around the specified value.; if optim = kFALSE, or n < 0, the axis will be forced to use; exactly n divisions. n = n1 + 100*n2 + 10000*n3. Where n1 is the number of primary divisions,; n2 is the number of second order divisions and; n3 is the number of third order divisions. e.g. 512 means 12 primary and 5 secondary divisions. If the number of divisions is ""optimized"" (see above) n1, n2, n3 are; maximum values. void SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim = kTRUE); see function above. void SetTickLength(Float_t length = 0.029999999999999999); Set tick mark length; The length is expressed in per cent of the pad width. void SetTitleOffset(Float_t offset = 1); Set distance between the axis and the axis title; Offset is a correction factor with respect to the ""standard"" value.; offset = 1 uses the default position that is computed in function; of the label offset and size.; offset = 1.2 will add 20 per cent more to the default offset. void SetTitleSize(Float_t size = 0.040000000000000001); Set size of axis title; The size is expressed in per cent of the pad width. void SetTitleColor(Color_t color = 1); Set color of axis title. void SetTitleFont(Style_t font = 62); Set the title font. void Streamer(TBuffer& ); Stream an object of class TAttAxis. TAttAxis(). Int_t GetNdivisions() const; {return fNdivisions;}. Color_t GetAxisColor() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAttAxis.html:3973,optimiz,optimized,3973,root/html602/TAttAxis.html,https://root.cern,https://root.cern/root/html602/TAttAxis.html,2,['optimiz'],['optimized']
Performance,"line below, 9 - full ouline.; fore_file specifies foreground texture of text. void Merge(const TImage* im, const char* op = ""alphablend"", Int_t x = 0, Int_t y = 0); Merge two images. op is string which specifies overlay operation. Supported operations are:; add - color addition with saturation; alphablend - alpha-blending; allanon - color values averaging; colorize - hue and saturate bottom image same as top image; darken - use lowest color value from both images; diff - use absolute value of the color difference between two images; dissipate - randomly alpha-blend images; hue - hue bottom image same as top image; lighten - use highest color value from both images; overlay - some weird image overlaying(see GIMP); saturate - saturate bottom image same as top image; screen - another weird image overlaying(see GIMP); sub - color substraction with saturation; tint - tinting image with image; value - value bottom image same as top image. void Blur(Double_t hr = 3, Double_t vr = 3); Perform Gaussian blurr of the image (usefull for drop shadows).; hr - horizontal radius of the blurr; vr - vertical radius of the blurr. TObject * Clone(const char* newname) const; Clone image. Double_t * Vectorize(UInt_t max_colors = 256, UInt_t dither = 4, Int_t opaque_threshold = 1); Reduce colordepth of an image and fills vector of ""scientific data""; [0...1]. Colors are reduced by allocating colorcells to most used colors first,; and then approximating other colors with those allocated.; max_colors - maximum size of the colormap.; dither - number of bits to strip off the color data ( 0...7 ); opaque_threshold - alpha channel threshold at which pixel should be; treated as opaque. void HSV(UInt_t hue = 0, UInt_t radius = 360, Int_t H = 0, Int_t S = 0, Int_t V = 0, Int_t x = 0, Int_t y = 0, UInt_t width = 0, UInt_t height = 0); This function will tile original image to specified size with offsets; requested, and then it will go though it and adjust hue, saturation and; value of those pixels th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TASImage.html:33423,Perform,Perform,33423,root/html534/TASImage.html,https://root.cern,https://root.cern/root/html534/TASImage.html,3,['Perform'],['Perform']
Performance,"line below, 9 - full ouline.; fore_file specifies foreground texture of text. void Merge(const TImage* im, const char* op = ""alphablend"", Int_t x = 0, Int_t y = 0); Merge two images. op is string which specifies overlay operation. Supported operations are:; add - color addition with saturation; alphablend - alpha-blending; allanon - color values averaging; colorize - hue and saturate bottom image same as top image; darken - use lowest color value from both images; diff - use absolute value of the color difference between two images; dissipate - randomly alpha-blend images; hue - hue bottom image same as top image; lighten - use highest color value from both images; overlay - some wierd image overlaying(see GIMP); saturate - saturate bottom image same as top image; screen - another wierd image overlaying(see GIMP); sub - color substraction with saturation; tint - tinting image with image; value - value bottom image same as top image. void Blur(Double_t hr = 3, Double_t vr = 3); Perform Gaussian blurr of the image (usefull for drop shadows).; hr - horizontal radius of the blurr; vr - vertical radius of the blurr. TObject * Clone(const char* newname) const; Clone image. Double_t * Vectorize(UInt_t max_colors = 256, UInt_t dither = 4, Int_t opaque_threshold = 1); Reduce colordepth of an image and fills vector of ""scientific data""; [0...1]. Colors are reduced by allocating colorcells to most used colors first,; and then approximating other colors with those allocated.; max_colors - maximum size of the colormap.; dither - number of bits to strip off the color data ( 0...7 ); opaque_threshold - alpha channel threshold at which pixel should be; treated as opaque. void HSV(UInt_t hue = 0, UInt_t radius = 360, Int_t H = 0, Int_t S = 0, Int_t V = 0, Int_t x = 0, Int_t y = 0, UInt_t width = 0, UInt_t height = 0); This function will tile original image to specified size with offsets; requested, and then it will go though it and adjust hue, saturation and; value of those pixels th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TASImage.html:32181,Perform,Perform,32181,root/html526/TASImage.html,https://root.cern,https://root.cern/root/html526/TASImage.html,4,['Perform'],['Perform']
Performance,"line group of the ALICE experiment. He is an experimental nuclear physicist who worked before ALICE on data analysis for heavy-ion experiments in emulsions. In 2000 he started collaborating with the ROOT project and implemented the TreeViewer interface. Andrei is the main developer of the ROOT geometry package. He integrated the geometry in the Virtual Monte Carlo framework by developing interfaces for the GEANT3, GEANT4 and FLUKA particle transport engines.; Anna Kreshuk; Anna was a project associate and contributed to different parts of ROOT, most notably to the fitting machinery, the interface to FFTW, numerous math-related functions, TEntryList container and PROOF GUI.; David Gonzalez Maline; David has been working on improving the performance and correctness of various mathematical algorithms as well as on integrating AI methods for data analysis inside the framework. He has also worked on extending and improving the FitPanel interface.; Diego Marcos Segura; Diego worked as technical student on CINT dictionary optimizations.; Eddy Offermann; Eddy joined the ROOT team during a sabbatical to work on making the ROOT matrix package the fastest and most versatile in the industry.; Ilka Antcheva; Ilka has been working from 2002 to 2008 in the ROOT team. She was responsible for the GUI system and designed many high level user interfaces and widgets, like found in many modern graphics applications: ROOT graphics editor (GED) and various object editors, Fit Panel, Style manager, a tool for automatic C++ code generation of any widget and the capability for widgets to save themselves. In addition Ilka took care of the ROOT Users Guide and contributed the chapter ‘Writing a Graphical User Interface’.; Gerardo Ganis; Gerri was a team member for more than ten years; among many other contributions he was in charge of PROOF for many years.; Jan Iwaszkiewicz; Jan was working in the context of a Ph.D. on scheduling and load-balancing of distributed processing in the Parallel ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/previous-developers.html:3103,optimiz,optimizations,3103,d/previous-developers.html,https://root.cern,https://root.cern/d/previous-developers.html,1,['optimiz'],['optimizations']
Performance,"line.; 773 ; 774### Distributed Snapshot; 775 ; 776The Snapshot operation behaves slightly differently when executed distributedly. First off, it requires the path; 777supplied to the Snapshot call to be accessible from any worker of the cluster and from the client machine (in general; 778it should be provided as an absolute path). Another important difference is that `n` separate files will be produced,; 779where `n` is the number of dataset partitions. As with local RDataFrame, the result of a Snapshot on a distributed; 780RDataFrame is another distributed RDataFrame on which we can define a new computation graph and run more distributed; 781computations.; 782 ; 783### Distributed RunGraphs; 784 ; 785Submitting multiple distributed RDataFrame executions is supported through the RunGraphs function. Similarly to its; 786local counterpart, the function expects an iterable of objects representing an RDataFrame action. Each action will be; 787triggered concurrently to send multiple computation graphs to a distributed cluster at the same time:; 788 ; 789~~~{.py}; 790import ROOT; 791RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; 792RunGraphs = ROOT.RDF.Experimental.Distributed.RunGraphs; 793 ; 794# Create 3 different dataframes and book an histogram on each one; 795histoproxies = [; 796 RDataFrame(100); 797 .Define(""x"", ""rdfentry_""); 798 .Histo1D((""name"", ""title"", 10, 0, 100), ""x""); 799 for _ in range(4); 800]; 801 ; 802# Execute the 3 computation graphs; 803RunGraphs(histoproxies); 804# Retrieve all the histograms in one go; 805histos = [histoproxy.GetValue() for histoproxy in histoproxies]; 806~~~; 807 ; 808Every distributed backend supports this feature and graphs belonging to different backends can be still triggered with; 809a single call to RunGraphs (e.g. it is possible to send a Spark job and a Dask job at the same time).; 810 ; 811### Histogram models in distributed mode; 812 ; 813When calling a Histo*D operation in distributed mode, remember to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:45787,concurren,concurrently,45787,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['concurren'],['concurrently']
Performance,"line.; 813 ; 814### Distributed Snapshot; 815 ; 816The Snapshot operation behaves slightly differently when executed distributedly. First off, it requires the path; 817supplied to the Snapshot call to be accessible from any worker of the cluster and from the client machine (in general; 818it should be provided as an absolute path). Another important difference is that `n` separate files will be produced,; 819where `n` is the number of dataset partitions. As with local RDataFrame, the result of a Snapshot on a distributed; 820RDataFrame is another distributed RDataFrame on which we can define a new computation graph and run more distributed; 821computations.; 822 ; 823### Distributed RunGraphs; 824 ; 825Submitting multiple distributed RDataFrame executions is supported through the RunGraphs function. Similarly to its; 826local counterpart, the function expects an iterable of objects representing an RDataFrame action. Each action will be; 827triggered concurrently to send multiple computation graphs to a distributed cluster at the same time:; 828 ; 829~~~{.py}; 830import ROOT; 831RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; 832RunGraphs = ROOT.RDF.Experimental.Distributed.RunGraphs; 833 ; 834# Create 3 different dataframes and book an histogram on each one; 835histoproxies = [; 836 RDataFrame(100); 837 .Define(""x"", ""rdfentry_""); 838 .Histo1D((""name"", ""title"", 10, 0, 100), ""x""); 839 for _ in range(4); 840]; 841 ; 842# Execute the 3 computation graphs; 843RunGraphs(histoproxies); 844# Retrieve all the histograms in one go; 845histos = [histoproxy.GetValue() for histoproxy in histoproxies]; 846~~~; 847 ; 848Every distributed backend supports this feature and graphs belonging to different backends can be still triggered with; 849a single call to RunGraphs (e.g. it is possible to send a Spark job and a Dask job at the same time).; 850 ; 851### Histogram models in distributed mode; 852 ; 853When calling a Histo*D operation in distributed mode, remember to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:47427,concurren,concurrently,47427,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['concurren'],['concurrently']
Performance,"lineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:138010,cache,cache,138010,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['cache'],['cache']
Performance,"lineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TDirectory.; Definition at line 281 of file TROOT.h. ◆ IsInterrupted(). Bool_t TROOT::IsInterrupted ; (; ); const. inline . Definition at line 282 of file TROOT.h. ◆ IsLineProcessing(). Bool_t TROOT::IsLineProcessing ; (; ); const. inline . Definition at line 284 of file TROOT.h. ◆ IsProofServ(). Bool_t TROOT::IsProofServ ; (; ); const. inline . Definition at line 285 of file TROOT.h. ◆ IsRootFile(). Bool_t TROOT::IsRootFile ; (; const char * ; filename); const. Return true if the file is local and is (likely) to be a ROOT file. ; Definition at line 2230 of file TROOT.cxx. ◆ IsWebDisplay(). Bool_t TROOT::IsWebDisplay ; (; ); const. inline . Definition at line 287 of file TROOT.h. ◆ IsWebDisplayBatch(). Bool_t TROOT::IsWebDisplayBatch ; (; ); const. inline . Definition at line 288 of file TROOT.h. ◆ LoadClass() [1/2]. Int_t TROOT::LoadClass ; (; const char * ; classname, . const char * ; libname, . Bool_t ; check = kFALSE . ). Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ; If not it will load library ""libname"". If the library couldn't be found with original libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again. If DynamicPathName still couldn't find the library, return -1. If check is true it will only check if libname exists and is readable. Returns 0 on successful loading, -1 in case libname does not exist or in case of error and -2 in case of version mismatch. ; Definition at line 2183 of file TROOT.cxx. ◆ LoadClass() [2/2]. TClass * TROOT::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent = kFALSE . ); const. Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:66057,Load,LoadClass,66057,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,2,['Load'],['LoadClass']
Performance,"lineprotected . Definition at line 348 of file TBufferXML.h. ◆ GetInfo(). TVirtualStreamerInfo * TBufferXML::GetInfo ; (; ). finalvirtual . Return current streamer info element. ; Implements TBuffer.; Definition at line 3171 of file TBufferXML.cxx. ◆ GetIOVersion(). Int_t TBufferXML::GetIOVersion ; (; ); const. inline . Definition at line 65 of file TBufferXML.h. ◆ IncrementLevel(). void TBufferXML::IncrementLevel ; (; TVirtualStreamerInfo * ; info). finalvirtual . Function is called from TStreamerInfo WriteBuffer and ReadBuffer functions and indent new level in xml structure. ; This call indicates, that TStreamerInfo functions starts streaming object data of correspondent class ; Implements TBuffer.; Definition at line 855 of file TBufferXML.cxx. ◆ IsA(). TClass * TBufferXML::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TBufferText.; Definition at line 332 of file TBufferXML.h. ◆ PerformPostProcessing(). void TBufferXML::PerformPostProcessing ; (; ). protected . Function is converts TObject and TString structures to more compact representation. ; Definition at line 1203 of file TBufferXML.cxx. ◆ PerformPreProcessing(). void TBufferXML::PerformPreProcessing ; (; const TStreamerElement * ; elem, . XMLNodePointer_t ; elemnode . ). protected . Function is unpack TObject and TString structures to be able read them from custom streamers of this objects. ; Definition at line 1321 of file TBufferXML.cxx. ◆ PopStack(). TXMLStackObj * TBufferXML::PopStack ; (; ). protected . Remove one level from xml stack. ; Definition at line 312 of file TBufferXML.cxx. ◆ ProcessPointer(). Bool_t TBufferXML::ProcessPointer ; (; const void * ; ptr, . XMLNodePointer_t ; node . ). protected . Add ""ptr"" attribute to node, if ptr is null or if ptr is pointer on object, which is already saved in buffer Automatically add ""ref"" attribute to node, where referenced object is stored. ; Definition at line 523 of file TBufferXML.cxx. ◆ PushStack",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferXML.html:62534,Perform,PerformPostProcessing,62534,doc/master/classTBufferXML.html,https://root.cern,https://root.cern/doc/master/classTBufferXML.html,1,['Perform'],['PerformPostProcessing']
Performance,"linestaticconstexpr . ReturnsVersion of this class ; Definition at line 110 of file RooIntegralMorph.h. ◆ clone(). TObject * RooIntegralMorph::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 35 of file RooIntegralMorph.h. ◆ createCache(). RooAbsCachedPdf::PdfCacheElem * RooIntegralMorph::createCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Create and return a derived MorphCacheElem. ; Reimplemented from RooAbsCachedPdf.; Definition at line 210 of file RooIntegralMorph.cxx. ◆ DeclFileName(). static const char * RooIntegralMorph::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 110 of file RooIntegralMorph.h. ◆ evaluate(). double RooIntegralMorph::evaluate ; (; ); const. overrideprotectedvirtual . Dummy. ; Implements RooAbsReal.; Definition at line 656 of file RooIntegralMorph.cxx. ◆ fillCacheObject(). void RooIntegralMorph::fillCacheObject ; (; PdfCacheElem & ; cache); const. overrideprotectedvirtual . Fill the cache with the interpolated shape. ; Implements RooAbsCachedPdf.; Definition at line 178 of file RooIntegralMorph.cxx. ◆ inputBaseName(). const char * RooIntegralMorph::inputBaseName ; (; ); const. overrideprotectedvirtual . Return base name component for cache components in this case a string encoding the names of both end point p.d.f.s. ; Implements RooAbsCachedPdf.; Definition at line 165 of file RooIntegralMorph.cxx. ◆ IsA(). TClass * RooIntegralMorph::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedPdf.; Definition at line 110 of file RooIntegralMorph.h. ◆ preferredObservableScanOrder(). void RooIntegralMorph::preferredObservableScanOrder ; (; const RooArgSet & ; obs, . RooArgSet & ; orderedObs . ); const. overridevirtual . Indicate to the RooAbsCachedPdf base class that for the filling of the cache the traversal of the x should be in the i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:84011,cache,cache,84011,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cache']
Performance,"linevirtual . Definition at line 221 of file TEveCaloData.h. ◆ GetPhiLimits(). virtual void TEveCaloData::GetPhiLimits ; (; Double_t & ; min, . Double_t & ; max . ); const. pure virtual . Implemented in TEveCaloDataVec, and TEveCaloDataHist. ◆ GetSliceColor(). Color_t TEveCaloData::GetSliceColor ; (; Int_t ; slice); const. Get color for given slice. ; Definition at line 338 of file TEveCaloData.cxx. ◆ GetSliceThreshold(). Float_t TEveCaloData::GetSliceThreshold ; (; Int_t ; slice); const. Get threshold for given slice. ; Definition at line 318 of file TEveCaloData.cxx. ◆ GetSliceTransparency(). Char_t TEveCaloData::GetSliceTransparency ; (; Int_t ; slice); const. Get transparency for given slice. ; Definition at line 358 of file TEveCaloData.cxx. ◆ GetWrapTwoPi(). Bool_t TEveCaloData::GetWrapTwoPi ; (; ); const. inline . Definition at line 227 of file TEveCaloData.h. ◆ InvalidateUsersCellIdCache(). void TEveCaloData::InvalidateUsersCellIdCache ; (; ). virtual . Invalidate cell ids cache on back ptr references. ; Definition at line 366 of file TEveCaloData.cxx. ◆ IsA(). TClass * TEveCaloData::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TEveElement.; Reimplemented in TEveCaloDataVec, and TEveCaloDataHist.; Definition at line 233 of file TEveCaloData.h. ◆ operator=(). TEveCaloData & TEveCaloData::operator= ; (; const TEveCaloData & ; ). private . ◆ PrintCellsSelected(). void TEveCaloData::PrintCellsSelected ; (; ). Print selected cells info. ; Definition at line 189 of file TEveCaloData.cxx. ◆ ProcessSelection(). void TEveCaloData::ProcessSelection ; (; vCellId_t & ; sel_cells, . TGLSelectRecord & ; rec . ). Process newly selected cells with given select-record. ; Secondary-select status is set. CellSelectionChanged() is called if needed. ; Definition at line 207 of file TEveCaloData.cxx. ◆ Rebin(). virtual void TEveCaloData::Rebin ; (; TAxis * ; ax, . TAxis * ; ay, . vCellId_t & ; in, . Bool_t ; et, . RebinDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloData.html:39140,cache,cache,39140,doc/master/classTEveCaloData.html,https://root.cern,https://root.cern/doc/master/classTEveCaloData.html,1,['cache'],['cache']
Performance,"ling.cxx:579; RegisterPreIncludedHeadersstatic void RegisterPreIncludedHeaders(cling::Interpreter &clingInterp)Definition TCling.cxx:1299; hasParsedRootmapForLibrarystatic bool hasParsedRootmapForLibrary(llvm::StringRef lib)Definition TCling.cxx:7252; TCling__InvalidateGlobalvoid TCling__InvalidateGlobal(const clang::Decl *D)Definition TCling.cxx:574; TClingLookupHelper__AutoParsebool TClingLookupHelper__AutoParse(const char *cname)Allow calling autoparsing from TMetaUtils.Definition TCling.cxx:894; optindR__EXTERN int optindDefinition TCling.cxx:317; TCling__LockCompilationDuringUserCodeExecutionvoid * TCling__LockCompilationDuringUserCodeExecution()Lock the interpreter.Definition TCling.cxx:368; TCling__UpdateListsOnUnloadedvoid TCling__UpdateListsOnUnloaded(const cling::Transaction &T)Definition TCling.cxx:569; TCling__GetNormalizedContextvoid TCling__GetNormalizedContext(const ROOT::TMetaUtils::TNormalizedCtxt *&normCtxt)Definition TCling.cxx:557; TCling__LoadLibraryint TCling__LoadLibrary(const char *library)Load a library.Definition TCling.cxx:333; TCling__DEBUG__dumpvoid TCling__DEBUG__dump(clang::DeclContext *DC)Definition TCling.cxx:224; ETupleOrderingETupleOrderingCheck in what order the member of a tuple are layout.Definition TCling.cxx:3905; ETupleOrdering::kAscending@ kAscending; ETupleOrdering::kDescending@ kDescending; ETupleOrdering::kUnexpected@ kUnexpected; TCling__LibraryLoadingFailedbool TCling__LibraryLoadingFailed(const std::string &errmessage, const std::string &libStem, bool permanent, bool resolved)Lookup libraries in LD_LIBRARY_PATH and DYLD_LIBRARY_PATH with mangled_name, which is extracted by er...Definition TCling.cxx:351; gIgnoredPCMNamesstatic const std::unordered_set< std::string > gIgnoredPCMNamesList of dicts that have the PCM information already in the PCH.Definition TCling.cxx:1939; s_IsLibraryLoadedstatic Bool_t s_IsLibraryLoaded(const char *libname, cling::Interpreter *fInterpreter)Definition TCling.cxx:3129; TCling__GetClassShar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:377593,Load,Load,377593,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['Load']
Performance,"ling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());; 1846 LoadPCMImpl(pcmMemFile);; 1847 // Currently the module file are never unloaded (even if the library is; 1848 // unloaded) and, of course, never reloaded.; 1849 // Consequently, we must NOT remove the `pendingRdict` from the list; 1850 // of pending dictionary, otherwise if a library is unloaded and then; 1851 // reload we will be unable to update properly the TClass object; 1852 // (because we wont be able to load the rootpcm file by executing the; 1853 // above lines); 1854 ; 1855 return;; 1856 }; 1857 ; 1858 if (!llvm::sys::fs::exists(pcmFileNameFullPath)) {; 1859 ::Error(""TCling::LoadPCM"", ""ROOT PCM %s file does not exist"",; 1860 pcmFileNameFullPath.data());; 1861 if (!fPendingRdicts.empty()); 1862 for (const auto &rdict : fPendingRdicts); 1863 ::Info(""TCling::LoadPCM"", ""In-memory ROOT PCM candidate %s\n"",; 1864 rdict.first.c_str());; 1865 return;; 1866 }; 1867 ; 1868 if (!gROOT->IsRootFile(pcmFileName)) {; 1869 Fatal(""LoadPCM"", ""The file %s is not a ROOT as was expected\n"", pcmFileName.Data());; 1870 return;; 1871 }; 1872 TFile pcmFile(pcmFileName + ""?filetype=pcm"", ""READ"");; 1873 LoadPCMImpl(pcmFile);; 1874}; 1875 ; 1876//______________________________________________________________________________; 1877 ; 1878namespace {; 1879 using namespace clang;; 1880 ; 1881 class ExtLexicalStorageAdder: public RecursiveASTVisitor<ExtLexicalStorageAdder>{; 1882 // This class is to be considered an helper for autoparsing.; 1883 // It visits the AST and marks all classes (in all of their redeclarations); 1884 // with the setHasExternalLexicalStorage method.; 1885 public:; 1886 bool VisitRecordDecl(clang::RecordDecl* rcd){; 1887 if (gDebug > 2); 1888 Info(""ExtLexicalStorageAdder"",; 1889 ""Adding external lexical storage to class %s"",; 1890 rcd->getNameAsString().c_str());; 1891 auto reDeclPtr = rcd->getMostRecentDecl();; 1892 do {; 1893 reDeclPtr->setHasExternalLexicalStorage();; 1894 } while ((reDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:70469,Load,LoadPCM,70469,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadPCM']
Performance,"lingInputTString fClingInput! Input function passed to ClingDefinition TFormula.h:93; TFormula::PrepareEvalMethodBool_t PrepareEvalMethod()Sets TMethodCall to function inside Cling environment.Definition TFormula.cxx:861; TFormula::fNumberInt_t fNumberNumber used to identify pre-defined functions (gaus, expo,..)Definition TFormula.h:151; TFormula::GetGradientFuncNamestd::string GetGradientFuncName() constDefinition TFormula.h:128; TFormula::fIsCladRuntimeIncludedstatic bool fIsCladRuntimeIncludedDefinition TFormula.h:111; TFormula::CladStoragestd::vector< Double_t > CladStorageDefinition TFormula.h:184; TFormula::GetVariableDouble_t GetVariable(const char *name) constReturns variable value.Definition TFormula.cxx:2686; TFormula::fFuncsstd::list< TFormulaFunction > fFuncs!Definition TFormula.h:143; TFormula::fAllParametersSettedBool_t fAllParametersSettedFlag to control if all parameters are setted.Definition TFormula.h:98; TFormula::ProcessFormulavoid ProcessFormula(TString &formula)Iterates through functors in fFuncs and performs the appropriate action.Definition TFormula.cxx:2077; TFormula::IsOperatorstatic Bool_t IsOperator(const char c)Definition TFormula.cxx:286; TFormula::HasHessianGenerationFailedbool HasHessianGenerationFailed() constDefinition TFormula.h:137; TFormula::SetVectorizedvoid SetVectorized(Bool_t vectorized)Definition TFormula.cxx:3046; TFormula::FillVecFunctionsShurtCutsvoid FillVecFunctionsShurtCuts()Fill the shortcuts for vectorized functions We will replace for example sin with vecCore::Mat::Sin.Definition TFormula.cxx:970; TFormula::GetParNameconst char * GetParName(Int_t ipar) constReturn parameter name given by integer.Definition TFormula.cxx:2859; TFormula::fVarsstd::map< TString, TFormulaVariable > fVars! List of variable namesDefinition TFormula.h:144; TFormula::fFuncPtrCallFuncSignature fFuncPtr! Function pointer, owned by the JIT.Definition TFormula.h:107; TFormula::HandlePolNvoid HandlePolN(TString &formula)Handling polN If before 'po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:158740,perform,performs,158740,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['perform'],['performs']
Performance,list of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooArgSet_emptySetSupports named argument constructor; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_extended; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization ; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNLLVar.html:33311,cache,cache,33311,root/html526/RooNLLVar.html,https://root.cern,https://root.cern/root/html526/RooNLLVar.html,1,['cache'],['cache']
Performance,list of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooArgSet_emptySetSupports named argument constructor; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_extended; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNLLVar.html:33818,cache,cache,33818,root/html528/RooNLLVar.html,https://root.cern,https://root.cern/root/html528/RooNLLVar.html,2,['cache'],['cache']
Performance,"list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the name of the given include file corresponds to a class that; is known to ROOT, e.g. ""TLorentzVector.h"" versus TLorentzVector. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:26700,Load,Load,26700,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,3,['Load'],['Load']
Performance,"list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5749 of file TClass.cxx. ◆ LoadClassCustom(). TClass * TClass::LoadClassCustom ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5801 of file TClass.cxx. ◆ LoadClassDefault(). TClass * TClass::LoadClassDefault ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the TClassTable or the autoloader. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5771 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data from the clang pcm. If further calls to this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set to false. ; Definition at line 5824 of file TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). If options contains 'streamerinfo', run ls on the list of streamerInfos and the list of conversion streamerInfos. ; Reimplemented from TObject.; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:102790,load,load,102790,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['load']
Performance,"list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5816 of file TClass.cxx. ◆ LoadClassCustom(). TClass * TClass::LoadClassCustom ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5868 of file TClass.cxx. ◆ LoadClassDefault(). TClass * TClass::LoadClassDefault ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the TClassTable or the autoloader. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5838 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data from the clang pcm. If further calls to this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set to false. ; Definition at line 5891 of file TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). If options contains 'streamerinfo', run ls on the list of streamerInfos and the list of conversion streamerInfos. ; Reimplemented from TObject.; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:102791,load,load,102791,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['load']
Performance,"list of leaves of the current tree. ;  ; Double_t GetMaximum (const char *columname) override;  Return maximum of column with name columname. ;  ; Double_t GetMinimum (const char *columname) override;  Return minimum of column with name columname. ;  ; Int_t GetNbranches () override;  Return the number of branches of the current tree. ;  ; Int_t GetNtrees () const;  ; Long64_t GetReadEntry () const override;  See TTree::GetReadEntry(). ;  ; TList * GetStatus () const;  ; TTree * GetTree () const override;  ; Int_t GetTreeNumber () const override;  ; Long64_t * GetTreeOffset () const;  ; Int_t GetTreeOffsetLen () const;  ; Double_t GetWeight () const override;  Return the chain weight. ;  ; bool InPlaceClone (TDirectory *newdirectory, const char *options="""") override;  Move content to a new file. (NOT IMPLEMENTED for TChain) ;  ; TClass * IsA () const override;  ; Int_t LoadBaskets (Long64_t maxmemory) override;  Dummy function. ;  ; Long64_t LoadTree (Long64_t entry) override;  Find the tree which contains entry, and set it as the current tree. ;  ; void Lookup (bool force=false);  Check / locate the files in the chain. ;  ; virtual void Loop (Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED) ;  ; void ls (Option_t *option="""") const override;  List the chain. ;  ; virtual Long64_t Merge (const char *name, Option_t *option="""");  Merge all the entries in the chain into a new tree in a new file. ;  ; Long64_t Merge (TCollection *list, Option_t *option="""") override;  Merge all chains in the collection. (NOT IMPLEMENTED) ;  ; Long64_t Merge (TCollection *list, TFileMergeInfo *info) override;  Merge all chains in the collection. (NOT IMPLEMENTED) ;  ; virtual Long64_t Merge (TFile *file, Int_t basketsize, Option_t *option="""");  Merge all the entries in the chain into a new tree in the current file. ;  ; void Print (Option_t *option="""") const override;  Print the header infor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:7441,Load,LoadTree,7441,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['Load'],['LoadTree']
Performance,"list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooAbsData *dset;  ;  R__DEPRECATED (6, 36, ""Use observabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:44267,cache,caches,44267,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['cache'],['caches']
Performance,"list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:34631,cache,caches,34631,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,132,['cache'],['caches']
Performance,"list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; virtual void setCachedValue (double, bool=true);  Overwrite the current value stored in this object, making it look like this object computed that value. ;  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStringVar.html:18928,cache,caches,18928,doc/master/classRooStringVar.html,https://root.cern,https://root.cern/doc/master/classRooStringVar.html,1,['cache'],['caches']
Performance,"list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; virtual void setCachedValue (double, bool=true);  Overwrite the current value stored in this object, making it look like this object computed that value. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:22447,cache,caches,22447,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['caches']
Performance,"list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:38596,cache,caches,38596,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['cache'],['caches']
Performance,"list of proxies; map<pair<string,int>,BoxInfo*>_rangeBoxInfo; Double_tRooAbsPdf::_rawValue; vector<Double_t>_rho; TMatrixD*_rotMat; Bool_t_rotate; vector<Int_t>_sIdcs; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; vector<Double_t>_sigma; Double_t_sigmaAvgR; TVectorD*_sigmaR; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Double_t_sqrt2pi; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooListProxy_varList; vector<string>_varName; Bool_t_verbose; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; map<Int_t,Double_t>_wMap; vector<vector<Double_t> >*_weights!; vector<vector<Double_t> >_weights0; vector<vector<Double_t> >_weights1; Double_t_widthFactor; vector<Double_t>_x; vector<Double_t>_x0; vector<Double_t>_x1; vector<Double_t>_x2; vector<Double_t>_xDatHi; vector<Double_t>_xDatHi3s; vector<Double_t>_xDatLo; vector<Double_t>_xDatLo3s; vector<Double_t>_xVarHi; vector<Double_t>_xVarHiM3s; vector<Double_t>_x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNDKeysPdf.html:41505,cache,cache,41505,root/html526/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html526/RooNDKeysPdf.html,2,['cache'],['cache']
Performance,"list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooArgSet * _ccdCloneSet;  ; bool _ccdRefresh;  ; RooSuperCategory * _ccdSuper;  SuperCategory of Common category dependents. ;  ; double * _ccdTable;  ; RooArgSet _commonCats;  Common category dependents. ;  ; std::list< std::unique_ptr< RooAbsGenContext > > _gcList;  List of component generator contexts. ;  ; RooArgSet _ownedMultiProds;  Owned auxiliary multi-term product PDFs. ;  ; const RooProdPdf * _pdf;  Original PDF. ;  ; RooRealIntegral * _pdfCcdInt;  ; RooAbsPdf * _pdfClone;  ; RooArgSet * _pdfCloneSet;  ; RooArgSet _uniObs;  Observable to be generated with flat distribution. ;  ;  Protected Attributes inherited from RooAbsGenContext; UInt_t _expectedEvents;  Number of expected events from extended p.d.f. ;  ; RooAbsPdf::ExtendMode _extendMode;  Extended mode capabilities of p.d.f. ;  ; RooDataSet * _genData = nullptr;  ! Data being generated ;  ; bool _isValid;  Is context in valid state? ;  ; Int_t _nextProtoIndex;  Next prototype event to load according to LUT. ;  ; TString _normRange;  Normalization range of pdf. ;  ; std::vector< Int_t > _protoOrder;  LUT with traversal order of prototype data. ;  ; const RooDataSet * _prototype;  Pointer to prototype dataset. ;  ; RooArgSet _protoVars;  Prototype observables. ;  ; RooArgSet _theEvent;  Pointer to observable event being generated. ;  ; bool _verbose;  Verbose messaging? ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 ))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdGenContext.html:15780,load,load,15780,doc/master/classRooProdGenContext.html,https://root.cern,https://root.cern/doc/master/classRooProdGenContext.html,1,['load'],['load']
Performance,"listDouble_t * fPARSplistDefinition TMinuit.h:124; TMinuit::fApsiDouble_t fApsiDefinition TMinuit.h:54; TMinuit::fBigedmDouble_t fBigedmDefinition TMinuit.h:61; TMinuit::~TMinuit~TMinuit() overrideMinuit default destructor.Definition TMinuit.cxx:497; TMinuit::fCstatuTString fCstatuDefinition TMinuit.h:167; TMinuit::fNwrmesInt_t fNwrmes[2]Definition TMinuit.h:151; TMinuit::fVlimloDouble_t fVlimloDefinition TMinuit.h:58; TMinuit::mnrazzvirtual void mnrazz(Double_t ynew, Double_t *pnew, Double_t *y, Int_t &jh, Int_t &jl)Called only by MNSIMP (and MNIMPR) to add a new point.Definition TMinuit.cxx:6568; TMinuit::fChptchar * fChptDefinition TMinuit.h:164; TMinuit::fIsysrdInt_t fIsysrdDefinition TMinuit.h:131; TMinuit::fXdircrDouble_t fXdircrDefinition TMinuit.h:65; TMinuit::mnmnosvirtual void mnmnos()Performs a MINOS error analysis.Definition TMinuit.cxx:5388; TMinuit::fUpdfltDouble_t fUpdfltDefinition TMinuit.h:62; TMinuit::mnlinevirtual void mnline(Double_t *start, Double_t fstart, Double_t *step, Double_t slope, Double_t toler)Perform a line search from position START.Definition TMinuit.cxx:4736; TMinuit::fNpfixInt_t fNpfixDefinition TMinuit.h:37; TMinuit::fMaxextInt_t fMaxextDefinition TMinuit.h:42; TMinuit::fNvarlInt_t * fNvarlDefinition TMinuit.h:126; TMinuit::mncuvevirtual void mncuve()Makes sure that the current point is a local minimum.Definition TMinuit.cxx:2130; TMinuit::fMATUvlineDouble_t * fMATUvlineDefinition TMinuit.h:107; TMinuit::fBlimDouble_t * fBlimDefinition TMinuit.h:70; TMinuit::fVthmatDouble_t * fVthmatDefinition TMinuit.h:90; TMinuit::mnscanvirtual void mnscan()Scans the values of FCN as a function of one parameter.Definition TMinuit.cxx:6708; TMinuit::fCundefTString fCundefDefinition TMinuit.h:170; TMinuit::fMIGRflnuDouble_t * fMIGRflnuDefinition TMinuit.h:108; TMinuit::fNfcnlcInt_t fNfcnlcDefinition TMinuit.h:147; TMinuit::fISWInt_t fISW[7]Definition TMinuit.h:141; TMinuit::fHESSyyDouble_t * fHESSyyDefinition TMinuit.h:104; TMinuit::fGraphicsMode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:263244,Perform,Perform,263244,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['Perform'],['Perform']
Performance,"lit also, and a split level of 3 its data members objects, will be split. As the split-level increases so does the splitting depth. The ROOT default for the split-level is 99. This means the object will be split to the maximum.; 12.10.1.1 Memory Considerations when Splitting a Branch; Splitting a branch can quickly generate many branches. Each branch has its own buffer in memory. In case of many branches (say more than 100), you should adjust the buffer size accordingly. A recommended buffer size is 32000 bytes if you have less than 50 branches. Around 16000 bytes if you have less than 100 branches and 4000 bytes if you have more than 500 branches. These numbers are recommended for computers with memory size ranging from 32MB to 256MB. If you have more memory, you should specify larger buffer sizes. However, in this case, do not forget that your file might be used on another machine with a smaller memory configuration.; 12.10.1.2 Performance Considerations when Splitting a Branch; A split branch is faster to read, but slightly slower to write. The reading is quicker because variables of the same type are stored consecutively and the type does not have to be read each time. It is slower to write because of the large number of buffers as described above. See ""; Performance Benchmarks"" for performance impact of split and non-split mode.; 12.10.1.3 Rules for Splitting; When splitting a branch, variables of different types are handled differently. Here are the rules that apply when splitting a branch. If a data member is a basic type, it becomes one branch of class TBranchElement.; A data member can be an array of basic types. In this case, one single branch is created for the array.; A data member can be a pointer to an array of basic types. The length can vary, and must be specified in the comment field of the data member in the class definition. See “Input/Output”.; Pointer data member are not split, except for pointers to a TClonesArray. The TClonesArray (pointed to) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:544363,Perform,Performance,544363,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Perform'],['Performance']
Performance,"lity interface with multi-dimensional functions. ;  ; double ParameterDerivative (const double *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values (multi-dim like interface) ;  ; double ParameterDerivative (double x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter. ;  ; double ParameterDerivative (double x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; void ParameterGradient (const double *x, const double *p, double *grad) const;  Compatibility interface with multi-dimensional functions. ;  ; void ParameterGradient (const double *x, double *grad) const;  Evaluate all derivatives using cached parameter values (multi-dim like interface) ;  ; virtual void ParameterGradient (double x, const double *p, double *grad) const;  Evaluate the derivatives of the function with respect to the parameters at a point x. ;  ; void ParameterGradient (double x, double *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual std::string ParameterName (unsigned int i) const;  Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ;  ;  Public Member Functions inherited from ROOT::Mat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Polynomial.html:4770,cache,cached,4770,doc/master/classROOT_1_1Math_1_1Polynomial.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Polynomial.html,1,['cache'],['cached']
Performance,"lity interface with multi-dimensional functions. ;  ; double ParameterDerivative (const double *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values (multi-dim like interface) ;  ; double ParameterDerivative (double x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter. ;  ; double ParameterDerivative (double x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; void ParameterGradient (const double *x, const double *p, double *grad) const;  Compatibility interface with multi-dimensional functions. ;  ; void ParameterGradient (const double *x, double *grad) const;  Evaluate all derivatives using cached parameter values (multi-dim like interface) ;  ; virtual void ParameterGradient (double x, const double *p, double *grad) const;  Evaluate the derivatives of the function with respect to the parameters at a point x. ;  ; void ParameterGradient (double x, double *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual IBaseFunctionOneDim * Clone () const =0;  Clone a function. ;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual unsigned int NPar () const =0;  Return the number of Parameters. ;  ; virtual std::string ParameterName (unsigned int i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html:2611,cache,cached,2611,doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html,1,['cache'],['cached']
Performance,"lity, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps. Graphical Checking Methods. Safety computation checking; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:103523,optimiz,optimized,103523,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,2,"['optimiz', 'perform']","['optimized', 'performing']"
Performance,"lity,; one object can be removed from its support directory; by calling object->SetDirectory(0) or object->SetDirectory(dir) to add it; to the list of objects in the directory dir. NOTE that this is a static function. To call it, use;; TDirectory::AddDirectory. Bool_t AddDirectoryStatus(); static function: see TDirectory::AddDirectory for more comments. void Append(TObject* obj, Bool_t replace = kFALSE); Append object to this directory. If replace is true:; remove any existing objects with the same same (if the name is not """". void Browse(TBrowser* b); Browse the content of the directory. void Build(TFile* motherFile = 0, TDirectory* motherDir = 0); -*-*Initialise directory to defaults; *-* ================================. void CleanTargets(); Clean the pointers to this object (gDirectory, TContext, etc.). TObject * CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); Clone an object.; This function is called when the directory is not a TDirectoryFile.; This version has to load the I/O package, hence via CINT. If autoadd is true and if the object class has a; DirectoryAutoAdd function, it will be called at the end of the; function with the parameter gDirector. This usually means that; the object will be appended to the current ROOT directory. TDirectory * GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); Find a directory using apath.; It apath is null or empty, returns ""this"" directory.; Otherwie use apath to find a directory.; The absolute path syntax is:; file.root:/dir1/dir2; where file.root is the file and /dir1/dir2 the desired subdirectory; in the file. Relative syntax is relative to ""this"" directory. E.g:; ../aa.; Returns 0 in case path does not exist.; If printError is true, use Error with 'funcname' to issue an error message. Bool_t cd(const char* path = 0); Change current directory to ""this"" directory . Using path one can; change the current directory to ""path"". The absolute path syntax is:; file.roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDirectory.html:11097,load,load,11097,root/html528/TDirectory.html,https://root.cern,https://root.cern/root/html528/TDirectory.html,2,['load'],['load']
Performance,"lity,; one object can be removed from its support directory; by calling object->SetDirectory(0) or object->SetDirectory(dir) to add it; to the list of objects in the directory dir. NOTE that this is a static function. To call it, use;; TDirectory::AddDirectory. Bool_t AddDirectoryStatus(); static function: see TDirectory::AddDirectory for more comments. void Append(TObject* obj, Bool_t replace = kFALSE); Append object to this directory. If replace is true:; remove any existing objects with the same same (if the name is not """". void Browse(TBrowser* b); Browse the content of the directory. void Build(TFile* motherFile = 0, TDirectory* motherDir = 0); -*-*Initialise directory to defaults; *-* ================================. void CleanTargets(); Clean the pointers to this object (gDirectory, TContext, etc.). TObject * CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); Clone an object.; This function is called when the directory is not a TDirectoryFile.; This version has to load the I/O package, hence via CINT. If autoadd is true and if the object class has a; DirectoryAutoAdd function, it will be called at the end of the; function with the parameter gDirector. This usually means that; the object will be appended to the current ROOT directory. TDirectory *& CurrentDirectory(); Return the current directory for the current thread. TDirectory * GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); Find a directory using apath.; It apath is null or empty, returns ""this"" directory.; Otherwie use apath to find a directory.; The absolute path syntax is:; file.root:/dir1/dir2; where file.root is the file and /dir1/dir2 the desired subdirectory; in the file. Relative syntax is relative to ""this"" directory. E.g:; ../aa.; Returns 0 in case path does not exist.; If printError is true, use Error with 'funcname' to issue an error message. Bool_t cd(const char* path = 0); Change current directory to ""this"" directory . Using path ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDirectory.html:11205,load,load,11205,root/html532/TDirectory.html,https://root.cern,https://root.cern/root/html532/TDirectory.html,4,['load'],['load']
Performance,"lity. Int_t EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify options for the loading step via 'loadopts';; the string will be passed passed as argument to SETUP.; Special option 'chkv=<o>' (or 'checkversion=<o>') can be used to control; plugin version checking during building: possible choices are:; off no check; failure may occur at loading; on check ROOT version [default]; svn check ROOT version and Git commit SHA1.; (Use ';', ' ' or '|' to separate 'chkv=<o>' from the rest.); If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify a list of objects to be passed to the SETUP; functions via 'loadopts'; the objects must be streamable.; Returns 0 in case of success and -1 in case of error. Int_t DownloadPackage(const char* par, const char* dstdir = 0); Download a PROOF archive (PAR file) from the master package repository.; The PAR file is downloaded in the current directory or in the directory; specified by 'dstdir'. If a package with the same name already exists; at destination, a check on the MD5 sum is done and the user warned or; prompted for action, depending is the file is equal or different.; Returns 0 in case of success and -1 in case of error. Int_t UploadPackage(const char* par, TProof::EUpload",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:77492,load,loadopts,77492,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['load'],['loadopts']
Performance,"lization observables are known. Class RooProjectedPdf can cache projected p.d.f.s for multiple normalization observables simultaneously. The createProjection() method of RooProjectedPdf is overloaded and will return a new RooProjectedPdf that performs the projection of itself and the requested additional projections in one integration step The performance of f->createProjection(x)->createProjection(y) is therefore identical to that of f->createProjection(RooArgSet(x,y)); Definition at line 21 of file RooProjectedPdf.h. Classes; class  CacheElem;  . Public Member Functions;  RooProjectedPdf ();  Default constructor. ;  ;  RooProjectedPdf (const char *name, const char *title, RooAbsReal &_intpdf, const RooArgSet &intObs);  Construct projection of input pdf '_intpdf' over observables 'intObs'. ;  ;  RooProjectedPdf (const RooProjectedPdf &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Return analytical integral represent by appropriate element of projection cache. ;  ; TObject * clone (const char *newname) const override;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsPdf * createProjection (const RooArgSet &iset) override;  Special version of RooAbsReal::createProjection that deals with projections of projections. ;  ; double expectedEvents (const RooArgSet *nset) const override;  Return expected number of events to be used in calculation of extended likelihood. ;  ; ExtendMode extendMode () const override;  Returns ability of PDF to provide extended likelihood terms. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to relegate integration of all observables to internal logic. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProjectedPdf.html:1693,cache,cache,1693,doc/master/classRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classRooProjectedPdf.html,1,['cache'],['cache']
Performance,"lization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxymsf; RooRealProxysigma; RooRealProxyssf; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGaussModel.html:41128,cache,cache,41128,root/html526/RooGaussModel.html,https://root.cern,https://root.cern/root/html526/RooGaussModel.html,4,['cache'],['cache']
Performance,"lization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,int>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_int_.html:45106,cache,cache,45106,root/html602/RooCFunction4PdfBinding_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_int_.html,2,['cache'],['cache']
Performance,"lization.; If shiftToZero is set, the entire curve is shift down to make the lowest; point in of the curve go through zero. RooCurve(const char* name, const char* title, const RooAbsFunc& func, Double_t xlo, Double_t xhi, UInt_t minPoints, Double_t prec = 0.001, Double_t resolution = 0.001, Bool_t shiftToZero = kFALSE, RooCurve::WingMode wmode = Extended, Int_t nEvalError = -1, Int_t doEEVal = kFALSE, Double_t eeVal = 0); Create a 1-dim curve of the value of the specified real-valued; expression as a function of x. Use the optional precision; parameter to control how precisely the smooth curve is; rasterized. If shiftToZero is set, the entire curve is shift; down to make the lowest point in of the curve go through zero. RooCurve(const char* name, const char* title, const RooCurve& c1, const RooCurve& c2, Double_t scale1 = 1., Double_t scale2 = 1.); Constructor of curve as sum of two other curves. Csum = scale1*c1 + scale2*c2. ~RooCurve(); Destructor. void initialize(); Perform initialization that is common to all curves. void shiftCurveToZero(Double_t prevYMax); Find lowest point in curve and move all points in curve so that; lowest point will go exactly through zero. void addPoints(const RooAbsFunc& func, Double_t xlo, Double_t xhi, Int_t minPoints, Double_t prec, Double_t resolution, RooCurve::WingMode wmode, Int_t numee = 0, Bool_t doEEVal = kFALSE, Double_t eeVal = 0., list<Double_t>* samplingHint = 0); Add points calculated with the specified function, over the range (xlo,xhi).; Add at least minPoints equally spaced points, and add sufficient points so that; the maximum deviation from the final straight-line segements is prec*(ymax-ymin),; down to a minimum horizontal spacing of resolution*(xhi-xlo). void addRange(const RooAbsFunc& func, Double_t x1, Double_t x2, Double_t y1, Double_t y2, Double_t minDy, Double_t minDx, Int_t numee = 0, Bool_t doEEVal = kFALSE, Double_t eeVal = 0.); Fill the range (x1,x2) with points calculated using func(&x). No point will; be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCurve.html:20900,Perform,Perform,20900,root/html602/RooCurve.html,https://root.cern,https://root.cern/root/html602/RooCurve.html,2,['Perform'],['Perform']
Performance,"lize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* object, Long_t& retLong); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Long_t& retLong); Execute the method for the specified object and argument values. void Execute(void* object, Double_t& retDouble); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Double_t& retDouble); Execute the method for the specified object and argument values. void Execute(void* object, char** retText); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, char** retText); Execute the method for the specified object and argument values. void SetParamPtrs(voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMethodCall.html:10549,cache,cached,10549,root/html528/TMethodCall.html,https://root.cern,https://root.cern/root/html528/TMethodCall.html,4,['cache'],['cached']
Performance,"lize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma' . Details on error band visualization; VisualizeError() uses plotOnWithErrorBand(). Documentation of the latter: See alsoplotOnWithErrorBand(). PyROOT; The RooAbsReal::plotOn() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Reimplemented in RooSimultaneous, RooAbsPdf, and RooSimultaneous.; Definition at line 1611 of file RooAbsReal.cxx. ◆ plotOn() [2/3]. RooPlot * RooAbsReal::plotOn ; (; RooPlot * ; frame, . PlotOpt ; o . ); const. protectedvirtual . Plotting engine function for internal use. ; Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted function that occur in the previously plotted dataset are projected via partial integration, otherwise no projections are performed. Optionally, certain projections can be performed by summing over the values present in a provided dataset ('projData'), to correctly project out data dependents that are not properly described by the PDF (e.g. per-event errors).; The functions value can be multiplied with an optional scale factor. The interpretation of the scale factor is unique for generic real functions, for PDFs there are various interpretations possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details).; The default projection behaviour can be overridden by supplying an optional set of dependents to project via RooFit command arguments. ; Reimplemented in RooAbsPdf, and RooSimultaneous.; Definition at line 1883 of file RooAbsReal.cxx. ◆ plotOn() [3/3]. RooPlot * RooAbsReal::plotOn ; (; RooPlot * ; frame, . RooLinkedList & ; cmdList . ); const. virtual . Internal back-end function of plotOn() with named arguments. ; Reimplemented in RooAbsPdf, RooSimultaneous, and RooSimultaneous.; Definition at line 1631 of file RooAbsReal.cxx. ◆ plotOnCompSelect(). void RooAbsReal::plotOnCompSelect ; (; Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:135551,perform,performed,135551,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['perform'],['performed']
Performance,"lize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma' . Details on error band visualization; VisualizeError() uses plotOnWithErrorBand(). Documentation of the latter: See alsoplotOnWithErrorBand(). PyROOT; The RooAbsReal::plotOn() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Reimplemented in RooSimultaneous, RooAbsPdf, and RooSimultaneous.; Definition at line 1639 of file RooAbsReal.cxx. ◆ plotOn() [2/3]. RooPlot * RooAbsReal::plotOn ; (; RooPlot * ; frame, . PlotOpt ; o . ); const. protectedvirtual . Plotting engine function for internal use. ; Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted function that occur in the previously plotted dataset are projected via partial integration, otherwise no projections are performed. Optionally, certain projections can be performed by summing over the values present in a provided dataset ('projData'), to correctly project out data dependents that are not properly described by the PDF (e.g. per-event errors).; The functions value can be multiplied with an optional scale factor. The interpretation of the scale factor is unique for generic real functions, for PDFs there are various interpretations possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details).; The default projection behaviour can be overridden by supplying an optional set of dependents to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface to modify the default projection behaviour. ; Reimplemented in RooAbsPdf, and RooSimultaneous.; Definition at line 1931 of file RooAbsReal.cxx. ◆ plotOn() [3/3]. RooPlot * RooAbsReal::plotOn ; (; RooPlot * ; frame, . RooLinkedList & ; cmdList . ); const. virtual . Internal back-end function of plotOn() with named arguments. ; Reimplemented in RooAbsPdf, RooSimultaneous, and RooSimultaneous.; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:136881,perform,performed,136881,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['perform'],['performed']
Performance,"lized, std::set< TClass * > &modifiedClasses);  ; Bool_t HasPCMForLibrary (const char *libname) const final;  Return true if ROOT has cxxmodules pcm for a given library name. ;  ; virtual void Initialize () final;  Initialize the interpreter, once TROOT::fInterpreter is set. ;  ; void InspectMembers (TMemberInspector &, const void *obj, const TClass *cl, Bool_t isTransient) final;  Visit all members over members, recursing over base classes. ;  ; void InvalidateGlobal (const clang::Decl *D);  Invalidate cached TCling information for the given global declaration. ;  ; Bool_t IsAutoLoadNamespaceCandidate (const clang::NamespaceDecl *nsDecl);  ; Bool_t IsAutoParsingSuspended () const final;  ; Bool_t IsErrorMessagesEnabled () const final;  If error messages are disabled, the interpreter should suppress its failures and warning messages from stdout. ;  ; bool IsFloatingType (const void *QualTypePtr) const;  ; bool IsIntegerType (const void *QualTypePtr) const;  ; Bool_t IsLibraryLoaded (const char *libname) const final;  ; Bool_t IsLoaded (const char *filename) const final;  Return true if the file has already been loaded by cint. ;  ; bool IsPointerType (const void *QualTypePtr) const;  ; Bool_t IsProcessLineLocked () const final;  ; bool IsSameType (const void *QualTypePtr1, const void *QualTypePtr2) const;  ; bool IsSignedIntegerType (const void *QualTypePtr) const;  ; bool IsUnsignedIntegerType (const void *QualTypePtr) const;  ; bool IsVoidPointerType (const void *QualTypePtr) const;  ; void * LazyFunctionCreatorAutoload (const std::string &mangled_name);  Autoload a library based on a missing symbol. ;  ; void LibraryLoaded (const void *dyLibHandle, const char *canonicalName);  ; bool LibraryLoadingFailed (const std::string &, const std::string &, bool, bool);  ; void LibraryUnloaded (const void *dyLibHandle, const char *canonicalName);  ; Int_t Load (const char *filenam, Bool_t system=kFALSE) final;  Load a library file in cling's memory. ;  ; void LoadEnums (TLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:22880,load,loaded,22880,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['loaded']
Performance,ll AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigN,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedPdf.html:39496,cache,cache,39496,root/html526/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedPdf.html,3,['cache'],['cache']
Performance,ll AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC genera,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsSelfCachedPdf.html:39943,cache,cache,39943,root/html528/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsSelfCachedPdf.html,3,['cache'],['cache']
Performance,ll AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculatin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsSelfCachedPdf.html:40412,cache,cache,40412,root/html530/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsSelfCachedPdf.html,3,['cache'],['cache']
Performance,ll AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalcul,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedPdf.html:40815,cache,cache,40815,root/html532/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedPdf.html,3,['cache'],['cache']
Performance,"ll as output from it; users can interact: Fix/release parameters, set values and errors, etc ;  CMnUserParameterStateClass which holds the external user and/or internal Minuit representation of the parameters and errors; transformation internal <-> external on demand; ;  CMnUserTransformationClass dealing with the transformation between user specified parameters (external) and internal parameters used for minimization ;  CMnVectorTransform;  CModularFunctionMinimizerBase common class providing the API for all the minimizer Various Minimize methods are provided varying on the type of FCN function passesd and on the objects used for the parameters ;  CMPIProcess;  CMPITerminate;  CNegativeG2LineSearchIn case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive ;  CNumerical2PGradientCalculatorClass performing the numerical gradient calculation ;  CParametricFunctionFunction which has parameters ;  CQuad12F;  CQuad1F;  CQuad4F;  CQuad4FGrad;  CQuad8F;  CScanBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CScanMinimizerClass implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class ;  CSimplexBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CSimplexMinimizerClass implementing the required methods for a minimization using Simplex ;  CSimplexParametersClass describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process ;  CSimplexSeedGeneratorGenerate Simplex starting point (state) ;  CSinParameterTransformationClass for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one ;  CSqrtLowParameterTransformationTransformation ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:63403,perform,performing,63403,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,3,['perform'],['performing']
Performance,"ll as output from it; users can interact: Fix/release parameters, set values and errors, etc ;  CMnUserParameterStateClass which holds the external user and/or internal Minuit representation of the parameters and errors; transformation internal <-> external on demand; ;  CMnUserTransformationClass dealing with the transformation between user specified parameters (external) and internal parameters used for minimization ;  CMnVectorTransform;  CModularFunctionMinimizerBase common class providing the API for all the minimizer Various Minimize methods are provided varying on the type of FCN function passesd and on the objects used for the parameters ;  CMPIProcess;  CMPITerminate;  CNegativeG2LineSearchIn case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive ;  CNumerical2PGradientCalculatorClass performing the numerical gradient calculation ;  CParametricFunctionFunction which has parameters ;  CScanBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CScanMinimizerClass implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class ;  CSimplexBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CSimplexMinimizerClass implementing the required methods for a minimization using Simplex ;  CSimplexParametersClass describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process ;  CSimplexSeedGeneratorGenerate Simplex starting point (state) ;  CSinParameterTransformationClass for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one ;  CSqrtLowParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:69746,perform,performing,69746,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['perform'],['performing']
Performance,"ll be processed, server only can be destroyed afterwards ; Definition at line 277 of file THttpServer.cxx. ◆ SetTimer(). void THttpServer::SetTimer ; (; Long_t ; milliSec = 100, . Bool_t ; mode = kTRUE . ). Create timer which will invoke ProcessRequests() function periodically. ; Timer is required to perform all actions in main ROOT thread Method arguments are the same as for TTimer constructor By default, sync timer with 100 ms period is created; It is recommended to always use sync timer mode and only change period to adjust server reaction time. Use of async timer requires, that application regularly calls gSystem->ProcessEvents(). It happens automatically in ROOT interactive shell. If milliSec == 0, no timer will be created. In this case application should regularly call ProcessRequests() method.; Async timer allows to use THttpServer in applications, which does not have explicit gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call (like malloc) and can lead to dead locks, especially in multi-threaded applications. ; Definition at line 490 of file THttpServer.cxx. ◆ SetTopName(). void THttpServer::SetTopName ; (; const char * ; top). inline . set name of top item in objects hierarchy ; Definition at line 127 of file THttpServer.h. ◆ SetWSOnly(). void THttpServer::SetWSOnly ; (; Bool_t ; on = kTRUE). Set websocket-only mode. ; If true, server will only handle websockets connection plus serving file requests to access jsroot/ui5 scripts ; Definition at line 318 of file THttpServer.cxx. ◆ StopServerThread(). void THttpServer::StopServerThread ; (; ). protected . Stop server thread. ; Normally called shortly before http server destructor ; Definition at line 547 of file THttpServer.cxx. ◆ Streamer(). void THttpServer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void THttpServer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:36849,multi-thread,multi-threaded,36849,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['multi-thread'],['multi-threaded']
Performance,"ll branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:19034,cache,cache,19034,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['cache'],['cache']
Performance,"ll branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:20900,cache,cache,20900,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,1,['cache'],['cache']
Performance,"ll branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:21742,cache,cache,21742,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance,"ll is forwarded to RooHistPdf cache p.d.f of cache that is used for given choice of observables ; Reimplemented from RooAbsReal.; Definition at line 334 of file RooAbsCachedPdf.cxx. ◆ getCache(). RooAbsCachedPdf::PdfCacheElem * RooAbsCachedPdf::getCache ; (; const RooArgSet * ; nset, . bool ; recalculate = true . ); const. protected . Retrieve cache object associated with given choice of observables. ; If cache object does not exist, create and fill and register it on the fly. If recalculate=false recalculation of cache contents of existing caches that are marked dirty due to dependent parameter changes is suppressed. ; Definition at line 113 of file RooAbsCachedPdf.cxx. ◆ getCacheHist() [1/2]. RooDataHist * RooAbsCachedPdf::getCacheHist ; (; const RooArgSet & ; nset); const. inline . Definition at line 43 of file RooAbsCachedPdf.h. ◆ getCacheHist() [2/2]. RooDataHist * RooAbsCachedPdf::getCacheHist ; (; const RooArgSet * ; nset = nullptr); const. Return pointer to RooDataHist cache histogram for given choice of observables. ; Definition at line 100 of file RooAbsCachedPdf.cxx. ◆ getCachePdf() [1/2]. RooAbsPdf * RooAbsCachedPdf::getCachePdf ; (; const RooArgSet & ; nset); const. inline . Definition at line 39 of file RooAbsCachedPdf.h. ◆ getCachePdf() [2/2]. RooAbsPdf * RooAbsCachedPdf::getCachePdf ; (; const RooArgSet * ; nset = nullptr); const. Return pointer to RooHistPdf cache pdf for given choice of observables. ; Definition at line 90 of file RooAbsCachedPdf.cxx. ◆ getInterpolationOrder(). Int_t RooAbsCachedPdf::getInterpolationOrder ; (; ); const. inline . Definition at line 51 of file RooAbsCachedPdf.h. ◆ getValV(). double RooAbsCachedPdf::getValV ; (; const RooArgSet * ; nset = nullptr); const. overridevirtual . Implementation of getVal() overriding default implementation of RooAbsPdf. ; Return normalized value stored in cache p.d.f rather than return value of evaluate() which is undefined for RooAbsCachedPdf ; Reimplemented from RooAbsReal.; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:82180,cache,cache,82180,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"ll members ; RooRealSumFunc Class Reference. . Definition at line 26 of file RooRealSumFunc.h. Public Member Functions;  RooRealSumFunc ();  ;  RooRealSumFunc (const char *name, const char *title);  ;  RooRealSumFunc (const char *name, const char *title, const RooArgList &funcList, const RooArgList &coefList);  ;  RooRealSumFunc (const char *name, const char *title, RooAbsReal &func1, RooAbsReal &func2, RooAbsReal &coef1);  ;  RooRealSumFunc (const RooRealSumFunc &other, const char *name=nullptr);  ;  ~RooRealSumFunc () override;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Retrieve bin boundaries if this distribution is binned in obs. ;  ; CacheMode canNodeBeCached () const override;  ; bool checkObservables (const RooArgSet *nset) const override;  Overloadable function in which derived classes can implement consistency checks of the variables. ;  ; TObject * clone (const char *newname) const override;  ; const RooArgList & coefList () const;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; bool forceAnalyticalInt (const RooAbsArg &arg) const override;  ; const RooArgList & funcList () const;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &numVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ;  ; bool getFloor () const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const overr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:1167,Cache,CacheMode,1167,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,2,['Cache'],['CacheMode']
Performance,"ll our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Jun 2 15:26:55 2015 » Last generated: 2015-06-02 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsCachedPdf.html:49409,cache,cache,49409,root/html604/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html604/RooAbsCachedPdf.html,3,['cache'],['cache']
Performance,"ll the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:41290,cache,cache,41290,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,3,['cache'],['cache']
Performance,"ll values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. RooCachedReal(); {}. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that represent the cache histogram; will use special boundary conditions for use with cumulative distribution; functions: at the lower bound the function is forced to converge at zero and the upper; bound is the function is forced to converge at 1.0. Bool_t getCdfBoundaries() const; If true the c.d.f boundary mode is active. const char* inputBaseName() const; Return base name for caches, i.e. the name of the cached function. Double_t evaluate() const; Dummy evaluate, it is never called. » Last changed: Mon Dec 7 13:47:03 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedReal.html:35920,cache,cache,35920,root/html526/RooCachedReal.html,https://root.cern,https://root.cern/root/html526/RooCachedReal.html,3,['cache'],"['cache', 'cached', 'caches']"
Performance,"llStylevoid SetHistFillStyle(Style_t styl=0)Definition TStyle.h:381; TStyle::GetHistLineWidthWidth_t GetHistLineWidth() constDefinition TStyle.h:236; TStyle::SetHistLineWidthvoid SetHistLineWidth(Width_t width=1)Definition TStyle.h:383; TSubStringA zero length substring is legal.Definition TString.h:85; TSubString::StringTString & String()Definition TString.h:124; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeCacheUnzipA TTreeCache which exploits parallelized decompression of its own content.Definition TTreeCacheUnzip.h:35; TTreeCacheUnzip::IsParallelUnzipstatic bool IsParallelUnzip()Static function that tells wether the multithreading unzipping is activated.Definition TTreeCacheUnzip.cxx:416; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::IsAutoCreatedbool IsAutoCreated() constDefinition TTreeCache.h:150; TTreeCache::SetBufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.h:149; TTreeCache::SetEntryRangevirtual void SetEntryRange(Long64_t emin, Long64_t emax)Set the minimum and maximum entry number to be processed this information helps to optimize the numbe...Definition TTreeCache.cxx:2106; TTreeCache::DropBranchvirtual Int_t DropBranch(TBranch *b, bool subbranches=false)Remove a branch to the list of branches to be stored in the cache this function is called by TBranch:...Definition TTreeCache.cxx:541",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:429121,cache,cache,429121,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,llTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected . ! save the fact that we processes the first entry ; Definition at line 60 of file TTreeCache.h. ◆ fgLearnEntries. Int_t TTreeCache::fgLearnEntries = 100. staticprotected . number of entries used for learning mode ; Definition at line 65 of file TTreeCache.h. ◆ fIsLearning. bool TTreeCache::fIsLearning {true}. protected . ! true if cache is in learning mode ; Definition at line 54 of file TTreeCache.h. ◆ fIsManual. bool TTreeCache::fIsManual {false}. protected . ! true if cache is StopLearningPhase was used ; Definition at line 55 of file TTreeCache.h. ◆ fLastMiss. Long64_t TTreeCache::fLastMiss {-1}. protected . ! set to the event # of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCach,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:54285,cache,cache,54285,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,"llback (just as TChain::LoadTree()).; 6470///; 6471/// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; 6472///; 6473/// \note This function is overloaded in TChain.; 6474Long64_t TTree::LoadTree(Long64_t entry); 6475{; 6476 // We have already been visited while recursively looking; 6477 // through the friend trees, let's return; 6478 if (kLoadTree & fFriendLockStatus) {; 6479 // We need to return a negative value to avoid a circular list of friends; 6480 // to think that there is always an entry somewhere in the list.; 6481 return -1;; 6482 }; 6483 ; 6484 // create cache if wanted; 6485 if (fCacheDoAutoInit && entry >=0); 6486 SetCacheSizeAux();; 6487 ; 6488 if (fNotify) {; 6489 if (fReadEntry < 0) {; 6490 fNotify->Notify();; 6491 }; 6492 }; 6493 fReadEntry = entry;; 6494 ; 6495 bool friendHasEntry = false;; 6496 if (fFriends) {; 6497 // Set current entry in friends as well.; 6498 //; 6499 // An alternative would move this code to each of the; 6500 // functions calling LoadTree (and to overload a few more).; 6501 bool needUpdate = false;; 6502 {; 6503 // This scope is need to insure the lock is released at the right time; 6504 TIter nextf(fFriends);; 6505 TFriendLock lock(this, kLoadTree);; 6506 TFriendElement* fe = nullptr;; 6507 while ((fe = (TFriendElement*) nextf())) {; 6508 if (fe->TestBit(TFriendElement::kFromChain)) {; 6509 // This friend element was added by the chain that owns this; 6510 // tree, the chain will deal with loading the correct entry.; 6511 continue;; 6512 }; 6513 TTree* friendTree = fe->GetTree();; 6514 if (friendTree) {; 6515 if (friendTree->LoadTreeFriend(entry, this) >= 0) {; 6516 friendHasEntry = true;; 6517 }; 6518 }; 6519 if (fe->IsUpdated()) {; 6520 needUpdate = true;; 6521 fe->ResetUpdated();; 6522 }; 6523 } // for each friend; 6524 }; 6525 if (needUpdate) {; 6526 //update list of leaves in all TTreeFormula of the TTreePlayer (if any); 6527 if (fPlayer) {; 6528 fPlayer->UpdateFormulaLeaves()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:253927,Load,LoadTree,253927,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"llback = 1;; 12709 }; 12710 mg_free(inflated);; 12711 }; 12712 } else; 12713#endif; 12714 if (!ws_data_handler(conn,; 12715 mop,; 12716 (char *)data,; 12717 (size_t)data_len,; 12718 callback_data)) {; 12719 exit_by_callback = 1;; 12720 }; 12721 }; 12722 }; 12723 ; 12724 /* It a buffer has been allocated, free it again */; 12725 if (data != mem) {; 12726 mg_free(data);; 12727 }; 12728 ; 12729 if (exit_by_callback) {; 12730 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12731 conn->request_info.remote_addr,; 12732 conn->request_info.remote_port);; 12733 break;; 12734 }; 12735 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12736 /* Opcode == 8, connection close */; 12737 DEBUG_TRACE(""Message requests to close connection from %s:%u"",; 12738 conn->request_info.remote_addr,; 12739 conn->request_info.remote_port);; 12740 break;; 12741 }; 12742 ; 12743 /* Not breaking the loop, process next websocket frame. */; 12744 } else {; 12745 /* Read from the socket into the next available location in the; 12746 * message queue. */; 12747 n = pull_inner(NULL,; 12748 conn,; 12749 conn->buf + conn->data_len,; 12750 conn->buf_size - conn->data_len,; 12751 timeout);; 12752 if (n <= -2) {; 12753 /* Error, no bytes read */; 12754 DEBUG_TRACE(""PULL from %s:%u failed"",; 12755 conn->request_info.remote_addr,; 12756 conn->request_info.remote_port);; 12757 break;; 12758 }; 12759 if (n > 0) {; 12760 conn->data_len += n;; 12761 /* Reset open PING count */; 12762 ping_count = 0;; 12763 } else {; 12764 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12765 && (!conn->must_close)) {; 12766 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12767 /* Stop sending PING */; 12768 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12769 ""- closing connection"",; 12770 ping_count,; 12771 conn->request_info.remote_addr,; 12772 conn->request_info.remote_port);; 12773 break;; 12774 }; 12775 if (enable_ping_pong) {; 12776 /* Send Websocket PING message */; 12777 DEBUG_TRACE(""PIN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:370454,queue,queue,370454,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"llback = 1;; 12710 }; 12711 mg_free(inflated);; 12712 }; 12713 } else; 12714#endif; 12715 if (!ws_data_handler(conn,; 12716 mop,; 12717 (char *)data,; 12718 (size_t)data_len,; 12719 callback_data)) {; 12720 exit_by_callback = 1;; 12721 }; 12722 }; 12723 }; 12724 ; 12725 /* It a buffer has been allocated, free it again */; 12726 if (data != mem) {; 12727 mg_free(data);; 12728 }; 12729 ; 12730 if (exit_by_callback) {; 12731 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12732 conn->request_info.remote_addr,; 12733 conn->request_info.remote_port);; 12734 break;; 12735 }; 12736 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12737 /* Opcode == 8, connection close */; 12738 DEBUG_TRACE(""Message requests to close connection from %s:%u"",; 12739 conn->request_info.remote_addr,; 12740 conn->request_info.remote_port);; 12741 break;; 12742 }; 12743 ; 12744 /* Not breaking the loop, process next websocket frame. */; 12745 } else {; 12746 /* Read from the socket into the next available location in the; 12747 * message queue. */; 12748 n = pull_inner(NULL,; 12749 conn,; 12750 conn->buf + conn->data_len,; 12751 conn->buf_size - conn->data_len,; 12752 timeout);; 12753 if (n <= -2) {; 12754 /* Error, no bytes read */; 12755 DEBUG_TRACE(""PULL from %s:%u failed"",; 12756 conn->request_info.remote_addr,; 12757 conn->request_info.remote_port);; 12758 break;; 12759 }; 12760 if (n > 0) {; 12761 conn->data_len += n;; 12762 /* Reset open PING count */; 12763 ping_count = 0;; 12764 } else {; 12765 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12766 && (!conn->must_close)) {; 12767 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12768 /* Stop sending PING */; 12769 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12770 ""- closing connection"",; 12771 ping_count,; 12772 conn->request_info.remote_addr,; 12773 conn->request_info.remote_port);; 12774 break;; 12775 }; 12776 if (enable_ping_pong) {; 12777 /* Send Websocket PING message */; 12778 DEBUG_TRACE(""PIN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:370487,queue,queue,370487,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"llection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:114576,optimiz,optimize,114576,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,1,['optimiz'],['optimize']
Performance,"llections of collections. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TObject.h""; 26 ; 27#include ""TIterator.h""; 28 ; 29#include ""TString.h""; 30 ; 31#include ""TVirtualRWMutex.h""; 32 ; 33#include ""ROOT/RRangeCast.hxx""; 34 ; 35#include <cassert>; 36 ; 37class TClass;; 38class TObjectTable;; 39class TVirtualMutex;; 40class TIter;; 41 ; 42const Bool_t kIterForward = kTRUE;; 43const Bool_t kIterBackward = !kIterForward;; 44 ; 45R__EXTERN TVirtualMutex *gCollectionMutex;; 46 ; 47// #define R__CHECK_COLLECTION_MULTI_ACCESS; 48 ; 49// When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; 50// the normal (not locked) ROOT TCollections are instrumented with a; 51// pseudo read-write lock which does not halt the execution but detects; 52// and report concurrent access to the same collections.; 53// Multiple readers are allowed.; 54// Multiple concurrent writer is reported as a Conflict; 55// Readers access while a write is running is reported as Conflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWriteCurrentRecurse;; 73 std::atomic<size_t> fReadCurrentRecurse;; 74 std::unordered_multiset<std::thread::id> fReadSet;; 75 std::atomic_flag fSpinLockFlag;; 76 ; 77 void Lock(const TCollection *collection, const char *function);; 78 ; 79 void Unlock();; 80 ; 81 void ReadLock(const TCollection *collection, const char *function);; 82 ; 83 void ReadUnlock();; 84 ; 85 void ConflictReport(std::thread::id holder, const char *accessty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:1842,concurren,concurrent,1842,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['concurren'],['concurrent']
Performance,"lled when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static THLimitsFinder * GetLimitsFinder ();  Return pointer to the current finder. ;  ; static void Optimize (Double_t A1, Double_t A2, Int_t nold, Double_t &BinLow, Double_t &BinHigh, Int_t &nbins, Double_t &BWID, Option_t *option="""");  Static function to compute reasonable axis limits. ;  ; static void OptimizeLimits (Int_t nbins, Int_t &newbins, Double_t &xmin, Double_t &xmax, Bool_t isInteger);  Optimize axis limits. ;  ; static void SetLimitsFinder (THLimitsFinder *finder);  This static function can be used to specify a finder derived from THLimitsFinder. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Static Protected Attributes; static THLimitsFinder * fgLimitsFinder = nullptr;  ! Pointer to hist limits finder ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x040",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHLimitsFinder.html:9406,Optimiz,OptimizeLimits,9406,doc/master/classTHLimitsFinder.html,https://root.cern,https://root.cern/doc/master/classTHLimitsFinder.html,2,['Optimiz'],"['Optimize', 'OptimizeLimits']"
Performance,"llowing the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree witho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:35703,cache,cache,35703,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['cache'],['cache']
Performance,"llptr;; 1766 return (char *)painter->GetVolumeInfo(vol, px, py);; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770/// Returns true if cylindrical voxelization is optimal.; 1771 ; 1772Bool_t TGeoVolume::GetOptimalVoxels() const; 1773{; 1774 Int_t nd = GetNdaughters();; 1775 if (!nd); 1776 return kFALSE;; 1777 Int_t id;; 1778 Int_t ncyl = 0;; 1779 TGeoNode *node;; 1780 for (id = 0; id < nd; id++) {; 1781 node = (TGeoNode *)fNodes->At(id);; 1782 ncyl += node->GetOptimalVoxels();; 1783 }; 1784 if (ncyl > (nd / 2)); 1785 return kTRUE;; 1786 return kFALSE;; 1787}; 1788 ; 1789////////////////////////////////////////////////////////////////////////////////; 1790/// Provide a pointer name containing uid.; 1791 ; 1792const char *TGeoVolume::GetPointerName() const; 1793{; 1794 static TString name;; 1795 name.Form(""p%s_%zx"", GetName(), (size_t)this);; 1796 return name.Data();; 1797}; 1798 ; 1799////////////////////////////////////////////////////////////////////////////////; 1800/// Getter for optimization structure.; 1801 ; 1802TGeoVoxelFinder *TGeoVolume::GetVoxels() const; 1803{; 1804 if (fVoxels && !fVoxels->IsInvalid()); 1805 return fVoxels;; 1806 return nullptr;; 1807}; 1808 ; 1809////////////////////////////////////////////////////////////////////////////////; 1810/// Move perspective view focus to this volume; 1811 ; 1812void TGeoVolume::GrabFocus(); 1813{; 1814 TVirtualGeoPainter *painter = fGeoManager->GetPainter();; 1815 if (painter); 1816 painter->GrabFocus();; 1817}; 1818 ; 1819////////////////////////////////////////////////////////////////////////////////; 1820/// Returns true if the volume is an assembly or a scaled assembly.; 1821 ; 1822Bool_t TGeoVolume::IsAssembly() const; 1823{; 1824 return fShape->IsAssembly();; 1825}; 1826 ; 1827////////////////////////////////////////////////////////////////////////////////; 1828/// Clone this volume.; 1829/// build a volume with same name, shape and medium; 1830 ; 18",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:68743,optimiz,optimization,68743,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"lls(); ++i) {; 611 psumw += pass->GetBinContent(i);; 612 psumw2 += pass->GetSumw2()->At(i);; 613 }; 614 }; 615 else {; 616 psumw = pass->GetSumOfWeights();; 617 psumw2 = psumw;; 618 }; 619 if (TMath::Abs(psumw - psumw2) > 1e-6); 620 bEffective = true;; 621 ; 622 Double_t tsumw = 0;; 623 Double_t tsumw2 = 0;; 624 if (total->GetSumw2()->fN > 0) {; 625 for (int i = 0; i < total->GetNcells(); ++i) {; 626 tsumw += total->GetBinContent(i);; 627 tsumw2 += total->GetSumw2()->At(i);; 628 }; 629 }; 630 else {; 631 tsumw = total->GetSumOfWeights();; 632 tsumw2 = tsumw;; 633 }; 634 if (TMath::Abs(tsumw - tsumw2) > 1e-6); 635 bEffective = true;; 636 ; 637 ; 638 ; 639 // we do not want to ignore the weights; 640 // if (bEffective && (pass->GetSumw2()->fN == 0 || total->GetSumw2()->fN == 0) ) {; 641 // Warning(""Divide"",""histogram have been computed with weights but the sum of weight squares are not stored in the histogram. Error calculation is performed ignoring the weights"");; 642 // bEffective = false;; 643 // }; 644 ; 645 //parse option; 646 TString option = opt;; 647 option.ToLower();; 648 ; 649 Bool_t bVerbose = false;; 650 //pointer to function returning the boundaries of the confidence interval; 651 //(is only used in the frequentist cases.); 652 Double_t (*pBound)(Double_t,Double_t,Double_t,Bool_t) = &TEfficiency::ClopperPearson; // default method; 653 //confidence level; 654 Double_t conf = 0.682689492137;; 655 //values for bayesian statistics; 656 Bool_t bIsBayesian = false;; 657 Double_t alpha = 1;; 658 Double_t beta = 1;; 659 ; 660 //verbose mode; 661 if(option.Contains(""v"")) {; 662 option.ReplaceAll(""v"","""");; 663 bVerbose = true;; 664 if (bEffective); 665 Info(""Divide"",""weight will be considered in the Histogram Ratio"");; 666 }; 667 ; 668 ; 669 //confidence level; 670 if(option.Contains(""cl="")) {; 671 Double_t level = -1;; 672 // coverity [secure_coding : FALSE]; 673 sscanf(strstr(option.Data(),""cl=""),""cl=%lf"",&level);; 674 if((level > 0) && (level < 1)); 675 conf = le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:23525,perform,performed,23525,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['perform'],['performed']
Performance,"lls, the relative and absolute tolerance must be provided.; 13.10.1.2 ROOT::Math::GSLMInimizer1D; This class wraps two different methods from the GSL. The algorithms which can be chosen at construction time are GOLDENSECTION, which is the simplest method but the slowest and BRENT (the default one) which combines the golden section with a parabolic interpolation. The algorithm can be chosen as a different enumeration in the constructor: * ROOT::Math::Minim1D::kBRENT for the Brent algorithm (default) * ROOT::Math::Minim1D::kGOLDENSECTION for the golden section algorithm; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; The interface to set the function and to minimize is the same as in the case of the BrentMinimizer1D.; 13.10.1.3 Using the TF1 class; It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, TF1 of the Hist library. The minmization is implemented in TF1 using the BrentMInimizer1D and available with the class member functions * TF1::GetMinimum/TF1::GetMaximum to find the function minimum/maximum value * TF1::GetMinimumX/TF1::GetMaximumX to find the x value corresponding at the function minimum.; The interval to search for the minimum (the default is the TF1 range), tolerance and maximum iterations can be provided as optional parameters of the TF1::GetMinimum/Maximum functions.; 13.10.2 Multi-Dimensional Minimization; All the algorithms for multi-dimensional minimization are implementing the ROOT::Math::Minimizer interface and they can be used in the same way and one can switch between minimizer at run-time. The minimizer concrete class can be in different ROOT libraries and they can be instantiate using the ROOT plug-in manager. More information on multi-dimensional minimization is provided in the Fitting Hist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:716684,perform,perform,716684,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['perform']
Performance,"lls-i,new TGeoTranslation(0,-ycell,0));; }; ; Double_t dxrow = 3.*(dshift+10.)*TMath::Tan(30.*TMath::DegToRad());; Double_t dyrow = dshift+10.;; Int_t nrows = 5;; for (i=0; i<nrows; i++) {; Double_t xrow = 0.5*(2*i+1)*dxrow;; Double_t yrow = 0.5*dyrow;; if ((i%2)==0) yrow = -yrow;; top->AddNode(row, nrows+i+1, new TGeoTranslation(xrow,yrow,0));; top->AddNode(row, nrows-i, new TGeoTranslation(-xrow,-yrow,0));; }; ; //--- close the geometry; geom->CloseGeometry();; ; geom->SetVisLevel(4);; geom->SetVisOption(0);; top->Draw();; }; ; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kBlue@ kBlueDefinition Rtypes.h:66; TGeoCombiTransClass describing rotation + translation.Definition TGeoMatrix.h:317; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::SetVisOptionvoid SetVisOption(Int_t option=0)set drawing mode :Definition TGeoManager.cxx:2426; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; TGeoRotationClass describing rotations.Definition TGeoMatrix.h:168; TGeoRotation::RotateXvoid RotateX(Double_t a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geom_2assembly_8C.html:3601,perform,performedDefinition,3601,doc/master/geom_2assembly_8C.html,https://root.cern,https://root.cern/doc/master/geom_2assembly_8C.html,1,['perform'],['performedDefinition']
Performance,"lly integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedComps! Owned components; TIterator*_pdfIter! Iterator over PDF list; RooListProxy_pdfListList of component PDFs; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooSetProxy_refCoefNorm! Reference observable set for coefficient interpretation; TNamed*_refCoefRangeName! Reference range name for coefficient interpreation; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:40704,cache,cache,40704,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,1,['cache'],['cache']
Performance,"lly saved in the high bits of fSeekPdir; Long64_tTKey::fSeekKeyLocation of object on file; Long64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasket(); Default contructor. TBasket(TDirectory* motherDir); Constructor used during reading. TBasket(const char* name, const char* title, TBranch* branch); Basket normal constructor, used during writing. ~TBasket(); Basket destructor. void AdjustSize(Int_t newsize); Increase the size of the current fBuffer up to newsize. Long64_t CopyTo(TFile* to); Copy the basket of this branch onto the file to. void DeleteEntryOffset(); Delete fEntryOffset array. Int_t DropBuffers(); Drop buffers of this basket if it is not the current basket. Int_t GetEntryPointer(Int_t Entry); Get pointer to buffer for internal entry. Int_t LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); Load basket buffers in memory without unziping.; This function is called by TTreeCloner.; The function returns 0 in case of success, 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBasket.html:10040,Load,LoadBasketBuffers,10040,root/html534/TBasket.html,https://root.cern,https://root.cern/root/html534/TBasket.html,6,['Load'],"['Load', 'LoadBasketBuffers']"
Performance,"lly. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:5516,cache,cache,5516,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,12,['cache'],"['cache', 'cachesize']"
Performance,"lly; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:17307,optimiz,optimized,17307,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['optimiz'],['optimized']
Performance,"lly; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete(). void Delete(Option_t* option = """"); Clear the clones array",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClonesArray.html:13814,optimiz,optimized,13814,root/html526/TClonesArray.html,https://root.cern,https://root.cern/root/html526/TClonesArray.html,1,['optimiz'],['optimized']
Performance,"lly; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:16467,optimiz,optimized,16467,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['optimiz'],['optimized']
Performance,"lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a7b1a0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf705__linearmorph_8C.html:8216,cache,cache,8216,doc/master/rf705__linearmorph_8C.html,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html,1,['cache'],['cache']
Performance,"lo.cxx. ◆ BuildCellIdCache(). virtual void TEveCaloViz::BuildCellIdCache ; (; ). protectedpure virtual . Implemented in TEveCalo3D, TEveCalo2D, and TEveCaloLego. ◆ CellInEtaPhiRng(). Bool_t TEveCaloViz::CellInEtaPhiRng ; (; TEveCaloData::CellData_t & ; cellData); const. Returns true if given cell is in the ceta phi range. ; Definition at line 307 of file TEveCalo.cxx. ◆ CellSelectionChanged(). virtual void TEveCaloViz::CellSelectionChanged ; (; ). inlinevirtual . Reimplemented in TEveCalo2D.; Definition at line 83 of file TEveCalo.h. ◆ Class(). static TClass * TEveCaloViz::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TEveCaloViz::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEveCaloViz::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 151 of file TEveCalo.h. ◆ DataChanged(). void TEveCaloViz::DataChanged ; (; ). Update setting and cache on data changed. ; Called from TEvecaloData::BroadcastDataChange() ; Definition at line 256 of file TEveCalo.cxx. ◆ DeclFileName(). static const char * TEveCaloViz::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 151 of file TEveCalo.h. ◆ ForwardEdit(). TEveElement * TEveCaloViz::ForwardEdit ; (; ). overridevirtual . Management of selection state and ownership of selected cell list is done in TEveCaloData. ; We still want GUI editor to display concrete calo-viz object. ; Reimplemented from TEveElement.; Definition at line 105 of file TEveCalo.cxx. ◆ ForwardSelection(). TEveElement * TEveCaloViz::ForwardSelection ; (; ). overridevirtual . Management of selection state and ownership of selected cell list is done in TEveCaloData. ; This is a reason selection is forwarded to it. ; Reimplemented from TEveElement.; Definition at line 95 of file TEveCalo.cxx. ◆ GetAutoRange(). Bool_t TEveCaloViz::GetAutoRange ; (; ); const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloViz.html:40156,cache,cache,40156,doc/master/classTEveCaloViz.html,https://root.cern,https://root.cern/doc/master/classTEveCaloViz.html,1,['cache'],['cache']
Performance,"load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pair is a transparent container so we should always look at its. void GetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); From the se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:39273,load,loading,39273,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['loading']
Performance,"load of libImt. ; Definition at line 463 of file TROOT.cxx. ◆ IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch processing is enabled. ; Definition at line 447 of file TROOT.cxx. ◆ LogicalCPUBandwidthControl(). int ROOT::Internal::LogicalCPUBandwidthControl ; (; ). Returns the available number of logical cores. . Checks if there is CFS bandwidth control in place (linux, via cgroups, assuming standard paths); Otherwise, returns the number of logical cores provided by std::thread::hardware_concurrency() . Definition at line 50 of file RTaskArena.cxx. ◆ MinimalErrorHandler(). void ROOT::Internal::MinimalErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). A very simple error handler that is usually replaced by the TROOT default error handler. ; The minimal error handler is not serialized across threads, so that output of multi-threaded programs can get scrambled Noteabort() is only called if abort_bool is true and level >= gErrorIgnoreLevel ; Definition at line 67 of file TError.cxx. ◆ NotifyDirected(). void ROOT::Internal::NotifyDirected ; (; Detail::TBranchProxy * ; x). Definition at line 36 of file TBranchProxyDirector.cxx. ◆ operator<<(). std::ostream & ROOT::Internal::operator<< ; (; std::ostream & ; os, . const RConcurrentHashColl::HashValue & ; h . ). Definition at line 24 of file RConcurrentHashColl.cxx. ◆ operator==(). bool ROOT::Internal::operator== ; (; const RConcurrentHashColl::HashValue & ; lhs, . const RConcurrentHashColl::HashValue & ; rhs . ). inline . Definition at line 69 of file RConcurrentHashColl.hxx. ◆ ParallelReduceHelper(). template<typename T > . static T ROOT::Internal::ParallelReduceHelper ; (; const std::vector< T > & ; objs, . const std::function< T(T a, T b)> & ; redfunc . ). static . A helper function to implement the TThreadExecutor::ParallelReduce methods. ; Definition at line 122 of file TThreadExecutor.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:38377,multi-thread,multi-threaded,38377,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,2,['multi-thread'],['multi-threaded']
Performance,"load over the network, so it must be used with care. Int_t SetParallelSilent(Int_t nodes, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. If random is TRUE a random; selection is done (if nodes is less than the available nodes).; Returns the number of parallel slaves. Returns -1 in case of error. Int_t SetParallel(Int_t nodes = -1, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. Returns the number of; parallel slaves. Returns -1 in case of error. Int_t GoMoreParallel(Int_t nWorkersToAdd); Add nWorkersToAdd workers to current list of workers. This function is; works on the master only, and only when an analysis is ongoing. A message; is sent back to the client when we go ""more"" parallel.; Returns -1 on error, number of total (not added!) workers on success. Int_t GoParallel(Int_t nodes, Bool_t accept = kFALSE, Bool_t random = kFALSE); Go in parallel mode with at most ""nodes"" slaves. Since the fSlaves; list is sorted by slave performace the active list will contain first; the most performant nodes. Returns the number of active slaves.; If random is TRUE, and nodes is less than the number of available workers,; a random selection is done.; Returns -1 in case of error. void ShowData(); List contents of the data directory in the sandbox.; This is the place where files produced by the client queries are kept. void ClearData(UInt_t what = kUnregistered, const char* dsname = 0); Remove files for the data directory.; The option 'what' can take the values:; kPurge remove all files and directories under '~/data'; kUnregistered remove only files not in registered datasets (default); kDataset remove files belonging to dataset 'dsname'; User is prompt for confirmation, unless kForceClear is ORed with the option. Bool_t Prompt(const char* p); Prompt the question 'p' requiring an answer y,Y,n,N; Return kTRUE is the answer was y or Y, kFALSE in all other cases. void ClearDataProgress(Int_t r, Int_t t); Progress bar for clear data. void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:68445,perform,performace,68445,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['perform'],"['performace', 'performant']"
Performance,"loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because z cannot accommodate the value 10; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds2) Ignored 36 out-of-range events; RooDataSet::ds2[x,z,y] = 26 entries; [#1] INFO:DataHandling -- RooAbsReal::attachToTree(i) TTree Int_t branch i will be converted to double precision.; RooDataSet::ds3[x,i] = 100 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #2 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #5 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #8 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #11 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds4) Ignored 33 out-of-range events; RooDataSet::ds4[i,x] = 67 entries; RooDataSet::dsABC[x,y,c] = 26 entries; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf401_importttreethx.py. tutorialsroofitrf401_importttreethx.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8py.html:5487,load,loadValues,5487,doc/master/rf401__importttreethx_8py.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8py.html,6,['load'],['loadValues']
Performance,"loatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,double>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction1Binding_double_double_.html:32417,cache,cache,32417,root/html526/RooCFunction1Binding_double_double_.html,https://root.cern,https://root.cern/root/html526/RooCFunction1Binding_double_double_.html,2,['cache'],['cache']
Performance,"loat_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 1899 of file TTreeCache.cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:45822,cache,cache,45822,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,4,"['cache', 'load']","['cache', 'loading']"
Performance,"loating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooSetProxy_varSetNot used anymore?; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooConvCoefVar.html:32717,cache,cache,32717,root/html530/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html530/RooConvCoefVar.html,1,['cache'],['cache']
Performance,"loating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_setset of terms to be summed; TIterator*_setIter! Iterator over set; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddition.html:32714,cache,cache,32714,root/html528/RooAddition.html,https://root.cern,https://root.cern/root/html528/RooAddition.html,1,['cache'],['cache']
Performance,"lobal activation switch for component selection; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooRealProxy_ixfInt(X*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; RooRealProxy_xfX*F ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMoment.html:32321,cache,cache,32321,root/html526/RooMoment.html,https://root.cern,https://root.cern/root/html526/RooMoment.html,2,['cache'],['cache']
Performance,"lobalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCachedReal.h>. Inheritance diagram for RooCachedReal:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCachedReal() [1/4]. RooCachedReal::RooCachedReal ; (; ). inline . Definition at line 22 of file RooCachedReal.h. ◆ RooCachedReal() [2/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func, . const RooArgSet & ; cacheObs . ). Constructor taking name, title and function to be cached and fixed choice of variable to cache. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function. If the fixed set of cache observables does not match the observables defined in the use context of the p.d.f the cache is still filled completely. Ee.g. when it is specified to cache x and p and only x is a observable in the given use context the cache histogram will store sampled values for all values of observable x and parameter p. In such a mode of operation the cache will also not be recalculated if the observable p changes ; Definition at line 68 of file RooCachedReal.cxx. ◆ RooCachedReal() [3/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func . ). Constructor taking name, title and function to be cached. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function ; Definition at line 42 of file RooCachedReal.cxx. ◆ RooCachedReal() [4/4]. RooCachedReal::Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:63702,cache,cache,63702,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,2,['cache'],['cache']
Performance,"location information and attach this TTree to the new directory. ; options: Indicates a basket sorting method, see TTreeCloner::TTreeCloner for details; If new and old directory are in the same file, the data is untouched, this ""just"" does a call to SetDirectory. Equivalent to an ""in place"" cloning of the TTree. ; Reimplemented in TChain.; Definition at line 7012 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 659 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 547 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:170469,Load,LoadBaskets,170469,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['Load'],['LoadBaskets']
Performance,"location information and attach this TTree to the new directory. ; options: Indicates a basket sorting method, see TTreeCloner::TTreeCloner for details; If new and old directory are in the same file, the data is untouched, this ""just"" does a call to SetDirectory. Equivalent to an ""in place"" cloning of the TTree. ; Reimplemented in TChain.; Definition at line 7012 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 705 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 587 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:172657,Load,LoadBaskets,172657,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['Load'],['LoadBaskets']
Performance,"lon; \]. Optionally, the user may impose a functional expression by specifying the powers of each variable in \( L\) specified functions \( F_1, \ldots,F_L\) (TMultiDimFit::SetPowers). In that case, only the coefficients \( c_l\) is calculated by the class. Limiting the Number of Terms; As always when dealing with fits, there's a real chance of over fitting. As is well-known, it's always possible to fit an \( N-1\) polynomial in \( x\) to \( N\) points \( (x,y)\) with \(\chi^2 = 0\), but the polynomial is not likely to fit new data at all 1. Therefore, the user is asked to provide an upper limit, \( L_{max}\) to the number of terms in \( D_p\) (TMultiDimFit::SetMaxTerms).; However, since there's an infinite number of \( F_l\) to choose from, the user is asked to give the maximum power. \( P_{max,i}\), of each variable \( x_i\) to be considered in the minimization of \( S\) (TMultiDimFit::SetMaxPowers).; One way of obtaining values for the maximum power in variable \( i\), is to perform a regular fit to the dependent quantity \( D\), using a polynomial only in \( x_i\). The maximum power is \( P_{max,i}\) is then the power that does not significantly improve the one-dimensional least-square fit over \( x_i\) to \( D\) 5.; There are still a huge amount of possible choices for \( F_l\); in fact there are \(\prod_{i=1}^{N} (P_{max,i} + 1)\) possible choices. Obviously we need to limit this. To this end, the user is asked to set a power control limit, \( Q\) (TMultiDimFit::SetPowerLimit), and a function \( F_l\) is only accepted if ; \[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \]. where \( P_{li}\) is the leading power of variable \( x_i\) in function \( F_l\) (TMultiDimFit::MakeCandidates). So the number of functions increase with \( Q\) (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression, only those functions that significantly reduce \( S\) is chosen. What ‘significant’ means, is ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:4712,perform,perform,4712,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['perform'],['perform']
Performance,"lone list so we can change their branch addresses when necessary.; This is to support the syntax: TTree* clone = chain->GetTree()->CloneTree(0);; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557. Definition at line 1278 of file TChain.cxx. ◆ IsA(). TClass * TChain::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TProofChain.; Definition at line 173 of file TChain.h. ◆ LoadBaskets(). Int_t TChain::LoadBaskets ; (; Long64_t ; maxmemory). overridevirtual . Dummy function. ; It could be implemented and load all baskets of all trees in the chain. For the time being use TChain::Merge and TTree::LoadBasket on the resulting tree. ; Reimplemented from TTree.; Definition at line 1296 of file TChain.cxx. ◆ LoadTree(). Long64_t TChain::LoadTree ; (; Long64_t ; entry). overridevirtual . Find the tree which contains entry, and set it as the current tree. ; Returns the entry number in that tree.; The input argument entry is the entry serial number in the whole chain.; In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number is less than zero or too large for the chain.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or the TTree is missing from the file.; -5: Internal error, please report the circumstance when this happen as a ROOT issue.; -6: An error occurred within the notify callback. Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new sub-tree. See TNotifyLink for more information on the notification mechanism.; NoteThis is the only routine which sets the value of fTree to a non-zero pointer. ; Reimplemented from TTree.; Definition at line 1324 of file T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:81236,Load,LoadTree,81236,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['Load'],['LoadTree']
Performance,"look at the base class of the collection!), we use a custom walk through the tree of base classes that checks their value of fCanSplit.; This also has the side-effect of allowing the extension of the concept ‘base class that prevent its derived class from being split’ to any user class. This fixes [ROOT-7972].; Reduce autoparse occasions by autoloading libraries also based on their type_info-derived name, instead of only their normalized name.; Improve TClassEdit’s handling of STL’s default allocator, in particular for std::map ROOT-8048. Dictionaries. Add the -noIncludePaths and –noIncludePaths to rootcling and genereflex respectively to avoid storing in the dictionaries the include paths passed with the “-I” switch. ROOT will rely on ROOT_INCLUDE_PATH only at runtime to find headers. I/O. Resolve an issue when space is freed in a large ROOT file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file [ROOT-8055]. TTree. Do not automatically setup read cache during TTree::Fill(). This fixes [ROOT-8031]. Fast Cloning. Added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address [ROOT-5078].; The new cache can be controlled from the TTreeCloner, TTree::CopyEntries or hadd interfaces.; The new cache is enabled by default.; To update the size of the cache or disable it:; From TTreeCloner use: TTreeCloner::SetCacheSize; From TTree::CopyEntries add to the option string ""cachesize=SIZE""; From hadd, use the command line option -cachesize SIZE; SIZE should be given in number bytes and can be expressed in ‘human readable form’ (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. Release 6.04/18; Published on 2016-06-22.; Core. Fix the validity of TRef after the first ProcessID is full. TTree. Properly handle the last element of arrays in the TTreeFormula functions MinIf and MaxIf ROOT-7258. Bugs and issues",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:38607,cache,cache,38607,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['cache'],['cache']
Performance,"loop.; 700 ; 701std::map<TString, Double_t> TMVA::Factory::OptimizeAllMethods(TString fomType, TString fitType); 702{; 703 ; 704 std::map<TString, MVector *>::iterator itrMap;; 705 std::map<TString, Double_t> TunedParameters;; 706 for (itrMap = fMethodsMap.begin(); itrMap != fMethodsMap.end(); ++itrMap) {; 707 MVector *methods = itrMap->second;; 708 ; 709 MVector::iterator itrMethod;; 710 ; 711 // iterate over methods and optimize; 712 for (itrMethod = methods->begin(); itrMethod != methods->end(); ++itrMethod) {; 713 Event::SetIsTraining(kTRUE);; 714 MethodBase *mva = dynamic_cast<MethodBase *>(*itrMethod);; 715 if (!mva) {; 716 Log() << kFATAL << ""Dynamic cast to MethodBase failed"" << Endl;; 717 return TunedParameters;; 718 }; 719 ; 720 if (mva->Data()->GetNTrainingEvents() < MinNoTrainingEvents) {; 721 Log() << kWARNING << ""Method "" << mva->GetMethodName() << "" not trained (training tree has less entries [""; 722 << mva->Data()->GetNTrainingEvents() << ""] than required ["" << MinNoTrainingEvents << ""]"" << Endl;; 723 continue;; 724 }; 725 ; 726 Log() << kINFO << ""Optimize method: "" << mva->GetMethodName() << "" for ""; 727 << (fAnalysisType == Types::kRegression; 728 ? ""Regression""; 729 : (fAnalysisType == Types::kMulticlass ? ""Multiclass classification"" : ""Classification"")); 730 << Endl;; 731 ; 732 TunedParameters = mva->OptimizeTuningParameters(fomType, fitType);; 733 Log() << kINFO << ""Optimization of tuning parameters finished for Method:"" << mva->GetName() << Endl;; 734 }; 735 }; 736 ; 737 return TunedParameters;; 738}; 739 ; 740////////////////////////////////////////////////////////////////////////////////; 741/// Private method to generate a ROCCurve instance for a given method.; 742/// Handles the conversion from TMVA ResultSet to a format the ROCCurve class; 743/// understands.; 744///; 745/// \note You own the retured pointer.; 746///; 747 ; 748TMVA::ROCCurve *; 749TMVA::Factory::GetROC(TMVA::DataLoader *loader, TString theMethodName, UInt_t iClass, Types::E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:28698,optimiz,optimize,28698,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,7,"['Optimiz', 'Tune', 'optimiz']","['Optimization', 'Optimize', 'OptimizeTuningParameters', 'TunedParameters', 'optimize']"
Performance,"lor palette defined by `gStyle->SetPalette()`.; 1828 ; 1829Begin_Macro(source); 1830{; 1831 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 1832 auto hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; 1833 float px, py;; 1834 for (Int_t i = 0; i < 25000; i++) {; 1835 gRandom->Rannor(px,py);; 1836 hcont4->Fill(px-1,5*py);; 1837 hcont4->Fill(2+0.5*px,2*py-10.,0.1);; 1838 }; 1839 hcont4->Draw(""CONT4Z"");; 1840}; 1841End_Macro; 1842 ; 1843The default number of contour levels is 20 equidistant levels and can be changed; 1844with `TH1::SetContour()` or `TStyle::SetNumberContours()`.; 1845 ; 1846\anchor HP16a; 1847#### The LIST option; 1848 ; 1849When option `LIST` is specified together with option; 1850`CONT`, the points used to draw the contours are saved in; 1851`TGraph` objects:; 1852 ; 1853 h->Draw(""CONT LIST"");; 1854 gPad->Update();; 1855 ; 1856The contour are saved in `TGraph` objects once the pad is painted.; 1857Therefore to use this functionality in a macro, `gPad->Update()`; 1858should be performed after the histogram drawing. Once the list is; 1859built, the contours are accessible in the following way:; 1860 ; 1861 TObjArray *contours = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; 1862 Int_t ncontours = contours->GetSize();; 1863 TList *list = (TList*)contours->At(i);; 1864 ; 1865Where `i` is a contour number, and list contains a list of; 1866`TGraph` objects.; 1867For one given contour, more than one disjoint polyline may be generated.; 1868The number of TGraphs per contour is given by:; 1869 ; 1870 list->GetSize();; 1871 ; 1872To access the first graph in the list one should do:; 1873 ; 1874 TGraph *gr1 = (TGraph*)list->First();; 1875 ; 1876 ; 1877The following example (ContourList.C) shows how to use this functionality.; 1878 ; 1879Begin_Macro(source); 1880../../../tutorials/hist/ContourList.C; 1881End_Macro; 1882 ; 1883\anchor HP16b; 1884#### The AITOFF, MERCATOR, SINUSOIDAL and PARABOLIC options; 1885 ; 1886The followin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:77711,perform,performed,77711,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['perform'],['performed']
Performance,"lor(""reset"") << Endl;; 1274 ; 1275 // don't do anything if no method booked; 1276 if (fMethodsMap.empty()) {; 1277 Log() << kINFO << ""...nothing found to test"" << Endl;; 1278 return;; 1279 }; 1280 std::map<TString, MVector *>::iterator itrMap;; 1281 ; 1282 for (itrMap = fMethodsMap.begin(); itrMap != fMethodsMap.end(); ++itrMap) {; 1283 MVector *methods = itrMap->second;; 1284 MVector::iterator itrMethod;; 1285 ; 1286 // iterate over methods and test; 1287 for (itrMethod = methods->begin(); itrMethod != methods->end(); ++itrMethod) {; 1288 Event::SetIsTraining(kFALSE);; 1289 MethodBase *mva = dynamic_cast<MethodBase *>(*itrMethod);; 1290 if (mva == 0); 1291 continue;; 1292 Types::EAnalysisType analysisType = mva->GetAnalysisType();; 1293 Log() << kHEADER << ""Test method: "" << mva->GetMethodName() << "" for ""; 1294 << (analysisType == Types::kRegression; 1295 ? ""Regression""; 1296 : (analysisType == Types::kMulticlass ? ""Multiclass classification"" : ""Classification"")); 1297 << "" performance"" << Endl << Endl;; 1298 mva->AddOutput(Types::kTesting, analysisType);; 1299 }; 1300 }; 1301}; 1302 ; 1303////////////////////////////////////////////////////////////////////////////////; 1304 ; 1305void TMVA::Factory::MakeClass(const TString &datasetname, const TString &methodTitle) const; 1306{; 1307 if (methodTitle != """") {; 1308 IMethod *method = GetMethod(datasetname, methodTitle);; 1309 if (method); 1310 method->MakeClass();; 1311 else {; 1312 Log() << kWARNING << ""<MakeClass> Could not find classifier \"""" << methodTitle << ""\"" in list"" << Endl;; 1313 }; 1314 } else {; 1315 ; 1316 // no classifier specified, print all help messages; 1317 MVector *methods = fMethodsMap.find(datasetname)->second;; 1318 MVector::const_iterator itrMethod;; 1319 for (itrMethod = methods->begin(); itrMethod != methods->end(); ++itrMethod) {; 1320 MethodBase *method = dynamic_cast<MethodBase *>(*itrMethod);; 1321 if (method == 0); 1322 continue;; 1323 Log() << kINFO << ""Make response class for classi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:53063,perform,performance,53063,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['perform'],['performance']
Performance,"lor(). void TEveGeoNode::SetMainColor ; (; Color_t ; color). overridevirtual . Set color, propagate to volume's line color. ; Reimplemented from TEveElement.; Definition at line 185 of file TEveGeoNode.cxx. ◆ SetMainTransparency(). void TEveGeoNode::SetMainTransparency ; (; Char_t ; t). overridevirtual . Set transparency, propagate to volume's transparency. ; Reimplemented from TEveElement.; Definition at line 210 of file TEveGeoNode.cxx. ◆ Streamer(). void TEveGeoNode::Streamer ; (; TBuffer & ; ). overridevirtual . Reimplemented from TEveElement.; Reimplemented in TEveGeoTopNode. ◆ StreamerNVirtual(). void TEveGeoNode::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 84 of file TEveGeoNode.h. ◆ UpdateNode(). void TEveGeoNode::UpdateNode ; (; TGeoNode * ; node). Updates all reve-browsers having the node in their contents. ; All 3D-pads updated if any change found.; Should (could?) be optimized with some assumptions about volume/node structure (search for parent, know the same node can not reoccur on lower level once found). ; Definition at line 224 of file TEveGeoNode.cxx. ◆ UpdateVolume(). void TEveGeoNode::UpdateVolume ; (; TGeoVolume * ; volume). Updates all reve-browsers having the volume in their contents. ; All 3D-pads updated if any change found.; Should (could?) be optimized with some assumptions about volume/node structure (search for parent, know the same node can not reoccur on lower level once found). ; Definition at line 246 of file TEveGeoNode.cxx. ◆ WriteExtract(). void TEveGeoNode::WriteExtract ; (; const char * ; name, . Bool_t ; leafs_only . ). Write the shape tree as TEveGeoShapeExtract to current directory. ; Definition at line 302 of file TEveGeoNode.cxx. Friends And Related Symbol Documentation. ◆ TEveGeoNodeEditor. friend class TEveGeoNodeEditor. friend . Definition at line 31 of file TEveGeoNode.h. Member Data Documentation. ◆ fgCSGExportNSeg. Int_t TEveGeoNode::fgCSGExportNSeg = 64. staticprotected .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveGeoNode.html:37857,optimiz,optimized,37857,doc/master/classTEveGeoNode.html,https://root.cern,https://root.cern/doc/master/classTEveGeoNode.html,1,['optimiz'],['optimized']
Performance,"lor. The color is the color index. The colors are described in “Color and Color Palettes”.; root[] la->SetTextColor(color); 9.6.1.4 Setting Text Font; Use TAttText::SetTextFont to set the font. The parameter font is the font code, combining the font and precision: font = 10 * fontID + precision; root[] la->SetTextFont(font); The table below lists the available fonts. The font IDs must be between 1 and 14. The precision can be:. Precision = 0 fast hardware fonts (steps in the size); Precision = 1 scalable and rotate-able hardware fonts (see below); Precision = 2 scalable and rotate-able hardware fonts. When precision 0 is used, only the original non-scaled system fonts are used. The fonts have a minimum (4) and maximum (37) size in pixels. These fonts are fast and are of good quality. Their size varies with large steps and they cannot be rotated. Precision 1 and 2 fonts have a different behavior depending if True Type Fonts (TTF) are used or not. If TTF are used, you always get very good quality scalable and rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a different behavior for PostScript in case of TLatex objects:. With precision 1, the PostScript text uses the old convention (see TPostScript) for some special characters to draw sub and superscripts or Greek text.; With precision 2, the “PostScript” special characters are drawn as such. To draw sub and superscripts it is highly recommended to use TLatex objects instead. For example: font = 62 is the font with ID 6 and precision 2. Font’s examples. The available fonts are:. Font ID; X11; True Type name; Is italic; “boldness”. 1; times-medium-i-normal; “Times New Roman”; Yes; 4. 2; times-bold-r-normal; “Times New Roman”; No; 7. 3; times-bold-i-normal; “Times New Roman”; Yes; 7. 4; helvetica-medium-r-norma l; “Arial”; No; 4. 5; helvetica-medium-o-norma l; “Arial”; Yes; 4. 6; helvetica-bold-r-normal; “Arial”; No; 7. 7; helvetica-bold-o-normal; “Arial”; Yes; 7. 8; courier-medium-r-normal; “Courie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:355109,scalab,scalable,355109,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['scalab'],['scalable']
Performance,"lor_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArray*fMatricesglobal transformation matrices; TGeoHMatrix*fMatrixOrigoriginal local matrix of the last node in the path; TStringTNamed::fNameobject identifier; TObjArray*fNodesbranch of nodes; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPhysicalNode(); Default constructor. TGeoPhysicalNode(const char* path); Constructor. TGeoPhysicalNode(const TGeoPhysicalNode& ); copy constructor. TGeoPhysicalNode& operator=(const TGeoPhysicalNode& ); assignment operator. ~TGeoPhysicalNode(); Destructor. Bool_t Align(TGeoMatrix* newmat = 0, TGeoShape* newshape = 0, Bool_t check = kFALSE, Double_t ovlp = 0.001); Align a physical node with a new relative matrix/shape.; Example: /TOP_1/A_1/B_1/C_1; node->Align(transl_1, box) will perform:; - change RELATIVE translation of C_1 node (with respect to its; container volume B) to transl_1; - change the shape of the C volume; *NOTE* The operations will affect ONLY the LAST node in the branch. All; volumes/nodes in the branch represented by this physical node are; CLONED so the operation does not affect other possible replicas. void cd() const. void Draw(Option_t* option = """"); Draw this node. TGeoNode * GetMother(Int_t levup = 1) const; Return parent at LEVUP generation. TGeoHMatrix * GetMatrix(Int_t level = -1) const; Return global matrix for node at LEVEL. TGeoNode * GetNode(Int_t level = -1) const; Return node in branch at LEVEL. If not specified, return last leaf. TGeoVolume * GetVolume(Int_t level = -1) const; Return volume associated with node at LEVEL in the branch. TGeoShape * GetShape(Int_t level = -1) const; Return shape associated with volume. void Paint(Option_t* option = """"); Paint this node and its content according to visualization settings. void Print(Option_t* option = """") const; Print info about this node. void Refresh();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPhysicalNode.html:9624,perform,perform,9624,root/html534/TGeoPhysicalNode.html,https://root.cern,https://root.cern/root/html534/TGeoPhysicalNode.html,3,['perform'],['perform']
Performance,"lormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TCanvasThe Canvas class.Definition TCanvas.h:23; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TMVA::ConfigurableDefinition Configurable.h:45; TMVA::CrossValidationClass to perform cross validation, splitting the dataloader into folds.Definition CrossValidation.h:124; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Factory::PrintHelpMessagevoid PrintHelpMessage(const TString &datasetname, const TString &methodTitle="""") constPrint predefined help message of classifier.Definition Factory.cxx:1333; TMVA::Factory::fSilentFileBool_t fSilentFile! used in constructor without fileDefinition Factory.h:217; TMVA::Factory::fCorrelationsBool_t fCorrelations! enable to calculate correlationsDefinition Factory.h:215; TMVA::Factory::IsModelPersistenceBool_t IsModelPersistence() constDefinition Factory.h:152; TMVA::Factory::fOptionsTString fOptions! option string given by construction (presently only ""V"")Definition Factory.h:211; TMVA::Factory::MVectorstd::vector< IMethod * > MVectorDefinition Factory.h:84; TMVA::Factor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:11913,perform,perform,11913,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['perform'],['perform']
Performance,"lot (project) PDF on specified frame. ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual RooPlot * plotSliceOn (RooPlot *frame, const RooArgSet &sliceSet, Option_t *drawOptions=""L"", double scaleFactor=1.0, ScaleType stype=Relative, const RooAbsData *projData=nullptr) const;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the special",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:17542,cache,cache,17542,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,1,['cache'],['cache']
Performance,"lot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TString_rangeName; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRangeBoolean(); Default constructor. RooRangeBoolean(const char* name, const char* title, RooAbsRealLValue& x, const char* rangeNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRangeBoolean.html:34460,cache,cache,34460,root/html534/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html534/RooRangeBoolean.html,2,['cache'],['cache']
Performance,"lot* frame, RooAbsData::PlotOpt o) const; Back end function to plotting functionality. Plot RooDataHist on given; frame in mode specified by plot options 'o'. The main purpose of; this function is to match the specified binning on 'o' to the; internal binning of the plot observable in this RooDataHist. Double_t weightSquared() const. Double_t weight(const RooArgSet& bin, Int_t intOrder = 1, Bool_t correctForBinSize = kFALSE, Bool_t cdfBoundaries = kFALSE, Bool_t oneSafe = kFALSE); Return the weight at given coordinates with optional; interpolation. If intOrder is zero, the weight; for the bin enclosing the coordinates; contained in 'bin' is returned. For higher values,; the result is interpolated in the real dimensions; of the dataset. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return the error on current weight. Double_t interpolateDim(RooRealVar& dim, const RooAbsBinning* binning, Double_t xval, Int_t intOrder, Bool_t correctForBinSize, Bool_t cdfBoundaries); Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim'; at current value 'xval'. void add(const RooArgSet& row, Double_t weight, Double_t sumw2); Increment the weight of the bin enclosing the coordinates given; by 'row' by the specified amount. Add the sum of weights squared; for the bin by 'sumw2' rather than wgt^2. void set(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataHist.html:29604,Perform,Perform,29604,root/html534/RooDataHist.html,https://root.cern,https://root.cern/root/html534/RooDataHist.html,3,['Perform'],['Perform']
Performance,"lotEntry() Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. . Vary() Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). . Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide.; In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters.; Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to produce many different results in one event loop. Instant actions trigger the event loop instantly. Lazy action Description . Aggregate() Execute a user-defined accumulation operation on the processed column values. . Book() Book execution of a custom action using a user-defined helper object. . Cache() Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). . Count() Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. . Display() Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. . Fill() Fill a user-defined object with the values of the specified columns, as if by calling Obj.Fill(col1, col2, ...). . Graph() Fills a TGraph with the two columns provided. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. . GraphAsymmErrors() Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. . Histo1D(), Histo2D(), Histo3D() Fill a one-, two-, three-dimensional histogr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:5227,cache,cached,5227,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,4,['cache'],['cached']
Performance,"lotOn() call. See that function for allowed options. RooPlot* makeFrameAndPlotCmd(const RooRealVar& param, RooLinkedList& cmdList, Bool_t symRange = kFALSE) const; Internal function. Construct RooPlot from given parameter and modify the list of named; arguments 'cmdList' to only contain the plot arguments that should be forwarded to; RooAbsData::plotOn(). RooPlot* plotNLL(Double_t lo, Double_t hi, Int_t nBins = 100); Create a RooPlot of the -log(L) distribution in the range lo-hi; with 'nBins' bins. RooPlot* plotError(const RooRealVar& param, Double_t lo, Double_t hi, Int_t nbins = 100); Create a RooPlot of the distribution of the fitted errors of the given parameter.; The frame is created with a range [lo,hi] and plotted data will be binned in 'nbins' bins. RooPlot* plotPull(const RooRealVar& param, Double_t lo = -3.0, Double_t hi = 3.0, Int_t nbins = 25, Bool_t fitGauss = kFALSE); Create a RooPlot of the pull distribution for the given; parameter. The range lo-hi is plotted in nbins. If fitGauss is; set, an unbinned ML fit of the distribution to a Gaussian p.d.f; is performed. The fit result is overlaid on the returned RooPlot; and a box with the fitted mean and sigma is added. RooMCStudy(const RooAbsPdf& model, const RooArgSet& observables, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()). const RooDataSet* genParDataSet() const; Return dataset with generator parameters for each toy. When constraints are used these; may generally not be the same. » Last changed: Mon Jul 4 15:23:17 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMCStudy.html:26808,perform,performed,26808,root/html530/RooMCStudy.html,https://root.cern,https://root.cern/root/html530/RooMCStudy.html,1,['perform'],['performed']
Performance,"lotOn() call. See that function for allowed options. RooPlot* makeFrameAndPlotCmd(const RooRealVar& param, RooLinkedList& cmdList, Bool_t symRange = kFALSE) const; Internal function. Construct RooPlot from given parameter and modify the list of named; arguments 'cmdList' to only contain the plot arguments that should be forwarded to; RooAbsData::plotOn(). RooPlot* plotNLL(Double_t lo, Double_t hi, Int_t nBins = 100); Create a RooPlot of the -log(L) distribution in the range lo-hi; with 'nBins' bins. RooPlot* plotError(const RooRealVar& param, Double_t lo, Double_t hi, Int_t nbins = 100); Create a RooPlot of the distribution of the fitted errors of the given parameter.; The frame is created with a range [lo,hi] and plotted data will be binned in 'nbins' bins. RooPlot* plotPull(const RooRealVar& param, Double_t lo = -3.0, Double_t hi = 3.0, Int_t nbins = 25, Bool_t fitGauss = kFALSE); Create a RooPlot of the pull distribution for the given; parameter. The range lo-hi is plotted in nbins. If fitGauss is; set, an unbinned ML fit of the distribution to a Gaussian p.d.f; is performed. The fit result is overlaid on the returned RooPlot; and a box with the fitted mean and sigma is added. RooMCStudy(const RooAbsPdf& model, const RooArgSet& observables, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()). const RooDataSet* genParDataSet() const; Return dataset with generator parameters for each toy. When constraints are used these; may generally not be the same. » Last changed: Thu Nov 3 20:08:34 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMCStudy.html:26808,perform,performed,26808,root/html532/RooMCStudy.html,https://root.cern,https://root.cern/root/html532/RooMCStudy.html,1,['perform'],['performed']
Performance,"low),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(""h1test.C+"");; TFile *f2 = new TFile(""stubs_nood_le1_coa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:49895,load,loaded,49895,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,9,['load'],['loaded']
Performance,"lowing code is equivalent in PyROOT: # Directly passing a RooCmdArg:; var.plotOn(frame, ROOT.RooFit.Components(""background"")); ; # With keyword arguments:; var.plotOn(frame, Components=""background""). Definition at line 59 of file RooAbsReal.h. Classes; class  EvalError;  ; class  EvalErrorContext;  Context to temporarily change the error logging mode as long as the context is alive. More...;  ; struct  GlobalSelectComponentRAII;  ; struct  PlotOpt;  ; class  Ref;  A RooAbsReal::Ref can be constructed from a RooAbsReal& or a double that will be implicitly converted to a RooConstVar&. More...;  . Public Types; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAdd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:1986,Cache,CacheMode,1986,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['Cache'],['CacheMode']
Performance,"lper routine for TCling::AutoParse implementing the actual call to the parser and looping over template parameters (if any) and when they don't have a registered header to autoparse, recurse over their template parameters. ;  ; void Execute (TMethod *, TObjArray *, int *=nullptr) final;  Execute method on this object with parameters stored in the TObjArray. ;  ; DeclId_t GetDeclId (const llvm::GlobalValue *gv) const;  Return pointer to cling DeclId for a global value. ;  ; cling::Interpreter * GetInterpreterImpl () const;  ; cling::MetaProcessor * GetMetaProcessorImpl () const;  ; Bool_t HandleNewTransaction (const cling::Transaction &T);  Helper function to increase the internal Cling count of transactions that change the AST. ;  ; void InitRootmapFile (const char *name);  Create a resource table and read the (possibly) three resource files, i.e. ;  ; void InvalidateCachedDecl (const std::tuple< TListOfDataMembers *, TListOfFunctions *, TListOfFunctionTemplates *, TListOfEnums * > &Lists, const clang::Decl *D);  Invalidate cached TCling information for the given declaration, and removed it from the appropriate object list. ;  ; bool IsClassAutoLoadingEnabled () const;  Returns if class AutoLoading is currently enabled. ;  ; void LoadPCM (std::string pcmFileNameFullPath);  Tries to load a rdict PCM, issues diagnostics if it fails. ;  ; void LoadPCMImpl (TFile &pcmFile);  Tries to load a PCM from TFile; returns true on success. ;  ; TCling & operator= (const TCling &)=delete;  ; void ProcessClassesToUpdate ();  ; int ReadRootmapFile (const char *rootmapfile, TUniqueString *uniqueString=nullptr);  Read and parse a rootmapfile in its new format, and return 0 in case of success, -1 if the file has already been read, and -3 in case its format is the old one (e.g. ;  ; void RegisterLoadedSharedLibrary (const char *name);  Register a new shared library name with the interpreter; add it to fSharedLibs. ;  ; void RegisterRdictForLoadPCM (const std::string &pcmFileNameFullPat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:47450,cache,cached,47450,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['cache'],['cached']
Performance,"lptr) final;  Let cling process a command line synchronously, i.e we are waiting it will be finished. ;  ; void RecursiveRemove (TObject *obj) final;  Delete object from cling symbol table so it can not be used anymore. ;  ; void RefreshClassInfo (TClass *cl, const clang::NamedDecl *def, bool alias);  Internal function. Actually do the update of the ClassInfo when seeing. ;  ; void RegisterModule (const char *modulename, const char **headers, const char **includePaths, const char *payloadCode, const char *fwdDeclsCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false) final;  Inject the module named ""modulename"" into cling; load all headers. ;  ; bool RegisterPrebuiltModulePath (const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const final;  ; void RegisterTClassUpdate (TClass *oldcl, DictFuncPtr_t dict) final;  Register classes that already existed prior to their dictionary loading and that already had a ClassInfo (and thus would not be refresh via UpdateClassInfo. ;  ; void RegisterTemporary (const cling::Value &value);  Register value as a temporary, extending its lifetime to that of the interpreter. ;  ; void RegisterTemporary (const TInterpreterValue &value);  ; Int_t ReloadAllSharedLibraryMaps () final;  Reload the library map entries coming from all the loaded shared libraries, after first unloading the current ones. ;  ; void ReportDiagnosticsToErrorHandler (bool enable=true) final;  Report diagnostics to the ROOT error handler (see TError.h). ;  ; Int_t RescanLibraryMap () final;  Scan again along the dynamic path for library maps. ;  ; void Reset () final;  Pressing Ctrl+C should forward here. ;  ; void ResetAll () final;  Reset the Cling state to its initial state. ;  ; void ResetGlobals () final;  Reset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobalsContext(). ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:28393,load,loading,28393,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['loading']
Performance,"lptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Return the observables to be cached given the normalization set nset. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Return the parameters on which the cache depends given normalization set nset. ;  ; void calcParams ();  (Re)calculate effective parameters of this p.d.f. ;  ; PdfCacheElem * createCache (const RooArgSet *nset) const override;  Return specialized cache subclass for FFT calculations. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillCacheObject (PdfCacheElem &cache) const override;  Fill the contents of the cache the FFT convolution output. ;  ; void fillCacheSlice (FFTCacheElem &cache, const RooArgSet &slicePosition) const;  Fill a slice of cachePdf with the output of the FFT convolution calculation. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create appropriate generator context for this convolution. ;  ; TString histNameSuffix () const override;  Suffix for cache histogram (added in addition to suffix for cache name) ;  ; const char * inputBaseName () const override;  Return base name component for cache components in this case 'PDF1_CONV_PDF2'. ;  ; RooAbsArg & pdfObservable (RooAbsArg &histObservable) const override;  Return p.d.f. ;  ; std::vector< double > scanPdf (RooRealVar &obs, RooAbsPdf &pdf, const RooDataHist &hist, const RooArgSet &slicePos, Int_t &N, Int_t &N2, Int_t &zeroBin, double shift) const;  Scan the values of 'pdf' ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:68797,cache,cache,68797,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,2,['cache'],['cache']
Performance,"lptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::fArgvchar ** fArgvDefinition TApplication.h:59; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBrowser::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove obj from browser.Definition TBrowser.cxx:408; TBrowser::Addvoid Add(TObject *obj, const char *name=nullptr, Int_t check=-1)Add object with name to browser.Definition TBrowser.cxx:303; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3929; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3753; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::GetMethodAllAnyTMethod * GetMethodAllAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4451; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TColor::InitializeColorsstatic void InitializeColors()Initialize colors used by the TCanvas based graphics (via TColor objects).Definition TColor.cxx:1167; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:95317,load,load,95317,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['load'],['load']
Performance,"ls to a failure. ; Reimplemented in TProofLite.; Definition at line 11046 of file TProof.cxx. ◆ cd(). void TProof::cd ; (; Int_t ; id = -1). Set session with 'id' the default one. ; If 'id' is not found in the list, the current session is set as default ; Definition at line 10496 of file TProof.cxx. ◆ CheckFile(). Bool_t TProof::CheckFile ; (; const char * ; file, . TSlave * ; slave, . Long_t ; modtime, . Int_t ; cpopt = (kCp | kCpBin) . ). private . Check if a file needs to be send to the slave. ; Use the following algorithm:; check if file appears in file map; if yes, get file's modtime and check against time in map, if modtime not same get md5 and compare against md5 in map, if not same return kTRUE.; if no, get file's md5 and modtime and store in file map, ask slave if file exists with specific md5, if yes return kFALSE, if no return kTRUE. The options 'cpopt' define if to copy things from cache to sandbox and what. To retrieve from the cache the binaries associated with the file TProof::kCpBin must be set in cpopt; the default is copy everything. Returns kTRUE in case file needs to be send, returns kFALSE in case file is already on remote node. . Definition at line 6799 of file TProof.cxx. ◆ Class(). static TClass * TProof::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TProof::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TProof::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 1073 of file TProof.h. ◆ CleanGDirectory(). void TProof::CleanGDirectory ; (; TList * ; ol). private . Remove links to objects in list 'ol' from gDirectory. ; Definition at line 3046 of file TProof.cxx. ◆ CleanupSession(). Int_t TProof::CleanupSession ; (; const char * ; sessiontag). Send cleanup request for the session specified by tag. ; Definition at line 6092 of file TProof.cxx. ◆ ClearCache(). void TProof::ClearCache ; (; const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:73309,cache,cache,73309,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['cache'],['cache']
Performance,"ls, which can be selected by the “Advanced Drawing Tool” panel that pops up when clicking the “Advanced” button, are:. Contour: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour (more points might require more time to compute it), the parameters and the desired confidence level .; Scan : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter.; Conf Interval : to plot the confidence interval of the fitted function as a filled coloured band around its central value. One can select the desired confidence level for the band to be plotted. 5.6.5 Print Options; This set of options specifies the amount of feedback printed on the root command line after performed fits.; ‘Verbose’ - prints fit results after each iteration.; ‘Quiet’ - no fit information is printed.; ‘Default’ - between Verbose and Quiet.; 5.6.6 Command Buttons; Fit button - performs a fit taking different option settings via the Fit Panel interface.; Reset - sets the GUI elements and related fit settings to the default ones.; Close - closes the Fit panel window.; 5.6.7 Minimization Options; With this tab one can select specific options for minimization. These include. The minimizer library ( Minuit, Minuit2, Fumili, GSL, Genetics ); The method (algorithm) for minimization. For example for Minuit one can choose between (Migrad, Simplex or Scan); Error definition; Minimization tolerance; Number of iterations/function calls; Print Level: (Default, Verbose or Quiet). 5.7 New ROOT::Fit classes; The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes, which are defined in the ROOT::Fit namespace. These classes can be classified in the following groups:. User classes driving the fit: ROOT::Fit::Fitter for executing the fit, ROOT::Fit::FitConfig for configuring the fit, ROOT::Fit::ParameterSettings to define the properties of the fit p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:187617,perform,performs,187617,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performs']
Performance,"ls.h. ◆ RandomizeCollection(). void RooStats::RandomizeCollection ; (; RooAbsCollection & ; set, . bool ; randomizeConstants = true . ). inline . assuming all values in set are RooRealVars, randomize their values ; Definition at line 98 of file RooStatsUtils.h. ◆ RemoveConstantParameters() [1/2]. void RooStats::RemoveConstantParameters ; (; RooArgList & ; set). inline . Definition at line 75 of file RooStatsUtils.h. ◆ RemoveConstantParameters() [2/2]. void RooStats::RemoveConstantParameters ; (; RooArgSet * ; set). inline . Definition at line 67 of file RooStatsUtils.h. ◆ SetAllConstant(). bool RooStats::SetAllConstant ; (; const RooAbsCollection & ; coll, . bool ; constant = true . ). inline . utility function to set all variable constant in a collection (from G. ; Petrucciani) ; Definition at line 85 of file RooStatsUtils.h. ◆ SetParameters(). void RooStats::SetParameters ; (; const RooArgSet * ; desiredVals, . RooArgSet * ; paramsToChange . ). inline . Definition at line 63 of file RooStatsUtils.h. ◆ SignificanceToPValue(). double RooStats::SignificanceToPValue ; (; double ; Z). inline . returns p-value corresponding to a 1-sided significance ; Definition at line 54 of file RooStatsUtils.h. ◆ StripConstraints(). RooAbsPdf * RooStats::StripConstraints ; (; RooAbsPdf & ; pdf, . const RooArgSet & ; observables . ). Definition at line 156 of file RooStatsUtils.cxx. ◆ UseNLLOffset(). void RooStats::UseNLLOffset ; (; bool ; on). function to set a global flag in RooStats to use NLL offset when performing nll computations Note that not all ROoStats tools implement this capabilities ; Use an offset in NLL calculations. ; Definition at line 82 of file RooStatsUtils.cxx. Variable Documentation. ◆ kRootFinderType. const ROOT::Math::RootFinder::EType RooStats::kRootFinderType = ROOT::Math::RootFinder::kBRENT. Definition at line 100 of file BayesianCalculator.cxx. RooStats. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:53 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:17695,perform,performing,17695,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['perform'],['performing']
Performance,"ls_df = df.Cache(myRegexp);. Definition at line 1459 of file RInterface.hxx. ◆ Cache() [2/4]. template<typename Proxied , typename DataSource = void> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; const ColumnNames_t & ; columnList). inline . Save selected columns in memory. ; Parameters. [in]columnListcolumns to be cached in memory . Returnsa RDataFrame that wraps the cached dataset.; See the previous overloads for more information. ; Definition at line 1471 of file RInterface.hxx. ◆ Cache() [3/4]. template<typename Proxied , typename DataSource = void> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; std::initializer_list< std::string > ; columnList). inline . Save selected columns in memory. ; Parameters. [in]columnListcolumns to be cached in memory. . Returnsa RDataFrame that wraps the cached dataset.; See the previous overloads for more information. ; Definition at line 1546 of file RInterface.hxx. ◆ Cache() [4/4]. template<typename Proxied , typename DataSource = void> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; std::string_view ; columnNameRegexp = """"). inline . Save selected columns in memory. ; Parameters. [in]columnNameRegexpThe regular expression to match the column names to be selected. The presence of a '^' and a '$' at the end of the string is implicitly assumed if they are not specified. The dialect supported is PCRE via the TPRegexp class. An empty string signals the selection of all columns. . Returnsa RDataFrame that wraps the cached dataset.; The existing columns are matched against the regular expression. If the string provided is empty, all columns are selected. See the previous overloads for more information. ; Definition at line 1520 of file RInterface.hxx. ◆ CacheImpl(). template<typename Proxied , typename DataSource = void> . template<typename... ColTypes, std::size_t... S> . RInterface< RLoopManager > ROOT::RDF::RInterface< ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:44287,Cache,Cache,44287,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['Cache'],['Cache']
Performance,"lse if (optimizer == ""ADADELTA"") {; 363 settings.optimizer = DNN::EOptimizer::kAdadelta;; 364 } else {; 365 // Make Adam as default choice if the input string is; 366 // incorrect.; 367 settings.optimizer = DNN::EOptimizer::kAdam;; 368 settings.optimizerName = ""ADAM"";; 369 }; 370 // check for specific optimizer parameters; 371 std::vector<TString> optimParamLabels = {""_beta1"", ""_beta2"", ""_eps"", ""_rho""};; 372 //default values; 373 std::map<TString, double> defaultValues = {; 374 {""ADADELTA_eps"", 1.E-8}, {""ADADELTA_rho"", 0.95},; 375 {""ADAGRAD_eps"", 1.E-8},; 376 {""ADAM_beta1"", 0.9}, {""ADAM_beta2"", 0.999}, {""ADAM_eps"", 1.E-7},; 377 {""RMSPROP_eps"", 1.E-7}, {""RMSPROP_rho"", 0.9},; 378 };; 379 for (auto &pN : optimParamLabels) {; 380 TString optimParamName = settings.optimizerName + pN;; 381 // check if optimizer has default values for this specific parameters; 382 if (defaultValues.count(optimParamName) > 0) {; 383 double defValue = defaultValues[optimParamName];; 384 double val = fetchValueTmp(block, optimParamName, defValue);; 385 // create entry in settings for this optimizer parameter; 386 settings.optimizerParams[optimParamName] = val;; 387 }; 388 }; 389 ; 390 fTrainingSettings.push_back(settings);; 391 }; 392 ; 393 // this set fInputShape[0] = batchSize; 394 this->SetBatchSize(fTrainingSettings.front().batchSize);; 395 ; 396 // case inputlayout and batch layout was not given. Use default then; 397 // (1, batchsize, nvariables); 398 // fInputShape[0] -> BatchSize; 399 // fInputShape[1] -> InputDepth; 400 // fInputShape[2] -> InputHeight; 401 // fInputShape[3] -> InputWidth; 402 if (fInputShape[3] == 0 && fInputShape[2] == 0 && fInputShape[1] == 0) {; 403 fInputShape[1] = 1;; 404 fInputShape[2] = 1;; 405 fInputShape[3] = GetNVariables();; 406 }; 407 // case when batch layout is not provided (all zero); 408 // batch layout can be determined by the input layout + batch size; 409 // case DNN : { 1, B, W }; 410 // case CNN : { B, C, H*W}; 411 // case RNN : { B, T, H*W }; 41",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:15192,optimiz,optimizer,15192,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['optimiz'],['optimizer']
Performance,"lse keep the old zipmode (e.g. ""3"") as ""Root.CompressionAlgorithm""; 2026 // if ""Root.CompressionAlgorithm"" isn't set; see below.; 2027 }; 2028 ; 2029 Int_t zipmode = gEnv->GetValue(""Root.CompressionAlgorithm"", oldzipmode);; 2030 if (zipmode != 0) R__SetZipMode(zipmode);; 2031 ; 2032 const char *sdeb;; 2033 if ((sdeb = gSystem->Getenv(""ROOTDEBUG""))); 2034 gDebug = atoi(sdeb);; 2035 ; 2036 if (gDebug > 0 && isatty(2)); 2037 fprintf(stderr, ""Info in <TROOT::InitSystem>: running with gDebug = %d\n"", gDebug);; 2038 ; 2039#if defined(R__HAS_COCOA); 2040 // create and delete a dummy TUrl so that TObjectStat table does not contain; 2041 // objects that are deleted after recording is turned-off (in next line),; 2042 // like the TUrl::fgSpecialProtocols list entries which are created in the; 2043 // TMacOSXSystem ctor.; 2044 { TUrl dummy(""/dummy""); }; 2045#endif; 2046 TObject::SetObjectStat(gEnv->GetValue(""Root.ObjectStat"", 0));; 2047 }; 2048}; 2049 ; 2050////////////////////////////////////////////////////////////////////////////////; 2051/// Load and initialize thread library.; 2052 ; 2053void TROOT::InitThreads(); 2054{; 2055 if (gEnv->GetValue(""Root.UseThreads"", 0) || gEnv->GetValue(""Root.EnableThreadSafety"", 0)) {; 2056 ROOT::EnableThreadSafety();; 2057 }; 2058}; 2059 ; 2060////////////////////////////////////////////////////////////////////////////////; 2061/// Initialize the interpreter. Should be called only after main(),; 2062/// to make sure LLVM/Clang is fully initialized.; 2063 ; 2064void TROOT::InitInterpreter(); 2065{; 2066 // usedToIdentifyRootClingByDlSym is available when TROOT is part of; 2067 // rootcling.; 2068 if (!dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym""); 2069 && !dlsym(RTLD_DEFAULT, ""usedToIdentifyStaticRoot"")) {; 2070 char *libRIO = gSystem->DynamicPathName(""libRIO"");; 2071 void *libRIOHandle = dlopen(libRIO, RTLD_NOW|RTLD_GLOBAL);; 2072 delete [] libRIO;; 2073 if (!libRIOHandle) {; 2074 TString err = dlerror();; 2075 fprintf(stderr, ""Fata",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:78829,Load,Load,78829,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['Load'],['Load']
Performance,"lse {; 5087 vprvt += info.private_pages_resident * getpagesize();; 5088 }; 5089 break;; 5090 }; 5091 case SM_PRIVATE: {; 5092 vprvt += size;; 5093 break;; 5094 }; 5095 default:; 5096 break;; 5097 }; 5098 }; 5099 ; 5100 procinfo->fMemResident = (Long_t)(rsize / 1024);; 5101 procinfo->fMemVirtual = (Long_t)(vprvt / 1024);; 5102 }; 5103}; 5104#endif; 5105 ; 5106#if defined(R__LINUX); 5107////////////////////////////////////////////////////////////////////////////////; 5108/// Get system info for Linux. Only fBusSpeed is not set.; 5109 ; 5110static void GetLinuxSysInfo(SysInfo_t *sysinfo); 5111{; 5112 TString s;; 5113 FILE *f = fopen(""/proc/cpuinfo"", ""r"");; 5114 if (f) {; 5115 while (s.Gets(f)) {; 5116 if (s.BeginsWith(""model name"")) {; 5117 TPRegexp(""^.+: *(.*$)"").Substitute(s, ""$1"");; 5118 sysinfo->fModel = s;; 5119 }; 5120 if (s.BeginsWith(""cpu MHz"")) {; 5121 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5122 sysinfo->fCpuSpeed = s.Atoi();; 5123 }; 5124 if (s.BeginsWith(""cache size"")) {; 5125 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5126 sysinfo->fL2Cache = s.Atoi();; 5127 }; 5128 if (s.BeginsWith(""processor"")) {; 5129 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5130 sysinfo->fCpus = s.Atoi();; 5131 sysinfo->fCpus++;; 5132 }; 5133 }; 5134 fclose(f);; 5135 }; 5136 ; 5137 f = fopen(""/proc/meminfo"", ""r"");; 5138 if (f) {; 5139 while (s.Gets(f)) {; 5140 if (s.BeginsWith(""MemTotal"")) {; 5141 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5142 sysinfo->fPhysRam = (s.Atoi() / 1024);; 5143 break;; 5144 }; 5145 }; 5146 fclose(f);; 5147 }; 5148 ; 5149 f = gSystem->OpenPipe(""uname -s -p"", ""r"");; 5150 if (f) {; 5151 s.Gets(f);; 5152 Ssiz_t from = 0;; 5153 s.Tokenize(sysinfo->fOS, from);; 5154 s.Tokenize(sysinfo->fCpuType, from);; 5155 gSystem->ClosePipe(f);; 5156 }; 5157}; 5158 ; 5159////////////////////////////////////////////////////////////////////////////////; 5160/// Get CPU load on Linux.; 5161 ; 5162static void ReadLinuxCpu(long *ticks); 5163{; 5164 t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:165805,cache,cache,165805,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['cache'],['cache']
Performance,"lse};  ! use extra threads for sending data from RWebWindow to clients ;  ; bool fUseSessionKey {false};  ! is session key has to be used for data signing ;  . Friends; class RWebWindow;  . #include <ROOT/RWebWindowsManager.hxx>; Constructor & Destructor Documentation. ◆ RWebWindowsManager(). RWebWindowsManager::RWebWindowsManager ; (; ). window manager constructor Required here for correct usage of unique_ptr<THttpServer> ; Definition at line 273 of file RWebWindowsManager.cxx. ◆ ~RWebWindowsManager(). RWebWindowsManager::~RWebWindowsManager ; (; ). window manager destructor Required here for correct usage of unique_ptr<THttpServer> ; Definition at line 287 of file RWebWindowsManager.cxx. Member Function Documentation. ◆ AddServerLocation(). void RWebWindowsManager::AddServerLocation ; (; const std::string & ; server_prefix, . const std::string & ; files_path . ). static . Configure server location which can be used for loading of custom scripts or files When THttpServer instance of RWebWindowsManager will be created, THttpServer::AddLocation() method with correspondent arguments will be invoked. ; Definition at line 178 of file RWebWindowsManager.cxx. ◆ AssignMainThrd(). void RWebWindowsManager::AssignMainThrd ; (; ). static . Re-assigns main thread id Normally main thread id recognized at the moment when library is loaded It supposed to be a thread where gApplication->Run() will be called If application runs in separate thread, one have to call this method to let RWebWindowsManager correctly recognize such situation. ; Definition at line 117 of file RWebWindowsManager.cxx. ◆ ClearServerLocations(). void RWebWindowsManager::ClearServerLocations ; (; ). static . Clear all server locations Does not change configuration of already running HTTP server. ; Definition at line 239 of file RWebWindowsManager.cxx. ◆ CreateServer(). bool RWebWindowsManager::CreateServer ; (; bool ; with_http = false). private . Creates http server, if required - with real http engine (civetw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:7869,load,loading,7869,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['load'],['loading']
Performance,"lse . ). Definition at line 296 of file RooExpensiveObjectCache.cxx. ◆ instance(). RooExpensiveObjectCache & RooExpensiveObjectCache::instance ; (; ). static . Return reference to singleton instance. ; Definition at line 58 of file RooExpensiveObjectCache.cxx. ◆ IsA(). TClass * RooExpensiveObjectCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ print(). void RooExpensiveObjectCache::print ; (; ); const. Definition at line 259 of file RooExpensiveObjectCache.cxx. ◆ registerObject(). bool RooExpensiveObjectCache::registerObject ; (; const char * ; ownerName, . const char * ; objectName, . TObject & ; cacheObject, . const RooArgSet & ; params . ). Register object associated with given name and given associated parameters with given values in cache. ; The cache will take ownership_of_object and is indexed under the given name (which does not need to be the name of cacheObject and with given set of dependent parameters with validity for the current values of those parameters. It can be retrieved later by callin retrieveObject() ; Definition at line 71 of file RooExpensiveObjectCache.cxx. ◆ retrieveObject(). const TObject * RooExpensiveObjectCache::retrieveObject ; (; const char * ; name, . TClass * ; tc, . const RooArgSet & ; params . ). Retrieve object from cache that was registered under given name with given parameters, if current parameter values match those that were stored in the registry for this object. ; The return object is owned by the cache instance. ; Definition at line 93 of file RooExpensiveObjectCache.cxx. ◆ setObj(). bool RooExpensiveObjectCache::setObj ; (; Int_t ; uid, . TObject * ; obj . ). Place new payload object in cache element with given unique ID. ; Cache will take ownership of provided object! ; Definition at line 148 of file RooExpensiveObjectCache.cxx. ◆ size(). Int_t RooExpensiveObjectCache::size ; (; ); const. in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:14790,cache,cache,14790,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,2,['cache'],"['cache', 'cacheObject']"
Performance,"lso on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, consider the macro to be a selector; and try to load the selector and set it to the pointer.; The mask 'opt' is an or of ESendFileOpt:; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache; Return -1 in case of error, 0 otherwise. Int_t CleanupSandbox(); Remove old sessions dirs keep at most 'Proof.MaxOldSessions' (default 10). TList * GetListOfQueries(Option_t* opt = """"); Get the list of queries. Bool_t RegisterDataSet(const char* dsName, TFileCollection* ds, const char* opt = """"); Register the 'dataSet' on the cluster under the current; user, group and the given 'dataSetName'.; Fails if a dataset named 'dataSetName' already exists, unless 'optStr'; contains 'O', in which case the old dataset is overwritten.; If 'optStr' contains 'V' the dataset files are verified (default no; verification).; Returns kTRUE on success. Int_t SetDataSetTreeName(const char* dataset, const char* treename); Set/Change the name of the default tree. The tree name may ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:29257,load,load,29257,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,4,['load'],['load']
Performance,"lso possible with indexed friend trees (see below).; To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame with the main tree:; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");; ; RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above, or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree).; NoteA common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original one: rows will be mismatched.; Indexed friend trees provide a way to perform simple joins of multiple trees over a common column. When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the ""index"" columns have a value identical to the one in the main one. For example, in Python:; main_tree = ...; aux_tree = ...; ; # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""); ; mainTree.AddFriend(aux_tree); ; df = ROOT.RDataFrame(mainTree); RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats.; RDataFrame calls into concrete RDataSource implementations to retrieve information abou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:71319,perform,perform,71319,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['perform'],['perform']
Performance,"lso resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This func",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:25338,load,load,25338,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"lso resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the name of the given include file corresponds to a class that; is known to ROOT, e.g. ""TLorentzVector.h"" versus TLorentzVector. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:25874,load,load,25874,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,3,['load'],['load']
Performance,"lt, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s); The supported option is:. ""GLISO"" ; TH3 is drawn using iso-surfaces. TF3 (implicit function); The supported option is:. GLTF3"" ; Draw a TF3. Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric; equations and visualize the surface.; Interaction with the plots; All the interactions are implemented via standard methods; DistancetoPrimitive() and ExecuteEvent(). That's why all the; interactions with the OpenGL plots are possible only when the mouse cursor is; in the plot's area (the plot's area is the part of a the pad occupied by; gl-produced picture). If the mouse cursor is not above gl-picture, the standard; pad interaction is performed.; Selectable parts; Different parts of the plot can be selected:. xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the; dynamic slicing by this plane is supported, and it's; highlighted in red, if the dynamic slicing is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and; ISO are not outlined). On lego plots, the selected bin is; highlighted. The bin number and content are displayed in pad's; status bar. In box plots, the box or sphere is highlighted and; the bin info is displayed in pad's status bar. Rotation and zooming. Rotation:; When the plot is selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. Panning; The selected plot can be moved in a pad's area by pressing and; holding the left mouse button and the shift key.; Box cut; Surface, iso, box, TF3 and parametr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:71346,perform,performed,71346,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,3,['perform'],['performed']
Performance,"lt: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldSys.html:17718,perform,performs,17718,root/html602/TUnfoldSys.html,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html,2,['perform'],['performs']
Performance,"lta . ). protected . Computes the hessian matrix using the BFGS update algorithm. ; from gamma (g_{(t+1)}-g_{(t)}) and delta (w_{(t+1)}-w_{(t)}). It returns true if such a direction could not be found (if gamma and delta are orthogonal). ; Definition at line 2405 of file TMultiLayerPerceptron.cxx. ◆ GetCrossEntropy(). Double_t TMultiLayerPerceptron::GetCrossEntropy ; (; ); const. protected . Cross entropy error for a softmax output neuron, for a given event. ; Definition at line 1142 of file TMultiLayerPerceptron.cxx. ◆ GetCrossEntropyBinary(). Double_t TMultiLayerPerceptron::GetCrossEntropyBinary ; (; ); const. protected . Cross entropy error for sigmoid output neurons, for a given event. ; Definition at line 1111 of file TMultiLayerPerceptron.cxx. ◆ GetDelta(). Double_t TMultiLayerPerceptron::GetDelta ; (; ); const. inline . Definition at line 78 of file TMultiLayerPerceptron.h. ◆ GetEntry(). void TMultiLayerPerceptron::GetEntry ; (; Int_t ; entry); const. protected . Load an entry into the network. ; Definition at line 759 of file TMultiLayerPerceptron.cxx. ◆ GetEpsilon(). Double_t TMultiLayerPerceptron::GetEpsilon ; (; ); const. inline . Definition at line 77 of file TMultiLayerPerceptron.h. ◆ GetError() [1/2]. Double_t TMultiLayerPerceptron::GetError ; (; Int_t ; event); const. Error on the output for a given event. ; Definition at line 1046 of file TMultiLayerPerceptron.cxx. ◆ GetError() [2/2]. Double_t TMultiLayerPerceptron::GetError ; (; TMultiLayerPerceptron::EDataSet ; set); const. Error on the whole dataset. ; Definition at line 1075 of file TMultiLayerPerceptron.cxx. ◆ GetEta(). Double_t TMultiLayerPerceptron::GetEta ; (; ); const. inline . Definition at line 76 of file TMultiLayerPerceptron.h. ◆ GetEtaDecay(). Double_t TMultiLayerPerceptron::GetEtaDecay ; (; ); const. inline . Definition at line 79 of file TMultiLayerPerceptron.h. ◆ GetLearningMethod(). TMultiLayerPerceptron::ELearningMethod TMultiLayerPerceptron::GetLearningMethod ; (; ); const. inline",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:40405,Load,Load,40405,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['Load'],['Load']
Performance,"lter to the call graph. ; Parameters. [in]fFunction, lambda expression, functor class or any other callable object. It must return a bool signalling whether the event has passed the selection (true) or not (false). ; [in]columnsNames of the columns/branches in input to the filter function. ; [in]nameOptional name of this filter. See Report. . Returnsthe filter node of the computation graph.; Append a filter node at the point of the call graph corresponding to the object this method is called on. The callable f should not have side-effects (e.g. modification of an external or static variable) to ensure correct results when implicit multi-threading is active.; RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed in order and the first one returning false causes the event to be discarded. Even if multiple actions or transformations depend on the same filter, it is executed once per entry. If its result is requested more than once, the cached result is served. Example usage:; // C++ callable (function, functor class, lambda...) that takes two parameters of the types of ""x"" and ""y""; auto filtered = df.Filter(myCut, {""x"", ""y""});; ; // String: it must contain valid C++ except that column names can be used instead of variable names; auto filtered = df.Filter(""x*y > 0"");; NoteIf the body of the string expression contains an explicit return statement (even if it is in a nested scope), RDataFrame will not add another one in front of the expression. So this will not work: df.Filter(""Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); but instead this will: df.Filter(""return Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); ; Definition at line 219 of file RInterface.hxx. ◆ Filter() [2/4]. template<typename Proxied , typename DataSource = void> . template<typename F > . RInterface< RDFDetail::RFilter< F, Proxied >, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Filter ; (; F ; f, . const std::initializer_l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:69047,cache,cached,69047,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['cache'],['cached']
Performance,"ltersAsStrings.py;   Use just-in-time-compiled Filters and Defines for quick prototyping. ;  ; file  df013_InspectAnalysis.C;   Use callbacks to update a plot and a progress bar during the event loop. ;  ; file  df014_CSVDataSource.C;   Process a CSV file with RDataFrame and the CSV data source. ;  ; file  df014_CSVDataSource.py;   Process a CSV file with RDataFrame and the CSV data source. ;  ; file  df015_LazyDataSource.C;   Use the lazy RDataFrame data source to concatenate computation graphs. ;  ; file  df016_vecOps.C;   Process collections in RDataFrame with the help of RVec. ;  ; file  df016_vecOps.py;   Process collections in RDataFrame with the help of RVec. ;  ; file  df017_vecOpsHEP.C;   Use RVecs to plot the transverse momentum of selected particles. ;  ; file  df017_vecOpsHEP.py;   Use RVecs to plot the transverse momentum of selected particles. ;  ; file  df018_customActions.C;   Implement a custom action to fill THns. ;  ; file  df019_Cache.C;   Cache a processed RDataFrame in memory for further usage. ;  ; file  df019_Cache.py;   Cache a processed RDataFrame in memory for further usage. ;  ; file  df020_helpers.C;   Show usage of RDataFrame's helper tools, contained in ROOT/RDFHelpers.hxx. ;  ; file  df021_createTGraph.C;   Fill a TGraph using RDataFrame. ;  ; file  df021_createTGraph.py;   Fill a TGraph using RDataFrame. ;  ; file  df022_useKahan.C;   Implement a custom action that evaluates a Kahan sum. ;  ; file  df023_aggregate.C;   Use the Aggregate action to specify arbitrary data aggregations. ;  ; file  df024_Display.C;   Use the Display action to inspect entry values. ;  ; file  df024_Display.py;   Use the Display action to inspect entry values. ;  ; file  df025_RNode.C;   Manipulate RDF objects in functions, loops and conditional branches. ;  ; file  df026_AsNumpyArrays.py;   Read data from RDataFrame into Numpy arrays. ;  ; file  df027_SQliteDependencyOverVersion.C;   Plot the ROOT downloads based on the version reading a remote sqlite3 fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__dataframe.html:4267,Cache,Cache,4267,doc/master/group__tutorial__dataframe.html,https://root.cern,https://root.cern/doc/master/group__tutorial__dataframe.html,1,['Cache'],['Cache']
Performance,"ltin types can freely cross; the boundary between the two interpreters, python objects can be instantiated; and their methods can be called. All other cross-coding is based on strings; that are run on the python interpreter. Examples:. $ cat MyPyClass.py; print 'creating class MyPyClass ... '. class MyPyClass:; def __init__( self ):; print 'in MyPyClass.__init__'. def gime( self, what ):; return what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] char* s = m.gime( ""aap"" );; root [9] s; (char* 0x41ee7754)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the CINT side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived types, as well; as ObjectProxy_CheckExact for ObjectProxy's only); and it allows conversions; of void* to an ObjectProxy and vice versa. Function Members (Methods); public:. TPython(); TPython(const TPython&); virtual~TPython(); static Bool_tBind(TObject* object, const char* label); static TClass*Class(); static const TPyReturnEval(const char* expr); static Bool_tExec(const char* cmd); static voidExecScript(const char* name,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPython.html:1425,Load,LoadMacro,1425,root/html528/TPython.html,https://root.cern,https://root.cern/root/html528/TPython.html,1,['Load'],['LoadMacro']
Performance,"lts; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = 2); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0, TList* workers = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackage(const char* package); Unload specified package.; Returns 0 in case of success an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:72483,load,load,72483,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['load'],['load']
Performance,"lude <ROOT/RConfig.hxx> // for R__unlikely; 20#include <ROOT/RError.hxx>; 21#include <ROOT/RNTupleDescriptor.hxx>; 22#include <ROOT/RNTupleMetrics.hxx>; 23#include <ROOT/RNTupleModel.hxx>; 24#include <ROOT/RNTupleReadOptions.hxx>; 25#include <ROOT/RNTupleUtil.hxx>; 26#include <ROOT/RNTupleView.hxx>; 27#include <ROOT/RPageStorage.hxx>; 28#include <ROOT/RSpan.hxx>; 29 ; 30#include <iostream>; 31#include <iterator>; 32#include <memory>; 33#include <string>; 34#include <string_view>; 35 ; 36namespace ROOT {; 37class RNTuple;; 38 ; 39namespace Experimental {; 40class REntry;; 41 ; 42/// Listing of the different options that can be printed by RNTupleReader::GetInfo(); 43enum class ENTupleInfo {; 44 kSummary, // The ntuple name, description, number of entries; 45 kStorageDetails, // size on storage, page sizes, compression factor, etc.; 46 kMetrics, // internals performance counters, requires that EnableMetrics() was called; 47};; 48 ; 49// clang-format off; 50/**; 51\class ROOT::Experimental::RNTupleReader; 52\ingroup NTuple; 53\brief An RNTuple that is used to read data from storage; 54 ; 55An input ntuple provides data from storage as C++ objects. The ntuple model can be created from the data on storage; 56or it can be imposed by the user. The latter case allows users to read into a specialized ntuple model that covers; 57only a subset of the fields in the ntuple. The ntuple model is used when reading complete entries.; 58Individual fields can be read as well by instantiating a tree view.; 59 ; 60~~~ {.cpp}; 61#include <ROOT/RNTupleReader.hxx>; 62using ROOT::Experimental::RNTupleReader;; 63 ; 64#include <iostream>; 65 ; 66auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; 67std::cout << ""myNTuple has "" << ntuple->GetNEntries() << "" entries\n"";; 68~~~; 69*/; 70// clang-format on; 71class RNTupleReader {; 72private:; 73 /// Set as the page source's scheduler for parallel page decompression if IMT is on; 74 /// Needs to be destructed after the pages source is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleReader_8hxx_source.html:1799,perform,performance,1799,doc/master/RNTupleReader_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html,1,['perform'],['performance']
Performance,"lue &var2); Construct a two-dimensional RooPlot with ranges and properties taken; from variables var1 and var2. RooPlot(const RooAbsRealLValue &var1, const RooAbsRealLValue &var2,		 Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); Construct a two-dimensional RooPlot with ranges and properties taken; from variables var1 and var2 but with an overriding range definition; of [xmin,xmax] x [ymin,ymax]. RooPlot(const char* name, const char* title, const RooAbsRealLValue &var, Double_t xmin, Double_t xmax, Int_t nbins); Create an 1-dimensional with all properties taken from 'var', but; with an explicit range [xmin,xmax] and a default binning of 'nbins'. RooPlot(const RooAbsRealLValue &var, Double_t xmin, Double_t xmax, Int_t nbins); Create an 1-dimensional with all properties taken from 'var', but; with an explicit range [xmin,xmax] and a default binning of 'nbins'. RooPlot* emptyClone(const char* name); Return empty clone of current RooPlot. void initialize(); Perform initialization that is common to all constructors. TString histName() const; Construct automatic name of internal TH1. ~RooPlot(); Destructor. void updateNormVars(const RooArgSet& vars); Install the given set of observables are reference normalization; variables for this frame. These observables are e.g. later used; to automatically project out observables when plotting functions; on this frame. This function is only effective when called the; first time on a frame. Stat_t GetBinContent(Int_t ) const; A plot object is a frame without any bin contents of its own so this; method always returns zero. Stat_t GetBinContent(Int_t , Int_t ) const; A plot object is a frame without any bin contents of its own so this; method always returns zero. Stat_t GetBinContent(Int_t , Int_t , Int_t ) const; A plot object is a frame without any bin contents of its own so this; method always returns zero. void addObject(TObject* obj, Option_t* drawOptions = """", Bool_t invisible = kFALSE); Add a generic object to this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooPlot.html:14129,Perform,Perform,14129,root/html526/RooPlot.html,https://root.cern,https://root.cern/root/html526/RooPlot.html,1,['Perform'],['Perform']
Performance,"lue (Reduce). ; Parameters. funcFunction to be executed on the elements of the vector passed as second parameter. ; argsVector of elements passed as an argument to func. ; redfuncReduction function to combine the results of the calls to func. Must return the same type as func. . ReturnsA value result of ""reducing"" the vector returned by the Map operation into a single object. ; Definition at line 526 of file TThreadExecutor.hxx. ◆ MapReduce() [6/8]. template<class F , class T , class R , class Cond > . auto ROOT::TThreadExecutor::MapReduce ; (; F ; func, . std::vector< T > & ; args, . R ; redfunc, . unsigned ; nChunks . ); -> InvokeResult_t<F, T>. Execute a function in parallel over the elements of a vector (Map) and accumulate the results into a single value (Reduce). ; Benefits from partial reduction into nChunks intermediate results.; Benefits from partial reduction into nChunks intermediate results if the execution policy is multithreaded. Otherwise, it ignores the nChunks argument and performs a normal MapReduce operation.; Parameters. funcFunction to be executed. Must take an element of the sequence passed assecond argument as a parameter. ; argsVector of elements passed as an argument to func. ; redfuncReduction function to combine the results of the calls to func into partial results, and these into a final result. Must return the same type as func and should be callable with const std::vector<T> where T is the output of func. ; nChunksNumber of chunks to split the input data for processing. . ReturnsA value result of ""reducing"" the vector returned by the Map operation into a single object. ; Definition at line 546 of file TThreadExecutor.hxx. ◆ MapReduce() [7/8]. template<class F , class R , class Cond > . auto ROOT::TThreadExecutor::MapReduce ; (; F ; func, . unsigned ; nTimes, . R ; redfunc . ); -> InvokeResult_t<F>. Execute a function nTimes in parallel (Map) and accumulate the results into a single value (Reduce). ; Parameters. funcFunction to be execut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html:29621,perform,performs,29621,doc/v632/classROOT_1_1TThreadExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html,2,['perform'],['performs']
Performance,"lue (not '5'); >>> ROOT.gDebug = 3 # changes ROOT module reference; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 3 # ROOT global properly changed; >>>; The above is another good reason to prefer ‘import ROOT’ over ‘from ROOT import *’.; 19.1.5.4 Access to Python; The access to Python from Cling goes through the TPython class, or directly if a Python object or class has crossed the border. The TPython class, which looks approximately like this:; class TPython {. public:; // load a Python script as if it were a macro; static void LoadMacro(const char* name);. // execute a Python statement (e.g. ""import ROOT""); static void Exec(const char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; LoadMacro(const char* name) - the argument is a name of a Python file that is to be executed ('execfile'), after which any new classes are automatically made available to Cling. Since it is non-selective, use with care.; ExecScript(const char* name,int argc=0,const char** argv=0) - the argument is a name of a python file that is to be executed (‘execfile’) in a private namespace to minimize side-effects. Optionally, you can add CLI-style arguments which are handed to the script through ‘sys.argv’ in the normal way.; Exec(const char* cmd)- the argument is a string of Python code that is executed as a statement. There is no return value, but an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1056400,Load,LoadMacro,1056400,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Load'],['LoadMacro']
Performance,"lue c0.; the new volume created will be medium number numed. void Gsdvt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS in steps of STEP. If not exactly divisible; will make as many as possible and will centre them; with respect to the mother. Divisions will have medium; number NUMED. If NUMED is 0, NUMED of MOTHER is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS starting at coordinate value C0 with step; size STEP.; The new volume created will have medium number NUMED.; If NUMED is 0, NUMED of mother is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsord(const char* name, Int_t iax). Flags volume CHNAME whose contents will have to be ordered; along axis IAX, by setting the search flag to -IAX; IAX = 1 X axis; IAX = 2 Y axis; IAX = 3 Z axis; IAX = 4 Rxy (static ordering only -> GTMEDI); IAX = 14 Rxy (also dynamic ordering -> GTNEXT); IAX = 5 Rxyz (static ordering only -> GTMEDI); IAX = 15 Rxyz (also dynamic ordering -> GTNEXT); IAX = 6 PHI (PHI=0 => X axis); IAX = 7 THETA (THETA=0 => Z axis). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly). Position a volume into an existing one. NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ONLY ONLY/MANY flag. It positions a previously defined vol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoMCGeometry.html:16009,perform,performed,16009,root/html528/TGeoMCGeometry.html,https://root.cern,https://root.cern/root/html528/TGeoMCGeometry.html,6,['perform'],['performed']
Performance,"lue caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; RooRealProxy_mu; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPGenDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBCPGenDecay.html:41039,cache,cache,41039,root/html530/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html530/RooBCPGenDecay.html,1,['cache'],['cache']
Performance,"lue caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; Bool_t_nlo; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGExpModel.html:42646,cache,cache,42646,root/html532/RooGExpModel.html,https://root.cern,https://root.cern/root/html532/RooGExpModel.html,1,['cache'],['cache']
Performance,"lue final : public ROOT::Internal::TTreeReaderValueBase {; 159 public:; 160 TTreeReaderOpaqueValue(TTreeReader &tr, const char *branchname); 161 : TTreeReaderValueBase(&tr, branchname, /*dict*/ nullptr, /*opaqueRead*/ true); 162 {; 163 }; 164 ; 165 protected:; 166 const char *GetDerivedTypeName() const { return """"; }; 167 };; 168 ; 169} // namespace Internal; 170} // namespace ROOT; 171 ; 172 ; 173template <typename T>; 174class R__CLING_PTRCHECK(off) TTreeReaderValue final: public ROOT::Internal::TTreeReaderValueBase {; 175// R__CLING_PTRCHECK is disabled because pointer / types are checked by CreateProxy().; 176 ; 177public:; 178 using NonConstT_t = typename std::remove_const<T>::type;; 179 TTreeReaderValue() = delete;; 180 TTreeReaderValue(TTreeReader& tr, const char* branchname):; 181 TTreeReaderValueBase(&tr, branchname,; 182 TDictionary::GetDictionary(typeid(NonConstT_t))) {}; 183 ; 184 /// Return a pointer to the value of the current entry.; 185 /// Return a nullptr and print an error if no entry has been loaded yet.; 186 /// The returned address is guaranteed to stay constant while a given TTree is being read from a given file,; 187 /// unless the branch addresses are manipulated directly (e.g. through TTree::SetBranchAddress()).; 188 /// The address might also change when the underlying TTree/TFile is switched, e.g. when a TChain switches files.; 189 T *Get(); 190 {; 191 if (!fProxy) {; 192 ErrorAboutMissingProxyIfNeeded();; 193 return nullptr;; 194 }; 195 void *address = GetAddress(); // Needed to figure out if it's a pointer; 196 return fProxy->IsaPointer() ? *(T **)address : (T *)address;; 197 }; 198 ; 199 /// Return a pointer to the value of the current entry.; 200 /// Equivalent to Get().; 201 T* operator->() { return Get(); }; 202 ; 203 /// Return a reference to the value of the current entry.; 204 /// Equivalent to dereferencing the pointer returned by Get(). Behavior is undefined if no entry has been loaded yet.; 205 /// Most likely a crash will occ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReaderValue_8h_source.html:8219,load,loaded,8219,doc/master/TTreeReaderValue_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html,1,['load'],['loaded']
Performance,"lue for JSON objects ;  Cinteger_sequence;  Cless< ROOT::Internal::RConcurrentHashColl::HashValue >;  ►NTClassEdit;  CFunctionSplitInfoResult of splitting a function declaration into fReturnType fScopeName::fFunctionName<fFunctionTemplateArguments>(fFunctionParameters) ;  CTInterpreterLookupHelper;  CTSplitType;  ►Ntest;  Ctest;  ►NTMathTMath ;  CLimits;  ►NTMVAAbstract ClassifierFactory template that handles arbitrary types ;  ►NDNN;  ►NCNN;  CTConvLayer;  CTConvParams;  CTMaxPoolLayerGeneric Max Pooling Layer class ;  ►NRNN;  CTBasicRNNLayer;  CBatchEncapsulates one mini-batch ;  CClassificationSettingsSettings for classificationused to distinguish between different function signatures ;  CLayerLayer defines the layout of a layer ;  CLayerDataLayerData holds the data of one layer ;  CMeanVariance;  CNetNeural net ;  CSettingsSettings for the training of the neural net ;  CSteepestSteepest Gradient Descent algorithm (SGD) ;  CTAdadeltaAdadelta Optimizer class ;  CTAdagradAdagrad Optimizer class ;  CTAdamAdam Optimizer class ;  CTBatchTBatch ;  CTBatchIteratorTBatchIterator ;  CTCpuThe TCpu architecture class ;  ►CTCpuBufferTCpuBuffer ;  CTDestructor;  CTCpuMatrixThe TCpuMatrix class ;  CTCudaThe TCuda architecture class ;  ►CTCudaDeviceBufferTCudaDeviceBuffer ;  CTDestructor;  CTCudaDeviceReferenceTCudaDeviceReference ;  ►CTCudaHostBufferTCudaHostBuffer ;  CTDestructor;  CTCudaMatrixTCudaMatrix Class ;  CTDataLoaderTDataLoader ;  CTDataLoader< AData, TReference< AReal > >;  CTDeepNetGeneric Deep Neural Network class ;  CTDenseLayerGeneric layer class ;  CTDeviceTDevice ;  CTDLGradientDescent;  CTGradientDescent;  CTLayerGeneric layer class ;  CTNetGeneric neural network class ;  CTReferenceThe reference architecture class ;  CTReshapeLayer;  CTRMSPropRMSProp Optimizer class ;  CTSGDStochastic Batch Gradient Descent Optimizer class ;  CTSharedLayerLayer class width shared weight and bias layers ;  CTTensorBatchTTensorBatch ;  CTTensorBatchIteratorTTensorBatchIterato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:81256,Optimiz,Optimizer,81256,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['Optimiz'],['Optimizer']
Performance,"lue needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static Bool_t_doLogEvalError; static map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >_evalErrorList. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsReal(); Destructor. Bool_t operator==(Double_t value); Equality operator comparing to a Double_t. Bool_t operator==(const RooAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getVal(const RooArgSet* nset); Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of depe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:31629,cache,cache,31629,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,3,['cache'],"['cache', 'cached']"
Performance,"lue of the proposed step is negative. In this case, one can subsequently call TGeoManager::ComputeNormalFast() to get the normal vector to the crossed surface, after propagating the current point with the TGeoManager::GetStep() value. This propagation can be done like:; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; I#define I(x, y, z); Note: The method TGeoManager::FindNextBoundary() does not modify the current point/direction nor the current volume/state. The returned node is the next crossed one, but the physical path (state) AFTER crossing the boundary is not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in ""Making a Step"", but users may implement more precise methods to insure post-step boundary crossing. Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism. Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:136060,perform,performs,136060,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['performs']
Performance,"lue, RooAbsCategory& blindState); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindOffset.html:24827,cache,cache,24827,root/html602/RooUnblindOffset.html,https://root.cern,https://root.cern/root/html602/RooUnblindOffset.html,2,['cache'],['cache']
Performance,"lue. ; This happens, for example, when the histogram is drawn and the y or z axis limits are changed; To get the minimum value of bins in the histogram regardless of whether the value has been overridden (using TH1::SetMinimum), use; h->GetBinContent(h->GetMinimumBin()); TH1::GetMinimumBin can be used to get the location of the minimum value. ; Reimplemented in TH2Poly.; Definition at line 8635 of file TH1.cxx. ◆ GetMinimumAndMaximum(). void TH1::GetMinimumAndMaximum ; (; Double_t & ; min, . Double_t & ; max . ); const. virtual . Retrieve the minimum and maximum values in the histogram. ; This will not return a cached value and will always search the histogram for the min and max values. The user can condition whether or not to call this with the GetMinimumStored() and GetMaximumStored() methods. If the cache is empty, then the value will be -1111. Users can then use the SetMinimum() or SetMaximum() methods to cache the results. For example, the following recipe will make efficient use of this method and the cached minimum and maximum values. Double_t currentMin = pHist->GetMinimumStored();; Double_t currentMax = pHist->GetMaximumStored();; if ((currentMin == -1111) || (currentMax == -1111)) {; pHist->GetMinimumAndMaximum(currentMin, currentMax);; pHist->SetMinimum(currentMin);; pHist->SetMaximum(currentMax);; }; Parameters. minreference to variable that will hold found minimum value ; maxreference to variable that will hold found maximum value . Definition at line 8731 of file TH1.cxx. ◆ GetMinimumBin() [1/2]. Int_t TH1::GetMinimumBin ; (; ); const. virtual . Return location of bin with minimum value in the range. ; Definition at line 8665 of file TH1.cxx. ◆ GetMinimumBin() [2/2]. Int_t TH1::GetMinimumBin ; (; Int_t & ; locmix, . Int_t & ; locmiy, . Int_t & ; locmiz . ); const. virtual . Return location of bin with minimum value in the range. ; Definition at line 8674 of file TH1.cxx. ◆ GetMinimumStored(). virtual Double_t TH1::GetMinimumStored ; (; ); const. inlin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:164754,cache,cached,164754,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['cache'],['cached']
Performance,"lue; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_asymLeft; Bool_t_asymRight; Double_t_binWidth; Double_t*_dataPts[_nEvents]; Double_t*_dataWgts[_nEvents]; Double_t_hi; Double_t_lo; Double_t_lookupTable[1001]; Bool_t_mirrorLeft; Bool_t_mirrorRight; Int_t_nEvents; static RooKeysPdf::(anonymous)_nPoints; static const Double_t_nSigma!; Double_t_rho; Double_t_sumWgt; Char_t_varName[128]; Double_t*_weights[_nEvents]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooKeysPdf(); coverity[UNINIT_CTOR]. RooKeysPdf(const char* name, const char* title, RooAbsReal& x, RooDataSet& data, RooKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1); cache stuff about x. RooKeysPdf(const char* name, const char* title, RooAbsReal& x, RooRealVar& xdata, RooDataSet& data, RooKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1); cache stuff about x. RooKeysPdf(const RooKeysPdf& other, const char* name = 0). ~RooKeysPdf(). void LoadDataSet(RooDataSet& data). Double_t evaluate() const. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const. Int_t getMaxVal(const RooArgSet& vars) const. Double_t maxVal(Int_t code) const. Double_t g(Double_t x, Double_t sigma) const. TObject* clone(const char* newname) const; {return new RooKeysPdf(*this,newname); }. » Last changed: Tue Jun 30 14:33:40 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooKeysPdf.html:46739,cache,cache,46739,root/html602/RooKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooKeysPdf.html,2,"['Load', 'cache']","['LoadDataSet', 'cache']"
Performance,"lueOnly = kFALSE, Bool_t setValueDirty = kTRUE); TStringcurrentLabel() const; const RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateIndexList().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiCategory.html:18741,optimiz,optimizeDirtyHook,18741,root/html534/RooMultiCategory.html,https://root.cern,https://root.cern/root/html534/RooMultiCategory.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"lueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooStringVar(); RooStringVar(const RooStringVar& other, const char* name = 0); RooStringVar(const char* name, const char* title, const char* value, Int_t size = 1024); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidsetVal(const char* newVal); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStringVar.html:13874,cache,cache,13874,root/html602/RooStringVar.html,https://root.cern,https://root.cern/root/html602/RooStringVar.html,2,['cache'],['cache']
Performance,"lues from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; RooRealProxy_realVarRealVar with the original error; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooErrorVar.html:36897,cache,cache,36897,root/html530/RooErrorVar.html,https://root.cern,https://root.cern/root/html530/RooErrorVar.html,2,['cache'],['cache']
Performance,"lues from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_t_treeVar!do not persist; UInt_t_uintValue! Transient cache for unsigned integer values from tree branches; TString_unitUnit for objects value; Double_t_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,pair<string,list<RooAbsReal::EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setHideOffset(Bool_t flag); { _hide",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsReal.html:34773,cache,cache,34773,root/html602/RooAbsReal.html,https://root.cern,https://root.cern/root/html602/RooAbsReal.html,4,['cache'],['cache']
Performance,"lues;; 1120 if (XGetGCValues((Display*)fDisplay, *gGCtext, GCForeground|GCBackground, &values)) {; 1121 XSetForeground((Display*)fDisplay, *gGCinvt, values.background);; 1122 XSetBackground((Display*)fDisplay, *gGCinvt, values.foreground);; 1123 } else {; 1124 Error(""OpenDisplay"", ""cannot get GC values"");; 1125 }; 1126 ; 1127 // Turn-off GraphicsExpose and NoExpose event reporting for the pixmap; 1128 // manipulation GC, this to prevent these events from being stacked up; 1129 // without ever being processed and thereby wasting a lot of memory.; 1130 XSetGraphicsExposures((Display*)fDisplay, *gGCpxmp, False);; 1131 ; 1132 // Create input echo graphic context; 1133 XGCValues echov;; 1134 echov.foreground = fBlackPixel;; 1135 echov.background = fWhitePixel;; 1136 if (strstr(vendor,""Hewlett"")); 1137 echov.function = GXxor;; 1138 else; 1139 echov.function = GXinvert;; 1140 ; 1141 gGCecho = XCreateGC((Display*)fDisplay, fVisRootWin,; 1142 GCForeground | GCBackground | GCFunction,; 1143 &echov);; 1144 ; 1145 // Load a default Font; 1146 static int isdisp = 0;; 1147 if (!isdisp) {; 1148 for (i = 0; i < kMAXFONT; i++) {; 1149 gFont[i].id = nullptr;; 1150 strcpy(gFont[i].name, "" "");; 1151 }; 1152 fontlist = XListFonts((Display*)fDisplay, ""*courier*"", 1, &fontcount);; 1153 if (fontlist && fontcount != 0) {; 1154 gFont[gCurrentFontNumber].id = XLoadQueryFont((Display*)fDisplay, fontlist[0]);; 1155 gTextFont = gFont[gCurrentFontNumber].id;; 1156 strcpy(gFont[gCurrentFontNumber].name, ""*courier*"");; 1157 gCurrentFontNumber++;; 1158 XFreeFontNames(fontlist);; 1159 } else {; 1160 // emergency: try fixed font; 1161 fontlist = XListFonts((Display*)fDisplay, ""fixed"", 1, &fontcount);; 1162 if (fontlist && fontcount != 0) {; 1163 gFont[gCurrentFontNumber].id = XLoadQueryFont((Display*)fDisplay, fontlist[0]);; 1164 gTextFont = gFont[gCurrentFontNumber].id;; 1165 strcpy(gFont[gCurrentFontNumber].name, ""fixed"");; 1166 gCurrentFontNumber++;; 1167 XFreeFontNames(fontlist);; 1168 } else {; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:37219,Load,Load,37219,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['Load'],['Load']
Performance,luesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedPdf.html:38928,cache,cache,38928,root/html526/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedPdf.html,3,['cache'],['cache']
Performance,luesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_p,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsSelfCachedPdf.html:39375,cache,cache,39375,root/html528/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsSelfCachedPdf.html,9,['cache'],['cache']
Performance,luesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:38656,cache,cache,38656,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,luesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:39086,cache,cache,39086,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,2,['cache'],['cache']
Performance,luesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAb,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooExtendedTerm.html:36925,cache,cache,36925,root/html526/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html526/RooExtendedTerm.html,1,['cache'],['cache']
Performance,luesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Boo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExtendedTerm.html:37307,cache,cache,37307,root/html528/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html528/RooExtendedTerm.html,3,['cache'],['cache']
Performance,luesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; Bool_t_noRounding; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooPoisson.html:37362,cache,cache,37362,root/html528/RooPoisson.html,https://root.cern,https://root.cern/root/html528/RooPoisson.html,3,['cache'],['cache']
Performance,luesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Roo2DKeysPdf.html:37909,cache,cache,37909,root/html526/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html526/Roo2DKeysPdf.html,37,['cache'],['cache']
Performance,luesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Pr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Roo2DKeysPdf.html:38291,cache,cache,38291,root/html528/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html528/Roo2DKeysPdf.html,117,['cache'],['cache']
Performance,luesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooRealProxy_nominalThe nominal value; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; TIterator*_obsIter! Iterator over lowSet; RooListProxy_obsSetLow-side variation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; TIterator*_paramIter! Itera,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooJeffreysPrior.html:37483,cache,cache,37483,root/html528/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html528/RooJeffreysPrior.html,3,['cache'],['cache']
Performance,"luginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); (unknown)(); Bool_tCanHandle(const char* base, const char* uri); const char*GetBase() const; const char*GetCtor() const; const char*GetOrigin() const; const char*GetPlugin() const; const char*GetRegexp() const; TPluginHandler&operator=(const TPluginHandler&); voidSetupCallEnv(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfBasebase class which will be extended by plugin; TMethodCall*fCallEnv!ctor method call environment; Int_tfCanCall!if 1 fCallEnv is ok, -1 fCallEnv is not ok; TStringfClassclass to be loaded from plugin library; TStringfCtorctor used to instantiate object of fClass; Bool_tfIsGlobalplugin ctor is a global function; Bool_tfIsMacroplugin is a macro and not a library; TFunction*fMethod!ctor method or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. Int_t LoadPlugin(); Load the plugin library for this",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPluginHandler.html:8823,load,loaded,8823,root/html528/TPluginHandler.html,https://root.cern,https://root.cern/root/html528/TPluginHandler.html,4,['load'],['loaded']
Performance,"lumn names like fValue:Int_t or fObject:pointer ;  ; Int_t fUseTransactions;  ! use transaction statements for writing data into the tables ;  ;  Protected Attributes inherited from TFile; TArchiveFile * fArchive {nullptr};  !Archive file from which we read this file ;  ; Long64_t fArchiveOffset {0};  !Offset at which file starts in archive ;  ; TFileOpenHandle * fAsyncHandle {nullptr};  !For proper automatic cleanup ;  ; EAsyncOpenStatus fAsyncOpenStatus {kAOSNotAsync};  !Status of an asynchronous open request ;  ; Long64_t fBEGIN {0};  First used byte in file. ;  ; Long64_t fBytesRead {0};  Number of bytes read from this file. ;  ; Long64_t fBytesReadExtra {0};  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Long64_t fBytesWrite {0};  Number of bytes written to this file. ;  ; TFileCacheRead * fCacheRead {nullptr};  !Pointer to the read cache (if any) ;  ; TMap * fCacheReadMap {nullptr};  !Pointer to the read cache (if any) ;  ; TFileCacheWrite * fCacheWrite {nullptr};  !Pointer to the write cache (if any) ;  ; TArrayC * fClassIndex {nullptr};  !Index of TStreamerInfo classes written to this file ;  ; Int_t fCompress {0};  Compression level and algorithm. ;  ; Int_t fD {-1};  File descriptor. ;  ; Long64_t fEND {0};  Last used byte in file. ;  ; TList * fFree {nullptr};  Free segments linked list table. ;  ; bool fGlobalRegistration = true;  ! if true, bypass use of global lists ;  ; TList * fInfoCache {nullptr};  !Cached list of the streamer infos in this file ;  ; Bool_t fInitDone {kFALSE};  !True if the file has been initialized ;  ; Bool_t fIsArchive {kFALSE};  !True if this is a pure archive file ;  ; Bool_t fIsPcmFile {kFALSE};  !True if the file is a ROOT pcm file. ;  ; Bool_t fIsRootFile {kTRUE};  !True is this is a ROOT file, raw file otherwise ;  ; Bool_t fMustFlush {kTRUE};  !True if the file buffers must be flushed ;  ; Int_t fNbytesFree {0};  Number of bytes for free segments structure. ;  ; Int_t fNbytesInfo {0};  Number of bytes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:53761,cache,cache,53761,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,3,['cache'],['cache']
Performance,"lumnList); 1547 {; 1548 ColumnNames_t selectedColumns(columnList);; 1549 return Cache(selectedColumns);; 1550 }; 1551 ; 1552 // clang-format off; 1553 ////////////////////////////////////////////////////////////////////////////; 1554 /// \brief Creates a node that filters entries based on range: [begin, end).; 1555 /// \param[in] begin Initial entry number considered for this range.; 1556 /// \param[in] end Final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; 1557 /// \param[in] stride Process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0.; 1558 /// \return the first node of the computation graph for which the event loop is limited to a certain range of entries.; 1559 ///; 1560 /// Note that in case of previous Ranges and Filters the selected range refers to the transformed dataset.; 1561 /// Ranges are only available if EnableImplicitMT has _not_ been called. Multi-thread ranges are not supported.; 1562 ///; 1563 /// ### Example usage:; 1564 /// ~~~{.cpp}; 1565 /// auto d_0_30 = d.Range(0, 30); // Pick the first 30 entries; 1566 /// auto d_15_end = d.Range(15, 0); // Pick all entries from 15 onwards; 1567 /// auto d_15_end_3 = d.Range(15, 0, 3); // Stride: from event 15, pick an event every 3; 1568 /// ~~~; 1569 // clang-format on; 1570 RInterface<RDFDetail::RRange<Proxied>, DS_t> Range(unsigned int begin, unsigned int end, unsigned int stride = 1); 1571 {; 1572 // check invariants; 1573 if (stride == 0 || (end != 0 && end < begin)); 1574 throw std::runtime_error(""Range: stride must be strictly greater than 0 and end must be greater than begin."");; 1575 CheckIMTDisabled(""Range"");; 1576 ; 1577 using Range_t = RDFDetail::RRange<Proxied>;; 1578 auto rangePtr = std::make_shared<Range_t>(begin, end, stride, fProxiedPtr);; 1579 RInterface<RDFDetail::RRange<Proxied>, DS_t> newInterface(std::move(rangePtr), *fLoopManager, fColRegister);; 1580 return newInterface;; 15",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:87546,Multi-thread,Multi-thread,87546,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['Multi-thread'],['Multi-thread']
Performance,"lumns must all be `float` variables):; 97/// \code; 98/// bool myVecFunc(std::vector<float> args);; 99/// df.Filter(PassAsVec<3, float>(myVecFunc), {""var1"", ""var2"", ""var3""});; 100/// \endcode; 101// clang-format on; 102template <std::size_t N, typename T, typename F>; 103auto PassAsVec(F &&f) -> RDFInternal::PassAsVecHelper<std::make_index_sequence<N>, T, F>; 104{; 105 return RDFInternal::PassAsVecHelper<std::make_index_sequence<N>, T, F>(std::forward<F>(f));; 106}; 107 ; 108// clang-format off; 109/// Create a graphviz representation of the dataframe computation graph, return it as a string.; 110/// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; 111///; 112/// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; 113///; 114/// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; 115/// effectively optimized away from the computation graph.; 116///; 117/// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; 118// clang-format on; 119template <typename NodeType>; 120std::string SaveGraph(NodeType node); 121{; 122 ROOT::Internal::RDF::GraphDrawing::GraphCreatorHelper helper;; 123 return helper.RepresentGraph(node);; 124}; 125 ; 126// clang-format off; 127/// Create a graphviz representation of the dataframe computation graph, write it to the specified file.; 128/// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; 129/// \param[in] outputFile file where to save the representation.; 130///; 131/// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; 132///; 133/// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:5144,optimiz,optimized,5144,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['optimiz'],['optimized']
Performance,"lumns;; 1529 std::copy_if(dsColumns.begin(), dsColumns.end(), std::back_inserter(dsColumnsWithoutSizeColumns),; 1530 [](const std::string &name) { return name.size() < 13 || name.substr(0, 13) != ""R_rdf_sizeof_""; });; 1531 ColumnNames_t columnNames;; 1532 columnNames.reserve(definedColumns.size() + treeBranchNames.size() + dsColumns.size());; 1533 columnNames.insert(columnNames.end(), definedColumns.begin(), definedColumns.end());; 1534 columnNames.insert(columnNames.end(), treeBranchNames.begin(), treeBranchNames.end());; 1535 columnNames.insert(columnNames.end(), dsColumns.begin(), dsColumns.end());; 1536 const auto selectedColumns = RDFInternal::ConvertRegexToColumns(columnNames, columnNameRegexp, ""Cache"");; 1537 return Cache(selectedColumns);; 1538 }; 1539 ; 1540 ////////////////////////////////////////////////////////////////////////////; 1541 /// \brief Save selected columns in memory.; 1542 /// \param[in] columnList columns to be cached in memory.; 1543 /// \return a `RDataFrame` that wraps the cached dataset.; 1544 ///; 1545 /// See the previous overloads for more information.; 1546 RInterface<RLoopManager> Cache(std::initializer_list<std::string> columnList); 1547 {; 1548 ColumnNames_t selectedColumns(columnList);; 1549 return Cache(selectedColumns);; 1550 }; 1551 ; 1552 // clang-format off; 1553 ////////////////////////////////////////////////////////////////////////////; 1554 /// \brief Creates a node that filters entries based on range: [begin, end).; 1555 /// \param[in] begin Initial entry number considered for this range.; 1556 /// \param[in] end Final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; 1557 /// \param[in] stride Process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0.; 1558 /// \return the first node of the computation graph for which the event loop is limited to a certain range of entries.; 1559 ///; 1560 /// Note that in case of pre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:86405,cache,cached,86405,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['cache'],['cached']
Performance,"lvirtual TLeaf * GetLeafImpl(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree::Showvirtual void Show(Long64_t entry=-1, Int_t lenmax=20)Print values of all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t GetMedianClusterSize()Estimate the median cluster size for the TTree.Definition TTree.cxx:8297; TTree::GetClusterIteratorvirtual TClusterIterator G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:437068,cache,cache,437068,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"lways require a raw tessellation description of points/lines/segments.; Some need the 3D object positions in the global frame, others can cope with local frames + a translation matrix - which can give considerable performance benefits. To cope with these situations the object buffer is filled out in negotiation with the viewer. TBuffer3D classes are conceptually divided into enumerated sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw) are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section in derived shape specific classes allows a more abstract shape description (""a sphere of inner radius x, outer radius y""). This enables a viewer which knows how to draw (tessellate) the shape itself to do so, which can bring considerable performance and quality benefits, while providing a generic fallback suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) AddObject() will return flags indicating which ones, otherwise it returns kNone. You must fill the buffer and mark these sections valid, and pass the buffer again. A typical code snippet would be: TBuffer3DSphere sphereBuffer;; // Fill out kCore...; // Fill out kBoundingBox...; // Fill out kShapeSpecific for TBuffer3DSphere; // Try first add to viewer; Int_t reqSections = viewer->AddObject(buffer);; if (reqSections != TBuffer3D::kNone) {; if (reqSections & TBuffer3D::kRawSize",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:3788,perform,performance,3788,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,1,['perform'],['performance']
Performance,lways validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSetRooAbsOptTestStatistic::_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts re,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataWeightedAverage.html:38261,cache,cache,38261,root/html602/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html602/RooDataWeightedAverage.html,2,['cache'],['cache']
Performance,"lwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsMoment(); Destructor. Int_t order() const; { return _order ; }. Bool_t ce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsMoment.html:34651,cache,cache,34651,root/html534/RooAbsMoment.html,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html,2,['cache'],['cache']
Performance,"ly (Int_t delta, Bool_t mod1, Bool_t mod2);  Dolly the camera - 'move camera along eye line, retaining lens focal length'. ;  ; void DrawDebugAids () const;  Draw out some debugging aids for the camera: ;  ; TGLVector3 EyeDirection () const;  Extract the camera eye direction (vector), running from EyePoint() Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 EyePoint () const;  Return the camera eye point (vertex) in world space Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 FrustumCenter () const;  Find the center of the camera frustum from intersection of planes This method will work even with parallel left/right & top/bottom and infinite eye point of ortho cameras Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; Rgl::EOverlap FrustumOverlap (const TGLBoundingBox &box) const;  Calculate overlap (kInside, kOutside, kPartial) of box with camera frustum Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; const TGLPlane & FrustumPlane (EFrustumPlane plane) const;  ; const TGLMatrix & GetCamBase () const;  ; const TGLMatrix & GetCamTrans () const;  ; Double_t * GetCenterVec ();  ; Bool_t GetExternalCenter ();  ; Double_t GetFarClip () const;  ; Double_t * GetFixDefCenterVec ();  ; Double_t GetNearClip () const;  ; Double_t GetTheta () const;  Get angle between camera up axis. ;  ; Float_t GetVAxisMinAngle ();  ; void IncTimeStamp ();  ; Bool_t IsCacheDirty () const;  ; virtual Bool_t IsOrthographic () const;  ; Bool_t OfInterest (const TGLBoundingBox &box, Bool_t ignoreSize) const;  Calculate if the an object defined by world frame bounding box is 'of interest' to the camera. ;  ; TGLMatrix & RefCamBase ();  ; TGLMatrix & RefCamTrans ();  ; TGLMatrix & RefLastNoPickProjM () const;  ; const TGLMatrix & RefModelViewMatrix () const;  ; TGLRect & RefViewport ();  ; cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLPerspectiveCamera.html:3897,cache,cache,3897,doc/master/classTGLPerspectiveCamera.html,https://root.cern,https://root.cern/doc/master/classTGLPerspectiveCamera.html,1,['cache'],['cache']
Performance,"ly (Int_t delta, Bool_t mod1, Bool_t mod2);  Dolly the camera - 'move camera along eye line, retaining lens focal length'. ;  ; void DrawDebugAids () const;  Draw out some debugging aids for the camera: ;  ; TGLVector3 EyeDirection () const;  Extract the camera eye direction (vector), running from EyePoint() Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 EyePoint () const;  Return the camera eye point (vertex) in world space Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 FrustumCenter () const;  Find the center of the camera frustum from intersection of planes This method will work even with parallel left/right & top/bottom and infinite eye point of ortho cameras Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; Rgl::EOverlap FrustumOverlap (const TGLBoundingBox &box) const;  Calculate overlap (kInside, kOutside, kPartial) of box with camera frustum Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; const TGLPlane & FrustumPlane (EFrustumPlane plane) const;  ; const TGLMatrix & GetCamBase () const;  ; const TGLMatrix & GetCamTrans () const;  ; Double_t * GetCenterVec ();  ; Bool_t GetExternalCenter ();  ; Double_t GetFarClip () const;  ; Double_t * GetFixDefCenterVec ();  ; Double_t GetNearClip () const;  ; Double_t GetTheta () const;  Get angle between camera up axis. ;  ; Float_t GetVAxisMinAngle ();  ; void IncTimeStamp ();  ; TClass * IsA () const override;  ; Bool_t IsCacheDirty () const;  ; virtual Bool_t IsOrthographic () const;  ; virtual Bool_t IsPerspective () const;  ; Bool_t OfInterest (const TGLBoundingBox &box, Bool_t ignoreSize) const;  Calculate if the an object defined by world frame bounding box is 'of interest' to the camera. ;  ; TGLMatrix & RefCamBase ();  ; TGLMatrix & RefCamTrans ();  ; TGLMatrix & RefLastNoPickProjM () const;  ; const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:3823,cache,cache,3823,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['cache'],['cache']
Performance,ly ; Definition at line 37 of file TFileCacheRead.h. ◆ fFile. TFile* TFileCacheRead::fFile. protected . Pointer to file. ; Definition at line 51 of file TFileCacheRead.h. ◆ fIsSorted. Bool_t TFileCacheRead::fIsSorted. protected . True if fSeek array is sorted. ; Definition at line 53 of file TFileCacheRead.h. ◆ fIsTransferred. Bool_t TFileCacheRead::fIsTransferred. protected . True when fBuffer contains something valid. ; Definition at line 54 of file TFileCacheRead.h. ◆ fLen. Int_t* TFileCacheRead::fLen. protected . [fNb] Length of long buffers ; Definition at line 50 of file TFileCacheRead.h. ◆ fNb. Int_t TFileCacheRead::fNb. protected . Number of long buffers. ; Definition at line 41 of file TFileCacheRead.h. ◆ fNoCacheBytesRead. Long64_t TFileCacheRead::fNoCacheBytesRead. protected . Number of bytes read by basket to fill cached tree. ; Definition at line 33 of file TFileCacheRead.h. ◆ fNoCacheReadCalls. Int_t TFileCacheRead::fNoCacheReadCalls. protected . Number of read calls by basket to fill cached tree. ; Definition at line 34 of file TFileCacheRead.h. ◆ fNseek. Int_t TFileCacheRead::fNseek. protected . Number of blocks to be prefetched. ; Definition at line 39 of file TFileCacheRead.h. ◆ fNtot. Int_t TFileCacheRead::fNtot. protected . Total size of prefetched blocks. ; Definition at line 40 of file TFileCacheRead.h. ◆ fPos. Long64_t* TFileCacheRead::fPos. protected . [fNb] start of long buffers ; Definition at line 46 of file TFileCacheRead.h. ◆ fPrefetch. TFilePrefetch* TFileCacheRead::fPrefetch. protected . ! Object that does the asynchronous reading in another thread ; Definition at line 25 of file TFileCacheRead.h. ◆ fPrefetchedBlocks. Long64_t TFileCacheRead::fPrefetchedBlocks. protected . Number of blocks prefetched. ; Definition at line 55 of file TFileCacheRead.h. ◆ fReadCalls. Int_t TFileCacheRead::fReadCalls. protected . Number of read calls for this cache. ; Definition at line 32 of file TFileCacheRead.h. ◆ fSeek. Long64_t* TFileCacheRead::fSeek.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:29620,cache,cached,29620,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,1,['cache'],['cached']
Performance,"ly = kFALSE, Bool_t setValueDirty = kTRUE); const RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); voidinitialize(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBinningCategory.html:17735,optimiz,optimizeDirtyHook,17735,root/html532/RooBinningCategory.html,https://root.cern,https://root.cern/root/html532/RooBinningCategory.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"ly crash."");; 2154 element->SetOffset(0);; 2155 element->Init(this);; 2156 dmType = element->GetTypeName();; 2157 dmIsPtr = false;; 2158 }; 2159 }; 2160 } // Class corresponding to StreamerInfo is emulated or not.; 2161 ; 2162 // Now let's deal with Schema evolution; 2163 Int_t newType = -1;; 2164 TClassRef newClass;; 2165 ; 2166 if (dm && dm->IsPersistent()) {; 2167 auto theType = isStdArray ? dt : dm->GetDataType();; 2168 if (theType) {; 2169 Bool_t isArray = isStdArray || element->GetArrayLength() >= 1;; 2170 Bool_t hasCount = element->HasCounter();; 2171 // data member is a basic type; 2172 if ((fClass == TObject::Class()) && !strcmp(dm->GetName(), ""fBits"")) {; 2173 //printf(""found fBits, changing dtype from %d to 15\n"", dtype);; 2174 newType = kBits;; 2175 } else {; 2176 // All the values of EDataType have the same semantic in EReadWrite; 2177 newType = (EReadWrite)theType->GetType();; 2178 }; 2179 if ((newType == ::kChar_t) && dmIsPtr && !isArray && !hasCount) {; 2180 newType = ::kCharStar;; 2181 } else if (dmIsPtr) {; 2182 newType += kOffsetP;; 2183 } else if (isArray) {; 2184 newType += kOffsetL;; 2185 }; 2186 }; 2187 if (newType == -1) {; 2188 newClass = TClass::GetClass(dmType);; 2189 }; 2190 } else {; 2191 // Either the class is not loaded or the data member is gone; 2192 if (!fClass->IsLoaded()) {; 2193 TStreamerInfo* newInfo = (TStreamerInfo*) fClass->GetStreamerInfos()->At(fClass->GetClassVersion());; 2194 if (newInfo && (newInfo != this)) {; 2195 TStreamerElement* newElems = (TStreamerElement*) newInfo->GetElements()->FindObject(element->GetName());; 2196 newClass = newElems ? newElems->GetClassPointer() : 0;; 2197 if (newClass == 0) {; 2198 newType = newElems ? newElems->GetType() : -1;; 2199 if (!(newType < kObject)) {; 2200 // sanity check.; 2201 newType = -1;; 2202 }; 2203 }; 2204 } else {; 2205 newClass = element->GetClassPointer();; 2206 if (newClass.GetClass() == 0) {; 2207 newType = element->GetType();; 2208 if (!(newType < kObject)) {; 2209 //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:85378,load,loaded,85378,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['loaded']
Performance,"ly enables a different likelihood class in the back-end. Note that this; 927 * should be set to true for parallel minimization of likelihoods!; 928 * Note that it is currently not recommended to use Modular likelihoods without any parallelization enabled in the minimization, since; 929 * some features such as offsetting might not yet work in this case.; 930 * </table>; 931 */; 932 ; 933 ; 934/** @brief Protected implementation of the NLL creation routine.; 935 *; 936 * This virtual function can be overridden in case you want to change the NLL creation logic for custom PDFs.; 937 *; 938 * \note Never call this function directly. Instead, call RooAbsPdf::createNLL().; 939 */; 940 ; 941std::unique_ptr<RooAbsReal> RooAbsPdf::createNLLImpl(RooAbsData &data, const RooLinkedList &cmdList); 942{; 943 return RooFit::FitHelpers::createNLL(*this, data, cmdList);; 944}; 945 ; 946 ; 947/** @fn RooAbsPdf::fitTo(); 948 *; 949 * @brief Fit PDF to given dataset.; 950 *; 951 * If dataset is unbinned, an unbinned maximum likelihood is performed.; 952 * If the dataset is binned, a binned maximum likelihood is performed.; 953 * By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession.; 954 *; 955 * @param data Reference to a RooAbsData object representing the dataset.; 956 * @param cmdArgs Variadic template arguments representing optional command arguments.; 957 * You can pass either an arbitrary number of RooCmdArg instances; 958 * or a single RooLinkedList that points to the RooCmdArg objects.; 959 * @return An owning pointer to the created RooAbsReal NLL object.; 960 * @return RooFitResult with fit status and parameters if option Save() is used, `nullptr` otherwise. The user takes ownership of the fit result.; 961 *; 962 * @tparam CmdArgs_t Template types for optional command arguments.; 963 * Can either be an arbitrary number of RooCmdArg or a single RooLinkedList.; 964 *; 965 * \note This front-end function should not be re-implemented in derived PDF ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:43637,perform,performed,43637,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['perform'],['performed']
Performance,"ly if done so directly through their containing module. The following session shows that in detail:; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDebug); 0 # local gDebug is unchanged; >>> gDebug = 5 # changes _local_ reference only; >>> print(gDebug); 5 # locally correct, but ...; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 7 # ... ROOT global unchanged; >>> import ROOT; >>> print(ROOT.gDebug); 7 # still the old value (not '5'); >>> ROOT.gDebug = 3 # changes ROOT module reference; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 3 # ROOT global properly changed; >>>; The above is another good reason to prefer ‘import ROOT’ over ‘from ROOT import *’.; 19.1.5.4 Access to Python; The access to Python from Cling goes through the TPython class, or directly if a Python object or class has crossed the border. The TPython class, which looks approximately like this:; class TPython {. public:; // load a Python script as if it were a macro; static void LoadMacro(const char* name);. // execute a Python statement (e.g. ""import ROOT""); static void Exec(const char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; LoadMacro(const char* name) - the argument is a name of a Python file that is to be executed ('execfile'), after which any new classes are automatically made available to Cling. Since it is non-selective, use with care.; ExecScript(const char* name,int argc=0,const char** argv=0) - the argument is a name of a python file that is to be executed (‘execfile’) in a private namespace to minimize side-effects. Optionally, you can add CLI-style arguments which are handed to the script through ‘sys.argv’ in the normal way.; Exec(const char* cmd)- the argument is a strin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1055932,load,load,1055932,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['Load', 'load']","['LoadMacro', 'load']"
Performance,"ly load libMathCore it cannot be auto-loaded it when using one; 199 // of its freestanding functions. Once functions can trigger autoloading we; 200 // can get rid of this.; 201 if (!gClassTable->GetDict(""TRandom"")); 202 gSystem->Load(""libMathCore"");; 203 ; 204 if (!gInterpreter->HasPCMForLibrary(""std"")) {; 205 // Load some frequently used includes; 206 Int_t includes = gEnv->GetValue(""Rint.Includes"", 1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 244 gCling->SaveContext();; 245 gCling->SaveGlobalsContext();; 246 ; 247 // Install interrupt and terminal input handlers; 248 TInterruptHandler *ih = new TIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:7144,load,load,7144,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['load'],['load']
Performance,"ly the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dynamic path. const char* GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* pathname); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Find a dynamic library called lib using the system search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSystem.html:34144,load,loading,34144,root/html602/TSystem.html,https://root.cern,https://root.cern/root/html602/TSystem.html,4,['load'],"['loaded', 'loading']"
Performance,"ly the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dynamic path. const char* GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* pathname); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSystem.html:33459,load,loading,33459,root/html534/TSystem.html,https://root.cern,https://root.cern/root/html534/TSystem.html,2,['load'],"['loaded', 'loading']"
Performance,"ly the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dynamic path. const char* GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* pathname); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:33172,load,loading,33172,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['load'],"['loaded', 'loading']"
Performance,"ly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publish",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:6544,cache,cached,6544,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,13,['cache'],['cached']
Performance,"ly the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0, TList* workers = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackage(const char* package); Unload specified package.; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackageOnClient(const char* package); Unload a specific package on the client.; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::UnloadPackage; case). Keep in sync in case of changes. Int_t UnloadPackages(); Unload all packages.; Returns 0 in case of success and -1 in case of e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:72815,Load,LoadPackageOnClient,72815,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,9,"['Load', 'load']","['Load', 'LoadPackageOnClient', 'loadopts']"
Performance,"ly, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: assembly.C.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; namechar name[80]Definition TGX11.cxx:110; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; Note that components cannot be declared as ""overlapping"" and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in **TGeo** has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:52919,optimiz,optimizing,52919,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,2,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,"ly, we would like to print a progress bar on the terminal to show how the event-loop is progressing.; // To take into account _all_ events we use `OnPartialResultSlot`: when Implicit Multi-Threading is enabled, in fact,; // `OnPartialResult` invokes the callback only in one of the worker threads, and always returns that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callback in each one of the worker threads, every time a; // thread finishes processing a batch of `everyN` events. This is what we want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_back('#');; // re-print the line with the progress bar; std::cout << ""\r["" << std::left << std::setw(barWidth) << progressBar << ']' << std::flush;; });; ; // ## Running the analysis; // So far we told RDataFrame what we want to happen during the event-loop, but we have not actually run any of those; // actions: the TBrowser is still empty, the progress bar has not been printed even once, and we haven't produced; // a single data-point!; // As usual with RDataFrame, the event-loop is triggered by accessing the contents of a TResultProxy for the first;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df013__InspectAnalysis_8C.html:5121,concurren,concurrent,5121,doc/master/df013__InspectAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html,1,['concurren'],['concurrent']
Performance,"ly. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CLHEP. { return fCoordinates.X(); }. Scalar y() const; { return fCoordinates.Y(); }. Scalar z() const; { return fCoordinates.Z(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar eta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:21056,perform,perform,21056,root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,1,['perform'],['perform']
Performance,"ly; 263 */; 264 DisplacementVector2D<CoordSystem, Tag>& SetR (Scalar a) {; 265 fCoordinates.SetR(a);; 266 return *this;; 267 }; 268 ; 269 ; 270 /**; 271 Change Phi - Polar2D coordinates; 272 */; 273 DisplacementVector2D<CoordSystem, Tag>& SetPhi (Scalar ang) {; 274 fCoordinates.SetPhi(ang);; 275 return *this;; 276 }; 277 ; 278 ; 279 ; 280 // ------ Operations combining two vectors ------; 281 // -- need to have the specialized version in order to avoid; 282 ; 283 /**; 284 Return the scalar (dot) product of two displacement vectors.; 285 It is possible to perform the product for any type of vector coordinates,; 286 but they must have the same coordinate system tag; 287 */; 288 template< class OtherCoords >; 289 Scalar Dot( const DisplacementVector2D<OtherCoords,Tag> & v) const {; 290 return X()*v.X() + Y()*v.Y();; 291 }; 292 /**; 293 Return the scalar (dot) product of two vectors.; 294 It is possible to perform the product for any classes; 295 implementing x() and y() member functions; 296 */; 297 template< class OtherVector >; 298 Scalar Dot( const OtherVector & v) const {; 299 return X()*v.x() + Y()*v.y();; 300 }; 301 ; 302 ; 303 ; 304 /**; 305 Self Addition with a displacement vector.; 306 */; 307 template <class OtherCoords>; 308 DisplacementVector2D & operator+=; 309 (const DisplacementVector2D<OtherCoords,Tag> & v) {; 310 SetXY( X() + v.X(), Y() + v.Y() );; 311 return *this;; 312 }; 313 ; 314 /**; 315 Self Difference with a displacement vector.; 316 */; 317 template <class OtherCoords>; 318 DisplacementVector2D & operator-=; 319 (const DisplacementVector2D<OtherCoords,Tag> & v) {; 320 SetXY( x() - v.x(), y() - v.y() );; 321 return *this;; 322 }; 323 ; 324 ; 325 /**; 326 multiply this vector by a scalar quantity; 327 */; 328 DisplacementVector2D & operator*= (Scalar a) {; 329 fCoordinates.Scale(a);; 330 return *this;; 331 }; 332 ; 333 /**; 334 divide this vector by a scalar quantity; 335 */; 336 DisplacementVector2D & operator/= (Scalar a) {; 337 fCoordinates.Sc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html:8682,perform,perform,8682,doc/master/GenVector_2DisplacementVector2D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html,1,['perform'],['perform']
Performance,"lyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; Bool_tRooAbsMoment::central() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFirstMoment.html:2373,Cache,CacheModeRooAbsArg,2373,root/html534/RooFirstMoment.html,https://root.cern,https://root.cern/root/html534/RooFirstMoment.html,3,['Cache'],['CacheModeRooAbsArg']
Performance,"lyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; Bool_tcentral() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsMoment.html:2187,Cache,CacheModeRooAbsArg,2187,root/html534/RooAbsMoment.html,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"lyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo1DMomentMorphFunction.html:2244,Cache,CacheModeRooAbsArg,2244,root/html534/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html534/Roo1DMomentMorphFunction.html,52,['Cache'],['CacheModeRooAbsArg']
Performance,"l~RooMultiCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiCategory.html:1836,Cache,CacheModeRooAbsArg,1836,root/html534/RooMultiCategory.html,https://root.cern,https://root.cern/root/html534/RooMultiCategory.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"l~RooSuperCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSuperCategory.html:2131,Cache,CacheModeRooAbsArg,2131,root/html534/RooSuperCategory.html,https://root.cern,https://root.cern/root/html534/RooSuperCategory.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"l ; adjustRange = true . ). overridevirtual . WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all arguments, but only does for the first one here... ; Implements RooAbsDataStore.; Definition at line 320 of file RooCompositeDataStore.cxx. ◆ append(). void RooCompositeDataStore::append ; (; RooAbsDataStore & ; other). overridevirtual . Implements RooAbsDataStore.; Definition at line 346 of file RooCompositeDataStore.cxx. ◆ attachBuffers(). void RooCompositeDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 435 of file RooCompositeDataStore.cxx. ◆ attachCache(). void RooCompositeDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overrideprotectedvirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 411 of file RooCompositeDataStore.cxx. ◆ cacheArgs(). void RooCompositeDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 384 of file RooCompositeDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooCompositeDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 94 of file RooCompositeDataStore.h. ◆ changeObservableName(). bool RooCompositeDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). overridevirtual . Change name of internal observable named 'from' into 'to'. ; Implements RooAbsDataStore.; Definition at line 290 of file RooCompositeDataStore.cxx. ◆ Class(). static TClass * RooCompositeDataStore::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCompositeDataStore::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:22396,cache,cacheArgs,22396,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['cache'],['cacheArgs']
Performance,"l FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:3227,cache,cache,3227,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"m ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Long64_t GetMaxFullCacheSize ();  Static method returning maxmimal size of full cache, which can be preserved by file instance. ;  ; static const char * GetProxy ();  Static method returning the global proxy URL. ;  ; static void SetMaxFullCacheSize (Long64_t sz);  Static method, set maxmimal size of full cache,. ;  ; static void SetProxy (const char *url);  Static method setting global proxy URL. ;  ;  Static Public Member Functions inherited from TFile; static TFileOpenHandle * AsyncOpen (const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Submit an asynchronous open request. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Cp (const char *src, const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000);  Allows to copy file from src to dst URL. ;  ; static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:23981,cache,cache,23981,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['cache'],['cache']
Performance,"m & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  If this pdf is operated with a fixed set of observables, return the subset of the fixed observables that are actual dependents of the external input p.d.f. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  If this p.d.f is operated with a fixed set of observables, return all variables of the external input p.d.f that are not one of the cache observables. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillCacheObject (PdfCacheElem &cachePdf) const override;  Update contents of cache histogram by resampling the input p.d.f. ;  ; const char * inputBaseName () const override;  Return the base name for cache objects, in this case the name of the cached p.d.f. ;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedPdf; virtual const char * binningName () const;  ; std::string cacheNameSuffix (const RooArgSet &nset) const;  Construct string with unique suffix for cache objects based on observable names that define cache configuration. ;  ; virtual PdfCacheElem * createCache (const RooArgSet *nset) const;  ; void disableCache (bool flag);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; PdfCacheElem * getCache (const RooArgSet *nset, bool recalculate=true) const;  Retrieve cache object associated with given choice of observables. ;  ; virtual TString histNameSuffix () const;  ; virtual RooAbsArg & pdfObservable ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:61208,cache,cachePdf,61208,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,2,['cache'],"['cache', 'cachePdf']"
Performance,"m & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ;  Protected Member Functions inherited from RooAbsHiddenReal; RooAbsCategory & dummyBlindState () const;  Return reference to internal dummy RooCategory implementation blinding state switch. ;  ; double getValV (const RooArgSet *nset=nullptr) const override;  Return value of object. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooUnblindCPAsymVar.html:50313,cache,cached,50313,doc/master/classRooUnblindCPAsymVar.html,https://root.cern,https://root.cern/doc/master/classRooUnblindCPAsymVar.html,2,['cache'],"['cache', 'cached']"
Performance,"m * ; PseRan, . TFoamIntegrand * ; fun . ). virtual . Basic initialization of FOAM invoked by the user. Mandatory!; This method starts the process of the cell build-up. User must invoke Initialize with two arguments or Initialize without arguments. This is done BEFORE generating first MC event and AFTER allocating FOAM object and resetting (optionally) its internal parameters/switches. The overall operational scheme of the FOAM is the following:. This method invokes several other methods:; InitCells initializes memory storage for cells and begins exploration process from the root cell. The empty cells are allocated/filled using CellFill. The procedure Grow which loops over cells, picks up the cell with the biggest `‘driver integral’', see Computer Physics Communications 152 152 (2003) 55 for explanations, with the help of PeekMax procedure. The chosen cell is split using Divide. Subsequently, the procedure Explore called by the Divide (and by InitCells for the root cell) does the most important job in the FOAM object build-up: it performs a small MC run for each newly allocated daughter cell. Explore calculates how profitable the future split of the cell will be and defines the optimal cell division geometry with the help of Carver or Varedu procedures, for maximum weight or variance optimization respectively. All essential results of the exploration are written into the explored cell object. At the very end of the foam build-up, Finally, MakeActiveList is invoked to create a list of pointers to all active cells, for the purpose of the quick access during the MC generation. The procedure Explore employs MakeAlpha to generate random coordinates inside a given cell with the uniform distribution. The above sequence of the procedure calls is depicted in the following figure:. Definition at line 307 of file TFoam.cxx. ◆ IsA(). TClass * TFoam::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFoam.html:33092,perform,performs,33092,doc/master/classTFoam.html,https://root.cern,https://root.cern/doc/master/classTFoam.html,1,['perform'],['performs']
Performance,"m = 1, // Used since v3.3; 111 kReflexNoComment = 2, // Up to v5.34.18 (has no range/comment and no typedef at all); 112 kNoRange = 3, // Up to v5.17; 113 kWithTypeDef = 4, // Up to v5.34.18 and v5.99/06; 114 kReflex = 5, // Up to v5.34.18 (has no typedef at all); 115 kNoRangeCheck = 6, // Up to v5.34.18 and v5.99/06; 116 kNoBaseCheckSum = 7, // Up to v5.34.18 and v5.99/06; 117 kLatestCheckSum = 8; 118 };; 119 ; 120 // Describe the current state of the TClass itself.; 121 enum EState {; 122 kNoInfo, // The state has not yet been initialized, i.e. the TClass; 123 // was just created and/or there is no trace of it in the interpreter.; 124 kForwardDeclared, // The interpreted knows the entity is a class but that's it.; 125 kEmulated, // The information about the class only comes from a TStreamerInfo; 126 kInterpreted, // The class is described completely/only in the interpreter database.; 127 kHasTClassInit, // The class has a TClass proper bootstrap coming from a run; 128 // through rootcling/genreflex/TMetaUtils and the library; 129 // containing this dictionary has been loaded in memory.; 130 kLoaded = kHasTClassInit,; 131 kNamespaceForMeta // Very transient state necessary to bootstrap namespace entries; 132 // in ROOT Meta w/o interpreter information; 133 };; 134 ; 135 // ""Typed"" pointer that recalls how TClass::New allocated the object.; 136 // It is returned by TClass:NewObject and should be passed to TClass::DeleteArray or TClass::Destructor; 137 // to delete the object.; 138 // It is also used in TVirtualCollectionProxy for the same reasons.; 139 struct ObjectPtr; 140 {; 141 void *fPtr = nullptr;; 142 ; 143 TVirtualStreamerInfo *fAllocator = nullptr;; 144 ; 145 ObjectPtr(void *ptr = nullptr, TVirtualStreamerInfo *allocator = nullptr) : fPtr(ptr), fAllocator(allocator) {}; 146 ; 147 void *GetPtr() const { return fPtr; }; 148 ; 149 TVirtualStreamerInfo *GetAllocator() const { return fAllocator; }; 150 ; 151 operator bool() const { return fPtr != nullptr; }; 152 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:4431,load,loaded,4431,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['load'],['loaded']
Performance,"m = fetchValueTmp(block, ""Momentum"", 0.3);; 341 settings.dropoutProbabilities = fetchValueTmp(block, ""DropConfig"", std::vector<Double_t>());; 342 ; 343 TString regularization = fetchValueTmp(block, ""Regularization"", TString(""NONE""));; 344 if (regularization == ""L1"") {; 345 settings.regularization = DNN::ERegularization::kL1;; 346 } else if (regularization == ""L2"") {; 347 settings.regularization = DNN::ERegularization::kL2;; 348 } else {; 349 settings.regularization = DNN::ERegularization::kNone;; 350 }; 351 ; 352 TString optimizer = fetchValueTmp(block, ""Optimizer"", TString(""ADAM""));; 353 settings.optimizerName = optimizer;; 354 if (optimizer == ""SGD"") {; 355 settings.optimizer = DNN::EOptimizer::kSGD;; 356 } else if (optimizer == ""ADAM"") {; 357 settings.optimizer = DNN::EOptimizer::kAdam;; 358 } else if (optimizer == ""ADAGRAD"") {; 359 settings.optimizer = DNN::EOptimizer::kAdagrad;; 360 } else if (optimizer == ""RMSPROP"") {; 361 settings.optimizer = DNN::EOptimizer::kRMSProp;; 362 } else if (optimizer == ""ADADELTA"") {; 363 settings.optimizer = DNN::EOptimizer::kAdadelta;; 364 } else {; 365 // Make Adam as default choice if the input string is; 366 // incorrect.; 367 settings.optimizer = DNN::EOptimizer::kAdam;; 368 settings.optimizerName = ""ADAM"";; 369 }; 370 // check for specific optimizer parameters; 371 std::vector<TString> optimParamLabels = {""_beta1"", ""_beta2"", ""_eps"", ""_rho""};; 372 //default values; 373 std::map<TString, double> defaultValues = {; 374 {""ADADELTA_eps"", 1.E-8}, {""ADADELTA_rho"", 0.95},; 375 {""ADAGRAD_eps"", 1.E-8},; 376 {""ADAM_beta1"", 0.9}, {""ADAM_beta2"", 0.999}, {""ADAM_eps"", 1.E-7},; 377 {""RMSPROP_eps"", 1.E-7}, {""RMSPROP_rho"", 0.9},; 378 };; 379 for (auto &pN : optimParamLabels) {; 380 TString optimParamName = settings.optimizerName + pN;; 381 // check if optimizer has default values for this specific parameters; 382 if (defaultValues.count(optimParamName) > 0) {; 383 double defValue = defaultValues[optimParamName];; 384 double val = fetchValueTm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:14066,optimiz,optimizer,14066,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,2,['optimiz'],['optimizer']
Performance,"m RooAbsDataStore.; Definition at line 181 of file RooTreeDataStore.h. ◆ isWeighted(). bool RooTreeDataStore::isWeighted ; (; ); const. inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 74 of file RooTreeDataStore.h. ◆ loadValues() [1/2]. void RooTreeDataStore::loadValues ; (; const RooAbsDataStore * ; tds, . const RooFormulaVar * ; select = nullptr, . const char * ; rangeName = nullptr, . std::size_t ; nStart = 0, . std::size_t ; nStop = std::numeric_limits<std::size_t>::max() . ). overridevirtual . Load values from dataset 't' into this data collection, optionally selecting events using 'select' RooFormulaVar. ; Implements RooAbsDataStore.; Definition at line 470 of file RooTreeDataStore.cxx. ◆ loadValues() [2/2]. void RooTreeDataStore::loadValues ; (; const TTree * ; t, . const RooFormulaVar * ; select = nullptr, . const char * ; rangeName = nullptr, . Int_t ; nStart = 0, . Int_t ; nStop = 2000000000 . ). Load values from tree 't' into this data collection, optionally selecting events using the RooFormulaVar 'select'. ; The source tree 't' is cloned to not disturb its branch structure when retrieving information from it. ; Definition at line 367 of file RooTreeDataStore.cxx. ◆ makeTreeName(). std::string RooTreeDataStore::makeTreeName ; (; ); const. private . Generate a name for the storage tree from the name and title of this instance. ; Definition at line 1185 of file RooTreeDataStore.cxx. ◆ merge(). RooAbsDataStore * RooTreeDataStore::merge ; (; const RooArgSet & ; allVars, . std::list< RooAbsDataStore * > ; dstoreList . ). overridevirtual . Merge columns of supplied data set(s) with this data set. ; All data sets must have equal number of entries. In case of duplicate columns the column of the last dataset in the list prevails ; Implements RooAbsDataStore.; Definition at line 840 of file RooTreeDataStore.cxx. ◆ numEntries(). Int_t RooTreeDataStore::numEntries ; (; ); const. overridevirtual . Implements RooAbsDataStore.; Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:34112,Load,Load,34112,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['Load'],['Load']
Performance,"m RooAbsReal.; Definition at line 77 of file RooAbsCachedReal.cxx. ◆ inputBaseName(). virtual const char * RooAbsCachedReal::inputBaseName ; (; ); const. protectedpure virtual . Implemented in RooCachedReal, and RooNumRunningInt. ◆ IsA(). TClass * RooAbsCachedReal::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in RooCachedReal, RooNumCdf, and RooNumRunningInt.; Definition at line 120 of file RooAbsCachedReal.h. ◆ payloadUniqueSuffix(). virtual const char * RooAbsCachedReal::payloadUniqueSuffix ; (; ); const. inlineprotectedvirtual . Reimplemented in RooCachedReal, and RooNumRunningInt.; Definition at line 93 of file RooAbsCachedReal.h. ◆ selfNormalized(). virtual bool RooAbsCachedReal::selfNormalized ; (; ); const. inlinevirtual . Definition at line 32 of file RooAbsCachedReal.h. ◆ setInterpolationOrder(). void RooAbsCachedReal::setInterpolationOrder ; (; Int_t ; order). Set interpolation order of RooHistFunct representing cache histogram. ; Definition at line 254 of file RooAbsCachedReal.cxx. ◆ Streamer(). void RooAbsCachedReal::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in RooCachedReal, RooNumCdf, and RooNumRunningInt. ◆ StreamerNVirtual(). void RooAbsCachedReal::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 120 of file RooAbsCachedReal.h. Friends And Related Symbol Documentation. ◆ FuncCacheElem. friend class FuncCacheElem. friend . Definition at line 95 of file RooAbsCachedReal.h. Member Data Documentation. ◆ _anaIntMap. std::map<Int_t,std::pair<const RooArgSet*,const RooArgSet*> > RooAbsCachedReal::_anaIntMap. mutableprotected . ! Map for analytical integration codes ; Definition at line 113 of file RooAbsCachedReal.h. ◆ _cacheMgr. RooObjCacheManager RooAbsCachedReal::_cacheMgr. mutableprotected . ! The cache manager ; Definition at line 106 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:67918,cache,cache,67918,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,1,['cache'],['cache']
Performance,"m RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistPdf.html:36651,cache,cache,36651,root/html528/RooHistPdf.html,https://root.cern,https://root.cern/root/html528/RooHistPdf.html,4,['cache'],"['cache', 'caches']"
Performance,"m RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooSetProxy_depListList of dependents defining dimensions of histogram; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistFunc.html:29936,cache,cache,29936,root/html528/RooHistFunc.html,https://root.cern,https://root.cern/root/html528/RooHistFunc.html,4,['cache'],"['cache', 'caches']"
Performance,"m RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooListProxy_highSetHigh-side varaition; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; vector<int>_interpCode; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_lowSetLow-side variation; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooRealProxy_nominalThe nominal value; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/PiecewiseInterpolation.html:30987,cache,cache,30987,root/html532/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html532/PiecewiseInterpolation.html,5,['cache'],"['cache', 'caches']"
Performance,"m RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Int_t_lenLength of _value; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:18959,cache,caches,18959,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,3,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"m TGTextEdit widget. void LoadFile(const char* fname = 0); Load a file into the editor. If fname is 0, a TGFileDialog will popup. void SaveFile(const char* fname); Save the edited text in the file ""fname"". Bool_t SaveFileAs(); Save the edited text in a file selected with TGFileDialog.; Shouldn't we create a backup file?. Int_t IsSaved(); Check if file has to be saved in case of modifications. void PrintText(); Open the print dialog and send current buffer to printer. void CloseWindow(); Close TGTextEditor window. Bool_t HandleKey(Event_t* event); Keyboard event handler. void ClearText(); Clear text edit widget. void Search(Bool_t ret); Invokes search dialog, or just search previous string if again is true. void Goto(); Invokes goto dialog, and go to the specified line. void CompileMacro(); Save the edited text in a temporary macro, then compile it. void ExecuteMacro(); Save the edited text in a temporary macro, execute it, and then delete; the temporary file. void InterruptMacro(); Interrupt execution of a macro. void About(); Display ROOT splash screen. Bool_t HandleTimer(TTimer* t); Handle timer event. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. Bool_t LoadBuffer(const char* buf); { return fTextEdit->LoadBuffer(buf); }. void DataChanged(); { fTextChanged = kTRUE; }. void SetText(TGText* text); { fTextEdit->SetText(text); }. void AddText(TGText* text); { fTextEdit->AddText(text); }. void AddLine(const char* string); { fTextEdit->AddLine(string); }. void AddLineFast(const char* string); { fTextEdit->AddLineFast(string); }. TGText * GetText() const; { return fTextEdit->GetText(); }. » Author: Bertrand Bellenot 20/06/06 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-14 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGTextEditor.html:28958,Load,LoadBuffer,28958,root/html534/TGTextEditor.html,https://root.cern,https://root.cern/root/html534/TGTextEditor.html,2,['Load'],['LoadBuffer']
Performance,"m TObject.; Reimplemented in TTreeFormula.; Definition at line 271 of file TFormula.h. ◆ IsLinear(). virtual Bool_t ROOT::v5::TFormula::IsLinear ; (; ); const. inlinevirtual . Definition at line 247 of file TFormula.h. ◆ IsNormalized(). virtual Bool_t ROOT::v5::TFormula::IsNormalized ; (; ); const. inlinevirtual . Definition at line 248 of file TFormula.h. ◆ IsString(). Bool_t TFormula::IsString ; (; Int_t ; oper); const. protectedvirtual . Return true if the expression at the index 'oper' has to be treated as a string. ; Reimplemented in TTreeFormula.; Definition at line 3269 of file TFormula_v5.cxx. ◆ MakePrimitive(). void TFormula::MakePrimitive ; (; const char * ; expr, . Int_t ; pos . ). protected . MakePrimitive find TFormulaPrimitive replacement for some operands. ; Definition at line 3746 of file TFormula_v5.cxx. ◆ operator=(). TFormula & TFormula::operator= ; (; const TFormula & ; rhs). Operator =. ; Definition at line 303 of file TFormula_v5.cxx. ◆ Optimize(). void TFormula::Optimize ; (; ). MI include. ; Optimize formula; Minimize the number of operands; several operands are glued together; some primitive functions glued together - exemp. (x+y) => PlusXY(x,y); maximize number of standard calls minimizing number of jumps in Eval cases; variables, parameters and constants are mapped - using fOperOfssets0 Eval procedure use direct acces to data (only one corresponding case statement in eval procedure) pdata[operand={Var,Par,Const}][offset]; pdata[fOperOffsets0[i]][fOperOffset1[i+1]]; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html:44249,Optimiz,Optimize,44249,doc/master/classROOT_1_1v5_1_1TFormula.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html,1,['Optimiz'],['Optimize']
Performance,"m TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Bool_t fAllTri;  ! True if FindAllTriangles() has been performed on fGraph2D ;  ; Double_t * fDist;  ! Array used to order mass points by distance ;  ; TGraph2D * fGraph2D;  ! 2D graph containing the user data ;  ; Int_t * fHullPoints;  ! Hull points of size fNhull ;  ; Bool_t fInit;  ! True if CreateTrianglesDataStructure() and FindHull() have been performed ;  ; Int_t fMaxIter;  ! Maximum number of iterations to find Delaunay triangles ;  ; Int_t * fMTried;  ! ;  ; Int_t fNdt;  ! Number of Delaunay triangles found ;  ; Int_t fNhull;  ! Number of points in the hull ;  ; Int_t fNpoints;  ! Number of data points in fGraph2D ;  ; Int_t * fNTried;  ! Delaunay triangles storage of size fNdt ;  ; Int_t * fOrder;  ! Array used to order mass points by distance ;  ; Int_t * fPTried;  ! ;  ; Int_t fTriedSize;  ! Real size of the fxTried arrays ;  ; Double_t * fX;  ! Pointer to fGraph2D->fX ;  ; Double_t * fXN;  ! fGraph2D vectors normalized of size fNpoints ;  ; Double_t fXNmax;  ! Maximum value of fXN ;  ; Double_t fXNmin;  ! Minimum value of fXN ;  ; Double_t fXoffset;  ! ;  ; Double_t fXScaleFactor;  ! ;  ; Double_t * fY;  ! Pointer to fGraph2D->fY ;  ; Double_t * fYN;  ! fGraph2D vectors normalized of size fNpoints ;  ; Double_t fYNmax;  ! Maximum value of fYN ;  ; Double_t fYNmin;  ! Minimum value of fYN ;  ; Double_t fYoffset;  ! Parameters used to normalize user data ;  ; Double_t fYScaleFactor;  ! ;  ; Double_t * fZ;  ! Pointer to fGraph2D->fZ ;  ; Double_t fZout;  ! Histogram bin height for points lying outside the convex hull ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions;  TGraphDelaunay (const TGraphDelaunay &)=delete;  ; TGraphDelaunay & operator= (const TGraphDelaunay &)=delete;  . Additional Inherited Member",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphDelaunay.html:13435,perform,performed,13435,doc/master/classTGraphDelaunay.html,https://root.cern,https://root.cern/doc/master/classTGraphDelaunay.html,2,['perform'],['performed']
Performance,"m TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <TProofOutputList.h>. Inheritance diagram for TProofOutputList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TProofOutputList(). TProofOutputList::TProofOutputList ; (; const char * ; dontshow = ""PROOF_*""). Constructor. ; Definition at line 31 of file TProofOutputList.cxx. ◆ ~TProofOutputList(). TProofOutputList::~TProofOutputList ; (; ). override . Destructor. ; Definition at line 44 of file TProofOutputList.cxx. Member Function Documentation. ◆ AttachList(). void TProofOutputList::AttachList ; (; TList * ; alist). Attach to list 'alist'. ; Definition at line 53 of file TProofOutputList.cxx. ◆ ClassDefOverride(). TProofOutputList::ClassDefOverrid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofOutputList.html:19169,cache,cache,19169,doc/master/classTProofOutputList.html,https://root.cern,https://root.cern/doc/master/classTProofOutputList.html,1,['cache'],['cache']
Performance,"m TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <TSortedList.h>. Inheritance diagram for TSortedList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TSortedList(). TSortedList::TSortedList ; (; Bool_t ; order = kSortAscending). inline . Definition at line 31 of file TSortedList.h. Member Function Documentation. ◆ Add() [1/2]. void TSortedList::Add ; (; TObject * ; obj). overridevirtual . Add object in sorted list. ; Uses object Compare() member to find right position. ; Reimplemented from TList.; Definition at line 27 of file TSortedList.cxx. ◆ Add() [2/2]. void TSortedList::Add ; (; TObject * ; obj, . Option_t * ; opt . ). overridevirtual . Add object in sorted list. ; Uses object Compare() memb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSortedList.html:19062,cache,cache,19062,doc/master/classTSortedList.html,https://root.cern,https://root.cern/doc/master/classTSortedList.html,1,['cache'],['cache']
Performance,"m TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . Inheritance diagram for TGTextEditHist:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGTextEditHist(). TGTextEditHist::TGTextEditHist ; (; ). inline . Definition at line 65 of file TGTextEdit.cxx. ◆ ~TGTextEditHist(). TGTextEditHist::~TGTextEditHist ; (; ). inlineoverride . Definition at line 66 of file TGTextEdit.cxx. Member Function Documentation. ◆ Notify(). Bool_t TGTextEditHist::Notify ; (; ). inlineoverridevirtual . 'Notify' all objects in this collection. ; Reimplemented from TCollection.; Definition at line 68 of file TGTextEdit.cxx. gui/gui/src/TGTextEdit.cxx. TGTextEditHist. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:37 (GVA ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEditHist.html:18793,cache,cache,18793,doc/master/classTGTextEditHist.html,https://root.cern,https://root.cern/doc/master/classTGTextEditHist.html,1,['cache'],['cache']
Performance,"m TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . Inheritance diagram for TQConnectionList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TQConnectionList(). TQConnectionList::TQConnectionList ; (; const char * ; name, . Int_t ; nsigargs . ). inline . Definition at line 315 of file TQObject.cxx. ◆ ~TQConnectionList(). TQConnectionList::~TQConnectionList ; (; ). virtual . Destructor. ; Definition at line 327 of file TQObject.cxx. Member Function Documentation. ◆ Disconnect(). Bool_t TQConnectionList::Disconnect ; (; void * ; receiver = nullptr, . const char * ; slot_name = nullptr . ). Remove connection from the list. ; For more info see TQObject::Disconnect() ; Definition at line 344 of file TQObject.cxx. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQConnectionList.html:19154,cache,cache,19154,doc/master/classTQConnectionList.html,https://root.cern,https://root.cern/doc/master/classTQConnectionList.html,1,['cache'],['cache']
Performance,"m TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . Inheritance diagram for TRootBrowserHistory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Function Documentation. ◆ DeleteItem(). void TRootBrowserHistory::DeleteItem ; (; TGListTreeItem * ; item). inline . Definition at line 207 of file TRootBrowserLite.cxx. ◆ RecursiveRemove(). void TRootBrowserHistory::RecursiveRemove ; (; TObject * ; obj). inlineoverridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; Reimplemented from TList.; Definition at line 194 of file TRootBrowserLite.cxx. gui/gui/src/TRootBrowserLite.cxx. TRootBrowserHistory. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:23 (GVA Time) usi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootBrowserHistory.html:18797,cache,cache,18797,doc/master/classTRootBrowserHistory.html,https://root.cern,https://root.cern/doc/master/classTRootBrowserHistory.html,1,['cache'],['cache']
Performance,"m TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . Inheritance diagram for TRootIconList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TRootIconList(). TRootIconList::TRootIconList ; (; TRootIconBox * ; box = nullptr). constructor ; Definition at line 353 of file TRootBrowserLite.cxx. ◆ ~TRootIconList(). TRootIconList::~TRootIconList ; (; ). override . destructor ; Definition at line 363 of file TRootBrowserLite.cxx. Member Function Documentation. ◆ Browse(). void TRootIconList::Browse ; (; TBrowser * ; b). overridevirtual . browse icon list ; Reimplemented from TCollection.; Definition at line 718 of file TRootBrowserLite.cxx. ◆ GetPicture(). const TGPicture * TRootIconList::GetPicture ; (; ); const. inli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootIconList.html:19003,cache,cache,19003,doc/master/classTRootIconList.html,https://root.cern,https://root.cern/doc/master/classTRootIconList.html,1,['cache'],['cache']
Performance,"m The array stats must be correctly dimensione...Definition TH1.cxx:7833; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::kIsAverage@ kIsAverageBin contents are average (used by Add)Definition TH1.h:171; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::GetBinvirtual Int_t GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) constReturn Global bin number corresponding to binx,y,z.Definition TH1.cxx:4961; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8cxx_source.html:179405,Perform,Performs,179405,doc/master/TEfficiency_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html,1,['Perform'],['Performs']
Performance,"m a vector expression, like v=p*q+w. Due to the expression template technique, no temporary objects are created in this operation.; Constructor by passing directly the elements. This is possible only for vectors up to size 10.; Constructor from an iterator copying the data referred by the iterator. It is possible to specify the begin and end of the iterator or the begin and the size. Note that for the Vector the iterator is not generic and must be of type T*, where T is the type of the contained elements. In the following example we assume that we are using the namespace ROOT::Math; //create an empty vector of size 3 ( v[0]=v[1]=v[2]=0); SVector<double,3> v;; double d[3] = {1,2,3};; SVector<double,3> v(d,3); //create a vector from a C array; 13.13.1.2 Accessing and Setting Methods; The single vector elements can be set or retrieved using the operator[i], operator(i) or the iterator interface. Notice that the index starts from zero and not from one as in FORTRAN. Also no check is performed on the passed index. The full vector elements can be set also by using the SetElements function passing a generic iterator.; double x = m(i); // return the i-th element; x = *(m.begin()+i); // return the i-th element; v[0] = 1; // set the first element; v(1) = 2; // set the second element; *(v.begin()+3) = 3; // set the third element; std::vector<double> w(3);. // set vector elements from a std::vector<double>::iterator; v.SetElements(w.begin(),w.end());; In addition there are methods to place a sub-vector in a vector. If the size of the sub-vector is larger than the vector size a static assert (a compilation error) is produced.; SVector>double,N> v;; SVector>double,M> w;; // M <= N otherwise a compilation error is obtained later; // place a vector of size M starting from; // element ioff, v[ioff+i]=w[i]; v.Place_at(w,ioff);; // return a sub-vector of size M starting from; // v[ioff]: w[i]=v[ioff+i]; w = v.Sub < SVector>double,M> > (ioff);; For the vector functions see later in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:752145,perform,performed,752145,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performed']
Performance,"m any other function, it can be drawn, evaluated, etc.; –For multidimensional fitting, TFormulas of the form: x[0]++...++x[n] can be used 2.2.2 There is no need to create the function if you don't want to,; the formula can be set by expression: –Example: // 2 is the number of dimensions; TLinearFitter *lf = new TLinearFitter(2);; lf->SetFormula(""x ++ y ++ x*x*y*y"");; 2.2.3 The fastest functions to compute are polynomials and hyperplanes.; –Polynomials are set the usual way: ""pol1"", ""pol2"",... –Hyperplanes are set by expression ""hyp3"", ""hyp4"", ... —The ""hypN"" expressions only work when the linear fitter is used directly, not through TH1::Fit or TGraph::Fit. To fit a graph or a histogram with a hyperplane, define the function as ""1++x++y"". —A constant term is assumed for a hyperplane, when using the ""hypN"" expression, so ""hyp3"" is in fact fitting with ""1++x++y++z"" function. –Fitting hyperplanes is much faster than fitting other expressions so if performance is vital, calculate the function values beforehand and give them to the fitter as variables –Example: You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate sin(x) and cos(2*x) beforehand and store them in array *data. Then: TLinearFitter *lf=new TLinearFitter(2, ""hyp2""); lf->AssignData(npoint, 2, data, y);; 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points. –Example: TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();; ...; e#define e(i)Definition RSha256.hxx:103; TLinearFitter::Evalvirtual Int_t Eval()Perform the fit and evaluate the parameters Returns 0 if the fit is ok, 1 if there are errors.Definition TLinearFitter.cxx:874; TLinearFitter::AssignDatavirtual void AssignData(Int_t npoints, Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearFitter.html:4916,perform,performance,4916,doc/master/classTLinearFitter.html,https://root.cern,https://root.cern/doc/master/classTLinearFitter.html,1,['perform'],['performance']
Performance,"m fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:15942,cache,cache,15942,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cache']
Performance,"m of column with name columname.; if the Tree has an associated TEventList or TEntryList, the maximum; is computed for the entries in this list. Long64_t GetMaxTreeSize(); Static function which returns the tree file size limit in bytes. Double_t GetMinimum(const char* columname); Return minimum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the minimum; is computed for the entries in this list. TVirtualTreePlayer* GetPlayer(); Load the TTreePlayer (if not already done). TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occured while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:94921,Load,LoadBaskets,94921,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['Load'],['LoadBaskets']
Performance,"m of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; std::unique_ptr< TreeReadBuffer > _treeReadBuffer;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void finalizeConstruction ();  ; std::pair< const RooArgSet *, AddCacheElem * > getNormAndCache (const RooArgSet *nset) const;  Look up projection cache and per-PDF norm sets. ;  ; void materializeRefCoefNormFromAttribute () const;  ; void setAllExtendable (bool allExtendable);  ; void setRecursiveFra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:74849,Cache,Cached,74849,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,1,['Cache'],['Cached']
Performance,"m of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; std::unique_ptr< TreeReadBuffer > _treeReadBuffer;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Int_t _evalErrorCount = 0;  ; static std::map< const RooAbsArg *, std::pair< std::string, std::list< EvalError > > > _evalErrorList;  ; static ErrorLoggingMode _evalErrorMode = RooAbsReal::PrintErrors;  ; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hidin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:59849,Cache,Cached,59849,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['Cache'],['Cached']
Performance,"m of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; std::unique_ptr< TreeReadBuffer > _treeReadBuffer;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _doFloorGlobal = false;  Global flag for introducing floor at zero in pdf. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static Int_t _evalErrorC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:64917,Cache,Cached,64917,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,1,['Cache'],['Cached']
Performance,"m of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; std::unique_ptr< TreeReadBuffer > _treeReadBuffer;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _doFloorGlobal = false;  Global flag for introducing floor at zero in pdf. ;  ;  Static Protected Attributes inherited from RooAbsReal; static Int_t _evalErrorCount = 0;  ; static std::map< const RooAbsArg *, std::pair< std::string, std::list< EvalError > > > _evalErrorList;  ; static E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:50996,Cache,Cached,50996,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,1,['Cache'],['Cached']
Performance,"m of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useCdfBoundariesAre c.d.f boundary conditions used by the RooHistFuncs?; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to function being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedReal(const char* name, const char* title, RooAbsReal& _func); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedReal.html:33592,cache,cached,33592,root/html526/RooCachedReal.html,https://root.cern,https://root.cern/root/html526/RooCachedReal.html,2,['cache'],['cached']
Performance,"m of the PAR file corresponding to given package Returns a pointer to a TMD5 object, transferring ownership to the caller. ;  ; const char * GetName () const override;  Returns name of object. ;  ; Int_t GetPackDir (const char *pack, TString &pdir);  Method to get the path of the dir for package 'pack'. ;  ; Int_t GetParPath (const char *pack, TString &path);  Method to get the path of the PAR file for package 'pack'. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; Bool_t Has (const char *pack);  Method to check if this package manager has package 'pack'. ;  ; Int_t Install (const char *par, Bool_t rmold=kFALSE);  Install package from par (unpack the file in the directory); par can be an URL for remote retrieval. ;  ; TClass * IsA () const override;  ; Bool_t IsInDir (const char *path);  Method to check if 'path' is in the managed directory Return kTRUE or kFALSE. ;  ; Bool_t IsPackageEnabled (const char *pack);  ; Int_t Load (const char *pack, const char *opts);  Method to load a package taking an option const char * Return -1 on error, 0 otherwise. ;  ; Int_t Load (const char *pack, TList *optls=0);  Method to load a package taking an option list Return -1 on error, 0 otherwise. ;  ; TMD5 * ReadMD5 (const char *pack);  Read MD5 checksum of the PAR file from the PROOF-INF/md5.txt file. ;  ; Int_t Remove (const char *pack=0, Bool_t dolock=kTRUE);  Remove package 'pack' If 'pack' is null or empty all packages are cleared. ;  ; void SetLogger (TPackMgrLog_t logger);  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetPrefix (const char *pfx);  ; void Show (const char *title=0);  Show available packages. ;  ; void ShowEnabled (const char *title=0);  Show enabled packages. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t Unload (const char *pack);  Method to unload a package. ;  ; Int_t Unpack (const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:3339,Load,Load,3339,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,2,"['Load', 'load']","['Load', 'load']"
Performance,"m of weights in dh : "", dh.sum(False)); # accounts for bin volume; print("">> integral over histogram: "", dh.sum(True)); ; # Locate a bin from a set of coordinates and retrieve its properties; x.setVal(0.3); y.setVal(20.5); print("">> retrieving the properties of the bin enclosing coordinate (x,y) = (0.3,20.5) bin center:""); # load bin center coordinates in internal buffer; dh.get({x, y}).Print(""v""); print("" weight = "", dh.weight()) # return weight of last loaded coordinates; ; # Reduce the 2-dimensional binned dataset to a 1-dimensional binned dataset; #; # All reduce() methods are interfaced in RooAbsData. All reduction techniques; # demonstrated on unbinned datasets can be applied to binned datasets as; # well.; print("">> Creating 1-dimensional projection on y of dh for bins with x>0""); dh2 = dh.reduce({y}, ""x>0""); dh2.Print(""v""); ; # Add dh2 to yframe and redraw; dh2.plotOn(yframe, LineColor=""r"", MarkerColor=""r""); ; # Saving and loading from file; # -------------------------------------------------------; ; # Datasets can be persisted with ROOT I/O; print(""\n >> Persisting d via ROOT I/O""); f = ROOT.TFile(""rf402_datahandling.root"", ""RECREATE""); d.Write(); f.ls(); ; # To read back in future session:; # > ROOT.TFile f(""rf402_datahandling.root""); # > d = (ROOT.RooDataSet*) f.FindObject(""d""); ; c = ROOT.TCanvas(""rf402_datahandling"", ""rf402_datahandling"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yframe.Draw(); ; c.SaveAs(""rf402_datahandling.png""); typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8py.html:4803,load,loading,4803,doc/master/rf402__datahandling_8py.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html,1,['load'],['loading']
Performance,"m optimization management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCache.html:1607,cache,cache,1607,root/html534/RooAbsCache.html,https://root.cern,https://root.cern/root/html534/RooAbsCache.html,1,['cache'],['cache']
Performance,"m previous sessions; TProofOutputListfOutputListTList implementation filtering ls(...) and Print(...); TStringfPackageDirpackage directory (used on client); TProofLockPath*fPackageLockpackage lock; TStringfPerfTreeIf non-null triggers saving of the performance info into fPerfTree; TVirtualProofPlayer*fPlayercurrent player; PrintProgress_tfPrintProgressFunction function to display progress info in batch mode; TPluginHandler*fProgressDialogprogress dialog plugin; Bool_tfProgressDialogStartedindicates if the progress dialog is up; TList*fQuerieslist of TProofQuery objects; Float_tfRealTimerealtime spent by all slaves during the session; TList*fRecvMessagesMessages received during collect not yet processed; Bool_tfRedirLogredirect received log info; Int_tfRedirectNext; TProof::ERunStatusfRunStatusrun status; Bool_tfSaveLogToMacroWhether to save received logs to TMacro fMacroLog (use with care); Bool_tfSendGroupViewif true send new group view; Int_tfSeqNumRemote sequential # of the last query submitted; Int_tfSessionIDremote ID of the session; TList*fSlaveInfo!list returned by kPROOF_GETSLAVEINFO; Int_tfStatusremote return status (part of kPROOF_LOGDONE); Bool_tfSynctrue if type of currently processed query is sync; Bool_tfTtyTRUE if connected to a terminal; TMonitor*fUniqueMonitormonitor activity on all unique slave sockets; TList*fUniqueSlaveslist of all active slaves with unique file systems; Bool_tfValidis this a valid proof object; TList*fWaitingSlavesstores a TPair of the slaves's TSocket and TMessage; TStringfWorkDircurrent work directory on remote servers; Int_tfWorkersToMergeCurrent total number of workers, which have not been yet assigned to any merger; TList*fWrksOutputReadyList of workers ready to send output (in control output sending mode); static TPluginHandler*fgLogViewerLog dialog box plugin; static TList*fgProofEnvListList of TNameds defining environment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProof(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:33255,perform,performance,33255,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['perform'],['performance']
Performance,"m proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; double _bufFrac;  ; BufStrat _bufStrat;  ; RooSetProxy _cacheObs;  Non-convolution observables that are also cached. ;  ; RooSetProxy _params;  Effective parameters of this p.d.f. ;  ; RooRealProxy _pdf1;  First input p.d.f. ;  ; RooRealProxy _pdf2;  Second input p.d.f. ;  ; double _shift1;  ; double _shift2;  ; RooRealProxy _x;  Convolution observable. ;  ; RooRealProxy _xprime;  Input function representing value of convolution observable. ;  ;  Protected Attributes inherited from RooAbsCachedPdf; std::map< Int_t, AnaIntConfig > _anaIntMap;  ! Map for analytical integration codes ;  ; RooAICRegistry _anaReg;  ! Registry for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ; Int_t _ipOrder;  The cache manager. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:79614,cache,cache,79614,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance,"m rays; A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node. The Drawing Package. The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter() loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes. Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; TGeoManager::GetMasterVolumeTGeoVolume * GetMasterVolume() constDefinition TGeoManager.h:511; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:106240,load,loads,106240,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['load'],['loads']
Performance,"m remote. ; Definition at line 600 of file RWebWindowsManager.cxx. ◆ InformListener(). bool RWebWindowsManager::InformListener ; (; const std::string & ; msg). private . If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket. ; Definition at line 227 of file RWebWindowsManager.cxx. ◆ Instance(). std::shared_ptr< RWebWindowsManager > & RWebWindowsManager::Instance ; (; ). static . Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel. ; Definition at line 78 of file RWebWindowsManager.cxx. ◆ IsLoopbackMode(). bool RWebWindowsManager::IsLoopbackMode ; (; ). static . Returns true if loopback mode used by THttpServer for web widgets. ; Definition at line 146 of file RWebWindowsManager.cxx. ◆ IsMainThrd(). bool RWebWindowsManager::IsMainThrd ; (; ). static . Returns true when called from main process Main process recognized at the moment when library is loaded It supposed to be a thread where gApplication->Run() will be called If application runs in separate thread, one have to use AssignMainThrd() method to let RWebWindowsManager correctly recognize such situation. ; Definition at line 104 of file RWebWindowsManager.cxx. ◆ IsUseHttpThread(). bool ROOT::RWebWindowsManager::IsUseHttpThread ; (; ); const. inlineprivate . Returns true if http server use special thread for requests processing (default off) ; Definition at line 55 of file RWebWindowsManager.hxx. ◆ IsUseSenderThreads(). bool ROOT::RWebWindowsManager::IsUseSenderThreads ; (; ); const. inlineprivate . Returns true if extra threads to send data via websockets will be used (default off) ; Definition at line 58 of file RWebWindowsManager.hxx. ◆ SetLoopbackMode(). void RWebWindowsManager::SetLoopbackMode ; (; bool ; on = true). static . Set loopback mode for THttpServer used for web widgets By default is on. ; Only local communication via localhost address is possible Disable it only if really necessary - it may open unauthorized access ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:12745,load,loaded,12745,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['load'],['loaded']
Performance,"m remote. ; Definition at line 686 of file RWebWindowsManager.cxx. ◆ InformListener(). bool RWebWindowsManager::InformListener ; (; const std::string & ; msg). private . If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket. ; Definition at line 299 of file RWebWindowsManager.cxx. ◆ Instance(). std::shared_ptr< RWebWindowsManager > & RWebWindowsManager::Instance ; (; ). static . Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel. ; Definition at line 79 of file RWebWindowsManager.cxx. ◆ IsLoopbackMode(). bool RWebWindowsManager::IsLoopbackMode ; (; ). static . Returns true if loopback mode used by THttpServer for web widgets. ; Definition at line 147 of file RWebWindowsManager.cxx. ◆ IsMainThrd(). bool RWebWindowsManager::IsMainThrd ; (; ). static . Returns true when called from main process Main process recognized at the moment when library is loaded It supposed to be a thread where gApplication->Run() will be called If application runs in separate thread, one have to use AssignMainThrd() method to let RWebWindowsManager correctly recognize such situation. ; Definition at line 105 of file RWebWindowsManager.cxx. ◆ IsUseHttpThread(). bool ROOT::RWebWindowsManager::IsUseHttpThread ; (; ); const. inlineprivate . Returns true if http server use special thread for requests processing (default off) ; Definition at line 60 of file RWebWindowsManager.hxx. ◆ IsUseSenderThreads(). bool ROOT::RWebWindowsManager::IsUseSenderThreads ; (; ); const. inlineprivate . Returns true if extra threads to send data via websockets will be used (default off) ; Definition at line 63 of file RWebWindowsManager.hxx. ◆ SetDeleteCallback(). void ROOT::RWebWindowsManager::SetDeleteCallback ; (; WebWindowDeleteCallback_t ; func). inline . Assign show callback which can catch window showing, used by RBrowser. ; Definition at line 98 of file RWebWindowsManager.hxx. ◆ SetLoopbackMode(). void RWebWindowsManager::SetLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:14936,load,loaded,14936,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['load'],['loaded']
Performance,"m requirement; Double_t**fCutMinminimum requirement; vector<Interval*>fCutRangeallowed ranges for cut optimisation; Double_t*fCutRangeMaxmaximum of allowed cut range; Double_t*fCutRangeMinminimum of allowed cut range; TH1*fEffBvsSLocalintermediate eff. background versus eff signal histo; TMVA::MethodCuts::EEffMethodfEffMethodchosen efficiency calculation method; TStringfEffMethodSchosen efficiency calculation method (string); Double_tfEffRefreference efficiency; Double_tfEffSMaxused to test optimized signal efficiency; Double_tfEffSMinused to test optimized signal efficiency; TMVA::MethodCuts::EFitMethodTypefFitMethodchosen fit method; TStringfFitMethodSchosen fit method (string); vector<EFitParameters>*fFitParamsvector for series of fit methods; vector<Double_t>*fMeanBmeans of variables (background); vector<Double_t>*fMeanSmeans of variables (signal); Bool_tfNegEffWarningflag risen in case of negative efficiency warning; Int_tfNparnumber of parameters in fit (default: 2*Nvar); TRandom*fRandomrandom generator for MC optimisation method; vector<Int_t>*fRangeSignused to match cuts to fit parameters (and vice versa); vector<Double_t>*fRmsBRMSs of variables (background); vector<Double_t>*fRmsSRMSs of variables (signal); Double_tfTestSignalEffused to test optimized signal efficiency; Double_t*fTmpCutMaxtemporary maximum requirement; Double_t*fTmpCutMintemporary minimum requirement; vector<TH1*>*fVarHistBreference histograms (background); vector<TH1*>*fVarHistB_smoothsmoothed reference histograms (background); vector<TH1*>*fVarHistSreference histograms (signal); vector<TH1*>*fVarHistS_smoothsmoothed reference histograms (signal) ; vector<PDF*>*fVarPdfBreference PDFs (background); vector<PDF*>*fVarPdfSreference PDFs (signal). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCuts(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""MC:150:10000:"", TDirectory* theTargetFile",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCuts.html:19090,optimiz,optimized,19090,root/html528/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html,12,['optimiz'],['optimized']
Performance,"m set the desired properties in the binning named ""cache"" in the observables of the function. The dimensions of the cache are automatically matched to the number of observables used in each use context. Multiple cache in different observable may exists simultaneously if the cached p.d.f is used with multiple observable configurations simultaneously ; Definition at line 44 of file RooCachedPdf.cxx. ◆ RooCachedPdf() [4/4]. RooCachedPdf::RooCachedPdf ; (; const RooCachedPdf & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 79 of file RooCachedPdf.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooCachedPdf::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . If this pdf is operated with a fixed set of observables, return the subset of the fixed observables that are actual dependents of the external input p.d.f. ; If this p.d.f is operated without a fixed set of cache observables, return the actual observables of the external input p.d.f given the choice of observables defined in nset ; Implements RooAbsCachedPdf.; Definition at line 129 of file RooCachedPdf.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooCachedPdf::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . If this p.d.f is operated with a fixed set of observables, return all variables of the external input p.d.f that are not one of the cache observables. ; If this p.d.f is operated in automatic mode, return the parameters of the external input p.d.f ; Implements RooAbsCachedPdf.; Definition at line 146 of file RooCachedPdf.cxx. ◆ Class(). static TClass * RooCachedPdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCachedPdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCachedPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:79307,cache,cache,79307,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,1,['cache'],['cache']
Performance,"m to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:52293,load,load,52293,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['load']
Performance,"m tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_t_treeVar!do not persist; UInt_t_uintValue! Transient cache for unsigned integer values from tree branches ; TString_unitUnit for objects value; Double_t_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setHideOffset(Bool_t flag)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:33084,cache,cache,33084,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,2,['cache'],['cache']
Performance,"m tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useCdfBoundariesAre c.d.f boundary conditions used by the RooHistFuncs?; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to function being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedReal(const char* name, const char* title, RooAbsReal& _func); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Interface function to create an internal cache object that represent; each cached function configuration. This interfa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:39095,cache,cacheObs,39095,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,6,['cache'],"['cache', 'cacheObs', 'cached']"
Performance,"m! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypeak; RooRealProxytail; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNovosibirsk.html:38655,cache,cache,38655,root/html526/RooNovosibirsk.html,https://root.cern,https://root.cern/root/html526/RooNovosibirsk.html,2,['cache'],['cache']
Performance,"m! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfIter! Iterator of PDF list; RooListProxy_pdfListList of PDF components; RooLinkedList_pdfNSetListList of PDF component normalization sets; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; TNamed*_refRangeNameReference range name for interpretation of conditional products; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; Bool_t_selfNormIs self-normalized; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useDefaultGenUse default or distributed event generator; Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:45752,cache,cache,45752,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,1,['cache'],['cache']
Performance,"m! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfIter! Iterator of PDF list; RooListProxy_pdfListList of PDF components; RooLinkedList_pdfNSetListList of PDF component normalization sets; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; TNamed*_refRangeNameReference range name for interpretation of conditional products; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; Bool_t_selfNormIs self-normalized; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useDefaultGenUse default or distributed event generator; Double_tRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:47419,cache,cache,47419,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,2,['cache'],['cache']
Performance,"m& ftor, const RooArgList& vars); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctorBinding.html:24599,cache,cache,24599,root/html602/RooFunctorBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctorBinding.html,2,['cache'],['cache']
Performance,"m& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to ostream. void printValue(ostream& os) const; Print value (label name). void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return nu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:23352,cache,cache,23352,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,3,['cache'],['cache']
Performance,"m& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual voidrandomize(const RooAbsBinning& binning); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsRealLValue(); RooAbsRealLValue(const RooAbsRealLValue& other, const char* name = 0); RooAbsRealLValue(const char* name, const char* title, const char* unit = """"); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); virtual voidsetBin(Int_t ibin, const RooAbsBinning& binning); virtual voidsetBinFast(Int_t ibin, const RooAbsBinning& binning); voidTObject::SetBit(U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsRealLValue.html:26556,cache,cache,26556,root/html602/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsRealLValue.html,2,['cache'],['cache']
Performance,"m& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual voidrandomize(const RooAbsBinning& binning); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); virtual voidsetBin(Int_t ibin, const RooAbsBinning& binning); virtual voidsetBinFast(Int_t ibin, const RooAbsBinning& binning); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetConstant(Bool_t val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsRealLValue.html:24618,cache,cache,24618,root/html526/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsRealLValue.html,2,['cache'],['cache']
Performance,"m& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual voidrandomize(const RooAbsBinning& binning); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); virtual voidsetBin(Int_t ibin, const RooAbsBinning& binning); virtual voidsetBinFast(Int_t ibin, const RooAbsBinning& binning); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetConsta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsRealLValue.html:25188,cache,cache,25188,root/html532/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html532/RooAbsRealLValue.html,1,['cache'],['cache']
Performance,"m& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual voidrandomize(const RooAbsBinning& binning); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); virtual voidsetBin(Int_t ibin, const RooAbsBinning& binning); virtual voidsetBinFast(Int_t ibin, const RooAbsBinning& binning); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidset",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsRealLValue.html:26534,cache,cache,26534,root/html534/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsRealLValue.html,1,['cache'],['cache']
Performance,"m& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual voidrandomize(const RooAbsBinning& binning); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); virtual voidsetBin(Int_t ibin, const RooAbsBinning& binning); virtual voidsetBinFast(Int_t ibin, const RooAbsBinning& binning); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetConstant(Bool_t value = kTRUE); virtual Bool_tRooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsRealLValue.html:25105,cache,cache,25105,root/html530/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html530/RooAbsRealLValue.html,1,['cache'],['cache']
Performance,"m(const RooComplex& z, Int_t nOrder); static Double_tITPComplexErrFuncRe(const RooComplex& z, Int_t nOrder); RooMath&operator=(const RooMath&); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static const char*cacheFileName(); static voidinitFastCERF(Int_t reBins = 800, Double_t reMin = -4.0, Double_t reMax = 4.0, Int_t imBins = 1000, Double_t imMin = -4.0, Double_t imMax = 6.0); static Bool_tloadCache(); static voidstoreCache(). Data Members; private:. static Bool_t_cacheTableSwitch activating use of file cache for CERF-LUT; static Int_t_imBinsNumber of grid points in imaginary dimension of CERF-LUT ; static double**_imCerfArrayLookup table for Im part of complex error function; static Double_t_imMaxHigh edge of imaginary dimension of CERF-LUT; static Double_t_imMinLow edge of imaginary dimension of CERF-LUT; static Double_t_imRangeRange in imaginary dimension of CERF-LUT; static Double_t_imStepGrid spacing in imaginary dimension of CERF-LUT; static Int_t_reBinsNumber of grid points in real dimension of CERF-LUT; static double**_reCerfArrayLookup table for Re part of complex error function; static Double_t_reMaxHigh edge of real dimension of CERF-LUT; static Double_t_reMinLow edge of real dimension of CERF-LUT; static Double_t_reRangeRange in real dimension of CERF-LUT; static Double_t_reStepGrid spacing in real dimension of CERF-LUT. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooComplex FastComplexErrFunc(const RooComplex& z). Double_t FastComplexErrFuncRe(const RooComplex& z). Double_t FastComplexErrFuncIm(const RooComplex& z). void cacheCERF(Bool_t flag = kTRUE). RooComplex ComplexErrFunc(Double_t re, Double_t im = 0); Return CERNlib complex error function for Z(re,im). RooComplex ComplexErrFunc(const RooComplex& z); Return CERNlib complex error function. This code is translated from the fortran version in the CERN mathlib.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMath.html:1694,cache,cache,1694,root/html526/RooMath.html,https://root.cern,https://root.cern/root/html526/RooMath.html,1,['cache'],['cache']
Performance,"m(const char* columname); Return minimum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the minimum; is computed for the entries in this list. TVirtualTreePlayer* GetPlayer(); Load the TTreePlayer (if not already done). TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occured while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:98072,Load,LoadBaskets,98072,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['Load'],['LoadBaskets']
Performance,"m(const char* columname); Return minimum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the minimum; is computed for the entries in this list. TVirtualTreePlayer* GetPlayer(); Load the TTreePlayer (if not already done). TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:100076,Load,LoadBaskets,100076,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['Load'],['LoadBaskets']
Performance,"m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ Fisher ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : Fisher discriminants select events by distinguishing the mean ; : values of the signal and background distributions in a trans- ; : formed variable space where linear correlations are removed.; : ; : (More precisely: the ""linear discriminator"" determines; : an axis in the (correlated) hyperspace of the input ; : variables such that, when projecting the output classes ; : (signal and background) upon this axis, they are pushed ; : as far as possible away from each other, while events; : of a same class are confined in a close vicinity. The ; : linearity property of this classifier is reflected in the ; : metric with which ""far apart"" and ""close vicinity"" are ; : determined: the covariance matrix of the discriminating; : variable space.); : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Optimal performance for Fisher discriminants is obtained for ; : linearly correlated Gaussian-distributed variables. Any deviation; : from this ideal reduces the achievable separation power. In ; : particular, no discrimination at all is achieved for a variable; : that has the same sample mean for signal and background, even if ; : the shapes of the distributions are very different. Thus, Fisher ; : discriminants often benefit from suitable transformations of the ; : input variables. For example, if a variable x in [-1,1] has a ; : a parabolic signal distributions, and a uniform background; : distributions, their mean value is zero in both cases, leading ; : to no separation. The simple transformation x -> |x| renders this ; : variable powerful for the use in a Fisher discriminant.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : <None>; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; Fisher",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:19430,Perform,Performance,19430,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,4,"['Perform', 'perform']","['Performance', 'performance']"
Performance,"mEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; Bool_tok() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormulaVar.html:20398,optimiz,optimizeCacheMode,20398,root/html534/RooFormulaVar.html,https://root.cern,https://root.cern/root/html534/RooFormulaVar.html,1,['optimiz'],['optimizeCacheMode']
Performance,"mEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction1Binding<double,double>&operator=(const RooCFunction1Binding<double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1Binding_double_double_.html:19766,optimiz,optimizeCacheMode,19766,root/html602/RooCFunction1Binding_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1Binding_double_double_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"mEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::HistFactory::LinInterpVar&operator=(const RooStats::HistFactory::LinInterpVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__LinInterpVar.html:19741,optimiz,optimizeCacheMode,19741,root/html602/RooStats__HistFactory__LinInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__LinInterpVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"mFit *p,; int size);; This function fits the source spectrum. The calling program should fill in the input parameters of the one_dim_fit structure. The fitted parameters are written into structure pointed by one_dim_fit structure pointer and fitted data are written into source spectrum.; Function parameters:. source: pointer to the vector of the source spectrum; p: pointer to the one_dim_fit structure pointer; size: length of the source spectrum. The one_dim_fit structure has the form of; class TSpectrumOneDimFit{. public:. int number_of_peaks; // input parameter, should be >0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel; int xmax; // last fitted channel; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns the resulting chi-square; int statistic_type; // type of statistics, possible values are:; // FIT1_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT1_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:39773,optimiz,optimization,39773,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,1,['optimiz'],['optimization']
Performance,"mInfo_t *info) constReturns ram and swap memory usage info into the MemInfo_t structure.Definition TSystem.cxx:2479; TSystem::GetAclicModevirtual EAclicMode GetAclicMode() constAclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:3947; TSystem::GetLinkedLibrariesvirtual const char * GetLinkedLibraries()Get list of shared libraries loaded at the start of the executable.Definition TSystem.cxx:2120; TSystem::SetIncludePathvirtual void SetIncludePath(const char *includePath)IncludePath should contain the list of compiler flags to indicate where to find user defined header f...Definition TSystem.cxx:4194; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExtDefinition TSystem.h:314; TSystem::fLinkdefSuffixTString fLinkdefSuffixDefinition TSystem.h:318; TSystem::fBeepFreqInt_t fBeepFreqDefinition TSystem.h:287; TSystem::GetCpuInfovirtual int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) constReturns cpu load average and load info into the CpuInfo_t structure.Definition TSystem.cxx:2469; TSystem::EAclicPropertiesEAclicPropertiesDefinition TSystem.h:270; TSystem::kFlatBuildDir@ kFlatBuildDirDefinition TSystem.h:271; TSystem::GetListOfFileHandlersvirtual TSeqCollection * GetListOfFileHandlers() constDefinition TSystem.h:382; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:48593,Load,Loadvirtual,48593,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,3,['Load'],"['Load', 'Loadvirtual']"
Performance,"mInfo_t *info) constReturns ram and swap memory usage info into the MemInfo_t structure.Definition TSystem.cxx:2479; TSystem::GetAclicModevirtual EAclicMode GetAclicMode() constAclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:3947; TSystem::GetLinkedLibrariesvirtual const char * GetLinkedLibraries()Get list of shared libraries loaded at the start of the executable.Definition TSystem.cxx:2120; TSystem::SetIncludePathvirtual void SetIncludePath(const char *includePath)IncludePath should contain the list of compiler flags to indicate where to find user defined header f...Definition TSystem.cxx:4194; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExtDefinition TSystem.h:314; TSystem::fLinkdefSuffixTString fLinkdefSuffixDefinition TSystem.h:318; TSystem::fBeepFreqInt_t fBeepFreqDefinition TSystem.h:287; TSystem::GetCpuInfovirtual int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) constReturns cpu load average and load info into the CpuInfo_t structure.Definition TSystem.cxx:2469; TSystem::kFlatBuildDir@ kFlatBuildDirDefinition TSystem.h:271; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:180427,Load,Loadvirtual,180427,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,3,['Load'],"['Load', 'Loadvirtual']"
Performance,"mInt = std::unique_ptr<RooAbsReal>{createIntegral(depList,*getIntegratorConfig(),nr)}.release();; 541 }; 542 static_cast<RooRealIntegral*>(normInt)->setAllowComponentSelection(false);; 543 normInt->getVal() ;; 544// cout << ""resulting normInt = "" << normInt->GetName() << endl ;; 545 ; 546 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 547 if (cacheParamsStr && strlen(cacheParamsStr)) {; 548 ; 549 std::unique_ptr<RooArgSet> intParams{normInt->getVariables()} ;; 550 ; 551 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 552 ; 553 if (!cacheParams.empty()) {; 554 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 555 << ""-dim value cache for integral over "" << depList << "" as a function of "" << cacheParams << "" in range "" << (nr?nr:""<default>"") << endl ;; 556 string name = Form(""%s_CACHE_[%s]"",normInt->GetName(),cacheParams.contentsString().c_str()) ;; 557 RooCachedReal* cachedIntegral = new RooCachedReal(name.c_str(),name.c_str(),*normInt,cacheParams) ;; 558 cachedIntegral->setInterpolationOrder(2) ;; 559 cachedIntegral->addOwnedComponents(*normInt) ;; 560 cachedIntegral->setCacheSource(true) ;; 561 if (normInt->operMode()==ADirty) {; 562 cachedIntegral->setOperMode(ADirty) ;; 563 }; 564 normInt= cachedIntegral ;; 565 }; 566 ; 567 }; 568 _norm = normInt ;; 569 }; 570 ; 571 // Register new normalization with manager (takes ownership); 572 cache = new CacheElem(*_norm) ;; 573 _normMgr.setObj(nset,cache) ;; 574 ; 575// cout << ""making new object "" << _norm->GetName() << endl ;; 576 ; 577 return true ;; 578}; 579 ; 580 ; 581 ; 582////////////////////////////////////////////////////////////////////////////////; 583/// Reset error counter to given value, limiting the number; 584/// of future error messages for this pdf to 'resetValue'; 585 ; 586void RooAbsPdf::resetErrorCounters(Int_t resetValue); 587{; 588 _errorCount = resetValue ;; 589 _negCount = resetValue ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:21747,cache,cachedIntegral,21747,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cachedIntegral']
Performance,"mIntCatVars() const; const RooArgSet&numIntRealVars() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealIntegral.html:18184,optimiz,optimizeCacheMode,18184,root/html530/RooRealIntegral.html,https://root.cern,https://root.cern/root/html530/RooRealIntegral.html,2,['optimiz'],['optimizeCacheMode']
Performance,"mMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooParametricStepFunction.html:40338,cache,cache,40338,root/html528/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html528/RooParametricStepFunction.html,4,['cache'],['cache']
Performance,"mMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDecay.html:46215,cache,cache,46215,root/html602/RooDecay.html,https://root.cern,https://root.cern/root/html602/RooDecay.html,2,['cache'],['cache']
Performance,"mOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsPdf::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsPdf::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsPdf::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; vector<RooAbsReal*>processProductTerm(const RooArgSet* nset, const RooArgSet* iset, const char* isetRangeName, const RooArgSet* term, const RooArgSet& termNSet, const RooArgSet& termISet, Bool_t& isOwned, Bool_t forceWrap = kFALSE) const; static voidRooAbsPdf::raiseEvalError(); Int_t*RooAbsPdf::randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; voidrearrangeProduct(RooProdPdf::CacheElem&) const; virtual Bool_tRooAbsPdf::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; RooAbsReal*specializeIntegral(RooAbsReal& orig, const char* targetRangeName) const; RooAbsReal*specializeRatio(RooFormulaVar& input, const char* targetRangeName) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tRooAbsPdf::syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:37195,Cache,CacheElem,37195,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,1,['Cache'],['CacheElem']
Performance,"mOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsPdf::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsPdf::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsPdf::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; vector<RooAbsReal*>processProductTerm(const RooArgSet* nset, const RooArgSet* iset, const char* isetRangeName, const RooArgSet* term, const RooArgSet& termNSet, const RooArgSet& termISet, Bool_t& isOwned, Bool_t forceWrap = kFALSE) const; static voidRooAbsPdf::raiseEvalError(); Int_t*RooAbsPdf::randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; voidrearrangeProduct(RooProdPdf::CacheElem&) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; RooAbsReal*specializeIntegral(RooAbsReal& orig, const char* targetRangeName) const; RooAbsReal*specializeRatio(RooFormulaVar& input, const char* targetRangeName) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tRooAbsPdf::syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProdPdf.html:37556,Cache,CacheElem,37556,root/html530/RooProdPdf.html,https://root.cern,https://root.cern/root/html530/RooProdPdf.html,2,['Cache'],['CacheElem']
Performance,"mRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction1PdfBinding_double_int_.html:42674,cache,cache,42674,root/html534/RooCFunction1PdfBinding_double_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction1PdfBinding_double_int_.html,1,['cache'],['cache']
Performance,"mRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; TString_sigCatNameName of accept state of accept/reject category; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooEfficiency.html:40184,cache,cache,40184,root/html530/RooEfficiency.html,https://root.cern,https://root.cern/root/html530/RooEfficiency.html,2,['cache'],['cache']
Performance,"mSetCache*_nsetCache! Normalization/Integration set manager; vector<double,allocator<double> >**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0). Int_t setObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Setter function without integration set. return setObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0). void reset(). void sterilize(). Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. T* getObjByIndex(Int_t index) const. const RooNameSet* nameSet1ByIndex(Int_t index) const. const RooNameSet* nameSet2ByIndex(Int_t index) const. void insertObjectHook(vector<double,allocator<double> >& ); Interface function to perform post-insert operations on cached object. template <> void RooCacheManager<RooAbsCacheElement> ShowMembers(TMemberInspector& insp, char* parent); needed to avoid 'specialization after instantiation' problem in gcc. » Last changed: Mon Dec 7 13:47:00 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCacheManager_vector_double___.html:4493,cache,cache,4493,root/html526/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html526/RooCacheManager_vector_double___.html,4,"['cache', 'perform']","['cache', 'cached', 'perform']"
Performance,"mStat manager. void Close(); Close - a static function; This method stops the manager,; flashes all the buffered data and closes the output tree. void SetBufferSize(Int_t buffersize); Set the maximum number of alloc/free calls to be buffered.; if the alloc and free are in the buffer, the corresponding entries; are not saved tio the Tree, reducing considerably the Tree output size. void SetMaxCalls(Int_t maxcalls); Set the maximum number of new/delete registered in the output Tree. void Enable(); Enable memory hooks. void Disable(); Disble memory hooks. void MacAllocHook(void* ptr, size_t size); AllocHook - a static function; a special memory hook for Mac OS X memory zones.; Triggered when memory is allocated. void MacFreeHook(void* ptr); AllocHook - a static function; a special memory hook for Mac OS X memory zones.; Triggered when memory is deallocated. void * AllocHook(size_t size, const void* ); AllocHook - a static function; A glibc memory allocation hook. void FreeHook(void* ptr, const void* ); FreeHook - a static function; A glibc memory deallocation hook. Int_t generateBTID(UChar_t* CRCdigest, Int_t stackEntries, void** stackPointers); An internal function, which returns a bitid for a corresponding CRC digest; cache variables. void AddPointer(void* ptr, Int_t size); Add pointer to table.; This method is called every time when any of the hooks are triggered.; The memory de-/allocation information will is recorded. void FillTree(); loop on all entries in the buffer and fill the output Tree; entries with alloc and free in the buffer are eliminated. TMemStatMng(). void SetUseGNUBuiltinBacktrace(Bool_t newVal); stack data members. » Author: Anar Manafov (A.Manafov@gsi.de) 2008-03-02 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/memstat:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/memstat__TMemStatMng.html:8471,cache,cache,8471,root/html534/memstat__TMemStatMng.html,https://root.cern,https://root.cern/root/html534/memstat__TMemStatMng.html,1,['cache'],['cache']
Performance,"mWSTool::SplitRule: public TNamed. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimWSTool__SplitRule.html:1288,perform,performed,1288,root/html534/RooSimWSTool__SplitRule.html,https://root.cern,https://root.cern/root/html534/RooSimWSTool__SplitRule.html,3,['perform'],['performed']
Performance,"m]);; 1038 }; 1039 Long64_t globalentry = fTreeOffset[treenum] + localentry;; 1040 return globalentry;; 1041 }; 1042 return entry;; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// Return entry corresponding to major and minor number.; 1047///; 1048/// The function returns the total number of bytes read.; 1049/// If the Tree has friend trees, the corresponding entry with; 1050/// the index values (major,minor) is read. Note that the master Tree; 1051/// and its friend may have different entry serial numbers corresponding; 1052/// to (major,minor).; 1053 ; 1054Int_t TChain::GetEntryWithIndex(Int_t major, Int_t minor); 1055{; 1056 Long64_t serial = GetEntryNumberWithIndex(major, minor);; 1057 if (serial < 0) return -1;; 1058 return GetEntry(serial);; 1059}; 1060 ; 1061////////////////////////////////////////////////////////////////////////////////; 1062/// Return a pointer to the current file.; 1063/// If no file is connected, the first file is automatically loaded.; 1064 ; 1065TFile* TChain::GetFile() const; 1066{; 1067 if (fFile) {; 1068 return fFile;; 1069 }; 1070 // Force opening the first file in the chain.; 1071 const_cast<TChain*>(this)->LoadTree(0);; 1072 return fFile;; 1073}; 1074 ; 1075////////////////////////////////////////////////////////////////////////////////; 1076/// Return a pointer to the leaf name in the current tree.; 1077 ; 1078TLeaf* TChain::GetLeaf(const char* branchname, const char *leafname); 1079{; 1080 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1081 // Make sure the element list is up to date; 1082 if (!TestBit(kProofUptodate)); 1083 SetProof(true, true);; 1084 return fProofChain->GetLeaf(branchname, leafname);; 1085 }; 1086 if (fTree) {; 1087 return fTree->GetLeaf(branchname, leafname);; 1088 }; 1089 LoadTree(0);; 1090 if (fTree) {; 1091 return fTree->GetLeaf(branchname, leafname);; 1092 }; 1093 return nullptr;; 1094}; 1095 ; 1096////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:39927,load,loaded,39927,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['loaded']
Performance,"major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediatly lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table, otherwise it returns -1. See also GetEntryNumberWithBestIndex. Long64_t* GetIndexValuesMinor() const. TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeIndex.html:11822,perform,performs,11822,root/html534/TTreeIndex.html,https://root.cern,https://root.cern/root/html534/TTreeIndex.html,3,['perform'],['performs']
Performance,"makeCoefVarList(). void RooAbsAnaConvPdf::makeCoefVarList ; (; RooArgList & ; varList); const. protected . Build complete list of coefficient variables. ; Definition at line 604 of file RooAbsAnaConvPdf.cxx. ◆ parseIntegrationRequest(). RooArgSet * RooAbsAnaConvPdf::parseIntegrationRequest ; (; const RooArgSet & ; intSet, . Int_t & ; coefCode, . RooArgSet * ; analVars = nullptr . ); const. protected . ◆ printMultiline(). void RooAbsAnaConvPdf::printMultiline ; (; std::ostream & ; stream, . Int_t ; contents, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Print info about this object to the specified stream. ; In addition to the info from RooAbsPdf::printStream() we add:; Verbose : detailed information on convolution integrals ; Reimplemented from RooPrintable.; Definition at line 645 of file RooAbsAnaConvPdf.cxx. ◆ setCacheAndTrackHints(). void RooAbsAnaConvPdf::setCacheAndTrackHints ; (; RooArgSet & ; trackNodes). overridevirtual . Label OK'ed components with cache-and-track. ; Reimplemented from RooAbsArg.; Definition at line 658 of file RooAbsAnaConvPdf.cxx. ◆ Streamer(). void RooAbsAnaConvPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in RooBCPEffDecay, RooBCPGenDecay, RooBDecay, RooBMixDecay, RooDecay, and RooNonCPEigenDecay. ◆ StreamerNVirtual(). void RooAbsAnaConvPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 120 of file RooAbsAnaConvPdf.h. Friends And Related Symbol Documentation. ◆ RooConvGenContext. friend class RooConvGenContext. friend . Definition at line 94 of file RooAbsAnaConvPdf.h. Member Data Documentation. ◆ _basisList. RooArgList RooAbsAnaConvPdf::_basisList. protected . ! List of created basis functions ; Definition at line 102 of file RooAbsAnaConvPdf.h. ◆ _codeReg. RooAICRegistry RooAbsAnaConvPdf::_codeReg. mutableprotected . ! Registry of analytical integration codes ; Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsAnaConvPdf.html:90202,cache,cache-and-track,90202,doc/master/classRooAbsAnaConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsAnaConvPdf.html,1,['cache'],['cache-and-track']
Performance,"makes a directory called MyProject that will contain all class definitions from the atlfast.root file. The necessary makefile to build a shared library are also created, and since the ‘++’ is appended, the shared library is also loaded.; root[] f.MakeProject(""MyProject"",""*"", ""recreate++""); MakeProject has generated 0 classes in MyProject; MyProject/MAKE file has been generated; Shared lib MyProject/MyProject.so has been generated; Shared lib MyProject/MyProject.so has been dynamically linked; The contents of MyProject:; root[] .! ls MyProject; ATLFCluster.h ATLFJet.h ATLFMiscMaker.h ATLFTrack.h; TMCParticle.h ATLFClusterMaker.h ATLFJetMaker.h ATLFMuon.h; ATLFElectron.h ATLFMCMaker.h ATLFMuonMaker.h ATLFElectronMaker.h; ATLFMaker.h ATLFPhoton.h ATLFHistBrowser.h ATLFMisc.h; ATLFPhotonMaker.h ATLFTrackMaker.h ATLFTrigger.h ATLFTriggerMaker.h; LinkDef.h MAKE MyProject.so MyProjectProjectDict.h; MyProjectProjectDict.cxx MyProjectProjectDict.o; Now you can load the shared library in any consecutive root session to use the atlfast classes.; root[]gSystem->Load(""MyProject/MyProject""); root[]ATLFMuon muon; This is an example of a generated header file:; //////////////////////////////////////////////////////////; // This class has been generated by TFile::MakeProject; // (Thu Apr 5 10:18:37 2001 by ROOT version 3.00/06); // from the TStreamerInfo in file atlfast.root; //////////////////////////////////////////////////////////; #ifndef ATLFMuon_h; #define ATLFMuon_h; #include ""TObject.h""; #include ""TAtt3D.h""; class ATLFMuon : public TObject , public TAtt3D {; public:; Int_t m_KFcode; //Muon KF-code; Int_t m_MCParticle; //Muon position in MCParticles list; Int_t m_KFmother; //Muon mother KF-code; Int_t m_UseFlag; //Muon energy usage flag; Int_t m_Isolated; //Muon isolation (1 for isolated); Float_t m_Eta; //Eta coordinate; Float_t m_Phi; //Phi coordinate; Float_t m_PT; //Transverse energy; Int_t m_Trigger; //Result of trigger; ATLFMuon() {;}; virtual ~ATLFMuon() {;}; ClassDef(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:511416,load,load,511416,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"malization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooSetProxy _cacheObs;  Observable to be cached. ;  ; RooRealProxy pdf;  Proxy to p.d.f being cached. ;  ;  Protected Attributes inherited from RooAbsCachedPdf; std::map< Int_t, AnaIntConfig > _anaIntMap;  ! Map for analytical integration codes ;  ; RooAICRegistry _anaReg;  ! Registry for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ; Int_t _ipOrder;  The cache manager. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:70807,cache,cache,70807,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,1,['cache'],['cache']
Performance,"malization range is different; from the reference range, the appropriate fraction coefficients; are automically calculation from the reference fractions using; ratios if integrals. RooResolutionModel* convolution(RooFormulaVar* basis, RooAbsArg* owner) const; Instantiate a clone of this resolution model representing a convolution with given; basis function. The owners object name is incorporated in the clones name; to avoid multiple convolution objects with the same name in complex PDF structures. RooAddModel will clone all the component models to create a composite convolution object. Int_t basisCode(const char* name) const; Return code for basis function representing by 'name' string.; The basis code of the first component model will be returned,; if the basis is supported by all components. Otherwise 0; is returned. void updateCoefficients(RooAddModel::CacheElem& cache, const RooArgSet* nset) const; Update the coefficient values in the given cache element: calculate new remainder; fraction, normalize fractions obtained from extended ML terms to unity and; multiply these the various range and dimensional corrections needed in the; current use context. Double_t evaluate() const; Calculate the current value. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. Bool_t checkObservables(const RooArgSet* nset) const; Check if PDF is valid for given normalization set.; Coeffient and PDF must be non-overlapping, but pdf-coefficient; pairs may overlap each other. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const. void getCompIntList(const RooArgSet* nset, const RooArgSet* iset, RooAddModel::pRooArgList& compIntList, Int_t& code, const char* isetRangeName) const; Check if this configuration was created before. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* ran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:45022,Cache,CacheElem,45022,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,21,"['Cache', 'cache']","['CacheElem', 'cache']"
Performance,"malization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooListProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooUniform.html:39943,cache,cache,39943,root/html532/RooUniform.html,https://root.cern,https://root.cern/root/html532/RooUniform.html,2,['cache'],['cache']
Performance,"malization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPEffDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPEffDecay.html:41587,cache,cache,41587,root/html532/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPEffDecay.html,1,['cache'],['cache']
Performance,"malization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for curr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBDecay.html:41435,cache,cache,41435,root/html532/RooBDecay.html,https://root.cern,https://root.cern/root/html532/RooBDecay.html,1,['cache'],['cache']
Performance,"malization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for curre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDecay.html:41119,cache,cache,41119,root/html532/RooDecay.html,https://root.cern,https://root.cern/root/html532/RooDecay.html,1,['cache'],['cache']
Performance,"malization.; If shiftToZero is set, the entire curve is shift down to make the lowest; point in of the curve go through zero. RooCurve(const char* name, const char* title, const RooAbsFunc& func, Double_t xlo, Double_t xhi, UInt_t minPoints, Double_t prec = 1e-3, Double_t resolution = 1e-3, Bool_t shiftToZero = kFALSE, RooCurve::WingMode wmode = Extended, Int_t nEvalError = -1, Int_t doEEVal = kFALSE, Double_t eeVal = 0); Create a 1-dim curve of the value of the specified real-valued; expression as a function of x. Use the optional precision; parameter to control how precisely the smooth curve is; rasterized. If shiftToZero is set, the entire curve is shift; down to make the lowest point in of the curve go through zero. RooCurve(const char* name, const char* title, const RooCurve& c1, const RooCurve& c2, Double_t scale1 = 1., Double_t scale2 = 1.); Constructor of curve as sum of two other curves. Csum = scale1*c1 + scale2*c2. ~RooCurve(); Destructor. void initialize(); Perform initialization that is common to all curves. void shiftCurveToZero(Double_t prevYMax); Find lowest point in curve and move all points in curve so that; lowest point will go exactly through zero. void addPoints(const RooAbsFunc& func, Double_t xlo, Double_t xhi, Int_t minPoints, Double_t prec, Double_t resolution, RooCurve::WingMode wmode, Int_t numee = 0, Bool_t doEEVal = kFALSE, Double_t eeVal = 0., list<Double_t>* samplingHint = 0); Add points calculated with the specified function, over the range (xlo,xhi).; Add at least minPoints equally spaced points, and add sufficient points so that; the maximum deviation from the final straight-line segements is prec*(ymax-ymin),; down to a minimum horizontal spacing of resolution*(xhi-xlo). void addRange(const RooAbsFunc& func, Double_t x1, Double_t x2, Double_t y1, Double_t y2, Double_t minDy, Double_t minDx, Int_t numee = 0, Bool_t doEEVal = kFALSE, Double_t eeVal = 0.); Fill the range (x1,x2) with points calculated using func(&x). No point will; be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCurve.html:19319,Perform,Perform,19319,root/html526/RooCurve.html,https://root.cern,https://root.cern/root/html526/RooCurve.html,5,['Perform'],['Perform']
Performance,"manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypeak; RooRealProxytail; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNovosibirsk.html:39131,cache,cache,39131,root/html528/RooNovosibirsk.html,https://root.cern,https://root.cern/root/html528/RooNovosibirsk.html,2,['cache'],['cache']
Performance,"mand=nullptr)Execute command when system has been idle for idleTimeInSec seconds.Definition TROOT.cxx:1892; TROOT::fSocketsTSeqCollection * fSocketsList of network sockets.Definition TROOT.h:148; TROOT::lsvoid ls(Option_t *option="""") const overrideTo list all objects of the application.Definition TROOT.cxx:2250; TROOT::IsEscapedBool_t IsEscaped() constDefinition TROOT.h:283; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::fFunctionsTCollection * fFunctionsList of analytic functions.Definition TROOT.h:151; TROOT::GetVersionDateInt_t GetVersionDate() constDefinition TROOT.h:226; TROOT::SaveContextvoid SaveContext()Save the current interpreter context.Definition TROOT.cxx:2671; TROOT::GetListOfClassGeneratorsTCollection * GetListOfClassGenerators() constDefinition TROOT.h:251; TROOT::IsExecutingMacroBool_t IsExecutingMacro() constDefinition TROOT.h:280; TROOT::GetTypeTDataType * GetType(const char *name, Bool_t load=kFALSE) constReturn pointer to type with name.Definition TROOT.cxx:1562; TROOT::Initializestatic void Initialize()Initialize ROOT explicitly.Definition TROOT.cxx:2899; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3136; TROOT::GetFunctionTObject * GetFunction(const char *name) constReturn pointer to function with name.Definition TROOT.cxx:1587; TROOT::ConvertVersionCode2Intstatic Int_t ConvertVersionCode2Int(Int_t code)Convert version code to an integer, i.e. 331527 -> 51507.Definition TROOT.cxx:2922; TROOT::fMessageHandlersTSeqCollection * fMessageHandlersList of message handlers.Definition TROOT.h:158; TROOT::SetStylevoid SetStyle(const char *stylename=""Default"")Change current style to style with name stylename.Definition TROOT.cxx:2730; TROOT::GetListOfMappedFilesTSeqCollection * GetListOfMappedFiles() constDefinition TROOT.h:238; TROOT::SetEditHistogramsvoid SetEditHistograms(Bool_t flag=kTRUE)Definition TROOT.h:322; TROOT::fEnumsAListOfEnums_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:30901,load,load,30901,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['load'],['load']
Performance,"mand=nullptr)Execute command when system has been idle for idleTimeInSec seconds.Definition TROOT.cxx:1892; TROOT::fSocketsTSeqCollection * fSocketsList of network sockets.Definition TROOT.h:148; TROOT::lsvoid ls(Option_t *option="""") const overrideTo list all objects of the application.Definition TROOT.cxx:2250; TROOT::IsEscapedBool_t IsEscaped() constDefinition TROOT.h:283; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::fFunctionsTCollection * fFunctionsList of analytic functions.Definition TROOT.h:151; TROOT::GetVersionDateInt_t GetVersionDate() constDefinition TROOT.h:226; TROOT::SaveContextvoid SaveContext()Save the current interpreter context.Definition TROOT.cxx:2671; TROOT::GetListOfClassGeneratorsTCollection * GetListOfClassGenerators() constDefinition TROOT.h:251; TROOT::IsExecutingMacroBool_t IsExecutingMacro() constDefinition TROOT.h:280; TROOT::GetTypeTDataType * GetType(const char *name, Bool_t load=kFALSE) constReturn pointer to type with name.Definition TROOT.cxx:1562; TROOT::Initializestatic void Initialize()Initialize ROOT explicitly.Definition TROOT.cxx:2903; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetFunctionTObject * GetFunction(const char *name) constReturn pointer to function with name.Definition TROOT.cxx:1587; TROOT::ConvertVersionCode2Intstatic Int_t ConvertVersionCode2Int(Int_t code)Convert version code to an integer, i.e. 331527 -> 51507.Definition TROOT.cxx:2926; TROOT::fMessageHandlersTSeqCollection * fMessageHandlersList of message handlers.Definition TROOT.h:158; TROOT::SetStylevoid SetStyle(const char *stylename=""Default"")Change current style to style with name stylename.Definition TROOT.cxx:2730; TROOT::GetListOfMappedFilesTSeqCollection * GetListOfMappedFiles() constDefinition TROOT.h:238; TROOT::SetEditHistogramsvoid SetEditHistograms(Bool_t flag=kTRUE)Definition TROOT.h:322; TROOT::fEnumsAListOfEnums_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:30900,load,load,30900,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['load'],['load']
Performance,"map< std::vector<Double_t> , Double_t> TMVA::OptimizeConfigParameters::fAlreadyTrainedParCombination. private . save parameters for which the FOM is already known (GA seems to evaluate the same parameters several times) ; Definition at line 86 of file OptimizeConfigParameters.h. ◆ fFOMType. TString TMVA::OptimizeConfigParameters::fFOMType. private . the FOM type (Separation, ROC integra.. whatever you implemented.. ; Definition at line 87 of file OptimizeConfigParameters.h. ◆ fFOMvsIter. std::vector<Float_t> TMVA::OptimizeConfigParameters::fFOMvsIter. private . graph showing the development of the Figure Of Merit values during the fit ; Definition at line 83 of file OptimizeConfigParameters.h. ◆ fLogger. MsgLogger* TMVA::OptimizeConfigParameters::fLogger. mutableprivate . ! message logger ; Definition at line 97 of file OptimizeConfigParameters.h. ◆ fMethod. MethodBase* const TMVA::OptimizeConfigParameters::fMethod. private . The MVA method to be evaluated. ; Definition at line 82 of file OptimizeConfigParameters.h. ◆ fMvaBkg. TH1D* TMVA::OptimizeConfigParameters::fMvaBkg. private . MVA distribution for bakgr. events, used for spline fit. ; Definition at line 90 of file OptimizeConfigParameters.h. ◆ fMvaBkgFineBin. TH1D* TMVA::OptimizeConfigParameters::fMvaBkgFineBin. private . MVA distribution for bakgr. events. ; Definition at line 93 of file OptimizeConfigParameters.h. ◆ fMvaSig. TH1D* TMVA::OptimizeConfigParameters::fMvaSig. private . MVA distribution for signal events, used for spline fit. ; Definition at line 89 of file OptimizeConfigParameters.h. ◆ fMvaSigFineBin. TH1D* TMVA::OptimizeConfigParameters::fMvaSigFineBin. private . MVA distribution for signal events. ; Definition at line 92 of file OptimizeConfigParameters.h. ◆ fNotDoneYet. Bool_t TMVA::OptimizeConfigParameters::fNotDoneYet. private . flat to indicate of Method Transformations have been obtained yet or not (normally done in MethodBase::TrainMethod) ; Definition at line 95 of file OptimizeConfigPar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:11178,Optimiz,OptimizeConfigParameters,11178,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance,"mapLoadPath = ldpath;; 5767#ifdef WIN32; 5768 TObjArray* paths = ldpath.Tokenize("";"");; 5769#else; 5770 TObjArray* paths = ldpath.Tokenize("":"");; 5771#endif; 5772 TString d;; 5773 for (Int_t i = 0; i < paths->GetEntriesFast(); i++) {; 5774 d = ((TObjString *)paths->At(i))->GetString();; 5775 // check if directory already scanned; 5776 Int_t skip = 0;; 5777 for (Int_t j = 0; j < i; j++) {; 5778 TString pd = ((TObjString *)paths->At(j))->GetString();; 5779 if (pd == d) {; 5780 skip++;; 5781 break;; 5782 }; 5783 }; 5784 if (!skip) {; 5785 void* dirp = gSystem->OpenDirectory(d);; 5786 if (dirp) {; 5787 if (gDebug > 3) {; 5788 Info(""LoadLibraryMap"", ""%s"", d.Data());; 5789 }; 5790 const char* f1;; 5791 while ((f1 = gSystem->GetDirEntry(dirp))) {; 5792 TString f = f1;; 5793 if (f.EndsWith("".rootmap"")) {; 5794 TString p;; 5795 p = d + ""/"" + f;; 5796 if (!gSystem->AccessPathName(p, kReadPermission)) {; 5797 if (!fRootmapFiles->FindObject(f) && f != "".rootmap"") {; 5798 if (gDebug > 4) {; 5799 Info(""LoadLibraryMap"", "" rootmap file: %s"", p.Data());; 5800 }; 5801 Int_t ret = ReadRootmapFile(p, &uniqueString);; 5802 ; 5803 if (ret == 0); 5804 fRootmapFiles->Add(new TNamed(gSystem->BaseName(f), p.Data()));; 5805 if (ret == -3) {; 5806 // old format; 5807 fMapfile->ReadFile(p, kEnvGlobal);; 5808 fRootmapFiles->Add(new TNamed(f, p));; 5809 }; 5810 }; 5811 // else {; 5812 // fprintf(stderr,""Reject %s because %s is already there\n"",p.Data(),f.Data());; 5813 // fRootmapFiles->FindObject(f)->ls();; 5814 // }; 5815 }; 5816 }; 5817 if (f.BeginsWith(""rootmap"")) {; 5818 TString p;; 5819 p = d + ""/"" + f;; 5820 FileStat_t stat;; 5821 if (gSystem->GetPathInfo(p, stat) == 0 && R_ISREG(stat.fMode)) {; 5822 Warning(""LoadLibraryMap"", ""please rename %s to end with \"".rootmap\"""", p.Data());; 5823 }; 5824 }; 5825 }; 5826 }; 5827 gSystem->FreeDirectory(dirp);; 5828 }; 5829 }; 5830 delete paths;; 5831 if (fMapfile->GetTable() && !fMapfile->GetTable()->GetEntries()) {; 5832 return -1;; 5833 }; 5834 }; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:225755,Load,LoadLibraryMap,225755,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadLibraryMap']
Performance,"master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf204b_extendedLikelihood_rangedFit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf->fitTo(data,Range(""Range1,Range2"")), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same model parameter results in a number that is not easily interpreted.; If both regions correct their inte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html:1014,perform,performed,1014,doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,1,['perform'],['performed']
Performance,"mat on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other value is; 512 /// used as a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods automatically take advantage of; 516 /// multi-threading if a call to `EnableImplicitMT` has been made before usage:; 517 ///; 518 /// - RDataFrame internally runs the event-loop by parallelizing over clusters of entries; 519 /// - TTree::GetEntry reads multiple branches in parallel; 520 /// - TTree::FlushBaskets writes multiple baskets to disk in parallel; 521 /// - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; 522 /// - THx::Fit performs in parallel the evaluation of the objective function over the data; 523 /// - TMVA::DNN trains the deep neural networks in parallel; 524 /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; 525 ///; 526 /// EnableImplicitMT calls in turn EnableThreadSafety.; 527 /// The 'numthreads' parameter allows to control the number of threads to; 528 /// be used by the implicit multi-threading. However, this parameter is just; 529 /// a hint for ROOT: it will try to satisfy the request if the execution; 530 /// scenario allows it. For example, if ROOT is configured to use an external; 531 /// scheduler, setting a value for 'numthreads' might not have any effect.; 532 /// The maximum number of threads can be influenced by the environment; 533 /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; 534 /// the maximum number ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:18860,multi-thread,multi-threading,18860,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,4,"['multi-thread', 'perform']","['multi-threading', 'performs']"
Performance,"mat->GetByteCount();; 2904 TIter next3(fMedia);; 2905 TGeoMedium *med;; 2906 while ((med = (TGeoMedium *)next3())); 2907 count += med->GetByteCount();; 2908 if (fgVerboseLevel > 0); 2909 Info(""GetByteCount"", ""Total size of logical tree : %i bytes"", count);; 2910 return count;; 2911}; 2912 ; 2913////////////////////////////////////////////////////////////////////////////////; 2914/// Make a default painter if none present. Returns pointer to it.; 2915 ; 2916TVirtualGeoPainter *TGeoManager::GetGeomPainter(); 2917{; 2918 if (!fPainter) {; 2919 const char *kind = gEnv->GetValue(""GeomPainter.Name"", """");; 2920 if (!kind || !*kind); 2921 kind = (gROOT->IsWebDisplay() && !gROOT->IsWebDisplayBatch()) ? ""web"" : ""root"";; 2922 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualGeoPainter"", kind)) {; 2923 if (h->LoadPlugin() == -1) {; 2924 Error(""GetGeomPainter"", ""could not load plugin for %s geo_painter"", kind);; 2925 return nullptr;; 2926 }; 2927 fPainter = (TVirtualGeoPainter *)h->ExecPlugin(1, this);; 2928 if (!fPainter) {; 2929 Error(""GetGeomPainter"", ""could not create %s geo_painter"", kind);; 2930 return nullptr;; 2931 }; 2932 } else {; 2933 Error(""GetGeomPainter"", ""not found plugin %s for geo_painter"", kind);; 2934 }; 2935 }; 2936 return fPainter;; 2937}; 2938 ; 2939////////////////////////////////////////////////////////////////////////////////; 2940/// Search for a named volume. All trailing blanks stripped.; 2941 ; 2942TGeoVolume *TGeoManager::GetVolume(const char *name) const; 2943{; 2944 TString sname = name;; 2945 sname = sname.Strip();; 2946 TGeoVolume *vol = (TGeoVolume *)fVolumes->FindObject(sname.Data());; 2947 return vol;; 2948}; 2949 ; 2950////////////////////////////////////////////////////////////////////////////////; 2951/// Fast search for a named volume. All trailing blanks stripped.; 2952 ; 2953TGeoVolume *TGeoManager::FindVolumeFast(const char *name, Bool_t multi); 2954{; 2955 if (!fHashVolumes) {; 2956 Int_t nvol = fVolumes->GetEntriesFast();;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:105322,Load,LoadPlugin,105322,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,2,"['Load', 'load']","['LoadPlugin', 'load']"
Performance,"matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; const RooArgSet*_nset! Normalization set to be used in evaluation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfProbability Density function; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooEffProd.html:42275,cache,cache,42275,root/html534/RooEffProd.html,https://root.cern,https://root.cern/root/html534/RooEffProd.html,1,['cache'],['cache']
Performance,"matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; const RooArgSet*_nset! Normalization set to be used in evaluation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfProbability Density function; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooEffProd.html:43943,cache,cache,43943,root/html602/RooEffProd.html,https://root.cern,https://root.cern/root/html602/RooEffProd.html,2,['cache'],['cache']
Performance,"mated size of a cluster size for the TTree. The TTreeCache prefilling is also enabled by default; when in learning phase rather than reading each requested branch individually, the TTreeCache will read all the branches thus trading off the latencies inherent to multiple small reads for the potential of requesting more data than needed by read from the disk or server the baskets for too many branches.; The default behavior can be changed by either updating one of the rootrc files or by setting environment variables. The rootrc files, both the global and the local ones, now support the following the resource variable TTreeCache.Size which set the default size factor for auto sizing TTreeCache for TTrees. The estimated cluster size for the TTree and this factor is used to give the cache size. If option is set to zero auto cache creation is disabled and the default cache size is the historical one (equivalent to factor 1.0). If set to non zero auto cache creation is enabled and both auto created and default sized caches will use the configured factor: 0.0 no automatic cache and greater than 0.0 to enable cache. This value can be overridden by the environment variable ROOT_TTREECACHE_SIZE.; The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling type. The prefill type may be: 0 for no prefilling and 1 to prefill all the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL; In particular the default can be set back to the same as in version 5 by setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill (or ROOT_TTREECACHE_PREFILL) both to zero.; TTree methods which are expected to modify a cache, like AddBranchToCache, will attempt to setup a cache of default size if one does not exist, irrespective of whether the auto cache creation is enabled. Additionally several methods giving control of the cache have changed return type from void to Int_t, to be able to return a code to indicate if there was an err",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:12855,cache,cache,12855,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,2,['cache'],"['cache', 'caches']"
Performance,"matrix If the variable is fixed or const the values for that variables are zero. ;  ; bool GetMinosError (unsigned int i, double &errLow, double &errUp, int=0) override;  get the minos error for parameter i, return false if Minos failed A minimizaiton must be performed befre, return false if no minimization has been done In case of Minos failed the status error is updated as following status += 10 * minosStatus. ;  ; bool GetVariableSettings (unsigned int ivar, ROOT::Fit::ParameterSettings &varObj) const override;  get variable settings in a variable object (like ROOT::Fit::ParamsSettings) ;  ; double GlobalCC (unsigned int i) const override;  get global correlation coefficient for the variable i. ;  ; bool Hesse () override;  perform a full calculation of the Hessian matrix for error calculation If a valid minimum exists the calculation is done on the minimum point otherwise is performed in the current set values of parameters Status code of minimizer is updated according to the following convention (in case Hesse failed) status += 100*hesseStatus where hesse status is: status = 1 : hesse failed status = 2 : matrix inversion failed status = 3 : matrix is not pos defined ;  ; bool IsFixedVariable (unsigned int ivar) const override;  query if an existing variable is fixed (i.e. ;  ; const double * MinGradient () const override;  return pointer to gradient values at the minimum ;  ; bool Minimize () override;  method to perform the minimization. ;  ; int MinosStatus () const override;  MINOS status code of last Minos run status & 1 > 0 : invalid lower error status & 2 > 0 : invalid upper error status & 4 > 0 : invalid because maximum number of function calls exceeded status & 8 > 0 : a new minimum has been found status & 16 > 0 : error is truncated because parameter is at lower/upper limit. ;  ; double MinValue () const override;  return minimum function value ;  ; unsigned int NCalls () const override;  number of function calls to reach the minimum ;  ; unsigned int N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html:3472,perform,perform,3472,doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,2,['perform'],"['perform', 'performed']"
Performance,"max = 9999999, Option_t* option = """")MENU ; virtual voidTNamed::ls(Option_t* option = """") const; static TGeoVolumeAssembly*MakeAssemblyFromVolume(TGeoVolume* vol); voidTGeoVolume::MakeCopyNodes(const TGeoVolume* other); virtual TGeoVolume*TGeoVolume::MakeCopyVolume(TGeoShape* newshape); TGeoVolume*TGeoVolume::MakeReflectedVolume(const char* newname = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tTGeoVolume::OptimizeVoxels()MENU ; virtual voidTGeoVolume::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTGeoVolume::Print(Option_t* option = """") constMENU ; voidTGeoVolume::PrintNodes() const; voidTGeoVolume::PrintVoxels() constMENU ; voidTGeoVolume::RandomPoints(Int_t npoints = 1000000, Option_t* option = """")MENU ; voidTGeoVolume::RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0, const char* target_vol = 0, Bool_t check_norm = kFALSE)MENU ; voidTGeoVolume::Raytrace(Bool_t flag = kTRUE)TOGGLE GETTER ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTGeoVolume::RegisterYourself(Option_t* option = """"); voidTGeoVolume::Release(); voidTGeoVolume::RemoveNode(TGeoNode* node); TGeoNode*TGeoVolume::ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidTGeoVolume::ReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeAssembly.html:25904,Optimiz,OptimizeVoxels,25904,root/html534/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeAssembly.html,1,['Optimiz'],['OptimizeVoxels']
Performance,"max = 9999999, Option_t* option = """")MENU ; virtual voidTNamed::ls(Option_t* option = """") const; static TGeoVolumeAssembly*MakeAssemblyFromVolume(TGeoVolume* vol); voidTGeoVolume::MakeCopyNodes(const TGeoVolume* other); virtual TGeoVolume*TGeoVolume::MakeCopyVolume(TGeoShape* newshape); TGeoVolume*TGeoVolume::MakeReflectedVolume(const char* newname = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tTGeoVolume::OptimizeVoxels()MENU ; virtual voidTGeoVolume::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; voidTGeoVolume::PrintNodes() const; voidTGeoVolume::PrintVoxels() constMENU ; voidTGeoVolume::RandomPoints(Int_t npoints = 1000000, Option_t* option = """")MENU ; voidTGeoVolume::RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0)MENU ; voidTGeoVolume::Raytrace(Bool_t flag = kTRUE)TOGGLE GETTER ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTGeoVolume::RegisterYourself(Option_t* option = """"); voidTGeoVolume::RemoveNode(TGeoNode* node); TGeoNode*TGeoVolume::ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidTGeoVolume::ReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAtt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoVolumeAssembly.html:16188,Optimiz,OptimizeVoxels,16188,root/html530/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html530/TGeoVolumeAssembly.html,2,['Optimiz'],['OptimizeVoxels']
Performance,"maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::GetEstimatevirtual Long64_t GetEstimate() constDefinition TTree.h:507; TTree::GetDebugMaxLong64_t GetDebugMax() constDefinition TTree.h:460; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t GetMedianClusterSize()Estimate the median cluster size for the TTree.Definition TTree.cxx:8297; TTree::GetClusterIteratorvirtual TClusterIterator GetClusterIterator(Long64_t firstentry)Return an iterator over the cluster of baskets starting at firstentry.Definition TTree.cxx:5467; TTree::ResetBranchAddressvirtual void ResetBranchAddress(TBranch *)Tell all of our branches to set their addresses to zero.Definition TTree.cxx:8065; TTree::fCacheUserSetbool fCacheUserSet! true if the cache setting was explicitly given by userDefinition TTree.h:141; TTree::GetNewlineValuechar GetNewlineValue(std::istream &inputStream)Determine which newline this file is using.Definition TTree.cxx:7588; TTree::BranchTBranch * Branch(const char *name, T **addobj, Int_t bufsize=32000, Int_t splitlevel=99)Add a new branch, and infer the data type from the array addobj being passed.Definition TTree.h:370; TTree::fIOFeaturesTIOFeatures fIOFeaturesIO features to define for newly-written baskets and branches.Definition TTree.h:114; TTree::GetSelectedRowsvirtual Long64_t GetSelectedRows()Definition TTree.h:553; TTree::AddAllocationCountvoid AddAllocationCount(UInt_t count)Definition TTree.h:337; TTree::SetMaxEntryLoopvirtual void SetMaxEntryLoop(Long64_t maxev=kMaxEntries)Definition TTree.h:663; TTree::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor=0) constReturn entry number corresponding to major and minor number.Definition TTree.cxx:5910; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:57533,cache,cache,57533,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['cache'],['cache']
Performance,"maximum number of nodes allwed in the tree splitting, then it stops.; MaxDepth maximum depth of the decision tree allowed before further splitting is stopped. void DeclareCompatibilityOptions(). void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the BDT-Method. void Reset( void ); reset the method, as if it had just been instantiated (forget all training etc.). ~MethodBDT( void ); destructor. void InitEventSample( void ); Write all Events from the Tree into a vector of Events, that are; more easily manipulated. This method should never be called without; existing trainingTree, as it the vector of events from the ROOT training tree. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument. void Train(); BDT training. void GetRandomSubSample(); fills fEventSample with fSampleFraction*NEvents random training events. Double_t GetGradBoostMVA(TMVA::Event& e, UInt_t nTrees); returns MVA value: -1 for background, 1 for signal. void UpdateTargets(vector<TMVA::Event*> , UInt_t cls = 0); Calculate residua for all events;. void UpdateTargetsRegression(vector<TMVA::Event*> , Bool_t first = kFALSE); Calculate current residuals for all events and update targets for next iteration. Double_t GetWeightedQuantile(vector<std::pair<Double_t,Double_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.0); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<TMVA::Event*> , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<TMVA::Event*> , TMVA::Dec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBDT.html:27463,tune,tuneParameters,27463,root/html528/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html,1,['tune'],['tuneParameters']
Performance,"may need to be forwarded to such cache payload. This cache manager takes care of all these operations by forwarding these calls to the RooAbsCacheElement interface functions, which have a sensible default implementation. ; Definition at line 29 of file RooObjCacheManager.h. Public Member Functions;  RooObjCacheManager (const RooObjCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooObjCacheManager (RooAbsArg *owner=nullptr, Int_t maxSize=2, bool clearCacheOnServerRedirect=true, bool allowOptimize=false);  Constructor of object cache manager for given owner. ;  ;  ~RooObjCacheManager () override;  Destructor. ;  ; void findConstantNodes (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  If clearOnRedirect is false, forward constant term optimization calls to cache elements. ;  ; void insertObjectHook (RooAbsCacheElement &) override;  Set owner link on all object inserted into cache. ;  ; TClass * IsA () const override;  ; void operModeHook () override;  Intercept changes to cache operation mode and forward to cache elements. ;  ; void optimizeCacheMode (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  Intercept calls to perform automatic optimization of cache mode operation. ;  ; void printCompactTreeHook (std::ostream &, const char *) override;  Add details on cache contents when printing in tree mode. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Intercept server redirect calls. ;  ; void setClearOnRedirect (bool flag);  ; void sterilize () override;  Clear the cache payload but retain slot mapping w.r.t to normalization and integration sets. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooCacheManager< RooAbsCacheElement >;  RooCacheManager (const RooCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooCacheManager (Int_t maxSize=2);  Constructor for simple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:1651,cache,cache,1651,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,2,['cache'],['cache']
Performance,"mbda_in, . TVectorD & ; u_in, . TVectorD & ; pi_in, . TVectorD & ; ixlow_in, . TVectorD & ; ixupp_in, . TVectorD & ; iclow_in, . TVectorD & ; icupp_in . ). Constructor. ; Definition at line 75 of file TQpVar.cxx. ◆ TQpVar() [3/4]. TQpVar::TQpVar ; (; Int_t ; nx, . Int_t ; my, . Int_t ; mz, . TVectorD & ; ixlow, . TVectorD & ; ixupp, . TVectorD & ; iclow, . TVectorD & ; icupp . ). Constructor. ; Definition at line 130 of file TQpVar.cxx. ◆ TQpVar() [4/4]. TQpVar::TQpVar ; (; const TQpVar & ; another). Copy constructor. ; Definition at line 181 of file TQpVar.cxx. ◆ ~TQpVar(). TQpVar::~TQpVar ; (; ). inlineoverride . Definition at line 120 of file TQpVar.h. Member Function Documentation. ◆ FindBlocking() [1/2]. Double_t TQpVar::FindBlocking ; (; TQpVar * ; step, . Double_t & ; primalValue, . Double_t & ; primalStep, . Double_t & ; dualValue, . Double_t & ; dualStep, . Int_t & ; fIrstOrSecond . ). virtual . Performs the same function as StepBound, and supplies additional information about which component of the nonnegative variables is responsible for restricting alpha. ; In terms of the abstract formulation, the components have the following meanings :; primalValue : the value of the blocking component of the primal variables (u,t,v,w). primalStep : the corresponding value of the blocking component of the primal step variables (b->u,b->t,b->v,b->w) dualValue : the value of the blocking component of the dual variables/ (lambda,pi,phi,gamma). dualStep : the corresponding value of the blocking component of the dual step variables (b->lambda,b->pi,b->phi,b->gamma) firstOrSecond : 1 if the primal step is blocking, 2 if the dual step is block, 0 if no step is blocking. ; Definition at line 414 of file TQpVar.cxx. ◆ FindBlocking() [2/2]. Double_t TQpVar::FindBlocking ; (; TVectorD & ; w, . TVectorD & ; wstep, . TVectorD & ; u, . TVectorD & ; ustep, . Double_t ; maxStep, . Double_t & ; w_elt, . Double_t & ; wstep_elt, . Double_t & ; u_elt, . Double_t & ; ustep_elt, . int & ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQpVar.html:15241,Perform,Performs,15241,doc/master/classTQpVar.html,https://root.cern,https://root.cern/doc/master/classTQpVar.html,1,['Perform'],['Performs']
Performance,"mber Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooRealProxy c;  ; RooRealProxy x;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1Heaviside.html:55413,Cache,Cache,55413,doc/master/classRooStats_1_1Heaviside.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1Heaviside.html,1,['Cache'],['Cache']
Performance,"mber Functions;  RooAbsCachedPdf ();  ;  RooAbsCachedPdf (const char *name, const char *title, int ipOrder=0);  Constructor. ;  ;  RooAbsCachedPdf (const RooAbsCachedPdf &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implements internal (analytical) integration capabilities. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to offer all our actual observable for internal integration. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertises internal (analytical) integration capabilities. ;  ; RooDataHist * getCacheHist (const RooArgSet &nset) const;  ; RooDataHist * getCacheHist (const RooArgSet *nset=nullptr) const;  Return pointer to RooDataHist cache histogram for given choice of observables. ;  ; RooAbsPdf * getCachePdf (const RooArgSet &nset) const;  ; RooAbsPdf * getCachePdf (const RooArgSet *nset=nullptr) const;  Return pointer to RooHistPdf cache pdf for given choice of observables. ;  ; Int_t getInterpolationOrder () const;  ; double getValV (const RooArgSet *set=nullptr) const override;  Implementation of getVal() overriding default implementation of RooAbsPdf. ;  ; TClass * IsA () const override;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setInterpolationOrder (int order);  Change the interpolation order that is used in RooHistPdf cache representation smoothing the RooDataHist shapes. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:4092,cache,cache,4092,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"mber Functions;  TSGD (Scalar_t learningRate, DeepNet_t &deepNet, Scalar_t momentum);  Constructor. ;  ;  ~TSGD ()=default;  Destructor. ;  ; Scalar_t GetMomentum () const;  Getters. ;  ; std::vector< std::vector< Matrix_t > > & GetPastBiasGradients ();  ; std::vector< Matrix_t > & GetPastBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastWeightGradients ();  ; std::vector< Matrix_t > & GetPastWeightGradientsAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fMomentum;  The momentum used for training. ;  ; std::vector< std::vector< Matrix_t > > fPastBiasGradients;  The sum of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastWeightGradients;  The sum of the past weight gradients associated with the deep net. ;  ;  Protected Attributes inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TSGD.html:2140,Perform,Performs,2140,doc/master/classTMVA_1_1DNN_1_1TSGD.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TSGD.html,2,"['Perform', 'optimiz']","['Performs', 'optimization']"
Performance,"mber of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:26544,concurren,concurrent,26544,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"mber to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:25887,cache,cache,25887,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['cache'],['cache']
Performance,"mber to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:26511,cache,cache,26511,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,2,['cache'],['cache']
Performance,mber::operator= ; (; const TDataMember & ; dm). protected . assignment operator ; Definition at line 298 of file TDataMember.cxx. ◆ Property(). Long_t TDataMember::Property ; (; ); const. overridevirtual . Get property description word. For meaning of bits see EProperty. ; Implements TDictionary.; Definition at line 588 of file TDataMember.cxx. ◆ SetClass(). void TDataMember::SetClass ; (; TClass * ; cl). inline . Definition at line 95 of file TDataMember.h. ◆ SetterMethod(). TMethodCall * TDataMember::SetterMethod ; (; TClass * ; cl). Return a TMethodCall method responsible for setting the value of data member. ; The cl argument specifies the class of the object which will be used to call this method (in case of multiple inheritance TMethodCall needs to know this to calculate the proper offset). ; Definition at line 878 of file TDataMember.cxx. ◆ Streamer(). void TDataMember::Streamer ; (; TBuffer & ; b). overridevirtual . Stream an object of TDataMember. ; Forces calculation of all cached (and persistent) values. ; Reimplemented from TObject.; Definition at line 956 of file TDataMember.cxx. ◆ StreamerNVirtual(). void TDataMember::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 98 of file TDataMember.h. ◆ Update(). Bool_t TDataMember::Update ; (; DataMemberInfo_t * ; info). virtual . Update the TFunction to reflect the new info. ; This can be used to implement unloading (info == 0) and then reloading (info being the 'new' decl address). ; Definition at line 921 of file TDataMember.cxx. Member Data Documentation. ◆ fArrayDim. Int_t TDataMember::fArrayDim. private . Definition at line 45 of file TDataMember.h. ◆ fArrayIndex. TString TDataMember::fArrayIndex. private . Definition at line 47 of file TDataMember.h. ◆ fArrayMaxIndex. Int_t* TDataMember::fArrayMaxIndex. private . Definition at line 46 of file TDataMember.h. ◆ fClass. TClass* TDataMember::fClass. private . pointer to CINT data member info ; Definition at line 39 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataMember.html:30463,cache,cached,30463,doc/master/classTDataMember.html,https://root.cern,https://root.cern/doc/master/classTDataMember.html,1,['cache'],['cached']
Performance,"mberInspector &, const void *obj, const TClass *cl, Bool_t isTransient)=0;  ; TClass * IsA () const override;  ; virtual Bool_t IsAutoParsingSuspended () const =0;  ; virtual Bool_t IsErrorMessagesEnabled () const =0;  ; virtual Bool_t IsFloatingType (const void *) const;  ; virtual Bool_t IsIntegerType (const void *) const;  ; virtual Bool_t IsLibraryLoaded (const char *libname) const =0;  ; virtual Bool_t IsLoaded (const char *filename) const =0;  ; virtual Bool_t IsPointerType (const void *) const;  ; virtual Bool_t IsProcessLineLocked () const =0;  ; virtual Bool_t IsSameType (const void *, const void *) const;  ; virtual Bool_t IsSignedIntegerType (const void *) const;  ; virtual Bool_t IsUnsignedIntegerType (const void *) const;  ; virtual Bool_t IsVoidPointerType (const void *) const;  ; virtual Int_t Load (const char *filenam, Bool_t system=kFALSE)=0;  ; virtual void LoadEnums (TListOfEnums &cl) const =0;  ; virtual int LoadFile (const char *) const;  ; virtual void LoadFunctionTemplates (TClass *cl) const =0;  ; virtual Int_t LoadLibraryMap (const char *rootmapfile=nullptr)=0;  ; virtual void LoadMacro (const char *filename, EErrorCode *error=nullptr)=0;  ; virtual Bool_t LoadText (const char *) const;  ; virtual std::unique_ptr< TInterpreterValue > MakeInterpreterValue () const;  ; virtual const char * MapCppName (const char *) const;  ; virtual const char * MethodArgInfo_DefaultValue (MethodArgInfo_t *) const;  ; virtual void MethodArgInfo_Delete (MethodArgInfo_t *) const;  ; virtual MethodArgInfo_t * MethodArgInfo_Factory () const;  ; virtual MethodArgInfo_t * MethodArgInfo_Factory (MethodInfo_t *) const;  ; virtual MethodArgInfo_t * MethodArgInfo_FactoryCopy (MethodArgInfo_t *) const;  ; virtual Bool_t MethodArgInfo_IsValid (MethodArgInfo_t *) const;  ; virtual const char * MethodArgInfo_Name (MethodArgInfo_t *) const;  ; virtual int MethodArgInfo_Next (MethodArgInfo_t *) const;  ; virtual Long_t MethodArgInfo_Property (MethodArgInfo_t *) const;  ; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter.html:18292,Load,LoadFunctionTemplates,18292,doc/master/classTInterpreter.html,https://root.cern,https://root.cern/doc/master/classTInterpreter.html,1,['Load'],['LoadFunctionTemplates']
Performance,"mberWiseTStreamerInfoActions::TActionSequence * fReadMemberWise! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:105; TStreamerInfo::GetReadObjectWiseActionsTStreamerInfoActions::TActionSequence * GetReadObjectWiseActions()Definition TStreamerInfo.h:168; TStreamerInfo::GetOldVersionVersion_t GetOldVersion() const overrideDefinition TStreamerInfo.h:181; TStreamerInfo::GetTypeInt_t GetType(Int_t id) constDefinition TStreamerInfo.h:187; TStreamerInfo::ReadBufferConvInt_t ReadBufferConv(TBuffer &b, const T &arrptr, const TCompInfo *compinfo, Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset)Convert elements of a TClonesArray.Definition TStreamerInfoReadBuffer.cxx:568; TStreamerInfo::GetElemTStreamerElement * GetElem(Int_t id) const overrideDefinition TStreamerInfo.h:164; TStreamerInfo::fClassVersionInt_t fClassVersionClass version identifier.Definition TStreamerInfo.h:89; TStreamerInfo::fNdataInt_t fNdata!number of optimized elementsDefinition TStreamerInfo.h:93; TStreamerInfo::Newvoid * New(void *obj=nullptr) overrideAn emulated object is created at address obj, if obj is null we allocate memory for the object.Definition TStreamerInfo.cxx:4769; TStreamerInfo::TStreamerInfoTStreamerInfo()Status bits See TVirtualStreamerInfo::EStatusBits for the values.Definition TStreamerInfo.cxx:145; TStreamerInfo::fReadMemberWiseVecPtrTStreamerInfoActions::TActionSequence * fReadMemberWiseVecPtr! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:106; TStreamerInfo::fReadObjectWiseTStreamerInfoActions::TActionSequence * fReadObjectWise! List of read action resulting from the compilation.Definition TStreamerInfo.h:104; TStreamerInfo::GetElementOffsetInt_t GetElementOffset(Int_t id) const overrideDefinition TStreamerInfo.h:166; TStreamerInfo::GetLengthInt_t GetLength(Int_t id) constDefinition TStreamerInfo.h:176; TStreamerInfo::TStreamerInfoTStreamerI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8h_source.html:31568,optimiz,optimized,31568,doc/master/TStreamerInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html,1,['optimiz'],['optimized']
Performance,"mbers ; RooGExpModel Class ReferenceRooFit » RooFit. ; The RooGExpModel is a RooResolutionModel implementation that models a resolution function that is the convolution of a Gaussian with a one-sided exponential. ; Such objects can be used for analytical convolutions with classes inheriting from RooAbsAnaConvPdf. ; \[; \mathrm{GExp} = \exp \left( -\frac{1}{2} \left(\frac{x-\mu}{\sigma} \right)^2 \right)^2; \otimes \exp\left( -\frac{x}{\tau} \right); \]. Definition at line 25 of file RooGExpModel.h. Public Types; enum  Type { Normal; , Flipped; };  ;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGExpModel.html:1298,Cache,CacheMode,1298,doc/master/classRooGExpModel.html,https://root.cern,https://root.cern/doc/master/classRooGExpModel.html,1,['Cache'],['CacheMode']
Performance,"mbers Class Reference. ; View implementing the TList interface and giving access all the TDictionary describing public data members in a class and all its base classes without caching any of the TDictionary pointers. ; Adding to this collection directly is prohibited. Iteration can only be done via the TIterator interfaces. ; Definition at line 28 of file TViewPubDataMembers.h. Public Member Functions;  TViewPubDataMembers (TClass *cl=nullptr);  Usual constructor. ;  ; virtual ~TViewPubDataMembers ();  Default destructor. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position idx. Returns 0 if idx is out of range. ;  ; TObject * FindObject (const char *name) const override;  Find an object in this list using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find an object in this list using the object's IsEqual() member function. ;  ; virtual const TList * GetListOfClasses () const;  ; Int_t GetSize () const override;  Return the total number of public data members(currently loaded in the list; of DataMembers) in this class and all its base classes. ;  ; void Load ();  Load all the DataMembers known to the interpreter for the scope 'fClass' and all its bases classes. ;  ; TIterator * MakeIterator (Bool_t dir=kIterForward) const override;  Return a list iterator. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; TClass * IsA () const override;  ; Bool_t IsAscending ();  ; TObject * Remove (const TObjLinkPtr_t &lnk);  ; void RemoveLast () override;  Remove the last object of the list. ;  ; virtual void Sort (Bool_t order=kSortAscending);  Sort linked list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTViewPubDataMembers.html:1331,load,loaded,1331,doc/master/classTViewPubDataMembers.html,https://root.cern,https://root.cern/doc/master/classTViewPubDataMembers.html,1,['load'],['loaded']
Performance,"mbers |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Private Types |; Private Member Functions |; Static Private Member Functions |; Private Attributes |; Static Private Attributes |; Friends |; List of all members ; TClass Class Reference. ; TClass instances represent classes, structs and namespaces in the ROOT type system. ; TClass instances are created starting from different sources of information:; TStreamerInfo instances saved in a ROOT file which is opened. This is called in jargon an emulated TClass.; From TProtoClass instances saved in a ROOT pcm file created by the dictionary generator and the dictionary itself.; From a lookup in the AST built by cling. If a TClass instance is built through the mechanisms 1. and 2., it does not contain information about methods of the class/struct/namespace it represents. Conversely, if built through 3. or 1., it does not carry the information which is necessary to ROOT to perform I/O of instances of the class/struct it represents. The mechanisms 1., 2. and 3. are not mutually exclusive: it can happen that during the execution of the program, all the three are triggered, modifying the state of the TClass instance.; In order to retrieve a TClass instance from the type system, a query can be executed as follows through the static TClass::GetClass method:; auto myClassTClass_0 = TClass::GetClass(""myClass"");; auto myClassTClass_1 = TClass::GetClass<myClass>();; auto myClassTClass_2 = TClass::GetClass(myClassTypeInfo);; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; The name of classes is crucial for ROOT. A careful procedure of name normalization is carried out for each and every class. A normalized name is a valid C++ class name. In order to access the name of a class within the ROOT type system, the method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:1130,perform,perform,1130,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['perform'],['perform']
Performance,"mbers |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Private Types |; Private Member Functions |; Static Private Member Functions |; Private Attributes |; Static Private Attributes |; Friends |; List of all members ; TClass Class Reference. ; TClass instances represent classes, structs and namespaces in the ROOT type system. ; TClass instances are created starting from different sources of information:; TStreamerInfo instances saved in a ROOT file which is opened. This is called in jargon an emulated TClass.; From TProtoClass instances saved in a ROOT pcm file created by the dictionary generator and the dictionary itself.; From a lookup in the AST built by cling. If a TClass instance is built through the mechanisms 1. and 2., it does not contain information about methods of the class/struct/namespace it represents. Conversely, if built through 3. or 1., it does not carry the information which is necessary to ROOT to perform I/O of instances of the class/struct it represents. The mechanisms 1., 2. and 3. are not mutually exclusive: it can happen that during the execution of the program, all the three are triggered, modifying the state of the TClass instance.; In order to retrieve a TClass instance from the type system, a query can be executed as follows through the static TClass::GetClass method:; auto myClassTClass_0 = TClass::GetClass(""myClass"");; auto myClassTClass_1 = TClass::GetClass<myClass>();; auto myClassTClass_2 = TClass::GetClass(myClassTypeInfo);; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; The name of classes is crucial for ROOT. A careful procedure of name normalization is carried out for each and every class. A normalized name is a valid C++ class name. In order to access the name of a class within the ROOT type system, the method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:1131,perform,perform,1131,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['perform'],['perform']
Performance,"mbers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. ULong_t_max!; RooNameSet_name1!; RooNameSet_name2!; ULong_t_next!; map<pair<const RooArgSet*,const RooArgSet*>,unsigned long>_pairToIdx!; vector<pair<const RooArgSet*,const RooArgSet*> >_pairs!; TNamed*_set2RangeName!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNormSetCache(ULong_t max = 32). ~RooNormSetCache(); Destructor. void clear(); Clear contents. void add(const RooArgSet* set1, const RooArgSet* set2 = 0); Add given pair of RooArgSet pointers to our store. Bool_t autoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); If RooArgSets set1 and set2 or sets with similar contents have; been seen by this cache manager before return kFALSE If not,; return kTRUE. If sets have not been seen and doRefill is true,; update cache reference to current input sets. RooNormSetCache(ULong_t max = 32). Int_t index(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Match range name first. Bool_t contains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); { return (index(set1,set2,set2RangeName) >= 0); }. Bool_t containsSet1(const RooArgSet* set1). const RooArgSet* lastSet1() const; { return _pairs.empty()?0:_pairs.back().first; }. const RooArgSet* lastSet2() const; { return _pairs.empty()?0:_pairs.back().second; }. const RooNameSet& nameSet1() const; { return _name1; }. const RooNameSet& nameSet2() const; { return _name2; }. Int_t entries() const; { return _pairs.size(); }. void initialize(const RooNormSetCache& other); { clear(); *this = other; }. » Last changed: Tue Mar 10 17:18:10 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNormSetCache.html:2958,cache,cache,2958,root/html534/RooNormSetCache.html,https://root.cern,https://root.cern/root/html534/RooNormSetCache.html,1,['cache'],['cache']
Performance,"mbers; Includes; Libraries. Function documentation; RooExpensiveObjectCache(); Constructor. RooExpensiveObjectCache(const RooExpensiveObjectCache& ); Copy constructor. ~RooExpensiveObjectCache(); Destructor. RooExpensiveObjectCache& instance(); Return reference to singleton instance. void cleanup(); Static function called by RooSentinel atexit() handler to cleanup at end of program. Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExpensiveObjectCache.html:7198,cache,cacheObject,7198,root/html528/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html528/RooExpensiveObjectCache.html,12,['cache'],"['cache', 'cacheObject']"
Performance,"mbie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meas; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to globa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPullVar.html:33947,cache,cache,33947,root/html602/RooPullVar.html,https://root.cern,https://root.cern/root/html602/RooPullVar.html,14,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"mbined tree created; ; ; ========================; --- maximize significance; Classifier ranges (defined by the user); range: -1 1; range: -1 1; range: -1 1; <HEADER> FitterBase : <GeneticFitter> Optimisation, please be patient ... (inaccurate progress timing for GA); : Elapsed time: 13.4 sec ; ; ======================; Efficiency : 0.955; Purity : 0.880184; ; True positive weights : 191; False positive weights: 26; Signal weights : 200; ; cutValue[0] = -0.950311;; cutValue[1] = 0.986588;; cutValue[2] = 0.928658;; ; ; #include <iostream> // Stream declarations; #include <vector>; #include <limits>; ; #include ""TChain.h""; #include ""TCut.h""; #include ""TDirectory.h""; #include ""TH1F.h""; #include ""TH1.h""; #include ""TMath.h""; #include ""TFile.h""; #include ""TStopwatch.h""; #include ""TROOT.h""; #include ""TSystem.h""; ; #include ""TMVA/GeneticAlgorithm.h""; #include ""TMVA/GeneticFitter.h""; #include ""TMVA/IFitterTarget.h""; #include ""TMVA/Factory.h""; #include ""TMVA/DataLoader.h""//required to load dataset; #include ""TMVA/Reader.h""; ; using std::vector, std::cout, std::endl;; ; using namespace TMVA;; ; // ----------------------------------------------------------------------------------------------; // Training; // ----------------------------------------------------------------------------------------------; //; void Training(){; std::string factoryOptions( ""!V:!Silent:Transformations=I;D;P;G,D:AnalysisType=Classification"" );; TString fname = ""./tmva_example_multiple_background.root"";; ; TFile *input(0);; input = TFile::Open( fname );; ; TTree *signal = (TTree*)input->Get(""TreeS"");; TTree *background0 = (TTree*)input->Get(""TreeB0"");; TTree *background1 = (TTree*)input->Get(""TreeB1"");; TTree *background2 = (TTree*)input->Get(""TreeB2"");; ; /// global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t background0Weight = 1.0;; Double_t background1Weight = 1.0;; Double_t background2Weight = 1.0;; ; // Create a new root output file.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMultipleBackgroundExample_8C.html:31215,load,load,31215,doc/master/TMVAMultipleBackgroundExample_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMultipleBackgroundExample_8C.html,1,['load'],['load']
Performance,"mdList); TStringRooAbsArg::cleanBranchName() const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; RooMomentMorph::CacheElem*getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); intidxmax(const double& m) const; intidxmin(const double& m) const; Int_tij(const Int_t& i, const Int_t& j) const; static Bool_tRooAbsArg::inhibitDirty(); voidinitialize(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMomentMorph.html:30954,Cache,CacheElem,30954,root/html526/RooMomentMorph.html,https://root.cern,https://root.cern/root/html526/RooMomentMorph.html,3,['Cache'],['CacheElem']
Performance,"me ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Attributes; RooArgSet _cachedVars;  ; bool _doDirtyProp = true;  Switch do (de)activate dirty state propagation when loading a data point. ;  ; RooArgSet _vars;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddres",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsDataStore.html:15486,load,loading,15486,doc/master/classRooAbsDataStore.html,https://root.cern,https://root.cern/doc/master/classRooAbsDataStore.html,1,['load'],['loading']
Performance,"me ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Evaluate RooBlindTools unhide-offset method on blind value. ;  ;  Protected Member Functions inherited from RooAbsHiddenReal; RooAbsCategory & dummyBlindState () const;  Return reference to internal dummy RooCategory implementation blinding state switch. ;  ; double getValV (const RooArgSet *nset=nullptr) const override;  Return value of object. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooUnblindOffset.html:50213,cache,cached,50213,doc/master/classRooUnblindOffset.html,https://root.cern,https://root.cern/doc/master/classRooUnblindOffset.html,4,['cache'],"['cache', 'cached']"
Performance,"me (by adding a dot ('.') at the end of the Branch creation and use the; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:131600,cache,cachesize,131600,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,4,['cache'],"['cache', 'cachesize']"
Performance,"me (by adding a dot ('.') at the end of the Branch creation and use the; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; WARNING: Currently only ONE TTree object can be 'cached' per TFile object.; This call disable the cache for the other TTree objects read from the same; TFile object as this TTree (The SetCacheSize called __last__ wins).; To cache multiple TTree objects in the same ROOT file, you must create; one TFile object per TTree object. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:127141,cache,cachesize,127141,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,2,['cache'],"['cache', 'cachesize']"
Performance,"me (i.e. in x); gauss.plotOn(xframe); ; # Change the value of sigma to 3; sigma.setVal(3); ; # Plot gauss in frame (i.e. in x) and draw frame on canvas; gauss.plotOn(xframe, LineColor=""r""); ; # Generate events; # -----------------------------; # Generate a dataset of 1000 events in x from gauss; data = gauss.generate({x}, 10000) # ROOT.RooDataSet; ; # Make a second plot frame in x and draw both the; # data and the pdf in the frame; xframe2 = x.frame(Title=""Gaussian pdf with data"") # RooPlot; data.plotOn(xframe2); gauss.plotOn(xframe2); ; # Fit model to data; # -----------------------------; # Fit pdf to data; gauss.fitTo(data, PrintLevel=-1); ; # Print values of mean and sigma (that now reflect fitted values and; # errors); mean.Print(); sigma.Print(); ; # Draw all frames on a canvas; c = ROOT.TCanvas(""rf101_basics"", ""rf101_basics"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.6); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); xframe2.GetYaxis().SetTitleOffset(1.6); xframe2.Draw(); ; c.SaveAs(""rf101_basics.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_gaussData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; RooRealVar::mean = 1.01746 +/- 0.0300144 L(-10 - 10) ; RooRealVar::sigma = 2.9787 +/- 0.0219217 L(0.1 - 10) ; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf101_basics.py. tutorialsroofitrf101_basics.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf101__basics_8py.html:2496,optimiz,optimization,2496,doc/master/rf101__basics_8py.html,https://root.cern,https://root.cern/doc/master/rf101__basics_8py.html,2,['optimiz'],['optimization']
Performance,"me = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidRooAbsOptTestStatistic::seal(const char* notice = """"); const char*RooAbsOptTestStatistic::sealNotice() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooChi2Var.html:24990,cache,cache,24990,root/html530/RooChi2Var.html,https://root.cern,https://root.cern/root/html530/RooChi2Var.html,4,['cache'],['cache']
Performance,"me = 0, const char* catTypeName = 0); virtual~RooBinningCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBinningCategory.html:1660,cache,cacheUniqueSuffix,1660,root/html534/RooBinningCategory.html,https://root.cern,https://root.cern/root/html534/RooBinningCategory.html,1,['cache'],['cacheUniqueSuffix']
Performance,"me Architecture_t::Scalar_t. Definition at line 48 of file Optimizer.h. Constructor & Destructor Documentation. ◆ VOptimizer(). template<typename Architecture_t , typename Layer_t , typename DeepNet_t > . TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::VOptimizer ; (; Scalar_t ; learningRate, . DeepNet_t & ; deepNet . ). Constructor. ; Definition at line 94 of file Optimizer.h. ◆ ~VOptimizer(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . virtual TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::~VOptimizer ; (; ). virtualdefault . Virtual Destructor. . Member Function Documentation. ◆ GetGlobalStep(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . size_t TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::GetGlobalStep ; (; ); const. inline . Definition at line 81 of file Optimizer.h. ◆ GetLayerAt(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Layer_t * TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::GetLayerAt ; (; size_t ; i). inline . Definition at line 83 of file Optimizer.h. ◆ GetLayers(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector< Layer_t * > & TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::GetLayers ; (; ). inline . Definition at line 82 of file Optimizer.h. ◆ GetLearningRate(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::GetLearningRate ; (; ); const. inline . Getters. ; Definition at line 77 of file Optimizer.h. ◆ IncrementGlobalStep(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html:3839,Optimiz,Optimizer,3839,doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,1,['Optimiz'],['Optimizer']
Performance,me for training with 4000 events: 5.42 sec ; : Dataset[dataset] : Create results for training; : Dataset[dataset] : Multiclass evaluation of BDTG on training sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 1.89 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAMulticlass_BDTG.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAMulticlass_BDTG.class.C␛[0m; : TMVAMulticlass.root:/dataset/Method_BDT/BDTG; Factory : Training finished; : ; Factory : Train method: MLP for Multiclass classification; : ; : Training Network; : ; : Elapsed time for training with 4000 events: 23.9 sec ; : Dataset[dataset] : Create results for training; : Dataset[dataset] : Multiclass evaluation of MLP on training sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.0125 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAMulticlass_MLP.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAMulticlass_MLP.class.C␛[0m; : Write special histos to file: TMVAMulticlass.root:/dataset/Method_MLP/MLP; Factory : Training finished; : ; Factory : Train method: PDEFoam for Multiclass classification; : ; : Build up multiclass foam 0; : Elapsed time: 0.659 sec ; : Build up multiclass foam 1; : Elapsed time: 0.667 sec ; : Build up multiclass foam 2; : Elapsed time: 0.671 sec ; : Build up multiclass foam 3; : Elapsed time: 0.469 sec ; : Elapsed time for training with 4000 events: 2.63 sec ; : Dataset[dataset] : Create results for training; : Dataset[dataset] : Multiclass evaluation of PDEFoam on training sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.12 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating xml weight file: ␛[0;36mdatase,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:11499,perform,performance,11499,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,"me in batch, used for image production, like ""$prog --headless --disable-gpu $geometry $url""; WebGui.ChromeHeadless: command to start chrome in headless mode, like ""fork: --headless --disable-gpu $geometry $url""; WebGui.ChromeInteractive: command to start chrome in interactive mode, like ""$prog $geometry --app=\'$url\' &""; WebGui.Firefox: full path to Mozilla Firefox executable; WebGui.FirefoxHeadless: command to start Firefox in headless mode, like ""fork:--headless --private-window --no-remote $profile $url""; WebGui.FirefoxInteractive: command to start Firefox in interactive mode, like ""$prog --private-window \'$url\' &""; WebGui.FirefoxProfile: name of Firefox profile to use; WebGui.FirefoxProfilePath: file path to Firefox profile; WebGui.FirefoxRandomProfile: usage of random Firefox profile -1 never, 0 - only for headless mode (dflt), 1 - always; WebGui.LaunchTmout: time required to start process in seconds (default 30 s); WebGui.OperationTmout: time required to perform WebWindow operation like execute command or update drawings; WebGui.RecordData: if specified enables data recording for each web window 0 - off, 1 - on; WebGui.JsonComp: compression factor for JSON conversion, if not specified - each widget uses own default values; WebGui.ForceHttp: 0 - off (default), 1 - always create real http server to run web window; WebGui.Console: -1 - output only console.error(), 0 - add console.warn(), 1 - add console.log() output; WebGui.ConnCredits: 10 - number of packets which can be send by server or client without acknowledge from receiving side; WebGui.openui5src: alternative location for openui5 like https://openui5.hana.ondemand.com/1.128.0/; WebGui.openui5libs: list of pre-loaded ui5 libs like sap.m, sap.ui.layout, sap.ui.unified; WebGui.openui5theme: openui5 theme like sap_belize (default) or sap_fiori_3; THttpServer-related parameters documented in CreateServer method ; Definition at line 778 of file RWebWindowsManager.cxx. ◆ Terminate(). void RWebWindowsManager::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:19640,perform,perform,19640,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['perform'],['perform']
Performance,"me in batch, used for image production, like ""$prog --headless --disable-gpu $geometry $url""; WebGui.ChromeHeadless: command to start chrome in headless mode, like ""fork: --headless --disable-gpu $geometry $url""; WebGui.ChromeInteractive: command to start chrome in interactive mode, like ""$prog $geometry --app=\'$url\' &""; WebGui.Firefox: full path to Mozilla Firefox executable; WebGui.FirefoxHeadless: command to start Firefox in headless mode, like ""fork:--headless --private-window --no-remote $profile $url""; WebGui.FirefoxInteractive: command to start Firefox in interactive mode, like ""$prog --private-window \'$url\' &""; WebGui.FirefoxProfile: name of Firefox profile to use; WebGui.FirefoxProfilePath: file path to Firefox profile; WebGui.FirefoxRandomProfile: usage of random Firefox profile -1 never, 0 - only for headless mode (dflt), 1 - always; WebGui.LaunchTmout: time required to start process in seconds (default 30 s); WebGui.OperationTmout: time required to perform WebWindow operation like execute command or update drawings; WebGui.RecordData: if specified enables data recording for each web window 0 - off, 1 - on; WebGui.JsonComp: compression factor for JSON conversion, if not specified - each widget uses own default values; WebGui.ForceHttp: 0 - off (default), 1 - always create real http server to run web window; WebGui.Console: -1 - output only console.error(), 0 - add console.warn(), 1 - add console.log() output; WebGui.ConnCredits: 10 - number of packets which can be send by server or client without acknowledge from receiving side; WebGui.openui5src: alternative location for openui5 like https://openui5.hana.ondemand.com/; WebGui.openui5libs: list of pre-loaded ui5 libs like sap.m, sap.ui.layout, sap.ui.unified; WebGui.openui5theme: openui5 theme like sap_belize (default) or sap_fiori_3; THttpServer-related parameters documented in CreateServer method ; Definition at line 692 of file RWebWindowsManager.cxx. ◆ Terminate(). void RWebWindowsManager::Terminat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:17201,perform,perform,17201,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['perform'],['perform']
Performance,"me y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd2Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrd2Editor.html:21104,Perform,Perform,21104,root/html528/TGeoTrd2Editor.html,https://root.cern,https://root.cern/root/html528/TGeoTrd2Editor.html,1,['Perform'],['Perform']
Performance,"me y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd2Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTrd2Editor.html:21204,Perform,Perform,21204,root/html530/TGeoTrd2Editor.html,https://root.cern,https://root.cern/root/html530/TGeoTrd2Editor.html,1,['Perform'],['Perform']
Performance,"me y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd2Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTrd2Editor.html:21204,Perform,Perform,21204,root/html532/TGeoTrd2Editor.html,https://root.cern,https://root.cern/root/html532/TGeoTrd2Editor.html,1,['Perform'],['Perform']
Performance,"me(). static const char * RooCrystalBall::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 50 of file RooCrystalBall.h. ◆ evaluate(). double RooCrystalBall::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 203 of file RooCrystalBall.cxx. ◆ getAnalyticalIntegral(). Int_t RooCrystalBall::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 234 of file RooCrystalBall.cxx. ◆ getMaxVal(). Int_t RooCrystalBall::getMaxVal ; (; const RooArgSet & ; vars); const. overridevirtual . Advertise that we know the maximum of self for given (m0,alpha,n,sigma). ; Reimplemented from RooAbsReal.; Definition at line 287 of file RooCrystalBall.cxx. ◆ IsA(). TClass * RooCrystalBall::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 50 of file RooCrystalBall.h. ◆ maxVal(). double RooCrystalBall::maxVal ; (; Int_t ; code); const. overridevirtual . Return maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooAbsReal.; Definition at line 295 of file RooCrystalBall.cxx. ◆ Streamer(). void RooCrystalBall::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCrystalBall.html:80440,perform,performed,80440,doc/master/classRooCrystalBall.html,https://root.cern,https://root.cern/doc/master/classRooCrystalBall.html,1,['perform'],['performed']
Performance,"me();; 6180 if (lib && lib[0]) {; 6181 if (gROOT->LoadClass(cls, lib) == 0) {; 6182 if (gDebug > 0) {; 6183 gCling->Info(""TCling::AutoLoad"",; 6184 ""loaded library %s for %s"", lib, cls);; 6185 }; 6186 status = 1;; 6187 }; 6188 else {; 6189 gCling->Error(""TCling::AutoLoad"",; 6190 ""failure loading library %s for %s"", lib, cls);; 6191 }; 6192 }; 6193 delete tokens;; 6194 }; 6195 ; 6196 return status;; 6197}; 6198 ; 6199////////////////////////////////////////////////////////////////////////////////; 6200// Iterate through the data member of the class (either through the TProtoClass; 6201// or through Cling) and trigger, recursively, the loading the necessary libraries.; 6202// \note `cls` is expected to be already normalized!; 6203// \returns 1 on success.; 6204Int_t TCling::DeepAutoLoadImpl(const char *cls, std::unordered_set<std::string> &visited,; 6205 bool nameIsNormalized); 6206{; 6207 // Try to insert; if insertion failed because the entry existed, DeepAutoLoadImpl(); 6208 // has previously (within the same call to `AutoLoad()`) tried to load this class; 6209 // and we are done, whether success or not, as it won't work better now than before,; 6210 // because there is no additional information now compared to before.; 6211 if (!visited.insert(std::string(cls)).second); 6212 return 1;; 6213 ; 6214 if (ShallowAutoLoadImpl(cls) == 0) {; 6215 // If ShallowAutoLoadImpl() has an error, we have an error.; 6216 return 0;; 6217 }; 6218 ; 6219 // Now look through the TProtoClass to load the required library/dictionary; 6220 if (TProtoClass *proto = nameIsNormalized ? TClassTable::GetProtoNorm(cls) : TClassTable::GetProto(cls)) {; 6221 for (auto element : proto->GetData()) {; 6222 if (element->IsBasic()); 6223 continue;; 6224 const char *subtypename = element->GetTypeName();; 6225 if (!TClassTable::GetDictNorm(subtypename)) {; 6226 // Failure to load a dictionary is not (quite) a failure load; 6227 // the top-level library. If we return false here, then; 6228 // we would end",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:240482,load,load,240482,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance,"me(const char* typeDesc) final;; 324 ; 325 void SnapshotMutexState(ROOT::TVirtualRWMutex* mtx) final;; 326 void ForgetMutexState() final;; 327 ; 328 void ApplyToInterpreterMutex(void* delta);; 329 void *RewindInterpreterMutex();; 330 ; 331 static void UpdateClassInfo(char* name, Long_t tagnum);; 332 static void UpdateClassInfoWork(const char* name);; 333 void RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias);; 334 void UpdateClassInfoWithDecl(const clang::NamedDecl* ND);; 335 static void UpdateAllCanvases();; 336 ; 337 // Misc; 338 int DisplayClass(FILE* fout, const char* name, int base, int start) const final;; 339 int DisplayIncludePath(FILE* fout) const final;; 340 void* FindSym(const char* entry) const final;; 341 void GenericError(const char* error) const final;; 342 Long_t GetExecByteCode() const final;; 343 const char* GetTopLevelMacroName() const final;; 344 const char* GetCurrentMacroName() const final;; 345 int GetSecurityError() const final;; 346 int LoadFile(const char* path) const final;; 347 Bool_t LoadText(const char* text) const final;; 348 const char* MapCppName(const char*) const final;; 349 void SetAlloclockfunc(void (*)()) const final;; 350 void SetAllocunlockfunc(void (*)()) const final;; 351 int SetClassAutoLoading(int) const final;; 352 int SetClassAutoparsing(int) final;; 353 Bool_t IsAutoParsingSuspended() const final { return fIsAutoParsingSuspended; }; 354 void SetErrmsgcallback(void* p) const final;; 355 void ReportDiagnosticsToErrorHandler(bool enable = true) final;; 356 void SetTempLevel(int val) const final;; 357 int UnloadFile(const char* path) const final;; 358 ; 359 void CodeComplete(const std::string&, size_t&,; 360 std::vector<std::string>&) final;; 361 int Evaluate(const char*, TInterpreterValue&) final;; 362 std::unique_ptr<TInterpreterValue> MakeInterpreterValue() const final;; 363 void RegisterTemporary(const TInterpreterValue& value);; 364 void RegisterTemporary(const cling::Value& value);; 365 const ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:16660,Load,LoadFile,16660,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['Load'],['LoadFile']
Performance,"me(h->fFile, kReadPermission)) {; 1735 Error(""ShowOutput"", ""file '%s' cannot be read"", h->fFile.Data());; 1736 return;; 1737 }; 1738 ; 1739 // Open the file; 1740 FILE *f = nullptr;; 1741 if (!(f = fopen(h->fFile.Data(), ""r""))) {; 1742 Error(""ShowOutput"", ""file '%s' cannot be open"", h->fFile.Data());; 1743 return;; 1744 }; 1745 ; 1746 // Determine the number of bytes to be read from the file.; 1747 off_t ltot = lseek(fileno(f), (off_t) 0, SEEK_END);; 1748 Int_t begin = (h->fReadOffSet > 0 && h->fReadOffSet < ltot) ? h->fReadOffSet : 0;; 1749 lseek(fileno(f), (off_t) begin, SEEK_SET);; 1750 Int_t left = ltot - begin;; 1751 ; 1752 // Now readout from file; 1753 const Int_t kMAXBUF = 16384;; 1754 char buf[kMAXBUF];; 1755 Int_t wanted = (left > kMAXBUF-1) ? kMAXBUF-1 : left;; 1756 Int_t len;; 1757 do {; 1758 while ((len = read(fileno(f), buf, wanted)) < 0 &&; 1759 TSystem::GetErrno() == EINTR); 1760 TSystem::ResetErrno();; 1761 ; 1762 if (len < 0) {; 1763 SysError(""ShowOutput"", ""error reading log file"");; 1764 break;; 1765 }; 1766 ; 1767 // Null-terminate; 1768 buf[len] = 0;; 1769 fprintf(stderr,""%s"", buf);; 1770 ; 1771 // Update counters; 1772 left -= len;; 1773 wanted = (left > kMAXBUF) ? kMAXBUF : left;; 1774 ; 1775 } while (len > 0 && left > 0);; 1776 ; 1777 // Do not display twice the same thing; 1778 h->fReadOffSet = ltot;; 1779 fclose(f);; 1780}; 1781 ; 1782//---- Dynamic Loading ---------------------------------------------------------; 1783 ; 1784////////////////////////////////////////////////////////////////////////////////; 1785/// Add a new directory to the dynamic path.; 1786 ; 1787void TSystem::AddDynamicPath(const char *); 1788{; 1789 AbstractMethod(""AddDynamicPath"");; 1790}; 1791 ; 1792////////////////////////////////////////////////////////////////////////////////; 1793/// Return the dynamic path (used to find shared libraries).; 1794 ; 1795const char *TSystem::GetDynamicPath(); 1796{; 1797 AbstractMethod(""GetDynamicPath"");; 1798 return nullptr;; 1799};",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:57198,Load,Loading,57198,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['Load'],['Loading']
Performance,"me) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTreeSQL&operator=(const TTreeSQL&); TTreeSQL&operator=(TTreeSQL&&); virtual voidTTree::OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeSQL.html:11761,Optimiz,OptimizeBaskets,11761,root/html602/TTreeSQL.html,https://root.cern,https://root.cern/root/html602/TTreeSQL.html,2,['Optimiz'],['OptimizeBaskets']
Performance,"me) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; voidgetCompIntList(const RooArgSet* nset, const RooArgSet* iset, RooAddModel::pRooArgList& compIntList, Int_t& code, const char* isetRangeName) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAddModel::CacheElem*getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:32390,Cache,CacheElem,32390,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,3,['Cache'],['CacheElem']
Performance,"me). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:23466,load,load,23466,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,4,['load'],['load']
Performance,"me); 143{; 144 // If the filename does not contain ""."" assume class is compiled in; 145 TString localname;; 146 bool fromFile = false;; 147 if (strchr(filename, '.') != nullptr) {; 148 //Interpret/compile filename via CINT; 149 localname = "".L "";; 150 localname += filename;; 151 gROOT->ProcessLine(localname);; 152 fromFile = true;; 153 }; 154 ; 155 //loop on all classes known to CINT to find the class on filename; 156 //that derives from TSelector; 157 const char *basename = gSystem->BaseName(filename);; 158 if (!basename) {; 159 ::Error(""TSelector::GetSelector"",""unable to determine the classname for file %s"", filename);; 160 return nullptr;; 161 }; 162 TString aclicmode,args,io;; 163 localname = gSystem->SplitAclicMode(basename,aclicmode,args,io);; 164 if (localname.Last('.') != kNPOS); 165 localname.Remove(localname.Last('.'));; 166 ; 167 // if a file was not specified, try to load the class via the interpreter;; 168 // this returns 0 (== failure) in the case the class is already in memory; 169 // but does not have a dictionary, so we just raise a flag for better; 170 // diagnostic in the case the class is not found in the CINT ClassInfo table.; 171 bool autoloaderr = false;; 172 if (!fromFile && gCling->AutoLoad(localname) != 1); 173 autoloaderr = true;; 174 ; 175 TClass *selCl = TClass::GetClass(localname);; 176 if (selCl) {; 177 // We have all we need.; 178 auto offset = selCl->GetBaseClassOffset(TSelector::Class());; 179 if (offset == -1) {; 180 // TSelector is not a based class.; 181 if (fromFile); 182 ::Error(""TSelector::GetSelector"",; 183 ""The class %s in file %s does not derive from TSelector."", localname.Data(), filename);; 184 else if (autoloaderr); 185 ::Error(""TSelector::GetSelector"", ""class %s could not be loaded"", filename);; 186 else; 187 ::Error(""TSelector::GetSelector"",; 188 ""class %s does not exist or does not derive from TSelector"", filename);; 189 return nullptr;; 190 }; 191 char *result = (char*)selCl->New();; 192 // By adding offset, we suppor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:6925,load,load,6925,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['load'],['load']
Performance,"me);; 1503 ; 1504 TClass *cl = nullptr;; 1505 if (normalized != name) cl = TClass::GetClass(normalized.c_str(),load,silent);; 1506 ; 1507 if (load && cl==nullptr) {; 1508 // Create an Emulated class for this container.; 1509 cl = gInterpreter->GenerateTClass(normalized.c_str(), kTRUE, silent);; 1510 }; 1511 ; 1512 return cl;; 1513}; 1514 ; 1515////////////////////////////////////////////////////////////////////////////////; 1516/// Return pointer to class with name. Obsolete, use TClass::GetClass directly; 1517 ; 1518TClass *TROOT::GetClass(const char *name, Bool_t load, Bool_t silent) const; 1519{; 1520 return TClass::GetClass(name,load,silent);; 1521}; 1522 ; 1523 ; 1524////////////////////////////////////////////////////////////////////////////////; 1525/// Return pointer to class from its name. Obsolete, use TClass::GetClass directly; 1526/// See TClass::GetClass; 1527 ; 1528TClass *TROOT::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t silent) const; 1529{; 1530 return TClass::GetClass(typeinfo,load,silent);; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Return address of color with index color.; 1535 ; 1536TColor *TROOT::GetColor(Int_t color) const; 1537{; 1538 TColor::InitializeColors();; 1539 TObjArray *lcolors = (TObjArray*) GetListOfColors();; 1540 if (!lcolors) return nullptr;; 1541 if (color < 0 || color >= lcolors->GetSize()) return nullptr;; 1542 TColor *col = (TColor*)lcolors->At(color);; 1543 if (col && col->GetNumber() == color) return col;; 1544 TIter next(lcolors);; 1545 while ((col = (TColor *) next())); 1546 if (col->GetNumber() == color) return col;; 1547 ; 1548 return nullptr;; 1549}; 1550 ; 1551////////////////////////////////////////////////////////////////////////////////; 1552/// Return a default canvas.; 1553 ; 1554TCanvas *TROOT::MakeDefCanvas() const; 1555{; 1556 return (TCanvas*)gROOT->ProcessLine(""TCanvas::MakeDefCanvas();"");; 1557}; 1558 ; 1559/////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:58957,load,load,58957,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,4,['load'],['load']
Performance,"me, const TVectorD &imageData, UInt_t width, TImagePalette *palette); Create an image depending on the values of imageData.; The size of the image is width X (imageData.fN / width).; For more information see function SetImage() which is called by; this constructor. TASImage(const TASImage& img); Image copy constructor. TASImage & operator=(const TASImage& img); Image assignment operator. ~TASImage(); Image destructor, clean up image and visual. const char * TypeFromMagicNumber(const char* file); Guess the file type from the first byte of file. void ReadImage(const char* file, TImage::EImageFileTypes type = TImage::kUnknown); Read specified image file.; The file type is determined by the file extension (the type argument is; ignored). It will attempt to append .gz and then .Z to the filename and; find such a file. If the filename ends with extension consisting of digits; only, it will attempt to find the file with this extension stripped; off. On success this extension will be used to load subimage from; the file with that number. Subimage is supported for GIF files; (ICO, BMP, CUR, TIFF, XCF to be supported in future).; For example,; i1 = TImage::Open(""anim.gif.0""); // read the first subimage; i4 = TImage::Open(""anim.gif.3""); // read the forth subimage. It is also possible to put XPM raw string (see also SetImageBuffer) as; the first input parameter (""filename""), such string is returned by; GetImageBuffer method. void WriteImage(const char* file, TImage::EImageFileTypes type = TImage::kUnknown); Write image to specified file.; If there is no file extension or if the file extension is unknown, the; type argument will be used to determine the file type. The quality and; compression is derived from the TAttImage values.; It's posiible to write image into an animated GIF file by specifying file; name as ""myfile.gif+"" of ""myfile.gif+NN"", where NN is delay of displaying; subimages during animation in 10ms seconds units.; If NN is ommitted the delay between subimages is zer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TASImage.html:20746,load,load,20746,root/html526/TASImage.html,https://root.cern,https://root.cern/root/html526/TASImage.html,1,['load'],['load']
Performance,"me, const char *title, InitializationOutput &&initInfo);  Private internal constructor. ;  . Static Private Member Functions; static std::unique_ptr< RooSimultaneous::InitializationOutput > initialize (std::string const &name, RooAbsCategoryLValue &inIndexCat, std::map< std::string, RooAbsPdf * > const &pdfMap);  . Private Attributes; std::unique_ptr< RooArgSet > _indexCatSet;  ! Index category wrapped in a RooArgSet if needed internally ;  . Friends; class RooSimGenContext;  ; class RooSimSplitGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:75703,Cache,CacheMode,75703,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['Cache'],['CacheMode']
Performance,"me.; Here, <rver> is the root version in integer form, e.g. 53403, and <build> a; string includign version, architecture and compiler version, e.g.; '53403_linuxx8664gcc_gcc46' . Int_t GetSessionStatus(); Return the status of this session:; 0 idle; 1 running; 2 being terminated (currently unused); 3 queued; 4 idle timed-out (not set in here but in TIdleTOTimer::Notify); This is typically run in the reader thread, so access needs to be protected. Int_t UpdateSessionStatus(Int_t xst = -1); Update the session status in the relevant file. The status is taken from; GetSessionStatus() unless xst >= 0, in which case xst is used.; Return 0 on success, -errno if the file could not be opened. Bool_t IsIdle(); Return the idle status. void SetIdle(Bool_t st = kTRUE); Change the idle status. Bool_t IsWaiting(); Return kTRUE if the session is waiting for the OK to start processing. Int_t WaitingQueries(); Return the number of waiting queries. Int_t QueueQuery(TProofQueryResult* pq); Add a query to the waiting list; Returns the number of queries in the list. TProofQueryResult * NextQuery(); Get the next query from the waiting list.; The query is removed from the list. Int_t CleanupWaitingQueries(Bool_t del = kTRUE, TList* qls = 0); Cleanup the waiting queries list. The objects are deleted if 'del' is true.; If 'qls' is non null, only objects in 'qls' are removed.; Returns the number of cleanup queries. void SetLastMsg(const char* lastmsg); Set the message to be sent back in case of exceptions. void SetLastEntry(Long64_t lastentry); Set the last entry before exception. Long_t GetVirtMemMax(); VirtMemMax getter. Long_t GetResMemMax(); ResMemMax getter. Float_t GetMemHWM(); MemHWM getter. Float_t GetMemStop(); MemStop getter. void GetLocalServer(TString& dsrv); Extract LOCALDATASERVER info in 'dsrv'. void FilterLocalroot(TString& path, const char* url = ""root://dum/""); If 'path' is local and 'dsrv' is Xrootd, apply 'path.Localroot' settings,; if any.; The final path via the server is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:31712,Queue,QueueQuery,31712,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,3,['Queue'],['QueueQuery']
Performance,"me.c_str());; 5793 i->SetClass(nullptr);; 5794 i->GetElements()->Delete();; 5795 TStreamerElement *fel = R__CreateEmulatedElement(""first"", firstname, 0, silent);; 5796 Int_t size = 0;; 5797 if (fel) {; 5798 i->GetElements()->Add( fel );; 5799 ; 5800 size = fel->GetSize();; 5801 Int_t sp = sizeof(void *);; 5802 //align the non-basic data types (required on alpha and IRIX!!); 5803 if (size%sp != 0) size = size - size%sp + sp;; 5804 } else {; 5805 delete i;; 5806 return 0;; 5807 }; 5808 if (hint_pair_offset); 5809 size = hint_pair_offset;; 5810 TStreamerElement *second = R__CreateEmulatedElement(""second"", secondname, size, silent);; 5811 if (second) {; 5812 i->GetElements()->Add( second );; 5813 } else {; 5814 delete i;; 5815 return 0;; 5816 }; 5817 Int_t oldlevel = gErrorIgnoreLevel;; 5818 // Hide the warning about the missing pair dictionary.; 5819 gErrorIgnoreLevel = kError;; 5820 i->BuildCheck(nullptr, kFALSE); // Skipping the loading part (it would leads to infinite recursion on this very routine); 5821 gErrorIgnoreLevel = oldlevel;; 5822 // In the state emulated, BuildOld would recalculate the offset and undo the offset update.; 5823 // Note: we should consider adding a new state just for this (the hints indicates that we are mapping a compiled class but; 5824 // then we would have to investigate all use of the state with <= and >= condition to make sure they are still appropriate).; 5825 if (hint_pair_size) {; 5826 i->GetClass()->SetClassSize(hint_pair_size);; 5827 i->GetClass()->fIsSyntheticPair = kTRUE;; 5828 }; 5829 ; 5830 i->BuildOld();; 5831 ; 5832 if (hint_pair_size); 5833 i->GetClass()->SetClassSize(hint_pair_size);; 5834 return i;; 5835}; 5836 ; 5837TVirtualStreamerInfo *TStreamerInfo::GenerateInfoForPair(const std::string &pairclassname, bool silent, size_t hint_pair_offset, size_t hint_pair_size); 5838{; 5839 const static int pairlen = strlen(""pair<"");; 5840 if (pairclassname.compare(0, pairlen, ""pair<"") != 0) {; 5841 if (!silent); 5842 Error(""GenerateI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:233349,load,loading,233349,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['loading']
Performance,"me4.GetYaxis().SetTitleOffset(1.4); frame4.Draw(); c.cd(6); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.4); frame5.Draw(); ; c.SaveAs(""rf102_dataimport.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_dh) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #0 because y cannot accommodate the value 14.424; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #3 because y cannot accommodate the value -12.0022; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #5 because y cannot accommodate the value 13.8261; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #6 because y cannot accommodate the value -14.9925; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 36 out-of-range events; [#1] INFO:DataHandling -- RooDataSet::read: reading file rf102_testData.txt; [#1] INFO:DataHandling -- RooDataSet::read: read 64 events (ignored 0 out of range events); DataStore dataset (rf102_testData.txt); Contains 64 entries; Observables: ; 1) x = 9.46654 L(-10 - 10) ""x""; 2) y = 0.0174204 L(-10 - 10) ""y""; 3) blindState = Normal(idx = 0); ""Blinding State""; 1) RooRealVar:: y = 0.0106407; 2) RooRealVar:: x = -0.79919; 1) RooRealVar:: x = 0.0106407; 2) RooRealVar:: y = -0.79919; 3) RooCategory:: blindState = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf102__dataimport_8py.html:6693,load,loadValues,6693,doc/master/rf102__dataimport_8py.html,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8py.html,1,['load'],['loadValues']
Performance,"me6[26]; vars_time6[27]; vars_time6[28]; vars_time6[29]; vars_time7[0]; vars_time7[1]; vars_time7[2]; vars_time7[3]; vars_time7[4]; vars_time7[5]; vars_time7[6]; vars_time7[7]; vars_time7[8]; vars_time7[9]; vars_time7[10]; vars_time7[11]; vars_time7[12]; vars_time7[13]; vars_time7[14]; vars_time7[15]; vars_time7[16]; vars_time7[17]; vars_time7[18]; vars_time7[19]; vars_time7[20]; vars_time7[21]; vars_time7[22]; vars_time7[23]; vars_time7[24]; vars_time7[25]; vars_time7[26]; vars_time7[27]; vars_time7[28]; vars_time7[29]; vars_time8[0]; vars_time8[1]; vars_time8[2]; vars_time8[3]; vars_time8[4]; vars_time8[5]; vars_time8[6]; vars_time8[7]; vars_time8[8]; vars_time8[9]; vars_time8[10]; vars_time8[11]; vars_time8[12]; vars_time8[13]; vars_time8[14]; vars_time8[15]; vars_time8[16]; vars_time8[17]; vars_time8[18]; vars_time8[19]; vars_time8[20]; vars_time8[21]; vars_time8[22]; vars_time8[23]; vars_time8[24]; vars_time8[25]; vars_time8[26]; vars_time8[27]; vars_time8[28]; vars_time8[29]; vars_time9[0]; vars_time9[1]; vars_time9[2]; vars_time9[3]; vars_time9[4]; vars_time9[5]; vars_time9[6]; vars_time9[7]; vars_time9[8]; vars_time9[9]; vars_time9[10]; vars_time9[11]; vars_time9[12]; vars_time9[13]; vars_time9[14]; vars_time9[15]; vars_time9[16]; vars_time9[17]; vars_time9[18]; vars_time9[19]; vars_time9[20]; vars_time9[21]; vars_time9[22]; vars_time9[23]; vars_time9[24]; vars_time9[25]; vars_time9[26]; vars_time9[27]; vars_time9[28]; vars_time9[29]; prepared DATA LOADER ; Building recurrent keras model using a LSTM layer; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 10, 30) 0 ; ; lstm (LSTM) (None, 10, 10) 1640 ; ; flatten (Flatten) (None, 100) 0 ; ; dense (Dense) (None, 64) 6464 ; ; dense_1 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 8234 (32.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:11381,LOAD,LOADER,11381,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['LOAD'],['LOADER']
Performance,"me::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; TGMenuBar*fMenuBarmenu bar; TGPopupMenu*fMenuFavorites""Favorites"" menu entry; TGPopupMenu*fMenuFile""File"" menu entry; TGPopupMenu*fMenuHelp""Help"" menu entry; TGPopupMenu*fMenuTools""Tools"" menu entry; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Int_tfNbFavoritesnumber of favorites in the menu; Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TGPictureButton*fReload""Reload Page"" picture button; TStringTGMainFrame::fResourceNameWM resource name; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGStatusBar*fStatusBarstatus bar; TGPictureButton*fStop""Stop Loading"" picture button; TGTextEntry*fURLcurrent URL text entry; TGTextBuffer*fURLBuftext buffer for current URL text entry; TGVerticalFrame*fVerticalFramemain vertical frame; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHtmlBrowser.html:20561,Load,Loading,20561,root/html528/TGHtmlBrowser.html,https://root.cern,https://root.cern/root/html528/TGHtmlBrowser.html,6,['Load'],['Loading']
Performance,"me; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_allVarsPdfAll pdf variables; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; Double_t*_fracThresh[_numPdf] Fraction threshold array; TList_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_t_haveIdxProtoFlag set if generation of index is requested; RooAbsCategoryLValue*_idxCatClone of index category; TString_idxCatNameName of index category; RooArgSet*_idxCatSetOwner of index category components; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; Int_t_numPdfNumber of generated PDFs; const RooSimultaneous*_pdfOriginal PDF; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*_prototypePrototype data set; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; TIterator*_proxyIterIterator over pdf proxies; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooSimGenContext.html:8281,load,load,8281,root/html530/RooSimGenContext.html,https://root.cern,https://root.cern/root/html530/RooSimGenContext.html,1,['load'],['load']
Performance,"meElementPack() [2/2]. TGFrameElementPack::TGFrameElementPack ; (; TGFrame * ; frame, . TGLayoutHints * ; lh = nullptr, . Float_t ; weight = 1 . ). inline . Definition at line 31 of file TGPack.h. Member Function Documentation. ◆ Class(). static TClass * TGFrameElementPack::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGFrameElementPack::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGFrameElementPack::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 34 of file TGPack.h. ◆ DeclFileName(). static const char * TGFrameElementPack::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 34 of file TGPack.h. ◆ IsA(). TClass * TGFrameElementPack::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGFrameElement.; Definition at line 34 of file TGPack.h. ◆ operator=(). TGFrameElementPack & TGFrameElementPack::operator= ; (; const TGFrameElementPack & ; ). privatedelete . ◆ Streamer(). void TGFrameElementPack::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGFrameElement. ◆ StreamerNVirtual(). void TGFrameElementPack::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 34 of file TGPack.h. Member Data Documentation. ◆ fSplitFE. TGFrameElementPack* TGFrameElementPack::fSplitFE. ! cached variable for optimisation ; Definition at line 29 of file TGPack.h. ◆ fWeight. Float_t TGFrameElementPack::fWeight. relative weight ; Definition at line 28 of file TGPack.h. Libraries for TGFrameElementPack:. [legend]; The documentation for this class was generated from the following file:; gui/gui/inc/TGPack.h. TGFrameElementPack. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:15 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFrameElementPack.html:12629,cache,cached,12629,doc/master/classTGFrameElementPack.html,https://root.cern,https://root.cern/doc/master/classTGFrameElementPack.html,1,['cache'],['cached']
Performance,"meHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tfIsLocalTRUE if the path points to this host; TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfLocalPrefixif fIsLocal, prefix to be prepend locally; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with wr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetSystem.html:19542,Cache,Cache,19542,root/html528/TNetSystem.html,https://root.cern,https://root.cern/root/html528/TNetSystem.html,3,['Cache'],['Cache']
Performance,"meLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; char*_value[_len] Value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsString(); Destructor. const char* getVal() const; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy cache of anothe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsString.html:19198,cache,cached,19198,root/html528/RooAbsString.html,https://root.cern,https://root.cern/root/html528/RooAbsString.html,2,['cache'],['cached']
Performance,"meLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; char*_value[_len] Value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsString(); Destructor. const char* getVal() const; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* value); Equality operator comparing with a TString. Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy cache of another",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsString.html:19077,cache,cached,19077,root/html526/RooAbsString.html,https://root.cern,https://root.cern/root/html526/RooAbsString.html,1,['cache'],['cached']
Performance,"mePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooAbsTestStatistic;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:57617,Cache,CacheMode,57617,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,1,['Cache'],['CacheMode']
Performance,"meWidth () const;  ; Bool_t GetRnrBarrelFrame () const;  ; Bool_t GetRnrEndCapFrame () const;  ; void GetRnrFrame (Bool_t &e, Bool_t &b) const;  ; TClass * IsA () const override;  ; void SetFrameTransparency (Char_t x);  ; void SetFrameWidth (Float_t w);  ; void SetRnrBarrelFrame (Bool_t r);  ; void SetRnrEndCapFrame (Bool_t r);  ; void SetRnrFrame (Bool_t e, Bool_t b);  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TEveCaloViz;  TEveCaloViz (TEveCaloData *data=nullptr, const char *n=""TEveCaloViz"", const char *t="""");  ;  ~TEveCaloViz () override;  Destructor. ;  ; Bool_t AssertCellIdCache () const;  Assert cell id cache is ok. ;  ; TEveRGBAPalette * AssertPalette ();  Make sure the TEveRGBAPalette pointer is not null. ;  ; Bool_t CellInEtaPhiRng (TEveCaloData::CellData_t &) const;  Returns true if given cell is in the ceta phi range. ;  ; virtual void CellSelectionChanged ();  ; void DataChanged ();  Update setting and cache on data changed. ;  ; TEveElement * ForwardEdit () override;  Management of selection state and ownership of selected cell list is done in TEveCaloData. ;  ; TEveElement * ForwardSelection () override;  Management of selection state and ownership of selected cell list is done in TEveCaloData. ;  ; Bool_t GetAutoRange () const;  ; Float_t GetBackwardEndCapPos () const;  ; Float_t GetBarrelRadius () const;  ; TEveCaloData * GetData () const;  ; Color_t GetDataSliceColor (Int_t slice) const;  Get slice color from data. ;  ; Float_t GetDataSliceThreshold (Int_t slice) const;  Get threshold for given slice. ;  ; Float_t GetEndCapPos () const;  ; Float_t GetEta () const;  ; Float_t GetEtaMax () const;  ; Float_t GetEtaMin () const;  ; Float_t GetEtaRng () const;  ; Float_t GetForwardEndCapPos () const;  ; Float_t GetMaxTowerH () const;  ; Float_t GetMaxVal () const;  ; Float_t GetMaxValAbs () const;  ; TEveRGBAPalette * GetPalette () const;  ; Float_t G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCalo3D.html:1837,cache,cache,1837,doc/master/classTEveCalo3D.html,https://root.cern,https://root.cern/doc/master/classTEveCalo3D.html,1,['cache'],['cache']
Performance,"mebase_ifo.denom);; 412 ; 413 t->tv_sec = now / 1000000000;; 414 t->tv_nsec = now % 1000000000;; 415 return 0;; 416 }; 417 return -1; /* EINVAL - Clock ID is unknown */; 418}; 419 ; 420/* if clock_gettime is declared, then __CLOCK_AVAILABILITY will be defined */; 421#if defined(__CLOCK_AVAILABILITY); 422/* If we compiled with Mac OSX 10.12 or later, then clock_gettime will be; 423 * declared but it may be NULL at runtime. So we need to check before using; 424 * it. */; 425static int; 426_civet_safe_clock_gettime(int clk_id, struct timespec *t); 427{; 428 if (clock_gettime) {; 429 return clock_gettime(clk_id, t);; 430 }; 431 return _civet_clock_gettime(clk_id, t);; 432}; 433#define clock_gettime _civet_safe_clock_gettime; 434#else; 435#define clock_gettime _civet_clock_gettime; 436#endif; 437 ; 438#endif; 439 ; 440 ; 441#if !defined(_WIN32); 442/* Unix might return different error codes indicating to try again.; 443 * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:15702,optimiz,optimize,15702,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['optimiz'],['optimize']
Performance,"mecycle, Bool_t printError=false, const char *funcname=""GetDirectory"")TDirectoryvirtual; GetDirLevel()TROOTstatic; GetDocDir()TROOTstatic; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetEditHistograms() constTROOTinline; GetEditorMode() constTROOTinline; GetEtcDir()TROOTstatic; GetExtraInterpreterArgs()TROOTstatic; GetFile() const overrideTROOTinlinevirtual; GetFile(const char *name) constTROOT; GetForceStyle() constTROOTinline; GetFunction(const char *name) constTROOT; GetFunctionTemplate(const char *name)TROOT; GetGeometry(const char *name) constTROOT; GetGitBranch() constTROOTinline; GetGitCommit() constTROOTinline; GetGitDate()TROOT; GetGlobal(const char *name, Bool_t load=kFALSE) constTROOT; GetGlobal(const TObject *obj, Bool_t load=kFALSE) constTROOT; GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)TROOT; GetGlobalFunctions()TROOTprotected; GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)TROOT; GetIconName() constTObjectvirtual; GetIconPath()TROOTstatic; GetIncludeDir()TROOTstatic; GetInterpreter() constTROOTinline; GetKey(const char *, Short_t=9999) constTDirectoryinlinevirtual; GetLibDir()TROOTstatic; GetList() constTDirectoryinlinevirtual; GetListOfBrowsables() constTROOTinline; GetListOfBrowsers() constTROOTinline; GetListOfCanvases() constTROOTinline; GetListOfClasses() constTROOTinline; GetListOfClassGenerators() constTROOTinline; GetListOfCleanups() constTROOTinline; GetListOfClosedObjects() constTROOTinline; GetListOfColors() constTROOTinline; GetListOfDataSets() constTROOTinline; GetListOfEnums(Bool_t load=kFALSE)TROOT; GetListOfFiles() constTROOTinline; GetListOfFunctionOverloads(const char *name) constTROOT; GetListOfFunctions() constTROOTinline; GetListOfFunctionTemplates()TROOT; GetListOfGeometries() constTROOTinline; GetListOfGlobalFunctions(Bool_t load=kFALSE)TROOT; GetListOfGlobals(Bool_t load=kFALSE)TROOT; GetListOfKeys() constTDirectoryinline",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT-members.html:7650,load,load,7650,doc/master/classTROOT-members.html,https://root.cern,https://root.cern/doc/master/classTROOT-members.html,1,['load'],['load']
Performance,"mecycle. ;  ; template<class T > ; T * Get (const char *namecycle);  See documentation of TDirectoryFile::Get(const char *namecycle) ;  ; virtual Int_t GetBufferSize () const;  ; virtual TDirectory * GetDirectory (const char *namecycle, Bool_t printError=false, const char *funcname=""GetDirectory"");  Find a directory using apath. ;  ; virtual TFile * GetFile () const;  ; virtual TKey * GetKey (const char *, Short_t=9999) const;  ; virtual TList * GetList () const;  ; virtual TList * GetListOfKeys () const;  ; TObject * GetMother () const;  ; TDirectory * GetMotherDir () const;  ; virtual Int_t GetNbytesKeys () const;  ; virtual Int_t GetNkeys () const;  ; template<class T > ; void GetObject (const char *namecycle, T *&ptr);  Get an object with proper type checking. ;  ; virtual void * GetObjectChecked (const char *namecycle, const char *classname);  See documentation of TDirectory::GetObjectCheck(const char *namecycle, const TClass *cl) ;  ; virtual void * GetObjectChecked (const char *namecycle, const TClass *cl);  Return pointer to object identified by namecycle if and only if the actual object is a type suitable to be stored as a pointer to a ""expectedClass"" If expectedClass is null, no check is performed. ;  ; virtual void * GetObjectUnchecked (const char *namecycle);  Return pointer to object identified by namecycle. ;  ; virtual const char * GetPath () const;  Returns the full path of the directory. ;  ; virtual const char * GetPathStatic () const;  Returns the full path of the directory. ;  ; virtual Long64_t GetSeekDir () const;  ; virtual Long64_t GetSeekKeys () const;  ; virtual Long64_t GetSeekParent () const;  ; TUUID GetUUID () const;  ; TClass * IsA () const override;  ; Bool_t IsBuilt () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; virtual Bool_t IsModified () const;  ; virtual Bool_t IsWritable () const;  ; void ls (Option_t *option="""") const over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTDirectory.html:4842,perform,performed,4842,doc/v632/classTDirectory.html,https://root.cern,https://root.cern/doc/v632/classTDirectory.html,2,['perform'],['performed']
Performance,"med to be the name of a TExec object.; When a file is connected, the dictionary of the classes on the file; is read in memory (see TFile::ReadStreamerInfo). When the TStreamerElement; object is read, a TExec object is automatically created with the name; specified after the keywork ""EXEC:"" in case a TExec with a same name does; not already exist.; The action to be executed via this TExec can be specified with:; - a call to the TExec constructor, if the constructor is called before; opening the file.; - a call to TExec::SetAction at any time.; One can compute a pointer to an existing TExec with a name with:; TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand); where; - actionCommand is a string containing a CINT instruction. Examples:; myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");. When a TRef is dereferenced via TRef::GetObject, its TExec will be; automatically executed. In the function/script being executed, one or more; of the following actions can be executed:; - load a file containing the referenced object. This function typically; looks in the file catalog (GRID).; - compute a pointer to the referenced object and communicate this pointer; back to the calling function TRef::GetObject via:; TRef::SetStaticObject(object).; When the TExec is called, it has access to the dereferencing TRef; by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this""; before the call to TExec). This can be useful for accessing the TRef's; fUniqueID.; As soon as an object is returned to GetObject, the fUniqueID of the TRef is set; to the fUniqueID of the referenced object. At the next call to GetObject,; the pointer stored in fPid:fObjects[fUniqueID] will be returned directly. An example of action on demand is shown in $ROOTSYS/test/Event.h with; the member:; TRef fWebHistogram; //EXEC:GetWebHistogram; When calling fWebHistogram.GetObject(), the function GetObject; will automatically invoke a script GetWebHistogram.C via the int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRef.html:6388,load,load,6388,root/html528/TRef.html,https://root.cern,https://root.cern/root/html528/TRef.html,6,['load'],['load']
Performance,"med)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 10, 30) 0 ; ; lstm (LSTM) (None, 10, 10) 1640 ; ; flatten (Flatten) (None, 100) 0 ; ; dense (Dense) (None, 64) 6464 ; ; dense_1 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 8234 (32.16 KB); Trainable params: 8234 (32.16 KB); Non-trainable params: 0 (0.00 Byte); ________________________________________________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:10736,perform,performance,10736,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['perform'],['performance']
Performance,"med)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Running with nthreads = 4; --- RNNClassification : Using input file: time_data_t10_d30.root; number of variables is 300; vars_time0[0]; vars_time0[1]; vars_time0[2]; vars_time0[3]; vars_time0[4]; vars_time0[5]; vars_time0[6]; vars_time0[7]; vars_time0[8]; vars_time0[9]; vars_time0[10]; vars_time0[11]; vars_time0[12]; vars_time0[13]; vars_time0[14]; vars_time0[15]; vars_time0[16]; vars_time0[17]; vars_time0[18]; vars_time0[19]; vars_time0[20]; vars_time0[21]; vars_time0[22]; vars_time0[23]; vars_time0[24]; vars_time0[25]; vars_time0[26]; vars_time0[27]; vars_time0[28]; vars_time0[29",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:6200,perform,performance,6200,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['perform'],['performance']
Performance,"membername) const;  return offset for member name. ;  ; Short_t GetDeclFileLine () const;  ; const char * GetDeclFileName () const;  Return name of the file containing the declaration of this class. ;  ; ROOT::DelFunc_t GetDelete () const;  Return the wrapper around delete ThiObject. ;  ; ROOT::DelArrFunc_t GetDeleteArray () const;  Return the wrapper around delete [] ThiObject. ;  ; ROOT::DesFunc_t GetDestructor () const;  Return the wrapper around the destructor. ;  ; ROOT::DirAutoAdd_t GetDirectoryAutoAdd () const;  Return the wrapper around the directory auto add function. ;  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; UInt_t GetHeapInstanceCount () const;  ; Short_t GetImplFileLine () const;  ; const char * GetImplFileName () const;  ; UInt_t GetInstanceCount () const;  ; TVirtualIsAProxy * GetIsAProxy () const;  Return the proxy implementing the IsA functionality. ;  ; TVirtualStreamerInfo * GetLastReadInfo () const;  ; TList * GetListOfAllPublicDataMembers (Bool_t load=kTRUE);  Returns a list of all public data members of this class and its base classes. ;  ; const TList * GetListOfAllPublicMethods (Bool_t load=kTRUE);  Returns a list of all public methods of this class and its base classes. ;  ; TList * GetListOfBases ();  Return list containing the TBaseClass(es) of a class. ;  ; TList * GetListOfDataMembers (Bool_t load=kTRUE);  Return list containing the TDataMembers of a class. ;  ; TList * GetListOfEnums (Bool_t load=kTRUE);  Return a list containing the TEnums of a class. ;  ; TList * GetListOfFunctionTemplates (Bool_t load=kTRUE);  Return TListOfFunctionTemplates for a class. ;  ; TCollection * GetListOfMethodOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TList * GetListOfMethods (Bool_t load=kTRUE);  Return list containing the TMethods of a class. ;  ; TList * GetListOfRealData () const;  ; TList * GetListOfUsingDataMembers (Bool_t load=kTRUE);  Return list containing the TDataMembers of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQClass.html:11182,load,load,11182,doc/master/classTQClass.html,https://root.cern,https://root.cern/doc/master/classTQClass.html,3,['load'],['load']
Performance,"members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods(). TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:34360,load,loaded,34360,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,1,['load'],['loaded']
Performance,"memory region ;  ; Long64_t fSize {0};  Total file size (sum of the size of the chunks) ;  ; Long64_t fSysOffset {0};  Seek offset in file. ;  ;  Protected Attributes inherited from TFile; TArchiveFile * fArchive {nullptr};  !Archive file from which we read this file ;  ; Long64_t fArchiveOffset {0};  !Offset at which file starts in archive ;  ; TFileOpenHandle * fAsyncHandle {nullptr};  !For proper automatic cleanup ;  ; EAsyncOpenStatus fAsyncOpenStatus {kAOSNotAsync};  !Status of an asynchronous open request ;  ; Long64_t fBEGIN {0};  First used byte in file. ;  ; Long64_t fBytesRead {0};  Number of bytes read from this file. ;  ; Long64_t fBytesReadExtra {0};  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Long64_t fBytesWrite {0};  Number of bytes written to this file. ;  ; TFileCacheRead * fCacheRead {nullptr};  !Pointer to the read cache (if any) ;  ; TMap * fCacheReadMap {nullptr};  !Pointer to the read cache (if any) ;  ; TFileCacheWrite * fCacheWrite {nullptr};  !Pointer to the write cache (if any) ;  ; TArrayC * fClassIndex {nullptr};  !Index of TStreamerInfo classes written to this file ;  ; Int_t fCompress {0};  Compression level and algorithm. ;  ; Int_t fD {-1};  File descriptor. ;  ; Long64_t fEND {0};  Last used byte in file. ;  ; TList * fFree {nullptr};  Free segments linked list table. ;  ; bool fGlobalRegistration = true;  ! if true, bypass use of global lists ;  ; TList * fInfoCache {nullptr};  !Cached list of the streamer infos in this file ;  ; Bool_t fInitDone {kFALSE};  !True if the file has been initialized ;  ; Bool_t fIsArchive {kFALSE};  !True if this is a pure archive file ;  ; Bool_t fIsPcmFile {kFALSE};  !True if the file is a ROOT pcm file. ;  ; Bool_t fIsRootFile {kTRUE};  !True is this is a ROOT file, raw file otherwise ;  ; Bool_t fMustFlush {kTRUE};  !True if the file buffers must be flushed ;  ; Int_t fNbytesFree {0};  Number of bytes for free segments structure. ;  ; Int_t fNbytesInfo {0};  Number of bytes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:37866,cache,cache,37866,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,15,['cache'],['cache']
Performance,"memory we are still below MaxVirtualsize. TTree* MergeTrees(TList* list, Option_t* option = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:114220,cache,cache,114220,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,1,['cache'],['cache']
Performance,"memory we are still below MaxVirtualsize. TTree* MergeTrees(TList* list, Option_t* option = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTree.html:115677,cache,cache,115677,root/html602/TTree.html,https://root.cern,https://root.cern/root/html602/TTree.html,2,['cache'],['cache']
Performance,"ment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: assembly.C.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; namechar name[80]Definition TGX11.cxx:110; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; Note that components cannot be declared as ""overlapping"" and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in **TGeo** has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:52995,perform,performance,52995,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,2,['perform'],"['performance', 'performing']"
Performance,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Roo2DKeysPdf&operator=(const Roo2DKeysPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DKeysPdf.html:23212,optimiz,optimizeCacheMode,23212,root/html602/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html602/Roo2DKeysPdf.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBMixDecay&operator=(const RooBMixDecay&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBMixDecay.html:23705,optimiz,optimizeCacheMode,23705,root/html602/RooBMixDecay.html,https://root.cern,https://root.cern/root/html602/RooBMixDecay.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBernstein&operator=(const RooBernstein&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBernstein.html:23322,optimiz,optimizeCacheMode,23322,root/html602/RooBernstein.html,https://root.cern,https://root.cern/root/html602/RooBernstein.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCachedPdf&operator=(const RooCachedPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedPdf.html:23295,optimiz,optimizeCacheMode,23295,root/html602/RooCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooCachedPdf.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooChebychev&operator=(const RooChebychev&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChebychev.html:22853,optimiz,optimizeCacheMode,22853,root/html602/RooChebychev.html,https://root.cern,https://root.cern/root/html602/RooChebychev.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExtendPdf&operator=(const RooExtendPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendPdf.html:23474,optimiz,optimizeCacheMode,23474,root/html602/RooExtendPdf.html,https://root.cern,https://root.cern/root/html602/RooExtendPdf.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooLognormal&operator=(const RooLognormal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLognormal.html:23170,optimiz,optimizeCacheMode,23170,root/html602/RooLognormal.html,https://root.cern,https://root.cern/root/html602/RooLognormal.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNDKeysPdf&operator=(const RooNDKeysPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNDKeysPdf.html:23789,optimiz,optimizeCacheMode,23789,root/html602/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooNDKeysPdf.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Roo2DKeysPdf.html:21467,optimiz,optimizeCacheMode,21467,root/html526/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html526/Roo2DKeysPdf.html,130,['optimiz'],['optimizeCacheMode']
Performance,"ment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsAnaConvPdf.html:24332,optimiz,optimizeCacheMode,24332,root/html532/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsAnaConvPdf.html,20,['optimiz'],['optimizeCacheMode']
Performance,"ment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooGaussModel&operator=(const RooGaussModel&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGaussModel.html:23813,optimiz,optimizeCacheMode,23813,root/html602/RooGaussModel.html,https://root.cern,https://root.cern/root/html602/RooGaussModel.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooTruthModel&operator=(const RooTruthModel&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTruthModel.html:23919,optimiz,optimizeCacheMode,23919,root/html602/RooTruthModel.html,https://root.cern,https://root.cern/root/html602/RooTruthModel.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ment->TestBit(TStreamerElement::kWrite)) {; 149 if (((TBufferFile&)b).PeekDataCache()==0) {; 150 Warning(""WriteBuffer"",""Skipping %s::%s because the cache is missing."",GetName(),aElement->GetName());; 151 } else {; 152 if (gDebug > 1) {; 153 printf(""WriteBuffer, class:%s, name=%s, fType[%d]=%d,""; 154 "" %s, bufpos=%d, arr=%p, eoffset=%d, Redirect=%p\n"",; 155 fClass->GetName(),aElement->GetName(),i,compinfo[i]->fType,; 156 aElement->ClassName(),b.Length(),arr[0], eoffset,((TBufferFile&)b).PeekDataCache()->GetObjectAt(0));; 157 }; 158 WriteBufferAux(b,*((TBufferFile&)b).PeekDataCache(),compinfo,i,i+1,narr,eoffset, arrayMode);; 159 }; 160 continue;; 161 } else {; 162 if (gDebug > 1) {; 163 printf(""WriteBuffer, class:%s, name=%s, fType[%d]=%d,""; 164 "" %s, bufpos=%d, arr=%p, eoffset=%d, not a write rule, skipping.\n"",; 165 fClass->GetName(),aElement->GetName(),i,compinfo[i]->fType,; 166 aElement->ClassName(),b.Length(),arr[0], eoffset);; 167 }; 168 // The rule was a cached element for a read, rule, the real offset is in the; 169 // next element (the one for the rule itself).; 170 if (aElement->TestBit(TStreamerElement::kRepeat)) continue;; 171 ioffset = eoffset+compinfo[i]->fOffset;; 172 continue;; 173 }; 174 }; 175 ; 176 if (gDebug > 1) {; 177 printf(""WriteBuffer, class:%s, name=%s, fType[%d]=%d, %s, ""; 178 ""bufpos=%d, arr=%p, offset=%d\n"",; 179 fClass->GetName(),aElement->GetName(),i,compinfo[i]->fType,aElement->ClassName(),; 180 b.Length(),arr[0],ioffset);; 181 }; 182 ; 183 switch (compinfo[i]->fType+typeOffset) {; 184 // In this switch we intentionally use 'continue' instead of; 185 // 'break' to avoid running the 2nd switch (see later in this; 186 // function).; 187 ; 188 case TStreamerInfo::kBool: WriteBasicType(Bool_t); continue;; 189 case TStreamerInfo::kChar: WriteBasicType(Char_t); continue;; 190 case TStreamerInfo::kShort: WriteBasicType(Short_t); continue;; 191 case TStreamerInfo::kInt: WriteBasicType(Int_t); continue;; 192 case TStreamerInfo::kLong: WriteBasicT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html:5604,cache,cached,5604,doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,1,['cache'],['cached']
Performance,"ment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxyRooAbsMoment::_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_tRooAbsMoment::_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsMoment::_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxyRooAbsMoment::_xObservable; RooRealProxy_xfX*F ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFirstMoment(); Default constructor. Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFirstMoment.html:35041,cache,cache,35041,root/html534/RooFirstMoment.html,https://root.cern,https://root.cern/root/html534/RooFirstMoment.html,2,['cache'],['cache']
Performance,"ment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxyRooAbsMoment::_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_tRooAbsMoment::_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsMoment::_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxyRooAbsMoment::_xObservable; RooRealProxy_xfX*F ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMoment(); Default constructor. RooMomen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMoment.html:35127,cache,cache,35127,root/html534/RooMoment.html,https://root.cern,https://root.cern/root/html534/RooMoment.html,2,['cache'],['cache']
Performance,"mental::Internal::RPageSourceFile. ◆ LoadPage() [1/2]. ROOT::Experimental::Internal::RPageRef ROOT::Experimental::Internal::RPageSource::LoadPage ; (; ColumnHandle_t ; columnHandle, . NTupleSize_t ; globalIndex . ). virtual . Allocates and fills a page that contains the index-th element. ; The default implementation searches the page and calls LoadPageImpl(). Returns a default-constructed RPage for suppressed columns. ; Reimplemented in ROOT::Experimental::Internal::RPageSourceFriends.; Definition at line 319 of file RPageStorage.cxx. ◆ LoadPage() [2/2]. ROOT::Experimental::Internal::RPageRef ROOT::Experimental::Internal::RPageSource::LoadPage ; (; ColumnHandle_t ; columnHandle, . RClusterIndex ; clusterIndex . ). virtual . Another version of LoadPage that allows to specify cluster-relative indexes. ; Returns a default-constructed RPage for suppressed columns. ; Reimplemented in ROOT::Experimental::Internal::RPageSourceFriends.; Definition at line 353 of file RPageStorage.cxx. ◆ LoadPageImpl(). virtual RPageRef ROOT::Experimental::Internal::RPageSource::LoadPageImpl ; (; ColumnHandle_t ; columnHandle, . const RClusterInfo & ; clusterInfo, . ClusterSize_t::ValueType ; idxInCluster . ). protectedpure virtual . Implemented in ROOT::Experimental::Internal::RPageSourceDaos, ROOT::Experimental::Internal::RPageSourceFile, and ROOT::Experimental::Internal::RPageSourceFriends. ◆ LoadSealedPage(). virtual void ROOT::Experimental::Internal::RPageSource::LoadSealedPage ; (; DescriptorId_t ; physicalColumnId, . RClusterIndex ; clusterIndex, . RSealedPage & ; sealedPage . ). pure virtual . Read the packed and compressed bytes of a page into the memory buffer provided by sealedPage. ; The sealed page can be used subsequently in a call to RPageSink::CommitSealedPage. The fSize and fNElements member of the sealedPage parameters are always set. If sealedPage.fBuffer is nullptr, no data will be copied but the returned size information can be used by the caller to allocate a large enou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:15835,Load,LoadPageImpl,15835,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['Load'],['LoadPageImpl']
Performance,"mentation of RooAbsCachedReal that can cache any external RooAbsReal input function provided in the constructor. ; Definition at line 20 of file RooCachedReal.h. Public Member Functions;  RooCachedReal ();  ;  RooCachedReal (const char *name, const char *title, RooAbsReal &_func);  Constructor taking name, title and function to be cached. ;  ;  RooCachedReal (const char *name, const char *title, RooAbsReal &_func, const RooArgSet &cacheObs);  Constructor taking name, title and function to be cached and fixed choice of variable to cache. ;  ;  RooCachedReal (const RooCachedReal &other, const char *name=nullptr);  Copy constructor. ;  ; bool cacheSource () const;  ; TObject * clone (const char *newname) const override;  ; bool getCdfBoundaries () const;  If true the c.d.f boundary mode is active. ;  ; TClass * IsA () const override;  ; void setCacheSource (bool flag);  ; void setCdfBoundaries (bool flag);  If flag is true the RooHistFunc that represent the cache histogram will use special boundary conditions for use with cumulative distribution functions: at the lower bound the function is forced to converge at zero and the upper bound is the function is forced to converge at 1.0. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsCachedReal;  RooAbsCachedReal ();  ;  RooAbsCachedReal (const char *name, const char *title, Int_t ipOrder=0);  Constructor. ;  ;  RooAbsCachedReal (const RooAbsCachedReal &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Forward call to implementation in relevant RooHistFunc instance. ;  ; void disableCache (bool flag);  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:1307,cache,cache,1307,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['cache'],['cache']
Performance,"mentation of the IntervalCalculator interface that, which uses the NeymanConstruction in a particular way. As the name suggests, it returns a ConfidenceInterval. In particular, it produces a RooStats::PointSetInterval, which is a concrete implementation of the ConfInterval interface. . The Neyman Construction is not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. . In the case of the Feldman-Cousins approach, the ordering principle is the likelihood ratio -- motivated; by the Neyman-Pearson lemma. When nuisance parameters are involved, the profile likelihood ratio is the natural generalization. One may either choose to perform the construction over the full space of the nuisance parameters, or restrict the nusiance parameters to their conditional MLE (eg. profiled values). . Function Members (Methods); public:. virtual~FeldmanCousins(); voidAdditionalNToysFactor(double fact); static TClass*Class(); virtual Double_tConfidenceLevel() const; voidCreateConfBelt(bool flag = true); RooStats::FeldmanCousinsFeldmanCousins(const RooStats::FeldmanCousins&); RooStats::FeldmanCousinsFeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); voidFluctuateNumDataEntries(bool flag = true); RooStats::ConfidenceBelt*GetConfidenceBelt(); virtual RooStats::PointSetInterval*GetInterval() const; RooAbsData*GetPointsToScan(); RooStats::TestStatSampler*GetTestStatSampler() const; RooStats::IntervalCalculatorRooStats::IntervalCalculator::IntervalCalculator(); RooStats::IntervalCalculatorRooStats::IntervalCalculator::IntervalCalculator(const RooStats::IntervalCalculator&); virtual TClass*IsA() const; RooStats::FeldmanCousins&operator=(const RooStats::FeldmanCousins&); voidSa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__FeldmanCousins.html:1469,perform,perform,1469,root/html602/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html,2,['perform'],['perform']
Performance,"mentation of the IntervalCalculator interface that, which uses the NeymanConstruction in a particular way. As the name suggests, it returns a ConfidenceInterval. In particular, it produces a RooStats::PointSetInterval, which is a concrete implementation of the ConfInterval interface. . The Neyman Construction is not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. . In the case of the Feldman-Cousins approach, the ordering principle is the likelihood ratio -- motivated; by the Neyman-Pearson lemma. When nuisance parameters are involved, the profile likelihood ratio is the natural generalization. One may either choose to perform the construction over the full space of the nuisance parameters, or restrict the nusiance parameters to their conditional MLE (eg. profiled values). . Function Members (Methods); public:. virtual~FeldmanCousins(); voidAdditionalNToysFactor(double fact); static TClass*Class(); virtual Double_tConfidenceLevel() const; voidCreateConfBelt(bool flag = true); RooStats::FeldmanCousinsFeldmanCousins(const RooStats::FeldmanCousins&); RooStats::FeldmanCousinsFeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); voidFluctuateNumDataEntries(bool flag = true); RooStats::ConfidenceBelt*GetConfidenceBelt(); virtual RooStats::PointSetInterval*GetInterval() const; RooAbsData*GetPointsToScan(); RooStats::TestStatSampler*GetTestStatSampler() const; virtual TClass*IsA() const; RooStats::IntervalCalculator&RooStats::IntervalCalculator::operator=(const RooStats::IntervalCalculator&); voidSaveBeltToFile(bool flag = true); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__FeldmanCousins.html:1469,perform,perform,1469,root/html528/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html528/RooStats__FeldmanCousins.html,4,['perform'],['perform']
Performance,"mentation of the IntervalCalculator interface that, which uses the NeymanConstruction in a particular way. As the name suggests, it returns a ConfidenceInterval. In particular, it produces a RooStats::PointSetInterval, which is a concrete implementation of the ConfInterval interface. . The Neyman Construction is not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. . In the case of the Feldman-Cousins approach, the ordering principle is the likelihood ratio -- motivated; by the Neyman-Pearson lemma. When nuisance parameters are involved, the profile likelihood ratio is the natural generalization. One may either choose to perform the construction over the full space of the nuisance parameters, or restrict the nusiance parameters to their conditional MLE (eg. profiled values). . Function Members (Methods); public:. virtual~FeldmanCousins(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject& named) const; voidCreateConfBelt(bool flag = true); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__FeldmanCousins.html:1484,perform,perform,1484,root/html526/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html526/RooStats__FeldmanCousins.html,1,['perform'],['perform']
Performance,"mentation; TAttAxis(); Constructor. ~TAttAxis(); Destructor. void Copy(TAttAxis& attaxis) const; Copy of the object. void ResetAttAxis(Option_t* option = """"); Reset axis attributes. void SaveAttributes(ostream& out, const char* name, const char* subname); Save axis attributes as C++ statement(s) on output stream out. void SetAxisColor(Color_t color = 1, Float_t alpha = 1.); Set color of the line axis and tick marks. void SetLabelColor(Color_t color = 1, Float_t alpha = 1.); Set color of labels. void SetLabelFont(Style_t font = 62); Set labels' font. void SetLabelOffset(Float_t offset = 0.0050000000000000001); Set distance between the axis and the labels; The distance is expressed in per cent of the pad width. void SetLabelSize(Float_t size = 0.040000000000000001); Set size of axis labels; The size is expressed in per cent of the pad width. void SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE); Set the number of divisions for this axis. if optim = kTRUE (default), the number of divisions will be; optimized around the specified value.; if optim = kFALSE, or n < 0, the axis will be forced to use; exactly n divisions. n = n1 + 100*n2 + 10000*n3. Where n1 is the number of primary divisions,; n2 is the number of second order divisions and; n3 is the number of third order divisions. e.g. 512 means 12 primary and 5 secondary divisions. If the number of divisions is ""optimized"" (see above) n1, n2, n3 are; maximum values. void SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim = kTRUE); see function above. void SetTickLength(Float_t length = 0.029999999999999999); Set tick mark length; The length is expressed in per cent of the pad width. void SetTitleOffset(Float_t offset = 1); Set distance between the axis and the axis title; Offset is a correction factor with respect to the ""standard"" value.; offset = 1 uses the default position that is computed in function; of the label offset and size.; offset = 1.2 will add 20 per cent more to the default offset. void SetTitleSiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAttAxis.html:3603,optimiz,optimized,3603,root/html602/TAttAxis.html,https://root.cern,https://root.cern/root/html602/TAttAxis.html,2,['optimiz'],['optimized']
Performance,"mentation; TConfidenceLevel * ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); class TLimit. Algorithm to compute 95% C.L. limits using the Likelihood ratio; semi-bayesian method.; It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. class TLimitDataSource. Takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. class TConfidenceLevel. Final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and other interesting; quantities. The actual algorithm...; From an input (TLimitDataSource) it produces an output TConfidenceLevel.; For this, nmc Monte Carlo experiments are performed.; As usual, the larger this number, the longer the compute time,; but the better the result. /*; ; Supposing that there is a plotfile.root file containing 3 histograms; (signal, background and data), you can imagine doing things like:. TFile* infile=new TFile(""plotfile.root"",""READ"");; infile->cd();; TH1* sh=(TH1*)infile->Get(""signal"");; TH1* bh=(TH1*)infile->Get(""background"");; TH1* dh=(TH1*)infile->Get(""data"");; TLimitDataSource* mydatasource = new TLimitDataSource(sh,bh,dh);; TConfidenceLevel *myconfidence = TLimit::ComputeLimit(mydatasource,50000);; cout << "" CLs : "" << myconfidence->CLs() << endl;; cout << "" CLsb : "" << myconfidence->CLsb() << endl;; cout << "" CLb : "" << myconfidence->CLb() << endl;; cout << ""< CLs > : "" << myconfidence->GetExpectedCLs_b() << endl;; cout << ""< CLsb > : "" << myconfidence->GetExpectedCLsb_b() << endl;; cout << ""< CLb > : "" << myconfidence->GetExpectedCLb_b() << endl;; delete myconfidence;; delete mydatasource;; infile->Clos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLimit.html:3527,perform,performed,3527,root/html528/TLimit.html,https://root.cern,https://root.cern/root/html528/TLimit.html,4,['perform'],['performed']
Performance,"mentation; TConfidenceLevel * ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); class TLimit. Algorithm to compute 95% C.L. limits using the Likelihood ratio; semi-bayesian method.; It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. class TLimitDataSource. Takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. class TConfidenceLevel. Final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and other interesting; quantities. The actual algorithm...; From an input (TLimitDataSource) it produces an output TConfidenceLevel.; For this, nmc Monte Carlo experiments are performed.; As usual, the larger this number, the longer the compute time,; but the better the result. /*; ; Supposing that there is a plotfile.root file containing 3 histograms; (signal, background and data), you can imagine doing things like:. TFile* infile=new TFile(""plotfile.root"",""READ"");; infile->cd();; TH1* sh=(TH1*)infile->Get(""signal"");; TH1* bh=(TH1*)infile->Get(""background"");; TH1* dh=(TH1*)infile->Get(""data"");; TLimitDataSource* mydatasource = new TLimitDataSource(sh,bh,dh);; TConfidenceLevel *myconfidence = TLimit::ComputeLimit(mydatasource,50000);; std::cout << "" CLs : "" << myconfidence->CLs() << std::endl;; std::cout << "" CLsb : "" << myconfidence->CLsb() << std::endl;; std::cout << "" CLb : "" << myconfidence->CLb() << std::endl;; std::cout << ""< CLs > : "" << myconfidence->GetExpectedCLs_b() << std::endl;; std::cout << ""< CLsb > : "" << myconfidence->GetExpectedCLsb_b() << std::endl;; std::cout << ""< CLb > : "" << myconfidence->GetExpectedCLb_b() << std::end",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLimit.html:3557,perform,performed,3557,root/html602/TLimit.html,https://root.cern,https://root.cern/root/html602/TLimit.html,2,['perform'],['performed']
Performance,"mented from RooAbsPdf.; Definition at line 135 of file RooLognormal.cxx. ◆ getAnalyticalIntegral(). Int_t RooLognormal::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 102 of file RooLognormal.cxx. ◆ getGenerator(). Int_t RooLognormal::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ; A code of zero indicates that we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented from RooAbsPdf.; Definition at line 128 of file RooLognormal.cxx. ◆ getMedian(). RooAbsReal const & RooLognormal::getMedian ; (; ); const. inline . Get the median parameter. ; Definition at line 39 of file RooLognormal.h. ◆ getShapeK(). RooAbsReal const & RooLognormal::getShapeK ; (; ); const. inline . Get the shape parameter. ; Definition at line 42 of file RooLognormal.h. ◆ getX(). RooAbsReal const & RooLognormal::getX ; (; ); const. inline . Get the x variable. ; Definition at line 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLognormal.html:78702,Load,Load,78702,doc/master/classRooLognormal.html,https://root.cern,https://root.cern/doc/master/classRooLognormal.html,1,['Load'],['Load']
Performance,"mented from RooAbsPdf.; Definition at line 944 of file RooGExpModel.cxx. ◆ getAnalyticalIntegral(). Int_t RooGExpModel::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 648 of file RooGExpModel.cxx. ◆ getGenerator(). Int_t RooGExpModel::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ; A code of zero indicates that we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented from RooAbsPdf.; Definition at line 936 of file RooGExpModel.cxx. ◆ IsA(). TClass * RooGExpModel::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 103 of file RooGExpModel.h. ◆ Streamer(). void RooGExpModel::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooGExpModel::StreamerNVirtual ; (; TBuffer & ; Clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGExpModel.html:86797,Load,Load,86797,doc/master/classRooGExpModel.html,https://root.cern,https://root.cern/doc/master/classRooGExpModel.html,1,['Load'],['Load']
Performance,"mented from TCollection.; Definition at line 541 of file TListOfFunctions.cxx. ◆ IndexOf(). Int_t TListOfFunctions::IndexOf ; (; const TObject * ; obj); const. overridevirtual . Return index of object in collection. ; Returns -1 when object not found. Uses member IsEqual() to find object. ; Reimplemented from TSeqCollection.; Definition at line 532 of file TListOfFunctions.cxx. ◆ IsA(). TClass * TListOfFunctions::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from THashList.; Definition at line 102 of file TListOfFunctions.h. ◆ Last(). TObject * TListOfFunctions::Last ; (; ); const. overridevirtual . Return the last object in the list. Returns 0 when list is empty. ; Reimplemented from TList.; Definition at line 507 of file TListOfFunctions.cxx. ◆ LastLink(). TObjLink * TListOfFunctions::LastLink ; (; ); const. overridevirtual . Reimplemented from TList.; Definition at line 515 of file TListOfFunctions.cxx. ◆ Load(). void TListOfFunctions::Load ; (; ). Load all the functions known to the interpreter for the scope 'fClass' into this collection. ; Definition at line 374 of file TListOfFunctions.cxx. ◆ MakeIterator(). TIterator * TListOfFunctions::MakeIterator ; (; Bool_t ; dir = kIterForward); const. overridevirtual . Return a list iterator. ; Reimplemented from TList.; Definition at line 451 of file TListOfFunctions.cxx. ◆ MapObject(). void TListOfFunctions::MapObject ; (; TObject * ; obj). private . Add pair<id, object> to the map of functions and their ids. ; Definition at line 51 of file TListOfFunctions.cxx. ◆ operator=(). TListOfFunctions & TListOfFunctions::operator= ; (; const TListOfFunctions & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfFunctions::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctions.html:32075,Load,Load,32075,doc/master/classTListOfFunctions.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctions.html,1,['Load'],['Load']
Performance,"mented from TObject.; Reimplemented in TLeafB, TLeafC, TLeafD, TLeafD32, TLeafElement, TLeafF, TLeafF16, TLeafG, TLeafI, TLeafL, TLeafO, TLeafObject, and TLeafS.; Definition at line 480 of file TLeaf.cxx. ◆ StreamerNVirtual(). void TLeaf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 168 of file TLeaf.h. Member Data Documentation. ◆ fBranch. TBranch* TLeaf::fBranch. protected . ! Pointer to supporting branch (we do not own the branch) ; Definition at line 78 of file TLeaf.h. ◆ fIsRange. bool TLeaf::fIsRange. protected . (=true if leaf has a range, false otherwise). This is equivalent to being a 'leafcount'. For a TLeafElement the range information is actually store in the TBranchElement. ; Definition at line 75 of file TLeaf.h. ◆ fIsUnsigned. bool TLeaf::fIsUnsigned. protected . (=true if unsigned, false otherwise) ; Definition at line 76 of file TLeaf.h. ◆ fLeafCount. TLeaf* TLeaf::fLeafCount. protected . Pointer to Leaf count if variable length (we do not own the counter) ; Definition at line 77 of file TLeaf.h. ◆ fLeafCountValues. LeafCountValues* TLeaf::fLeafCountValues. protected . ! Cache of collection/array sizes ; Definition at line 79 of file TLeaf.h. ◆ fLen. Int_t TLeaf::fLen. protected . Number of fixed length elements in the leaf's data. ; Definition at line 72 of file TLeaf.h. ◆ fLenType. Int_t TLeaf::fLenType. protected . Number of bytes for this data type. ; Definition at line 73 of file TLeaf.h. ◆ fNdata. Int_t TLeaf::fNdata. protected . ! Number of elements in fAddress data buffer. ; Definition at line 71 of file TLeaf.h. ◆ fOffset. Int_t TLeaf::fOffset. protected . Offset in ClonesArray object (if one) ; Definition at line 74 of file TLeaf.h. Libraries for TLeaf:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TLeaf.h; tree/tree/src/TLeaf.cxx. TLeaf. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:53 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeaf.html:30452,Cache,Cache,30452,doc/master/classTLeaf.html,https://root.cern,https://root.cern/doc/master/classTLeaf.html,1,['Cache'],['Cache']
Performance,"mented from TVirtualX. ◆ ReadGIF(). void TGWin32VirtualXProxy::ReadGIF ; (; Int_t ; x0, . Int_t ; y0, . const char * ; file . ). ◆ ReadPictureDataFromFile(). Bool_t TGWin32VirtualXProxy::ReadPictureDataFromFile ; (; const char * ; filename, . char *** ; ret_data . ). overridevirtual . Reads picture data from file ""filename"" and store it in ""ret_data"". ; Returns kTRUE in case of success, kFALSE otherwise. ; Reimplemented from TVirtualX. ◆ RealObject(). TVirtualX * TGWin32VirtualXProxy::RealObject ; (; ). static . Definition at line 32 of file TGWin32VirtualXProxy.cxx. ◆ RemoveWindow(). void TGWin32VirtualXProxy::RemoveWindow ; (; ULongptr_t ; qwid). overridevirtual . Removes the created by Qt window ""qwid"". ; Reimplemented from TVirtualX. ◆ ReparentWindow(). void TGWin32VirtualXProxy::ReparentWindow ; (; Window_t ; id, . Window_t ; pid, . Int_t ; x, . Int_t ; y . ). overridevirtual . If the specified window is mapped, ReparentWindow automatically performs an UnmapWindow request on it, removes it from its current position in the hierarchy, and inserts it as the child of the specified parent. ; The window is placed in the stacking order on top with respect to sibling windows. ; Reimplemented from TVirtualX. ◆ RequestLocator(). Int_t TGWin32VirtualXProxy::RequestLocator ; (; Int_t ; mode, . Int_t ; ctyp, . Int_t & ; x, . Int_t & ; y . ). overridevirtual . Requests Locator position. ; Parameters. [in]x,ycursor position at moment of button press (output) ; [in]ctypcursor type (input); ctyp = 1 tracking cross; ctyp = 2 cross-hair; ctyp = 3 rubber circle; ctyp = 4 rubber band; ctyp = 5 rubber rectangle. [in]modeinput mode; mode = 0 request; mode = 1 sample. Returns; in request mode:; 1 = left is pressed; 2 = middle is pressed; 3 = right is pressed. in sample mode:; 11 = left is released; 12 = middle is released; 13 = right is released; -1 = nothing is pressed or released; -2 = leave the window; else = keycode (keyboard is pressed) . Reimplemented from TVirtualX. ◆ RequestStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:102822,perform,performs,102822,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['perform'],['performs']
Performance,"mented in a separate chapter (see “Linear Algebra in ROOT”). SMatrix is a C++ package, for high performance vector and matrix computations. It has been introduced in ROOT v5.08. It is optimized for describing small matrices and vectors and It can be used only in problems when the size of the matrices is known at compile time, like in the tracking reconstruction of physics experiments. It is based on a C++ technique, called expression templates, to achieve an high level optimization. The C++ templates can be used to implement vector and matrix expressions such that these expressions can be transformed at compile time to code which is equivalent to hand optimized code in a low-level language like FORTRAN or C (see for example T. Veldhuizen, Expression Templates, C++ Report, 1995).; The SMatrix has been developed initially by T. Glebe in Max-Planck-Institut, Heidelberg, as part of the HeraB analysis framework. A subset of the original package has been now incorporated in the ROOT distribution, with the aim to provide a stand-alone and high performance matrix package. The API of the current package differs from the original one, in order to be compliant to the ROOT coding conventions.; SMatrix contains the generic ROOT::Math::SMatrix and ROOT::Math::SVector classes for describing matrices and vectors of arbitrary dimensions and of arbitrary type. The classes are templated on the scalar type and on the size, like number of rows and columns for a matrix . Therefore, the matrix/vector dimension has to be known at compile time. An advantage of using the dimension as template parameters is that the correctness of dimension in the matrix/vector operations can be checked at compile time.; SMatrix supports, since ROOT v5.10, symmetric matrices using a storage class (ROOT::Math::MatRepSym) which contains only the N*(N+1)/2 independent element of a NxN symmetric matrix. It is not in the mandate of this package to provide complete linear algebra functionality. It provides basic ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:748819,perform,performance,748819,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance,"menting x(), y() and z() member functions; 410 */; 411 template< class OtherVector >; 412 Scalar Dot( const OtherVector & v) const {; 413 return X()*v.x() + Y()*v.y() + Z()*v.z();; 414 }; 415 ; 416 /**; 417 Return vector (cross) product of two displacement vectors,; 418 as a vector in the coordinate system of this class.; 419 It is possible to perform the product for any type of vector coordinates,; 420 but they must have the same coordinate system tag; 421 */; 422 template <class OtherCoords>; 423 DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 424 DisplacementVector3D result;; 425 result.SetXYZ ( Y()*v.Z() - v.Y()*Z(),; 426 Z()*v.X() - v.Z()*X(),; 427 X()*v.Y() - v.X()*Y() );; 428 return result;; 429 }; 430 /**; 431 Return vector (cross) product of two vectors,; 432 as a vector in the coordinate system of this class.; 433 It is possible to perform the product for any classes; 434 implementing X(), Y() and Z() member functions; 435 */; 436 template <class OtherVector>; 437 DisplacementVector3D Cross( const OtherVector & v) const {; 438 DisplacementVector3D result;; 439 result.SetXYZ ( Y()*v.z() - v.y()*Z(),; 440 Z()*v.x() - v.z()*X(),; 441 X()*v.y() - v.x()*Y() );; 442 return result;; 443 }; 444 ; 445 ; 446 ; 447 /**; 448 Self Addition with a displacement vector.; 449 */; 450 template <class OtherCoords>; 451 DisplacementVector3D & operator+=; 452 (const DisplacementVector3D<OtherCoords,Tag> & v) {; 453 SetXYZ( X() + v.X(), Y() + v.Y(), Z() + v.Z() );; 454 return *this;; 455 }; 456 ; 457 /**; 458 Self Difference with a displacement vector.; 459 */; 460 template <class OtherCoords>; 461 DisplacementVector3D & operator-=; 462 (const DisplacementVector3D<OtherCoords,Tag> & v) {; 463 SetXYZ( x() - v.x(), y() - v.y(), z() - v.z() );; 464 return *this;; 465 }; 466 ; 467 ; 468 /**; 469 multiply this vector by a scalar quantity; 470 */; 471 DisplacementVector3D & operator*= (Scalar a) {; 472 fCoordinates.Scale(a);; 473 return *this;; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:13966,perform,perform,13966,doc/master/GenVector_2DisplacementVector3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html,1,['perform'],['perform']
Performance,"ments, void *arena, ENewType defConstructor) const; 5311{; 5312 ObjectPtr p;; 5313 ; 5314 if (fNewArray) {; 5315 // We have the new operator wrapper function,; 5316 // so there is a dictionary and it was generated; 5317 // by rootcint, so there should be a default; 5318 // constructor we can call through the wrapper.; 5319 {; 5320 TClass__GetCallingNewRAII callingNew(defConstructor);; 5321 p = fNewArray(nElements, arena);; 5322 }; 5323 if (!p) {; 5324 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5325 }; 5326 } else if (HasInterpreterInfo()) {; 5327 // We have the dictionary but do not have the constructor wrapper,; 5328 // so the dictionary was not generated by rootcint (it was made either; 5329 // by cint or by some external mechanism). Let's try to create the; 5330 // object by having the interpreter call the new operator, either the; 5331 // class library is loaded and there is a default constructor we can; 5332 // call, or the class is interpreted and we will call the default; 5333 // constructor that way, or no default constructor is available and; 5334 // we fail.; 5335 {; 5336 TClass__GetCallingNewRAII callingNew(defConstructor);; 5337 p = gCling->ClassInfo_New(GetClassInfo(),nElements, arena);; 5338 }; 5339 if (!p) {; 5340 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5341 }; 5342 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5343 // There is no dictionary at all, so this is an emulated; 5344 // class; however we do have the services of a collection proxy,; 5345 // so this is an emulated STL class.; 5346 {; 5347 TClass__GetCallingNewRAII callingNew(defConstructor);; 5348 p = fCollectionProxy->NewObjectArray(nElements, arena);; 5349 }; 5350 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5351 // There is no dictionary at all and we do not have; 5352 // the services of a colle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:203741,load,loaded,203741,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"ments, void *arena, ENewType defConstructor) const; 5378{; 5379 ObjectPtr p;; 5380 ; 5381 if (fNewArray) {; 5382 // We have the new operator wrapper function,; 5383 // so there is a dictionary and it was generated; 5384 // by rootcint, so there should be a default; 5385 // constructor we can call through the wrapper.; 5386 {; 5387 TClass__GetCallingNewRAII callingNew(defConstructor);; 5388 p = fNewArray(nElements, arena);; 5389 }; 5390 if (!p) {; 5391 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5392 }; 5393 } else if (HasInterpreterInfo()) {; 5394 // We have the dictionary but do not have the constructor wrapper,; 5395 // so the dictionary was not generated by rootcint (it was made either; 5396 // by cint or by some external mechanism). Let's try to create the; 5397 // object by having the interpreter call the new operator, either the; 5398 // class library is loaded and there is a default constructor we can; 5399 // call, or the class is interpreted and we will call the default; 5400 // constructor that way, or no default constructor is available and; 5401 // we fail.; 5402 {; 5403 TClass__GetCallingNewRAII callingNew(defConstructor);; 5404 p = gCling->ClassInfo_New(GetClassInfo(),nElements, arena);; 5405 }; 5406 if (!p) {; 5407 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5408 }; 5409 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5410 // There is no dictionary at all, so this is an emulated; 5411 // class; however we do have the services of a collection proxy,; 5412 // so this is an emulated STL class.; 5413 {; 5414 TClass__GetCallingNewRAII callingNew(defConstructor);; 5415 p = fCollectionProxy->NewObjectArray(nElements, arena);; 5416 }; 5417 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5418 // There is no dictionary at all and we do not have; 5419 // the services of a colle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:206492,load,loaded,206492,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"ments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the function TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:41113,load,loading,41113,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['load'],['loading']
Performance,"menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TListOfFunctions * GetMethodList(); Return (create an empty one if needed) the list of functions.; The major difference with GetListOfMethod is that this returns; the internal type of fMethod and thus can not be made public.; It also never 'loads' the content of the list. TMethod * GetMethodAny(const char* method); Return pointer to method without looking at parameters.; Does not look in (possible) base classes.; Has the side effect of loading all the TMethod object in the list; of the class. TMethod * GetMethodAllAny(const char* method); Return pointer to method without looking at parameters.; Does look in all base classes. TMethod * GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); Find the best method (if there is one) matching the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; The function invokes GetClassMethod to search for a possible method; in the class itself or in its base classes. Returns 0 in case method; is not found. TMethod* FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); Find a method with decl id in this class or its bases. TMethod * GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found. TMethod * GetClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:42714,load,loading,42714,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['loading']
Performance,"meobject identifier; TStringfParamsdefault string of macro parameters; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMacro(); Create an empty macro, use AddLine() or ReadFile() to fill this macro. TMacro(const char* name, const char* title = """"); Create a macro with a name and a title.; If name contains a '.' it is assumed to be the name of a file, and; * the macro is automatically filled by reading all the lines in the file,; * if the title is empty, it will be set to the name of the file,; * the name will be set to the filename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. Returns 0 in; case of error, otherwise the added TObjString. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMacro.html:7835,perform,performed,7835,root/html534/TMacro.html,https://root.cern,https://root.cern/root/html534/TMacro.html,1,['perform'],['performed']
Performance,"meoftype);; will return the TDataType corresponding to 'nameoftype'. If the; TDataType is not already in the list itself and the type does exist,; a new TDataType will be created and added to the list. Calling; gROOT->GetListOfTypes()->ls(); // or Print(); list only the typedefs that have been previously accessed throught the; list (plus the builtins types). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the name of the given include file corresponds to a class that; is known to ROOT, e.g. ""TLorentzVector.h"" versus TLorentzVector. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. void InitInterpreter(); Initialize the interpreter. Should be called only after main(),; to make sure LLVM/Clang is fully initialized. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:30180,Load,LoadClass,30180,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['Load'],['LoadClass']
Performance,"mer from list of system timers. ;  ; virtual int Rename (const char *from, const char *to);  Rename a file. ;  ; virtual void ResetSignal (ESignals sig, Bool_t reset=kTRUE);  If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ;  ; virtual void ResetSignals ();  Reset signals handlers to previous behaviour. ;  ; virtual void ResetTimer (TTimer *);  ; virtual void Run ();  System event loop. ;  ; virtual Int_t Select (TFileHandler *fh, Long_t timeout);  Select on active file descriptors (called by TMonitor). ;  ; virtual Int_t Select (TList *active, Long_t timeout);  Select on active file descriptors (called by TMonitor). ;  ; virtual int SendBuf (int sock, const void *buffer, int length);  Send a buffer headed by a length indicator. ;  ; virtual int SendRaw (int sock, const void *buffer, int length, int flag);  Send exactly length bytes from buffer. ;  ; virtual void SetAclicMode (EAclicMode mode);  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual void SetBuildDir (const char *build_dir, Bool_t isflat=kFALSE);  Set the location where ACLiC will create libraries and use as a scratch area. ;  ; virtual void SetDisplay ();  Set DISPLAY environment variable based on utmp entry. Only for UNIX. ;  ; virtual void SetDynamicPath (const char *pathname);  Set the dynamic path to a new value. ;  ; virtual void Setenv (const char *name, const char *value);  Set environment variable. ;  ; void SetErrorStr (const char *errstr);  Set the system error string. ;  ; virtual void SetFlagsDebug (const char *);  FlagsDebug should contain the options to pass to the C++ compiler in order to compile the library in debug mode. ;  ; virtual void SetFlagsOpt (const char *);  FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in optimized mode. ;  ; virtual Int_t SetFPEMask (Int_t mask=kDefaultMask);  Set which conditions trigger a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetSystem.html:15985,optimiz,optimized,15985,doc/master/classTNetSystem.html,https://root.cern,https://root.cern/doc/master/classTNetSystem.html,6,['optimiz'],['optimized']
Performance,"merInfo as a single object in this file The class Streamer description for al...Definition TFile.cxx:3792; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TFolder::GetListOfFoldersTCollection * GetListOfFolders() constDefinition TFolder.h:55; TFolder::Occurencevirtual Int_t Occurence(const TObject *obj) constReturn occurence number of object in the list of objects of this folder.Definition TFolder.cxx:427; TFolder::Classstatic TClass * Class(); TFriendElementA TFriendElement TF describes a TTree object TF in a file.Definition TFriendElement.h:33; TFriendElement::ResetUpdatedvoid ResetUpdated()Definition TFriendElement.h:68; TFriendElement::kFromChain@ kFromChainDefinition TFriendElement.h:49; TFriendElement::GetTreeNamevirtual const char * GetTreeName() constGet the actual TTree name of the friend.Definition TFriendElement.h:64; TFriendElement::GetTreevirtual TTree * GetTree()Return pointer to friend TTree.Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:413271,cache,cache,413271,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"merInfo instances saved in a ROOT file which is opened. This is called in jargon an emulated TClass.; From TProtoClass instances saved in a ROOT pcm file created by the dictionary generator and the dictionary itself.; From a lookup in the AST built by cling. If a TClass instance is built through the mechanisms 1. and 2., it does not contain information about methods of the class/struct/namespace it represents. Conversely, if built through 3. or 1., it does not carry the information which is necessary to ROOT to perform I/O of instances of the class/struct it represents. The mechanisms 1., 2. and 3. are not mutually exclusive: it can happen that during the execution of the program, all the three are triggered, modifying the state of the TClass instance.; In order to retrieve a TClass instance from the type system, a query can be executed as follows through the static TClass::GetClass method:; auto myClassTClass_0 = TClass::GetClass(""myClass"");; auto myClassTClass_1 = TClass::GetClass<myClass>();; auto myClassTClass_2 = TClass::GetClass(myClassTypeInfo);; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; The name of classes is crucial for ROOT. A careful procedure of name normalization is carried out for each and every class. A normalized name is a valid C++ class name. In order to access the name of a class within the ROOT type system, the method TClass::GetName() can be used. ; Definition at line 81 of file TClass.h. Classes; class  InsertTClassInRegistryRAII;  ; struct  ObjectPtr;  ; class  TDeclNameRegistry;  . Public Types; enum  ECheckSum { ;   kCurrentCheckSum = 0; , kNoEnum = 1; , kReflexNoComment = 2; , kNoRange = 3; , ;   kWithTypeDef = 4; , kReflex = 5; , kNoRangeCheck = 6; , kNoBaseCheckSum = 7; , ;   kLatestCheckSum = 8. };  ; enum  ENewType { kRealNew = 0; , kClassNew; , kDummyNew; };  ; enum  EState { ;   kNoI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:1749,load,load,1749,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['load']
Performance,"merInfo instances saved in a ROOT file which is opened. This is called in jargon an emulated TClass.; From TProtoClass instances saved in a ROOT pcm file created by the dictionary generator and the dictionary itself.; From a lookup in the AST built by cling. If a TClass instance is built through the mechanisms 1. and 2., it does not contain information about methods of the class/struct/namespace it represents. Conversely, if built through 3. or 1., it does not carry the information which is necessary to ROOT to perform I/O of instances of the class/struct it represents. The mechanisms 1., 2. and 3. are not mutually exclusive: it can happen that during the execution of the program, all the three are triggered, modifying the state of the TClass instance.; In order to retrieve a TClass instance from the type system, a query can be executed as follows through the static TClass::GetClass method:; auto myClassTClass_0 = TClass::GetClass(""myClass"");; auto myClassTClass_1 = TClass::GetClass<myClass>();; auto myClassTClass_2 = TClass::GetClass(myClassTypeInfo);; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; The name of classes is crucial for ROOT. A careful procedure of name normalization is carried out for each and every class. A normalized name is a valid C++ class name. In order to access the name of a class within the ROOT type system, the method TClass::GetName() can be used. ; Definition at line 81 of file TClass.h. Classes; class  InsertTClassInRegistryRAII;  ; struct  ObjectPtr;  ; class  TDeclNameRegistry;  . Public Types; enum  ECheckSum { ;   kCurrentCheckSum = 0; , kNoEnum = 1; , kReflexNoComment = 2; , kNoRange = 3; , ;   kWithTypeDef = 4; , kReflex = 5; , kNoRangeCheck = 6; , kNoBaseCheckSum = 7; , ;   kLatestCheckSum = 8. };  ; enum  ENewType { kRealNew = 0; , kClassNew; , kDummyNew; };  ; enum  EState { ;   kNoI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:1750,load,load,1750,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['load']
Performance,"merIntervalvirtual void SetTimerInterval(Int_t msec=333)Definition TTree.h:693; TTree::SetBranchStatusvirtual void SetBranchStatus(const char *bname, bool status=true, UInt_t *found=nullptr)Set branch status to Process or DoNotProcess.Definition TTree.cxx:8534; TTree::GetSelectTTreeFormula * GetSelect()Definition TTree.h:552; TTree::EnableCachebool EnableCache()Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0).Definition TTree.cxx:2685; TTree::GetBranchvirtual TBranch * GetBranch(const char *name)Return pointer to the branch with the given name in this tree or its friends.Definition TTree.cxx:5294; TTree::GetScanFieldvirtual Int_t GetScanField() constDefinition TTree.h:551; TTree::GetBranchStylestatic Int_t GetBranchStyle()Static function returning the current branch style.Definition TTree.cxx:5395; TTree::fFriendsTList * fFriendspointer to list of friend elementsDefinition TTree.h:130; TTree::fIMTEnabledbool fIMTEnabled! true if implicit multi-threading is enabled for this treeDefinition TTree.h:142; TTree::GetChainEntryNumbervirtual Long64_t GetChainEntryNumber(Long64_t entry) constDefinition TTree.h:455; TTree::GetBranchStatusvirtual bool GetBranchStatus(const char *branchname) constReturn status of branch with name branchname.Definition TTree.cxx:5380; TTree::fFriendLockStatusUInt_t fFriendLockStatus! Record which method is locking the friend recursionDefinition TTree.h:137; TTree::GetLeafImplvirtual TLeaf * GetLeafImpl(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:54489,multi-thread,multi-threading,54489,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['multi-thread'],['multi-threading']
Performance,"mera::UpdateCache() const. Data Members; public:. enum EType { kZOY; kXOZ; kXOY; kZnOY; kXnOZ; kXnOY; };; enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoom! zoom when dolly is requested; Bool_tfEnableRotate! enable rotation; TGLOrthoCamera::ETypefType! camera type; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLOrthoCamera.html:5517,cache,cached,5517,root/html528/TGLOrthoCamera.html,https://root.cern,https://root.cern/root/html528/TGLOrthoCamera.html,18,['cache'],['cached']
Performance,"meric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:33985,cache,cache,33985,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,3,['cache'],['cache']
Performance,"merical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; RooRealProxy_valueHolder of the blind value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooUnblindPrecision.html:33589,cache,cache,33589,root/html530/RooUnblindPrecision.html,https://root.cern,https://root.cern/root/html530/RooUnblindPrecision.html,1,['cache'],['cache']
Performance,"mes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; (containing all geometry tree) must be specified before closing the geometry; and must not be positioned - it represents the global reference frame. After; building the full geometry tree, the geometry must be closed; (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:6576,load,loaded,6576,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['load'],['loaded']
Performance,"meter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially useful for example with TVirtualMC or similar. Function Members (Methods); public:. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenerator.html:2639,load,loaded,2639,root/html528/TGenerator.html,https://root.cern,https://root.cern/root/html528/TGenerator.html,4,['load'],['loaded']
Performance,"meter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially useful for example with TVirtualMC or similar. Function Members (Methods); public:. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenerator.html:2634,load,loaded,2634,root/html602/TGenerator.html,https://root.cern,https://root.cern/root/html602/TGenerator.html,2,['load'],['loaded']
Performance,"meterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; virtual voidParameterGradient(double x, const double* par, double* grad) const; virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; static voidSetDerivPrecision(double eps); virtual voidSetParameters(const double* p); ROOT::Math::WrappedTF1WrappedTF1(TF1& f); ROOT::Math::WrappedTF1WrappedTF1(const ROOT::Math::WrappedTF1& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const; virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Data Members; private:. TF1*fFuncpointer to ROOT function; boolfLinearflag for linear functions ; vector<double>fParamscached vector with parameter values; boolfPolynomialflag for polynomial functions ; doublefX[1]! cached vector for x value (needed for TF1::EvalPar signature) ; static doublefgEpsepsilon used in derivative calculation h ~ eps |x|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedTF1(TF1& f). constructor from a TF1 function pointer. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. WrappedTF1(TF1& f). Copy constructor. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__WrappedTF1.html:2379,cache,cached,2379,root/html528/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__WrappedTF1.html,4,['cache'],['cached']
Performance,"meters of the external input p.d.f ; Implements RooAbsCachedReal.; Definition at line 178 of file RooCachedReal.cxx. ◆ cacheSource(). bool RooCachedReal::cacheSource ; (; ); const. inline . Definition at line 42 of file RooCachedReal.h. ◆ Class(). static TClass * RooCachedReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCachedReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCachedReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 72 of file RooCachedReal.h. ◆ clone(). TObject * RooCachedReal::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 28 of file RooCachedReal.h. ◆ createCache(). RooAbsCachedReal::FuncCacheElem * RooCachedReal::createCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Interface function to create an internal cache object that represent each cached function configuration. ; This interface allows to create and return a class derived from RooAbsCachedReal::FuncCacheElem so that a derived class fillCacheObject implementation can utilize extra functionality defined in such a derived cache class ; Reimplemented from RooAbsCachedReal.; Definition at line 103 of file RooCachedReal.cxx. ◆ DeclFileName(). static const char * RooCachedReal::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 72 of file RooCachedReal.h. ◆ evaluate(). double RooCachedReal::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Dummy evaluate, it is never called. ; Implements RooAbsReal.; Definition at line 55 of file RooCachedReal.h. ◆ fillCacheObject(). void RooCachedReal::fillCacheObject ; (; RooAbsCachedReal::FuncCacheElem & ; cache); const. overrideprotectedvirtual . Update contents of cache histogram by resampling the input function. ; Implements RooAbsCachedRea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:66837,cache,cache,66837,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,2,['cache'],"['cache', 'cached']"
Performance,"meters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M is entirely based on double precision. The actual floating point precision of double precision (32–bit or 64–bit) is platform dependent and can even vary on the same platform, depending on whether a floating point number is read from memory a CPU register.; The argument of the user’s implementation of FCNBase::operator() is therefore a std:vector\(<\)double\(>\). M expects that the calculations inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M of this situation with setting a different machine precision via the MnMachinePrecision::setPrecision(double) method.; With reduced precision, the user may find that certain features sensitive to first and second differences (\(\mbox{HESSE}\), \(\mbox{MINOS}\), \(\mbox{CO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:28252,perform,performed,28252,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['perform'],['performed']
Performance,"method = GetMethod(datasetname, methodTitle);; 1337 if (method); 1338 method->PrintHelpMessage();; 1339 else {; 1340 Log() << kWARNING << ""<PrintHelpMessage> Could not find classifier \"""" << methodTitle << ""\"" in list"" << Endl;; 1341 }; 1342 } else {; 1343 ; 1344 // no classifier specified, print all help messages; 1345 MVector *methods = fMethodsMap.find(datasetname)->second;; 1346 MVector::const_iterator itrMethod;; 1347 for (itrMethod = methods->begin(); itrMethod != methods->end(); ++itrMethod) {; 1348 MethodBase *method = dynamic_cast<MethodBase *>(*itrMethod);; 1349 if (method == 0); 1350 continue;; 1351 Log() << kINFO << ""Print help message for classifier: "" << method->GetMethodName() << Endl;; 1352 method->PrintHelpMessage();; 1353 }; 1354 }; 1355}; 1356 ; 1357////////////////////////////////////////////////////////////////////////////////; 1358/// Iterates over all MVA input variables and evaluates them.; 1359 ; 1360void TMVA::Factory::EvaluateAllVariables(DataLoader *loader, TString options); 1361{; 1362 Log() << kINFO << ""Evaluating all variables..."" << Endl;; 1363 Event::SetIsTraining(kFALSE);; 1364 ; 1365 for (UInt_t i = 0; i < loader->GetDataSetInfo().GetNVariables(); i++) {; 1366 TString s = loader->GetDataSetInfo().GetVariableInfo(i).GetLabel();; 1367 if (options.Contains(""V"")); 1368 s += "":V"";; 1369 this->BookMethod(loader, ""Variable"", s);; 1370 }; 1371}; 1372 ; 1373////////////////////////////////////////////////////////////////////////////////; 1374/// Iterates over all MVAs that have been booked, and calls their evaluation methods.; 1375 ; 1376void TMVA::Factory::EvaluateAllMethods(void); 1377{; 1378 Log() << kHEADER << gTools().Color(""bold"") << ""Evaluate all methods"" << gTools().Color(""reset"") << Endl;; 1379 ; 1380 // don't do anything if no method booked; 1381 if (fMethodsMap.empty()) {; 1382 Log() << kINFO << ""...nothing found to evaluate"" << Endl;; 1383 return;; 1384 }; 1385 std::map<TString, MVector *>::iterator itrMap;; 1386 ; 1387 for (itr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:55509,load,loader,55509,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TSelector. ◆ Process(). Bool_t TSelEvent::Process ; (; Long64_t ; entry). virtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TTree::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms. ; Reimplemented from TSelector.; Definition at line 201 of file TSelEvent.cxx. ◆ SetInputList(). virtual void TSelEvent::SetInputList ; (; TList * ; input). inlinevirtual . Reimplemented from TSelector.; Definition at line 113 of file TSelEvent.h. ◆ SetObject(). virtual void TSelEvent::SetObject ; (; TObject * ; obj). inlinevirtual . Reimplemented from TSelector.; Definition at line 112 of file TSelEvent.h. ◆ SetOption(). virtual void TSelEvent::SetOption ; (; const char * ; option). inlinevirtual . Reimplemented from TSelector.; Definition at line 111 of file TSelEvent.h. ◆ SlaveBegin(). void TSelEvent::SlaveBegin ; (; TTree * ; tree). virtual . The SlaveBegin() function is called after the Begin() function. ; When running with PROOF SlaveBegin() i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelEvent.html:17921,load,loaded,17921,doc/master/classTSelEvent.html,https://root.cern,https://root.cern/doc/master/classTSelEvent.html,1,['load'],['loaded']
Performance,"method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found.; See TClass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:45353,load,loaded,45353,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['loaded']
Performance,"method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCategoryLValue.html:11170,optimiz,optimizeCacheMode,11170,root/html530/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html,3,['optimiz'],['optimizeCacheMode']
Performance,"method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tFill(); Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); Int_tTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TNtuple&operator=(const TNtuple&); TNtuple(const TNtuple&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TNtuple.html:21466,cache,cacheSize,21466,root/html604/TNtuple.html,https://root.cern,https://root.cern/root/html604/TNtuple.html,1,['cache'],['cacheSize']
Performance,"method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tFill(); Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); Int_tTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TNtupleD&operator=(const TNtupleD&); TNtupleD(const TNtupleD&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TNtupleD.html:21452,cache,cacheSize,21452,root/html604/TNtupleD.html,https://root.cern,https://root.cern/root/html604/TNtupleD.html,1,['cache'],['cacheSize']
Performance,"method.; ...; if (fChain == 0) return;; Int_t nentries = Int_t(fChain->GetEntries());; TH1F *myHisto = new TH1F(""myHisto"",""fPx"", 100, -5,5);; TH1F *smallHisto = new TH1F(""small"",""fPx"", 100, -5,5);; ...; In the for-loop, we need to add another for-loop to go over all the tracks. In the outer for-loop, we get the entry and the number of tracks. In the inner for-loop, we fill the large histogram (myHisto) with all tracks and the small histogram (smallHisto) with the track if it is in the first 100.; ...; for (Int_t jentry=0; jentry<nentries;jentry++) {; GetEntry(jentry);; for (Int_t j = 0; j < 100; j++) {; myHisto->Fill(fTracks_fPx[j]);; if (j < 100) {; smallHisto->Fill(fTracks_fPx[j]);; }; }; }; ...; Outside of the for-loop, we draw both histograms on the same canvas.; ...; myHisto->Draw();; smallHisto->Draw(""Same"");; ...; Save these changes to MyClass.C and start a fresh root session. We will now load MyClass and experiment with its methods.; 12.21.5 Loading MyClass; The first step is to load the library and the class file. Then we can instantiate a MyClass object.; root[] .L libEvent.so; root[] .L MyClass.C; root[] MyClass m; Now we can get a specific entry and populate the event leaf. In the code snipped below, we get entry 0, and print the number of tracks (594). Then we get entry 1 and print the number of tracks (597).; root[] m.GetEntry(0); (int)57503; root[] m.fNtrack(); (Int_t)594; root[] m.GetEntry(1); (int)48045; root[] m.fNtrack(); (Int_t)597; Now we can call the Loop method, which will build and display the two histograms.; root[] m.Loop(); You should now see a canvas that looks like this. To conclude the discussion on MakeClass let us lists the steps that got us here. Call TTree::MakeClass, which automatically creates a class to loop over the tree.; Modify the MyClass::Loop() method in MyClass.C to fit your task.; Load and instantiate MyClass, and run MyClass::Loop(). 12.22 Using TTree::MakeSelector. With a TTree we can make a selector and use it to proce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:642297,Load,Loading,642297,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['Load', 'load']","['Loading', 'load']"
Performance,"metric error associated with current value. ;  ; std::shared_ptr< RooRealVarSharedProperties > _sharedProp;  ! Shared binnings associated with this instance ;  ; std::size_t _valueResetCounter = 0;  ! How many times the value of this variable was reset ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:69104,Cache,Cache,69104,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['Cache'],['Cache']
Performance,"metry MDI Geometry; TGMdiHorizontalWinResizer Horizontal Window Resizer; TGMdiMainFrame MDI main frame; TGMdiMenuBar MDI menu bar; TGMdiTitleBar MDI Title Bar; TGMdiTitleIcon MDI Title Icon; TGMdiVerticalWinResizer Vertical Window Resizer; TGMdiWinResizer Window Resizer; TGMenuBar Menu bar class; TGMenuEntry Menu entry class; TGMenuTitle Menu title class; TGMimeTypes Pool of mime type objects; TGMsgBox A message dialog box; TGNumberEntry Entry field widget for several numeric formats; TGNumberEntryField A text entry field used by a TGNumberEntry; TGNumberEntryLayout Layout manager for number entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGQt Interface to Qt GUI; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGSFile Read a ROOT file from the Google Storage cloud; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectBox TreeView dialog widget; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interfac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:84365,cache,cache,84365,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['cache'],['cache']
Performance,"metry MDI Geometry; TGMdiHorizontalWinResizer Horizontal Window Resizer; TGMdiMainFrame MDI main frame; TGMdiMenuBar MDI menu bar; TGMdiTitleBar MDI Title Bar; TGMdiTitleIcon MDI Title Icon; TGMdiVerticalWinResizer Vertical Window Resizer; TGMdiWinResizer Window Resizer; TGMenuBar Menu bar class; TGMenuEntry Menu entry class; TGMenuTitle Menu title class; TGMimeTypes Pool of mime type objects; TGMsgBox A message dialog box; TGNumberEntry Entry field widget for several numeric formats; TGNumberEntryField A text entry field used by a TGNumberEntry; TGNumberEntryLayout Layout manager for number entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGQt Interface to Qt GUI; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectBox TreeView dialog widget; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider wid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:77300,cache,cache,77300,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,5,['cache'],['cache']
Performance,"metry MDI Geometry; TGMdiHorizontalWinResizer Horizontal Window Resizer; TGMdiMainFrame MDI main frame; TGMdiMenuBar MDI menu bar; TGMdiTitleBar MDI Title Bar; TGMdiTitleIcon MDI Title Icon; TGMdiVerticalWinResizer Vertical Window Resizer; TGMdiWinResizer Window Resizer; TGMenuBar Menu bar class; TGMenuEntry Menu entry class; TGMenuTitle Menu title class; TGMimeTypes Pool of mime type objects; TGMsgBox A message dialog box; TGNumberEntry Entry field widget for several numeric formats; TGNumberEntryField A text entry field used by a TGNumberEntry; TGNumberEntryLayout Layout manager for number entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGQt Interface to Qt GUI; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider widget abstract base class; TGSpeedo Ba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:82250,cache,cache,82250,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['cache'],['cache']
Performance,"mevirtual TInetAddress GetPeerName(int sock)Get Internet Protocol (IP) address of remote host and port #.Definition TSystem.cxx:2300; TSystem::Nowvirtual TTime Now()Get current time in milliseconds since 0:00 Jan 1 1995.Definition TSystem.cxx:463; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::GetSysInfovirtual int GetSysInfo(SysInfo_t *info) constReturns static system info, like OS type, CPU type, number of CPUs RAM size, etc into the SysInfo_t s...Definition TSystem.cxx:2458; TSystem::fFlagsOptTString fFlagsOptDefinition TSystem.h:309; TSystem::GetMemInfovirtual int GetMemInfo(MemInfo_t *info) constReturns ram and swap memory usage info into the MemInfo_t structure.Definition TSystem.cxx:2479; TSystem::GetAclicModevirtual EAclicMode GetAclicMode() constAclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:3947; TSystem::GetLinkedLibrariesvirtual const char * GetLinkedLibraries()Get list of shared libraries loaded at the start of the executable.Definition TSystem.cxx:2120; TSystem::SetIncludePathvirtual void SetIncludePath(const char *includePath)IncludePath should contain the list of compiler flags to indicate where to find user defined header f...Definition TSystem.cxx:4194; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:179858,load,loaded,179858,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"mial(double a, double b, double c, double d). Construct a Polynomial of degree 3 : a*x**3 + b*x**2 + c*x + d. Polynomial(double a, double b, double c, double d, double e). Construct a Polynomial of degree 4 : a*x**4 + b*x**3 + c*x**2 + dx + e. virtual ~Polynomial(); {}. const std::vector<std::complex <double> > & FindRoots(); use default copy-ctor and assignment operators; using ParamFunction::operator();. Find the polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). std::vector<double > FindRealRoots(). Find the only the real polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). const std::vector<std::complex <double> > & FindNumRoots(). Find the polynomial roots using always an iterative numerical methods; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). unsigned int Order() const. Order of Polynomial. { return fOrder; }. IGenFunction * Clone() const. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Implement the interface specified bby ROOT::Math::IGradientOneDim.; In the case of polynomial there is no advantage to compute both at the same time. double DoEvalPar(double x, const double* p) const. double DoDerivative(double x) const. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const. » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Polynomial.html:7264,Optimiz,Optimized,7264,root/html602/ROOT__Math__Polynomial.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Polynomial.html,1,['Optimiz'],['Optimized']
Performance,"mial(double a, double b, double c, double d). Construct a Polynomial of degree 3 : a*x**3 + b*x**2 + c*x + d. Polynomial(double a, double b, double c, double d, double e). Construct a Polynomial of degree 4 : a*x**4 + b*x**3 + c*x**2 + dx + e. virtual ~Polynomial(); {}. const std::vector<std::complex <double> > & FindRoots(); use default copy-ctor and assignment operators; using ParamFunction::operator();. Find the polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). std::vector<double > FindRealRoots(). Find the only the real polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). const std::vector<std::complex <double> > & FindNumRoots(). Find the polynomial roots using always an iterative numerical methods; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). unsigned int Order() const. Order of Polynomial. { return fOrder; }. IGenFunction * Clone() const. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Implement the interface specified bby ROOT::Math::IGradientOneDim.; In the case of polynomial there is no advantage to compute both at the same time. double DoEvalPar(double x, const double* p) const. double DoDerivative(double x) const. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Polynomial.html:5562,Optimiz,Optimized,5562,root/html534/ROOT__Math__Polynomial.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Polynomial.html,1,['Optimiz'],['Optimized']
Performance,"mial(double a, double b, double c, double d). Construct a Polynomial of degree 3 : a*x**3 + b*x**2 + c*x + d. Polynomial(double a, double b, double c, double d, double e). Construct a Polynomial of degree 4 : a*x**4 + b*x**3 + c*x**2 + dx + e. virtual ~Polynomial(); {}. const std::vector<std::complex <double> > & FindRoots(); use default copy-ctor and assignment operators; using ParamFunction::operator();. Find the polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). std::vector<double > FindRealRoots(). Find the only the real polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). const std::vector<std::complex <double> > & FindNumRoots(). Find the polynomial roots using always an iterative numerical methods; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). unsigned int Order() const. Order of Polynomial. { return fOrder; }. IGenFunction * Clone() const. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Implement the interface specified bby ROOT::Math::IGradientOneDim.; In the case of polynomial there is no advantage to compute both at the same time. double DoEvalPar(double x, const double* p) const. double DoDerivative(double x) const. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__Polynomial.html:7264,Optimiz,Optimized,7264,root/html604/ROOT__Math__Polynomial.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__Polynomial.html,1,['Optimiz'],['Optimized']
Performance,"mials. TF1. Change of its inheritance structure. TF1 has not anymore TFormula as a base class, so this code. TF1 * f1 = new TF1(""f1"",""f1"",""sin(x)"",0,10);; TFormula * formula = (TFormula *) f1;; it is not valid anymore. The equivalent correct code is now; TF1 * f1 = new TF1(""f1"",""f1"",""sin(x)"",0,10);; TFormula * formula = f1->GetFormula();. Allow possibility to automatically normalize itself. If the function TF1::SetNormalized(true) is called, when evaluated, the function will return its value divided by its integral computed in the function range. TF1NormSum. New helper class computing the normalized sum of TF1 objects. It is a functor class which can be used as input to a global TF1 for fitting a sum of normalized components. This is useful for example in signal plus background fit, where one can fit directly the number of signal and background events, without the need to use something like TF1::IntegralError. See the tutorial tutorials/fit/fitNormSum.C as an example on how to use the TF1NormSum and perform such a fit. TF1Convolution. Another helper functor class for performing numerical convolution of functions, expressed as TF1 objects, using Fast Fourier Transform. The class requires the FFTW package installed in ROOT. The tutorial tutorials/fit/fitConvolution.C provides an example on how to create a TF1 based on the convolution of two others TF1 objects and used it to fit some data. TGraph2DPainter. In some case and extra point was drawn in the center od the plot when a TGRaph2dwas drawn with P, P0, or PCOL options. THistPainter. It was possible to interactively zoom outside the histograms’ limits. Protections have been added.; When an histogram was drawn with the option E0 and log scale along the Y axis, some additional markers were drawn at the bottom line of the plot. This was reported <a href=“http://root.cern.ch/phpBB3/viewtopic.php?f=3&t=18778”>here.; Implement the option 0 combined with the option COL as requested <a href=“https://root.cern.ch/phpBB3/view",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:16426,perform,perform,16426,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['perform'],['perform']
Performance,"milliseconds with a tone of frequency freq. ;  ; Bool_t cd (const char *path);  ; virtual void CleanCompiledMacros ();  Remove the shared libs produced by the CompileMacro() function, together with their rootmaps, linkdefs, and pcms (and some more on Windows). ;  ; virtual int CompileMacro (const char *filename, Option_t *opt="""", const char *library_name="""", const char *build_dir="""", UInt_t dirmode=0);  This method compiles and loads a shared library containing the code from the file ""filename"". ;  ; virtual char * ConcatFileName (const char *dir, const char *name);  Concatenate a directory and a file name. User must delete returned string. ;  ; virtual const char * DirName (const char *pathname);  Return the directory name in pathname. ;  ; char * DynamicPathName (const char *lib, Bool_t quiet=kFALSE);  Find a dynamic library called lib using the system search paths. ;  ; virtual void ExitLoop ();  Exit from event loop. ;  ; virtual EAclicMode GetAclicMode () const;  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual Int_t GetAclicProperties () const;  Return the ACLiC properties field. ;  ; void GetBeepDefaults (Int_t &freq, Int_t &duration) const;  ; virtual const char * GetBuildArch () const;  Return the build architecture. ;  ; virtual const char * GetBuildCompiler () const;  Return the build compiler. ;  ; virtual const char * GetBuildCompilerVersion () const;  Return the build compiler version. ;  ; virtual const char * GetBuildCompilerVersionStr () const;  Return the build compiler version identifier string. ;  ; virtual const char * GetBuildDir () const;  Return the path of the build directory. ;  ; virtual const char * GetBuildNode () const;  Return the build node name. ;  ; virtual TString GetDirName (const char *pathname);  Return the directory name in pathname. ;  ; virtual void * GetDirPtr () const;  ; const char * GetErrorStr () const;  ; virtual const char * GetFlagsDebug () const;  Return the debug flags",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:14432,optimiz,optimized,14432,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,2,['optimiz'],['optimized']
Performance,"min(rangeName),2))+(1./""; ""3)*(pow(x.max(rangeName)-B,3)-pow(x.min(rangeName)-B,3))"");; ; // U s e i n s t a n c e o f c r e a t e d c l a s s; // ---------------------------------------------------------; ; // Compile MyPdfV3 class; gROOT->ProcessLineSync("".x MyPdfV3.cxx+"");; ; // Create instance of MyPdfV3 class; RooRealVar a(""a"", ""a"", 1);; RooRealVar b(""b"", ""b"", 2, -10, 10);; RooRealVar y(""y"", ""y"", -10, 10);; ; // We need to hide the type to run in a ROOT macro; RooWorkspace w(""w"");; w.factory(""MyPdfV3::pdf(y[-10,10], a[1], b[2,-10,10])"");; auto pdf = w.pdf(""pdf"");; ; // Generate toy data from pdf and plot data and pdf on frame; RooPlot *frame1 = y.frame(Title(""Compiled class MyPdfV3""));; std::unique_ptr<RooDataSet> data{pdf->generate(y, 1000)};; pdf->fitTo(*data, PrintLevel(-1));; data->plotOn(frame1);; pdf->plotOn(frame1);; ; // -----------------------------------------------------------------; // C o m p i l e d v e r s i o n o f e x a m p l e r f 1 0 3; // =================================================================; ; // Declare observable x; RooRealVar x(""x"", ""x"", -20, 20);; ; // The RooClassFactory::makePdfInstance() function performs code writing, compiling, linking; // and object instantiation in one go and can serve as a straight replacement of RooGenericPdf; ; RooRealVar alpha(""alpha"", ""alpha"", 5, 0.1, 10);; RooAbsPdf *genpdf =; RooClassFactory::makePdfInstance(""GenPdf"", ""(1+0.1*fabs(x)+sin(sqrt(fabs(x*alpha+0.1))))"", RooArgSet(x, alpha));; ; // Generate a toy dataset from the interpreted pdf; std::unique_ptr<RooDataSet> data2{genpdf->generate(x, 50000)};; ; // Fit the interpreted pdf to the generated data; genpdf->fitTo(*data2, PrintLevel(-1));; ; // Make a plot of the data and the pdf overlaid; RooPlot *frame2 = x.frame(Title(""Compiled version of pdf of rf103""));; data2->plotOn(frame2);; genpdf->plotOn(frame2);; ; // Draw all frames on a canvas; TCanvas *c = new TCanvas(""rf104_classfactory"", ""rf104_classfactory"", 800, 400);; c->Divide(2);; c->cd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf104__classfactory_8C.html:3339,perform,performs,3339,doc/master/rf104__classfactory_8C.html,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8C.html,1,['perform'],['performs']
Performance,"min(x), max(x)], where; nout = max(nout, number of input data).; xout: an optional set of values at which to evaluate the fit. void BDRksmooth(Double_t* x, Double_t* y, Int_t n, Double_t* xp, Double_t* yp, Int_t np, Int_t kernel, Double_t bw); Smooth data with specified kernel*-*-; *-* =================================. Based on R function ksmooth: Translated to C++ by C. Stratowa; (R source file: ksmooth.c by B.D.Ripley Copyright (C) 1998). -. TGraph * SmoothLowess(TGraph* grin, Option_t* option = """", Double_t span = 0.67, Int_t iter = 3, Double_t delta = 0); Smooth data with Lowess smoother*-*-. This function performs the computations for the LOWESS smoother; (see the reference below). Lowess returns the output points; x and y which give the coordinates of the smooth. Arguments:; grin: Input graph. span: the smoother span. This gives the proportion of points in the plot; which influence the smooth at each value.; Larger values give more smoothness.; iter: the number of robustifying iterations which should be performed.; Using smaller values of iter will make lowess run faster.; delta: values of x which lie within delta of each other replaced by a; single value in the output from lowess.; For delta = 0, delta will be calculated. References:; Cleveland, W. S. (1979) Robust locally weighted regression and smoothing; scatterplots. J. Amer. Statist. Assoc. 74, 829-836.; Cleveland, W. S. (1981) LOWESS: A program for smoothing scatterplots; by robust locally weighted regression.; The American Statistician, 35, 54. void Lowess(Double_t* x, Double_t* y, Int_t n, Double_t* ys, Double_t span, Int_t iter, Double_t delta); Lowess regression smoother*-*-*-*-*-. Based on R function clowess: Translated to C++ by C. Stratowa; (R source file: lowess.c by R Development Core Team (C) 1999-2001). -. void Lowest(Double_t* x, Double_t* y, Int_t n, Double_t& xs, Double_t& ys, Int_t nleft, Int_t nright, Double_t* w, Bool_t userw, Double_t* rw, Bool_t& ok); Fit value at x[i] *-*-*-*-*-*-*-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphSmooth.html:9302,perform,performed,9302,root/html528/TGraphSmooth.html,https://root.cern,https://root.cern/root/html528/TGraphSmooth.html,4,['perform'],['performed']
Performance,"min)/fNpx. This way, the step size can be controlled via the SetNpx() function. If the function is unimodal or if its extrema are far apart, setting the fNpx to a small value speeds the algorithm up many times. Then, Brent's method is applied on the bracketed interval epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ) and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number of iteration of the Brent algorithm If the flag logx is set the grid search is done in log step size This is done automatically if the log scale is set in the current Pad; NOTE: see also TF1::GetMaximumX and TF1::GetX ; Reimplemented from TF1.; Definition at line 498 of file TF1.cxx. ◆ GetMinimumXY(). Double_t TF2::GetMinimumXY ; (; Double_t & ; x, . Double_t & ; y . ); const. virtual . Compute the X and Y values corresponding to the minimum value of the function. ; Return the minimum value of the function To find the minimum on a range, first set this range via the SetRange function; Method: First, a grid search is performed to find the initial estimate of the minimum location. The range of the function is divided into fNpx and fNpy sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed by SetNpx and SetNpy functions Then, a minimization is used with starting values found by the grid search The minimizer algorithm used (by default Minuit) can be changed by callinga ROOT::Math::Minimizer::SetDefaultMinimizerType("".."") Other option for the minimizer can be set using the static method of the MinimizerOptions class; Note that this method will always do first a grid search in contrast to GetMinimum ; Definition at line 425 of file TF2.cxx. ◆ GetNpy(). Int_t TF2::GetNpy ; (; ); const. inline . Definition at line 96 of file TF2.h. ◆ GetObjectInfo(). char * TF2::GetObjectInfo ; (; Int_t ; px, . Int_t ; py . ); const. overridevirtual . Redefines TObject::GetObjectInfo. ; Displays the function value corresponding to cursor position px,py ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF2.html:60374,perform,performed,60374,doc/master/classTF2.html,https://root.cern,https://root.cern/doc/master/classTF2.html,1,['perform'],['performed']
Performance,"min=1 and ixmax=NbinsX the underflow and/or overflow in X will be excluded; By setting iymin=1 and/or iymax=NbinsY the underflow and/or overflow in Y will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad,; the histogram is reset and filled again with the projected contents of the TH3. implemented using Project3D. TH1D * DoProject1D(const char* name, const char* title, int imin1, int imax1, int imin2, int imax2, const TAxis* projAxis, const TAxis* axis1, const TAxis* axis2, Option_t* option) const; internal methdod performing the projection to 1D histogram; called from TH3::Project3D. TH1D * DoProject1D(const char* name, const char* title, const TAxis* projAxis, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal methdod performing the projection to 1D histogram; called from other TH3::DoProject1D. TH2D * DoProject2D(const char* name, const char* title, const TAxis* projX, const TAxis* projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal method performing the projection to a 2D histogram; called from TH3::Project3D. TH1 * Project3D(Option_t* option = ""x"") const; Project a 3-d histogram into 1 or 2-d histograms depending on the; option parameter; option may contain a combination of the characters x,y,z,e; option = ""x"" return the x projection into a TH1D histogram; option = ""y"" return the y projection into a TH1D histogram; option = ""z"" return the z projection into a TH1D histogram; option = ""xy"" return the x versus y projection into a TH2D histogram; option = ""yx"" return the y versus x projection into a TH2D histogram; option = ""xz"" return the x versus z projection into a TH2D histogram; option = ""zx"" return the z versus x pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH3.html:46058,perform,performing,46058,root/html602/TH3.html,https://root.cern,https://root.cern/root/html602/TH3.html,2,['perform'],['performing']
Performance,"minimization; RooRealProxy_nllInput -log(L) function; RooSetProxy_obsParameters of profile likelihood; RooArgSet_obsAbsMinObservable values at absolute minimum; TIterator*_oiter! Iterator of profile likelihood output parameter(s); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_parMarginialized parameters of likelihood; RooArgSet_paramAbsMinParameter values at absolute minimum; map<string,bool>_paramFixedParameter constant status at last time of use; TIterator*_piter! Iterator over profile likelihood parameters to be minimized; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_startFromMinAlways start minimization for global minimum?; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProfileLL.html:37930,cache,cache,37930,root/html602/RooProfileLL.html,https://root.cern,https://root.cern/root/html602/RooProfileLL.html,2,['cache'],['cache']
Performance,"mit reading of branches to the ones we need.; When a selector is used with a TChain in methods Process(), ProcessFill(), ProcessCut(), you must use the pointer to the current TTree to call the method GetEntry(entry). The parameter entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use. fChain->GetTree()->GetEntry(entry);; To create a selector call:; root[] T->MakeSelector(""MySelector"");; Where T is the TTree and MySelector is the name of created class and the name of the .h and .C files. The resulting TSelector is the argument to TTree::Process. The argument can be the file name or a pointer to the selector object.; root[] T->Process(""MySelector.C"","""",1000,100);; This call will interpret the class defined in MySelector.C and process 1000 entries beginning with entry 100. The file name can be appended with a “+” or a “++” to use ACLiC.; root[] T->Process(""MySelector.C++"","""",1000,100);; When appending a “++”, the class will be compiled and dynamically loaded.; root[] T->Process(""MySelector.C+"","""",1000,100);; When appending a “+”, the class will also be compiled and dynamically loaded. When it is called again, it recompiles only if the macro (MySelector.C) has changed since it was compiled last. If not, it loads the existing library. The next example shows how to create a selector with a pointer:; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; Using this form, you can do things like:; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; TTree::Process() is aware of PROOF, ROOT parallel processing facility. If PROOF is setup, it divides the processing amongst the slave CPUs.; 12.22.1 Performance Benchmarks. The program $ROOTSYS/test/bench.cxx compares the I/O performance of STL vectors to the ROOT native TClonesArrays collecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:646190,load,loaded,646190,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"mitsFinder.cxx. ◆ FindGoodLimits() [3/3]. Int_t THLimitsFinder::FindGoodLimits ; (; TH1 * ; h, . Double_t ; xmin, . Double_t ; xmax, . Double_t ; ymin, . Double_t ; ymax, . Double_t ; zmin, . Double_t ; zmax . ). virtual . Compute the best axis limits for the X, Y and Z axis. ; If the bit kIsInteger is set, the number of channels is also recomputed. The axis parameters are replaced by the optimized parameters ; Reimplemented in TProofLimitsFinder.; Definition at line 111 of file THLimitsFinder.cxx. ◆ GetLimitsFinder(). THLimitsFinder * THLimitsFinder::GetLimitsFinder ; (; ). static . Return pointer to the current finder. ; Create one if none exists Use SetLimitsFinder to set a user defined finder. ; Definition at line 153 of file THLimitsFinder.cxx. ◆ IsA(). TClass * THLimitsFinder::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TProofLimitsFinder.; Definition at line 46 of file THLimitsFinder.h. ◆ Optimize(). void THLimitsFinder::Optimize ; (; Double_t ; A1, . Double_t ; A2, . Int_t ; nold, . Double_t & ; BinLow, . Double_t & ; BinHigh, . Int_t & ; nbins, . Double_t & ; BinWidth, . Option_t * ; option = """" . ). static . Static function to compute reasonable axis limits. ; Input parameters:; Parameters. [in]A1,A2: Original axis limits ; [in]BinLow,BinHigh: Optimized axis limits. They should be initialized by the calling method for instance to 0. ; [out]nold: Original number of divisions. ; [out]nbins: Optimized number of divisions. ; [out]BinWidth: Optimized bin width. It should be initialized by the calling method for instance to 0. ; [in]option: ""T"" means Time axis. . Definition at line 184 of file THLimitsFinder.cxx. ◆ OptimizeLimits(). void THLimitsFinder::OptimizeLimits ; (; Int_t ; nbins, . Int_t & ; newbins, . Double_t & ; xmin, . Double_t & ; xmax, . Bool_t ; isInteger . ). static . Optimize axis limits. ; When isInter=kTRUE, the function makes an integer binwidth and recompu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHLimitsFinder.html:14312,Optimiz,Optimize,14312,doc/master/classTHLimitsFinder.html,https://root.cern,https://root.cern/doc/master/classTHLimitsFinder.html,1,['Optimiz'],['Optimize']
Performance,"mitted, the first default column is used instead.; 2838 /// \param[in] aggIdentity The aggregator variable of each thread is initialized to this value (or is default-constructed if the parameter is omitted); 2839 /// \return the result of the aggregation wrapped in a RResultPtr.; 2840 ///; 2841 /// An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is; 2842 /// initialized to aggIdentity or default-constructed if aggIdentity is omitted.; 2843 /// This action calls the aggregator callable for each processed entry, passing in the aggregator variable and; 2844 /// the value of the column columnName.; 2845 /// If the signature is `U(U,T)` the aggregator variable is then copy-assigned the result of the execution of the callable.; 2846 /// Otherwise the signature of aggregator must be `void(U&,T)`.; 2847 ///; 2848 /// The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions.; 2849 /// If its signature is `U(U,U)` the aggregator variables of each thread are merged two by two.; 2850 /// If its signature is `void(std::vector<U>& a)` it is assumed that it merges all aggregators in a[0].; 2851 ///; 2852 /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; 2853 ///; 2854 /// Example usage:; 2855 /// ~~~{.cpp}; 2856 /// auto aggregator = [](double acc, double x) { return acc * x; };; 2857 /// ROOT::EnableImplicitMT();; 2858 /// // If multithread is enabled, the aggregator function will be called by more threads; 2859 /// // and will produce a vector of partial accumulators.; 2860 /// // The merger function performs the final aggregation of these partial results.; 2861 /// auto merger = [](std::vector<double> &accumulators) {; 2862 /// for (auto i : ROOT::TSeqU(1u, accumulators.size())) {; 2863 /// accumulators[0] *= accumulators[i];; 2864 /// }; 2865 /// };; 2866 ///; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:159628,multi-thread,multi-thread,159628,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['multi-thread'],['multi-thread']
Performance,"mize; kIgnoreTObjectStreamer; kRecovered; kNeedCheck; kIsCompiled; };; enum EReadWrite { kBase; kOffsetL; kOffsetP; kCounter; kCharStar; kChar; kShort; kInt; kLong; kFloat; kDouble; kDouble32; kUChar; kUShort; kUInt; kULong; kBits; kLong64; kULong64; kBool; kFloat16; kObject; kAny; kObjectp; kObjectP; kTString; kTObject; kTNamed; kAnyp; kAnyP; kAnyPnoVT; kSTLp; kSkip; kSkipL; kSkipP; kConv; kConvL; kConvP; kSTL; kSTLstring; kStreamer; kStreamLoop; kCache; kArtificial; kCacheNew; kCacheDelete; kMissing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfIsBuilt! true if the StreamerInfo has been 'built'; TStringTNamed::fNameobject identifier; Bool_tfOptimized! true if the Streamer has been optimized; TStringTNamed::fTitleobject title; static Bool_tfgCanDeleteTrue if ReadBuffer can delete object; static TVirtualStreamerInfo*fgInfoFactory; static Bool_tfgOptimizeTrue if optimization on; static Bool_tfgStreamMemberWiseTrue if the collections are to be stream ""member-wise"" (when possible). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualStreamerInfo& operator=(const TVirtualStreamerInfo& ); assignment operator. ~TVirtualStreamerInfo(); Destructor. Bool_t CanDelete(); static function returning true if ReadBuffer can delete object. Bool_t CanOptimize(); static function returning true if optimization can be on. TStreamerBasicType * GetElementCounter(const char* countName, TClass* cl); Get pointer to a TStreamerBasicType in TClass *cl; static function. Bool_t GetStreamMemberWise(); Return whether the TStreamerInfos will save the collections in; ""member-wise"" order whenever possible. The default is to store member-wise.; kTRUE indicates member-wise storing; kFALSE inddicates object-wise storing. A collect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualStreamerInfo.html:8562,optimiz,optimized,8562,root/html528/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html528/TVirtualStreamerInfo.html,6,['optimiz'],"['optimization', 'optimized']"
Performance,"mizeConfigParameters.cxx. ◆ GetROCIntegral(). Double_t TMVA::OptimizeConfigParameters::GetROCIntegral ; (; ). private . calculate the area (integral) under the ROC curve as a overall quality measure of the classification ; making pdfs out of the MVA-output distributions doesn't work reliably for cases where the MVA-output isn't a smooth distribution. this happens ""frequently"" in BDTs for example when the number of trees is small resulting in only some discrete possible MVA output values. (I still leave the code here, but use this with care!!! The default however is to use the distributions!!! ; Definition at line 458 of file OptimizeConfigParameters.cxx. ◆ GetScanIndices(). std::vector< int > TMVA::OptimizeConfigParameters::GetScanIndices ; (; int ; val, . std::vector< int > ; base . ). private . helper function to scan through the all the combinations in the parameter space ; Definition at line 149 of file OptimizeConfigParameters.cxx. ◆ GetSeparation(). Double_t TMVA::OptimizeConfigParameters::GetSeparation ; (; ). private . return the separation between the signal and background MVA ouput distribution ; Definition at line 434 of file OptimizeConfigParameters.cxx. ◆ GetSigEffAtBkgEff(). Double_t TMVA::OptimizeConfigParameters::GetSigEffAtBkgEff ; (; Double_t ; bkgEff = 0.1). private . calculate the signal efficiency for a given background efficiency ; Definition at line 509 of file OptimizeConfigParameters.cxx. ◆ IsA(). virtual TClass * TMVA::OptimizeConfigParameters::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::IFitterTarget.; Definition at line 100 of file OptimizeConfigParameters.h. ◆ Log(). MsgLogger & TMVA::OptimizeConfigParameters::Log ; (; ); const. inlineprivate . Definition at line 98 of file OptimizeConfigParameters.h. ◆ optimize(). std::map< TString, Double_t > TMVA::OptimizeConfigParameters::optimize ; (; ). Definition at line 127 of file OptimizeConfigParameters.cxx. ◆ optimizeFit(). void TMVA::O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:8343,Optimiz,OptimizeConfigParameters,8343,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance,"mizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<std::string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsTFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Short_tfCodes[500]List of leaf numbers referenced in formula; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayTFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayTFormula::fLinearPar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:14946,optimiz,optimization,14946,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,3,['optimiz'],['optimization']
Performance,"ml.cxx. ◆ IsLightColor(). int TGHtml::IsLightColor ; (; ColorStruct_t * ; p). protected . Check to see if the given color is too light to be easily distinguished from white. ; Definition at line 1725 of file TGHtml.cxx. ◆ IsVisited(). virtual int TGHtml::IsVisited ; (; const char * ; ). inlinevirtual . Definition at line 924 of file TGHtml.h. ◆ ItemLayout(). Bool_t TGHtml::ItemLayout ; (; ). overridevirtual . Layout html widget. ; Reimplemented from TGView.; Definition at line 834 of file TGHtml.cxx. ◆ LayoutDoc(). void TGHtml::LayoutDoc ; (; ). protected . Advance the layout as far as possible. ; Definition at line 1178 of file TGHtmlLayout.cxx. ◆ ListTokens(). TGString * TGHtml::ListTokens ; (; TGHtmlElement * ; p, . TGHtmlElement * ; pEnd . ). Return all tokens between the two elements as a string list. ; Definition at line 1454 of file TGHtmlParse.cxx. ◆ LoadImage(). TImage * TGHtml::LoadImage ; (; const char * ; url, . int ; w = 0, . int ; h = 0 . ). virtual . This is the default LoadImage() procedure. ; It just tries to load the image from a file in the local filesystem. ; Definition at line 292 of file TGHtmlImage.cxx. ◆ LostSelection(). void TGHtml::LostSelection ; (; ). protected . Clear selection. ; Definition at line 2027 of file TGHtml.cxx. ◆ MakeInvisible(). void TGHtml::MakeInvisible ; (; TGHtmlElement * ; p_first, . TGHtmlElement * ; p_last . ). protected . Add the STY_Invisible style to every token between p_first and p_last. ; Definition at line 144 of file TGHtmlSizer.cxx. ◆ MakeMarkupEntry(). TGHtmlMarkupElement * TGHtml::MakeMarkupEntry ; (; int ; objType, . int ; type, . int ; argc, . int ; arglen[], . char * ; argv[] . ). protected . Make one markup entry. ; Definition at line 1006 of file TGHtmlParse.cxx. ◆ MapControls(). int TGHtml::MapControls ; (; ). protected . Map any control that should be visible according to the current scroll position. ; At the same time, if any controls that should not be visible are mapped, unmap them. After this rou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:76388,Load,LoadImage,76388,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['Load'],['LoadImage']
Performance,"mlink_file(pcmFileNameFullPath)); 1836 pcmFileNameFullPath = ROOT::TMetaUtils::GetRealPath(pcmFileNameFullPath);; 1837 ; 1838 auto pendingRdict = fPendingRdicts.find(pcmFileNameFullPath);; 1839 if (pendingRdict != fPendingRdicts.end()) {; 1840 llvm::StringRef pcmContent = pendingRdict->second;; 1841 TMemFile::ZeroCopyView_t range{pcmContent.data(), pcmContent.size()};; 1842 std::string RDictFileOpts = pcmFileNameFullPath + ""?filetype=pcm"";; 1843 TMemFile pcmMemFile(RDictFileOpts.c_str(), range);; 1844 ; 1845 cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());; 1846 LoadPCMImpl(pcmMemFile);; 1847 // Currently the module file are never unloaded (even if the library is; 1848 // unloaded) and, of course, never reloaded.; 1849 // Consequently, we must NOT remove the `pendingRdict` from the list; 1850 // of pending dictionary, otherwise if a library is unloaded and then; 1851 // reload we will be unable to update properly the TClass object; 1852 // (because we wont be able to load the rootpcm file by executing the; 1853 // above lines); 1854 ; 1855 return;; 1856 }; 1857 ; 1858 if (!llvm::sys::fs::exists(pcmFileNameFullPath)) {; 1859 ::Error(""TCling::LoadPCM"", ""ROOT PCM %s file does not exist"",; 1860 pcmFileNameFullPath.data());; 1861 if (!fPendingRdicts.empty()); 1862 for (const auto &rdict : fPendingRdicts); 1863 ::Info(""TCling::LoadPCM"", ""In-memory ROOT PCM candidate %s\n"",; 1864 rdict.first.c_str());; 1865 return;; 1866 }; 1867 ; 1868 if (!gROOT->IsRootFile(pcmFileName)) {; 1869 Fatal(""LoadPCM"", ""The file %s is not a ROOT as was expected\n"", pcmFileName.Data());; 1870 return;; 1871 }; 1872 TFile pcmFile(pcmFileName + ""?filetype=pcm"", ""READ"");; 1873 LoadPCMImpl(pcmFile);; 1874}; 1875 ; 1876//______________________________________________________________________________; 1877 ; 1878namespace {; 1879 using namespace clang;; 1880 ; 1881 class ExtLexicalStorageAdder: public RecursiveASTVisitor<ExtLexicalStorageAdder>{; 1882 // This class is to be consid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:69946,load,load,69946,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,"['Load', 'load']","['LoadPCM', 'load']"
Performance,"mlist = gTools().SplitString( myMethodList, ',' );; 115 for (UInt_t i=0; i<mlist.size(); i++) {; 116 std::string regMethod(mlist[i].Data());; 117 ; 118 if (Use.find(regMethod) == Use.end()) {; 119 std::cout << ""Method \"""" << regMethod << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; 120 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) std::cout << it->first << "" "";; 121 std::cout << std::endl;; 122 return;; 123 }; 124 Use[regMethod] = 1;; 125 }; 126 }; 127 ; 128 // --------------------------------------------------------------------------------------------------; 129 ; 130 // Here the preparation phase begins; 131 ; 132 // Create a new root output file; 133 TString outfileName( ""TMVAReg.root"" );; 134 TFile* outputFile = TFile::Open( outfileName, ""RECREATE"" );; 135 ; 136 // Create the factory object. Later you can choose the methods; 137 // whose performance you'd like to investigate. The factory will; 138 // then run the performance analysis for you.; 139 //; 140 // The first argument is the base of the name of all the; 141 // weightfiles in the directory weight/; 142 //; 143 // The second argument is the output file for the training results; 144 // All TMVA output can be suppressed by removing the ""!"" (not) in; 145 // front of the ""Silent"" argument in the option string; 146 TMVA::Factory *factory = new TMVA::Factory( ""TMVARegression"", outputFile,; 147 ""!V:!Silent:Color:DrawProgressBar:AnalysisType=Regression"" );; 148 ; 149 ; 150 TMVA::DataLoader *dataloader=new TMVA::DataLoader(""datasetreg"");; 151 // If you wish to modify default settings; 152 // (please check ""src/Config.h"" to see all available global options); 153 //; 154 // (TMVA::gConfig().GetVariablePlotting()).fTimesRMS = 8.0;; 155 // (TMVA::gConfig().GetIONames()).fWeightFileDir = ""myWeightDirectory"";; 156 ; 157 // Define the input variables that shall be used for the MVA training; 158 // note that you may also use variable expressions, su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C_source.html:4541,perform,performance,4541,doc/master/TMVARegression_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C_source.html,1,['perform'],['performance']
Performance,"mma; , ;   kDelta. };  . Private Member Functions; bool canComputeBatchWithCuda () const override;  ; void doEval (RooFit::EvalContext &) const override;  Compute multiple values of the Johnson distribution. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  . Private Attributes; RooRealProxy _delta;  ; RooRealProxy _gamma;  ; RooRealProxy _lambda;  ; RooRealProxy _mass;  ; double _massThreshold {-1.E300};  ; RooRealProxy _mu;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooJohnson.html:60491,Cache,CacheMode,60491,doc/master/classRooJohnson.html,https://root.cern,https://root.cern/doc/master/classRooJohnson.html,1,['Cache'],['CacheMode']
Performance,"mmentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2791; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5209; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2897; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4215; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2396; TClass::SetStreamerImplvoid SetStreamerImpl()Internal routine to set fStreamerImpl based on the value of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:333678,cache,caches,333678,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['cache'],['caches']
Performance,"mmentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2791; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5209; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2897; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4215; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2396; TClass::SetStreamerImplvoid SetStreamerImpl()Internal routine to set fStreamerImpl based on the value of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:68736,cache,caches,68736,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['cache'],['caches']
Performance,"mmentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5276; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4282; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2463; TClass::SetStreamerImplvoid SetStreamerImpl()Internal routine to set fStreamerImpl based on the value of fStreamerType.Definition TClass.cxx:6282; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3690; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2250; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:4040; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:336316,cache,caches,336316,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['cache'],['caches']
Performance,"mmentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5276; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4282; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2463; TClass::SetStreamerImplvoid SetStreamerImpl()Internal routine to set fStreamerImpl based on the value of fStreamerType.Definition TClass.cxx:6282; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3690; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2250; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:68564,cache,caches,68564,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['cache'],['caches']
Performance,"mmon one such as int, double, char or float it is nonetheless good practice to specify it as a template parameter to the action itself, like this: df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.; When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing x = 0 rather than x == 0:; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");. User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same time, it allows users to inject their own action code to perform arbitrarily complex data reductions.; Implementing custom actions with Book(); Through the Book() method, users can implement a custom action and have access to the same features that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:; #include <ROOT/RDataFrame.hxx>; #include <memory>; ; class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; std::vector<int> fPerThreadResults;; ; public:; // We use a public type alias to advertise the type of the result of this action; using Result_t = int;; ; MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}; ; // Called before the event loop to retrieve the address of the result that will be filled/generated.; std::shared_ptr<int> GetResultPtr() const { return fFinalResult; }; ; // Called at the beginn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:65094,perform,perform,65094,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['perform'],['perform']
Performance,"mn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBuf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooTreeDataStore.html:17009,cache,cached,17009,root/html528/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html528/RooTreeDataStore.html,4,['cache'],['cached']
Performance,"mn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree(); { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). void setBranchBufferSize(Int_t size); TTree Branch buffer size contro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:16935,cache,cached,16935,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,2,['cache'],['cached']
Performance,"mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; static RooRealVarSharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; static Bool_t_printScientific; static Int_t_printSigDigits; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealVarSharedProperties*_sharedProp! Shared properties associated with this instance; static RooSharedPropertiesList_sharedPropListList of properties shared among clone sets; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealVar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealVar.html:42137,cache,cache,42137,root/html602/RooRealVar.html,https://root.cern,https://root.cern/root/html602/RooRealVar.html,4,['cache'],['cache']
Performance,"mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:30417,cache,cacheList,30417,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,4,['cache'],"['cacheList', 'cached']"
Performance,"mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent, const char* filename, const char* namePat, RooAbsArg* client); Print tree structure of expression tree ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:30214,cache,cacheList,30214,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,2,['cache'],"['cacheList', 'cached']"
Performance,"mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsArg.html:30674,cache,cacheList,30674,root/html532/RooAbsArg.html,https://root.cern,https://root.cern/root/html532/RooAbsArg.html,8,['cache'],"['cacheList', 'cached']"
Performance,"model function from FCN useful for fits done with customized FCN classes ; Definition at line 584 of file Fitter.h. ◆ GetFCN(). ROOT::Math::IMultiGenFunction * ROOT::Fit::Fitter::GetFCN ; (; ); const. inline . return pointer to last used objective function (is NULL in case fit is not yet done) This pointer will be valid as far as the fitter class has not been deleted. ; To be used after the fitting. The pointer should not be stored and will be invalided after performing a new fitting. In this case a new instance of the function pointer will be re-created and can be obtained calling again GetFCN() ; Definition at line 455 of file Fitter.h. ◆ GetMinimizer(). ROOT::Math::Minimizer * ROOT::Fit::Fitter::GetMinimizer ; (; ); const. inline . return pointer to last used minimizer (is NULL in case fit is not yet done) This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone. ; To be used only after fitting. The pointer should not be stored and will be invalided after performing a new fitting. In this case a new instance of ROOT::Math::Minimizer will be re-created and can be obtained calling again GetMinimizer() ; Definition at line 444 of file Fitter.h. ◆ GetNCallsFromFCN(). int ROOT::Fit::Fitter::GetNCallsFromFCN ; (; ). protected . Definition at line 870 of file Fitter.cxx. ◆ IsBinFit(). bool ROOT::Fit::Fitter::IsBinFit ; (; ); const. inline . query if fit is binned. ; In cse of false the fit can be unbinned or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN) ; Definition at line 433 of file Fitter.h. ◆ LeastSquareFit() [1/2]. bool ROOT::Fit::Fitter::LeastSquareFit ; (; const BinData & ; data, . const ROOT::EExecutionPolicy & ; executionPolicy = ROOT::EExecutionPolicy::kSequential . ). inline . Fit a binned data set using a least square fit copying the input data. ; Definition at line 172 of file Fitter.h. ◆ LeastSquareFit() [2/2]. bool ROOT::Fit::Fitter::LeastSquareFit ; (; const std::shared_ptr< Bin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html:27522,perform,performing,27522,doc/master/classROOT_1_1Fit_1_1Fitter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html,1,['perform'],['performing']
Performance,"module at beginning of RooCMStudy run. ;  ; TClass * IsA () const override;  ; bool processAfterFit (Int_t) override;  Save likelihood from nominal fit, fix chosen parameter to its null hypothesis value and rerun fit Save difference in likelihood and associated Gaussian significance in auxiliary dataset. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsMCStudyModule;  RooAbsMCStudyModule (const char *name, const char *title);  Constructor. ;  ;  RooAbsMCStudyModule (const RooAbsMCStudyModule &other);  Copy constructor. ;  ; bool doInitializeInstance (RooMCStudy &);  Initializer method called upon attachment to given RooMCStudy object. ;  ; virtual bool processBeforeGen (Int_t);  Method called after resetting of generator parameters to initial values and before call to generator context Any modifications to generator parameters will affect next generation operation (only) ;  ; virtual bool processBetweenGenAndFit (Int_t);  Method called after generation of toy data sample and resetting of fit parameters to initial values and before actual fit is performed. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDLLSignificanceMCSModule.html:3101,perform,performed,3101,doc/master/classRooDLLSignificanceMCSModule.html,https://root.cern,https://root.cern/doc/master/classRooDLLSignificanceMCSModule.html,1,['perform'],['performed']
Performance,"module, const char *entry)Find specific entry point in specified library.Definition TSystem.cxx:2044; TSystem::GetLinkedLibsvirtual const char * GetLinkedLibs() constReturn the list of library linked to this executable.Definition TSystem.cxx:3992; TSystem::Beepvoid Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)Beep for duration milliseconds with a tone of frequency freq.Definition TSystem.cxx:324; TSystem::fBeepDurationInt_t fBeepDurationDefinition TSystem.h:288; TSystem::IgnoreInterruptvirtual void IgnoreInterrupt(Bool_t ignore=kTRUE)If ignore is true ignore the interrupt signal, else restore previous behaviour.Definition TSystem.cxx:602; TSystem::Syslogvirtual void Syslog(ELogLevel level, const char *mess)Send mess to syslog daemon.Definition TSystem.cxx:1686; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::SetAclicModevirtual void SetAclicMode(EAclicMode mode)AclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:4077; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::LoadAllLibrariesvirtual UInt_t LoadAllLibraries()Load all libraries known to ROOT via the rootmap system.Definition TSystem.cxx:1970; TSystem::GetDirPtrvirtual void * GetDirPtr() constDefinition TSystem.h:416; TSystem::SetObjExtvirtual void SetObjExt(const char *objExt)Set object files extension, should be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:172343,optimiz,optimized,172343,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBukinPdf&operator=(const RooBukinPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBukinPdf.html:22875,optimiz,optimizeCacheMode,22875,root/html602/RooBukinPdf.html,https://root.cern,https://root.cern/root/html602/RooBukinPdf.html,4,['optimiz'],['optimizeCacheMode']
Performance,"moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooGaussian&operator=(const RooGaussian&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGaussian.html:22785,optimiz,optimizeCacheMode,22785,root/html602/RooGaussian.html,https://root.cern,https://root.cern/root/html602/RooGaussian.html,4,['optimiz'],['optimizeCacheMode']
Performance,"moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooVoigtian&operator=(const RooVoigtian&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooVoigtian.html:23300,optimiz,optimizeCacheMode,23300,root/html602/RooVoigtian.html,https://root.cern,https://root.cern/root/html602/RooVoigtian.html,4,['optimiz'],['optimizeCacheMode']
Performance,"moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction4PdfBinding<double,double,double,double,double>&operator=(const RooCFunction4PdfBinding<double,double,double,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html:23626,optimiz,optimizeCacheMode,23626,root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html,4,['optimiz'],['optimizeCacheMode']
Performance,"mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; virtual voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetNumberOfUniqueSlaves() const; Int_tGetQueryReference(Int_t qry, TString& ref); Int_tGoMoreParallel(Int_t nWorkersToAdd); Int_tGoParallel(Int_t nodes, Bool_t accept = kFALSE, Bool_t random = kFALSE); Int_tHandleInputMessage(TSlave* wrk, TMessage* m, Bool_t deactonfail = kFALSE); voidHandleSubmerger(TMessage* mess, TSlave* sl); voidInterrupt(TProof::EUrgent type, TProof::ESlaves list = kActive); voidInterruptCurrentMonitor(); Bool_tIsEndMaster() const; Bool_tIsSync() const; Int_tLoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0, TList* workers = 0); Int_tLoadPackageOnClient(const char* package, TList* loadopts = 0); voidMarkBad(TSlave* wrk, const char* reason = 0); voidMarkBad(TSocket* s, const char* reason = 0); Int_tModifyWorkerLists(const char* ord, Bool_t add, Bool_t save); voidNotifyLogMsg(const char* msg, const char* sfx = ""\n""); voidoperator=(const TProof&); voidParseConfigField(const char* config); Int_tPing(TProof::ESlaves list); Int_tPollForNewWorkers(); voidPrintProgress(Long64_t total, Long64_t processed, Float_t procTime = -1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:24619,load,loadopts,24619,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['load'],['loadopts']
Performance,"more than one adequate generator. If you use Visual Studio, “NMake Makefiles” is a generator you can use for building with NMake. By default, CMake chooses the most specific generator supported by your development environment. If you want an alternative generator, you must tell this to CMake with the -G option.; Options and variables; Variables customize how the build will be generated. Options are boolean variables, with possible values ON/OFF. Options and variables are defined on the CMake command line like this:; $ cmake -DVARIABLE=value path/to/source. You can set a variable after the initial CMake invocation to change its value. You can also undefine a variable:; $ cmake -UVARIABLE path/to/source. Variables are stored in the CMake cache. This is a file named CMakeCache.txt stored at the root of your build directory that is generated by cmake. Editing it yourself is not recommended.; Variables are listed in the CMake cache with the variable name and type separated by a colon. You can also specify the variable and type on the CMake command line:; $ cmake -DVARIABLE:TYPE=value path/to/source. Variables in the CMake cache are 'remembered', so you do not need to type them if you execute cmake command again. It is recommended to delete the file CMakeCache.txt to start from a clean configuration. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:23410,cache,cache,23410,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['cache'],['cache']
Performance,"more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tTFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TFormula::fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**TFormula::fPredefined![fNPar] predefined function ; Bool_tfQuickLoad! If true, branch GetEntry is only called when the entry number changes.; TStringTNamed::fTitleobject title; TTree*fTree! pointer to Tree; TTreeFormula*fVarIndexes[500][5]Pointer to a variable index",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:16694,load,loaded,16694,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,4,['load'],['loaded']
Performance,"more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tTFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); TFormula::TFuncGTFormula::fOptimal!pointer to optimal function; Double_t*TFormula::fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**TFormula::fPredefined![fNPar] predefined function; Bool_tfQuickLoad! If true, branch GetEntry is only called when the entry number changes.; TStringTNamed::fTitleobject title; TTree*fTree! pointer to Tree; TTreeFormula*fVarIndexes[500][5]Pointer to a variable in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeFormula.html:16769,load,loaded,16769,root/html602/TTreeFormula.html,https://root.cern,https://root.cern/root/html602/TTreeFormula.html,1,['load'],['loaded']
Performance,"mory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 244 gCling->SaveContext();; 245 gCling->SaveGlobalsContext();; 246 ; 247 // Install interrupt and terminal input handlers; 248 TInterruptHandler *ih = new TInterruptHandler();; 249 ih->Add();; 250 SetSignalHandler(ih);; 251 ; 252 // Handle stdin events; 253 fInputHandler = new TTermInputHandler(0);; 254 fInputHandler->Add();; 255 ; 256 // Goto into raw terminal input mode; 257 char defhist[kMAXPATHLEN];; 258 snprintf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the code we had HistorySize and HistorySave, in the rootrc and doc; 261 // we have HistSize and HistSave. Keep the doc as it is and check; 262 // now also for HistSize and HistSave in case the user did not use; 263 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:7751,Load,Load,7751,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['Load'],['Load']
Performance,mory.h;  logarithm.h;  macros.h;  memory.h;  memorybase.h;  memoryfwd.h;  operand.h;  operators.h;  storage.h;  support.h;  trigonometric.h;  types.h;  undomacros.h;  vectortuple.h;  windows_fix_intrin.h;  ► internal;  namespace.h;  ► scalar;  helperimpl.h;  limits.h;  macros.h;  mask.h;  math.h;  types.h;  undomacros.h;  vector.h;  writemaskedvector.h;  ► sse;  casts.h;  const.h;  const_data.h;  debug.h;  helperimpl.h;  intrinsics.h;  limits.h;  macros.h;  mask.h;  math.h;  shuffle.h;  types.h;  undomacros.h;  vector.h;  vectorhelper.h;  cpuid.h;  global.h;  support.h;  vector.h;  version.h;  ► src;  avx_sorthelper.cpp;  const.cpp;  cpuid.cpp;  support.cpp;  trigonometric.cpp;  ► tests;  arithmetics.cpp;  casts.cpp;  const.h;  convert-sincos-reference.cpp;  deinterleave.cpp;  expandandmerge.cpp;  gather.cpp;  implicit_type_conversion.cpp;  implicit_type_conversion_failures.cpp;  linkTest0.cpp;  linkTest1.cpp;  linkTestLib0.cpp;  linkTestLib1.cpp;  linkTestLib2.cpp;  linkTestLib3.cpp;  load.cpp;  mask.cpp;  math.cpp;  memory.cpp;  scalaraccess.cpp;  scatter.cpp;  sse_blend.cpp;  stlcontainer.cpp;  store.cpp;  supportfunctions.cpp;  swizzles.cpp;  ulp.h;  unittest.h;  utils.cpp;  vectormemoryhelper.h;  makeTest.py;  ► vdt;  ► include;  ► vdt;  asin.h;  atan.h;  atan2.h;  cos.h;  exp.h;  inv.h;  log.h;  sin.h;  sincos.h;  sqrt.h;  tan.h;  vdtcore_common.h;  vdtMath.h;  ► tests;  stressVdt.cxx;  ► misc;  ► memstat;  ► inc;  LinkDef.h;  TMemStat.h;  TMemStatBacktrace.h;  TMemStatDef.h;  TMemStatHelpers.h;  TMemStatHook.h;  TMemStatMng.h;  ► src;  TMemStat.cxx;  TMemStatBacktrace.cxx;  TMemStatHelpers.cxx;  TMemStatHook.cxx;  TMemStatMng.cxx;  ► test;  leak_test.C;  run.C;  ► table;  ► inc;  LinkDef.h;  tableDescriptor.h;  TCernLib.h;  TChair.h;  TColumnView.h;  TDataSet.h;  TDataSetIter.h;  TDsKey.h;  TFileIter.h;  TFileSet.h;  TGenericTable.h;  TIndexTable.h;  TObjectSet.h;  TPoints3D.h;  TPointsArray3D.h;  TPolyLineShape.h;  TResponseTable.h;  TTable.h;  TTable3Points.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:59460,load,load,59460,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['load'],['load']
Performance,"moryDefinition TBranch.cxx:2283; TBranch::SetStatusvirtual void SetStatus(bool status=true)Set branch status to Process or DoNotProcess.Definition TBranch.cxx:2947; TBranch::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Reset a Branch.Definition TBranch.cxx:2598; TBranch::ReadLeaves0Implvoid ReadLeaves0Impl(TBuffer &b)Read zero leaves without the overhead of a loop.Definition TBranch.cxx:2472; TBranch::SupportsBulkReadbool SupportsBulkRead() constReturns true if this branch supports bulk IO, false otherwise.Definition TBranch.cxx:1431; TBranch::GetRealFileNameTString GetRealFileName() constGet real file name.Definition TBranch.cxx:2068; TBranch::FindBranchvirtual TBranch * FindBranch(const char *name)Find the immediate sub-branch with passed name.Definition TBranch.cxx:1035; TBranch::fDirectoryTDirectory * fDirectory! Pointer to directory where this branch buffers are storedDefinition TBranch.h:148; TBranch::PrintCacheInfovoid PrintCacheInfo() constPrint the information we have about which basket is currently cached and whether they have been 'used...Definition TBranch.cxx:2445; TBranch::fBasketsTObjArray fBaskets-> List of baskets of this branchDefinition TBranch.h:140; TBranch::LoadBasketsvirtual Int_t LoadBaskets()Baskets associated to this branch are forced to be in memory.Definition TBranch.cxx:2309; TBranch::fMotherTBranch * fMother! Pointer to top-level parent branch in the tree.Definition TBranch.h:145; TBranch::GetTotBytesLong64_t GetTotBytes(Option_t *option="""") constReturn total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub...Definition TBranch.cxx:2220; TBranch::fParentTBranch * fParent! Pointer to parent branch.Definition TBranch.h:146; TBranch::WriteBasketInt_t WriteBasket(TBasket *basket, Int_t where)Definition TBranch.h:175; TBranch::FlushOneBasketInt_t FlushOneBasket(UInt_t which)If we have a write basket in memory and it contains some entries and has not yet been written to disk...Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:137831,cache,cached,137831,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['cache'],['cached']
Performance,"moryFull(Int_t nbytes); Check if adding nbytes to memory we are still below MaxVirtualsize. TTree* MergeTrees(TList* list, Option_t* option = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:107962,Optimiz,OptimizeBaskets,107962,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,2,['Optimiz'],['OptimizeBaskets']
Performance,"mote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TPSocket(const char* host, Int_t port, Int_t size, Int_t tcpwindowsize = -1); Create a parallel socket. Connect to specified port # on the remote host.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TPSocket(const char* host, Int_t port, Int_t size, TSocket* sock); Create a parallel socket on a connection already opened via; TSocket sock.; This constructor is provided to optimize TNetFile opening when; instatiated via a call to TXNetFile.; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TPSocket(TSocket** pSockets, Int_t size); Create a parallel socket. This ctor is called by TPServerSocket. ~TPSocket(); Cleanup the parallel socket. void Close(Option_t* opt = """"); Close a parallel socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). void Init(Int_t tcpwindowsize, TSocket* sock = 0); Create a parallel socket to the specified host. TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPSocket.html:13284,optimiz,optimize,13284,root/html528/TPSocket.html,https://root.cern,https://root.cern/root/html528/TPSocket.html,3,['optimiz'],['optimize']
Performance,"mote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TPSocket(const char* host, Int_t port, Int_t size, Int_t tcpwindowsize = -1); Create a parallel socket. Connect to specified port # on the remote host.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TPSocket(const char* host, Int_t port, Int_t size, TSocket* sock); Create a parallel socket on a connection already opened via; TSocket sock.; This constructor is provided to optimize TNetFile opening when; instatiated via a call to TXNetFile.; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TPSocket(TSocket** pSockets, Int_t size); Create a parallel socket. This ctor is called by TPServerSocket. ~TPSocket(); Cleanup the parallel socket. void Close(Option_t* opt = """"); Close a parallel socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). void Init(Int_t tcpwindowsize, TSocket* sock = 0); Create a parallel socket to the specified host. TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPSocket.html:13616,optimiz,optimize,13616,root/html534/TPSocket.html,https://root.cern,https://root.cern/root/html534/TPSocket.html,1,['optimiz'],['optimize']
Performance,"mote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TPSocket(const char* host, Int_t port, Int_t size, Int_t tcpwindowsize = -1); Create a parallel socket. Connect to specified port # on the remote host.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TPSocket(const char* host, Int_t port, Int_t size, TSocket* sock); Create a parallel socket on a connection already opened via; TSocket sock.; This constructor is provided to optimize TNetFile opening when; instatiated via a call to TXNetFile.; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TPSocket(TSocket*[] pSockets, Int_t size); Create a parallel socket. This ctor is called by TPServerSocket. ~TPSocket(); Cleanup the parallel socket. void Close(Option_t* opt = """"); Close a parallel socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). void Init(Int_t tcpwindowsize, TSocket* sock = 0); Create a parallel socket to the specified host. TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPSocket.html:14234,optimiz,optimize,14234,root/html602/TPSocket.html,https://root.cern,https://root.cern/root/html602/TPSocket.html,2,['optimiz'],['optimize']
Performance,"mous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-06-02 15:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFileCacheWrite.html:7314,cache,cache,7314,root/html604/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html604/TFileCacheWrite.html,2,['cache'],['cache']
Performance,"mous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-06-30 14:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileCacheWrite.html:7314,cache,cache,7314,root/html602/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html602/TFileCacheWrite.html,2,['cache'],['cache']
Performance,"move(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetCache(); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:12289,cache,cache,12289,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,1,['cache'],['cache']
Performance,"mparison of chi-squared estimators for signal and background; TMVA::MethodKNN k Nearest Neighbour classifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach""); TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Multi-dimensional probability density estimator using TFoam (PDE-Foam); TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassificationError as separation criterion; TMVA::MsgLogger Ostringstream derivative to redirect and format logging output; TMVA::Node Node for the BinarySearch or Decision Trees; TMVA::OptimizeConfigParameters Interface to different separation critiera used in training algorithms; TMVA::PDEFoam Tree of PDEFoamCells; TMVA::PDEFoamCell Single cell of FOAM; TMVA::PDEFoamDecisionTree Decision tree like PDEFoam; TMVA::PDEFoamDecisionTreeDensity Class for decision tree like PDEFoam density; TMVA::PDEFoamDensityBase PDEFoam event density interface; TMVA::PDEFoamDiscriminant Tree of PDEFoamCells; TMVA::PDEFoamDiscriminantDensity Class for Discriminant density; TMVA::PDEFoamEvent Tree of PDEFoamCells; TMVA::PDEFoamEventDensity Class for Event density; TMVA::PDEFoamKernelBase PDEFoam kernel interface; TMVA::PDEFoamKernelGauss Gaussian PDEFoam kernel estimator; TMVA::PDEFoamKernelLinN next neighbor PDEFoam kernel estimator; TMVA::PDEFoamKernelTrivial trivial PDEFoam kernel estimator; TMVA::PDEFoamMultiTarget Tree of PDEFoamCells; TMVA::PDEFoamTarget Tree of PDEFoamCells; TMVA::PDEFoamTargetDensity Class for Target density; TMVA::PDEFoamVect n-dimensional vector with dynamical allocation; TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:103155,Optimiz,OptimizeConfigParameters,103155,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['Optimiz'],['OptimizeConfigParameters']
Performance,"mpilePdf(const char* name, const char* expression, const RooArgList& vars, const char* intExpression = 0). Bool_t makeAndCompileFunction(const char* name, const char* expression, const RooArgList& args, const char* intExpression = 0); Write, compile and load code for a RooAbsReal implementation with; class name 'name', taking all elements of 'vars' as constructor; arguments. The initial value expression is taken to be; 'expression' which can be any one-line C++ expression in terms of; variables that occur in 'vars'. You can add optional expressions; for analytical integrals to be advertised by your class in the; syntax; ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; where <intObsName> a name of the observable integrated over and; <CPPAnaIntExpression> is the C++ expression that calculates that; integral. RooAbsReal* makeFunctionInstance(const char* name, const char* expression, const RooArgList& vars, const char* intExpression = 0); Write, compile and load code and instantiate object for a; RooAbsReal implementation with class name 'name', taking all; elements of 'vars' as constructor arguments. The initial value; expression is taken to be 'expression' which can be any one-line; C++ expression in terms of variables that occur in 'vars'. The returned object is an instance of the object you just defined; connected to the variables listed in 'vars'. The name of the; object is 'name', its class name Roo<name>Class. This function is an effective compiled replacement of RooFormulaVar. You can add optional expressions for analytical integrals to be; advertised by your class in the syntax; ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; where <intObsName> a name of the observable integrated over and; <CPPAnaIntExpression> is the C++ expression that calculates that; integral. RooAbsReal* makeFunctionInstance(const char* className, const char* name, const char* expression, const RooArgList& vars, const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooClassFactory.html:9638,load,load,9638,root/html526/RooClassFactory.html,https://root.cern,https://root.cern/root/html526/RooClassFactory.html,7,['load'],['load']
Performance,"mpiler(). const char * TSystem::GetBuildCompiler ; (; ); const. virtual . Return the build compiler. ; Definition at line 3883 of file TSystem.cxx. ◆ GetBuildCompilerVersion(). const char * TSystem::GetBuildCompilerVersion ; (; ); const. virtual . Return the build compiler version. ; Definition at line 3891 of file TSystem.cxx. ◆ GetBuildCompilerVersionStr(). const char * TSystem::GetBuildCompilerVersionStr ; (; ); const. virtual . Return the build compiler version identifier string. ; Definition at line 3899 of file TSystem.cxx. ◆ GetBuildDir(). const char * TSystem::GetBuildDir ; (; ); const. virtual . Return the path of the build directory. ; Definition at line 3915 of file TSystem.cxx. ◆ GetBuildNode(). const char * TSystem::GetBuildNode ; (; ); const. virtual . Return the build node name. ; Definition at line 3907 of file TSystem.cxx. ◆ GetCpuInfo(). int TSystem::GetCpuInfo ; (; CpuInfo_t * ; info, . Int_t ; sampleTime = 1000 . ); const. virtual . Returns cpu load average and load info into the CpuInfo_t structure. ; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the interval over which the CPU load will be measured, in ms (default 1000). ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2469 of file TSystem.cxx. ◆ GetCryptoRandom(). Int_t TSystem::GetCryptoRandom ; (; void * ; buf, . Int_t ; len . ). virtual . Return cryptographic random number Fill provided buffer with random values Returns number of bytes written to buffer or -1 in case of error. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 266 of file TSystem.cxx. ◆ GetDirEntry(). const char * TSystem::GetDirEntry ; (; void * ; dirp). virtual . Get a directory entry. Returns 0 if no more entries. ; Reimplemented in TDavixSystem, TUnixSystem, TWinNTSystem, TDCacheSystem, TWebSystem, TNetXNGSystem, and TNetSystem.; Definition at line 853 of file TSystem.cxx. ◆ GetDirName(). TString TSystem::GetDirName ; (; const char * ; pathname). virtual . Return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:55073,load,load,55073,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,2,['load'],['load']
Performance,"mpl = &TClass::StreamerStreamerInfo;; 6133 ; 6134 } else if ( kl->fStreamerType == TClass::kDefault ) {; 6135 if (kl->fConvStreamerFunc) {; 6136 kl->fStreamerType = kInstrumented;; 6137 kl->fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6138 } else if (kl->fStreamerFunc) {; 6139 kl->fStreamerType = kInstrumented;; 6140 kl->fStreamerImpl = &TClass::StreamerInstrumented;; 6141 } else {; 6142 // We have an automatic streamer using the StreamerInfo .. no need to go through the; 6143 // Streamer method function itself.; 6144 kl->fStreamerType = kInstrumented;; 6145 kl->fStreamerImpl = &TClass::StreamerStreamerInfo;; 6146 }; 6147 }; 6148 ; 6149 if (fStreamer) {; 6150 kl->fStreamerType = kExternal;; 6151 kl->fStreamerImpl = &TClass::StreamerExternal;; 6152 }; 6153 ; 6154 if (const_cast<TClass *>(this)->GetClassMethodWithPrototype(""Hash"", """", kTRUE)) {; 6155 kl->SetBit(kHasLocalHashMember);; 6156 }; 6157 ; 6158 if (GetClassInfo()) {; 6159 // In the case where the TClass for one of ROOT's core class; 6160 // (eg TClonesArray for map<int,TClonesArray*>) is requested; 6161 // during the execution of rootcling, we could end up in a situation; 6162 // where we should have the information (since TClonesArray has; 6163 // a dictionary as part of libCore) but do not because the user; 6164 // only include a forward declaration of TClonesArray and we do not; 6165 // forcefully load the header file either (because the autoparsing; 6166 // is intentionally disabled).; 6167 kl->fClassProperty = gCling->ClassInfo_ClassProperty(fClassInfo);; 6168 // Must set this last since other threads may read fProperty; 6169 // and think all test bits have been properly set.; 6170 kl->fProperty = gCling->ClassInfo_Property(fClassInfo);; 6171 }; 6172 } else {; 6173 ; 6174 if (fStreamer) {; 6175 kl->fStreamerType = kExternal;; 6176 kl->fStreamerImpl = &TClass::StreamerExternal;; 6177 }; 6178 ; 6179 kl->fStreamerType |= kEmulatedStreamer;; 6180 kl->SetStreamerImpl();; 6181 // fProperty was *not* set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:237208,load,load,237208,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"mpl = &TClass::StreamerStreamerInfo;; 6200 ; 6201 } else if ( kl->fStreamerType == TClass::kDefault ) {; 6202 if (kl->fConvStreamerFunc) {; 6203 kl->fStreamerType = kInstrumented;; 6204 kl->fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6205 } else if (kl->fStreamerFunc) {; 6206 kl->fStreamerType = kInstrumented;; 6207 kl->fStreamerImpl = &TClass::StreamerInstrumented;; 6208 } else {; 6209 // We have an automatic streamer using the StreamerInfo .. no need to go through the; 6210 // Streamer method function itself.; 6211 kl->fStreamerType = kInstrumented;; 6212 kl->fStreamerImpl = &TClass::StreamerStreamerInfo;; 6213 }; 6214 }; 6215 ; 6216 if (fStreamer) {; 6217 kl->fStreamerType = kExternal;; 6218 kl->fStreamerImpl = &TClass::StreamerExternal;; 6219 }; 6220 ; 6221 if (const_cast<TClass *>(this)->GetClassMethodWithPrototype(""Hash"", """", kTRUE)) {; 6222 kl->SetBit(kHasLocalHashMember);; 6223 }; 6224 ; 6225 if (GetClassInfo()) {; 6226 // In the case where the TClass for one of ROOT's core class; 6227 // (eg TClonesArray for map<int,TClonesArray*>) is requested; 6228 // during the execution of rootcling, we could end up in a situation; 6229 // where we should have the information (since TClonesArray has; 6230 // a dictionary as part of libCore) but do not because the user; 6231 // only include a forward declaration of TClonesArray and we do not; 6232 // forcefully load the header file either (because the autoparsing; 6233 // is intentionally disabled).; 6234 kl->fClassProperty = gCling->ClassInfo_ClassProperty(fClassInfo);; 6235 // Must set this last since other threads may read fProperty; 6236 // and think all test bits have been properly set.; 6237 kl->fProperty = gCling->ClassInfo_Property(fClassInfo);; 6238 }; 6239 } else {; 6240 ; 6241 if (fStreamer) {; 6242 kl->fStreamerType = kExternal;; 6243 kl->fStreamerImpl = &TClass::StreamerExternal;; 6244 }; 6245 ; 6246 kl->fStreamerType |= kEmulatedStreamer;; 6247 kl->SetStreamerImpl();; 6248 // fProperty was *not* set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:239959,load,load,239959,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"mpl(); 5910{; 5911 if (TestBit((long)kDoNotProcess|(long)kAddressSet)) {; 5912 // -- Do nothing if we have been told not to.; 5913 // Or the data member in this branch is not longer part of the; 5914 // parent's layout.; 5915 return;; 5916 }; 5917 ; 5918 //--------------------------------------------------------------------------; 5919 // Check if we are splited STL collection of pointers; 5920 /////////////////////////////////////////////////////////////////////////////; 5921 ; 5922 if( fType == 41 && fSplitLevel >= TTree::kSplitCollectionOfPointers ); 5923 {; 5924 TBranchElement *parent = (TBranchElement *)GetMother()->GetSubBranch( this );; 5925 ; 5926 // Make sure the StreamerInfo is loaded and initialized.; 5927 GetInfoImp();; 5928 ; 5929 if( !parent->GetAddress() ); 5930 parent->SetAddress( nullptr );; 5931 return;; 5932 }; 5933 ; 5934 //--------------------------------------------------------------------------; 5935 // Any other case; 5936 /////////////////////////////////////////////////////////////////////////////; 5937 ; 5938 TBranchElement* mother = (TBranchElement*) GetMother();; 5939 if (!mother) {; 5940 return;; 5941 }; 5942 TClass* cl = TClass::GetClass(mother->GetClassName());; 5943 ; 5944 // Make sure the StreamerInfo is loaded and initialized.; 5945 GetInfoImp();; 5946 ; 5947 if (!cl) {; 5948 return;; 5949 }; 5950 ; 5951 if (!mother->GetAddress()) {; 5952 // -- Our top-level branch has no address.; 5953 bool motherStatus = mother->TestBit(kDoNotProcess);; 5954 mother->ResetBit(kDoNotProcess);; 5955 // Note: This will allocate an object.; 5956 mother->SetAddress(nullptr);; 5957 mother->SetBit(kDoNotProcess, motherStatus);; 5958 }; 5959}; 5960 ; 5961////////////////////////////////////////////////////////////////////////////////; 5962/// Stream an object of class TBranchElement.; 5963 ; 5964void TBranchElement::Streamer(TBuffer& R__b); 5965{; 5966 if (R__b.IsReading()) {; 5967 R__b.ReadClassBuffer(TBranchElement::Class(), this);; 5968 fParentClass.Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:222776,load,loaded,222776,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['load'],['loaded']
Performance,"mplate<class T1 , class T2 > ; bool operator!= (const RResultPtr< T1 > &lhs, const RResultPtr< T2 > &rhs);  ; template<class T1 > ; bool operator!= (const RResultPtr< T1 > &lhs, std::nullptr_t rhs);  ; template<class T1 > ; bool operator!= (std::nullptr_t lhs, const RResultPtr< T1 > &rhs);  ; std::ostream & operator<< (std::ostream &os, const RDFDescription &description);  ; template<class T1 , class T2 > ; bool operator== (const RResultPtr< T1 > &lhs, const RResultPtr< T2 > &rhs);  ; template<class T1 > ; bool operator== (const RResultPtr< T1 > &lhs, std::nullptr_t rhs);  ; template<class T1 > ; bool operator== (std::nullptr_t lhs, const RResultPtr< T1 > &rhs);  ; template<std::size_t N, typename T , typename F > ; auto PassAsVec (F &&f) -> RDFInternal::PassAsVecHelper< std::make_index_sequence< N >, T, F >;  PassAsVec is a callable generator that allows passing N variables of type T to a function as a single collection. ;  ; unsigned int RunGraphs (std::vector< RResultHandle > handles);  Trigger the event loop of multiple RDataFrames concurrently. ;  ; template<typename NodeType > ; std::string SaveGraph (NodeType node);  Create a graphviz representation of the dataframe computation graph, return it as a string. ;  ; template<typename NodeType > ; void SaveGraph (NodeType node, const std::string &outputFile);  Create a graphviz representation of the dataframe computation graph, write it to the specified file. ;  ; void splitInEqualRanges (std::vector< std::pair< ULong64_t, ULong64_t > > &ranges, int nRecords, unsigned int nSlots);  . Typedef Documentation. ◆ ColumnNames_t. typedef std::vector< std::string > ROOT::RDF::ColumnNames_t. Definition at line 35 of file RInterfaceBase.hxx. ◆ RNode. typedef RInterface<::ROOT::Detail::RDF::RNodeBase, void > ROOT::RDF::RNode. Definition at line 57 of file InterfaceUtils.hxx. ◆ SampleCallback_t. using ROOT::RDF::SampleCallback_t = typedef std::function<void(unsigned int, const ROOT::RDF::RSampleInfo &)>. The type of a data-bl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF.html:5752,concurren,concurrently,5752,doc/master/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF.html,2,['concurren'],['concurrently']
Performance,"mplate<typename AReal > . bool TMVA::DNN::TCpu< AReal >::AlmostEquals ; (; const Matrix_t & ; A, . const Matrix_t & ; B, . double ; epsilon = 0.1 . ). static . Check two matrices for equality, taking floating point arithmetic errors into account. ; Checks two matrices for element-wise equality.; Template Parameters. ARealAn architecture-specific floating point number type. . Parameters. AThe first matrix. ; BThe second matrix. ; epsilonEquality tolerance, needed to address floating point arithmetic. . ReturnsWhether the two matrices can be considered equal element-wise ; Definition at line 194 of file Arithmetic.hxx. ◆ Backward(). template<typename AReal = Float_t> . void TMVA::DNN::TCpu< AFloat >::Backward ; (; Tensor_t & ; activationGradientsBackward, . Matrix_t & ; weightGradients, . Matrix_t & ; biasGradients, . const Tensor_t & ; df, . const Tensor_t & ; activationGradients, . const Matrix_t & ; weights, . const Tensor_t & ; activationBackward . ). static . Perform the complete backward propagation step. ; If the provided activationGradientsBackward matrix is not empty, compute the gradients of the objective function with respect to the activations of the previous layer (backward direction). Also compute the weight and the bias gradients. Modifies the values in df and thus produces only a valid result, if it is applied the first time after the corresponding forward propagation has been per- formed. ; Definition at line 100 of file Propagation.hxx. ◆ BatchNormLayerBackward(). template<typename AReal = Float_t> . void TMVA::DNN::TCpu< AFloat >::BatchNormLayerBackward ; (; int ; axis, . const Tensor_t & ; x, . const Tensor_t & ; dy, . Tensor_t & ; dx, . Matrix_t & ; gamma, . Matrix_t & ; dgamma, . Matrix_t & ; dbeta, . const Matrix_t & ; mean, . const Matrix_t & ; variance, . const Matrix_t & ; iVariance, . Scalar_t ; epsilon, . const TensorDescriptor_t & ;  . ). static . Definition at line 835 of file Propagation.hxx. ◆ BatchNormLayerForwardInference(). template<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpu.html:32699,Perform,Perform,32699,doc/master/classTMVA_1_1DNN_1_1TCpu.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpu.html,1,['Perform'],['Perform']
Performance,"mplateProxy *pytmpl, bool use_targs, uint64_t sighash, CPPOverload *pymeth);  ; bool UseStrictOwnership (CallContext *ctxt);  ; static void vectoriter_dealloc (vectoriterobject *vi);  ; static PyObject * vectoriter_iternext (vectoriterobject *vi);  . Variables; PyTypeObject CPPDataMember_Type;  ; PyTypeObject CPPExcInstance_Type;  ; PyTypeObject CPPInstance_Type;  ; PyTypeObject CPPOverload_Type;  ; PyTypeObject CPPScope_Type;  ; PyTypeObject CustomInstanceMethod_Type;  ; static PyMemberDef dm_members [];  ; static PyMethodDef dm_methods [];  ; static PyNumberMethods ep_as_number;  ; static PyMethodObject * free_list;  ; PyObject * gAbrtException = nullptr;  ; PyObject * gBusException = nullptr;  ; std::ostringstream gCapturedError;  ; static ConvFactories_t gConvFactories;  ; PyObject * gDefaultObject = nullptr;  ; bool gDictLookupActive = false;  ; dict_lookup_func gDictLookupOrg = 0;  ; static ExecFactories_t gExecFactories;  ; PyObject * gIllException = nullptr;  ; std::set< std::string > gIteratorTypes;  ; PyObject * gNullPtrObject = nullptr;  ; std::streambuf * gOldErrorBuffer = nullptr;  ; std::set< Cppyy::TCppType_t > gPinnedTypes;  ; PyObject * gPyTypeMap = nullptr;  ; PyObject * gSegvException = nullptr;  ; PyObject * gThisModule = nullptr;  ; PyTypeObject IndexIter_Type;  ; PyTypeObject InstanceArrayIter_Type;  ; PyTypeObject LowLevelView_Type;  ; static PyGetSetDef meta_getset [];  ; static PyMethodDef meta_methods [];  ; static int numfree = 0;  ; static PyNumberMethods op_as_number;  ; static PySequenceMethods op_as_sequence;  ; static PyGetSetDef op_getset [];  ; static PyMethodDef op_methods [];  ; PyTypeObject RefFloat_Type;  Custom ""builtins,"" detectable by type, for pass by ref and improved performance. ;  ; PyTypeObject RefInt_Type;  ; const int SMALL_ARGS_N = 8;  ; PyTypeObject TemplateProxy_Type;  ; static PyMappingMethods tpp_as_mapping;  ; static PyGetSetDef tpp_getset [];  ; static PyMethodDef tpp_methods [];  ; static PyGetSetDef tptc_getset",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceCPyCppyy.html:20294,perform,performance,20294,doc/master/namespaceCPyCppyy.html,https://root.cern,https://root.cern/doc/master/namespaceCPyCppyy.html,1,['perform'],['performance']
Performance,"mplemented from RooAbsPdf.; Definition at line 383 of file RooNonCPEigenDecay.cxx. ◆ getCoefAnalyticalIntegral(). Int_t RooNonCPEigenDecay::getCoefAnalyticalIntegral ; (; Int_t ; coef, . RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Default implementation of function advertising integration capabilities. ; The interface is similar to that of getAnalyticalIntegral except that an integer code is added that designates the coefficient number for which the integration capabilities are requested; This default implementation advertises that no internal integrals are supported. ; Reimplemented from RooAbsAnaConvPdf.; Definition at line 264 of file RooNonCPEigenDecay.cxx. ◆ getGenerator(). Int_t RooNonCPEigenDecay::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ; A code of zero indicates that we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented from RooAbsPdf.; Definition at line 331 of file RooNonCPEigenDecay.cxx. ◆ initGenerator(). void RooNonCPEigenDecay::initGenerator ; (; Int_t ; code). overridevirtual . Interface for one-time initialization to setup the generator for the specified code. ; Reimplemented from RooAbsPdf.; Definition at line 345 of file RooNonCPEigenDecay.cxx. ◆ IsA(). TClass * RooNonCPEigenDecay::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsAn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNonCPEigenDecay.html:83010,Load,Load,83010,doc/master/classRooNonCPEigenDecay.html,https://root.cern,https://root.cern/doc/master/classRooNonCPEigenDecay.html,1,['Load'],['Load']
Performance,"mplemented in TSQLFile, TXMLFile, TNetFile, TWebFile, and TNetXNGFile.; Definition at line 2162 of file TFile.cxx. ◆ ResetErrno(). void TFile::ResetErrno ; (; ); const. virtual . Method resetting the errno. ; Reimplemented in TSQLFile, TXMLFile, TDCacheFile, and TMemFile.; Definition at line 1254 of file TFile.cxx. ◆ Seek(). void TFile::Seek ; (; Long64_t ; offset, . ERelativeTo ; pos = kBeg . ). virtual . Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ; Reimplemented in TDavixFile, TNetFile, TWebFile, TNetXNGFile, TSQLFile, and TXMLFile.; Definition at line 2274 of file TFile.cxx. ◆ SetCacheFileDir(). Bool_t TFile::SetCacheFileDir ; (; std::string_view ; cachedir, . Bool_t ; operatedisconnected = kTRUE, . Bool_t ; forcecacheread = kFALSE . ). static . Sets the directory where to locally stage/cache remote files. ; If the directory is not writable by us return kFALSE. ; Definition at line 4626 of file TFile.cxx. ◆ SetCacheRead(). void TFile::SetCacheRead ; (; TFileCacheRead * ; cache, . TObject * ; tree = nullptr, . ECacheAction ; action = kDisconnect . ). virtual . Set a pointer to the read cache. ; This relinquishes ownership of the previous cache, so if you do not already have a pointer to the previous cache (and there was a previous cache), you ought to retrieve (and delete it if needed) using: TFileCacheRead *older = myfile->GetCacheRead();; The action specifies how to behave when detaching a cache from the the TFile. If set to (default) kDisconnect, the contents of the cache will be flushed when it is removed from the file, and it will disconnect the cache object from the file. In almost all cases, this is what you want. If you want to disconnect the cache temporarily from this tree and re-attach later to the same fil, you can set action to kDoNotDisconnect. This will allow things like prefetching to continue in the background while it is no longer the default cache for the TTree. Except for a few expert use cases, kDisconnect is li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:91831,cache,cache,91831,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['cache'],['cache']
Performance,"mplemented in derived PDF types. If you mean to customize the likelihood fitting routine, you need to override the virtual RooAbsPdf::fitToImpl() method.; The following named arguments are supported:. Type of CmdArg Options to control construction of -log(L) . All command arguments that can also be passed to the NLL creation method. See alsoRooAbsPdf::createNLL(). Options to control flow of fit procedure . Minimizer(""<type>"", ""<algo>"") Choose minimization package and optionally the algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer interface, but others can be specified (through RooMinimizer interface). . Type Algorithm . Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve) . Minuit2 migrad, simplex, minimize, scan . GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent . GSLSimAn - . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Optimize(bool flag) Activate constant term optimization of test statistic during minimization (on by default) . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, off by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 to 2, default is 1) . MaxCalls(int n) Change maximum number of likelihood function calls from MINUIT (if n <= 0, the default of 500 * #parameters is used) . EvalErrorWall(bool flag=true) When parameters are in disallowed regions (e.g. PDF is negative), return very high value to fitter to force it out of that region. This can, however, mean that the fitter gets lost in this region. If this happens, try switching it off. . RecoverFromUndefinedRegions(double strength) When PDF is invalid (e.g. parameter in undefined region), try to direct minimiser away from that region. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:105850,Optimiz,Optimize,105850,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,2,"['Optimiz', 'optimiz']","['Optimize', 'optimization']"
Performance,"mplementing createHistogram. RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables. The slice is position at the 'current'; value of the observable objects. Slice(RooCategory& cat, -- Override default projection behaviour by omittting specified category; const char* label) observable from the projection, resulting in a 'slice' plot. The slice is positioned; at the given label value. Multiple Slice() commands can be given to specify slices; in multiple observables. Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only. ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:43875,perform,performed,43875,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,4,['perform'],['performed']
Performance,"mplements RooAbsDataStore.; Definition at line 623 of file RooVectorDataStore.cxx. ◆ addReal(). RooVectorDataStore::RealVector * RooVectorDataStore::addReal ; (; RooAbsReal * ; real). protected . Definition at line 1244 of file RooVectorDataStore.cxx. ◆ addRealFull(). RooVectorDataStore::RealFullVector * RooVectorDataStore::addRealFull ; (; RooAbsReal * ; real). protected . Definition at line 1304 of file RooVectorDataStore.cxx. ◆ append(). void RooVectorDataStore::append ; (; RooAbsDataStore & ; other). overridevirtual . Implements RooAbsDataStore.; Definition at line 720 of file RooVectorDataStore.cxx. ◆ attachBuffers(). void RooVectorDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 1041 of file RooVectorDataStore.cxx. ◆ attachCache(). void RooVectorDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overridevirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 982 of file RooVectorDataStore.cxx. ◆ cache(). const RooVectorDataStore * RooVectorDataStore::cache ; (; ); const. inline . Definition at line 171 of file RooVectorDataStore.h. ◆ cacheArgs(). void RooVectorDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; newVarSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = true . ). overridevirtual . Cache given RooAbsArgs: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ; Upon a get() call, the internal cache of 'newVar' will be loaded with the precalculated value and it's dirty flag will be cleared. ; Implements RooAbsDataStore.; Definition at line 764 of file RooVectorDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooVectorDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:26743,cache,cache,26743,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,2,['cache'],['cache']
Performance,"mplements TVirtualGeoPainter.; Definition at line 171 of file TGeoPainter.cxx. ◆ CheckBoundaryErrors(). void TGeoPainter::CheckBoundaryErrors ; (; Int_t ; ntracks = 1000000, . Double_t ; radius = -1. . ). overridevirtual . Check pushes and pulls needed to cross the next boundary with respect to the position given by FindNextBoundary. ; If radius is not mentioned the full bounding box will be sampled. ; Implements TVirtualGeoPainter.; Definition at line 200 of file TGeoPainter.cxx. ◆ CheckBoundaryReference(). void TGeoPainter::CheckBoundaryReference ; (; Int_t ; icheck = -1). overridevirtual . Check the boundary errors reference file created by CheckBoundaryErrors method. ; The shape for which the crossing failed is drawn with the starting point in red and the extrapolated point to boundary (+/- failing push/pull) in yellow. ; Implements TVirtualGeoPainter.; Definition at line 210 of file TGeoPainter.cxx. ◆ CheckEdit(). void TGeoPainter::CheckEdit ; (; ). Check if Ged library is loaded and load geometry editor classe. ; Definition at line 682 of file TGeoPainter.cxx. ◆ CheckGeometry(). void TGeoPainter::CheckGeometry ; (; Int_t ; nrays, . Double_t ; startx, . Double_t ; starty, . Double_t ; startz . ); const. overridevirtual . Geometry checking method (see TGeoChecker). ; Implements TVirtualGeoPainter.; Definition at line 226 of file TGeoPainter.cxx. ◆ CheckGeometryFull(). void TGeoPainter::CheckGeometryFull ; (; Bool_t ; checkoverlaps = kTRUE, . Bool_t ; checkcrossings = kTRUE, . Int_t ; nrays = 10000, . const Double_t * ; vertex = nullptr . ). overridevirtual . Geometry checking method (see: TGeoManager::CheckGeometry()) ; Implements TVirtualGeoPainter.; Definition at line 218 of file TGeoPainter.cxx. ◆ CheckOverlaps(). void TGeoPainter::CheckOverlaps ; (; const TGeoVolume * ; vol, . Double_t ; ovlp = 0.1, . Option_t * ; option = """" . ); const. overridevirtual . Check overlaps for the top volume of the geometry, within a limit OVLP. ; Implements TVirtualGeoPainter.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPainter.html:23639,load,loaded,23639,doc/master/classTGeoPainter.html,https://root.cern,https://root.cern/doc/master/classTGeoPainter.html,2,['load'],"['load', 'loaded']"
Performance,"mples of valid expression: ""x<y && sqrt(z)>3.2""; TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. . Definition at line 58 of file TTreeFormula.h. Classes; struct  RealInstanceCache;  . Public Member Functions;  TTreeFormula ();  ;  TTreeFormula (const char *name, const char *formula, TTree *tree);  Normal TTree Formula Constructor. ;  ;  ~TTreeFormula () override;  Tree Formula default destructor. ;  ; Int_t DefinedVariable (TString &variable, Int_t &action) override;  Check if name is in the list of Tree/Branch leaves. ;  ; virtual TClass * EvalClass () const;  Evaluate the class of this treeformula. ;  ; template<typename T > ; T EvalInstance (Int_t i=0, const char *stringStack[]=nullptr);  Evaluate this treeformula. ;  ; virtual Double_t EvalInstance (Int_t i=0, const char *strin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:1875,load,loading,1875,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['load'],['loading']
Performance,"mpling strategy is; to start with 64 equally spaces samples in the range y=(0.01-0.99).; Then the y ranges are pushed outward by reducing y (or the distance of y to 1.0); by a factor of sqrt(10) iteratively up to the point where the corresponding; x value no longer changes significantly. For p.d.f.s with very flat tails; such as Gaussians some part of the tail may be lost due to limitations; in numeric precision in the CDF inversion step. An effect related to the above limitation in numeric precision should; be anticipated when floating the alpha parameter in a fit. If a p.d.f; with such flat tails is fitted, it is likely that the dataset contains; events in the flat tail region. If the alpha parameter is varied, the; likelihood contribution from such events may exhibit discontinuities; in alpha, causing discontinuities in the summed likelihood as well; that will cause convergence problems in MINUIT. To mitigate this effect; one can use the setCacheAlpha() method to instruct RooIntegralMorph; to construct a two-dimensional cache for its output values in both; x and alpha. If linear interpolation is requested on the resulting; output histogram, the resulting interpolation of the p.d.f in the; alpha dimension will smooth out the discontinities in the tail regions; result in a continuous likelihood distribution that can be fitted.; An added advantage of the cacheAlpha option is that if parameters; p,q of f1,f2 are fixed, the cached values in RooIntegralMorph are; valid for the entire fit session and do not need to be recalculated; for each change in alpha, which may result an considerable increase; in calculation speed. Function Members (Methods); public:. RooIntegralMorph(); RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); RooIntegralMorph(const char* name, const char* title, RooAbsReal& _pdf1, RooAbsReal& _pdf2, RooAbsReal& _x, RooAbsReal& _alpha, Bool_t cacheAlpha = kFALSE); virtual~RooIntegralMorph(); voidTObject::AbstractMethod(const char* met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooIntegralMorph.html:3563,cache,cache,3563,root/html526/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html526/RooIntegralMorph.html,5,['cache'],['cache']
Performance,"mpling strategy is; to start with 64 equally spaces samples in the range y=(0.01-0.99).; Then the y ranges are pushed outward by reducing y (or the distance of y to 1.0); by a factor of sqrt(10) iteratively up to the point where the corresponding; x value no longer changes significantly. For p.d.f.s with very flat tails; such as Gaussians some part of the tail may be lost due to limitations; in numeric precision in the CDF inversion step. An effect related to the above limitation in numeric precision should; be anticipated when floating the alpha parameter in a fit. If a p.d.f; with such flat tails is fitted, it is likely that the dataset contains; events in the flat tail region. If the alpha parameter is varied, the; likelihood contribution from such events may exhibit discontinuities; in alpha, causing discontinuities in the summed likelihood as well; that will cause convergence problems in MINUIT. To mitigate this effect; one can use the setCacheAlpha() method to instruct RooIntegralMorph; to construct a two-dimensional cache for its output values in both; x and alpha. If linear interpolation is requested on the resulting; output histogram, the resulting interpolation of the p.d.f in the; alpha dimension will smooth out the discontinities in the tail regions; result in a continuous likelihood distribution that can be fitted.; An added advantage of the cacheAlpha option is that if parameters; p,q of f1,f2 are fixed, the cached values in RooIntegralMorph are; valid for the entire fit session and do not need to be recalculated; for each change in alpha, which may result an considerable increase; in calculation speed. Function Members (Methods); public:. virtual~RooIntegralMorph(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valuePro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooIntegralMorph.html:3563,cache,cache,3563,root/html602/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html602/RooIntegralMorph.html,2,['cache'],['cache']
Performance,"mponents from four orthosymplectic vectors (which must have methods x(), y(), z(), and t()) which will be used as the columns of the Lorentz rotation matrix. ; The values will be adjusted so that the result will always be a good Lorentz rotation matrix. ; Definition at line 223 of file LorentzRotation.h. ◆ SetComponents() [2/3]. template<class IT > . void ROOT::Math::LorentzRotation::SetComponents ; (; IT ; begin, . IT ; end . ). inline . Set the 16 matrix components given an iterator to the start of the desired data, and another to the end (16 past start). ; Definition at line 256 of file LorentzRotation.h. ◆ SetComponents() [3/3]. void ROOT::Math::LorentzRotation::SetComponents ; (; Scalar ; xx, . Scalar ; xy, . Scalar ; xz, . Scalar ; xt, . Scalar ; yx, . Scalar ; yy, . Scalar ; yz, . Scalar ; yt, . Scalar ; zx, . Scalar ; zy, . Scalar ; zz, . Scalar ; zt, . Scalar ; tx, . Scalar ; ty, . Scalar ; tz, . Scalar ; tt . ). inline . Set the components from sixteen scalars – UNCHECKED for orthosymplectic. ; Definition at line 320 of file LorentzRotation.h. ◆ SetRotationMatrix(). template<class ForeignMatrix > . void ROOT::Math::LorentzRotation::SetRotationMatrix ; (; const ForeignMatrix & ; m). inline . Set components from a linear algebra matrix of size at least 4x4, which must support operator()(i,j) to obtain elements (0,0) thru (3,3). ; Precondition: The matrix is assumed to be orthosymplectic. NO checking or re-adjusting is performed. ; Definition at line 295 of file LorentzRotation.h. Member Data Documentation. ◆ fM. Scalar ROOT::Math::LorentzRotation::fM[16]. private . Definition at line 460 of file LorentzRotation.h. Libraries for ROOT::Math::LorentzRotation:. [legend]; The documentation for this class was generated from the following files:; math/genvector/inc/Math/GenVector/LorentzRotation.h; math/genvector/src/LorentzRotation.cxx. ROOTMathLorentzRotation. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzRotation.html:23472,perform,performed,23472,doc/master/classROOT_1_1Math_1_1LorentzRotation.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzRotation.html,1,['perform'],['performed']
Performance,"mponents of complex PDFs that can be precalculated with the dataset are automatically identified as such and will be precalculated when fitting to a dataset; By forcibly precalculating functions with non-trivial Jacobians, or functions of multiple variables occurring in the data set, using addColumn(), you may alter the outcome of the fit.; Only in cases where such a modification of fit behaviour is intentional, this function should be used. ; Implements RooAbsDataStore.; Definition at line 782 of file RooTreeDataStore.cxx. ◆ append(). void RooTreeDataStore::append ; (; RooAbsDataStore & ; other). overridevirtual . Implements RooAbsDataStore.; Definition at line 867 of file RooTreeDataStore.cxx. ◆ attachBuffers(). void RooTreeDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 1036 of file RooTreeDataStore.cxx. ◆ attachCache(). void RooTreeDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overrideprivatevirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 229 of file RooTreeDataStore.cxx. ◆ cacheArgs(). void RooTreeDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; newVarSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). overridevirtual . Cache given RooAbsArgs with this tree: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ; Upon a get() call, the internal cache of 'newVar' will be loaded with the precalculated value and it's dirty flag will be cleared. ; Implements RooAbsDataStore.; Definition at line 950 of file RooTreeDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooTreeDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 121 of file RooTreeDataStore",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:27625,cache,cachedVars,27625,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['cache'],['cachedVars']
Performance,"mponents! Set of owned component; TIterator*_pdfIter! Iterator of PDF list; RooListProxy_pdfListList of PDF components; RooLinkedList_pdfNSetListList of PDF component normalization sets; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; TNamed*_refRangeNameReference range name for interpretation of conditional products; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; Bool_t_selfNormIs self-normalized; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useDefaultGenUse default or distributed event generator; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:46586,cache,cache,46586,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,1,['cache'],['cache']
Performance,"mponents! Set of owned component; TIterator*_pdfObsIter! ; RooSetProxy_pdfObsListList of observables mapped onto histogram observables; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Double_t_totVolume! Total volume of space (product of ranges of observables); Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_unitNormAssume contents is unit normalized (for use as pdf cache); Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistPdf.html:40541,cache,cache,40541,root/html528/RooHistPdf.html,https://root.cern,https://root.cern/root/html528/RooHistPdf.html,6,['cache'],['cache']
Performance,"mporary directories. More...;  ; class  RWebBrowserImp;  ; class  RWebDisplayArgs;  Holds different arguments for starting browser with RWebDisplayHandle::Display() method. More...;  ; class  RWebDisplayHandle;  Handle of created web-based display Depending from type of web display, holds handle of started browser process or other display-specific information to correctly stop and cleanup display. More...;  ; class  RWebWindow;  Represents web window, which can be shown in web browser or any other supported environment. More...;  ; class  RWebWindowsManager;  Central instance to create and show web-based windows like Canvas or FitPanel. More...;  ; class  RWebWindowWSHandler;  just wrapper to deliver websockets call-backs to the RWebWindow class More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:5902,queue,queue,5902,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,3,['queue'],['queue']
Performance,"mport(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; 18.9.1 GDML; Few lines above word GDML was used. GDML stands for Geometry Description Markup Language. It is an application-independent geometry description format based on XML. It is mainly used for geometry interchange between ROOT and Geant4 framework. More details about this project can be found http://gdml.web.cern.ch. This feature (importing/exporting from/to gdml file format) is disabled by default in ROOT installation. To enable this feature add --enable-gdml option to ./configure script call.; 18.10 Navigation Algorithms; This section will describe the main methods and algorithms used for implementing the navigation features within the geometrical modeller. This includes navigation queries at shape level, global geometrical queries and optimization mechanisms.; 18.10.1 Finding the State Corresponding to a Location (x,y,z); For reminder, a geometry state is a ‘touchable’ object in the geometry hierarchy. It is represented by a path like: /TOP_1/A_1/B_3/C_1, where B_3 for instance is a copy of volume B positioned inside volume A. A state is always associated to a transformation matrix M of the touchable with respect to the global reference frame (obtained by piling-up all local transformations of nodes in the branch with respect to their containers). The current state and the corresponding global matrix are updated whenever the geometry depth is modified. The global transformations corresponding to all nodes in the current branch are kept in an array: (MTOP_1, MA_1, MB_3, …). Navigation in the geometry hierarchy. The elementary operations for changing the state are:; TGeoManager::CdUp();; TGeoManager::CdDown(i);; TGeoManager::CdTop(); The current state accounting and global matrix handling a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1021952,optimiz,optimization,1021952,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimization']
Performance,"mpositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTGTextView::IsMarked() const; Bool_tTObject::IsOnHeap() const; Bool_tTGTextView::IsReadOnly() const; virtual Bool_tTGTextView::IsSaved(); virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; long&ios_base::iword(int __ix); virtual voidTGTextView::Layout(); virtual Bool_tTGTextView::LoadBuffer(const char* txtbuf); virtual Bool_tTGTextView::LoadFile(const char* fname, long startpos = 0, long length = -1); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); virtual voidTGTextView::Marked(Bool_t mark)SIGNAL ; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; charbasic_ios<char,char_traits<char> >::narrow(basic_ios<char,char_traits<char> >::char_type __c, char __dfault) const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGTextViewostream.html:12407,Load,LoadBuffer,12407,root/html604/TGTextViewostream.html,https://root.cern,https://root.cern/root/html604/TGTextViewostream.html,1,['Load'],['LoadBuffer']
Performance,"mpute the likelihood ratio chi2 See the function GetChisquare() for details. ; Definition at line 914 of file TFractionFitter.cxx. ◆ ComputeFCN(). void TFractionFitter::ComputeFCN ; (; Double_t & ; f, . const Double_t * ; par, . Int_t ; flag . ). private . Used internally to compute the likelihood value. ; Definition at line 664 of file TFractionFitter.cxx. ◆ Constrain(). void TFractionFitter::Constrain ; (; Int_t ; parm, . Double_t ; low, . Double_t ; high . ). Constrain the values of parameter number <parm> (the parameter numbering follows that of the input template vector). ; Use UnConstrain() to remove this constraint. ; Definition at line 463 of file TFractionFitter.cxx. ◆ DeclFileName(). static const char * TFractionFitter::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 112 of file TFractionFitter.h. ◆ ErrorAnalysis(). void TFractionFitter::ErrorAnalysis ; (; Double_t ; UP). Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. ; Definition at line 583 of file TFractionFitter.cxx. ◆ EvaluateFCN(). Double_t TFractionFitter::EvaluateFCN ; (; const Double_t * ; par). inline . Definition at line 66 of file TFractionFitter.h. ◆ ExcludeBin(). void TFractionFitter::ExcludeBin ; (; Int_t ; bin). Exclude the given bin from the fit. ; The bin numbering to be used is that of TH1::GetBin(). ; Definition at line 418 of file TFractionFitter.cxx. ◆ FindPrediction(). void TFractionFitter::FindPrediction ; (; int ; bin, . double & ; t_i, . int & ; k_0, . double & ; A_ki . ); const. private . Function used internally to obtain the template prediction in the individual bins 'bin' <=> 'i' (paper) 'par' <=> 'j' (paper) ; Definition at line 757 of file TFractionFitter.cxx. ◆ Fit(). TFitResultPtr TFractionFitter::Fit ; (; ). Perform the fit with the default UP value. ; The value returned is the minimisation status. ; Definition at line 553 of file TFractionFitter.cxx. ◆ GetChisquare(). Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:24860,perform,perform,24860,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['perform'],['perform']
Performance,"mputed. The axis parameters are replaced by the optimized parameters ; Reimplemented in TProofLimitsFinder.; Definition at line 111 of file THLimitsFinder.cxx. ◆ GetLimitsFinder(). THLimitsFinder * THLimitsFinder::GetLimitsFinder ; (; ). static . Return pointer to the current finder. ; Create one if none exists Use SetLimitsFinder to set a user defined finder. ; Definition at line 153 of file THLimitsFinder.cxx. ◆ IsA(). TClass * THLimitsFinder::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TProofLimitsFinder.; Definition at line 46 of file THLimitsFinder.h. ◆ Optimize(). void THLimitsFinder::Optimize ; (; Double_t ; A1, . Double_t ; A2, . Int_t ; nold, . Double_t & ; BinLow, . Double_t & ; BinHigh, . Int_t & ; nbins, . Double_t & ; BinWidth, . Option_t * ; option = """" . ). static . Static function to compute reasonable axis limits. ; Input parameters:; Parameters. [in]A1,A2: Original axis limits ; [in]BinLow,BinHigh: Optimized axis limits. They should be initialized by the calling method for instance to 0. ; [out]nold: Original number of divisions. ; [out]nbins: Optimized number of divisions. ; [out]BinWidth: Optimized bin width. It should be initialized by the calling method for instance to 0. ; [in]option: ""T"" means Time axis. . Definition at line 184 of file THLimitsFinder.cxx. ◆ OptimizeLimits(). void THLimitsFinder::OptimizeLimits ; (; Int_t ; nbins, . Int_t & ; newbins, . Double_t & ; xmin, . Double_t & ; xmax, . Bool_t ; isInteger . ). static . Optimize axis limits. ; When isInter=kTRUE, the function makes an integer binwidth and recompute the number of bins accordingly. ; Definition at line 367 of file THLimitsFinder.cxx. ◆ SetLimitsFinder(). void THLimitsFinder::SetLimitsFinder ; (; THLimitsFinder * ; finder). static . This static function can be used to specify a finder derived from THLimitsFinder. ; The finder may redefine the functions FindGoodLimits. Note that the redef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHLimitsFinder.html:14677,Optimiz,Optimized,14677,doc/master/classTHLimitsFinder.html,https://root.cern,https://root.cern/doc/master/classTHLimitsFinder.html,1,['Optimiz'],['Optimized']
Performance,"ms supporting window scaling). Use IsValid() to check the validity of the server socket. In case server socket is not valid use GetErrorCode() to obtain the specific error value. These values are: 0 = no error (socket is valid) -1 = low level socket() call failed -2 = low level bind() call failed -3 = low level listen() call failed Every valid server socket is added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. ; Definition at line 76 of file TServerSocket.cxx. ◆ ~TServerSocket(). TServerSocket::~TServerSocket ; (; ). virtual . Destructor: cleanup authentication stuff (if any) and close. ; Definition at line 162 of file TServerSocket.cxx. Member Function Documentation. ◆ Accept(). TSocket * TServerSocket::Accept ; (; UChar_t ; opt = 0). virtual . Accept a connection on a server socket. ; Returns a full-duplex communication TSocket object. If no pending connections are present on the queue and nonblocking mode has not been enabled with SetOption(kNoBlock,1) the call blocks until a connection is present. The returned socket must be deleted by the user. The socket is also added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. In case of error 0 is returned and in case non-blocking I/O is enabled and no connections are available -1 is returned.; The opt can be used to require client authentication; valid options are; kSrvAuth = require client authentication kSrvNoAuth = force no client authentication; Example: use Opt = kSrvAuth to require client authentication.; Default options are taken from fgAcceptOpt and are initially equivalent to kSrvNoAuth; they can be changed with the static method TServerSocket::SetAcceptOptions(Opt). The active defaults can be visualized using the static method TServerSocket::ShowAcceptOptions(). ; Reimplemented in TPServerSocket.; Definition at line 204 of file TServerSocket.cxx. ◆ Authenticate(). Bool_t TServerSo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTServerSocket.html:22183,queue,queue,22183,doc/master/classTServerSocket.html,https://root.cern,https://root.cern/doc/master/classTServerSocket.html,1,['queue'],['queue']
Performance,"ms(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFunctor1DBinding&operator=(const RooFunctor1DBinding&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctor1DBinding.html:19670,optimiz,optimizeCacheMode,19670,root/html602/RooFunctor1DBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctor1DBinding.html,2,['optimiz'],['optimizeCacheMode']
Performance,"ms(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::Heaviside&operator=(const RooStats::Heaviside&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__Heaviside.html:19363,optimiz,optimizeCacheMode,19363,root/html602/RooStats__Heaviside.html,https://root.cern,https://root.cern/root/html602/RooStats__Heaviside.html,2,['optimiz'],['optimizeCacheMode']
Performance,"ms(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUnblindCPAsymVar&operator=(const RooUnblindCPAsymVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindCPAsymVar.html:19748,optimiz,optimizeCacheMode,19748,root/html602/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html602/RooUnblindCPAsymVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"ms(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUnblindPrecision&operator=(const RooUnblindPrecision&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindPrecision.html:19745,optimiz,optimizeCacheMode,19745,root/html602/RooUnblindPrecision.html,https://root.cern,https://root.cern/root/html602/RooUnblindPrecision.html,2,['optimiz'],['optimizeCacheMode']
Performance,"ms; 2459/// of the observables listed in iset. If no nset argument is given; 2460/// the c.d.f normalization is constructed over the integrated; 2461/// observables, so that its maximum value is precisely 1. It is also; 2462/// possible to choose a different normalization for; 2463/// multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; 2464/// construct a partial cdf c(x,y) that only when integrated itself; 2465/// over z results in a maximum value of 1. To construct such a cdf pass; 2466/// z as argument to the optional nset argument; 2467 ; 2468RooFit::OwningPtr<RooAbsReal> RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset); 2469{; 2470 return createCdf(iset,RooFit::SupNormSet(nset)) ;; 2471}; 2472 ; 2473 ; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Create an object that represents the integral of the function over one or more observables listed in `iset`.; 2477/// The actual integration calculation is only performed when the return object is evaluated. The name; 2478/// of the integral object is automatically constructed from the name of the input function, the variables; 2479/// it integrates and the range integrates over; 2480///; 2481/// The following named arguments are accepted; 2482/// | Type of CmdArg | Effect on CDF; 2483/// | ---------------------|-------------------; 2484/// | SupNormSet(const RooArgSet&) | Observables over which should be normalized _in addition_ to the integration observables; 2485/// | ScanNumCdf() | Apply scanning technique if cdf integral involves numeric integration [ default ]; 2486/// | ScanAllCdf() | Always apply scanning technique; 2487/// | ScanNoCdf() | Never apply scanning technique; 2488/// | ScanParameters(Int_t nbins, Int_t intOrder) | Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf; 2489 ; 2490RooFit::OwningPtr<RooAbsReal> RooAbsPdf::createCdf(const RooArgSet& iset, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:118828,perform,performed,118828,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['perform'],['performed']
Performance,"mt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); voidTChain::InvalidateCurrentTree(); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); voidTChain::ReleaseChainProof(); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); Int_tTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. voidAddAliases(); voidFillDrawAttributes(TProof* p). Data Members; public:. static TChain::(anonymous)TChain::kAutoDelete; static TChain::(anonymous)TChain::kBigNumber; static TObject::(ano",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofChain.html:22421,cache,cacheSize,22421,root/html604/TProofChain.html,https://root.cern,https://root.cern/root/html604/TProofChain.html,1,['cache'],['cacheSize']
Performance,"mt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); voidTChain::InvalidateCurrentTree(); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); voidTChain::ReleaseChainProof(); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. voidAddAliases(); voidFillDrawAttributes(TProof* p). Data Members; public:. enum { kOwnsChain; };; enum TChain::[unnamed] { kGlobalWeight; kAutoDelete; kProofUptodate; kProofLite; kBigNumbe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofChain.html:22131,cache,cacheSize,22131,root/html534/TProofChain.html,https://root.cern,https://root.cern/root/html534/TProofChain.html,1,['cache'],['cacheSize']
Performance,"mt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); voidTChain::InvalidateCurrentTree(); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); voidTChain::ReleaseChainProof(); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. voidAddAliases(); voidFillDrawAttributes(TProof* p). Data Members; public:. static TChain::(anonymous)TChain::kAutoDelete; static TChain::(anonymous)TChain::kBigNumber; static TObject::(ano",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofChain.html:22412,cache,cacheSize,22412,root/html602/TProofChain.html,https://root.cern,https://root.cern/root/html602/TProofChain.html,1,['cache'],['cacheSize']
Performance,"mula *GetVar3() { return GetPlayer()->GetVar3(); }; 571 // See TSelectorDraw::GetVar; 572 TTreeFormula *GetVar4() { return GetPlayer()->GetVar4(); }; 573 // See TSelectorDraw::GetVal; 574 virtual Double_t *GetVal(Int_t i) { return GetPlayer()->GetVal(i); }; 575 // See TSelectorDraw::GetVal; 576 virtual Double_t *GetV1() { return GetPlayer()->GetV1(); }; 577 // See TSelectorDraw::GetVal; 578 virtual Double_t *GetV2() { return GetPlayer()->GetV2(); }; 579 // See TSelectorDraw::GetVal; 580 virtual Double_t *GetV3() { return GetPlayer()->GetV3(); }; 581 // See TSelectorDraw::GetVal; 582 virtual Double_t *GetV4() { return GetPlayer()->GetV4(); }; 583 virtual Double_t *GetW() { return GetPlayer()->GetW(); }; 584 virtual Double_t GetWeight() const { return fWeight; }; 585 virtual Long64_t GetZipBytes() const { return fZipBytes; }; 586 virtual void IncrementTotalBuffers(Int_t nbytes) { fTotalBuffers += nbytes; }; 587 bool IsFolder() const override { return true; }; 588 virtual bool InPlaceClone(TDirectory *newdirectory, const char *options = """");; 589 virtual Int_t LoadBaskets(Long64_t maxmemory = 2000000000);; 590 virtual Long64_t LoadTree(Long64_t entry);; 591 virtual Long64_t LoadTreeFriend(Long64_t entry, TTree* T);; 592 virtual Int_t MakeClass(const char *classname = nullptr, Option_t* option = """");; 593 virtual Int_t MakeCode(const char *filename = nullptr);; 594 virtual Int_t MakeProxy(const char* classname, const char* macrofilename = nullptr, const char* cutfilename = nullptr, const char* option = nullptr, Int_t maxUnrolling = 3);; 595 virtual Int_t MakeSelector(const char *selector = nullptr, Option_t *option = """");; 596 bool MemoryFull(Int_t nbytes);; 597 virtual Long64_t Merge(TCollection* list, Option_t* option = """");; 598 virtual Long64_t Merge(TCollection* list, TFileMergeInfo *info);; 599 static TTree *MergeTrees(TList* list, Option_t* option = """");; 600 bool Notify() override;; 601 virtual void OptimizeBaskets(ULong64_t maxMemory=10000000, Float_t minComp=1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:32073,Load,LoadBaskets,32073,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,4,"['Load', 'Optimiz']","['LoadBaskets', 'LoadTree', 'LoadTreeFriend', 'OptimizeBaskets']"
Performance,"mula); virtual voidTChain::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidTTree::SetAutoFlush(Long64_t autof = 30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTChain::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidSetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTChain::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* enlist, Option_t*); virtual voidTChain::SetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttribu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofChain.html:15994,cache,cachesize,15994,root/html528/TProofChain.html,https://root.cern,https://root.cern/root/html528/TProofChain.html,3,['cache'],['cachesize']
Performance,"mulaVar& select, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooTreeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeDataStore.html:2251,cache,cacheOwner,2251,root/html532/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html,1,['cache'],['cacheOwner']
Performance,"mum number of numerically integrated dimensions to activate normalization value caching; Int_t_nBins; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooParametricStepFunction.html:40099,cache,cache,40099,root/html530/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html530/RooParametricStepFunction.html,1,['cache'],['cache']
Performance,"mum of -log(L); Bool_t_absMinValidflag if absmin is up-to-date; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooMinuit*_minuit! Internal minuit instance; static Int_tRooPrintable::_nameLength; Int_t_nevalNumber evaluations used in last minimization; RooRealProxy_nllInput -log(L) function; RooSetProxy_obsParameters of profile likelihood; RooArgSet_obsAbsMinObservable values at absolute minimum; TIter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProfileLL.html:31424,cache,cache,31424,root/html530/RooProfileLL.html,https://root.cern,https://root.cern/root/html530/RooProfileLL.html,2,['cache'],['cache']
Performance,"mum of -log(L); Bool_t_absMinValidflag if absmin is up-to-date; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooMinuit*_minuit! Internal minuit instance; static Int_tRooPrintable::_nameLength; RooRealProxy_nllInput -log(L) function; RooSetProxy_obsParameters of profile likelihood; RooArgSet_obsAbsMinObservable values at absolute minimum; TIterator*_oiter! Iterator of profile likelihood output parame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProfileLL.html:30719,cache,cache,30719,root/html526/RooProfileLL.html,https://root.cern,https://root.cern/root/html526/RooProfileLL.html,2,['cache'],['cache']
Performance,"mum value of fXN; 49 Double_t fYNmin; ///<! Minimum value of fYN; 50 Double_t fYNmax; ///<! Maximum value of fYN; 51 Double_t fXoffset; ///<!; 52 Double_t fYoffset; ///<! Parameters used to normalize user data; 53 Double_t fXScaleFactor; ///<!; 54 Double_t fYScaleFactor; ///<!; 55 Double_t fZout; ///<! Histogram bin height for points lying outside the convex hull; 56 Double_t *fDist; ///<! Array used to order mass points by distance; 57 Int_t fMaxIter; ///<! Maximum number of iterations to find Delaunay triangles; 58 Int_t fTriedSize; ///<! Real size of the fxTried arrays; 59 Int_t *fPTried; ///<!; 60 Int_t *fNTried; ///<! Delaunay triangles storage of size fNdt; 61 Int_t *fMTried; ///<!; 62 Int_t *fHullPoints; ///<! Hull points of size fNhull; 63 Int_t *fOrder; ///<! Array used to order mass points by distance; 64 Bool_t fAllTri; ///<! True if FindAllTriangles() has been performed on fGraph2D; 65 Bool_t fInit; ///<! True if CreateTrianglesDataStructure() and FindHull() have been performed; 66 TGraph2D *fGraph2D; ///<! 2D graph containing the user data; 67 ; 68 void CreateTrianglesDataStructure();; 69 Bool_t Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) const;; 70 void FileIt(Int_t P, Int_t N, Int_t M);; 71 void FindHull();; 72 Bool_t InHull(Int_t E, Int_t X) const;; 73 Double_t InterpolateOnPlane(Int_t TI1, Int_t TI2, Int_t TI3, Int_t E) const;; 74 ; 75public:; 76 ; 77 TGraphDelaunay();; 78 TGraphDelaunay(TGraph2D *g);; 79 ; 80 ~TGraphDelaunay() override;; 81 ; 82 Double_t ComputeZ(Double_t x, Double_t y);; 83 void FindAllTriangles();; 84 TGraph2D *GetGraph2D() const {return fGraph2D;}; 85 Double_t GetMarginBinsContent() const {return fZout;}; 86 Int_t GetNdt() const {return fNdt;}; 87 Int_t *GetPTried() const {return fPTried;}; 88 Int_t *GetNTried() const {return fNTried;}; 89 Int_t *GetMTried() const {return fMTried;}; 90 Double_t *GetXN() const {return fXN;}; 91 Double_t *GetYN() const {return fYN;}; 92 Double_t GetXNmin() const {return fXNmin;}; 93 Double_t G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphDelaunay_8h_source.html:2885,perform,performed,2885,doc/master/TGraphDelaunay_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8h_source.html,1,['perform'],['performed']
Performance,"mutableprivate; GetActualClass(const void *object) constTClass; GetAttributeMap() constTDictionaryinline; GetBaseClass(const char *classname)TClass; GetBaseClass(const TClass *base)TClass; GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)TClass; GetBaseClassOffsetRecurse(const TClass *toBase)TClassprivate; GetBaseDataMember(const char *datamember)TClass; GetCheckSum(ECheckSum code=kCurrentCheckSum) constTClass; GetCheckSum(Bool_t &isvalid) constTClass; GetCheckSum(ECheckSum code, Bool_t &isvalid) constTClass; GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)TClassstatic; GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size)TClassstatic; GetClass(const std::type_info &typeinfo, Bool_t load=kTRUE, Bool_t silent=kFALSE, size_t hint_pair_offset=0, size_t hint_pair_size=0)TClassstatic; GetClass(ClassInfo_t *info, Bool_t load=kTRUE, Bool_t silent=kFALSE)TClassstatic; GetClass(Bool_t load=kTRUE, Bool_t silent=kFALSE)TClassstatic; GetClass(DeclId_t id, std::vector< TClass * > &classes)TClassstatic; GetClassInfo() constTClassinline; GetClassMethod(Longptr_t faddr)TClassprivate; GetClassMethod(const char *name, const char *params, Bool_t objectIsConst=kFALSE)TClass; GetClassMethodWithPrototype(const char *name, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)TClass; GetClassSize() constTClassinline; GetClassVersion() constTClassinline; GetCollectionProxy() constTClass; GetCollectionType() constTClass; GetContextMenuTitle() constTClassinline; GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constTClass; GetConversionStreamerInfo(const TClass *onfile_cl, Int_t version) constTClass; GetConvStreamerFunc() constTClass; GetCurrentStreamerInfo()TClassinline; GetDataMember(const char *datamember) constTClass; GetDataMemberOffset(const char *membername) constTClass; GetDeclFileLine() constTClassinline; Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:7487,load,load,7487,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['load'],['load']
Performance,"mvirtual; IsSortable() const overrideTNamedinlinevirtual; IsZombie() constTObjectinline; kBitMask enum valueTObject; kCanDelete enum valueTObject; kCannotPick enum valueTObject; kDebug enum valueTSystem; kDefault enum valueTSystem; kFlatBuildDir enum valueTSystem; kHasUUID enum valueTObject; kInconsistent enum valueTObject; kInvalidObject enum valueTObject; kIsOnHeap enum valueTObject; kIsReferenced enum valueTObject; kMustCleanup enum valueTObject; kNoContextMenu enum valueTObject; kNotDeleted enum valueTObject; kObjInCanvas enum valueTObject; kOnlyPrepStep enum valueTObjectprotected; kOpt enum valueTSystem; kOverwrite enum valueTObject; kSingleKey enum valueTObject; kWriteDelete enum valueTObject; kZombie enum valueTObject; Link(const char *from, const char *to)TSystemvirtual; ListLibraries(const char *regexp="""")TSystemvirtual; ListSymbols(const char *module, const char *re="""")TSystemvirtual; Load(const char *module, const char *entry="""", Bool_t system=kFALSE)TSystemvirtual; LoadAllLibraries()TSystemvirtual; ls(Option_t *option="""") const overrideTNamedvirtual; MakeDirectory(const char *name)TSystemvirtual; MakeZombie()TObjectinlineprotected; MayNotUse(const char *method) constTObject; mkdir(const char *name, Bool_t recursive=kFALSE)TSystemvirtual; NextTimeOut(Bool_t mode)TSystemvirtual; Notify()TObjectvirtual; NotifyApplicationCreated()TSystemvirtual; Now()TSystemvirtual; Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constTObject; OpenConnection(const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"")TSystemvirtual; OpenDirectory(const char *name)TSystemvirtual; Openlog(const char *name, Int_t options, ELogFacility facility)TSystemvirtual; OpenPipe(const char *command, const char *mode)TSystemvirtual; operator delete(void *ptr)TObject; operator delete(void *ptr, void *vp)TObject; operator delete[](void *ptr)TObject; operator delete[](void *ptr, void *vp)TObject; operator new(size_t sz)TObjectinline; operator ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem-members.html:10987,Load,LoadAllLibraries,10987,doc/master/classTSystem-members.html,https://root.cern,https://root.cern/doc/master/classTSystem-members.html,1,['Load'],['LoadAllLibraries']
Performance,"my for now). void printValue(ostream& os) const; Print object value. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Structure printing. Bool_t isValid() const; Check if current value is valid. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Interface function to check if given value is a valid value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset, 				 const RooNumIntConfig* cfg, const char* rangeName); Create an object that represents the integral o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:35025,perform,performed,35025,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['perform'],['performed']
Performance,"m BaseFunc;  ;  Public Types inherited from ROOT::Math::IBaseFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  ;  Public Types inherited from ROOT::Math::IGradientFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  ; typedef IGradientFunctionOneDim BaseGrad;  . Public Member Functions;  Polynomial (double a, double b);  Construct a Polynomial of degree 1 : a*x + b. ;  ;  Polynomial (double a, double b, double c);  Construct a Polynomial of degree 2 : a*x**2 + b*x + c. ;  ;  Polynomial (double a, double b, double c, double d);  Construct a Polynomial of degree 3 : a*x**3 + b*x**2 + c*x + d. ;  ;  Polynomial (double a, double b, double c, double d, double e);  Construct a Polynomial of degree 4 : a*x**4 + b*x**3 + c*x**2 + dx + e. ;  ;  Polynomial (unsigned int n=0);  Construct a Polynomial function of order n. ;  ;  ~Polynomial () override;  ; IGenFunction * Clone () const override;  Clone a function. ;  ; void FdF (double x, double &f, double &df) const override;  Optimized method to evaluate at the same time the function value and derivative at a point x. ;  ; const std::vector< std::complex< double > > & FindNumRoots ();  Find the polynomial roots using always an iterative numerical methods The numerical method used is from GSL (see documentation ) ;  ; std::vector< double > FindRealRoots ();  Find the only the real polynomial roots. ;  ; const std::vector< std::complex< double > > & FindRoots ();  Find the polynomial roots. ;  ; unsigned int Order () const;  Order of Polynomial. ;  ;  Public Member Functions inherited from ROOT::Math::ParamFunction< IParamGradFunction >;  ParamFunction (unsigned int npar=0);  Construct a parameteric function with npar parameters. ;  ; virtual ~ParamFunction ();  ; unsigned int NPar () const;  Return the number of parameters. ;  ; virtual const double * Parameters () const;  Access the parameter values. ;  ; virtual void SetParameters (const double *p);  Set the parameter values. ;  ;  Public Member Functions inherited from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Polynomial.html:2447,Optimiz,Optimized,2447,doc/master/classROOT_1_1Math_1_1Polynomial.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Polynomial.html,1,['Optimiz'],['Optimized']
Performance,"n ( a value <=0 corresponds to the let the minimizer choose its default one) ;  ; int PrintLevel () const;  minimizer configuration parameters ;  ; void SetDefaultOptions ();  reset the default options (defined in MinimizerOptions) ;  ; void SetErrorDef (double up);  set scale for calculating the errors ;  ; void SetExtraOptions (const IOptions &extraOptions);  set only the extra options ;  ; void SetMaxFunctionCalls (unsigned int maxfcn);  set maximum of function calls ;  ; void SetMaxIterations (unsigned int maxiter);  set maximum iterations (one iteration can have many function calls) ;  ; void SetOptions (const MinimizerOptions &opt);  set all options in one go ;  ; void SetPrecision (double prec);  set in the minimizer the objective function evaluation precision ( a value <=0 means the minimizer will choose its optimal value automatically, i.e. ;  ; void SetPrintLevel (int level);  set print level ;  ; void SetStrategy (int strategyLevel);  set the strategy ;  ; void SetTolerance (double tol);  set the tolerance ;  ; void SetValidError (bool on);  flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit) ;  ; virtual bool SetVariableInitialRange (unsigned int, double, double);  set the initial range of an existing variable ;  ; template<class VariableIterator > ; int SetVariables (const VariableIterator &begin, const VariableIterator &end);  add variables . Return number of variables successfully added ;  ; int Status () const;  status code of minimizer ;  ; int Strategy () const;  strategy ;  ; double Tolerance () const;  absolute tolerance ;  . Protected Member Functions; bool ExamineMinimum (const ROOT::Minuit2::FunctionMinimum &min);  examine the minimum result ;  ; virtual const ROOT::Minuit2::FCNBase * GetFCN () const;  ; virtual const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer () const;  ; int RunMinosError (unsigned int i, double &errLow, double &errUp, int runopt);  ; bool SetCovariance (std::span< const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html:10396,perform,perform,10396,doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,1,['perform'],['perform']
Performance,"n ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; virtual bool Equals (RooArgSet &x1, RooArgSet &x2);  whether we own the proposal density function ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::unique_ptr< RooDataSet > fCache;  our position in the cached proposal data set ;  ; Int_t fCachePosition = 0;  how many points to generate each time ;  ; Int_t fCacheSize = 1;  the last point we were at ;  ; std::map< RooRealVar *, RooAbsReal * >::iterator fIt;  map of values in pdf to update ;  ; RooArgSet fLastX;  pdf iterator ;  ; std::map< RooRealVar *, RooAbsReal * > fMap;  the proposal density function ;  ; RooArgSet fMaster;  the cached proposal data set ;  ; bool fOwnsPdf = false;  pointers to master variables needed for updates ;  ; RooAbsPdf * fPdf = nullptr;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html:13260,cache,cached,13260,doc/master/classRooStats_1_1PdfProposal.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html,2,['cache'],['cached']
Performance,"n ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Static Public Attributes; static constexpr double implementedPrecision = RooFit::SuperFloatPrecision::digits10;  length of floating point digits precision supported by implementation. ;  . Private Member Functions; void disableInterference (const std::vector< const char * > &nonInterfering);  disable interference between terms ;  ; void disableInterferences (const std::vector< std::vector< const char * > > &nonInterfering);  disable interference between terms ;  ; RooLagrangianMorphFunc::CacheElem * getCache () const;  retrieve the cache object ;  ; bool hasCache () const;  return true if a cache object is present, false otherwise ;  ; void init ();  initialise inputs required for the morphing function ;  ; void setup (bool ownParams=true);  setup this instance with the given set of operators and vertices if own=true, the class will own the operators template <class Base> ;  ; RooRealVar * setupObservable (const char *obsname, TClass *mode, TObject *inputExample);  setup observable, recycle existing observable if defined ;  ; void updateSampleWeights ();  update sample weight (-?-) ;  . Private Attributes; RooListProxy _binWidths;  ; RooObjCacheManager _cacheMgr;  ; Config _config;  ; std::vector< std::vector< RooListProxy * > > _diagrams;  ; RooListProxy _flags;  ; std::vector< std::vector< std::string > > _nonInterfering;  ; RooListProxy _observables;  ; RooSetProxy _operators;  ; RooListProxy _physics;  ; std::map< std::string, int > _sampleMap;  ; double _scale = 1.0;  The cache manager. ;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:59209,Cache,CacheElem,59209,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,3,"['Cache', 'cache']","['CacheElem', 'cache']"
