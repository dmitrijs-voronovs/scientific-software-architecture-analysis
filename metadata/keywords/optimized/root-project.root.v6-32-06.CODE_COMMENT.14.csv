quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Integrability,"// The value for the symbol depends on the context we're evaluating in:; // Inside a load this is the address in the linker's memory, outside a; // load it's the address in the target processes memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:28,depend,depends,28,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,1,['depend'],['depends']
Integrability,"// The value is free of any CFG dependencies.; // Do as if it lives in the entry block.; //; // We do this to make sure all the values falling on this path are; // seen through the same anchor point. The rationale is these values; // can be combined together to from a sub expression free of any CFG; // dependencies so we want them to stay together.; // We could be cleverer and postpone the anchor down to the first; // anchored value, but that's likely complicated to get right.; // E.g., we wouldn't want to do that if that means being stuck in a; // loop.; //; // For instance, we wouldn't want to change:; // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...; // into; // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...; // Because all the sub expressions with arg2..N would be stuck between; // two loop dependent values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:32,depend,dependencies,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,3,['depend'],"['dependencies', 'dependent']"
Integrability,// The value of CondIsTrue only matters if the value is not; // condition-dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:74,depend,dependent,74,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['depend'],['dependent']
Integrability,"// The value of this expr depends on a template parameter, or an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:26,depend,depends,26,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['depend'],['depends']
Integrability,"// The value returned by fpclassify is platform dependent, therefore it is not; // supported by hipRTC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:48,depend,dependent,48,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,1,['depend'],['dependent']
Integrability,// The value should be equal to PseudoProbeReservedId::Last + 1 which is; // defined in SampleProfileProbe.h. The header file is not included here to; // reduce the dependency from MC to IPO.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCPseudoProbe.h:165,depend,dependency,165,interpreter/llvm-project/llvm/include/llvm/MC/MCPseudoProbe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCPseudoProbe.h,1,['depend'],['dependency']
Integrability,// The value written by __atomic_test_and_set.; // FIXME: This is target-dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:73,depend,dependent,73,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,1,['depend'],['dependent']
Integrability,// The vector index of the LSBs of the source depend on the endian-ness.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:46,depend,depend,46,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['depend']
Integrability,// The vectorizer may have significantly shortened a loop body; unroll; // again. Unroll small loops to hide loop backedge latency and saturate any; // parallel execution resources of an out-of-order processor. We also then; // need to clean up redundancies and loop invariant code.; // FIXME: It would be really good to use a loop-integrated instruction; // combiner for cleanup here so that the unrolling and LICM can be pipelined; // across the loop nests.; // We do UnrollAndJam in a separate LPM to ensure it happens before unroll,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:332,integrat,integrated,332,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['integrat'],['integrated']
Integrability,"// The visitor has requested that cut off visitation of any; // module that the current module depends on. To indicate this; // behavior, we mark all of the reachable modules as having been visited.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:95,depend,depends,95,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,1,['depend'],['depends']
Integrability,// The wider add is guaranteed to not wrap because both operands are; // sign-extended.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,wrap,wrap,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['wrap'],['wrap']
Integrability,"// The wider cast must be supported by the target. This is unusual because; // the operation support type parameter depends on the opcode. In addition,; // check the other type in the cast to make sure this is really legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:116,depend,depends,116,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['depends']
Integrability,// The wrapper is not needed in this case as we don't need to export; // it to anyone else.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:7,wrap,wrapper,7,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,1,['wrap'],['wrapper']
Integrability,// ThePreheaderBB conceptually corresponds to both Plan.getPreheader() (which; // wraps the original preheader BB) and Plan.getEntry() (which represents the; // new vector preheader); here we're interested in setting BB2VPBB to the; // latter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp:82,wrap,wraps,82,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,1,['wrap'],['wraps']
Integrability,"// There are 2 cases to represent the bounds information for an array:; // 1) DW_TAG_array_type; // DW_AT_type --> ref_type; // DW_TAG_subrange_type; // DW_AT_type --> ref_type (type of object); // DW_AT_count --> value (number of elements in subrange); // 2) DW_TAG_array_type; // DW_AT_type --> ref_type; // DW_TAG_subrange_type; // DW_AT_lower_bound --> value; // DW_AT_upper_bound --> value; // The idea is to represent the bounds as a string, depending on the format:; // 1) [count]; // 2) [lower][upper]; // Traverse scope types, looking for those types that are subranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp:448,depend,depending,448,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,1,['depend'],['depending']
Integrability,"// There are 2 cases to represent the bounds information for an array:; // 1) DW_TAG_subrange_type; // DW_AT_type --> ref_type (type of count); // DW_AT_count --> value (number of elements in subrange); // 2) DW_TAG_subrange_type; // DW_AT_lower_bound --> value; // DW_AT_upper_bound --> value; // The idea is to represent the bounds as a string, depending on the format:; // 1) [count]; // 2) [lower..upper]; // Subrange information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVType.cpp:347,depend,depending,347,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVType.cpp,1,['depend'],['depending']
Integrability,"// There are a couple of different kinds of errors we could get here.; // First, we re-format the SMDiagnostic in terms of a clang diagnostic.; // Strip ""error: "" off the start of the message string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp:184,message,message,184,interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,1,['message'],['message']
Integrability,"// There are cases where we cannot determine whether two values are; // equivalent, because it depends on not yet processed basic blocks -- see the; // documentation on assumptions.; //; // AC is the context in which we are currently performing a diff.; // When we encounter a pair of values for which we can neither prove; // equivalence nor the opposite, we do the following:; // * If AC is nullptr, we treat the pair as non-equivalent.; // * If AC is set, we add an assumption for the basic blocks given by AC,; // and treat the pair as equivalent. The assumption is checked later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:95,depend,depends,95,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,1,['depend'],['depends']
Integrability,"// There are certain anti-dependencies that cannot be ignored.; // Specifically:; // J2_call ... implicit-def %r0 ; SUJ; // R0 = ... ; SUI; // Those cannot be packetized together, since the call will observe; // the effect of the assignment to R0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:26,depend,dependencies,26,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependencies']
Integrability,"// There are compiler-wrappers (ccache, distcc, gomacc) that take the ""real""; // compiler as an argument, e.g. distcc gcc -O3 foo.c.; // These end up in compile_commands.json when people set CC=""distcc gcc"".; // Clang's driver doesn't understand this, so we need to unwrap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:22,wrap,wrappers,22,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,1,['wrap'],['wrappers']
Integrability,"// There are no more unscheduled dependencies after decrementing,; // so we can put the dependent instruction into the ready list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,depend,dependencies,33,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,4,['depend'],"['dependencies', 'dependent']"
Integrability,"// There are no more unscheduled dependencies after; // decrementing, so we can put the dependent instruction; // into the ready list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,depend,dependencies,33,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['depend'],"['dependencies', 'dependent']"
Integrability,"// There are noalias scope declarations:; // (general):; // Original: OrigPre { OrigHeader NewHeader ... Latch }; // after: (OrigPre+OrigHeader') { NewHeader ... Latch OrigHeader }; //; // with D: llvm.experimental.noalias.scope.decl,; // U: !noalias or !alias.scope depending on D; // ... { D U1 U2 } can transform into:; // (0) : ... { D U1 U2 } // no relevant rotation for this part; // (1) : ... D' { U1 U2 D } // D is part of OrigHeader; // (2) : ... D' U1' { U2 D U1 } // D, U1 are part of OrigHeader; //; // We now want to transform:; // (1) -> : ... D' { D U1 U2 D'' }; // (2) -> : ... D' U1' { D U2 D'' U1'' }; // D: original llvm.experimental.noalias.scope.decl; // D', U1': duplicate with replaced scopes; // D'', U1'': different duplicate with replaced scopes; // This ensures a safe fallback to 'may_alias' introduced by the rotate,; // as U1'' and U1' scopes will not be compatible wrt to the local restrict; // Clone the llvm.experimental.noalias.decl again for the NewHeader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:267,depend,depending,267,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['depend'],['depending']
Integrability,"// There are routines for saving at least 3 registers (r13 to r15, etc.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCFrameLowering.cpp:13,rout,routines,13,interpreter/llvm-project/llvm/lib/Target/ARC/ARCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCFrameLowering.cpp,2,['rout'],['routines']
Integrability,"// There are some benefits to schedule the ADDI before the load to hide the; // latency, as RA may create a true dependency between the load and addi.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:113,depend,dependency,113,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,1,['depend'],['dependency']
Integrability,"// There are some legal shift amounts, we can compute conservatively-correct; // range of no-wrap inputs. Note that by now we have clamped the ShAmtUMax; // to be at most bitwidth-1, which results in most conservative range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:93,wrap,wrap,93,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['wrap'],['wrap']
Integrability,// There are three cases for the base type:; // - builtin id (qualified or unqualified); // - builtin Class (qualified or unqualified); // - an interface,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:144,interface,interface,144,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['interface'],['interface']
Integrability,"// There are three cases for the receiver:; // (1) it is definitely nil,; // (2) it is definitely non-nil, and; // (3) we don't know.; //; // If the receiver is definitely nil, we skip the pre/post callbacks and; // instead call the ObjCMessageNil callbacks and return.; //; // If the receiver is definitely non-nil, we call the pre- callbacks,; // evaluate the call, and call the post- callbacks.; //; // If we don't know, we drop the potential nil flow and instead; // continue from the assumed non-nil state as in (2). This approach; // intentionally drops coverage in order to prevent false alarms; // in the following scenario:; //; // id result = [o someMethod]; // if (result) {; // if (!o) {; // // <-- This program point should be unreachable because if o is nil; // // it must the case that result is nil as well.; // }; // }; //; // However, it also loses coverage of the nil path prematurely,; // leading to missed reports.; //; // It's possible to handle this by performing a state split on every call:; // explore the state where the receiver is non-nil, and independently; // explore the state where it's nil. But this is not only slow, but; // completely unwarranted. The mere presence of the message syntax in the code; // isn't sufficient evidence that nil is a realistic possibility.; //; // An ideal solution would be to add the following constraint that captures; // both possibilities without splitting the state:; //; // ($x == 0) => ($y == 0) (1); //; // where in our case '$x' is the receiver symbol, '$y' is the returned symbol,; // and '=>' is logical implication. But RangeConstraintManager can't handle; // such constraints yet, so for now we go with a simpler, more restrictive; // constraint: $x != 0, from which (1) follows as a vacuous truth.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:1209,message,message,1209,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,1,['message'],['message']
Integrability,"// There are two notions of a ""definition"" for an Objective-C; // class: the interface and its implementation. When we resolved a; // reference to an Objective-C class, produce the @interface as; // the definition; when we were provided with the interface,; // produce the @implementation as the definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:77,interface,interface,77,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,3,['interface'],['interface']
Integrability,"// There are two possible boolean constructors, depending on which; // version of gtest is being used:; //; // v1.7 and earlier:; // AssertionResult(bool success); //; // v1.8 and greater:; // template <typename T>; // AssertionResult(const T& success,; // typename internal::EnableIf<; // !internal::ImplicitlyConvertible<T,; // AssertionResult>::value>::type*); //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:48,depend,depending,48,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,1,['depend'],['depending']
Integrability,"// There are two types of string tables that can exist, dynamic and not dynamic.; // In the dynamic case the string table is allocated. Changing a dynamic string; // table would mean altering virtual addresses and thus the memory image. So; // dynamic string tables should not have an interface to modify them or; // reconstruct them. This type lets us reconstruct a string table. To avoid; // this class being used for dynamic string tables (which has happened) the; // classof method checks that the particular instance is not allocated. This; // then agrees with the makeSection method used to construct most sections.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.h:285,interface,interface,285,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.h,1,['interface'],['interface']
Integrability,"// There are two ways we can find a class-scope declaration during template; // instantiation that we did not find in the template definition: if it is a; // member of a dependent base class, or if it is declared after the point of; // use in the same class. Distinguish these by comparing the class in which; // the member was found to the naming class of the lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:170,depend,dependent,170,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependent']
Integrability,"// There is ""more"" - let's assume this input consists of a using; // declaration or definition plus some code that should be wrapped.; //; // We need to include the ';' in the offset as this will be a; // non-wrapped statement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:125,wrap,wrapped,125,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,2,['wrap'],['wrapped']
Integrability,// There is a form of VFSGNJ which injects the negated sign of its second; // operand. Try and bubble any FNEG up after the extend/round to produce; // this optimized pattern. Avoid modifying cases where FP_ROUND and; // TRUNC=1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,inject,injects,35,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['inject'],['injects']
Integrability,"// There is a lack of information in the IR to assist with determining the; // source language. AIX exception handling mechanism would only search for; // personality routine and LSDA area when such language supports exception; // handling. So to be conservatively correct and allow runtime to do its job,; // we need to set it to C++ for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:167,rout,routine,167,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['rout'],['routine']
Integrability,"// There is a really nice hard cut-over between AVX1 and AVX2 that means we; // can check for those subtargets here and avoid much of the subtarget; // querying in the per-vector-type lowering routines. With AVX1 we have; // essentially *zero* ability to manipulate a 256-bit vector with integer; // types. Since we'll use floating point types there eventually, just; // immediately cast everything to a float and operate entirely in that domain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:193,rout,routines,193,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['rout'],['routines']
Integrability,"// There is another kind of unwind destination mismatches besides call unwind; // mismatches, which we will call ""catch unwind mismatches"". See this example; // after the marker placement:; // try; // try; // call @foo; // catch __cpp_exception ;; ehpad A (next unwind dest: caller); // ...; // end_try; // catch_all ;; ehpad B; // ...; // end_try; //; // 'call @foo's unwind destination is the ehpad A. But suppose 'call @foo'; // throws a foreign exception that is not caught by ehpad A, and its next; // destination should be the caller. But after control flow linearization,; // another EH pad can be placed in between (e.g. ehpad B here), making the; // next unwind destination incorrect. In this case, the foreign exception; // will instead go to ehpad B and will be caught there instead. In this; // example the correct next unwind destination is the caller, but it can be; // another outer catch in other cases.; //; // There is no specific 'call' or 'throw' instruction to wrap with a; // try-delegate, so we wrap the whole try-catch-end with a try-delegate and; // make it rethrow to the right destination, as in the example below:; // try; // try ;; (new); // try; // call @foo; // catch __cpp_exception ;; ehpad A (next unwind dest: caller); // ...; // end_try; // delegate 1 (caller) ;; (new); // catch_all ;; ehpad B; // ...; // end_try",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:982,wrap,wrap,982,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,2,['wrap'],['wrap']
Integrability,"// There is no call jmp sample between the inliner and inlinee, we need to use; // the inlinee's context to infer inliner's context, i.e. parent(inliner)'s; // sample depends on child(inlinee)'s sample, so traverse the tree in; // post-order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp:167,depend,depends,167,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp,1,['depend'],['depends']
Integrability,"// There is no integral type larger enough to represent this; // value. Complain, then allow the value to wrap around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,wrap,wrap,106,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['wrap'],['wrap']
Integrability,"// There is no need to update MaxSafeVectorWidthInBits after call to; // couldPreventStoreLoadForward, even if it changed MinDepDistBytes,; // since a forward dependency will allow vectorization using any width.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:159,depend,dependency,159,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependency']
Integrability,// There is no stall when ProdMI and ConsMI are not dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:52,depend,dependent,52,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['depend'],['dependent']
Integrability,// There is possibility of hoisting this instruction above some arbitrary; // condition. Any metadata defined on it can be control dependent on this; // condition. Conservatively strip it here so that we don't give any wrong; // information to the optimizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:131,depend,dependent,131,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,1,['depend'],['dependent']
Integrability,"// There is something else here that needs to be wrapped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:49,wrap,wrapped,49,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['wrap'],['wrapped']
Integrability,"// There isn't necessarily a valid equivalent source-level syntax for; // these; in particular, a naive lowering might violate access control.; // So for now we lower to a ConstantExpr holding the value, wrapped around; // an OpaqueValueExpr.; // FIXME: We should have a better representation for this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:204,wrap,wrapped,204,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['wrap'],['wrapped']
Integrability,// There may also be regunit dependencies to include in the height.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:29,depend,dependencies,29,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['depend'],['dependencies']
Integrability,// There may be multiple wrappers: using distcc and ccache together is common.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:25,wrap,wrappers,25,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,1,['wrap'],['wrappers']
Integrability,// There may be no interface context due to error in declaration; // of the interface (which has been reported). Recover gracefully.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:19,interface,interface,19,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,2,['interface'],['interface']
Integrability,"// There may be patterns where the importer can't deal with them optimally,; // but does select it to a suboptimal sequence so our custom C++ selection; // code later never has a chance to work on it. Therefore, we have an early; // selection attempt here to give priority to certain selection routines; // over the imported ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:294,rout,routines,294,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['rout'],['routines']
Integrability,"// There may be several overloads of ToDeclT::Create. We must make sure; // to call the one which would be chosen by the arguments, thus we use a; // wrapper for the overload set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:150,wrap,wrapper,150,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['wrap'],['wrapper']
Integrability,"// There may be two labels for the same location, and a function region may; // have the same address as a label at the start of the function (depending; // on the ABI).; // FIXME: we can probably do a comparison against other MemRegions, though.; // FIXME: is there a way to tell if two labels refer to the same location?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:143,depend,depending,143,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['depend'],['depending']
Integrability,"// There might be 'cycles' in the forced dependencies, since profile; // data isn't 100% accurate. Typically this is observed in loops, when the; // loop edges are the hottest successors for the basic blocks of the loop.; // Break the cycles by choosing the node with the smallest index as the; // head. This helps to keep the original order of the loops, which likely; // have already been rotated in the optimized manner.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:41,depend,dependencies,41,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['depend'],['dependencies']
Integrability,"// There must be no other dependency routes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:26,depend,dependency,26,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,2,"['depend', 'rout']","['dependency', 'routes']"
Integrability,// There no dependency between a prolog instruction and its successor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:12,depend,dependency,12,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependency']
Integrability,"// There should be no numeric integration happening",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx:30,integrat,integration,30,roofit/roofitcore/test/testRooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx,1,['integrat'],['integration']
Integrability,"// There should be no other servers besides the actual function and the; // factorized observables that the function doesn't depend on but are; // integrated over later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:125,depend,depend,125,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,2,"['depend', 'integrat']","['depend', 'integrated']"
Integrability,"// There was a buffer underrun on the kernel side. We may have lost; // events, please re-synchronize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp:90,synchroniz,synchronize,90,interpreter/llvm-project/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp,1,['synchroniz'],['synchronize']
Integrability,// There's no fundamental reason why we require at least one index; // (other than weirdness with &*IdxBegin being invalid; see; // getelementptr's init routine for example). But there's no; // present need to support it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:153,rout,routine,153,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['rout'],['routine']
Integrability,"// There's no need for a Wrapper node because we always incorporate a jump; // table operand into a BR_TABLE instruction, rather than ever; // materializing it in a register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:25,Wrap,Wrapper,25,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['Wrap'],['Wrapper']
Integrability,// These API functions are known to NOT act as a CFRetain wrapper.; // They simply make a new object owned by the caller.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:58,wrap,wrapper,58,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,2,['wrap'],['wrapper']
Integrability,// These are all defined in DependentDiagnostic.h.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:28,Depend,DependentDiagnostic,28,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['Depend'],['DependentDiagnostic']
Integrability,// These are not merged; we don't need to merge redeclarations of dependent; // template friends.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:66,depend,dependent,66,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['depend'],['dependent']
Integrability,// These are patterns used to reduce the length of dependence chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h:51,depend,dependence,51,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,1,['depend'],['dependence']
Integrability,// These are private helper routines of the constant emitter that; // can't actually be private because things are split out into helper; // functions and classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ConstantEmitter.h:28,rout,routines,28,interpreter/llvm-project/clang/lib/CodeGen/ConstantEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ConstantEmitter.h,1,['rout'],['routines']
Integrability,// These attributes are dependent on the capture of location information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVOptions.cpp:24,depend,dependent,24,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVOptions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVOptions.cpp,1,['depend'],['dependent']
Integrability,"// These attributes are normally just advisory, but in ARC, ns_consumed; // is significant. Allow non-dependent code to contain inappropriate; // attributes even in ARC, but require template instantiations to be; // set up correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:102,depend,dependent,102,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['depend'],['dependent']
Integrability,"// These bytes sort of have a hidden message, but it's not in; // little-endian this time, and it's a little redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:37,message,message,37,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,1,['message'],['message']
Integrability,"// These calls return their argument verbatim, as a low-level; // optimization. However, this makes high-level optimizations; // harder. Undo any uses of this optimization that the front-end; // emitted here. We'll redo them in the contract pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:232,contract,contract,232,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,1,['contract'],['contract']
Integrability,"// These can be scalar arguments or elements of a float array type; // passed directly. The latter are used to implement ELFv2 homogenous; // float aggregates.; // Named arguments go into FPRs first, and once they overflow, the; // remaining arguments go into GPRs and then the parameter save area.; // Unnamed arguments for vararg functions always go to GPRs and; // then the parameter save area. For now, put all arguments to vararg; // routines always in both locations (FPR *and* GPR or stack slot).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:439,rout,routines,439,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['rout'],['routines']
Integrability,"// These constructors are defined in the Frontend library, because; // CheckerRegistry, a crucial component of the initialization is in there.; // CheckerRegistry cannot be moved to the Core library, because the checker; // registration functions are defined in the Checkers library, and the library; // dependencies look like this: Core -> Checkers -> Frontend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h:304,depend,dependencies,304,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h,1,['depend'],['dependencies']
Integrability,"// These correspond with the checker options. Looking at other checkers such; // as MallocChecker and CStringChecker, this is similar as to how they pull; // off having a modeling class, but emitting diagnostics under a smaller; // checker's name that can be safely disabled without disturbing the; // underlaying modeling engine.; // The reason behind having *checker options* rather then actual *checkers*; // here is that CallAndMessage is among the oldest checkers out there, and can; // be responsible for the majority of the reports on any given project. This; // is obviously not ideal, but changing checker name has the consequence of; // changing the issue hashes associated with the reports, and databases; // relying on this (CodeChecker, for instance) would suffer greatly.; // If we ever end up making changes to the issue hash generation algorithm, or; // the warning messages here, we should totally jump on the opportunity to; // convert these to actual checkers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:882,message,messages,882,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,1,['message'],['messages']
Integrability,// These enumeration declarations were originally in MipsInstrInfo.h but; // had to be moved here to avoid circular dependencies between; // LLVMMipsCodeGen and LLVMMipsAsmPrinter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h:116,depend,dependencies,116,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h,1,['depend'],['dependencies']
Integrability,"// These functions change the specified standard stream (stdin or stdout) mode; // based on the Flags. They return errc::success if the specified stream was; // changed. Otherwise, a platform dependent error is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h:192,depend,dependent,192,interpreter/llvm-project/llvm/include/llvm/Support/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h,1,['depend'],['dependent']
Integrability,// These functions change the specified standard stream (stdin or stdout) to; // binary mode. They return errc::success if the specified stream; // was changed. Otherwise a platform dependent error is returned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h:182,depend,dependent,182,interpreter/llvm-project/llvm/include/llvm/Support/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h,1,['depend'],['dependent']
Integrability,// These instructions are sometimes used with an undef first or second; // source. Return true here so BreakFalseDeps will assign this source to the; // same register as the first source to avoid a false dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:204,depend,dependency,204,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['depend'],['dependency']
Integrability,// These instructions are sometimes used with an undef first or second; // source. Return true here so BreakFalseDeps will assign this source to the; // same register as the first source to avoid a false dependency.; // Operand 1 of these instructions is tied so they're separate from their; // VEX counterparts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:204,depend,dependency,204,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['depend'],['dependency']
Integrability,"// These intrinsics can read arbitrary memory, and additionally modref; // inaccessible memory to model control dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:112,depend,dependence,112,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// These live sets may contain state Value pointers, since we replaced calls; // with operand bundles with calls wrapped in gc.statepoint, and some of; // those calls may have been def'ing live gc pointers. Clear these out to; // avoid accidentally using them.; //; // TODO: We should create a separate data structure that does not contain; // these live sets, and migrate to using that data structure from this point; // onward.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:113,wrap,wrapped,113,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['wrap'],['wrapped']
Integrability,"// These methods return zero to indicate that they do not support; // this interface. See RooPlot::updateFitRangeNorm() for details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooEllipse.h:75,interface,interface,75,roofit/roofitcore/inc/RooEllipse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooEllipse.h,1,['interface'],['interface']
Integrability,"// These next two are very similar to the above, but also look through PHI; // nodes.; // TODO: See if we can integrate these two together.; /// If we can compute the length of the string pointed to by; /// the specified pointer, return 'len+1'. If we can't, return 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:110,integrat,integrate,110,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['integrat'],['integrate']
Integrability,"// These passes import type identifier resolutions for whole-program; // devirtualization and CFI. They must run early because other passes may; // disturb the specific instruction patterns that these passes look for,; // creating dependencies on resolutions that may not appear in the summary.; //; // For example, GVN may transform the pattern assume(type.test) appearing in; // two basic blocks into assume(phi(type.test, type.test)), which would; // transform a dependency on a WPD resolution into a dependency on a type; // identifier resolution for CFI.; //; // Also, WPD has access to more precise information than ICP and can; // devirtualize more effectively, so it should operate on the IR first.; //; // The WPD and LowerTypeTest passes need to run at -O0 to lower type; // metadata and intrinsics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:231,depend,dependencies,231,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,3,['depend'],"['dependencies', 'dependency']"
Integrability,"// These queries ask for a single size_t result for a given dimension index, e.g; // size_t get_global_id(uint dimindex). In SPIR-V, the builtins corresonding to; // these values are all vec3 types, so we need to extract the correct index or; // return defaultVal (0 or 1 depending on the query). We also handle extending; // or tuncating in case size_t does not match the expected result type's; // bitwidth.; //; // For a constant index >= 3 we generate:; // %res = OpConstant %SizeT 0; //; // For other indices we generate:; // %g = OpVariable %ptr_V3_SizeT Input; // OpDecorate %g BuiltIn XXX; // OpDecorate %g LinkageAttributes ""__spirv_BuiltInXXX""; // OpDecorate %g Constant; // %loadedVec = OpLoad %V3_SizeT %g; //; // Then, if the index is constant < 3, we generate:; // %res = OpCompositeExtract %SizeT %loadedVec idx; // If the index is dynamic, we generate:; // %tmp = OpVectorExtractDynamic %SizeT %loadedVec %idx; // %cmp = OpULessThan %bool %idx %const_3; // %res = OpSelect %SizeT %cmp %tmp %const_0; //; // If the bitwidth of %res does not match the expected return type, we add an; // extend or truncate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:272,depend,depending,272,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,1,['depend'],['depending']
Integrability,"// These tests check the generated wrapper functions that allow calling C++ functions.; // via C interface.; // Usually we only test that a wrapper function compiles correctly, but sometimes; // we also do some further checks on the wrapper here. See the specific assertions for more; // explanation on this.; // NOTE: This wrapper interface should be replaced in the future with a proper; // way of calling these functions that doesn't require parsing generated strings; // of C++ code, so if these tests fail because this interface was replaced by another; // system, feel free to delete them as these tests here don't represent things the user; // should do in his code.; // A class that creates a CallFunc and deletes it at the end of its scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingCallFuncTests.cxx:35,wrap,wrapper,35,core/metacling/test/TClingCallFuncTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingCallFuncTests.cxx,7,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"// These two functions are helper functions for; // TrailingObjects::getTrailingObjects. They recurse to the left --; // the result for each type in the list of trailing types depends on; // the result of calling the function on the type to the; // left. However, the function for the type to the left is; // implemented by a *subclass* of this class, so we invoke it via; // the TopTrailingObj, which is, via the; // curiously-recurring-template-pattern, the most-derived type in; // this recursion, and thus, contains all the overloads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h:176,depend,depends,176,interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h,1,['depend'],['depends']
Integrability,// These values are set when the size of the schedule window is limited; // due to chain dependences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:89,depend,dependences,89,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependences']
Integrability,// These vec_malloc/free routines are only available on AIX.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:25,rout,routines,25,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,1,['rout'],['routines']
Integrability,"// These will be modified in code below, but we need to preserve the original; // values in case we want to throw the generic message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:126,message,message,126,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['message'],['message']
Integrability,// Thin wrapper around preserveDebugSections to be used as a standalone plugin.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Debugging/DebugInfoSupport.h:8,wrap,wrapper,8,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Debugging/DebugInfoSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Debugging/DebugInfoSupport.h,1,['wrap'],['wrapper']
Integrability,"// Things such as CFTypeRef are really just opaque pointers; // to C structs representing CF types that can often be bridged; // to Objective-C objects. Since the compiler doesn't know which; // structs can be toll-free bridged, we just accept them all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp:117,bridg,bridged,117,interpreter/llvm-project/clang/lib/AST/FormatString.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp,2,['bridg'],['bridged']
Integrability,"// This RNG is guaranteed to produce the same random stream only; // when the Module ID and thus the input filename is the same. This; // might be problematic if the input filename extension changes; // (e.g. from .c to .bc or .ll).; //; // We could store this salt in NamedMetadata, but this would make; // the parameter non-const. This would unfortunately make this; // interface unusable by any Machine passes, since they only have a; // const reference to their IR Module. Alternatively we can always; // store salt metadata from the Module constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:372,interface,interface,372,interpreter/llvm-project/llvm/lib/IR/Module.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp,1,['interface'],['interface']
Integrability,"// This RooGenericPdf should behave exactly the same as the exponential, only; // that the integration will be done numerically.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testGenericPdf.cxx:91,integrat,integration,91,roofit/roofitcore/test/testGenericPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testGenericPdf.cxx,1,['integrat'],['integration']
Integrability,// This affects protocol buffer options specifications and text protos.; // Text protos are currently mostly formatted inside C++ raw string literals; // and often the current breaking behavior of string literals is not; // beneficial there. Investigate turning this on once proper string reflow; // has been implemented.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:16,protocol,protocol,16,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['protocol'],['protocol']
Integrability,// This attribute can only be applied to methods in interfaces or class; // extensions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:52,interface,interfaces,52,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['interface'],['interfaces']
Integrability,"// This can also print error messages, so we need to do it outside the lock",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TErrorDefaultHandler.cxx:29,message,messages,29,core/base/src/TErrorDefaultHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TErrorDefaultHandler.cxx,1,['message'],['messages']
Integrability,// This can be called from the ArchiveMemberHeader constructor when the; // archive header is truncated to produce an error message with the name.; // Make sure the name field is not truncated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp:124,message,message,124,interpreter/llvm-project/llvm/lib/Object/Archive.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp,1,['message'],['message']
Integrability,"// This can happen from recv if ppoll initially gets a read-ready signal for a socket,; // but the received data does not pass the checksum test, so the socket becomes unreadable; // again or from non-blocking send if the socket becomes unwritable either due to the HWM; // being reached or the socket not being connected (anymore). The latter case usually means; // the connection has been severed from the other side, meaning it has probably been killed; // and in that case the next ppoll call will probably also receive a SIGTERM, ending the; // loop. In case something else is wrong, this message will print multiple times, which; // should be taken as a cue for writing a bug report :)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/util.cxx:594,message,message,594,roofit/multiprocess/src/util.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/util.cxx,1,['message'],['message']
Integrability,// This can only be a message send. We're done with disambiguation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:22,message,message,22,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['message'],['message']
Integrability,"// This can't be done with ReplaceStmt(S, ThrowExpr), since; // the throw expression is typically a message expression that's already; // been rewritten! (which implies the SourceLocation's are invalid).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:100,message,message,100,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['message'],['message']
Integrability,// This castAs is safe: methods that don't return an object; // pointer won't be inferred as inits and will reject an explicit; // objc_method_family(init).; // We ignore protocols here. Should we? What about Class?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:171,protocol,protocols,171,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocols']
Integrability,"// This catchswitch has no parent to inherit constraints from, and; // none of its descendants can have an unwind edge that exits it and; // targets another funclet in the inlinee. It may or may not have a; // descendant that definitively has an unwind to caller. In either; // case, we'll have to assume that any unwinds out of it may need to; // be routed to the caller, so treat it as though it has a definitive; // unwind to caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:351,rout,routed,351,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['rout'],['routed']
Integrability,// This check is solely here to handle arbitrary target-dependent syncscopes.; // TODO: Can remove if does not matter in practice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:56,depend,dependent,56,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['depend'],['dependent']
Integrability,"// This check makes sure that the IV does not change sign during loop; // iterations. Consider latchType = i64, LatchStart = 5, Pred = ICMP_SGE,; // LatchEnd = 2, rangeCheckType = i32. If it's not a monotonic predicate, the; // IV wraps around, and the truncation of the IV would lose the range of; // iterations between 2^32 and 2^64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:231,wrap,wraps,231,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,1,['wrap'],['wraps']
Integrability,"// This checks for hazards associated with inline asm statements.; // Since inline asms can contain just about anything, we use this; // to call/leverage other check*Hazard routines. Note that; // this function doesn't attempt to address all possible inline asm; // hazards (good luck), but is a collection of what has been; // problematic thus far.; // see checkVALUHazards()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:173,rout,routines,173,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['rout'],['routines']
Integrability,"// This class defines the interface for the class registration and; // the TClass creation. To modify the default behavior, one would; // inherit from this class and overload ROOT::DefineBehavior().; // See TQObject.h and table/inc/Ttypes.h for examples.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/Rtypes.h:26,interface,interface,26,core/base/inc/Rtypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/Rtypes.h,1,['interface'],['interface']
Integrability,// This class extends ScheduleDAGInstrs and overrides the schedule method; // to build the dependence graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:91,depend,dependence,91,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,1,['depend'],['dependence']
Integrability,"// This class is intentionally packed into a 32b value as it is used as a; // MVT::i32 ConstantSDNode SDValue for SelectionDAG and as immediate operands; // on INLINEASM and INLINEASM_BR MachineInstr's.; //; // The encoding of Flag is currently:; // Bits 2-0 - A Kind::* value indicating the kind of the operand.; // (KindField); // Bits 15-3 - The number of SDNode operands associated with this inline; // assembly operand. Once lowered to MIR, this represents the; // number of MachineOperands necessary to refer to a; // MachineOperandType::MO_FrameIndex. (NumOperands); // Bit 31 - Determines if this is a matched operand. (IsMatched); // If bit 31 is set:; // Bits 30-16 - The operand number that this operand must match.; // (MatchedOperandNo); // Else if bits 2-0 are Kind::Mem:; // Bits 30-16 - A ConstraintCode:: value indicating the original; // constraint code. (MemConstraintCode); // Else:; // Bits 29-16 - The register class ID to use for the operand. (RegClass); // Bit 30 - If the register is permitted to be spilled.; // (RegMayBeFolded); // Defaults to false ""r"", may be set for constraints like; // ""rm"" (or ""g"").; //; // As such, MatchedOperandNo, MemConstraintCode, and; // (RegClass+RegMayBeFolded) are views of the same slice of bits, but are; // mutually exclusive depending on the fields IsMatched then KindField.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InlineAsm.h:1289,depend,depending,1289,interpreter/llvm-project/llvm/include/llvm/IR/InlineAsm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InlineAsm.h,1,['depend'],['depending']
Integrability,// This class just wraps StringTableBuilder for the purpose of adding a; // default constructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:19,wrap,wraps,19,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,1,['wrap'],['wraps']
Integrability,"// This class template specialization is a dependent; // type. Therefore, its canonical type is another class template; // specialization type that contains all of the converted; // arguments in canonical form. This ensures that, e.g., A<T> and; // A<T, T> have identical types when A is declared as:; //; // template<typename T, typename U = T> struct A;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:43,depend,dependent,43,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,// This class wraps any memcpy/memmove intrinsics; // i.e. llvm.element.unordered.atomic.memcpy/memmove; // and llvm.memcpy/memmove,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h:14,wrap,wraps,14,interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,1,['wrap'],['wraps']
Integrability,// This class wraps the atomic memcpy/memmove intrinsics; // i.e. llvm.element.unordered.atomic.memcpy/memmove,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h:14,wrap,wraps,14,interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,1,['wrap'],['wraps']
Integrability,"// This code is analoguous to that in CheckDerivedToBaseConversion, except; // that it builds the paths in reverse order.; // To sum up: record all paths to the base and build a nice string from; // them. Use it to spice up the error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:234,message,message,234,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['message'],['message']
Integrability,"// This code used to use ClassInfo_Has|IsValidMethod but since v6; // they return true if the routine is defined in the class or any of; // its parent. We explicitly want to know whether the function is; // defined locally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:94,rout,routine,94,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['rout'],['routine']
Integrability,"// This condition does not depend on predicates, no need to add users",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:27,depend,depend,27,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['depend'],['depend']
Integrability,"// This could be 32bit int or 64bit integer depending on the architecture.; // Cast it to 64bit integer value, if it is a 32bit integer ivar offset value; // as this is what caller always expects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:44,depend,depending,44,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['depend'],['depending']
Integrability,"// This declaration is a reference to an existing entity, but; // has different visibility from that entity: it either makes; // a friend visible or it makes a type visible in a new module.; // In either case, create a new declaration. We only do this if; // the declaration would have meant the same thing if no prior; // declaration were found, that is, if it was found in the same; // scope where we would have injected a declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:414,inject,injected,414,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['injected']
Integrability,// This depends on SmallVector::pop_back() not invalidating iterators.; // std::vector::pop_back() doesn't give that guarantee.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:8,depend,depends,8,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,1,['depend'],['depends']
Integrability,// This depends on previous transformations removing various expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp:8,depend,depends,8,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,1,['depend'],['depends']
Integrability,"// This depends on proper (de-)serialisation of proxies:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooExponential.cxx:8,depend,depends,8,roofit/roofit/test/testRooExponential.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooExponential.cxx,1,['depend'],['depends']
Integrability,// This doesn't depend on the ordering of the nodes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:16,depend,depend,16,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['depend'],['depend']
Integrability,// This doesn't use 'isIntegralType' despite the error message mentioning; // integral type because isIntegralType would also allow enum types in C.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:55,message,message,55,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['message'],['message']
Integrability,"// This end message was for the saved monitor; // Deactivate it if we are done with it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:12,message,message,12,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['message'],['message']
Integrability,// This enum has a dependent nested-name-specifier. Handle it as a; // dependent tag.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,depend,dependent,19,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['depend'],['dependent']
Integrability,"// This error message is repeated several times in the code. We write it once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:14,message,message,14,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['message'],['message']
Integrability,"// This exception specification doesn't make the type dependent, because; // it's not instantiated as part of instantiating the type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:54,depend,dependent,54,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['depend'],['dependent']
Integrability,// This exception specification indirectly depends on itself. Reject.; // FIXME: Corresponding rule in the standard?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:43,depend,depends,43,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['depend'],['depends']
Integrability,"// This expands into one of three sequences, depending on whether; // the first operand is odd or even, positive or negative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:45,depend,depending,45,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['depend'],['depending']
Integrability,"// This expr depends in any way on; // - a template parameter, it implies that the resolution of this expr may; // cause instantiation to fail; // - or an error (often in a non-template context); //; // Note that C++ standard doesn't define the instantiation-dependent term,; // we follow the formal definition coming from the Itanium C++ ABI, and; // extend it to errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:13,depend,depends,13,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,2,['depend'],"['dependent', 'depends']"
Integrability,"// This feature depends on RPageSinkBuf and the ability to issue a single `CommitSealedPageV()` call; thus, disable if; // ROOT was built with `-Dimt=OFF`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx:16,depend,depends,16,tree/ntuple/v7/test/ntuple_storage_daos.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx,1,['depend'],['depends']
Integrability,"// This field is set if this is a partial register write, and it has a false; // dependency on any previous write of the same register (or a portion of it).; // DependentWrite must be able to complete before this write completes, so; // that we don't break the WAW, and the two writes can be merged together.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:81,depend,dependency,81,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,2,"['Depend', 'depend']","['DependentWrite', 'dependency']"
Integrability,"// This field is set to true only if there are no dependent writes, and; // there are no `CyclesLeft' to wait.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:50,depend,dependent,50,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['depend'],['dependent']
Integrability,"// This field is updated on every writeStartEvent(). When the number of; // dependent writes (i.e. field DependentWrite) is zero, this value is; // propagated to field CyclesLeft.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:76,depend,dependent,76,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,2,"['Depend', 'depend']","['DependentWrite', 'dependent']"
Integrability,"// This file is used by Code Analysis to maintain SuppressMessage; // attributes that are applied to this project. Project-level; // suppressions either have no target or are given a specific target; // and scoped to a namespace, type, member, etc.; //; // To add a suppression to this file, right-click the message in the; // Error List, point to ""Suppress Message(s)"", and click ""In Project; // Suppression File"". You do not need to add suppressions to this; // file manually.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs:308,message,message,308,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs,2,"['Message', 'message']","['Message', 'message']"
Integrability,"// This full expression is not instantiation dependent or the variable; // can not be used in a constant expression - which means; // this variable must be odr-used here, so diagnose a; // capture violation early, if the variable is un-captureable.; // This is purely for diagnosing errors early. Otherwise, this; // error would get diagnosed when the lambda becomes capture ready.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:45,depend,dependent,45,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['depend'],['dependent']
Integrability,"// This function handles the high level operations of GNU objcopy including; // handling command line options. It's important to outline certain properties; // we expect to hold of the command line operations. Any operation that ""keeps""; // should keep regardless of a remove. Additionally any removal should respect; // any previous removals. Lastly whether or not something is removed shouldn't; // depend a) on the order the options occur in or b) on some opaque priority; // system. The only priority is that keeps/copies overrule removes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp:401,depend,depend,401,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp,1,['depend'],['depend']
Integrability,"// This function is deliberately left empty, because it is not used in; // PyROOT, and synchronizing it with cppyy-backend upstream would require; // patches to ROOT meta.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:87,synchroniz,synchronizing,87,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['synchroniz'],['synchronizing']
Integrability,"// This function is not supposed to be used with language specific; // address spaces. If that happens, the diagnostic message should consider; // printing the QualType instead of the address space value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:119,message,message,119,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['message'],['message']
Integrability,"// This function is the result of instantiating or; // specializing a member function of a class template,; // or a member function of a class member of a class template,; // or a member function template of a class template, or a; // member function template of a class member of a class; // template where at least some part of the function is; // dependent on a template argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx:350,depend,dependent,350,core/metacling/src/TClingCallFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx,2,['depend'],['dependent']
Integrability,"// This function maintains a map for the pairs <TOC Save Instr, Keep>; // Each time a new TOC save is encountered, it checks if any of the existing; // ones are dominated by the new one. If so, it marks the existing one as; // redundant by setting it's entry in the map as false. It then adds the new; // instruction to the map with either true or false depending on if any; // existing instructions dominated the new one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:354,depend,depending,354,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['depend'],['depending']
Integrability,"// This function tries to get the injected type from getTypeForDecl,; // then from the previous declaration if possible. If not, it creates; // a new type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:34,inject,injected,34,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['inject'],['injected']
Integrability,"// This function tries to set specified \p Placement for the \p Entry.; // Depending on the concrete entry, the placement could be:; // a) changed to another.; // b) joined with current entry placement.; // c) set as requested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp:75,Depend,Depending,75,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,1,['Depend'],['Depending']
Integrability,// This function will copy the injected type from D2CXX into Injected.; // The injected decl does not have a previous decl to copy from.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:31,inject,injected,31,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,3,"['Inject', 'inject']","['Injected', 'injected']"
Integrability,// This function wraps the ELFT writeELFBinaryToFile() so writeBinaryStub(); // can be called without having to use ELFType templates directly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:17,wrap,wraps,17,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,1,['wrap'],['wraps']
Integrability,"// This function writes the TGeneraticClassInfo initialiser; // and the auxiliary functions (new and delete wrappers) for; // each of the STL containers that have been registered",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/RStl.cxx:108,wrap,wrappers,108,core/clingutils/src/RStl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/RStl.cxx,1,['wrap'],['wrappers']
Integrability,"// This function's type depends on an incomplete tag type.; // Force conversion of all the relevant record types, to make sure; // we re-convert the FunctionType when appropriate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp:24,depend,depends,24,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp,1,['depend'],['depends']
Integrability,"// This handles ConstantDataArray and ConstantDataVector. Note that we; // compare the two raw data arrays, which might differ depending on the host; // endianness. This isn't a problem though, because the endiness of a module; // will affect the order of the constants, but this order is the same; // for a given input module and host platform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:127,depend,depending,127,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,1,['depend'],['depending']
Integrability,"// This handles null references from FieldRegions, for example:; // struct Wrapper { int &ref; };; // Wrapper w = { *(int *)0 };; // w.ref = 1;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:75,Wrap,Wrapper,75,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,2,['Wrap'],['Wrapper']
Integrability,"// This handles the following case:; // @interface NewI @end; // typedef NewI DeprI __attribute__((deprecated(""blah""))); // @interface SI : DeprI /* warn here */ @end",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:41,interface,interface,41,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['interface'],['interface']
Integrability,// This handles the following case:; //; // typedef int SuperClass;; // @interface MyClass : SuperClass {} @end; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:73,interface,interface,73,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['interface'],['interface']
Integrability,"// This has the same effect as calling TheStream.current_pos(),; // but that interface is private.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/circular_raw_ostream.h:77,interface,interface,77,interpreter/llvm-project/llvm/include/llvm/Support/circular_raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/circular_raw_ostream.h,1,['interface'],['interface']
Integrability,// This header exports all AST interfaces.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/AST.h:31,interface,interfaces,31,interpreter/llvm-project/clang/include/clang/AST/AST.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/AST.h,1,['interface'],['interfaces']
Integrability,"// This holds the offset value, when pruning the dependences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:49,depend,dependences,49,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,1,['depend'],['dependences']
Integrability,// This implementation and its interface do not have the same; // super class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,interface,interface,31,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['interface'],['interface']
Integrability,"// This interface is allowed to return nullptr on a missing symbol without; // diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp:8,interface,interface,8,interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,1,['interface'],['interface']
Integrability,"// This is a ""reference"" to a va_list; however, what exactly; // this means depends on how va_list is defined. There are two; // different kinds of va_list: ones passed by value, and ones; // passed by reference. An example of a by-value va_list is; // x86, where va_list is a char*. An example of by-ref va_list; // is x86-64, where va_list is a __va_list_tag[1]. For x86,; // we want this argument to be a char*&; for x86-64, we want; // it to be a __va_list_tag*.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:76,depend,depends,76,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['depend'],['depends']
Integrability,"// This is a bit of a hack because TargetLibraryInfo is a function pass.; // The DFSan pass would need to be refactored to be function pass oriented; // (like MSan is) in order to fit together nicely with TargetLibraryInfo.; // We need this check to prevent them from being instrumented, or wrapped.; // Match on name and number of arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:291,wrap,wrapped,291,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['wrap'],['wrapped']
Integrability,"// This is a callback that can be passed to a number of functions.; // It can be used to ignore non-critical errors (warnings), which is; // useful for dumpers, like llvm-readobj.; // It accepts a warning message string and returns a success; // when the warning should be ignored or an error otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:205,message,message,205,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,1,['message'],['message']
Integrability,"// This is a def of Reg. Remove corresponding entries from RegUnits, and; // update MI Height to consider the physreg dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:118,depend,dependencies,118,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['depend'],['dependencies']
Integrability,"// This is a flat memory operation that access both VMEM and LDS, so note it; // - it will require that both the VM and LGKM be flushed to zero if it is; // pending when a VM or LGKM dependency occurs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:183,depend,dependency,183,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['depend'],['dependency']
Integrability,"// This is a helper function used by the creation routines. It places NewAccess; // into the access and defs lists for a given basic block, at the given; // insertion point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:50,rout,routines,50,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['rout'],['routines']
Integrability,"// This is a kind of template name, but can never occur in a dependent; // scope (literal operators can only be declared at namespace scope).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:61,depend,dependent,61,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// This is a non-ClassDef(), complex function - it might depend on state; // and thus we'll need the runtime and cannot determine the result; // statically.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:57,depend,depend,57,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['depend'],['depend']
Integrability,"// This is a normal type template argument. Note, if the type template; // argument is an injected-class-name for a template, it has a dual nature; // and can be used as either a type or a template. We handle that in; // convertTypeTemplateArgumentToTemplate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:90,inject,injected-class-name,90,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['inject'],['injected-class-name']
Integrability,// This is a physical register dependency and it's impossible or; // expensive to copy the register. Make sure nothing that can; // clobber the register is scheduled between the predecessor and; // this node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:31,depend,dependency,31,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,2,['depend'],['dependency']
Integrability,"// This is a pretty light-weight wrapper function; //; // Take a fully configured measurement as well as; // one of its channels; //; // Return a workspace representing that channel; // Do this by first creating a vector of EstimateSummary's; // and this by configuring the workspace with any post-processing; // Get the channel's name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx:33,wrap,wrapper,33,roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,1,['wrap'],['wrapper']
Integrability,// This is a temporary option until we change the interface to this pass based; // on optimization level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:50,interface,interface,50,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,1,['interface'],['interface']
Integrability,"// This is a transient data member, so it is probably fine to not have; // access to its content. However let's no mark it as definitively setup,; // since another class might use this class for a persistent data member and; // in this case we really want the error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:266,message,message,266,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['message'],['message']
Integrability,"// This is a variant of from generic_parser_base::printOptionInfo. Sadly,; // it's not easy to make it more usable. We could get it to print these as; // options if we were a cl::opt and registered them, but lists don't have; // options, nor does the parser for std::string. The other mechanisms for; // options are global and would pollute the global namespace with our; // counters. Rather than go that route, we have just overridden the; // printing, which only a few things call anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DebugCounter.cpp:405,rout,route,405,interpreter/llvm-project/llvm/lib/Support/DebugCounter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DebugCounter.cpp,1,['rout'],['route']
Integrability,// This is a wrapper class around StringLiteral to support offsetted string; // literals as format strings. It takes the offset into account when returning; // the string and its length or the source locations to display notes correctly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:13,wrap,wrapper,13,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['wrap'],['wrapper']
Integrability,"// This is actually an interesting policy decision. We don't; // *have* to delay immediately here: we can do the full access; // calculation in the hope that friendship on some intermediate; // class will make the declaration accessible non-dependently.; // But that's not cheap, and odds are very good (note: assertion; // made without data) that the friend declaration will determine; // access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:241,depend,dependently,241,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['depend'],['dependently']
Integrability,"// This is an empty wrapper function. Get rid of it.; // We know that it didn't end up in the EE by design.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CheckEmptyTransactionTransformer.cpp:20,wrap,wrapper,20,interpreter/cling/lib/Interpreter/CheckEmptyTransactionTransformer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CheckEmptyTransactionTransformer.cpp,1,['wrap'],['wrapper']
Integrability,"// This is an in-class initialization for a static data member, e.g.,; //; // struct S {; // static const int value = 17;; // };; // C++ [class.mem]p4:; // A member-declarator can contain a constant-initializer only; // if it declares a static member (9.4) of const integral or; // const enumeration type, see 9.4.2.; //; // C++11 [class.static.data]p3:; // If a non-volatile non-inline const static data member is of integral; // or enumeration type, its declaration in the class definition can; // specify a brace-or-equal-initializer in which every initializer-clause; // that is an assignment-expression is a constant expression. A static; // data member of literal type can be declared in the class definition; // with the constexpr specifier; if so, its declaration shall specify a; // brace-or-equal-initializer in which every initializer-clause that is; // an assignment-expression is a constant expression.; // Do nothing on dependent types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:934,depend,dependent,934,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// This is an old (TNetFile,TFTP) client:; // send our protocol first ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:55,protocol,protocol,55,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['protocol'],['protocol']
Integrability,// This is correct even for INT_SMIN. Let's look at i8 to illustrate this:; // abs(INT_SMIN) = abs(-128) = abs(0x80) = -0x80 = 0x80 = 128.; // This equations hold true due to the well-defined wrap-around behavior of; // APInt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:192,wrap,wrap-around,192,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap-around']
Integrability,// This is different depending on the type of xray record. The naive format; // stores a Wallclock timespec. FDR logging stores the size of a thread; // buffer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:21,depend,depending,21,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,1,['depend'],['depending']
Integrability,"// This is dubious and is added to be compatible with gcc. In gcc, it is; // also allowed assigning a protocol-qualified 'id' type to a LHS object; // when protocol in qualified LHS is in list of protocols in the rhs 'id'; // object. This IMO, should be a bug.; // FIXME: Treat this as an extension, and flag this as an error when GCC; // extensions are not enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:102,protocol,protocol-qualified,102,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,3,['protocol'],"['protocol', 'protocol-qualified', 'protocols']"
Integrability,"// This is endian dependent, but it will only work on x86 anyway.; // FIXME: Will not trap if loading a signaling NaN.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:18,depend,dependent,18,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,1,['depend'],['dependent']
Integrability,"// This is essentially a reduced version of hasFP for entry functions. Since the; // stack pointer is known 0 on entry to kernels, we never really need an FP; // register. We may need to initialize the stack pointer depending on the frame; // properties, which logically overlaps many of the cases where an ordinary; // function would require an FP.; // Also used for chain functions. While not technically entry functions, chain; // functions may need to set up a stack pointer in some situations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:216,depend,depending,216,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['depend'],['depending']
Integrability,// This is expected to undergo unsigned wrapping since FunctionIndex is; // ~0 and that's where we start.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h:40,wrap,wrapping,40,interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,1,['wrap'],['wrapping']
Integrability,"// This is helper routine for loop directives (e.g., 'for', 'simd',; // 'for simd', etc.).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:18,rout,routine,18,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['rout'],['routine']
Integrability,"// This is in the injected scope, create a new declaration in; // that scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,inject,injected,18,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['injected']
Integrability,"// This is inaccurate. It depends on the instruction and address space. The; // only place where we should hit this is for dealing with frame indexes /; // private accesses, so this is correct in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:26,depend,depends,26,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['depend'],['depends']
Integrability,// This is just a MachO name translation routine and there's no; // way to join this into ARMTargetParser without breaking all; // other assumptions. Maybe MachO should consider standardising; // their nomenclature.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:41,rout,routine,41,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['rout'],['routine']
Integrability,// This is just the 'operator co_await' call inside the guts of a; // dependent co_await call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:70,depend,dependent,70,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['depend'],['dependent']
Integrability,"// This is kind of a silly class, hence why we keep it private to the file.; // It's only purpose is to wrap the real type record. I guess this is so that; // we can have the lexical parent point to the function instead of the global; // scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/NativeTypeFunctionSig.cpp:104,wrap,wrap,104,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/NativeTypeFunctionSig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/NativeTypeFunctionSig.cpp,1,['wrap'],['wrap']
Integrability,// This is mainly for function exit BB.; // The integrated tail duplication is really designed for increasing; // fallthrough from predecessors from Succ to its successors. We may need; // other machanism to handle different cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:48,integrat,integrated,48,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['integrat'],['integrated']
Integrability,"// This is not perfect, but as we're just verifying here, we can live with; // the loss of precision. The real solution would be that of doing strongly; // connected component finding in this routine, and it's probably not worth; // the complexity for the time being. So, we just keep a set of visited; // MemoryAccess and return true when we hit a cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:192,rout,routine,192,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['rout'],['routine']
Integrability,"// This is not the same as `VFS::getRealPath()`, which resolves symlinks; // but can be very expensive on real file systems.; // FIXME: the semantic of RealPathName is unclear, and the name might be; // misleading. We need to clean up the interface here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:239,interface,interface,239,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,1,['interface'],['interface']
Integrability,// This is only valid on protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:25,protocol,protocols,25,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocols']
Integrability,"// This is possible only if obj is actually a TInspectorObject; // wrapping a non-TObject.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TInspectCanvas.cxx:67,wrap,wrapping,67,graf2d/gpad/src/TInspectCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TInspectCanvas.cxx,1,['wrap'],['wrapping']
Integrability,// This is rather dubious but matches gcc's behavior. If lhs has; // no type qualifier and its class has no static protocol(s); // assume that it is mismatch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:115,protocol,protocol,115,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['protocol'],['protocol']
Integrability,// This is reachable only when constructing an outlined SEH finally; // block. Nothing depends on this mangling and it's used only with; // functinos with internal linkage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:87,depend,depends,87,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,1,['depend'],['depends']
Integrability,"// This is similar to the above case, but here we handle a scalar 64-bit; // integer store that is extracted from a vector on a 32-bit target.; // If we have SSE2, then we can treat it like a floating-point double; // to get past legalization. The execution dependencies fixup pass will; // choose the optimal machine instruction for the store if this really is; // an integer or v2f32 rather than an f64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:258,depend,dependencies,258,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['dependencies']
Integrability,"// This is the __NO_INLINE__ define, which just depends on things like the; // optimization level and -fno-inline, not actually whether the backend has; // inlining enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:48,depend,depends,48,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['depend'],['depends']
Integrability,"// This is the high-performance happy path, though getting here depends; // on the caller giving us a long enough input.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:64,depend,depends,64,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['depend'],['depends']
Integrability,"// This is the last chance we have of checking copy elision eligibility; // for functions in dependent contexts. The sema actions for building; // the return statement during template instantiation will have no effect; // regarding copy elision, since NRVO propagation runs on the scope exit; // actions, and these are not run on instantiation.; // This might run through some VarDecls which were returned from non-taken; // 'if constexpr' branches, and these will end up being constructed on the; // return slot even if they will never be returned, as a sort of accidental; // 'optimization'. Notably, functions with 'auto' return types won't have it; // deduced by this point. Coupled with the limitation described; // previously, this makes it very hard to support copy elision for these.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:93,depend,dependent,93,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['depend'],['dependent']
Integrability,"// This is the lower bound of places on the stack to check. It is equal to; // the place the last stack walk ended.; // Note: Correctness depends on this being initialized to 0, which densemap; // does",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:138,depend,depends,138,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['depend'],['depends']
Integrability,// This is the name of a routine to call to print the operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterInst.h:25,rout,routine,25,interpreter/llvm-project/llvm/utils/TableGen/AsmWriterInst.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterInst.h,1,['rout'],['routine']
Integrability,"// This is the same as getTemplateSpecializationKind(), except that for a; // function that is both a function template specialization and a member; // specialization, we prefer the member specialization information. Eg:; //; // template<typename T> struct A {; // template<typename U> void f() {}; // template<> void f<int>() {}; // };; //; // Within the templated CXXRecordDecl, A<T>::f<int> is a dependent function; // template specialization; both getTemplateSpecializationKind() and; // getTemplateSpecializationKindForInstantiation() will return; // TSK_ExplicitSpecialization.; //; // For A<int>::f<int>():; // * getTemplateSpecializationKind() will return TSK_ExplicitSpecialization; // * getTemplateSpecializationKindForInstantiation() will return; // TSK_ImplicitInstantiation; //; // This reflects the facts that A<int>::f<int> is an explicit specialization; // of A<int>::f, and that A<int>::f<int> should be implicitly instantiated; // from A::f<int> if a definition is needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:399,depend,dependent,399,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['depend'],['dependent']
Integrability,"// This is the second phase of vectorizing first-order recurrences. An; // overview of the transformation is described below. Suppose we have the; // following loop.; //; // for (int i = 0; i < n; ++i); // b[i] = a[i] - a[i - 1];; //; // There is a first-order recurrence on ""a"". For this loop, the shorthand; // scalar IR looks like:; //; // scalar.ph:; // s_init = a[-1]; // br scalar.body; //; // scalar.body:; // i = phi [0, scalar.ph], [i+1, scalar.body]; // s1 = phi [s_init, scalar.ph], [s2, scalar.body]; // s2 = a[i]; // b[i] = s2 - s1; // br cond, scalar.body, ...; //; // In this example, s1 is a recurrence because it's value depends on the; // previous iteration. In the first phase of vectorization, we created a; // vector phi v1 for s1. We now complete the vectorization and produce the; // shorthand vector IR shown below (for VF = 4, UF = 1).; //; // vector.ph:; // v_init = vector(..., ..., ..., a[-1]); // br vector.body; //; // vector.body; // i = phi [0, vector.ph], [i+4, vector.body]; // v1 = phi [v_init, vector.ph], [v2, vector.body]; // v2 = a[i, i+1, i+2, i+3];; // v3 = vector(v1(3), v2(0, 1, 2)); // b[i, i+1, i+2, i+3] = v2 - v3; // br cond, vector.body, middle.block; //; // middle.block:; // x = v2(3); // br scalar.ph; //; // scalar.ph:; // s_init = phi [x, middle.block], [a[-1], otherwise]; // br scalar.body; //; // After execution completes the vector loop, we extract the next value of; // the recurrence (x) to use as the initial value in the scalar loop.; // Extract the last vector element in the middle block. This will be the; // initial value for the recurrence when jumping to the scalar loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:638,depend,depends,638,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['depend'],['depends']
Integrability,"// This is the set of instructions to revisit on a reachability change. At; // the end of the main iteration loop it will contain at least all the phi of; // ops instructions that will be changed to phis, as well as regular phis.; // During the iteration loop, it may contain other things, such as phi of ops; // instructions that used edge reachability to reach a result, and so need to; // be revisited when the edge changes, independent of whether the phi they; // depended on changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:468,depend,depended,468,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['depend'],['depended']
Integrability,// This is used for both record definitions and ObjC interface declarations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:53,interface,interface,53,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['interface'],['interface']
Integrability,"// This is used for the type ""ptr_rc"", which is either IntRegs or I64Regs; // depending on SparcRegisterInfo::getPointerRegClass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Disassembler/SparcDisassembler.cpp:78,depend,depending,78,interpreter/llvm-project/llvm/lib/Target/Sparc/Disassembler/SparcDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Disassembler/SparcDisassembler.cpp,1,['depend'],['depending']
Integrability,"// This isn't a great error message, but this should never occur in real; // code anyway -- you'd have to create a buffer longer than a size_t can; // represent, which is sort of a contradiction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:28,message,message,28,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['message'],['message']
Integrability,// This isn't exactly right. We're using slow unaligned 32-byte accesses; // as a proxy for a double-pumped AVX memory interface such as on; // Sandybridge.; // Sub-32-bit loads/stores will be slower either with PINSR*/PEXTR* or; // will be scalarized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:119,interface,interface,119,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['interface'],['interface']
Integrability,"// This item may depend on multiple instructions, complicating any; // potential sink. This block takes the defensive approach, opting to; // ""undef"" the item if it has more than one instruction and any of them do; // not dominate iem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:17,depend,depend,17,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['depend'],['depend']
Integrability,"// This latency applies to Pentium M, Merom, Wolfdale, Nehalem, and Sandy; // Bridge. Probably Ivy Bridge as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:78,Bridg,Bridge,78,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,2,['Bridg'],['Bridge']
Integrability,"// This may insert new phi nodes, because we are not guaranteed the; // block we are processing has a single pred, and depending where the; // store was inserted, it may require phi nodes below it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:119,depend,depending,119,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['depend'],['depending']
Integrability,"// This message is sent from a worker that finished processing.; // We determine whether it was asked to finish by the; // packetizer or stopped during processing a packet; // (by TProof::RemoveWorkers() or by an external signal).; // In the later case call packetizer->MarkBad.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:8,message,message,8,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['message'],['message']
Integrability,"// This message resumes the session; should not come during processing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:8,message,message,8,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['message']
Integrability,"// This message was for the base monitor in recursive case",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:8,message,message,8,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['message'],['message']
Integrability,// This method adds Use to the set of data dependent reads. IID is the; // instruction identifier associated with this write. ReadAdvance is the; // number of cycles to subtract from the latency of this data dependency.; // Use is in a RAW dependency with this write.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:43,depend,dependent,43,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,3,['depend'],"['dependency', 'dependent']"
Integrability,"// This method creates the following nodes, which are necessary for; // computing a global symbol's address in large-GOT mode:; //; // (load (wrapper (add %hi(sym), $gp), %lo(sym)))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:142,wrap,wrapper,142,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,1,['wrap'],['wrapper']
Integrability,"// This method creates the following nodes, which are necessary for; // computing a global symbol's address:; //; // (load (wrapper $gp, %got(sym)))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:124,wrap,wrapper,124,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,1,['wrap'],['wrapper']
Integrability,"// This method creates the following nodes, which are necessary for; // computing a local symbol's address:; //; // (add (load (wrapper $gp, %got(sym)), %lo(sym))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:128,wrap,wrapper,128,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,1,['wrap'],['wrapper']
Integrability,"// This method tries to turn a variable array into a constant; // array even when the size isn't an ICE. This is necessary; // for compatibility with code that depends on gcc's buggy; // constant expression folding, like struct {char x[(int)(char*)2];}",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:160,depend,depends,160,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['depends']
Integrability,"// This might be worth an error message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMemberInspector.cxx:32,message,message,32,core/base/src/TMemberInspector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMemberInspector.cxx,1,['message'],['message']
Integrability,"// This might get called recursively, or a billion of times. Do not generate; // useless output; unresolvedSymbol() is always handed out with an error; // message - that's enough.; //cling::errs() << ""IncrementalExecutor: calling unresolved symbol, ""; // ""see previous error message!\n"";; // throw exception instead?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp:155,message,message,155,interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp,2,['message'],['message']
Integrability,"// This might possibly be a type with a dependent scope specifier and; // a missing 'typename' keyword. Don't use TryAnnotateName in this case,; // since it will annotate as a primary expression, and we want to use the; // ""missing 'typename'"" logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:40,depend,dependent,40,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['depend'],['dependent']
Integrability,"// This might seem conter-intuitive at first glance, but the functions are; // closely related. Reasoning about destructors depends only on the type; // of the expression that initialized the memory region, which is the; // CXXConstructExpr. So to avoid code repetition, the work is delegated; // to the function that reasons about destructor inlining. Also note that; // if the constructors of the array elements are inlined, the destructors; // can also be inlined and if the destructors can be inline, it's safe to; // inline the constructors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:124,depend,depends,124,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['depend'],['depends']
Integrability,"// This might work out to be a current instantiation, in which; // case the canonical type needs to be the InjectedClassNameType.; //; // TODO: in theory this could be a simple hashtable lookup; most; // changes to CurContext don't change the set of current; // instantiations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:107,Inject,InjectedClassNameType,107,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Inject'],['InjectedClassNameType']
Integrability,"// This mode implements more precise float in terms of two APFloats.; // The interface and layout is designed for arbitrary underlying semantics,; // though currently only PPCDoubleDouble semantics are supported, whose; // corresponding underlying semantics are IEEEdouble.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:77,interface,interface,77,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,1,['interface'],['interface']
Integrability,"// This must be an instruction because we are only called from phi nodes; // in the case that the value it needs to check against is an instruction.; // The most likely candidates for dominance are the leader and the next leader.; // The leader or nextleader will dominate in all cases where there is an; // equivalent that is higher up in the dom tree.; // We can't *only* check them, however, because the; // dominator tree could have an infinite number of non-dominating siblings; // with instructions that are in the right congruence class.; // A; // B C D E F G; // |; // H; // Instruction U could be in H, with equivalents in every other sibling.; // Depending on the rpo order picked, the leader could be the equivalent in; // any of these siblings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:657,Depend,Depending,657,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['Depend'],['Depending']
Integrability,"// This must happen BEFORE restoring dependents, otherwise no dirty state propagation in restore step",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:37,depend,dependents,37,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['depend'],['dependents']
Integrability,// This name cannot possibly name a dependent template. Diagnose this now; // rather than building a dependent template name that can never be valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:36,depend,dependent,36,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,['depend'],['dependent']
Integrability,"// This namespace provides all the routines necessary for checking if a number; // is a NaN also in presence of optimisations affecting the behaviour of the; // floating point calculations.; // Inspired from the CMSSW FWCore/Utilities package",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/TMath.h:35,rout,routines,35,math/mathcore/inc/TMath.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/TMath.h,1,['rout'],['routines']
Integrability,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp:86,depend,depend,86,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,15,['depend'],['depend']
Integrability,"// This needs to be done very early, since everything that writes; // SourceLocations or FileIDs depends on it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:97,depend,depends,97,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['depend'],['depends']
Integrability,"// This object wraps TGLPhysicalShape (not a TObject)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLPShapeObj.h:15,wrap,wraps,15,graf3d/gl/inc/TGLPShapeObj.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLPShapeObj.h,1,['wrap'],['wraps']
Integrability,// This only depends on powers of 2 because we use bit tricks to figure out; // the bit offset we need to shift to get the target element. A general; // expansion could emit division/multiply.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:13,depend,depends,13,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,2,['depend'],['depends']
Integrability,// This partial write has a false dependency on RenameAs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp:34,depend,dependency,34,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,1,['depend'],['dependency']
Integrability,"// This pass can create copies between registers that don't have the; // exact same values. Updating the tracker has to involve updating; // all dependent cells. Example:; // %1 = inst %2 ; %1 != %2, but used bits are equal; //; // %3 = copy %2 ; <- inserted; // ... = %3 ; <- replaced from %2; // Indirectly, we can create a ""copy"" between %1 and %2 even; // though their exact values do not match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:145,depend,dependent,145,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,1,['depend'],['dependent']
Integrability,// This pass is the current implementation of all of the interfaces it; // implements as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:57,interface,interfaces,57,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['interface'],['interfaces']
Integrability,"// This read may be dependent on more than one write. This typically occurs; // when a definition is the result of multiple writes where at least one; // write does a partial register update.; // The HW is forced to do some extra bookkeeping to track of all the; // dependent writes, and implement a merging scheme for the partial writes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp:20,depend,dependent,20,interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp,2,['depend'],['dependent']
Integrability,"// This relies on two's complement wraparound when N == 64, so we convert to; // int64_t only at the very end to avoid UB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h:35,wrap,wraparound,35,interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,1,['wrap'],['wraparound']
Integrability,"// This resets the lists to avoid the problem fixed in protocol 33",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofNodes.cxx:55,protocol,protocol,55,proof/proofbench/src/TProofNodes.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofNodes.cxx,1,['protocol'],['protocol']
Integrability,"// This routine also takes the intersection of C1 and C2, but it does so by; // altering the VarDefinitions. C1 must be the result of an earlier call to; // createReferenceContext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:8,rout,routine,8,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,1,['rout'],['routine']
Integrability,"// This routine assumes that the range begin/end matches the regex for integer; // and FP constants (specifically, the 'pp-number' regex), and assumes that; // the byte at ""*end"" is both valid and not part of the regex. Because of; // this, it doesn't have to check for 'overscan' in various places.; // Note: For HLSL, the end token is allowed to be '.' which would be in the; // 'pp-number' regex. This is required to support vector swizzles on numeric; // constants (i.e. 1.xx or 1.5f.rrr).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:8,rout,routine,8,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['rout'],['routine']
Integrability,"// This routine could be enhanced to also support:; //; // testAlloc: if true, we test allocator, if it is not default result is negative; // result: 0 : not stl container; // abs(result): code of container 1=vector,2=list,3=deque,4=map; // 5=multimap,6=set,7=multiset; // positive val: we have a vector or list with default allocator to any depth; // like vector<list<vector<int>>>; // negative val: STL container other than vector or list, or non default allocator; // For example: vector<deque<int>> has answer -1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:8,rout,routine,8,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['rout'],['routine']
Integrability,"// This routine creates the edge table for; // scan converting polygons.; // The Edge Table (ET) looks like:; //; // EdgeTable; // --------; // | ymax | ScanLineLists; // |scanline|-->------------>-------------->...; // -------- |scanline| |scanline|; // |edgelist| |edgelist|; // --------- ---------; // | |; // | |; // V V; // list of ETEs list of ETEs; //; // where ETE is an EdgeTableEntry data structure,; // and there is one ScanLineList per scanline at; // which an edge is initially entered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPolyUtils.c:8,rout,routine,8,graf2d/asimage/src/TASPolyUtils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPolyUtils.c,1,['rout'],['routine']
Integrability,"// This routine does not expect to deal with volatile instructions.; // Doing so would require piping through the QueryInst all the way through.; // TODO: volatiles can't be elided, but they can be reordered with other; // non-volatile accesses.; // We currently give up on any instruction which is ordered, but we do handle; // atomic instructions which are unordered.; // TODO: Handle ordered instructions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:8,rout,routine,8,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['rout'],['routine']
Integrability,"// This routine is called for @protocol only. So, we must build definition; // of protocol's meta-data (not a reference to it!)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:8,rout,routine,8,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,3,"['protocol', 'rout']","['protocol', 'routine']"
Integrability,"// This routine is meant to be called (indirectly) by dlclose so we; // we are guaranteed that the library initialization has completed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx:8,rout,routine,8,core/cont/src/TClassTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx,1,['rout'],['routine']
Integrability,// This routine is only called for variable references.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h:8,rout,routine,8,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,1,['rout'],['routine']
Integrability,// This routine is only handling x86 targets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp:8,rout,routine,8,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp,1,['rout'],['routine']
Integrability,// This routine is used by lowerTypeClass and lowerTypeUnion to determine; // if a complete type should be emitted instead of a forward reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:8,rout,routine,8,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['rout'],['routine']
Integrability,"// This routine is used to load fields one-by-one to perform a copy, so; // don't load reference fields.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:8,rout,routine,8,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['rout'],['routine']
Integrability,"// This routine moves EdgeTableEntries from the; // EdgeTable into the Active Edge Table,; // leaving them sorted by smaller x coordinate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPolyUtils.c:8,rout,routine,8,graf2d/asimage/src/TASPolyUtils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPolyUtils.c,1,['rout'],['routine']
Integrability,"// This routine must always return a class definition, if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:8,rout,routine,8,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['rout'],['routine']
Integrability,// This routine must enter the loop below to work correctly; // when (Reciprocal == false).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:8,rout,routine,8,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['rout'],['routine']
Integrability,// This routine only handles 128-bit shufps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:8,rout,routine,8,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['rout'],['routine']
Integrability,// This routine only supports 128-bit integer dual input vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:8,rout,routine,8,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['rout'],['routine']
Integrability,// This routine performs a basic correctness check. This routine should only; // be called when we know that 'IR' is not in the scheduler's instruction; // queues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:8,rout,routine,8,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,2,['rout'],['routine']
Integrability,"// This routine returns a DeclGroup, if the thing we parsed only contains a; // single decl, convert it now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:8,rout,routine,8,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['rout'],['routine']
Integrability,"// This scheduler implements a different scheduling algorithm than; // GenericScheduler.; //; // There are several specific architecture behaviours that can't be modelled; // for GenericScheduler:; // . When accessing the result of an SGPR load instruction, you have to wait; // for all the SGPR load instructions before your current instruction to; // have finished.; // . When accessing the result of an VGPR load instruction, you have to wait; // for all the VGPR load instructions previous to the VGPR load instruction; // you are interested in to finish.; // . The less the register pressure, the best load latencies are hidden; //; // Moreover some specifities (like the fact a lot of instructions in the shader; // have few dependencies) makes the generic scheduler have some unpredictable; // behaviours. For example when register pressure becomes high, it can either; // manage to prevent register pressure from going too high, or it can; // increase register pressure even more than if it hadn't taken register; // pressure into account.; //; // Also some other bad behaviours are generated, like loading at the beginning; // of the shader a constant in VGPR you won't need until the end of the shader.; //; // The scheduling problem for SI can distinguish three main parts:; // . Hiding high latencies (texture sampling, etc); // . Hiding low latencies (SGPR constant loading, etc); // . Keeping register usage low for better latency hiding and general; // performance; //; // Some other things can also affect performance, but are hard to predict; // (cache usage, the fact the HW can issue several instructions from different; // wavefronts if different types, etc); //; // This scheduler tries to solve the scheduling problem by dividing it into; // simpler sub-problems. It divides the instructions into blocks, schedules; // locally inside the blocks where it takes care of low latencies, and then; // chooses the order of the blocks by taking care of high latencies.; // Dividing the ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:731,depend,dependencies,731,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['depend'],['dependencies']
Integrability,// This set of folds is intentionally placed after folds that use no-wrapping; // flags because those folds are likely better for later analysis/codegen.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:69,wrap,wrapping,69,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['wrap'],['wrapping']
Integrability,"// This should be 'tool' dependant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLEventHandler.cxx:25,depend,dependant,25,graf3d/gl/src/TGLEventHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLEventHandler.cxx,1,['depend'],['dependant']
Integrability,"// This should not be moved earlier, since its initialization depends on some; // of the previous reference members being already initialized",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.h:62,depend,depends,62,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.h,1,['depend'],['depends']
Integrability,"// This should not be moved earlier, since its initialization depends on some; // of the previous reference members being already initialized and also checks; // if TheTargetCodeGenInfo is NULL",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:62,depend,depends,62,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['depend'],['depends']
Integrability,"// This should read ROOT::Math::Integration::kGAUSS21, but this is in MathMore, so we cannot include it here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:32,Integrat,Integration,32,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['Integrat'],['Integration']
Integrability,"// This technique allows you to project a finite width slice in a real-valued observable; ///; /// <tr><td> `NumCPU(Int_t ncpu)` <td> Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData); ///; ///; /// <tr><th><th> Misc content control; /// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per curve. A negative; /// value suppress output completely, a zero value will only print the error count per p.d.f component,; /// a positive value is will print details of each error up to numErr messages per p.d.f component.; ///; /// <tr><td> `EvalErrorValue(double value)` <td> Set curve points at which (pdf) evaluation errors occur to specified value. By default the; /// function value is plotted.; ///; /// <tr><td> `Normalization(double scale, ScaleType code)` <td> Adjust normalization by given scale factor. Interpretation of number depends on code:; /// - Relative: relative adjustment factor for a normalized function,; /// - NumEvent: scale to match given number of events.; /// - Raw: relative adjustment factor for an un-normalized function.; ///; /// <tr><td> `Name(const chat* name)` <td> Give curve specified name in frame. Useful if curve is to be referenced later; ///; /// <tr><td> `Asymmetry(const RooCategory& c)` <td> Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; /// the PDF projection. Category must have two states with indices -1 and +1 or three states with; /// indices -1,0 and +1.; ///; /// <tr><td> `ShiftToZero(bool flag)` <td> Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when plotting \f$ -\log(L) \f$ or \f$ \chi^2 \f$ distributions; ///; /// <tr><td> `AddTo(const char* name, double_t wgtSelf, double_t wgtOther)` <td> Add constructed projection to already existing curve with given name and relative weight factors; /// <tr><td> `Components(const char* names)` <td> When plo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:3885,depend,depends,3885,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['depend'],['depends']
Integrability,"// This template is explicitly instantiated in the implementation file for all; // supported types. The method itself is ugly, so inlining it into the header; // file clutters an otherwise straightforward interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/ContinuationRecordBuilder.h:205,interface,interface,205,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/ContinuationRecordBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/ContinuationRecordBuilder.h,2,['interface'],['interface']
Integrability,"// This test has been disabled in favor of the pub-sub connection check in the Messenger ctor, which is more robust",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Messenger.cxx:47,pub-sub,pub-sub,47,roofit/multiprocess/test/test_Messenger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Messenger.cxx,1,['pub-sub'],['pub-sub']
Integrability,"// This tests the analytical integration of RooParamHistFunc,; // inspired by this issue on GitHub:; // https://github.com/root-project/root/issues/7182",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooParamHistFunc.cxx:29,integrat,integration,29,roofit/roofit/test/testRooParamHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooParamHistFunc.cxx,1,['integrat'],['integration']
Integrability,"// This tests the analytical integration of RooParamHistFunc; // after the RooParamHistFunc has been cloned.; // The test was inspired by this error reported on the forum:; // https://root-forum.cern.ch/t/barlow-beeston-in-subrange/43909/5",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooParamHistFunc.cxx:29,integrat,integration,29,roofit/roofit/test/testRooParamHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooParamHistFunc.cxx,1,['integrat'],['integration']
Integrability,"// This token is injected to represent the translation of '#include ""a.h""'; // into ""import a.h;"". Mimic the notional ';'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:17,inject,injected,17,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['inject'],['injected']
Integrability,"// This type is designed to be compatible with NSConstantString, but cannot; // use the same name, since NSConstantString is an interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:128,interface,interface,128,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['interface'],['interface']
Integrability,"// This union is to avoid a warning message:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooCFunction1Binding.h:36,message,message,36,roofit/roofit/inc/RooCFunction1Binding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooCFunction1Binding.h,6,['message'],['message']
Integrability,"// This version of error() prints the archive name and member name, for example:; // ""libx.a(foo.o)"" after the ToolName before the error message. It sets; // HadError but returns allowing the code to move on to other archive members.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:137,message,message,137,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,2,['message'],['message']
Integrability,"// This version of error() prints the file name and which architecture slice it // is from, for example: ""foo.o (for architecture i386)"" after the ToolName; // before the error message. It sets HadError but returns allowing the code to; // move on to other architecture slices.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-size/llvm-size.cpp:177,message,message,177,interpreter/llvm-project/llvm/tools/llvm-size/llvm-size.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-size/llvm-size.cpp,1,['message'],['message']
Integrability,"// This version of error() prints the file name and which architecture slice it; // is from, for example: ""foo.o (for architecture i386)"" after the ToolName; // before the error message. It sets HadError but returns allowing the code to; // move on to other architecture slices.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:178,message,message,178,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,1,['message'],['message']
Integrability,// This will generate an error message,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:31,message,message,31,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,4,['message'],['message']
Integrability,"// This word does not fit on the current line, so wrap to the next; // line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:50,wrap,wrap,50,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,1,['wrap'],['wrap']
Integrability,"// This would inject an emprt parameter pack, which is a good default.; // But for cases where instantiation fails, this hits bug in unloading; // of the failed instantiation, causing a missing symbol in subsequent; // transactions where a Decl instantiated by the failed instatiation; // is not re-emitted. So for now just give up default-instantiating; // templates with parameter packs, even if this is simply a work-around.; //defaultTemplateArgs.emplace_back(ArrayRef<TemplateArgument>{}); // empty pack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx:14,inject,inject,14,core/metacling/src/TClingMethodInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx,1,['inject'],['inject']
Integrability,"// This wrapper class allow to avoid putting #include <map> in the; // TROOT.h header file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx:8,wrap,wrapper,8,core/cont/src/TClassTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx,2,['wrap'],['wrapper']
Integrability,// This wrapper requires 32bit disp/imm field for Medium CM,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:8,wrap,wrapper,8,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,1,['wrap'],['wrapper']
Integrability,"// This wraps a const Loop * into the iterator, so we know which edges to; // filter out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:8,wrap,wraps,8,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,1,['wrap'],['wraps']
Integrability,"// This wraps a set of Nodes into the iterator, so we know which edges to; // filter out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:8,wrap,wraps,8,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,1,['wrap'],['wraps']
Integrability,// This wraps the Uncategorizing and Categorizing printers and decides; // at run time which should be invoked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp:8,wrap,wraps,8,interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,1,['wrap'],['wraps']
Integrability,// Three cases. This is a message send to a type: [type foo]; // This is a message send to super: [super foo]; // This is a message sent to an expr: [super.bar foo],MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:26,message,message,26,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,3,['message'],['message']
Integrability,// Throws either one of our exception or a native C++ exception depending; // on a runtime argument value containing a type info type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:64,depend,depending,64,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,1,['depend'],['depending']
Integrability,"// Thumb1 instructions don't have explicit S bits. Rather, they; // implicitly set CPSR. Since it's not represented in the encoding, the; // auto-generated decoder won't inject the CPSR operand. We need to fix; // that as a post-pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:170,inject,inject,170,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,1,['inject'],['inject']
Integrability,"// Thumb1: depending on immediate size, use either; // ADDS NewBase, Base, #imm3; // or; // MOV NewBase, Base; // ADDS NewBase, #imm8.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:11,depend,depending,11,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['depend'],['depending']
Integrability,"// To ""insert"" Select_* instructions, we actually have to insert the triangle; // control-flow pattern. The incoming instructions know the destination vreg; // to set, the condition code register to branch on, the true/false values to; // select between, and the condcode to use to select the appropriate branch.; //; // We produce the following control flow:; // HeadMBB; // | \; // | IfFalseMBB; // | /; // TailMBB; //; // When we find a sequence of selects we attempt to optimize their emission; // by sharing the control flow. Currently we only handle cases where we have; // multiple selects with the exact same condition (same LHS, RHS and CC).; // The selects may be interleaved with other instructions if the other; // instructions meet some requirements we deem safe:; // - They are not pseudo instructions.; // - They are debug instructions. Otherwise,; // - They do not have side-effects, do not access memory and their inputs do; // not depend on the results of the select pseudo-instructions.; // The TrueV/FalseV operands of the selects cannot depend on the result of; // previous selects in the sequence.; // These conditions could be further relaxed. See the X86 target for a; // related approach and more information.; //; // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)); // is checked here and handled by a separate function -; // EmitLoweredCascadedSelect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:949,depend,depend,949,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['depend'],['depend']
Integrability,"// To address a limitation of the current GVN, we need to rerun the; // hoisting after we hoisted loads or stores in order to be able to; // hoist all scalars dependent on the hoisted ld/st.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:159,depend,dependent,159,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['depend'],['dependent']
Integrability,"// To always print messages that have no level specified...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MsgLogger.cxx:19,message,messages,19,tmva/tmva/src/MsgLogger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MsgLogger.cxx,1,['message'],['messages']
Integrability,"// To avoid breaking dependences, vectorized instructions of an interleave; // group should be inserted at either the first load or the last store in; // program order.; //; // E.g. %even = load i32 // Insert Position; // %add = add i32 %even // Use of %even; // %odd = load i32; //; // store i32 %even; // %odd = add i32 // Def of %odd; // store i32 %odd // Insert Position",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:21,depend,dependences,21,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['depend'],['dependences']
Integrability,"// To avoid depending on the order of slices, Ty and TyIsCommon must not; // depend on types skipped above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:12,depend,depending,12,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,2,['depend'],"['depend', 'depending']"
Integrability,"// To avoid join/split of directory+filename, the integrated assembler prefers; // the directory form of .file on all DWARF versions. GNU as doesn't allow the; // form before DWARF v5.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:50,integrat,integrated,50,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['integrat'],['integrated']
Integrability,"// To avoid unnecessary dependence on nlohman json in the interface. Note that; // we should not forward declare nlohmann::json directly, since its declaration; // might change (it is currently a typedef). With this wrapper type, we are; // completely decoupled on nlohmann::json in the RMetaData interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/inc/RooFit/MultiProcess/HeatmapAnalyzer.h:24,depend,dependence,24,roofit/multiprocess/inc/RooFit/MultiProcess/HeatmapAnalyzer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/inc/RooFit/MultiProcess/HeatmapAnalyzer.h,8,"['depend', 'interface', 'wrap']","['dependence', 'interface', 'wrapper']"
Integrability,"// To build the package we execute PROOF-INF/BUILD.sh via a pipe; // so that we can send back the log in (almost) real-time to the; // (impatient) client. Note that this operation will block, so; // the messages from builds on the workers will reach the client; // shortly after the master ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TPackMgr.cxx:203,message,messages,203,proof/proof/src/TPackMgr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TPackMgr.cxx,1,['message'],['messages']
Integrability,"// To determine the ""true"" side of the select, we need to know the high bit; // of the value returned by the setcc if it evaluates to true.; // If the type of the setcc is i1, then the true case of the select is just; // sext(i1 1), that is, -1.; // If the type of the setcc is larger (say, i8) then the value of the high; // bit depends on getBooleanContents(), so ask TLI for a real ""true"" value; // of the appropriate width.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:330,depend,depends,330,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['depends']
Integrability,"// To do the 'conservative' version, we would need to do some; // intervention here. We would probably need to create a different; // ParamHistFunc for each sample in the channel. The would nominally; // use the same gamma's, so we haven't increased the number of parameters; // However, if a bin in the 'nominal' histogram is 0, we simply need to; // change the parameter in that bin in the ParamHistFunc for this sample.; // We also need to add a constraint term.; // Actually, we'd probably not use the ParamHistFunc...?; // we could remove the dependence in this ParamHistFunc on the ith gamma; // and then create the poisson term: Pois(tau | n_exp)Pois(data | n_exp); // Next, try to get the common ParamHistFunc (it may have been; // created by another sample in this channel); // or create it if it doesn't yet exist:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx:548,depend,dependence,548,roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,1,['depend'],['dependence']
Integrability,// To emit type record using Codeview MCStreamer adapter,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:49,adapter,adapter,49,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['adapter'],['adapter']
Integrability,"// To focus on basic collection protocol, this sample program uses; // simple classes inheriting from TObject. One class, TObjString, is a; // collectable string class (a TString wrapped in a TObject) provided; // by the ROOT system. The other class we define below, is an integer; // wrapped in a TObject, just like TObjString.; // TObjNum is a simple container for an integer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/tcollex.cxx:32,protocol,protocol,32,test/tcollex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/tcollex.cxx,3,"['protocol', 'wrap']","['protocol', 'wrapped']"
Integrability,"// To make the exception handling table become more compact, ARM defined; // several personality routines in EHABI. There are 3 different; // personality routines in ARM EHABI currently. It is possible to have 16; // pre-defined personality routines at most.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ARMEHABI.h:97,rout,routines,97,interpreter/llvm-project/llvm/include/llvm/Support/ARMEHABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ARMEHABI.h,3,['rout'],['routines']
Integrability,"// To read the 64-bit cycle CSR on a 32-bit target, we read the two halves.; // Should the count have wrapped while it was being read, we need to try; // again.; // ...; // read:; // rdcycleh x3 # load high word of cycle; // rdcycle x2 # load low word of cycle; // rdcycleh x4 # load high word of cycle; // bne x3, x4, read # check if high word reads match, otherwise try again; // ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:102,wrap,wrapped,102,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['wrap'],['wrapped']
Integrability,"// To read the 64-bit time-base register on a 32-bit target, we read the; // two halves. Should the counter have wrapped while it was being read, we; // need to try again.; // ...; // readLoop:; // mfspr Rx,TBU # load from TBU; // mfspr Ry,TB # load from TB; // mfspr Rz,TBU # load from TBU; // cmpw crX,Rx,Rz # check if 'old'='new'; // bne readLoop # branch if they're not equal; // ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:113,wrap,wrapped,113,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['wrap'],['wrapped']
Integrability,"// To remove the INFO:NumericIntegration output from the stressRooFit output,; // change the message level locally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:93,message,message,93,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['message'],['message']
Integrability,"// To remove the need for index wrapping, double the permutation table length",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:32,wrap,wrapping,32,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['wrap'],['wrapping']
Integrability,"// To replace the top/bottom half of vector V with vector SubV we widen the; // preserved half of V, concatenate this to SubV (the order depending on the; // half being replaced) and then narrow the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:137,depend,depending,137,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['depend'],['depending']
Integrability,"// To signal to the text printer that a certain text needs to be bolded,; // a special character is injected into the character stream which the; // text printer will later strip out.; /// Bold - Start bolding text.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:100,inject,injected,100,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,1,['inject'],['injected']
Integrability,"// To silence the numeric integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/test/testRooFitHS3.cxx:26,integrat,integration,26,roofit/hs3/test/testRooFitHS3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/test/testRooFitHS3.cxx,2,['integrat'],['integration']
Integrability,// To support shrink-wrapping we would need to insert the new blocks; // at the right place and update the branches to PrologueMBB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:21,wrap,wrapping,21,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,2,['wrap'],['wrapping']
Integrability,"// To synchronize with the 'paging'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:6,synchroniz,synchronize,6,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,1,['synchroniz'],['synchronize']
Integrability,"// To update r = r - c * m, it suffices to know c * (-2 ** 240 + 1); // because the 2 ** 576 will cancel out. Also note that c may be zero, but; // the operation is still performed to avoid branching.; // c * (-2 ** 240 + 1) in 576 bits looks as follows, depending on c:; // - if c = 0, the number is zero.; // - if c = 1: bits 576 to 240 are set,; // bits 239 to 1 are zero, and; // the last one is set; // - if c = -1, which corresponds to all bits set (signed int64_t):; // bits 576 to 240 are zero and the rest is set.; // Note that all bits except the last are exactly complimentary (unless c = 0); // and the last byte is conveniently represented by c already.; // Now construct the three bit patterns from c, their names correspond to the; // assembly implementation by Alexei Sibidanov.; // c = 0 -> t0 = 0; c = 1 -> t0 = 0; c = -1 -> all bits set (sign extension); // (The assembly implementation shifts by 63, which gives the same result.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/ranluxpp/mulmod.h:255,depend,depending,255,math/mathcore/src/ranluxpp/mulmod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/ranluxpp/mulmod.h,1,['depend'],['depending']
Integrability,"// ToDo: case 248: 1/(2*PI) - is allowed only on VI; // ImmWidth 0 is a default case where operand should not allow immediates.; // Imm value is still decoded into 32 bit immediate operand, inst printer will; // use it to print verbose error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp:242,message,message,242,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,1,['message'],['message']
Integrability,// Top-level semantics-checking routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:32,rout,routines,32,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['rout'],['routines']
Integrability,// Top/bottom cases covered. Need to integrate L's set into ours.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:37,integrat,integrate,37,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,1,['integrat'],['integrate']
Integrability,"// TotPages = 16 will give 32k buffers at 4k page size for both; // parent and child; if your average message to send is larger; // than this, consider raising the value (max 256)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:102,message,message,102,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['message'],['message']
Integrability,// Total number of VGPRs is actually a combination of AGPR and VGPR; // depending on architecture - and some alignment constraints,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUResourceUsageAnalysis.h:72,depend,depending,72,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUResourceUsageAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUResourceUsageAnalysis.h,1,['depend'],['depending']
Integrability,// Touch all the predicates that depend on this instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:33,depend,depend,33,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['depend'],['depend']
Integrability,"// TraceGVPlacement controls messages for all builds. For builds with assertions; // (debug or release), messages are also controlled by the usual debug flags; // (e.g. -debug and -debug-only=globallayout)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:29,message,messages,29,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,2,['message'],['messages']
Integrability,// Track MIs with ignored dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:26,depend,dependence,26,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,1,['depend'],['dependence']
Integrability,"// Track Output, Flow, and Anti dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:32,depend,dependencies,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['depend'],['dependencies']
Integrability,"// Track all instructions that may raise floating-point exceptions.; // These do not depend on one other (or normal loads or stores), but; // must not be rescheduled across global barriers. Note that we don't; // really need a ""map"" here since we don't track those MIs by value;; // using the same Value2SUsMap data type here is simply a matter of; // convenience.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:85,depend,depend,85,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['depend'],['depend']
Integrability,// Track progress along the critical path through the SUnit graph as; // we walk the instructions. This is needed for regclasses that only; // break critical-path anti-dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:168,depend,dependencies,168,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,1,['depend'],['dependencies']
Integrability,"// Track the set of load-dependent registers through the basic block. Because; // the values of these registers have an existing data dependency on a loaded; // value which we would have checked, we can omit any checks on them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:25,depend,dependent,25,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,2,['depend'],"['dependency', 'dependent']"
Integrability,"// Track whether any functions in this SCC have an unknown call edge.; // Note: if this is ever a performance hit, we can common it with; // subsequent routines which also do scans over the instructions of the; // function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:152,rout,routines,152,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['rout'],['routines']
Integrability,"// Trailing padding: although this is implementation-dependent, most add enough padding to comply with the; // requirements of the type with strictest alignment",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldRecord.hxx:53,depend,dependent,53,tree/ntuple/v7/inc/ROOT/RField/RFieldRecord.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldRecord.hxx,3,['depend'],['dependent']
Integrability,"// Training sample, dependent quantity",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:20,depend,dependent,20,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['depend'],['dependent']
Integrability,"// Transaction management interface for multi-step import operations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooWorkspace.h:26,interface,interface,26,roofit/roofitcore/inc/RooWorkspace.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooWorkspace.h,1,['interface'],['interface']
Integrability,// Transfer unemitted dependencies from this node to the; // dependant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:22,depend,dependencies,22,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,2,['depend'],"['dependant', 'dependencies']"
Integrability,"// Transform all of the components into components similar to what the; // parser uses.; // FIXME: It would be slightly more efficient in the non-dependent case to; // just map FieldDecls, rather than requiring the rebuilder to look for; // the fields again. However, __builtin_offsetof is rare enough in; // template code that we don't care.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:146,depend,dependent,146,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependent']
Integrability,"// Transform the implicit coroutine statements constructed using dependent; // types during the previous parse: initial and final suspensions, the return; // object, and others. We also transform the coroutine function's body.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,depend,dependent,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependent']
Integrability,// Transform the underlying type of the typedef and clone the Decl only if; // the typedef has a dependent context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:97,depend,dependent,97,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,// Translate available BinaryMetadataFeatures to corresponding clang-cc1; // flags. Does not depend on any other sanitizers. Unsupported on GPUs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:93,depend,depend,93,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['depend'],['depend']
Integrability,"// Trapezodial integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/ROCCurve.cxx:15,integrat,integration,15,tmva/tmva/src/ROCCurve.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/ROCCurve.cxx,1,['integrat'],['integration']
Integrability,"// Trapezoid integration between midpoints",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCurve.cxx:13,integrat,integration,13,roofit/roofitcore/src/RooCurve.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCurve.cxx,1,['integrat'],['integration']
Integrability,"// Trapezoid integration from last midpoint to upper edge",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCurve.cxx:13,integrat,integration,13,roofit/roofitcore/src/RooCurve.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCurve.cxx,1,['integrat'],['integration']
Integrability,"// Trapezoid integration from lower edge to first midpoint",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCurve.cxx:13,integrat,integration,13,roofit/roofitcore/src/RooCurve.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCurve.cxx,1,['integrat'],['integration']
Integrability,"// Traverse TopDown, and give different colors to SUs depending; // on which combination of High Latencies they depend on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:54,depend,depending,54,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,2,['depend'],"['depend', 'depending']"
Integrability,// Traverse all the symbols this symbol depends on to see if any are tainted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp:40,depend,depends,40,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp,1,['depend'],['depends']
Integrability,"// Traverse preheader's instructions in reverse order because if A depends; // on B (A appears after B), A needs to be sunk first before B can be; // sinked.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:67,depend,depends,67,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,1,['depend'],['depends']
Integrability,// Traverse protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:12,protocol,protocols,12,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['protocol'],['protocols']
Integrability,"// Traverse the graph, making sure to visit a module before visiting any; // of its dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:84,depend,dependencies,84,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,1,['depend'],['dependencies']
Integrability,// Treat a template's injected-class-name as if the template; // specialization type had been used.; // template-name<T> (where template-name refers to a class template); // template-name<i>; // TT<T>; // TT<i>; // TT<>,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:22,inject,injected-class-name,22,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['inject'],['injected-class-name']
Integrability,// Treat an injected-class-name as its underlying template-id.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:12,inject,injected-class-name,12,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['inject'],['injected-class-name']
Integrability,"// Treat constant and global as identical. SMRD loads are sometimes usable for; // global loads (ideally constant address space should be eliminated); // depending on the context. Legality cannot be context dependent, but; // RegBankSelect can split the load as necessary depending on the pointer; // register bank/uniformity and if the memory is invariant or not written in a; // kernel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:154,depend,depending,154,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,3,['depend'],"['dependent', 'depending']"
Integrability,// Treat instantiation-dependent types as external.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:23,depend,dependent,23,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,2,['depend'],['dependent']
Integrability,"// Treat the start of the IT block as a scheduling boundary, but schedule; // t2IT along with all instructions following it.; // FIXME: This is a big hammer. But the alternative is to add all potential; // true and anti dependencies to IT block instructions as implicit operands; // to the t2IT instruction. The added compile time and complexity does not; // seem worth it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:220,depend,dependencies,220,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['depend'],['dependencies']
Integrability,"// Tries to find a possibility to optimize a v_cmp ..., s_and_saveexec; // sequence by looking at an instance of an s_and_saveexec instruction.; // Returns a pointer to the v_cmp instruction if it is safe to replace the; // sequence (see the conditions in the function body). This is after register; // allocation, so some checks on operand dependencies need to be considered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp:341,depend,dependencies,341,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp,1,['depend'],['dependencies']
Integrability,// Trigger a nice error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:24,message,message,24,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['message'],['message']
Integrability,// Trigger the import of the full interface definition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:34,interface,interface,34,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['interface'],['interface']
Integrability,// Trigger the import of the full protocol definition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:34,protocol,protocol,34,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['protocol'],['protocol']
Integrability,"// Trivial case, fully analytical integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:34,integrat,integration,34,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['integrat'],['integration']
Integrability,// True data dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:13,depend,dependency,13,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['depend'],['dependency']
Integrability,// True if this register read is from a dependency-breaking instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:40,depend,dependency-breaking,40,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['depend'],['dependency-breaking']
Integrability,// True if this write is from a dependency breaking zero-idiom instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:32,depend,dependency,32,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['depend'],['dependency']
Integrability,"// Truncate cast to fit cint interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx:29,interface,interface,29,core/metacling/src/TClingMethodInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx,2,['interface'],['interface']
Integrability,"// Truncate cast to fit the CINT interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingTypedefInfo.cxx:33,interface,interface,33,core/metacling/src/TClingTypedefInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingTypedefInfo.cxx,1,['interface'],['interface']
Integrability,"// Truncate cast to fit to cint interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingDataMemberInfo.cxx:32,interface,interface,32,core/metacling/src/TClingDataMemberInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingDataMemberInfo.cxx,1,['interface'],['interface']
Integrability,"// Try CINT interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx:12,interface,interface,12,roofit/roofitcore/src/RooFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx,1,['interface'],['interface']
Integrability,"// Try combining even if fmul has more than one use as it eliminates; // dependency between fadd(fsub) and fmul. However, it can extend liveranges; // for fmul operands, so reject the transformation in register pressure; // reduction mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:73,depend,dependency,73,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,1,['depend'],['dependency']
Integrability,"// Try duplicating the nodes that produces these; // ""expensive to copy"" values to break the dependency. In case even; // that doesn't work, insert cross class copies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:93,depend,dependency,93,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,1,['depend'],['dependency']
Integrability,"// Try find out the type of the left-hand-side of the operator; // and give the hint to the right-hand-side in order to replace the; // dependent symbol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp:136,depend,dependent,136,interpreter/cling/lib/Interpreter/DynamicLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp,1,['depend'],['dependent']
Integrability,// Try sinking IRG as deep as possible to avoid hurting shrink wrap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTagging.cpp:63,wrap,wrap,63,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTagging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTagging.cpp,1,['wrap'],['wrap']
Integrability,// Try to add details to the message:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp:29,message,message,29,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp,1,['message'],['message']
Integrability,// Try to build the offloading actions and add the result as a dependency; // to the host.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:63,depend,dependency,63,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['dependency']
Integrability,"// Try to combine the following nodes; // t29: i64 = X86ISD::Wrapper TargetConstantPool:i64; // <i32 -2147483648[float -0.000000e+00]> 0; // t27: v16i32[v16f32],ch = X86ISD::VBROADCAST_LOAD; // <(load 4 from constant-pool)> t0, t29; // [t30: v16i32 = bitcast t27]; // t6: v16i32 = xor t7, t27[t30]; // t11: v16f32 = bitcast t6; // t21: v16f32 = X86ISD::VFMULC[X86ISD::VCFMULC] t11, t8; // into X86ISD::VFCMULC[X86ISD::VFMULC] if possible:; // t22: v16f32 = bitcast t7; // t23: v16f32 = X86ISD::VFCMULC[X86ISD::VFMULC] t8, t22; // t24: v32f16 = bitcast t23",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:61,Wrap,Wrapper,61,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Wrap'],['Wrapper']
Integrability,"// Try to correct typos if possible. If constructor name lookup finds no; // results, that means the named class has no explicit constructors, and we; // suppressed declaring implicit ones (probably because it's dependent or; // invalid).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:212,depend,dependent,212,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"// Try to create a valid projection integral. If no variables are to be projected,; // create a null projection anyway to bind our normalization over the dependents; // consistently with the way they would be bound with a non-trivial projection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:154,depend,dependents,154,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['depend'],['dependents']
Integrability,"// Try to disprove equal directions.; // For example, given a subscript pair [3*i + 2*j] and [i' + 2*j' - 1],; // the code above can't disprove the dependence because the GCD = 1.; // So we consider what happen if i = i' and what happens if j = j'.; // If i = i', we can simplify the subscript to [2*i + 2*j] and [2*j' - 1],; // which is infeasible, so we can disallow the = direction for the i level.; // Setting j = j' doesn't help matters, so we end up with a direction vector; // of [<>, *]; //; // Given A[5*i + 10*j*M + 9*M*N] and A[15*i + 20*j*M - 21*N*M + 5],; // we need to remember that the constant part is 5 and the RunningGCD should; // be initialized to ExtraGCD = 30.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:148,depend,dependence,148,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,// Try to evaluate any dependencies out of the loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:23,depend,dependencies,23,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['depend'],['dependencies']
Integrability,"// Try to find an usable `errno` value.; // It can be an external variable called ""errno"" or a function that returns a; // pointer to the ""errno"" value. This function can have different names.; // The actual case is dependent on the C library implementation, we; // can only search for a match in one of these variations.; // We assume that exactly one of these cases might be true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:216,depend,dependent,216,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,1,['depend'],['dependent']
Integrability,// Try to find the interface where getters might live.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,interface,interface,19,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['interface'],['interface']
Integrability,// Try to find the interface where setters might live.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,interface,interface,19,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['interface'],['interface']
Integrability,"// Try to guess which DIEs must go to the accelerator tables. We do that; // just for variables, because functions will be handled depending on; // whether they carry a DW_AT_low_pc attribute or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerCompileUnit.cpp:131,depend,depending,131,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerCompileUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerCompileUnit.cpp,1,['depend'],['depending']
Integrability,// Try to instantiate any non-dependent declaration contexts before; // we look in them. Bail out if we fail.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:30,depend,dependent,30,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['depend'],['dependent']
Integrability,"// Try to invalidate the result, giving it the Invalidator so it can; // recursively query for any dependencies it has and record the result.; // Note that we cannot reuse 'IMapI' here or pre-insert the ID, as; // Result.invalidate may insert things into the map, invalidating our; // iterator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManagerImpl.h:99,depend,dependencies,99,interpreter/llvm-project/llvm/include/llvm/IR/PassManagerImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManagerImpl.h,1,['depend'],['dependencies']
Integrability,"// Try to load the library which should provide the symbol definition.; // TODO: Should this interface with the DynamicLibraryManager directly?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:93,interface,interface,93,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['interface'],['interface']
Integrability,// Try to merge a control statement block with left brace wrapped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:58,wrap,wrapped,58,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['wrap'],['wrapped']
Integrability,// Try to merge a function block with left brace wrapped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:49,wrap,wrapped,49,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['wrap'],['wrapped']
Integrability,// Try to move splat constant adders from the index operand to the base; // pointer operand. Taking care to multiply by the scale. We can only do; // this when index element type is the same as the pointer type.; // Otherwise we need to be sure the math doesn't wrap before the scale.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:262,wrap,wrap,262,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['wrap'],['wrap']
Integrability,// Try to prove `WrapType` (SCEV::FlagNSW or SCEV::FlagNUW) on `PreStart` +; // `Step`:; // 1. NSW/NUW flags on the step increment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:17,Wrap,WrapType,17,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Wrap'],['WrapType']
Integrability,"// Try to prove away overflow by looking at ""nearby"" add recurrences. A; // motivating example for this rule: if we know `{0,+,4}` is `ult` `-1` and it; // does not itself wrap then we can conclude that `{1,+,4}` is `nuw`.; //; // Formally:; //; // {S,+,X} == {S-T,+,X} + T; // => Ext({S,+,X}) == Ext({S-T,+,X} + T); //; // If ({S-T,+,X} + T) does not overflow ... (1); //; // RHS == Ext({S-T,+,X} + T) == Ext({S-T,+,X}) + Ext(T); //; // If {S-T,+,X} does not overflow ... (2); //; // RHS == Ext({S-T,+,X}) + Ext(T) == {Ext(S-T),+,Ext(X)} + Ext(T); // == {Ext(S-T)+Ext(T),+,Ext(X)}; //; // If (S-T)+T does not overflow ... (3); //; // RHS == {Ext(S-T)+Ext(T),+,Ext(X)} == {Ext(S-T+T),+,Ext(X)}; // == {Ext(S),+,Ext(X)} == LHS; //; // Thus, if (1), (2) and (3) are true for some T, then; // Ext({S,+,X}) == {Ext(S),+,Ext(X)}; //; // (3) is implied by (1) -- ""(S-T)+T does not overflow"" is simply ""({S-T,+,X}+T); // does not overflow"" restricted to the 0th iteration. Therefore we only need; // to check for (1) and (2).; //; // In the current context, S is `Start`, X is `Step`, Ext is `ExtendOpTy` and T; // is `Delta` (defined below).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:172,wrap,wrap,172,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// Try to reduce the pass list again. This covers additional cases; // we failed to reduce earlier, because of more complex pass dependencies; // triggering the crash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:129,depend,dependencies,129,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['depend'],['dependencies']
Integrability,"// Try to remove those functions from the public interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TStreamerInfo.h:49,interface,interface,49,io/io/inc/TStreamerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TStreamerInfo.h,1,['interface'],['interface']
Integrability,"// Try to set ROOTSYS depending on pathname of the executable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/rootx/src/rootx.cxx:22,depend,depending,22,rootx/src/rootx.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/rootx/src/rootx.cxx,1,['depend'],['depending']
Integrability,"// Turn 'store float 1.0, Ptr' -> 'store int 0x12345678, Ptr'; // FIXME: move this to the DAG Combiner! Note that we can't regress due; // to phase ordering between legalized code and the dag combiner. This; // probably means that we need to integrate dag combiner and legalizer; // together.; // We generally can't do this one for long doubles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:242,integrat,integrate,242,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['integrat'],['integrate']
Integrability,"// Turn off 'warning C4355: 'this' : used in base member initializer list'; //; // This message will pop up for any class that initializes member proxy objects; // Including the pragma here will automatically disable that warning message; // for all such cases",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsProxy.h:88,message,message,88,roofit/roofitcore/inc/RooAbsProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsProxy.h,2,['message'],['message']
Integrability,// Two non-wrapped sets can produce wrapped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:11,wrap,wrapped,11,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,2,['wrap'],['wrapped']
Integrability,// Type arguments for the superclass or protocol conformances.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:40,protocol,protocol,40,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocol']
Integrability,// Type dependent expressions will be checked during instantiation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:8,depend,dependent,8,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,1,['depend'],['dependent']
Integrability,// Type depends on a runtime value (variable-length array).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:8,depend,depends,8,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['depend'],['depends']
Integrability,"// Type mismatch here means that MaxIter is potentially larger than max; // unsigned value in start type, which mean we cannot prove no wrap for the; // indvar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:136,wrap,wrap,136,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// Type name qualified with ""template"".; // Note: Do we need to check for a dependent type here?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:76,depend,dependent,76,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,1,['depend'],['dependent']
Integrability,// Type-Generic Wrappers; //____________________________________________________________________________; /** Add the vector \p x scaled by \p alpha to \p y scaled by `\beta` */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Blas.h:16,Wrap,Wrappers,16,tmva/tmva/src/DNN/Architectures/Cpu/Blas.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Blas.h,1,['Wrap'],['Wrappers']
Integrability,"// Type-dependent expressions are always be value-dependent, so we simply drop; // type dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:8,depend,dependent,8,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,3,['depend'],"['dependency', 'dependent']"
Integrability,// Type-dependent expressions are always be value-dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:8,depend,dependent,8,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,2,['depend'],['dependent']
Integrability,"// Type-dependent operator calls are profiled like their underlying; // syntactic operator.; //; // An operator call to operator-> is always implicit, so just skip it. The; // enclosing MemberExpr will profile the actual member access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp:8,depend,dependent,8,interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,1,['depend'],['dependent']
Integrability,"// TypeInfo interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h:12,interface,interface,12,core/meta/inc/TInterpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h,2,['interface'],['interface']
Integrability,"// TypedefInfo interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h:15,interface,interface,15,core/meta/inc/TInterpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h,2,['interface'],['interface']
Integrability,"// Types to instantiate Chi2FCN: the gradient function interface handles the; // parameters, so its base typedef; // has to be always a double; the parametric function interface is templated; // to test both serial and vectorial; // cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testGradient.cxx:55,interface,interface,55,math/mathcore/test/testGradient.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testGradient.cxx,2,['interface'],['interface']
Integrability,"// UI5 rendering is performed; // only from here we can start to analyze messages and create TGeo painter, clones objects and so on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomViewer.controller.js:73,message,messages,73,ui5/geom/controller/GeomViewer.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomViewer.controller.js,1,['message'],['messages']
Integrability,"// Undefined linkage, it represents usage of external interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/Record.h:54,interface,interface,54,interpreter/llvm-project/llvm/include/llvm/TextAPI/Record.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/Record.h,1,['interface'],['interface']
Integrability,"// Under MSVC's cl driver mode, dependency file generation is controlled; // using /showIncludes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:32,depend,dependency,32,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,1,['depend'],['dependency']
Integrability,"// Unexpected message, just receive log file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:14,message,message,14,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,2,['message'],['message']
Integrability,"// Unfortunately, we have to bail out instead of recovering by; // ignoring the parameters, just in case the nested name specifier; // depends on the parameters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:135,depend,depends,135,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['depend'],['depends']
Integrability,"// Unfortunately, we have to parse some forwarding options (-Xassembler,; // -Xlinker, -Xpreprocessor) because we either integrate their functionality; // (assembler and preprocessor), or bypass a previous driver ('collect2').; // Rewrite linker options, to replace --no-demangle with a custom internal; // option.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:121,integrat,integrate,121,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['integrat'],['integrate']
Integrability,// Unique backedge insertion currently depends on having a preheader.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:39,depend,depends,39,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,1,['depend'],['depends']
Integrability,"// Unless -analyze-all is specified, treat decls differently depending on; // where they came from:; // - Main source file: run both path-sensitive and non-path-sensitive checks.; // - Header files: run non-path-sensitive checks only.; // - System headers: don't run any checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:61,depend,depending,61,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,1,['depend'],['depending']
Integrability,"// Unlike for UnresolvedLookupExpr, it is very easy to re-derive this.; // If there was a nested name specifier, it names the naming class.; // It can't be dependent: after all, we were actually able to do the; // lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:156,depend,dependent,156,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,1,['depend'],['dependent']
Integrability,"// Unlike most lookups, we don't always want to hide tag; // declarations: tag names are visible through the using declaration; // even if hidden by ordinary names, *except* in a dependent context; // where they may be used by two-phase lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:179,depend,dependent,179,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"// Unlike protocol lists, generic parameterizations support; // nested angles:; //; // @interface Foo<ValueType : id <NSCopying, NSSecureCoding>> :; // NSObject <NSCopying, NSSecureCoding>; //; // so we need to count how many open angles we have left.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:10,protocol,protocol,10,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,2,"['interface', 'protocol']","['interface', 'protocol']"
Integrability,"// Unlike the global bitset builder, the function bitset builder cannot; // re-arrange functions in a particular order and base its calculations on the; // layout of the functions' entry points, as we have no idea how large a; // particular function will end up being (the size could even depend on what; // this pass does!) Instead, we build a jump table, which is a block of code; // consisting of one branch instruction for each of the functions in the bit; // set that branches to the target function, and redirect any taken function; // addresses to the corresponding jump table entry. In the object file's; // symbol table, the symbols for the target functions also refer to the jump; // table entries, so that addresses taken outside the module will pass any; // verification done inside the module.; //; // In more concrete terms, suppose we have three functions f, g, h which are; // of the same type, and a function foo that returns their addresses:; //; // f:; // mov 0, %eax; // ret; //; // g:; // mov 1, %eax; // ret; //; // h:; // mov 2, %eax; // ret; //; // foo:; // mov f, %eax; // mov g, %edx; // mov h, %ecx; // ret; //; // We output the jump table as module-level inline asm string. The end result; // will (conceptually) look like this:; //; // f = .cfi.jumptable; // g = .cfi.jumptable + 4; // h = .cfi.jumptable + 8; // .cfi.jumptable:; // jmp f.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; // jmp g.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; // jmp h.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; //; // f.cfi:; // mov 0, %eax; // ret; //; // g.cfi:; // mov 1, %eax; // ret; //; // h.cfi:; // mov 2, %eax; // ret; //; // foo:; // mov f, %eax; // mov g, %edx; // mov h, %ecx; // ret; //; // Because the addresses of f, g, h are evenly spaced at a power of 2, in the; // normal case the check can be carried out using the same kind of simple; // arithmetic that we normally use for globals.; // FIXME: find ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:289,depend,depend,289,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['depend'],['depend']
Integrability,"// Unlike the specialization arguments, the injected arguments are not; // always canonical.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:44,inject,injected,44,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['inject'],['injected']
Integrability,// Unroll small loops to hide loop backedge latency and saturate any; // parallel execution resources of an out-of-order processor. We also then; // need to clean up redundancies and loop invariant code.; // FIXME: It would be really good to use a loop-integrated instruction; // combiner for cleanup here so that the unrolling and LICM can be pipelined; // across the loop nests.; // We do UnrollAndJam in a separate LPM to ensure it happens before unroll,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:253,integrat,integrated,253,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['integrat'],['integrated']
Integrability,// UnrollLevel might carry the dependency Dst --> Src,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:31,depend,dependency,31,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,1,['depend'],['dependency']
Integrability,// UnrollLevel might carry the dependency Src --> Dst; // Does a different loop after unrolling?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:31,depend,dependency,31,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,1,['depend'],['dependency']
Integrability,// Unsafe if the minimum distance needed is greater than smallest dependence; // distance distance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:66,depend,dependence,66,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// Unwrap packs that getInjectedTemplateArgs wrapped around pack; // expansions, to form an ""as written"" argument list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:45,wrap,wrapped,45,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['wrap'],['wrapped']
Integrability,// Unwrap types that may be wrapping the function type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:28,wrap,wrapping,28,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['wrap'],['wrapping']
Integrability,"// Up until now, we have been queuing up parameters because they; // might be protocol references. Turn them into parameters now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:78,protocol,protocol,78,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,2,['protocol'],['protocol']
Integrability,// Update DAG root to include dependencies on Pending chains.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:30,depend,dependencies,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['depend'],['dependencies']
Integrability,// Update ExpectedLatency and DependentLatency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:30,Depend,DependentLatency,30,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['Depend'],['DependentLatency']
Integrability,"// Update PHI nodes in both successors. The original BB needs to be; // replaced in one successor's PHI nodes, because the branch comes now from; // the newly generated BB (NewBB). In the other successor we need to add one; // incoming edge to the PHI nodes, because both branch instructions target; // now the same successor. Depending on the original branch condition; // (and/or) we have to swap the successors (TrueDest, FalseDest), so that; // we perform the correct update for the PHI nodes.; // This doesn't change the successor order of the just created branch; // instruction (or any other instruction).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:327,Depend,Depending,327,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['Depend'],['Depending']
Integrability,"// Update StdCXXImportSeqState to track our position within a C++20 import-seq; // if this token is being produced as a result of phase 4 of translation.; // Update TrackGMFState to decide if we are currently in a Global Module; // Fragment. GMF state updates should precede StdCXXImportSeq ones, since GMF state; // depends on the prevailing StdCXXImportSeq state in two cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:317,depend,depends,317,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['depend'],['depends']
Integrability,// Update analysis JumpThreading depends on and not explicitly preserved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:33,depend,depends,33,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['depend'],['depends']
Integrability,"// Update counter in loop for unrolling.; // Use an incrementing IV. Pre-incr/post-incr is backedge/trip count.; // Subtle: TestVal can be 0 if we wrapped when computing the trip count,; // thus we must compare the post-increment (wrapping) value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:147,wrap,wrapped,147,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,2,['wrap'],"['wrapped', 'wrapping']"
Integrability,// Update dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:10,depend,dependencies,10,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,1,['depend'],['dependencies']
Integrability,"// Update dominators of blocks we might reach through exits.; // Immediate dominator of such block might change, because we add more; // routes which can lead to the exit: we can now reach it from the copied; // iterations too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:137,rout,routes,137,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,1,['rout'],['routes']
Integrability,"// Update instantiation-dependent, variably-modified, and error bits.; // If the canonical type exists and is non-dependent, the template; // specialization type can be non-dependent even if one of the type; // arguments is. Given:; // template<typename T> using U = int;; // U<T> is always non-dependent, irrespective of the type T.; // However, U<Ts> contains an unexpanded parameter pack, even though; // its expansion (and thus its desugared type) doesn't.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:24,depend,dependent,24,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,4,['depend'],['dependent']
Integrability,// Update the DependencyMatrix,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:14,Depend,DependencyMatrix,14,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['Depend'],['DependencyMatrix']
Integrability,"// Update the allocation point of this memory block in MemorySanitizer.; // Without this, MemorySanitizer messages for values originated from here; // will point to the allocation of the entire slab.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:106,message,messages,106,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,1,['message'],['messages']
Integrability,// Update the costs depending on the block metadata,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:20,depend,depending,20,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,2,['depend'],['depending']
Integrability,"// Update the existing PHI node operand with the value from the; // new PHI node. How this is done depends on if the existing; // PHI node is in the original loop block, or the exit block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:99,depend,depends,99,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,1,['depend'],['depends']
Integrability,// Update the location of C++ catch objects for the MSVC personality routine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:69,rout,routine,69,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['rout'],['routine']
Integrability,// Update the message ref argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:14,message,message,14,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['message'],['message']
Integrability,// Update the path diagnostic message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:30,message,message,30,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['message'],['message']
Integrability,"// Update the ring buffer. Top byte of ThreadLong defines the size of the; // buffer in pages, it must be a power of two, and the start of the buffer; // must be aligned by twice that much. Therefore wrap around of the ring; // buffer is simply Addr &= ~((ThreadLong >> 56) << 12).; // The use of AShr instead of LShr is due to; // https://bugs.llvm.org/show_bug.cgi?id=39030; // Runtime library makes sure not to use the highest bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:200,wrap,wrap,200,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['wrap'],['wrap']
Integrability,"// Updates X with the intersection; // of the Constraints X and Y. Returns true if X has changed.; // Corresponds to Figure 4 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:159,Depend,Dependence,159,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['Depend'],['Dependence']
Integrability,// Upper wrapped range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:9,wrap,wrapped,9,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['wrap'],['wrapped']
Integrability,"// Usable locations are valid with non-zero line numbers. A line number of zero; // corresponds to optimized code that doesn't have a distinct source location.; // In this case, we try to use the previous or next source location depending on; // the context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:229,depend,depending,229,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['depend'],['depending']
Integrability,"// Use Adaptive Gauss-Kronrod integration by default for the convolution integral",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx:30,integrat,integration,30,roofit/roofitcore/src/RooNumConvolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx,1,['integrat'],['integration']
Integrability,"// Use CCP_Type for type declarations unless we're in a statement, Objective-C; // message receiver, or parenthesized expression context. There, it's as; // likely that the user will want to write a type as other declarations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:83,message,message,83,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['message'],['message']
Integrability,"// Use RooMinimizer interface to minimize chi^2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:20,interface,interface,20,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['interface'],['interface']
Integrability,"// Use SCALAR_TO_VECTOR for lane zero to; // a) Avoid a RMW dependency on the full vector register, and; // b) Allow the register coalescer to fold away the copy if the; // value is already in an S or D register, and we're forced to emit an; // INSERT_SUBREG that we can't fold anywhere.; //; // We also allow types like i8 and i16 which are illegal scalar but legal; // vector element types. After type-legalization the inserted value is; // extended (i32) and it is safe to cast them to the vector type by ignoring; // the upper bits of the lowest lane (e.g. v8i8, v4i16).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:60,depend,dependency,60,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['depend'],['dependency']
Integrability,"// Use a SCHED_BARRIER's mask to identify instruction SchedGroups that should; // not be reordered accross the SCHED_BARRIER. This is used for the base; // SCHED_BARRIER, and not SCHED_GROUP_BARRIER. The difference is that; // SCHED_BARRIER will always block all instructions that can be classified; // into a particular SchedClass, whereas SCHED_GROUP_BARRIER has a fixed size; // and may only synchronize with some SchedGroups. Returns the inverse of; // Mask. SCHED_BARRIER's mask describes which instruction types should be; // allowed to be scheduled across it. Invert the mask to get the; // SchedGroupMask of instructions that should be barred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:395,synchroniz,synchronize,395,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['synchroniz'],['synchronize']
Integrability,// Use a different message for terminator misses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:19,message,message,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['message'],['message']
Integrability,// Use a generic helper to update the postorder sequence of RefSCCs and return; // a range of any RefSCCs connected into a cycle by inserting this edge. This; // routine will also take care of updating the indices into the postorder; // sequence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:162,rout,routine,162,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['rout'],['routine']
Integrability,// Use a generic helper to update the postorder sequence of SCCs and return; // a range of any SCCs connected into a cycle by inserting this edge. This; // routine will also take care of updating the indices into the postorder; // sequence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:156,rout,routine,156,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['rout'],['routine']
Integrability,// Use a new dependence vector for this update.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:13,depend,dependence,13,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['depend'],['dependence']
Integrability,// Use a v_mov_b32 here to make the exec dependency explicit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:41,depend,dependency,41,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,2,['depend'],['dependency']
Integrability,"// Use an incrementing IV. Pre-incr/post-incr is backedge/trip count.; // Subtle: NewIter can be 0 if we wrapped when computing the trip count,; // thus we must compare the post-increment (wrapping) value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:105,wrap,wrapped,105,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,2,['wrap'],"['wrapped', 'wrapping']"
Integrability,// Use cached result for invariant load only if there is no dependency for non; // invariant load. In this case invariant load can not have any dependency as; // well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:60,depend,dependency,60,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,2,['depend'],['dependency']
Integrability,"// Use computeTargetABI to check if ABIName is valid. If invalid, output; // error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:83,message,message,83,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,1,['message'],['message']
Integrability,// Use default section depending on the 'type' of global,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/TargetLoweringObjectFile.cpp:23,depend,depending,23,interpreter/llvm-project/llvm/lib/Target/TargetLoweringObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/TargetLoweringObjectFile.cpp,1,['depend'],['depending']
Integrability,// Use device / host triples as the key into the ToolChains map because the; // device ToolChain we create depends on both.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:107,depend,depends,107,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['depends']
Integrability,// Use is a younger register write that is in a false dependency with this; // write. IID is the instruction identifier associated with this write.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:54,depend,dependency,54,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['depend'],['dependency']
Integrability,// Use no indentation as we need to wrap the lines into quotes ourselves.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:36,wrap,wrap,36,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,1,['wrap'],['wrap']
Integrability,"// Use performance counter (system dependent support) if possible",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLStopwatch.cxx:35,depend,dependent,35,graf3d/gl/src/TGLStopwatch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLStopwatch.cxx,1,['depend'],['dependent']
Integrability,"// Use the 32-bit bitfield extract instruction if the width is a constant.; // Depending on the width size, use either the low or high 32-bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:79,Depend,Depending,79,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['Depend'],['Depending']
Integrability,"// Use the CUDA and host triples as the key into the ToolChains map,; // because the device toolchain we create depends on both.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:112,depend,depends,112,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['depends']
Integrability,// Use the cursor modified by skipping the wrapper header.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:43,wrap,wrapper,43,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,1,['wrap'],['wrapper']
Integrability,// Use the dependency scanning optimized file system if requested to do so.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:11,depend,dependency,11,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,1,['depend'],['dependency']
Integrability,"// Use the protocol definition, if there is one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:11,protocol,protocol,11,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,4,['protocol'],['protocol']
Integrability,// Use the wrapper function instead of the old function,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:11,wrap,wrapper,11,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,1,['wrap'],['wrapper']
Integrability,// Use this for ODR checking ObjC interfaces. This; // method compares more information than the AddDecl class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRHash.h:34,interface,interfaces,34,interpreter/llvm-project/clang/include/clang/AST/ODRHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRHash.h,1,['interface'],['interfaces']
Integrability,// Use this for ODR checking ObjC protocols. This; // method compares more information than the AddDecl class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRHash.h:34,protocol,protocols,34,interpreter/llvm-project/clang/include/clang/AST/ODRHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRHash.h,1,['protocol'],['protocols']
Integrability,"// Use this form of the constructor to integrate over the function's default range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx:39,integrat,integrate,39,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,2,['integrat'],['integrate']
Integrability,"// Use this protocol meta-data to build protocol list table in section; // __DATA, __objc_protolist",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:12,protocol,protocol,12,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['protocol'],['protocol']
Integrability,// Use this to diagnose that an unexpected Decl was encountered; // or no difference was detected. This causes a generic error; // message to be emitted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRDiagsEmitter.h:131,message,message,131,interpreter/llvm-project/clang/include/clang/AST/ODRDiagsEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRDiagsEmitter.h,1,['message'],['message']
Integrability,// Use unique exit code to differentiate failures not directly caused from; // TextAPI operations. This is used for wrapping `compare` operations in; // automation and scripting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readtapi/llvm-readtapi.cpp:116,wrap,wrapping,116,interpreter/llvm-project/llvm/tools/llvm-readtapi/llvm-readtapi.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readtapi/llvm-readtapi.cpp,1,['wrap'],['wrapping']
Integrability,// Used by Memory SSA dumpers and wrapper pass,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:34,wrap,wrapper,34,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,1,['wrap'],['wrapper']
Integrability,"// Used by PredicateInfo annotater, dumpers, and wrapper pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h:49,wrap,wrapper,49,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h,1,['wrap'],['wrapper']
Integrability,// Used for SME ABI routines to avoid lazy saves,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h:20,rout,routines,20,interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h,1,['rout'],['routines']
Integrability,"// Used to access filesystem interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/TNetXNGFileStager.h:29,interface,interface,29,net/netxng/inc/TNetXNGFileStager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/TNetXNGFileStager.h,1,['interface'],['interface']
Integrability,// Used to populate the dependency graph DG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:24,depend,dependency,24,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,1,['depend'],['dependency']
Integrability,"// Used to test the dependence analyzer.; // Looks through the function, noting instructions that may access memory.; // Calls depends() on every possible pair and prints out the result.; // Ignores all other instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:20,depend,dependence,20,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,2,['depend'],"['dependence', 'depends']"
Integrability,// Useful for e.g. interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:19,interface,interface,19,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['interface'],['interface']
Integrability,"// User didn't forbid integration, and it seems appropriate with a; // RooDataHist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:22,integrat,integration,22,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['integrat'],['integration']
Integrability,"// User forced integration. Let just apply it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:15,integrat,integration,15,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['integrat'],['integration']
Integrability,"// User interface -- Add or delete reporting streams ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMsgService.h:8,interface,interface,8,roofit/roofitcore/inc/RooMsgService.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMsgService.h,1,['interface'],['interface']
Integrability,"// User-specifed personality routine: [ SIZE , OP1 , OP2 , ... ]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp:29,rout,routine,29,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp,1,['rout'],['routine']
Integrability,"// Using CINT to avoid a dependency in TParallelCoord",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx:25,depend,dependency,25,tree/treeplayer/src/TSelectorDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx,1,['depend'],['dependency']
Integrability,// Using CanBreakBefore here and below takes care of the decision whether the; // current style uses wrapping before or after operators for the given; // operator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:101,wrap,wrapping,101,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['wrap'],['wrapping']
Integrability,"// Using declarations cannot inject special members; do not call them; // as such. This might happen by using `Base(Base&, int = 12)`, which; // is fine to be called as `Derived d(someBase, 42)` but not as; // copy constructor of `Derived`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx:29,inject,inject,29,core/metacling/src/TClingCallFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx,1,['inject'],['inject']
Integrability,"// Using directives are never dependent (and never contain any types or; // expressions), so they require no explicit instantiation work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:30,depend,dependent,30,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['depend'],['dependent']
Integrability,"// UsualArithmeticConversions - performs the UsualUnaryConversions on it's; // operands and then handles various conversions that are common to binary; // operators (C99 6.3.1.8). If both operands aren't arithmetic, this; // routine returns the first non-arithmetic type found. The client is; // responsible for emitting appropriate error diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:225,rout,routine,225,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['rout'],['routine']
Integrability,// Utility function for printing the help message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp:42,message,message,42,interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,1,['message'],['message']
Integrability,"// Utility functions.; ////////////////////////////////////////////////////////////////////////////////; /// Render text at the given position. Offset depends of text alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLAxisPainter.cxx:151,depend,depends,151,graf3d/gl/src/TGLAxisPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLAxisPainter.cxx,1,['depend'],['depends']
Integrability,// Utility helper routines,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp:18,rout,routines,18,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp,1,['rout'],['routines']
Integrability,// Utility helper routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:18,rout,routines,18,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,2,['rout'],['routines']
Integrability,// Utility routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:11,rout,routines,11,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,2,['rout'],['routines']
Integrability,"// Utility routines. Most belongs in TMetaUtils and should be shared with rootcling.cxx",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/Scanner.h:11,rout,routines,11,core/dictgen/res/Scanner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/Scanner.h,1,['rout'],['routines']
Integrability,"// Utility to handle information from clauses associated with a given; // construct that use mappable expressions (e.g. 'map' clause, 'to' clause).; // It provides a convenient interface to obtain the information and generate; // code for that information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:177,interface,interface,177,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['interface'],['interface']
Integrability,// VLDR* instructions share the same opcode (and thus the same form) for Arm; // and Thumb. Use a bit longer route through STI in that case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp:109,rout,route,109,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp,1,['rout'],['route']
Integrability,"// VLIWPacketizerList implements a simple VLIW packetizer using DFA. The; // packetizer works on machine basic blocks. For each instruction I in BB,; // the packetizer consults the DFA to see if machine resources are available; // to execute I. If so, the packetizer checks if I depends on any instruction; // in the current packet. If no dependency is found, I is added to current; // packet and the machine resource is marked as taken. If any dependency is; // found, a target API call is made to prune the dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:279,depend,depends,279,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,4,['depend'],"['dependence', 'dependency', 'depends']"
Integrability,// VMOVRRD is also a copy instruction but it requires; // special way of handling. It is more complex copy version; // and since that we are not considering it. For recognition; // of such instruction isExtractSubregLike MI interface fuction; // could be used.; // VORRq is considered as a move only if two inputs are; // the same register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:224,interface,interface,224,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['interface'],['interface']
Integrability,// Valid value for the third argument is dependent on the input type and; // builtin called.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:41,depend,dependent,41,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['depend'],['dependent']
Integrability,// Validate and pass through -ffp-contract option.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:34,contract,contract,34,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['contract'],['contract']
Integrability,// Validate the always/never attribute files. We also make sure that they; // are treated as actual dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/XRayArgs.cpp:100,depend,dependencies,100,interpreter/llvm-project/clang/lib/Driver/XRayArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/XRayArgs.cpp,1,['depend'],['dependencies']
Integrability,"// Validate the original range to attempt to get a meaningful error; // message. If it's valid, then something else is the cause and we just; // return the generic failure message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:72,message,message,72,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,2,['message'],['message']
Integrability,// Validation strictness depends on whether message is specified; // in a symbolic or in a numeric form. In the latter case; // only encoding possibility is checked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:25,depend,depends,25,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,2,"['depend', 'message']","['depends', 'message']"
Integrability,"// Value modifiers; ////////////////////////////////////////////////////////////////////////////////; /// Change category state by specifying the index code of the desired state.; /// If printError is set, a message will be printed if; /// the specified index does not represent a valid state.; /// \return bool to signal an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCategoryLValue.h:208,message,message,208,roofit/roofitcore/inc/RooAbsCategoryLValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCategoryLValue.h,1,['message'],['message']
Integrability,// Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:9,depend,dependent,9,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,4,['depend'],['dependent']
Integrability,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:10,depend,depend,10,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,3,['depend'],"['depend', 'depends']"
Integrability,"// Values outside the region can be combined into PHINode when we; // have multiple exits. We collect both of these into a list to identify; // which values are being used in the PHINode. Each list identifies a; // different PHINode, and a different output. We store the PHINode as it's; // own canonical value. These canonical values are also dependent on the; // output argument it is saved to.; // If two PHINodes have the same canonical values, but different aggregate; // argument locations, then they will have distinct Canonical Values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:344,depend,dependent,344,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,1,['depend'],['dependent']
Integrability,"// Variables created by this function are thread local. If the target does not; // support TLS, we depend on CoalesceFeaturesAndStripAtomics to downgrade it; // to non-thread-local ones, in which case we don't allow this object to be; // linked with other objects using shared memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:99,depend,depend,99,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,1,['depend'],['depend']
Integrability,// Various SDK-dependent features that affect CUDA compilation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Cuda.h:15,depend,dependent,15,interpreter/llvm-project/clang/include/clang/Basic/Cuda.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Cuda.h,1,['depend'],['dependent']
Integrability,"// Various error message that may be printed by TTreeReader depending on; // whether we are running with IMT or not",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:17,message,message,17,tree/dataframe/test/dataframe_incomplete_entries.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx,8,"['depend', 'message']","['depending', 'message']"
Integrability,"// Various uses, depending on ""type""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:17,depend,depending,17,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['depend'],['depending']
Integrability,"// Vector and fp128 types require one register, other floating point types; // require one or two registers depending on their size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp:108,depend,depending,108,interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,1,['depend'],['depending']
Integrability,// Vector lists can wrap around.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp:20,wrap,wrap,20,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp,3,['wrap'],['wrap']
Integrability,"// Verifies that RooAbsPdf::createNLL() can create a valid RooAbsL wrapped in RooRealL",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testInterface.cxx:67,wrap,wrapped,67,roofit/roofitcore/test/TestStatistics/testInterface.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testInterface.cxx,1,['wrap'],['wrapped']
Integrability,"// Verifies that the fitTo parallelize interface creates a valid minimization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testInterface.cxx:39,interface,interface,39,roofit/roofitcore/test/TestStatistics/testInterface.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testInterface.cxx,1,['interface'],['interface']
Integrability,// Verify protocol compatibility for casts from Class<P1> to Class<P2>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:10,protocol,protocol,10,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['protocol'],['protocol']
Integrability,"// Verify that ArgumentDependentLookup is consistent with the rules; // in C++0x [basic.lookup.argdep]p3:; //; // Let X be the lookup set produced by unqualified lookup (3.4.1); // and let Y be the lookup set produced by argument dependent; // lookup (defined as follows). If X contains; //; // -- a declaration of a class member, or; //; // -- a block-scope function declaration that is not a; // using-declaration, or; //; // -- a declaration that is neither a function or a function; // template; //; // then Y is empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:230,depend,dependent,230,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['depend'],['dependent']
Integrability,// Verify that ConstantMultipleCache computations are correct. We check that; // cached multiples and recomputed multiples are multiples of each other to; // verify correctness. It is possible that a recomputed multiple is different; // from the cached multiple due to strengthened no wrap flags or changes in; // KnownBits computations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:285,wrap,wrap,285,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// Verify that RooFit correctly uses analytic integration when having a; // RooLinearVar as the observable of a RooHistPdf.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooHistPdf.cxx:46,integrat,integration,46,roofit/roofitcore/test/testRooHistPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooHistPdf.cxx,1,['integrat'],['integration']
Integrability,// Verify that the function takes one or two arguments (depending on; // the function).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:56,depend,depending,56,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,1,['depend'],['depending']
Integrability,// Verify that the types of the call parameter arguments match; // the type of the wrapped callee.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:83,wrap,wrapped,83,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['wrap'],['wrapped']
Integrability,"// Verify the stack was used properly, that is we pop the dependence vector we; // put there earlier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:58,depend,dependence,58,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['depend'],['dependence']
Integrability,// VerifyParameterAttrs - Check the given attributes for an argument or return; // value of the specified type. The value V is printed in error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:144,message,messages,144,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['message'],['messages']
Integrability,"// Virtual hook function for class-specific content implementation; ////////////////////////////////////////////////////////////////////////////////; /// Interface to print value of object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooPrintable.cxx:154,Interface,Interface,154,roofit/roofitcore/src/RooPrintable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooPrintable.cxx,1,['Interface'],['Interface']
Integrability,// Visit all protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:13,protocol,protocols,13,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,1,['protocol'],['protocols']
Integrability,// Visit synthesized methods since they will be skipped when visiting; // the @interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:79,interface,interface,79,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['interface'],['interface']
Integrability,// Visit the protocols of protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:13,protocol,protocols,13,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,2,['protocol'],['protocols']
Integrability,"// Visualization of Load-Op-Store fusion:; // -------------------------; // Legend:; // *-lines = Chain operand dependencies.; // |-lines = Normal operand dependencies.; // Dependencies flow down and right. n-suffix references multiple nodes.; //; // C Xn C; // * * *; // * * *; // Xn A-LD Yn TF Yn; // * * \ | * |; // * * \ | * |; // * * \ | => A--LD_OP_ST; // * * \| \; // TF OP \; // * | \ Zn; // * | \; // A-ST Zn; //; // This merge induced dependences from: #1: Xn -> LD, OP, Zn; // #2: Yn -> LD; // #3: ST -> Zn; // Ensure the transform is safe by checking for the dual; // dependencies to make sure we do not induce a loop.; // As LD is a predecessor to both OP and ST we can do this by checking:; // a). if LD is a predecessor to a member of Xn or Yn.; // b). if a Zn is a predecessor to ST.; // However, (b) can only occur through being a chain predecessor to; // ST, which is the same as Zn being a member or predecessor of Xn,; // which is a subset of LD being a predecessor of Xn. So it's; // subsumed by check (a).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:112,depend,dependencies,112,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,5,"['Depend', 'depend']","['Dependencies', 'dependences', 'dependencies']"
Integrability,// Volatile Setting; // - .volatile is only available for .global and .shared; // - .volatile has the same memory synchronization semantics as .relaxed.sys,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:114,synchroniz,synchronization,114,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,2,['synchroniz'],['synchronization']
Integrability,// Volatile may synchronize,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:16,synchroniz,synchronize,16,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['synchroniz'],['synchronize']
Integrability,"// WARNING: At this time, the state attached to 'Call' may be older than the; // state in 'Pred'. This is a minor optimization since CheckerManager will; // use an updated CallEvent instance when calling checkers, but if 'Call' is; // ever used directly in this function all callers should be updated to pass; // the most recent state. (It is probably not worth doing the work here since; // for some callers this will not be necessary.); // Run any pre-call checks using the generic call interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:489,interface,interface,489,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['interface'],['interface']
Integrability,"// WARNING: It is generally unsound to apply any wrap flags to the proposed; // replacement SCEV which isn't directly implied by the structure of that; // SCEV. In particular, using contextual facts to imply flags is *NOT*; // legal. See the scoping rules for flags in the header to understand why.; // If LHS is a constant, apply information to the other expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:49,wrap,wrap,49,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// WARNING:; //; // The large blocks of commented-out code in this routine; // are there to support doing more desugaring in the future,; // we will probably have to.; //; // Do not delete until we are completely sure we will; // not be changing this routine again!; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp:67,rout,routine,67,interpreter/cling/lib/Utils/AST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp,2,['rout'],['routine']
Integrability,"// WVE Remove projected dependents from normalization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx:24,depend,dependents,24,roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,1,['depend'],['dependents']
Integrability,"// WVE kludge: synchronize dset for use in analyticalIntegral; // LM : I think this is needed only if _funcNormSet is not an empty set",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:15,synchroniz,synchronize,15,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['synchroniz'],['synchronize']
Integrability,"// WVE needs adaptation for rangename feature; // Partial integration scenarios",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:58,integrat,integration,58,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['integrat'],['integration']
Integrability,"// WVE this will only get the observables, but not l-value transformations; // Expand server in final dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:102,depend,dependents,102,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['depend'],['dependents']
Integrability,// Wait for any outstanding memory operations that the input registers may; // depend on. We can't track them and it's better to do the wait after the; // costly call sequence.; // TODO: Could insert earlier and schedule more liberally with operations; // that only use caller preserved registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:79,depend,depend,79,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['depend'],['depend']
Integrability,// Wait for messages to be pushed into the queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp:12,message,messages,12,interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp,1,['message'],['messages']
Integrability,"// Wait till we get the start message; // server tells us who we are",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TParallelMergingFile.cxx:30,message,message,30,net/net/src/TParallelMergingFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TParallelMergingFile.cxx,1,['message'],['message']
Integrability,"// Walk back through the IR for a pointer, looking for a select like the; // following:; //; // %offset = select i1 %cmp, i64 %a, i64 %b; // %addr = getelementptr double, double* %base, i64 %offset; // %ld = load double, double* %addr, align 8; //; // We won't be able to form a single SCEVAddRecExpr from this since the; // address for each loop iteration depends on %cmp. We could potentially; // produce multiple valid SCEVAddRecExprs, though, and check all of them for; // memory safety/aliasing if needed.; //; // If we encounter some IR we don't yet handle, or something obviously fine; // like a constant, then we just add the SCEV for that term to the list passed; // in by the caller. If we have a node that may potentially yield a valid; // SCEVAddRecExpr then we decompose it into parts and build the SCEV terms; // ourselves before adding to the list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:357,depend,depends,357,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['depends']
Integrability,"// Walk backwards through the basic block, looking for dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:55,depend,dependencies,55,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependencies']
Integrability,"// Walk backwards through the block, looking for dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:49,depend,dependencies,49,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependencies']
Integrability,"// Walk the GEP operands and see if any operand introduces a non-zero offset.; // If so, then the GEP cannot produce a null pointer, as doing so would; // inherently violate the inbounds contract within address space zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:187,contract,contract,187,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['contract'],['contract']
Integrability,"// Walk the Runtime list to get all protocols implied via the inclusion of; // this protocol, e.g. all protocols it inherits from including itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:36,protocol,protocols,36,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,3,['protocol'],"['protocol', 'protocols']"
Integrability,"// Walk through the Non-local dependencies, removing this one as the value; // for any cached queries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:30,depend,dependencies,30,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependencies']
Integrability,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:117,depend,depend,117,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['depend']
Integrability,// Warn if a method declared in a protocol to which a category or; // extension conforms is non-escaping and the implementation's method is; // escaping.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:34,protocol,protocol,34,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocol']
Integrability,// Warn instead of error because users might have makefiles written for; // gfortran (which accepts -ffp-contract=on),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp:105,contract,contract,105,interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,1,['contract'],['contract']
Integrability,"// Warn that analytical integration is only provided for the first 127 observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx:24,integrat,integration,24,roofit/roofitcore/src/RooMultiVarGaussian.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx,2,['integrat'],['integration']
Integrability,"// Warn that analytical integration is only provided for the first 31 observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooUniform.cxx:24,integrat,integration,24,roofit/roofit/src/RooUniform.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooUniform.cxx,2,['integrat'],['integration']
Integrability,"// Warning message will appear if the user types the function name incorrectly; // or the function is not a member function of ""cl"" or any of its base classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:11,message,message,11,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['message'],['message']
Integrability,"// We add a technical suffix for each unnamed section/fill. It does not; // affect the output, but allows us to map them by name in the code and; // report better error messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp:169,message,messages,169,interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,1,['message'],['messages']
Integrability,"// We allow accessing the edges by dereferencing or using the arrow; // operator, essentially wrapping the internal optional.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:94,wrap,wrapping,94,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['wrap'],['wrapping']
Integrability,// We allow for the case that a module object is added to a linked binary; // without a specific call to the the initializer. This also ensures that; // implementation partition initializers are called when the partition; // is not imported as an interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:247,interface,interface,247,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,1,['interface'],['interface']
Integrability,// We allow sending a message to a pointer to an interface (an object).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:22,message,message,22,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,2,"['interface', 'message']","['interface', 'message']"
Integrability,"// We allow sending a message to a qualified ID (""id<foo>""), which is ok as; // long as one of the protocols implements the selector (if not, warn).; // And as long as message is not deprecated/unavailable (warn if it is).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:22,message,message,22,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,3,"['message', 'protocol']","['message', 'protocols']"
Integrability,"// We already have a ""canonical"" version of an identical, dependent; // typeof(expr) type. Use that as our canonical type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:58,depend,dependent,58,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['depend'],['dependent']
Integrability,// We already parsed the protocols named when we thought we had a; // type parameter list. Translate them into actual protocol references.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:25,protocol,protocols,25,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,// We already potentially made an implicit import (in the case of a module; // implementation unit importing its interface). Make this module visible; // and return the import decl to be added to the current TU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:113,interface,interface,113,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,1,['interface'],['interface']
Integrability,"// We always synthesize an interface for an implementation; // without an interface decl. So, IDecl is always non-zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:27,interface,interface,27,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,2,['interface'],['interface']
Integrability,"// We always take all children ... interest is viewer dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScenePad.cxx:54,depend,dependent,54,graf3d/gl/src/TGLScenePad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScenePad.cxx,1,['depend'],['dependent']
Integrability,// We appear to have a dependent template name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:23,depend,dependent,23,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['depend'],['dependent']
Integrability,"// We appreciate the error message about an unknown flag (or do we? if not; // we should switch to a different DiagEngine for parsing the flags).; // But in general we'll happily go on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:27,message,message,27,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['message'],['message']
Integrability,"// We are adding all independent direct servers of the args depending on the; // integration variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:60,depend,depending,60,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,2,"['depend', 'integrat']","['depending', 'integration']"
Integrability,"// We are an enum or namespace.; // The cint interface always returns 0L for these guys.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx:45,interface,interface,45,core/metacling/src/TClingClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx,1,['interface'],['interface']
Integrability,"// We are avoiding substitution in the case of; // ....;c:.... and of ...;root:/... where root can be any url protocol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:110,protocol,protocol,110,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['protocol'],['protocol']
Integrability,// We are checking for shuffle match or shift match. Loop twice so we can; // order which we try and match first depending on target preference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:113,depend,depending,113,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['depending']
Integrability,"// We are either TSK_Undeclared or; // TSK_ExplicitSpecialization.; // Note: This might be ok, the body might be defined; // in a library, and all we have seen is the; // header file.; //::Error(""TClingCallFunc::make_wrapper"",; // ""Cannot make wrapper for a dependent function ""; // ""template explicit specialization which is declared ""; // ""but not defined!"");; // return 0;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx:244,wrap,wrapper,244,core/metacling/src/TClingCallFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx,2,"['depend', 'wrap']","['dependent', 'wrapper']"
Integrability,"// We are either TSK_Undeclared or; // TSK_ExplicitSpecialization.; // Note: This might be ok, the body might be defined; // in a library, and all we have seen is the; // header file.; //::Error(""TClingCallFunc::make_wrapper"",; // ""Cannot make wrapper for a function template ""; // ""explicit specialization which is declared ""; // ""but not defined!"");; // return 0;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx:244,wrap,wrapper,244,core/metacling/src/TClingCallFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx,2,['wrap'],['wrapper']
Integrability,"// We are extracting part of the original scalar. How that scalar is; // inserted into the vector depends on the endian-ness. Example:; // Vector Byte Elt Index: 0 1 2 3 4 5 6 7; // +--+--+--+--+--+--+--+--+; // inselt <2 x i32> V, <i32> S, 1: |V0|V1|V2|V3|S0|S1|S2|S3|; // extelt <4 x i16> V', 3: | |S2|S3|; // +--+--+--+--+--+--+--+--+; // If this is little-endian, S2|S3 are the MSB of the 32-bit 'S' value.; // If this is big-endian, S2|S3 are the LSB of the 32-bit 'S' value.; // In this example, we must right-shift little-endian. Big-endian is just a; // truncate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:98,depend,depends,98,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['depend'],['depends']
Integrability,// We are going to resume the execution of the scalar loop.; // Go over all of the induction variables that we found and fix the; // PHIs that are left in the scalar version of the loop.; // The starting values of PHI nodes depend on the counter of the last; // iteration in the vectorized loop.; // If we come from a bypass edge then we need to start from the original; // start value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:224,depend,depend,224,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['depend'],['depend']
Integrability,// We are implementing a weak imported interface. Give it external linkage,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:39,interface,interface,39,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['interface'],['interface']
Integrability,"// We are in the case of a type(def) that was declared in a; // class template but is *not* type dependent. In clang, it gets; // attached to the class template declaration rather than any; // specific class template instantiation. This result in 'odd'; // fully qualified typename:; // vector<_Tp,_Alloc>::size_type; // Make the situation is 'useable' but looking a bit odd by; // picking a random instance as the declaring context.; // FIXME: We should not use the iterators here to check if we are in; // a template specialization. clTempl != cxxdecl already tell us that; // is the case. It seems that we rely on a side-effect from triggering; // deserializations to support 'some' use-case. See ROOT-9709.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp:97,depend,dependent,97,interpreter/cling/lib/Utils/AST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp,1,['depend'],['dependent']
Integrability,"// We are in the case of a type(def) that was declared in a; // class template but is *not* type dependent. In clang, it; // gets attached to the class template declaration rather than; // any specific class template instantiation. This result in; // 'odd' fully qualified typename:; //; // vector<_Tp,_Alloc>::size_type; //; // Make the situation is 'useable' but looking a bit odd by; // picking a random instance as the declaring context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp:97,depend,dependent,97,interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp,1,['depend'],['dependent']
Integrability,"// We are indexing into this struct, and want to extract the workgroup_size_*; // fields.; //; // typedef struct hsa_kernel_dispatch_packet_s {; // uint16_t header;; // uint16_t setup;; // uint16_t workgroup_size_x ;; // uint16_t workgroup_size_y;; // uint16_t workgroup_size_z;; // uint16_t reserved0;; // uint32_t grid_size_x ;; // uint32_t grid_size_y ;; // uint32_t grid_size_z;; //; // uint32_t private_segment_size;; // uint32_t group_segment_size;; // uint64_t kernel_object;; //; // #ifdef HSA_LARGE_MODEL; // void *kernarg_address;; // #elif defined HSA_LITTLE_ENDIAN; // void *kernarg_address;; // uint32_t reserved1;; // #else; // uint32_t reserved1;; // void *kernarg_address;; // #endif; // uint64_t reserved2;; // hsa_signal_t completion_signal; // uint64_t wrapper; // } hsa_kernel_dispatch_packet_t; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp:772,wrap,wrapper,772,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,1,['wrap'],['wrapper']
Integrability,"// We are inside an instance method, which means that the message; // send [super ...] is actually calling an instance method on the; // current object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:58,message,message,58,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['message'],['message']
Integrability,"// We are looking for a pair of blocks A, B so that the following is true:; // * A is a predecessor of B; // * B is marked as NotCalled; // * A has at least one successor marked as either; // Escaped or DefinitelyCalled; //; // In that situation, it is guaranteed that B is the first block of the path; // where the user doesn't call or use parameter in question.; //; // For this reason, branch A -> B can be used for reporting.; //; // This part of the algorithm is guarded by a condition that the function; // does indeed have a violation of contract. For this reason, we can; // spend more time to find a good spot to place the warning.; //; // The following algorithm has the worst case complexity of O(V + E),; // where V is the number of basic blocks in FunctionCFG,; // E is the number of edges between blocks in FunctionCFG.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:545,contract,contract,545,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['contract'],['contract']
Integrability,"// We are looking up for something on the TU scope.; // FIXME: We do not want to go through TClingClassInfo(fInterpreter) because of redundant deserializations. That; // interface will actually construct iterators and walk over the decls on the global scope. In would return the first; // occurrence of a decl with the looked up name. However, that's not what C++ lookup would do: if we want to switch; // to a more complete C++ lookup interface we need sift through the found names and pick up the declarations which; // are only fulfilling ROOT's understanding for a Data Member.; // FIXME: We should probably deprecate the TClingClassInfo(fInterpreter) interface and replace it withe something; // similar as below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:170,interface,interface,170,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,3,['interface'],['interface']
Integrability,// We are not able to config tile registers since the shape to config; // is not defined yet. Emit error message and continue. The function; // would not config tile registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp:105,message,message,105,interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp,1,['message'],['message']
Integrability,"// We are not split, so our local offset will be; // added later by the i/o routines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:76,rout,routines,76,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['rout'],['routines']
Integrability,"// We are out of bounds! [Multiple var dims, See same message a few line above]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:54,message,message,54,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['message'],['message']
Integrability,// We are sorting on MDNode pointers here. For valid input IR this is ok.; // TODO: Sort on Metadata ID to avoid non-deterministic error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:137,message,messages,137,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['message'],['messages']
Integrability,// We assign consecutive id to access from different dependence sets.; // Accesses within the same set don't need a runtime check.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:53,depend,dependence,53,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependence']
Integrability,// We assume Objective-C++ message expressions are not; // primary-expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:27,message,message,27,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['message'],['message']
Integrability,// We assume that the type of the object returned by alloc and new are the; // pointer to the object of the class specified in the receiver of the; // message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:151,message,message,151,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,1,['message'],['message']
Integrability,"// We assume this is supposed to correspond to a C++0x-style; // sequentially-consistent fence (i.e. this is only usable for; // synchronization, not device I/O or anything like that). This intrinsic; // is really badly designed in the sense that in theory, there isn't; // any way to safely use it... but in practice, it mostly works; // to use it with non-atomic loads and stores to get acquire/release; // semantics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:129,synchroniz,synchronization,129,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['synchroniz'],['synchronization']
Integrability,"// We assume we've got an ""integrated"" assembler in that gcc will produce an; // object file itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:27,integrat,integrated,27,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['integrat'],['integrated']
Integrability,"// We bind ""check_if_null"" to modify the warning message; // in case it was intended to compare a pointer to 0 with a relatively-ok; // construct ""x == 0"" or ""x != 0"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:49,message,message,49,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,1,['message'],['message']
Integrability,"// We build scheduling units by walking a block's instruction list; // from bottom to top.; // Each MIs' memory operand(s) is analyzed to a list of underlying; // objects. The SU is then inserted in the SUList(s) mapped from the; // Value(s). Each Value thus gets mapped to lists of SUs depending; // on it, stores and loads kept separately. Two SUs are trivially; // non-aliasing if they both depend on only identified Values and do; // not share any common Value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:287,depend,depending,287,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,2,['depend'],"['depend', 'depending']"
Integrability,"// We build the groups from dependency candidates equivalence classes; // because:; // - We know that pointers in the same equivalence class share; // the same underlying object and therefore there is a chance; // that we can compare pointers; // - We wouldn't be able to merge two pointers for which we need; // to emit a memcheck. The classes in DepCands are already; // conveniently built such that no two pointers in the same; // class need checking against each other.; // We use the following (greedy) algorithm to construct the groups; // For every pointer in the equivalence class:; // For each existing group:; // - if the difference between this pointer and the min/max bounds; // of the group is a constant, then make the pointer part of the; // group and update the min/max bounds of that group as required.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:28,depend,dependency,28,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependency']
Integrability,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:683,wrap,wraps,683,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['wrap'],['wraps']
Integrability,// We call out to an external function to actually print the message as the; // printing code uses Allocator.h in its implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:61,message,message,61,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,1,['message'],['message']
Integrability,"// We can compute the correct backedge taken count for loops with unknown; // strides if we can prove that the loop is not an infinite loop with side; // effects. Here's the loop structure we are trying to handle -; //; // i = start; // do {; // A[i] = i;; // i += s;; // } while (i < end);; //; // The backedge taken count for such loops is evaluated as -; // (max(end, start + stride) - start - 1) /u stride; //; // The additional preconditions that we need to check to prove correctness; // of the above formula is as follows -; //; // a) IV is either nuw or nsw depending upon signedness (indicated by the; // NoWrap flag).; // b) the loop is guaranteed to be finite (e.g. is mustprogress and has; // no side effects within the loop); // c) loop has a single static exit (with no abnormal exits); //; // Precondition a) implies that if the stride is negative, this is a single; // trip loop. The backedge taken count formula reduces to zero in this case.; //; // Precondition b) and c) combine to imply that if rhs is invariant in L,; // then a zero stride means the backedge can't be taken without executing; // undefined behavior.; //; // The positive stride case is the same as isKnownPositive(Stride) returning; // true (original behavior of the function).; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:566,depend,depending,566,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['depend'],['depending']
Integrability,"// We can emit the pointer value into this slot if the slot is an; // integer slot equal to the size of the pointer.; //; // If the pointer is larger than the resultant integer, then; // as with Trunc just depend on the assembler to truncate it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:206,depend,depend,206,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['depend'],['depend']
Integrability,"// We can fuse FADD/FSUB with FMUL, if fusion is either allowed globally by; // the target options or if FADD/FSUB has the contract fast-math flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:123,contract,contract,123,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['contract'],['contract']
Integrability,// We can get a value-dependent initializer during error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:22,depend,dependent,22,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['depend'],['dependent']
Integrability,// We can have cleanups wrapping the converted expression; these need to be; // preserved so that destructors run if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:24,wrap,wrapping,24,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['wrap'],['wrapping']
Integrability,"// We can integrate over m if power = 0.5",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooArgusBG.cxx:10,integrat,integrate,10,roofit/roofit/src/RooArgusBG.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooArgusBG.cxx,1,['integrat'],['integrate']
Integrability,"// We can only build these statements, however, if the current promise type; // is not dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:87,depend,dependent,87,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependent']
Integrability,// We can only correctly find a minimum type for a scalable vector when it is; // a splat. For splats of constant values the fpext is wrapped up as a; // ConstantExpr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:134,wrap,wrapped,134,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['wrap'],['wrapped']
Integrability,// We can only handle unsigned relational comparisons because 'inbounds' on; // a GEP only protects against unsigned wrapping.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:117,wrap,wrapping,117,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['wrap'],['wrapping']
Integrability,"// We can only legally extract other elements from 128-bit vectors and in; // certain circumstances, depending on SSE-level.; // TODO: Investigate float/double extraction if it will be just stored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:101,depend,depending,101,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['depending']
Integrability,// We can only reason about control dependencies within the same stack frame.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:36,depend,dependencies,36,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['depend'],['dependencies']
Integrability,"// We can only use the 32-bit instructions if all source bits are; // in the low 32 bits without wrapping, both after rotation (because; // of the smaller range for Start and End) and before rotation; // (because the input value is truncated).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:97,wrap,wrapping,97,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['wrap'],['wrapping']
Integrability,"// We can optimistically ignore calls to functions in the same SCC, with; // two caveats:; // * Calls with operand bundles may have additional effects.; // * Argument memory accesses may imply additional effects depending on; // what the argument location is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:212,depend,depending,212,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['depend'],['depending']
Integrability,"// We can safely assume the conversion won't overflow the output range,; // because (for example) (uint8_t)18293.f is undefined behavior.; // Since we can assume the conversion won't overflow, our decision as to; // whether the input will fit in the float should depend on the minimum; // of the input range and output range.; // This means this is also safe for a signed input and unsigned output, since; // a negative input would lead to undefined behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:263,depend,depend,263,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['depend']
Integrability,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:32,wrap,wrapping,32,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,7,['wrap'],"['wrap', 'wrapping']"
Integrability,// We can use the comparison to infer no-wrap flags only if it fully; // controls the loop exit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:41,wrap,wrap,41,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// We can't PushDeclContext, because we go up and the routine that pops; // the DeclContext assumes that we drill down always.; // We have to be on the global context. At that point we are in a; // wrapper function so the parent context must be the global.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/ClingRAII.h:54,rout,routine,54,core/metacling/src/ClingRAII.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/ClingRAII.h,4,"['rout', 'wrap']","['routine', 'wrapper']"
Integrability,"// We can't PushDeclContext, because we go up and the routine that pops; // the DeclContext assumes that we drill down always.; // We have to be on the global context. At that point we are in a; // wrapper function so the parent context must be the global.; // This is needed to solve potential issues when using #include ""myFile.C+""; // after a scope declaration like:; // void Check(TObject* obj) {; // if (obj) cout << ""Found the referenced object\n"";; // else cout << ""Error: Could not find the referenced object\n"";; // }; // #include ""A.C+""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:54,rout,routine,54,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,2,"['rout', 'wrap']","['routine', 'wrapper']"
Integrability,"// We can't PushDeclContext, because we go up and the routine that; // pops the DeclContext assumes that we drill down always.; // We have to be on the global context. At that point we are in a; // wrapper function so the parent context must be the global.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ClingPragmas.cpp:54,rout,routine,54,interpreter/cling/lib/Interpreter/ClingPragmas.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ClingPragmas.cpp,2,"['rout', 'wrap']","['routine', 'wrapper']"
Integrability,"// We can't actually test that if we still have a placeholder,; // though. Fortunately, none of the exceptions we see in that; // code below are valid when the LHS is an overload set. Note; // that an overload set can be dependently-typed, but it never; // instantiates to having an overloadable type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:221,depend,dependently-typed,221,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependently-typed']
Integrability,// We can't assume anything about other targets; just use libatomic; // routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:72,rout,routines,72,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['rout'],['routines']
Integrability,// We can't check arbitrary value-dependent arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:34,depend,dependent,34,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,// We can't check dependent instance methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,depend,dependent,18,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"// We can't check the number of elements, since the argument has a; // dependent number of elements. This can only occur during partial; // ordering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:71,depend,dependent,71,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,depend,dependent,33,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,14,['depend'],['dependent']
Integrability,// We can't check this yet because the base type is still; // dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:62,depend,dependent,62,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['depend'],['dependent']
Integrability,// We can't check validity of alignment if it is value dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:55,depend,dependent,55,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['depend'],['dependent']
Integrability,"// We can't check whether an implicit destructor is deleted before we complete; // the definition of the class, because its validity depends on the alignment; // of the class. We'll check this from ActOnFields once the class is complete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:133,depend,depends,133,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['depends']
Integrability,"// We can't definitely say whether GEP1 is before or after V2 due to wrapping; // arithmetic (i.e. for some values of GEP1 and V2 GEP1 < V2, and for other; // values GEP1 > V2). We'll therefore only declare NoAlias if both V1Size and; // V2Size can fit in the MinDiffBytes gap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:69,wrap,wrapping,69,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['wrap'],['wrapping']
Integrability,// We can't do any type-checking on a type-dependent argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:43,depend,dependent,43,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,2,['depend'],['dependent']
Integrability,"// We can't extract the stride if the arithmetic is done at a different size; // than the pointer type. Adding the stride later may not wrap correctly.; // Technically we could handle wider indices, but I don't expect that in; // practice. Handle one special case here - constants. This simplifies; // writing test cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:136,wrap,wrap,136,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,1,['wrap'],['wrap']
Integrability,// We can't get dependent types here; our callers should have; // filtered them out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:16,depend,dependent,16,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['depend'],['dependent']
Integrability,// We can't jump into or indirect-jump out of a @synchronized block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:49,synchroniz,synchronized,49,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['synchroniz'],['synchronized']
Integrability,"// We can't look at FD->getPreviousDecl() because it may not have been set; // if we're in a dependent context. If the function is known to be a; // redeclaration, we will have narrowed Previous down to the right decl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:93,depend,dependent,93,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,// We can't perform any more checking for type-dependent expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:47,depend,dependent,47,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['depend'],['dependent']
Integrability,// We can't recover unless there's a dependent scope specifier preceding the; // template name.; // FIXME: Typo correction?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:37,depend,dependent,37,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// We can't reliably skip over a mem-initializer-id, because it could be; // a template-id involving not-yet-declared names. Given:; //; // S ( ) : a < b < c > ( e ); //; // 'e' might be an initializer or part of a template argument, depending; // on whether 'b' is a template.; // Track whether we might be inside a template argument. We can give; // significantly better diagnostics if we know that we're not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:234,depend,depending,234,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['depend'],['depending']
Integrability,"// We can't simply call Type::isUndeducedType here, because inside template; // auto can be deduced to a dependent type, which is not considered; // ""undeduced"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:105,depend,dependent,105,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""alignment-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,depend,dependent,22,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,4,['depend'],['dependent']
Integrability,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""type-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,depend,dependent,22,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,4,['depend'],['dependent']
Integrability,"// We can't use S->getSynchExpr()->getEndLoc() to find the end location, since; // the sync expression is typically a message expression that's already; // been rewritten! (which implies the SourceLocation's are invalid).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:118,message,message,118,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['message'],['message']
Integrability,"// We can't use an addressing mode in the 64-bit large code model.; // Global TLS addressing is an exception. In the medium code model,; // we use can use a mode when RIP wrappers are present.; // That signifies access to globals that are known to be ""near"",; // such as the GOT itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:171,wrap,wrappers,171,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['wrap'],['wrappers']
Integrability,"// We cannot add R2/X2 as an operand here for PATCHPOINT, because there is; // no way to mark dependencies as implicit here.; // We will add the R2/X2 dependency in EmitInstrWithCustomInserter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:94,depend,dependencies,94,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['depend'],"['dependencies', 'dependency']"
Integrability,"// We cannot compute offset for incomplete type.; // For unions, we could treat everything as offset 0, but we'd rather; // treat each field as a symbolic offset so they aren't stored on top; // of each other, since we depend on things in typed regions actually; // matching their types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:219,depend,depend,219,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,1,['depend'],['depend']
Integrability,"// We cannot directly use RFieldBase::RDeleter as a shared pointer deleter due to splicing. We use this; // wrapper class to store a polymorphic pointer to the actual deleter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:108,wrap,wrapper,108,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['wrap'],['wrapper']
Integrability,"// We cannot use the default THREE.Curve getPoint() with getLength() because in; // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath; // getPoint() depends on getLength",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:109,depend,depends,109,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['depend'],['depends']
Integrability,"// We check here for invalid destructor names.; // If we have a friend destructor declaration that is dependent, we can't; // diagnose right away because cases like this are still valid:; // template <class T> struct A { friend T::X::~Y(); };; // struct B { struct Y { ~Y(); }; using X = Y; };; // template struct A<B>;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:102,depend,dependent,102,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// We could append this fake main routine to the compilation line.; // But in this case compiler may output the name of the dictionary file; // and of the fakeMain file while it compiles it. (this would be useless; // confusing output).; // We could also the fake main routine to the end of the dictionary file; // however compilation would fail if a main is already there; // (like stress.cxx); // dict.Append("" "").Append(fakeMain);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:34,rout,routine,34,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,2,['rout'],['routine']
Integrability,// We create a new MCInstrInfo here since we might be at the module level; // and not have a MachineFunction to initialize the TargetInstrInfo from and; // we only need MCInstrInfo for asm parsing. We create one unconditionally; // because it's not subtarget dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:259,depend,dependent,259,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,1,['depend'],['dependent']
Integrability,// We defer the injected-class-name checks until we've found whether; // this template-id is used to form a nested-name-specifier or not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:16,inject,injected-class-name,16,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['inject'],['injected-class-name']
Integrability,// We depend on the UREM by constant optimization in DAGCombiner that requires; // high multiply.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:6,depend,depend,6,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['depend'],['depend']
Integrability,"// We did not handle HW dependences in previous for loop,; // and we normally set Latency = 0 for Anti deps,; // so may have nodes in same cycle with Anti denpendent on HW regs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:24,depend,dependences,24,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependences']
Integrability,"// We did not manage to simplify this branch, try to see whether; // CondCmp depends on a known phi-select pattern.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:77,depend,depends,77,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['depend'],['depends']
Integrability,// We did not resolve these as protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,protocol,protocols,31,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocols']
Integrability,"// We didn't find a public path, but at least one path was subject; // to dependent friendship, so delay the check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:74,depend,dependent,74,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['depend'],['dependent']
Integrability,"// We didn't find anything. If the class definition is in this module; // file, then the module files it depends on cannot have any categories,; // so suppress further lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:105,depend,depends,105,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['depend'],['depends']
Integrability,"// We didn't find our type, but that's OK: it's dependent anyway.; // FIXME: What if we have no nested-name-specifier?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:48,depend,dependent,48,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['depend'],['dependent']
Integrability,// We do allow diagnostics from unit test/example dependency checkers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:50,depend,dependency,50,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,1,['depend'],['dependency']
Integrability,"// We do not (otherwise) record whether the path was set automatically or; // whether it was set explicitly by the user. If the user set the path; // explicitly, we should never automatically over-ride the value; if; // seenCling stayed false, it would tell this routine that at the next; // call it should update the value (to insert the Cling provided parts); // back to the default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:263,rout,routine,263,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,1,['rout'],['routine']
Integrability,"// We do not expect that forgetting cached data for SCEVConstants will ever; // open any prospects for sharpening or introduce any correctness issues,; // so we don't bother storing their dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:188,depend,dependencies,188,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['depend'],['dependencies']
Integrability,"// We do not know at CFG-construction time whether the right-hand-side was; // executed, thus we add a branch node that depends on the temporary; // constructor call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:120,depend,depends,120,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['depend'],['depends']
Integrability,// We do not need to track any dependencies for constant registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:31,depend,dependencies,31,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['depend'],['dependencies']
Integrability,"// We do not offer misspelled character names suggestions here; // as the set of what would be a valid suggestion depends on context,; // and we should not make invalid suggestions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:114,depend,depends,114,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['depend'],['depends']
Integrability,// We do not store dependencies of constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:19,depend,dependencies,19,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['depend'],['dependencies']
Integrability,"// We do not support linker redefined symbols (e.g. --wrap) for device; // image linking, so the symbols will not be changed after LTO.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:54,wrap,wrap,54,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,1,['wrap'],['wrap']
Integrability,"// We do this only once because it depends only on; // the type of our object, not on its address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:35,depend,depends,35,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['depend'],['depends']
Integrability,"// We don't actually care about the order, but for consistency it; // shouldn't depend on pointer comparisons.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp:80,depend,depend,80,interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp,1,['depend'],['depend']
Integrability,"// We don't bother trying to simplify unless all of the operands; // were constant.; // TODO: There are a lot of Simplify*'s we could call here, if we; // wanted to. The original motivating case for this code was a; // zext i1 false to i8, which we don't have an interface to; // simplify (IE there is no SimplifyZExt).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:263,interface,interface,263,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['interface'],['interface']
Integrability,"// We don't care if this analysis itself is preserved, it has no state. But; // we need to check that the analyses it depends on have been.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:118,depend,depends,118,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,1,['depend'],['depends']
Integrability,"// We don't care if this analysis itself is preserved, it has no state. But; // we need to check that the analyses it depends on have been. Note that we; // may be created without handles to some analyses and in that case don't; // depend on them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:118,depend,depends,118,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,2,['depend'],"['depend', 'depends']"
Integrability,"// We don't check for an invalid 'self' in an obj-c message expression to cut; // down false positives where logging functions get information from self; // (like its class) or doing ""invalidation"" on self when the initialization; // fails.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:52,message,message,52,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,1,['message'],['message']
Integrability,"// We don't check wrapping here because we don't know yet if Ptr will be; // part of a full group or a group with gaps. Checking wrapping for all; // pointers (even those that end up in groups with no gaps) will be overly; // conservative. For full groups, wrapping should be ok since if we would; // wrap around the address space we would do a memory access at nullptr; // even without the transformation. The wrapping checks are therefore; // deferred until after we've formed the interleaved groups.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:18,wrap,wrapping,18,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,5,['wrap'],"['wrap', 'wrapping']"
Integrability,"// We don't handle non-definitions. If we already have a call, reject; // instruction dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:86,depend,dependencies,86,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['depend'],['dependencies']
Integrability,"// We don't have a varied RDefine for this variation.; // This means we don't depend on it and we can return ourselves, i.e. the RDefine for the nominal universe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx:78,depend,depend,78,tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx,2,['depend'],['depend']
Integrability,"// We don't have to recheck for duplication of the UsingEnumDecl itself, as it; // cannot be dependent, and will therefore have been checked during template; // definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:93,depend,dependent,93,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['depend'],['dependent']
Integrability,"// We don't know the concrete type, fallback to dependent type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:48,depend,dependent,48,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependent']
Integrability,"// We don't necessarily build correct LLVM struct types for ObjC; // interfaces, so we can't rely on GEP to do this scaling; // correctly, so we need to cast to i8*. FIXME: is this actually; // true? A lot of other things in the fragile ABI would break...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:69,interface,interfaces,69,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['interface'],['interfaces']
Integrability,// We don't need to bother trying to break a dependency if this; // instruction has a true dependency on that register through another; // operand - we'll have to wait for it to be available regardless.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:45,depend,dependency,45,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,2,['depend'],['dependency']
Integrability,// We don't need to check non-wrapping here because forward/backward; // dependence wouldn't be valid if these weren't monotonic accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:30,wrap,wrapping,30,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,2,"['depend', 'wrap']","['dependence', 'wrapping']"
Integrability,// We don't want to check PacketMI for dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:39,depend,dependence,39,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependence']
Integrability,"// We don't want to consider the function itself; // Mark all args that are (indirect) value servers of the integration; // variable or the integration variable itself. If something was marked,; // it means the integration variable was in the compute graph and we will; // add it to the server list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:108,integrat,integration,108,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,3,['integrat'],['integration']
Integrability,"// We don't want to generate duplicated error messages in several dictionaries (when generating temporaries)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:46,message,messages,46,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['message'],['messages']
Integrability,"// We don't want to put in the same block; // two high latency instructions that depend; // on each other.; // One way would be to check canAddEdge; // in both directions, but that currently is not; // enough because there the high latency order is; // enforced (via links).; // Instead, look at the dependencies between the; // high latency instructions and deduce if it is; // a data dependency or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:81,depend,depend,81,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,3,['depend'],"['depend', 'dependencies', 'dependency']"
Integrability,"// We don't want to track the block through assignments and so on, instead; // we simply see how the block used and if it's used directly in a call,; // we decide based on call to what it is.; //; // In order to do this, we go up the parents of the block looking for; // a call or a message expressions. These might not be immediate parents; // of the actual block expression due to casts and parens, so we skip them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:283,message,message,283,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['message'],['message']
Integrability,"// We emit a hard dependency on the __xray_CustomEvent symbol, which is the; // name of the trampoline to be implemented by the XRay runtime.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp:18,depend,dependency,18,interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,1,['depend'],['dependency']
Integrability,"// We emit a hard dependency on the __xray_TypedEvent symbol, which is the; // name of the trampoline to be implemented by the XRay runtime.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp:18,depend,dependency,18,interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,1,['depend'],['dependency']
Integrability,"// We emit callback to LibraryLoadingFailed when we get error with error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManager.cpp:73,message,message,73,interpreter/cling/lib/Interpreter/DynamicLibraryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManager.cpp,2,['message'],['message']
Integrability,"// We emit the value and depend on the assembler to truncate the generated; // expression properly. This is important for differences between; // blockaddress labels. Since the two labels are in the same function, it; // is reasonable to treat their delta as a 32-bit value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:25,depend,depend,25,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,2,['depend'],['depend']
Integrability,// We exclude all exception handling cases since they are so context; // dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:73,depend,dependent,73,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,2,['depend'],['dependent']
Integrability,"// We expect to have the same number of input dependences and device tool; // chains, except if we also have a host dependence. In that case we have one; // more dependence than we have device tool chains.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Action.cpp:46,depend,dependences,46,interpreter/llvm-project/clang/lib/Driver/Action.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Action.cpp,3,['depend'],"['dependence', 'dependences']"
Integrability,"// We expect zero and -1 to be invalid addresses in DWARF depending; // on the linker of the DWARF. This indicates a function was stripped; // and the debug info wasn't able to be stripped from the DWARF. If; // the LowPC isn't zero or -1, then we should emit an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp:58,depend,depending,58,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,1,['depend'],['depending']
Integrability,"// We failed to load one of the dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:32,depend,dependency,32,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['depend'],['dependency']
Integrability,"// We first collect all declarations that should not throw but not declared; // with noexcept. We then sort them based on the location before printing.; // This is to avoid emitting the same note multiple times on the same; // declaration, and also provide a deterministic order for the messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:287,message,messages,287,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['message'],['messages']
Integrability,// We found a div wrapping a cell content whose height exceeds ; // CLIP_HEIGHT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scripts/expandcollapse.js:18,wrap,wrapping,18,interpreter/llvm-project/clang/www/analyzer/scripts/expandcollapse.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scripts/expandcollapse.js,1,['wrap'],['wrapping']
Integrability,"// We found a pointer that isn't null, but doesn't refer to an object.; // We could just return NPV_NotNullPointer, but we can print a better; // message with the information we have here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:146,message,message,146,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['message'],['message']
Integrability,// We found a similarly-named type or interface; suggest that.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,interface,interface,38,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['interface'],['interface']
Integrability,// We found a true dependency - replace the undef register with the true; // dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:19,depend,dependency,19,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,2,['depend'],['dependency']
Integrability,// We found a usable declaration of the name in a dependent base of some; // enclosing class.; // FIXME: We should also explain why the candidates found by name lookup; // were not viable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:50,depend,dependent,50,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['depend'],['dependent']
Integrability,// We found an override at this category; there is no need to look; // into its protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:80,protocol,protocols,80,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['protocol'],['protocols']
Integrability,// We found an override at this level; there is no need to look; // into other protocols or categories.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:79,protocol,protocols,79,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['protocol'],['protocols']
Integrability,// We found some types in dependent base classes. Recover as if the user; // wrote 'typename MyClass::II' instead of 'II'. We'll fully resolve the; // lookup during template instantiation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:26,depend,dependent,26,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// We found something. If it's a type, then we have a class; // message. Otherwise, it's an instance message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:64,message,message,64,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,2,['message'],['message']
Integrability,"// We found two dependencies, so bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:16,depend,dependencies,16,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['depend'],['dependencies']
Integrability,"// We got an expr, wrap it up in parens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:19,wrap,wrap,19,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['wrap'],['wrap']
Integrability,// We had a dependent elaborated-type-specifier that has been transformed; // into a non-dependent elaborated-type-specifier. Find the tag we're; // referring to.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:12,depend,dependent,12,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['depend'],['dependent']
Integrability,"// We have a GCC style pragma message, and we just read the string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:30,message,message,30,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['message'],['message']
Integrability,// We have a MSVC style pragma message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:31,message,message,31,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['message'],['message']
Integrability,"// We have a class message, and T is the type we're; // messaging. Build source-location information for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:19,message,message,19,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['message'],['message']
Integrability,// We have a class message. Turn the simple-type-specifier or; // typename-specifier we parsed into a type and parse the; // remainder of the class message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:19,message,message,19,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,2,['message'],['message']
Integrability,"// We have a class type.; // Note: This cannot happen due to the rd->IsObject() test above.; // FIXME: Put an error message here just in case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:116,message,message,116,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['message'],['message']
Integrability,// We have a conflict: some names refer to protocols and others; // refer to types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:43,protocol,protocols,43,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocols']
Integrability,"// We have a function template; // template <class X = int, int i = 7> void func(int a0, X a1[i], X::type a2[i]); // which has defaults for all its template parameters `X` and `i`. To; // instantiate it we have to do a lookup, which in turn needs the function; // argument types, e.g. `int[12]`.; // If the function argument type is dependent (a1 and a2) we need to; // substitute the types first, using the template arguments derived from the; // template parameters' defaults.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx:333,depend,dependent,333,core/metacling/src/TClingMethodInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx,1,['depend'],['dependent']
Integrability,"// We have a hit - Var0 and Var1 only differ by a constant offset!; // If we've been sext'ed then zext'd the maximum difference between Var0 and; // Var1 is possible to calculate, but we're just interested in the absolute; // minimum difference between the two. The minimum distance may occur due to; // wrapping; consider ""add i3 %i, 5"": if %i == 7 then 7 + 5 mod 8 == 4, and so; // the minimum distance between %i and %i + 5 is 3.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:304,wrap,wrapping,304,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['wrap'],['wrapping']
Integrability,"// We have a qualified template-id, e.g., N::A<int>; // If this would be a valid constructor declaration with template; // arguments, we will reject the attempt to form an invalid type-id; // referring to the injected-class-name when we annotate the token,; // per C++ [class.qual]p2.; //; // To improve diagnostics for this case, parse the declaration as a; // constructor (and reject the extra template arguments later).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:209,inject,injected-class-name,209,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['inject'],['injected-class-name']
Integrability,"// We have a series of f+1 checks as:; //; // I+k_0 u< L ... Chk_0; // I+k_1 u< L ... Chk_1; // ...; // I+k_f u< L ... Chk_f; //; // with forall i in [0,f]: k_f-k_i u< k_f-k_0 ... Precond_0; // k_f-k_0 u< INT_MIN+k_f ... Precond_1; // k_f != k_0 ... Precond_2; //; // Claim:; // Chk_0 AND Chk_f implies all the other checks; //; // Informal proof sketch:; //; // We will show that the integer range [I+k_0,I+k_f] does not unsigned-wrap; // (i.e. going from I+k_0 to I+k_f does not cross the -1,0 boundary) and; // thus I+k_f is the greatest unsigned value in that range.; //; // This combined with Ckh_(f+1) shows that everything in that range is u< L.; // Via Precond_0 we know that all of the indices in Chk_0 through Chk_(f+1); // lie in [I+k_0,I+k_f], this proving our claim.; //; // To see that [I+k_0,I+k_f] is not a wrapping range, note that there are; // two possibilities: I+k_0 u< I+k_f or I+k_0 >u I+k_f (they can't be equal; // since k_0 != k_f). In the former case, [I+k_0,I+k_f] is not a wrapping; // range by definition, and the latter case is impossible:; //; // 0-----I+k_f---I+k_0----L---INT_MAX,INT_MIN------------------(-1); // xxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; //; // For Chk_0 to succeed, we'd have to have k_f-k_0 (the range highlighted; // with 'x' above) to be at least >u INT_MIN.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:431,wrap,wrap,431,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,3,['wrap'],"['wrap', 'wrapping']"
Integrability,"// We have a template parameter list with no corresponding scope, which; // means that the resulting template declaration can't be instantiated; // properly (we'll end up with dependent nodes when we shouldn't).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:176,depend,dependent,176,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,// We have a type parameter list that looks like a list of protocol; // references. Turn that parameter list into type parameters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:59,protocol,protocol,59,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocol']
Integrability,"// We have an emulated class that has no TStreamerInfo, this; // means it was created to insert a (default) rule. Consequently; // the error message about the missing dictionary was not printed.; // For consistency, let's print it now!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:141,message,message,141,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['message'],['message']
Integrability,"// We have dedicated lowering for unpredicated uniform loads and; // stores. Note that even with tail folding we know that at least; // one lane is active (i.e. generalized predication is not possible; // here), and the logic below depends on this fact.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:232,depend,depends,232,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['depend'],['depends']
Integrability,// We have dependences we need to bundle together. We use an offload action; // for that.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:11,depend,dependences,11,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['dependences']
Integrability,// We have identified all uses of GV into loads and stores. Now check if all; // of them are known not to depend on the value of the global at the function; // entry point. We do this by ensuring that every load is dominated by at; // least one store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:106,depend,depend,106,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['depend'],['depend']
Integrability,"// We have no rootmap files or modules to construct `-l` flags enabling; // explicit linking. We have to resolve the dependencies by ourselves; // taking the job of the dyld.; // FIXME: This is a rare case where we have rootcling running with; // modules disabled. Remove this code once we fully switch to modules,; // or implement a special flag in rootcling which selective enables; // modules for dependent libraries and does not produce a module for; // the ACLiC library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:117,depend,dependencies,117,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,2,['depend'],"['dependencies', 'dependent']"
Integrability,"// We have only had PP directives; no need to wrap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:46,wrap,wrap,46,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['wrap'],['wrap']
Integrability,"// We have some deduction failure messages. Use them to diagnose; // the function templates, and diagnose the non-template candidates; // normally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:34,message,messages,34,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['message'],['messages']
Integrability,"// We have something like t->getAs<T>(), where getAs is a; // member of an unknown specialization. However, this will only; // parse correctly as a template, so suggest the keyword 'template'; // before 'getAs' and treat this as a dependent template name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:231,depend,dependent,231,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['depend'],['dependent']
Integrability,"// We have something like t::getAs<T>, where getAs is a; // member of an unknown specialization. However, this will only; // parse correctly as a template, so suggest the keyword 'template'; // before 'getAs' and treat this as a dependent template name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:229,depend,dependent,229,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['depend'],['dependent']
Integrability,"// We have the array delete wrapper, use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:28,wrap,wrapper,28,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['wrap'],['wrapper']
Integrability,"// We have the delete wrapper, use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:22,wrap,wrapper,22,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['wrap'],['wrapper']
Integrability,"// We have the destructor wrapper, use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:26,wrap,wrapper,26,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['wrap'],['wrapper']
Integrability,"// We have the dictionary but do not have the constructor wrapper,; // so the dictionary was not generated by rootcint (it was made either; // by cint or by some external mechanism). Let's try to create the; // object by having the interpreter call the new operator, either the; // class library is loaded and there is a default constructor we can; // call, or the class is interpreted and we will call the default; // constructor that way, or no default constructor is available and; // we fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:58,wrap,wrapper,58,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['wrap'],['wrapper']
Integrability,"// We have the dictionary but do not have the; // array delete wrapper, so the dictionary was; // not generated by rootcint. Let's try to; // delete the array by having the interpreter; // call the array delete operator, hopefully; // the class library is loaded and there will be; // a destructor we can call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:63,wrap,wrapper,63,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['wrap'],['wrapper']
Integrability,"// We have the dictionary but do not have the; // constructor wrapper, so the dictionary was; // not generated by rootcint. Let's try to; // create the object by having the interpreter; // call the new operator, hopefully the class; // library is loaded and there will be a default; // constructor we can call.; // [This is very unlikely to work, but who knows!]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:62,wrap,wrapper,62,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,3,['wrap'],['wrapper']
Integrability,"// We have the dictionary but do not have the; // destruct/delete wrapper, so the dictionary was; // not generated by rootcint (it could have been; // created by cint or by some external mechanism).; // Let's have the interpreter call the destructor,; // either the code will be in a loaded library,; // or it will be interpreted, otherwise we fail; // because there is no destructor code at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:66,wrap,wrapper,66,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['wrap'],['wrapper']
Integrability,// We have the method which returns a struct/union. Must also generate; // call to objc_msgSend_stret and hang both varieties on a conditional; // expression which dictate which one to envoke depending on size of; // method's return type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:192,depend,depending,192,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['depend'],['depending']
Integrability,"// We have the new operator wrapper function,; // so there is a dictionary and it was generated; // by rootcint, so there should be a default; // constructor we can call through the wrapper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:28,wrap,wrapper,28,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,8,['wrap'],['wrapper']
Integrability,"// We have the offset of a field, but we can't look into the dependent; // type. Just record the identifier of the field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:61,depend,dependent,61,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependent']
Integrability,"// We have the wrapper as Sema's CurContext",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp:15,wrap,wrapper,15,interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp,1,['wrap'],['wrapper']
Integrability,"// We have to be able to save if statements to execute later, and they have; // to live on the same stack as foreach loops. The simplest implementation; // technique is to convert each 'then' or 'else' clause *into* a foreach; // loop, over a list of length 0 or 1 depending on the condition, and with no; // iteration variable being assigned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:265,depend,depending,265,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['depend'],['depending']
Integrability,// We have to be conservative when checking a template in a dependent; // context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:60,depend,dependent,60,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// We have to create a placed volume from the unplaced one to have access; // to the navigation interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/vecgeom/src/TGeoVGShape.cxx:96,interface,interface,96,geom/vecgeom/src/TGeoVGShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/vecgeom/src/TGeoVGShape.cxx,1,['interface'],['interface']
Integrability,"// We have to exit early if the message stream is not active. Otherwise it's; // possible that this function skips logging because it thinks it has; // already logged, but actually it didn't.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Evaluator.cxx:32,message,message,32,roofit/roofitcore/src/RooFit/Evaluator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Evaluator.cxx,1,['message'],['message']
Integrability,// We have to explicitly define this move operator to copy the fields in; // reverse order (i.e. module first) to ensure the dependencies are; // protected: The old module that is being overwritten must be destroyed; // *before* the context that it depends on.; // We also need to lock the context to make sure the module tear-down; // does not overlap any other work on the context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h:125,depend,dependencies,125,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h,2,['depend'],"['dependencies', 'depends']"
Integrability,// We have to explicitly provide ++ and -- rather than letting the facade; // forward to += because WrappedIteratorT might not support +=.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:100,Wrap,WrappedIteratorT,100,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,1,['Wrap'],['WrappedIteratorT']
Integrability,"// We have to make sure no-alias on the argument does not break; // synchronization when this is a callback argument, see also [1] below.; // If synchronization cannot be affected, we delegate to the base updateImpl; // function, otherwise we give up for now.; // If the function is no-sync, no-alias cannot break synchronization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:68,synchroniz,synchronization,68,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,3,['synchroniz'],['synchronization']
Integrability,"// We have wrapped and need to disable warnings that are caused by; // non-default C++ at the prompt:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:11,wrap,wrapped,11,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['wrap'],['wrapped']
Integrability,"// We have; //; // template-id '::'; //; // So we need to check whether the template-id is a simple-template-id of; // the right kind (it should name a type or be dependent), and then; // convert it into a type within the nested-name-specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:163,depend,dependent,163,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['depend'],['dependent']
Integrability,// We increment the counter only if the locations are aliased; // (instead of counting all alias checks). This gives a better; // balance between reduced runtime and accurate dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:175,depend,dependencies,175,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependencies']
Integrability,// We just return an empty result. The caller will use the updateFAM interface; // to correctly register the relevant FunctionAnalysisManager based on the; // context in which this proxy is run.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:69,interface,interface,69,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,1,['interface'],['interface']
Integrability,"// We just test that the wrapper compiles. This is a regression test to make sure; // we never try to cast a member function as we do above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingCallFuncTests.cxx:25,wrap,wrapper,25,core/metacling/test/TClingCallFuncTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingCallFuncTests.cxx,1,['wrap'],['wrapper']
Integrability,// We just went back in time and modified history; the; // liveness information for the anti-dependence reg is now; // inconsistent. Set the state as if it were dead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:93,depend,dependence,93,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['depend'],['dependence']
Integrability,"// We know S is for Ptr, the operand on a load/store, so doesn't wrap.; // If both parts are NonNegative, the end result will be NonNegative",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:65,wrap,wrap,65,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['wrap'],['wrap']
Integrability,"// We know from the grammar that this name refers to a type,; // so build a dependent node to describe the type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:76,depend,dependent,76,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// We know that the function pass couldn't have invalidated any other; // function's analyses (that's the contract of a function pass), so; // directly handle the function analysis manager's invalidation here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:106,contract,contract,106,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,2,['contract'],['contract']
Integrability,"// We know that the loop pass couldn't have invalidated any other; // loop's analyses (that's the contract of a loop pass), so directly; // handle the loop analysis manager's invalidation here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:98,contract,contract,98,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,1,['contract'],['contract']
Integrability,"// We know that there is no self-wrap. Let's take Start and End values and; // look at all intermediate values V1, V2, ..., Vn that IndVar takes during; // the iteration. They either lie inside the range [Min(Start, End),; // Max(Start, End)] or outside it:; //; // Case 1: RangeMin ... Start V1 ... VN End ... RangeMax;; // Case 2: RangeMin Vk ... V1 Start ... End Vn ... Vk + 1 RangeMax;; //; // No self wrap flag guarantees that the intermediate values cannot be BOTH; // outside and inside the range [Min(Start, End), Max(Start, End)]. Using that; // knowledge, let's try to prove that we are dealing with Case 1. It is so if; // Start <= End and step is positive, or Start >= End and step is negative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:33,wrap,wrap,33,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['wrap'],['wrap']
Integrability,"// We know that this read depends on all the writes in DependentWrites.; // For each write, check if we have ReadAdvance information, and use it; // to figure out in how many cycles this read will be available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp:26,depend,depends,26,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,2,"['Depend', 'depend']","['DependentWrites', 'depends']"
Integrability,"// We know we have a ""Constant"" argument. But we want to only; // return true for manifest constants, not those that depend on; // constants with unknowable values, e.g. GlobalValue or BlockAddress.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:117,depend,depend,117,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['depend'],['depend']
Integrability,"// We let objc ivars without warning, objc interfaces generally are not used; // for padding tricks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:43,interface,interfaces,43,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['interface'],['interfaces']
Integrability,"// We look for instructions that write S registers that are then read as; // D/Q registers. These can only be caused by COPY, INSERT_SUBREG and; // REG_SEQUENCE pseudos that insert an SPR value into a DPR register or; // merge two SPR values to form a DPR register. In order avoid false; // positives we make sure that there is an SPR producer so we look past; // COPY and PHI nodes to find it.; //; // The best code pattern for when an SPR producer is going to be used by a; // DPR or QPR consumer depends on whether the other lanes of the; // corresponding DPR/QPR are currently defined.; //; // We can handle these efficiently, depending on the type of; // pseudo-instruction that is producing the pattern; //; // * COPY: * VDUP all lanes and merge the results together; // using VEXTs.; //; // * INSERT_SUBREG: * If the SPR value was originally in another DPR/QPR; // lane, and the other lane(s) of the DPR/QPR register; // that we are inserting in are undefined, use the; // original DPR/QPR value.; // * Otherwise, fall back on the same stategy as COPY.; //; // * REG_SEQUENCE: * If all except one of the input operands are; // IMPLICIT_DEFs, insert the VDUP pattern for just the; // defined input operand; // * Otherwise, fall back on the same stategy as COPY.; //; // First, get all the reads of D-registers done by this instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp:499,depend,depends,499,interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp,2,['depend'],"['depending', 'depends']"
Integrability,"// We look into the AST of the case statement to determine which; // enumerator was named. Alternatively, we could compute the value of; // the integral constant expression, then compare it against the; // values of each enumerator. However, value-based approach would not; // work as well with C++ templates where enumerators declared within a; // template are type- and value-dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:378,depend,dependent,378,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['depend'],['dependent']
Integrability,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:31,depend,dependency,31,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,5,['depend'],"['dependence', 'dependency']"
Integrability,"// We mark this instruction as zero-cost because the cost of GEPs in; // vectorized code depends on whether the corresponding memory instruction; // is scalarized or not. Therefore, we handle GEPs with the memory; // instruction cost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:89,depend,depends,89,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['depend'],['depends']
Integrability,"// We mask write here to teach later passes that the ith element of this; // vector is undef. Thus we can use it to reduce 128 bits reg usage,; // break false dependencies and additionally make assembly easier to read.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp:159,depend,dependencies,159,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,1,['depend'],['dependencies']
Integrability,// We may have a (non-dependent) template name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:22,depend,dependent,22,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['depend'],['dependent']
Integrability,"// We may have added values to the cache list before this PHI translation.; // If so, we haven't done anything to ensure that the cache remains sorted.; // Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the cache; // value will only see properly sorted cache arrays.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:255,rout,routines,255,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['rout'],['routines']
Integrability,"// We may have an umbrella and forgot to add the flag. Downgrade the; // warning into an information message.; // FIXME: We should open the umbrella, extract the set of header files; // and check if they exist in the modulemap.; // FIXME: We should also check if the header files are specified in the; // modulemap file as they appeared in the rootcling invocation, i.e.; // if we passed rootcling ... -I/some/path somedir/some/header, the; // modulemap should contain module M { header ""somedir/some/header"" }; // This way we will make sure the module is properly activated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:101,message,message,101,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['message'],['message']
Integrability,"// We may have found the injected-class-name of a class template,; // class template partial specialization, or class template specialization.; // In these cases, grab the template that is being defined or specialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:25,inject,injected-class-name,25,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['inject'],['injected-class-name']
Integrability,"// We may have unresolved symbols. Use dyld to resolve the dependent; // libraries and relink.; // FIXME: We will likely have duplicated libraries as we are appending; // FIXME: This likely makes rootcling --lib-list-prefix redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:59,depend,dependent,59,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['depend'],['dependent']
Integrability,"// We may need to add the step a number of times, depending on the unroll; // factor. The last of those goes into the PHI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:50,depend,depending,50,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,1,['depend'],['depending']
Integrability,"// We may need to generate one of these, depending on the type and sign of the; // input:; // DstReg = SMOV Src0, Lane;; // NewReg = UMOV Src0, Lane; DstReg = SUBREG_TO_REG NewReg, sub_32;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:41,depend,depending,41,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['depend'],['depending']
Integrability,"// We may not know the UseMI of this dependency, if it came from the; // live-in list. SchedModel can handle a NULL UseMI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:37,depend,dependency,37,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['depend'],['dependency']
Integrability,"// We may now overlap, although the overlap is not complete. There might also; // be other incomplete overlaps, and together, they might cover the complete; // dead store.; // Note: The correctness of this logic depends on the fact that this function; // is not even called providing DepWrite when there are any intervening reads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:212,depend,depends,212,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['depend'],['depends']
Integrability,"// We might be live, depending on the liveness of Use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:21,depend,depending,21,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['depend'],['depending']
Integrability,"// We might be live, depending on the liveness of Use. If any; // sub-value is live, then the entire value is considered live. This; // is a conservative choice, and better tracking is possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:21,depend,depending,21,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['depend'],['depending']
Integrability,// We might have a control-dependent range information for this context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:27,depend,dependent,27,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['depend'],['dependent']
Integrability,"// We might have either a ConstantArrayType or a VariableArrayType now:; // a ConstantArrayType is allowed to have an element type which is a; // VariableArrayType if the type is dependent. Fortunately, all array; // types have the same location layout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:179,depend,dependent,179,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependent']
Integrability,"// We model implicit conversions as combining the dependence of their; // subexpression, apart from its type, with the semantic portion of the; // target type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:50,depend,dependence,50,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,1,['depend'],['dependence']
Integrability,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:890,synchroniz,synchronization,890,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['synchroniz'],['synchronization']
Integrability,"// We must ensure that this sequence is dominated by the prologue.; // FIXME: This is a bit of a big hammer since we don't get the benefits; // of shrink-wrapping whenever we emit this instruction. Considering; // this is used in any function where we emit a jump table, this may be; // a significant limitation. We should consider inserting this in the; // block where it is used and then commoning this sequence up if it; // appears in multiple places.; // Note: on ISA 3.0 cores, we can use lnia (addpcis) instead of; // MovePCtoLR8.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:154,wrap,wrapping,154,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['wrap'],['wrapping']
Integrability,// We must have either an array designator now or an objc message send.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:58,message,message,58,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,1,['message'],['message']
Integrability,// We must match the FunctionDecl's type to the hack introduced in; // RebuildUnknownAnyExpr::VisitCallExpr to vararg functions of unknown; // type. See the lengthy commentary in that routine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:184,rout,routine,184,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['rout'],['routine']
Integrability,"// We must not publish this objects to the list of RecursiveRemove (indirectly done; // by 'Appending' this object to it's mother) before the object is completely; // initialized.; // However a better option would be to delay the publishing until the very end,; // but it is currently done in the middle of the initialization (by Build which; // is a public interface) ....",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx:358,interface,interface,358,io/io/src/TDirectoryFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx,1,['interface'],['interface']
Integrability,// We must select between the MIPS32r6/MIPS64r6 BALC (which is a normal; // instruction) and the pre-MIPS32r6/MIPS64r6 definition (which is an; // pseudo-instruction wrapping BGEZAL).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:166,wrap,wrapping,166,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,1,['wrap'],['wrapping']
Integrability,// We naively assume that all def'ed registers of an instruction have; // a data dependency on all of their operands.; // FIXME: Do a more careful analysis of x86 to build a conservative; // model here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:81,depend,dependency,81,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['depend'],['dependency']
Integrability,// We need at least one -MT equivalent for the generator of make dependency; // files to work.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:65,depend,dependency,65,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,1,['depend'],['dependency']
Integrability,"// We need the dictionary initialization but we don't want to inject the; // declarations into the interpreter, except for those we really need for; // I/O; see rootcling.cxx after the call to TCling__GetInterpreter().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:62,inject,inject,62,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['inject'],['inject']
Integrability,// We need to check that merging these stores does not cause a loop in the; // DAG. Any store candidate may depend on another candidate indirectly through; // its operands. Check in parallel by searching up from operands of candidates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:108,depend,depend,108,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['depend']
Integrability,"// We need to check the dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:24,depend,dependencies,24,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['depend'],['dependencies']
Integrability,"// We need to communicate this to our CUDA/HIP header wrapper, which in turn; // informs the proper CUDA/HIP headers of this choice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:54,wrap,wrapper,54,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,1,['wrap'],['wrapper']
Integrability,"// We need to compute an access strategy for this bit-field. We are given the; // offset to the first byte in the bit-field, the sub-byte offset is taken; // from the original layout. We reuse the normal bit-field access strategy by; // treating this as an access to a struct where the bit-field is in byte 0,; // and adjust the containing type size as appropriate.; //; // FIXME: Note that currently we make a very conservative estimate of the; // alignment of the bit-field, because (a) it is not clear what guarantees the; // runtime makes us, and (b) we don't have a way to specify that the struct is; // at an alignment plus offset.; //; // Note, there is a subtle invariant here: we can only call this routine on; // non-synthesized ivars but we may be called for synthesized ivars. However,; // a synthesized ivar can never be a bit-field, so this is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp:708,rout,routine,708,interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp,1,['rout'],['routine']
Integrability,"// We need to create at most two routing blocks per entry: one for; // predecessors outside the loop and one for predecessors inside the loop.; // This map stores; // <<loop entry, Predecessor is within the loop?>, routing block>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:33,rout,routing,33,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,2,['rout'],['routing']
Integrability,"// We need to emit a new custom wrapper wrapping the stmts",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:32,wrap,wrapper,32,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,2,['wrap'],"['wrapper', 'wrapping']"
Integrability,"// We need to emit only one of these. The prevailing module will keep it,; // but turned into a weak, while the others will drop it when possible.; // This is both a compile-time optimization and a correctness; // transformation. This is necessary for correctness when we have exported; // a reference - we need to convert the linkonce to weak to; // ensure a copy is kept to satisfy the exported reference.; // FIXME: We may want to split the compile time and correctness; // aspects into separate routines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:499,rout,routines,499,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['rout'],['routines']
Integrability,// We need to inject some bytes before the member we just wrote but after; // the previous member. Save off the length of the member we just wrote so; // that we can do validate it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp:14,inject,inject,14,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp,1,['inject'],['inject']
Integrability,// We need to invalidate if we have either failed to preserve this analyses; // result directly or if any of its dependencies have been invalidated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:113,depend,dependencies,113,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['depend'],['dependencies']
Integrability,"// We need to keep track of the last label we emitted (only one) because; // depending on whether the label is on the same line as an aligned; // instruction or not, the label may refer to the instruction or the nop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h:77,depend,depending,77,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h,1,['depend'],['depending']
Integrability,"// We need to know the type of the pointer in order to add an integer to it.; // Depending on the type, different amount of bytes is added.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:81,Depend,Depending,81,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['Depend'],['Depending']
Integrability,// We need to look in the @interface to see if the @property was; // already declared.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:27,interface,interface,27,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['interface'],['interface']
Integrability,"// We need to lookup by the pointer to the object wrapped by zmq::socket_t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/src/ZeroMQPoller.cpp:50,wrap,wrapped,50,roofit/roofitZMQ/src/ZeroMQPoller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/src/ZeroMQPoller.cpp,2,['wrap'],['wrapped']
Integrability,"// We need to override the default register parsing for GPRs and FPRs; // because the interpretation depends on VT. The internal names of; // the registers are also different from the external names; // (F0D and F0S instead of F0, etc.).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:101,depend,depends,101,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['depend'],['depends']
Integrability,// We need to return the rewritten expression to handle cases where the; // BlockDeclRefExpr is embedded in another expression being rewritten.; // For example:; //; // int main() {; // __block Foo *f;; // __block int i;; //; // void (^myblock)() = ^() {; // [f test]; // f is a BlockDeclRefExpr embedded in a message (which is being rewritten).; // i = 77;; // };; //},MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:310,message,message,310,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,1,['message'],['message']
Integrability,// We need to return the rewritten expression to handle cases where the; // DeclRefExpr is embedded in another expression being rewritten.; // For example:; //; // int main() {; // __block Foo *f;; // __block int i;; //; // void (^myblock)() = ^() {; // [f test]; // f is a DeclRefExpr embedded in a message (which is being rewritten).; // i = 77;; // };; //},MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:300,message,message,300,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,1,['message'],['message']
Integrability,// We need to save the copied-in variables in nested; // blocks because it is needed at the end for some of the API generations.; // See SynthesizeBlockLiterals routine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:161,rout,routine,161,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['rout'],['routine']
Integrability,"// We need to untag stack frames as we unwind past them. That is the job of; // the personality function wrapper, which either wraps an existing; // personality function or acts as a personality function on its own. Each; // function that has a personality function or that can be unwound past has; // its personality function changed to a thunk that calls the personality; // function wrapper in the runtime.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:105,wrap,wrapper,105,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,3,['wrap'],"['wrapper', 'wraps']"
Integrability,// We need to wrap around the index to fit it inside the buffer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:14,wrap,wrap,14,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,1,['wrap'],['wrap']
Integrability,// We never wrap type sugar around a PackExpansionType.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:12,wrap,wrap,12,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['wrap'],['wrap']
Integrability,// We only care for dependencies to predicated instructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:20,depend,dependencies,20,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependencies']
Integrability,"// We only depend on liveness. DeadEdges is all we care about, check if any; // of them changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:11,depend,depend,11,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['depend'],['depend']
Integrability,"// We only have a limited number of bits to encode command IDs in the; // CommandInfo structure, so the ID numbers can potentially wrap around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp:131,wrap,wrap,131,interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp,1,['wrap'],['wrap']
Integrability,// We only need the size as part of the type if it's instantiation-dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:67,depend,dependent,67,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['depend'],['dependent']
Integrability,"// We only resolve DependentTy, or undeduced autos (including auto* etc).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Depend,DependentTy,19,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['Depend'],['DependentTy']
Integrability,"// We only syntactically depend on the constraint arguments. They don't; // affect the deduced type, only its validity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:25,depend,depend,25,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['depend'],['depend']
Integrability,// We only take known information from the argument; // so we do not need to track a dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:85,depend,dependence,85,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['depend'],['dependence']
Integrability,"// We only track expressions if we believe that they are important. Chances; // are good that control dependencies to the tracking point are also; // important because of this, let's explain why we believe control reached; // this point.; // TODO: Shouldn't we track control dependencies of every bug location,; // rather than only tracked expressions?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:102,depend,dependencies,102,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,2,['depend'],['dependencies']
Integrability,"// We only use TTreeReaderArrays to read columns that users flagged as type `RVec`, so we need to check; // that the branch stores the array as contiguous memory that we can actually wrap in an `RVec`.; // Currently we need the first entry to have been loaded to perform the check; // TODO Move check to constructor once ROOT-10823 is fixed and TTreeReaderArray itself exposes this information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:183,wrap,wrap,183,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,1,['wrap'],['wrap']
Integrability,"// We only want to cluster the mem ops that have the same ctrl(non-data); // pred so that they didn't have ctrl dependency for each other. But for; // store instrs, we can still cluster them if the pred is load instr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:112,depend,dependency,112,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['depend'],['dependency']
Integrability,"// We parsed an identifier list but stumbled into non single identifiers, this; // means we might (a) check that what we already parsed is a legitimate type; // (not a protocol or unknown type) and (b) parse the remaining ones, which; // must all be type args.; // Convert the identifiers into type arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:168,protocol,protocol,168,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocol']
Integrability,"// We perform this check post-message so that if the super -dealloc; // calls a helper method and that this class overrides, any ivars released in; // the helper method will be recorded before checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:30,message,message,30,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,1,['message'],['message']
Integrability,"// We performed name lookup into the current instantiation, and there were; // dependent bases, so we treat this result the same way as any other; // dependent nested-name-specifier.; // C++ [temp.res]p2:; // A name used in a template declaration or definition and that is; // dependent on a template-parameter is assumed not to name a type; // unless the applicable name lookup finds a type name or the name is; // qualified by the keyword typename.; //; // FIXME: If the next token is '<', we might want to ask the parser to; // perform some heroics to see if we actually have a; // template-argument-list, which would indicate a missing 'template'; // keyword here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:79,depend,dependent,79,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,3,['depend'],['dependent']
Integrability,"// We performed some kind of instantiation in the parent context,; // so now we need to look into the instantiated parent context to; // find the instantiation of the declaration D.; // If our context used to be dependent, we may need to instantiate; // it before performing lookup into that context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:212,depend,dependent,212,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['depend'],['dependent']
Integrability,"// We process the set twice: first we process read-write pointers, last we; // process read-only pointers. This allows us to skip dependence tests for; // read-only pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:130,depend,dependence,130,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// We query the topological order in the loop body, so make sure outstanding; // updates are applied before entering it (we only enter the loop if there; // are some interferences). If we make changes to the ordering, we exit; // the loop.; // All candidates are delayed due to live physical reg dependencies.; // Try backtracking, code duplication, or inserting cross class copies; // to resolve it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:296,depend,dependencies,296,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['depend'],['dependencies']
Integrability,"// We re-build the coroutine promise object (and the coroutine parameters its; // type and constructor depend on) based on the types used in our current; // function. We must do so, and set it on the current FunctionScopeInfo,; // before attempting to transform the other parts of the coroutine body; // statement, such as the implicit suspend statements (because those; // statements reference the FunctionScopeInfo::CoroutinePromise).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:103,depend,depend,103,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['depend']
Integrability,// We reach this ctor with either dependent types (in which; // IsSatisfied doesn't matter) or with non-dependent type in; // which the existence of the type indicates satisfaction.; /*IsSatisfied=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:34,depend,dependent,34,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,2,['depend'],['dependent']
Integrability,"// We recreate the RequiresExpr body, but not by instantiating it.; // Produce pending diagnostics for dependent access check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:103,depend,dependent,103,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['depend'],['dependent']
Integrability,"// We recreated a local declaration, but not by instantiating it. There; // may be pending dependent diagnostics to produce.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:91,depend,dependent,91,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['depend'],['dependent']
Integrability,// We recurse into all record fields to detect incomplete and dependent types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:62,depend,dependent,62,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp,1,['depend'],['dependent']
Integrability,"// We reorder declarations in RecordDecls because they may have another order; // in the ""to"" context than they have in the ""from"" context. This may happen; // e.g when we import a class like this:; // struct declToImport {; // int a = c + b;; // int b = 1;; // int c = 2;; // };; // During the import of `a` we import first the dependencies in sequence,; // thus the order would be `c`, `b`, `a`. We will get the normal order by; // first removing the already imported members and then adding them in the; // order as they appear in the ""from"" context.; //; // Keeping field order is vital because it determines structure layout.; //; // Here and below, we cannot call field_begin() method and its callers on; // ToDC if it has an external storage. Calling field_begin() will; // automatically load all the fields by calling; // LoadFieldsFromExternalStorage(). LoadFieldsFromExternalStorage() would; // call ASTImporter::Import(). This is because the ExternalASTSource; // interface in LLDB is implemented by the means of the ASTImporter. However,; // calling an import at this point would result in an uncontrolled import, we; // must avoid that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:329,depend,dependencies,329,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,2,"['depend', 'interface']","['dependencies', 'interface']"
Integrability,// We report a custom error message instead below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp:28,message,message,28,interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,1,['message'],['message']
Integrability,// We resolved this to a (non-dependent) template name. Return it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:30,depend,dependent,30,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,// We save the actual erasing to avoid invalidating memory; // dependencies until we are done with everything.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:63,depend,dependencies,63,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['depend'],['dependencies']
Integrability,"// We set the parameters constant to disable the default label. Still, we; // use param() on as a wrapper for the text box generation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx:98,wrap,wrapper,98,roofit/roofitcore/src/RooMCStudy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx,1,['wrap'],['wrapper']
Integrability,"// We should always be able to find the boxing class interface,; // but consider this future-proofing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:53,interface,interface,53,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,1,['interface'],['interface']
Integrability,"// We should attempts to set the address of the branch.; // something like:; //(TBranchElement*)branch->GetMother()->SetAddress(0); //plus a few more subtleties (see TBranchElement::GetEntry).; //but for now we go the simplest route:; //; // Note: This may result in the allocation of an object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:227,rout,route,227,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['rout'],['route']
Integrability,// We should only get a null bound type if processing a dependent; // CFG. Recover by assuming nothing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:56,depend,dependent,56,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['depend'],['dependent']
Integrability,"// We should trigger in all cases in which eraseInstrs() does something.; // match what eraseInstrs() is doing, print a message so",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:120,message,message,120,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['message'],['message']
Integrability,// We shouldn't use callee-saved registers as scratch registers as they may be; // available when looking for a candidate block for shrink wrapping but not; // available when the actual prologue/epilogue is being emitted because they; // were added as live-in to the prologue block by PrologueEpilogueInserter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:139,wrap,wrapping,139,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['wrap'],['wrapping']
Integrability,// We somehow specified dependent template arguments in an explicit; // instantiation. This should probably only happen during error; // recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:24,depend,dependent,24,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// We special-case rvalues of array type because the analyzer cannot; // reason about them, since we expect all regions to be wrapped in Locs.; // We instead treat these as lvalues and assume that they will decay to; // pointers as soon as they are used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:126,wrap,wrapped,126,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,1,['wrap'],['wrapped']
Integrability,"// We specifically do not do word-wrapping or tab-expansion here,; // because this is supposed to be easy to parse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:34,wrap,wrapping,34,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,1,['wrap'],['wrapping']
Integrability,// We still need to inject the function into the enclosing block scope so; // that later (non-call) uses can see it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:20,inject,inject,20,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['inject']
Integrability,// We store for each line whether it must be a declaration depending on; // whether we are in a compound statement or not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h:59,depend,depending,59,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h,1,['depend'],['depending']
Integrability,// We tag the symbol that the SVal wraps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp:35,wrap,wraps,35,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp,2,['wrap'],['wraps']
Integrability,// We treat bridge casts as objective-C keywords so we can warn on them; // in non-arc mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:12,bridg,bridge,12,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,1,['bridg'],['bridge']
Integrability,// We try to figure out the type from the receiver of the 'class' message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:66,message,message,66,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,1,['message'],['message']
Integrability,// We try to figure out the type from the receiver of the 'superclass'; // message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:75,message,message,75,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,1,['message'],['message']
Integrability,"// We update NumUnsafeDependencesActive post-instruction, catch the; // start of a dependence directly via NumUnsafeDependencesStartOrEnd.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:83,depend,dependence,83,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,1,['depend'],['dependence']
Integrability,// We use C-style casts instead of cast<> here because we do not wish; // to have a dependency of Type.h on Stmt.h/Expr.h.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:84,depend,dependency,84,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,2,['depend'],['dependency']
Integrability,"// We use Delta32/Delta64 to represent SUBTRACTOR relocations.; // parsePairRelocation handles the paired reloc, and returns the; // edge kind to be used (either Delta32/Delta64, or; // NegDelta32/NegDelta64, depending on the direction of the; // subtraction) along with the addend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp:209,depend,depending,209,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp,2,['depend'],['depending']
Integrability,"// We use UTF-8 as the internal character encoding. On z/OS, all external; // output is encoded in EBCDIC. In order to be able to read all; // error messages, we turn conversion to EBCDIC on for stderr fd.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp:149,message,messages,149,interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp,1,['message'],['messages']
Integrability,"// We use a perfect hash function here involving the length of the keyword,; // the first and third character. For preprocessor ID's there are no; // collisions (if there were, the switch below would complain about duplicate; // case values). Note that this depends on 'if' being null terminated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:258,depend,depends,258,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,1,['depend'],['depends']
Integrability,"// We use enough digits so the number can be round-tripped back to an; // APFloat. The formula comes from ""How to Print Floating-Point Numbers; // Accurately"" by Steele and White.; // FIXME: Using a formula based purely on the precision is conservative;; // we can print fewer digits depending on the actual value being printed.; // FormatPrecision = 2 + floor(significandBits / lg_2(10))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:284,depend,depending,284,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['depend'],['depending']
Integrability,// We use one of these or the other depending on whether the; // reference is nested.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:36,depend,depending,36,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['depend'],['depending']
Integrability,"// We use profile, instead of structural comparison of the arguments,; // because canonicalization can't do the right thing for dependent; // expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:128,depend,dependent,128,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,2,['depend'],['dependent']
Integrability,// We use the SSAUpdater interface to insert phi nodes as required.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:25,interface,interface,25,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['interface'],['interface']
Integrability,"// We use the full double result here as reference and allow for some; // jitter introduced by the floating point promotion that happens along; // the way (in deterministic but different places depending on the types; // of the arguments)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/test/vecops_rvec.cxx:194,depend,depending,194,math/vecops/test/vecops_rvec.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/test/vecops_rvec.cxx,4,['depend'],['depending']
Integrability,// We use the initializer as a marker of whether this is a forward; // reference or not. At module finalization we add the empty; // contents for protocols which were referenced but never defined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:146,protocol,protocols,146,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['protocol'],['protocols']
Integrability,// We use the kinds of the host dependence for this action.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Action.cpp:32,depend,dependence,32,interpreter/llvm-project/clang/lib/Driver/Action.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Action.cpp,1,['depend'],['dependence']
Integrability,"// We use untyped (.b) integer registers here as NVCC does.; // Correctness of generated code does not depend on register type,; // but using .s/.u registers runs into ptxas bug that prevents; // assembly of otherwise valid PTX into SASS. Despite PTX ISA; // specifying only argument size for fp16 instructions, ptxas does; // not allow using .s16 or .u16 arguments for .fp16; // instructions. At the same time it allows using .s32/.u32; // arguments for .fp16v2 instructions:; //; // .reg .b16 rb16; // .reg .s16 rs16; // add.f16 rb16,rb16,rb16; // OK; // add.f16 rs16,rs16,rs16; // Arguments mismatch for instruction 'add'; // but:; // .reg .b32 rb32; // .reg .s32 rs32; // add.f16v2 rb32,rb32,rb32; // OK; // add.f16v2 rs32,rs32,rs32; // OK",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXRegisterInfo.cpp:103,depend,depend,103,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXRegisterInfo.cpp,1,['depend'],['depend']
Integrability,"// We used to assume that whatever type we got from inferring the; // type is actually precise (and it is not exactly correct).; // A big portion of the existing behavior depends on that assumption; // (e.g. certain inlining won't take place). For this reason, we don't; // use ObjTy.Precise flag here.; //; // TODO: We should mitigate this problem some time in the future; // and replace hardcoded 'false' with '!ObjTy.Precise'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:171,depend,depends,171,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,1,['depend'],['depends']
Integrability,// We want both WorkListObserver as well as all the auxiliary observers (e.g.; // CSEInfo) to observe all changes. Use the wrapper observer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:123,wrap,wrapper,123,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,1,['wrap'],['wrapper']
Integrability,"// We want messages on the main window during synchronous collection,; // but we save the present status to restore it at the end",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:11,message,messages,11,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['message'],['messages']
Integrability,"// We want to assert there is only one wrapper per transaction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Transaction.cpp:39,wrap,wrapper,39,interpreter/cling/lib/Interpreter/Transaction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Transaction.cpp,1,['wrap'],['wrapper']
Integrability,"// We want to associate the argument with the frame index, among; // involved operands, that correspond to the lowest address. The; // getCopyFromParts function, called earlier, is swapping the order of; // the operands to BUILD_PAIR depending on endianness. The result of; // that swapping is that the least significant bits of the argument will; // be in the first operand of the BUILD_PAIR node, and the most; // significant bits will be in the second operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:234,depend,depending,234,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['depend'],['depending']
Integrability,"// We want to collect all dependencies for correctness. Avoiding the real; // system dependencies (e.g. stl from /usr/lib) would probably be a good idea,; // but there is no way to distinguish between those and the ones that can be; // spuriously added by '-isystem' (e.g. to suppress warnings from those; // headers).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:26,depend,dependencies,26,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,2,['depend'],['dependencies']
Integrability,"// We want to eliminate this interface and use the measurement directly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx:29,interface,interface,29,roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,1,['interface'],['interface']
Integrability,"// We want to emit the following pattern, which follows the x86 calling; // convention to prepare for the trampoline call to be patched in.; //; // .p2align 1, ...; // .Lxray_event_sled_N:; // jmp +N // jump across the instrumentation sled; // ... // set up arguments in register; // callq __xray_CustomEvent@plt // force dependency to symbol; // ...; // <jump here>; //; // After patching, it would look something like:; //; // nopw (2-byte nop); // ...; // callq __xrayCustomEvent // already lowered; // ...; //; // ---; // First we emit the label and the jump.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp:322,depend,dependency,322,interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,1,['depend'],['dependency']
Integrability,"// We want to emit the following pattern, which follows the x86 calling; // convention to prepare for the trampoline call to be patched in.; //; // .p2align 1, ...; // .Lxray_event_sled_N:; // jmp +N // jump across the instrumentation sled; // ... // set up arguments in register; // callq __xray_TypedEvent@plt // force dependency to symbol; // ...; // <jump here>; //; // After patching, it would look something like:; //; // nopw (2-byte nop); // ...; // callq __xrayTypedEvent // already lowered; // ...; //; // ---; // First we emit the label and the jump.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp:321,depend,dependency,321,interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,1,['depend'],['dependency']
Integrability,"// We want to end up calling one of checkPseudoObjectAssignment; // (if the LHS is a pseudo-object), BuildOverloadedBinOp (if; // both expressions are overloadable or either is type-dependent),; // or CreateBuiltinBinOp (in any other case). We also want to get; // any placeholder types out of the way.; // Handle pseudo-objects in the LHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:182,depend,dependent,182,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependent']
Integrability,"// We want to find all load dependencies for long chains of stores to enable; // merging into very wide vectors. The problem is with vectors with > 4; // elements. MergeConsecutiveStores will attempt to merge these because x8/x16; // vectors are a legal type, even though we have to split the loads; // usually. When we can more precisely specify load legality per address; // space, we should be able to make FindBetterChain/MergeConsecutiveStores; // smarter so that they can figure out what to do in 2 iterations without all; // N > 4 stores on the same chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:28,depend,dependencies,28,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['depend'],['dependencies']
Integrability,"// We want to hit all cases here to completely cover the analytical integral function.; // The RooCrystalBall has 4 separate definition regions:; //; // 1. Gaussian core left; // 2. Gaussian core right; // 3. left tail; // 4. right tail; //; // It's important that the integration range limits are in all possible combinations of these; // regions to cover all branches of the integration code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooCrystalBall.cxx:269,integrat,integration,269,roofit/roofit/test/testRooCrystalBall.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooCrystalBall.cxx,2,['integrat'],['integration']
Integrability,"// We want to reliably handle any conditional branch terminators in the; // MBB, so we manually analyze the branch. We can handle all of the; // permutations here, including ones that analyze branch cannot.; //; // The approach is to walk backwards across the terminators, resetting at; // any unconditional non-indirect branch, and track all conditional edges; // to basic blocks as well as the fallthrough or unconditional successor; // edge. For each conditional edge, we track the target and the opposite; // condition code in order to inject a ""no-op"" cmov into that successor; // that will harden the predicate. For the fallthrough/unconditional; // edge, we inject a separate cmov for each conditional branch with; // matching condition codes. This effectively implements an ""and"" of the; // condition flags, even if there isn't a single condition flag that would; // directly implement that. We don't bother trying to optimize either of; // these cases because if such an optimization is possible, LLVM should; // have optimized the conditional *branches* in that way already to reduce; // instruction count. This late, we simply assume the minimal number of; // branch instructions is being emitted and use that to guide our cmov; // insertion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:540,inject,inject,540,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,2,['inject'],['inject']
Integrability,"// We want to support cases such as:; // gCling->evaluate(""if() return 'A' else return 12"", V), that puts in V,; // either A or 12.; // In this case the void wrapper is compiled with the stmts returning; // values. Sema would cast them to void, but the code will still be; // executed. For example:; // int g(); void f () { return g(); } will still call g().; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp:158,wrap,wrapper,158,interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp,1,['wrap'],['wrapper']
Integrability,// We warn about copying to or from `nullptr` pointers when `size` is; // greater than 0. When `size` is value dependent we cannot evaluate its; // value so we bail out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:111,depend,dependent,111,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['depend'],['dependent']
Integrability,// We warn about filling to `nullptr` pointers when `size` is greater than; // 0. When `size` is value dependent we cannot evaluate its value so we bail; // out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:103,depend,dependent,103,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['depend'],['dependent']
Integrability,// We were asked to compile a module interface unit but this is a module; // implementation unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:37,interface,interface,37,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,1,['interface'],['interface']
Integrability,"// We were not able to compute the declaration context for a dependent; // base object type or prior nested-name-specifier, so this; // nested-name-specifier refers to an unknown specialization. Just build; // a dependent nested-name-specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:61,depend,dependent,61,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,2,['depend'],['dependent']
Integrability,"// We will either select ds_read_b64/ds_write_b64 or ds_read2_b32/; // ds_write2_b32 depending on the alignment. In either case with either; // alignment there is no faster way of doing this.; // The numbers returned here and below are not additive, it is a 'speed; // rank'. They are just meant to be compared to decide if a certain way; // of lowering an operation is faster than another. For that purpose; // naturally aligned operation gets it bitsize to indicate that ""it; // operates with a speed comparable to N-bit wide load"". With the full; // alignment ds128 is slower than ds96 for example. If underaligned it; // is comparable to a speed of a single dword access, which would then; // mean 32 < 128 and it is faster to issue a wide load regardless.; // 1 is simply ""slow, don't do it"". I.e. comparing an aligned load to a; // wider load which will not be aligned anymore the latter is slower.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:85,depend,depending,85,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['depend'],['depending']
Integrability,"// We will need to clone a bunch of blocks, wrap up the clone operation in; // a helper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:44,wrap,wrap,44,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['wrap'],['wrap']
Integrability,"// We will not add the servers just now, because it makes only sense to add; // them once we have made sure that this integral is not operating in; // pass-through mode. It will be done at the end of this constructor.; // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *; // * E) interact with function to make list of objects actually integrated analytically *; // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:375,integrat,integrated,375,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['integrat'],['integrated']
Integrability,"// We will pass the device action as a host dependence, so we don't; // need to do anything else with them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:44,depend,dependence,44,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['dependence']
Integrability,"// We won't auto-synthesize properties declared in protocols.; // Suppress the warning if class's superclass implements property's; // getter and implements property's setter (if readwrite property).; // Or, if property is going to be implemented in its super class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:51,protocol,protocols,51,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['protocol'],['protocols']
Integrability,"// We won't be able to check, so assume the worst but don't issue any; // error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TCheckHashRecursiveRemoveConsistency.h:80,message,message,80,core/meta/src/TCheckHashRecursiveRemoveConsistency.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TCheckHashRecursiveRemoveConsistency.h,1,['message'],['message']
Integrability,// We won't bother with the InstSimplify interface if we didn't simplify any; // operand ourselves.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:41,interface,interface,41,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['interface'],['interface']
Integrability,// We would normally delete the original instruction here but in this case; // we only needed to inject an additional instruction rather than replace it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:97,inject,inject,97,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['inject'],['inject']
Integrability,"// We wrap the CGSCC pipeline in a devirtualization repeater. This will try; // to detect when we devirtualize indirect calls and iterate the SCC passes; // in that case to try and catch knock-on inlining or function attrs; // opportunities. Then we add it to the module pipeline by walking the SCCs; // in postorder (or bottom-up).; // If MaxDevirtIterations is 0, we just don't use the devirtualization; // wrapper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:6,wrap,wrap,6,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,2,['wrap'],"['wrap', 'wrapper']"
Integrability,// We wrap up the current range when we see a marker even if we haven't; // finished a BB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:6,wrap,wrap,6,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,1,['wrap'],['wrap']
Integrability,"// We'd like to let SCEV reason about control dependencies, so we constrain; // both the inequalities to be about add recurrences on the same loop. This; // way we can use isLoopEntryGuardedByCond later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:46,depend,dependencies,46,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['depend'],['dependencies']
Integrability,// We'll also need to make an extra allocation for the eh-frame wrapper call; // arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp:64,wrap,wrapper,64,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,1,['wrap'],['wrapper']
Integrability,// We'll delete all of these special member functions to force the users of; // this interface to only store references to FieldNode objects in containers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:85,interface,interface,85,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,1,['interface'],['interface']
Integrability,// We're analyzing dependences across loop iterations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:19,depend,dependences,19,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependences']
Integrability,"// We're certain that ConstCoeff > 0; therefore,; // if Delta < 0, then no dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:75,depend,dependence,75,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// We're disambiguating this:; //; // [..., x = expr; //; // We need to find the end of the following expression in order to; // determine whether this is an Obj-C message send's receiver, a; // C99 designator, or a lambda init-capture.; //; // Parse the expression to find where it ends, and annotate it back; // onto the tokens. We would have parsed this expression the same way; // in either case: both the RHS of an init-capture and the RHS of an; // assignment expression are parsed as an initializer-clause, and in; // neither case can anything be added to the scope between the '[' and; // here.; //; // FIXME: This is horrible. Adding a mechanism to skip an expression; // would be much cleaner.; // FIXME: If there is a ',' before the next ']' or ':', we can skip to; // that instead. (And if we see a ':' with no matching '?', we can; // classify this as an Obj-C message send.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:164,message,message,164,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,2,['message'],['message']
Integrability,"// We're generating a reduction, where each instruction depends on; // the previous one, so we need to order them according to the position; // of their inputs in the code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:56,depend,depends,56,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['depend'],['depends']
Integrability,"// We're going to use the larger candidates as a ""bridge"" to create the; // canonical number for the target candidate since we have idetified two; // candidates as subsequences of larger sequences, and therefore must be; // structurally similar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:50,bridg,bridge,50,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,1,['bridg'],['bridge']
Integrability,// We're in -harness mode. Use a custom interface for this; // test object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:40,interface,interface,40,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,1,['interface'],['interface']
Integrability,// We're trying to construct a SCEV of type `Type' with `Ops' as operands and; // `OldFlags' as can't-wrap behavior. Infer a more aggressive set of; // can't-overflow flags for the operation if possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:102,wrap,wrap,102,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,// We're walking the dependencies of a module forward declaration that was; // kept because there is no definition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:21,depend,dependencies,21,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,1,['depend'],['dependencies']
Integrability,"// We've determined that we are going to sink last ScanIdx instructions,; // and recorded them in InstructionsToSink. Now, some instructions may be; // unprofitable to sink. But that determination depends on the instructions; // that we are going to sink.; // First, forward scan: find the first instruction unprofitable to sink,; // recording all the ones that are profitable to sink.; // FIXME: would it be better, after we detect that not all are profitable.; // to either record the profitable ones, or erase the unprofitable ones?; // Maybe we need to choose (at runtime) the one that will touch least; // instrs?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:197,depend,depends,197,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['depend'],['depends']
Integrability,"// We've made an edge reachable to an existing block, which may; // impact predicates. Otherwise, only mark the phi nodes as touched, as; // they are the only thing that depend on new edges. Anything using their; // values will get propagated to if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:170,depend,depend,170,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['depend'],['depend']
Integrability,"// We've wrapped, therefore, full set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:9,wrap,wrapped,9,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,2,['wrap'],['wrapped']
Integrability,"// WebAssembly constant offsets are performed as unsigned with infinite; // precision, so we need to check for NoUnsignedWrap so that we don't fold an; // offset for an add that needs wrapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:184,wrap,wrapping,184,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,1,['wrap'],['wrapping']
Integrability,"// WebAssembly has variable length opcodes, so can't use EmitFixedLenDecoder; // below (which depends on a Size table-gen Record), and also uses a custom; // disassembler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DisassemblerEmitter.cpp:94,depend,depends,94,interpreter/llvm-project/llvm/utils/TableGen/DisassemblerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DisassemblerEmitter.cpp,1,['depend'],['depends']
Integrability,"// WebAssembly offsets are added as unsigned without wrapping. The; // isLegalAddressingMode gives us no way to determine if wrapping could be; // happening, so we approximate this by accepting only non-negative offsets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:53,wrap,wrapping,53,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,2,['wrap'],['wrapping']
Integrability,"// Welcome message, if requested ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:11,message,message,11,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['message'],['message']
Integrability,"// What to do depends on the size of the integer and the size of the pointer.; // We can either truncate, zero extend, or no-op, accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:14,depend,depends,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,2,['depend'],['depends']
Integrability,"// When -O0 is enabled, the Load Value Injection Hardening pass will fall back; // to using the Speculative Execution Side Effect Suppression pass for; // mitigation. This is to prevent slow downs due to; // analyses needed by the LVIHardening pass when compiling at -O0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp:39,Inject,Injection,39,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp,1,['Inject'],['Injection']
Integrability,"// When a Constant is destroyed, there may be lingering; // references to the constant by other constants in the constant pool. These; // constants are implicitly dependent on the module that is being deleted,; // but they don't know that. Because we only find out when the CPV is; // deleted, we must now notify all of our users (that should only be; // Constants) that they are, in fact, invalid now and should be deleted.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:163,depend,dependent,163,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp,1,['depend'],['dependent']
Integrability,"// When a fieldchain is printed, it will have the following format (without; // newline, indices are in order of insertion, from 1 to n):; //; // <note_message_n>'<prefix_n><prefix_n-1>...<prefix_1>; // this-><node_1><separator_1><node_2><separator_2>...<node_n>'; /// If this is the last element of the fieldchain, this method will print the; /// note message associated with it.; /// The note message should state something like ""uninitialized field"" or; /// ""uninitialized pointee"" etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:353,message,message,353,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,2,['message'],['message']
Integrability,"// When building a C++20 module interface unit or a partition unit, a; // strong definition in the module interface is provided by the; // compilation of that unit, not by its users. (Inline functions are still; // emitted in module users.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:32,interface,interface,32,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,2,['interface'],['interface']
Integrability,"// When building a C++20 module interface unit or a partition unit, a; // strong definition in the module interface is provided by the; // compilation of that unit, not by its users. (Inline variables are still; // emitted in module users.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:32,interface,interface,32,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,2,['interface'],['interface']
Integrability,"// When building a template-id where the template-name is dependent,; // assume the template is a type template. Either our assumption is; // correct, or the code is ill-formed and will be diagnosed when the; // dependent name is substituted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:58,depend,dependent,58,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,['depend'],['dependent']
Integrability,"// When building modules and generating crashdumps, we need to dump a module; // dependency VFS alongside the output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:81,depend,dependency,81,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['depend'],['dependency']
Integrability,"// When checking a deduced template argument, deduce from its type even if; // the type is dependent, in order to check the types of non-type template; // arguments line up properly in partial ordering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:91,depend,dependent,91,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// When compiling with NVCC, we allow setting and getting the actual CUDA objects from the wrapper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/CudaInterface.h:91,wrap,wrapper,91,roofit/batchcompute/src/CudaInterface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/CudaInterface.h,2,['wrap'],['wrapper']
Integrability,"// When correcting from misplaced brackets before the identifier, the location; // is saved inside the declarator so that other diagnostic messages can use; // them. This extracts and returns that location, or returns the provided; // location if a stored location does not exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:139,message,messages,139,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['message'],['messages']
Integrability,"// When counting down, the dependence distance needs to be swapped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,depend,dependence,27,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// When creating this SCEV expr, don't apply the current operations NSW or NUW; // flags. This instruction may be guarded by control flow that the no-wrap; // behavior depends on. Non-control-equivalent instructions can be mapped to; // the same SCEV expression, and it would be incorrect to transfer NSW/NUW; // semantics to those operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:150,wrap,wrap,150,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,2,"['depend', 'wrap']","['depends', 'wrap']"
Integrability,"// When emitting a variant part, wrap each member in; // DW_TAG_variant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:33,wrap,wrap,33,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,1,['wrap'],['wrap']
Integrability,"// When encountering a message that does initialization (init rule),; // tag the return value so that we know later on that if self has this value; // then it is properly initialized.; // FIXME: A callback should disable checkers at the start of functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:23,message,message,23,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,1,['message'],['message']
Integrability,"// When generating value profiling calls on Windows routines that make use of; // handler funclets for exception processing an operand bundle needs to attached; // to the called function. This routine will set \p OpBundles to contain the; // funclet information, if any is needed, that should be placed on the generated; // value profiling call for the value profile candidate call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:52,rout,routines,52,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,2,['rout'],"['routine', 'routines']"
Integrability,"// When in ARC mode we also convert ""[[.. alloc] init]"" messages to literals,; // since the change from +1 to +0 will be handled fine by ARC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:56,message,messages,56,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,1,['message'],['messages']
Integrability,"// When inlining, we should consider the body of the function, not the; // interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:75,interface,interface,75,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['interface'],['interface']
Integrability,"// When iterating backwards, the loop condition relies on unsigned wraparound.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:67,wrap,wraparound,67,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['wrap'],['wraparound']
Integrability,"// When naming a constructor as a member of a dependent context (eg, in a; // friend declaration or an inherited constructor declaration), form an; // unresolved ""typename"" type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:46,depend,dependent,46,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['depend'],['dependent']
Integrability,"// When not using the cl driver mode, dependency file generation options; // begin with -M. These include -MM, -MF, -MG, -MP, -MT, -MQ, -MD, and; // -MMD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:38,depend,dependency,38,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,1,['depend'],['dependency']
Integrability,"// When optimising for size, always run the Thumb2SizeReduction pass before; // IfConversion. Otherwise, check whether IT blocks are restricted; // (e.g. in v8, IfConversion depends on Thumb instruction widths)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:174,depend,depends,174,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,1,['depend'],['depends']
Integrability,"// When reporting on missing property setter/getter implementation in; // categories, do not report when they are declared in primary class,; // class's protocol, or one of it super classes. This is because,; // the class is going to implement them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:153,protocol,protocol,153,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['protocol'],['protocol']
Integrability,"// When retrieving symbolic pointer and expecting a non-void pointer,; // wrap them into element regions of the expected type if necessary.; // It is necessary to make sure that the retrieved value makes sense,; // because there's no other cast in the AST that would tell us to cast; // it to the correct pointer type. We might need to do that for non-void; // pointers as well.; // FIXME: We really need a single good function to perform casts for us; // correctly every time we need it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:74,wrap,wrap,74,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,1,['wrap'],['wrap']
Integrability,"// When running in integrated-cc1 mode, the CrashRecoveryContext returns; // the same codes as if the program crashed. See section ""Exit Status for; // Commands"":; // https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xcu_chap02.html",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:19,integrat,integrated-,19,interpreter/llvm-project/clang/tools/driver/driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp,1,['integrat'],['integrated-']
Integrability,// When scheduling a Phi it is better to start at the late cycle and go; // backwards. The default order may insert the Phi too far away from; // its first dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:156,depend,dependence,156,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependence']
Integrability,"// When the container is the ObjCImplementationDecl (the primary; // @implementation), then the canonical Decl is either in; // the class Interface, or in any of its extension.; //; // So when we don't find it in the ObjCInterfaceDecl,; // sift through extensions too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:138,Interface,Interface,138,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['Interface'],['Interface']
Integrability,// When the internal visitor calls Types.getType(Index) the interface is; // required to return a CVType with the bytes filled out. So we can assume; // that the bytes will be present when individual records are visited.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/CVTypeVisitor.cpp:60,interface,interface,60,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/CVTypeVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/CVTypeVisitor.cpp,1,['interface'],['interface']
Integrability,"// When the member is missing, just leave the address alone; // (since setting explicitly to 0 would trigger error/warning; // messages).; // abranch->SetAddress(0);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:127,message,messages,127,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['message'],['messages']
Integrability,"// When there are protocol qualifers, we have LAngleLoc and RAngleLoc; // as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TypeLoc.h:18,protocol,protocol,18,interpreter/llvm-project/clang/include/clang/AST/TypeLoc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TypeLoc.h,1,['protocol'],['protocol']
Integrability,"// When trying to determine if value-dependent expressions can populate; // the attribute without prior instantiation, the decision is made based; // on the assumption that only the last argument is ever variadic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:37,depend,dependent,37,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,1,['depend'],['dependent']
Integrability,"// When we apply attributes to statements, it actually creates; // a wrapper statement that only contains attributes and the wrapped; // statement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:69,wrap,wrapper,69,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,2,['wrap'],"['wrapped', 'wrapper']"
Integrability,// When we have a file provide a heap-allocated wrapper for the memory buffer; // to match the ownership semantics for File.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:48,wrap,wrapper,48,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['wrap'],['wrapper']
Integrability,"// When we have both sret and another return value, we should use the; // original Chain stored in RetOps[0], instead of the current Chain updated; // in the above loop. If we only have sret, RetOps[0] equals to Chain.; // For the case of sret and another return value, we have; // Chain_0 at the function entry; // Chain_1 = getCopyToReg(Chain_0) in the above loop; // If we use Chain_1 in getCopyFromReg, we will have; // Val = getCopyFromReg(Chain_1); // Chain_2 = getCopyToReg(Chain_1, Val) from below; // getCopyToReg(Chain_0) will be glued together with; // getCopyToReg(Chain_1, Val) into Unit A, getCopyFromReg(Chain_1) will be; // in Unit B, and we will have cyclic dependency between Unit A and Unit B:; // Data dependency from Unit B to Unit A due to usage of Val in; // getCopyToReg(Chain_1, Val); // Chain dependency from Unit A to Unit B; // So here, we use RetOps[0] (i.e Chain_0) for getCopyFromReg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:675,depend,dependency,675,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,3,['depend'],['dependency']
Integrability,"// When we have small integers (i16 to be specific), the form present; // post-legalization uses SETULT in the SELECT_CC for the; // higher-order byte, depending on the fact that the; // even-higher-order bytes are known to all be zero, for example:; // select_cc (xor $lhs, $rhs), 256, 65280, 0, setult; // (so when the second byte is the same, because all higher-order; // bits from bytes 3 and 4 are known to be zero, the result of the; // xor can be at most 255)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:152,depend,depending,152,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['depend'],['depending']
Integrability,// When we leave this function this RAII will make sure the member; // KernelEnvC is updated properly depending on the state. That member is; // used for simplification of values and needs to be up to date at all; // times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:102,depend,depending,102,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['depend'],['depending']
Integrability,// When we run after a failing dependency check we have to make sure; // we don't have wrapping pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:31,depend,dependency,31,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,"['depend', 'wrap']","['dependency', 'wrapping']"
Integrability,"// When we're using a record/enum/Objective-C class/protocol as a context, we; // need it to have a definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:52,protocol,protocol,52,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['protocol'],['protocol']
Integrability,"// Where in the prologue we move the CR fields depends on how many scratch; // registers we have, and if we need to save the link register or not. This; // lambda is to avoid duplicating the logic in 2 places.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:47,depend,depends,47,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['depend'],['depends']
Integrability,"// Whether all of the elements we've parsed thus far are single; // identifiers, which might be types or might be protocols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:114,protocol,protocols,114,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocols']
Integrability,"// Whether the mangling of a function type includes the return type depends on; // the context and the nature of the function. The rules for deciding whether; // the return type is included are:; //; // 1. Template functions (names or types) have return types encoded, with; // the exceptions listed below.; // 2. Function types not appearing as part of a function name mangling,; // e.g. parameters, pointer types, etc., have return type encoded, with the; // exceptions listed below.; // 3. Non-template function names do not have return types encoded.; //; // The exceptions mentioned in (1) and (2) above, for which the return type is; // never included, are; // 1. Constructors.; // 2. Destructors.; // 3. Conversion operator functions, e.g. operator int.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:68,depend,depends,68,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['depend'],['depends']
Integrability,// Whether the visiting of the function has been done. Done[0] is for the; // case not in OpenMP device context. Done[1] is for the case in OpenMP; // device context. We need two sets because diagnostics emission may be; // different depending on whether it is in OpenMP device context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:234,depend,depending,234,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['depend'],['depending']
Integrability,"// Whether these functions overflow depends on the runtime strlen of the; // string, not just the buffer size, so emitting the ""always overflow""; // diagnostic isn't quite right. We should still diagnose passing a buffer; // size larger than the destination buffer though; this is a runtime abort; // in _FORTIFY_SOURCE mode, and is quite suspicious otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:36,depend,depends,36,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['depend'],['depends']
Integrability,// Whether this is legal depends on the floating point mode for the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:25,depend,depends,25,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['depend'],['depends']
Integrability,// Whether to use MAD_64_32 for partial products whose high half is; // discarded. This avoids some ADD instructions but risks false dependency; // stalls on some subtargets in some cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:133,depend,dependency,133,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['depend'],['dependency']
Integrability,// Whether we need to save SCC depends on start and end states.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:31,depend,depends,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['depend'],['depends']
Integrability,// Whether we're looking for a use of a template parameter that makes the; // overall construct type-dependent / a dependent type. This is strictly; // best-effort for now; we may fail to match at all for a dependent type; // in some cases if this is set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:101,depend,dependent,101,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,3,['depend'],['dependent']
Integrability,// Which blocks are predecessors via this branch depends on if the; // branch is triangle-like or diamond-like.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:49,depend,depends,49,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['depend'],['depends']
Integrability,// Which instruction to expand to depends on the CCOut operand and; // whether we're in an IT block if the register operands are low; // registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:34,depend,depends,34,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,2,['depend'],['depends']
Integrability,// Which register is Rt and which is Rt2 depends on the offset order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:41,depend,depends,41,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,1,['depend'],['depends']
Integrability,"// Which register is Rt and which is Rt2 depends on the offset order.; // However, for pre load/stores the Rt should be the one of the pre; // load/store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:41,depend,depends,41,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,1,['depend'],['depends']
Integrability,"// While Threshold depends on commandline options that can take negative; // values, we want to enforce the invariant that the computed threshold and; // bonuses are non-negative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,depend,depends,19,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['depend'],['depends']
Integrability,"// While __dso_handle is still overriden in the JIT below,; // #define __dso_handle is used to mitigate the following problems:; // 1. Type of __dso_handle is void* making assignemnt to it legal; // 2. Making it void* const in cling would mean possible type mismatch; // 3. Cannot override void* __dso_handle in child Interpreter; // 4. On Unix where the symbol actually exists, __dso_handle will be; // linked into the code before the JIT can say otherwise, so:; // [cling] __dso_handle // codegened __dso_handle always printed; // [cling] __cxa_atexit(f, 0, __dso_handle) // seg-fault; // 5. Code that actually uses __dso_handle will fail as a declaration is; // needed which is not possible with the macro.; // 6. Assuming 4 is sorted out in user code, calling __cxa_atexit through; // atexit below isn't linking to the __dso_handle symbol.; // Use __cxa_atexit to intercept all of the following routines",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:899,rout,routines,899,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['rout'],['routines']
Integrability,"// While generating code for CUDA, we only depend on the host input action; // to trigger the creation of all the CUDA device actions.; // If we are dealing with an input action, replicate it for each GPU; // architecture. If we are in host-only mode we return 'success' so that; // the host uses the CUDA offload kind.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:43,depend,depend,43,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['depend']
Integrability,"// While interface stubs are in the development stage, it's probably best to; // catch anything that's not a VarDecl or Template/FunctionDecl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp:9,interface,interface,9,interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp,1,['interface'],['interface']
Integrability,"// Whitesmiths is weird here. The brace needs to be indented for the namespace; // block, but the block itself may not be indented depending on the style; // settings. This allows the format to back up one level in those cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:131,depend,depending,131,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['depend'],['depending']
Integrability,"// Will Candidate ever be called on the object, when overloaded with Incumbent?; // Returns Dominates if Candidate is always called, Dominated if Incumbent is; // always called, BothViable if either may be called depending on arguments.; // Precondition: must actually be overloads!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:213,depend,depending,213,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['depend'],['depending']
Integrability,"// Windows SDK 8.x installs libraries in a folder whose names depend on the; // version of the OS you're targeting. By default choose the newest, which; // usually corresponds to the version of the OS you've installed the SDK on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:62,depend,depend,62,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,1,['depend'],['depend']
Integrability,// Windows with CFI has some limitations that make it impossible; // to use shrink-wrapping.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:83,wrap,wrapping,83,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['wrap'],['wrapping']
Integrability,// With -fno-integrated-as -mfpu=crypto-neon-fp-armv8 some assemblers such; // as the GNU assembler will permit the use of crypto instructions as the; // fpu will override the architecture. We keep the crypto feature in this; // case to preserve compatibility. In all other cases we remove the crypto; // feature.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:13,integrat,integrated-as,13,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,1,['integrat'],['integrated-as']
Integrability,// With any pair of no-wrap subtracts:; // (A > B) ? (A - B) : (B - A) --> abs(A - B),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:23,wrap,wrap,23,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['wrap'],['wrap']
Integrability,"// With appropriate no-wrap constraints, remove a common factor in the; // dividend and divisor that is disguised as a left-shift amount.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:23,wrap,wrap,23,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['wrap'],['wrap']
Integrability,"// With appropriate no-wrap constraints, remove a common factor in the; // dividend and divisor that is disguised as a left-shifted value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:23,wrap,wrap,23,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['wrap'],['wrap']
Integrability,"// With instance variables, this puts '}' on its own line. Without instance; // variables, this ends the @interface line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:106,interface,interface,106,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['interface'],['interface']
Integrability,"// With the CSE-driven heuristic, we are about to slap two values at the; // beginning of the expression whereas they could live very late in the CFG.; // When using the CSE-local heuristic we avoid creating dependences from; // completely unrelated part of the CFG by limiting the expression; // reordering on the values that live in the first seen basic block.; // The main idea is that we want to avoid forming expressions that would; // become loop dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:208,depend,dependences,208,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,['depend'],"['dependences', 'dependent']"
Integrability,"// With the appropriate no-wrap constraint, remove a multiply by the divisor; // after peeking through another divide:; // ((Op1 * X) / Y) / Op1 --> X / Y",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:27,wrap,wrap,27,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['wrap'],['wrap']
Integrability,"// Within P1689 format, we don't want all the paths to be absolute path; // since it may violate the tranditional make style dependencies info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:125,depend,dependencies,125,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,1,['depend'],['dependencies']
Integrability,"// Work around MinGW's macro definition of 'interface' to 'struct'. We; // have an attribute argument called 'Interface', so only the lower case; // name conflicts with the macro definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:44,interface,interface,44,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,2,"['Interface', 'interface']","['Interface', 'interface']"
Integrability,"// Working with parameterized ranges to define non-rectangular regions; // for fitting and integration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:91,integrat,integration,91,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['integrat'],['integration']
Integrability,// Wrap AVL in a LEGALAVL node (unless it is one already).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,1,['Wrap'],['Wrap']
Integrability,// Wrap MemorySSA result to ensure address stability of internal MemorySSA; // pointers after construction. Use a wrapper class instead of plain; // unique_ptr<MemorySSA> to avoid build breakage on MSVC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,2,"['Wrap', 'wrap']","['Wrap', 'wrapper']"
Integrability,// Wrap Source in a MemoryBuffer,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c,2,['Wrap'],['Wrap']
Integrability,"// Wrap Stmts into a function body.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:3,Wrap,Wrap,3,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap a 64-bit pointer into a v4i32 (which is how all SelectionDAG code; // represents ptr addrspace(8)) using the flags specified in the intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.h:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.h,1,['Wrap'],['Wrap']
Integrability,// Wrap a global or flat pointer into a buffer intrinsic using the flags; // specified in the intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap any static runtimes that must be forced into executable in; // whole-archive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap arg 'c' of type int to char,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['Wrap'],['Wrap']
Integrability,"// Wrap around if needed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THn.cxx:3,Wrap,Wrap,3,hist/hist/src/THn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THn.cxx,1,['Wrap'],['Wrap']
Integrability,"// Wrap both the existing source and our source. We give our own; // source preference to the existing one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/InterpreterCallbacks.cpp:3,Wrap,Wrap,3,interpreter/cling/lib/Interpreter/InterpreterCallbacks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/InterpreterCallbacks.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap call with invoke wrapper and generate preamble/postamble,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,2,"['Wrap', 'wrap']","['Wrap', 'wrapper']"
Integrability,// Wrap conditions that can potentially generate errno to the library call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap double-quotes around a '%s' specifier and limit its maximum; // length. Ideally we'd also somehow escape special characters in the; // contents but printf doesn't support that.; // FIXME: '%s' formatting is not safe in general.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['Wrap'],['Wrap']
Integrability,"// Wrap each pass with (-check)-debugify passes if requested, making; // exceptions for passes which shouldn't see -debugify instrumentation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,1,['Wrap'],['Wrap']
Integrability,"// Wrap everything after ';'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:3,Wrap,Wrap,3,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['Wrap'],['Wrap']
Integrability,"// Wrap everything after '}'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:3,Wrap,Wrap,3,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap everything in namespace llvm so that programs can link with llvm and; // their own version of the unicode libraries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h,1,['Wrap'],['Wrap']
Integrability,// Wrap expr in () if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h:3,Wrap,Wrap,3,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,1,['Wrap'],['Wrap']
Integrability,// Wrap invoke with invoke wrapper and generate preamble/postamble,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,2,"['Wrap', 'wrap']","['Wrap', 'wrapper']"
Integrability,// Wrap it in a construction of a std::initializer_list<T>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap it with compound value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap lines.; // Wrap very long names even though we can't find a space.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,2,['Wrap'],['Wrap']
Integrability,"// Wrap parentheses around the given pointer. This is not necessary for; // correct code generation, but it means that when we pretty-print the call; // arguments in our diagnostics we will produce '(&s)->n' instead of the; // incorrect '&s->n'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap predicates from outer loops are not supported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Wrap'],['Wrap']
Integrability,"// Wrap return value with a recovery expression of the previous type.; // If no deduction yet, use DependentTy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,2,"['Depend', 'Wrap']","['DependentTy', 'Wrap']"
Integrability,"// Wrap some gymnastic around the enum finding. The special treatment of the; // ListOfEnums objects is located in this routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TEnum.cxx:3,Wrap,Wrap,3,core/meta/src/TEnum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TEnum.cxx,2,"['Wrap', 'rout']","['Wrap', 'routine']"
Integrability,// Wrap target address space into an attribute syntax,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap the base FE action in an extract api action to generate; // symbol graph as a biproduct of comilation ( enabled with; // --emit-symbol-graph option ),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,1,['Wrap'],['Wrap']
Integrability,"// Wrap the channel pdf in a RooProdPdf to mimic HistFactory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testTestStatistics.cxx:3,Wrap,Wrap,3,roofit/roofitcore/test/testTestStatistics.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testTestStatistics.cxx,1,['Wrap'],['Wrap']
Integrability,"// Wrap the evaluation in a block scope, in case it's a DeclStmt; // preceded by our switch label.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Wrap'],['Wrap']
Integrability,"// Wrap the existing source in a wrapper so that it becomes an; // external sema source. This way we can use the existing multiplexer; // for this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/InterpreterCallbacks.cpp:3,Wrap,Wrap,3,interpreter/cling/lib/Interpreter/InterpreterCallbacks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/InterpreterCallbacks.cpp,2,"['Wrap', 'wrap']","['Wrap', 'wrapper']"
Integrability,"// Wrap the expression",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:3,Wrap,Wrap,3,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap the future so that both ThreadPool::wait() can operate and the; // returned future can be sync'ed on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,1,['Wrap'],['Wrap']
Integrability,// Wrap the given range of instruction with try-delegate. RangeBegin and; // RangeEnd are inclusive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap the literal in parentheses to attach a source location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap the old arguments in an InputArgList.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,1,['Wrap'],['Wrap']
Integrability,"// Wrap the pointer to the Bytes, BytesSize and PC in a MemoryObject.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,1,['Wrap'],['Wrap']
Integrability,"// Wrap the sub-expression in a parenthesized expression, to distinguish; // a boxed expression from a literal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap this into DW_CFA_def_cfa.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap this into DW_CFA_expression,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap up any cleanups in the expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:3,Wrap,Wrap,3,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['Wrap'],['Wrap']
Integrability,// Wrap-up,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:3,Wrap,Wrap-up,3,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,1,['Wrap'],['Wrap-up']
Integrability,"// WrappedFunction; /**; Template class to wrap any member function of a class; taking a double and returning a double in a 1D function interface; For example, if you have a class like:; struct X {; double Eval(double x);; };; you can wrapped in the following way:; WrappedMemFunction<X, double ( X::* ) (double) > f;. @ingroup GenFunc. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h:3,Wrap,WrappedFunction,3,math/mathcore/inc/Math/WrappedFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h,5,"['Wrap', 'interface', 'wrap']","['WrappedFunction', 'WrappedMemFunction', 'interface', 'wrap', 'wrapped']"
Integrability,// WrappedMemFunction; /**; Template class to wrap any C++ callable object; implementing operator() (const double * x) in a multi-dimensional function interface.; It provides a ROOT::Math::IGenMultiFunction-like signature. Note: If you want to wrap just the reference (to avoid copying) you need to use; Func& or const Func & as template parameter. The former should be used when the; operator() is not a const method of Func. @ingroup GenFunc. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h:3,Wrap,WrappedMemFunction,3,math/mathcore/inc/Math/WrappedFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h,4,"['Wrap', 'interface', 'wrap']","['WrappedMemFunction', 'interface', 'wrap']"
Integrability,"// WrappedMemMultiFunction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h:3,Wrap,WrappedMemMultiFunction,3,math/mathcore/inc/Math/WrappedFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h,1,['Wrap'],['WrappedMemMultiFunction']
Integrability,"// WrappedMultiFunction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h:3,Wrap,WrappedMultiFunction,3,math/mathcore/inc/Math/WrappedFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h,1,['Wrap'],['WrappedMultiFunction']
Integrability,"// Wrapper - A wrapper node for TargetConstantPool, TargetExternalSymbol,; // and TargetGlobalAddress.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h,2,"['Wrap', 'wrap']","['Wrapper', 'wrapper']"
Integrability,"// Wrapper - A wrapper node for TargetConstantPool,; // TargetExternalSymbol, and TargetGlobalAddress.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,2,"['Wrap', 'wrap']","['Wrapper', 'wrapper']"
Integrability,// Wrapper around ExternalAAWrapperPass so that the default constructor gets the; // callback.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAliasAnalysis.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAliasAnalysis.h,1,['Wrap'],['Wrapper']
Integrability,// Wrapper around ExternalAAWrapperPass so that the default; // constructor gets the callback.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper around TMinuit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MinuitWrapper.h:3,Wrap,Wrapper,3,tmva/tmva/inc/TMVA/MinuitWrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MinuitWrapper.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper around TStorage::ReAlloc to update the signature.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx:3,Wrap,Wrapper,3,io/io/src/TMapFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx,1,['Wrap'],['Wrapper']
Integrability,// Wrapper around an MCSymbolXCOFF.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp,1,['Wrap'],['Wrapper']
Integrability,// Wrapper around handleOccurrence that enforces Flags.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['Wrap'],['Wrapper']
Integrability,// Wrapper around parse function,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['Wrap'],['Wrapper']
Integrability,// Wrapper around transferSymbol to transfer all of \a Obj symbols; // to \a NewSymtab. This function does not write in the output file.; // \returns the number of symbols in \a NewSymtab.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper callback: except this to become available from Cling directly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.h:3,Wrap,Wrapper,3,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper class for GL capture & output routines",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLOutput.h:3,Wrap,Wrapper,3,graf3d/gl/inc/TGLOutput.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLOutput.h,2,"['Wrap', 'rout']","['Wrapper', 'routines']"
Integrability,"// Wrapper class for misc GL pieces",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h:3,Wrap,Wrapper,3,graf3d/gl/inc/TGLUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper class for the multimap of DeclId_t and TClass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:3,Wrap,Wrapper,3,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['Wrap'],['Wrapper']
Integrability,// Wrapper class that contains Clause's information defined in DirectiveBase.td; // and provides helper methods for accessing it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,1,['Wrap'],['Wrapper']
Integrability,// Wrapper class that contains DirectiveLanguage's information defined in; // DirectiveBase.td and provides helper methods for accessing it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,1,['Wrap'],['Wrapper']
Integrability,// Wrapper class that contains VersionedClause's information defined in; // DirectiveBase.td and provides helper methods for accessing it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,1,['Wrap'],['Wrapper']
Integrability,// Wrapper class that contains a Directive's information defined in; // DirectiveBase.td and provides helper methods for accessing it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper class to make the TUUID comparable for use as key type in std::map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooSharedProperties.h:3,Wrap,Wrapper,3,roofit/roofitcore/inc/RooSharedProperties.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooSharedProperties.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper class to steer the merging of files produced on workers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofOutputFile.h:3,Wrap,Wrapper,3,proof/proof/inc/TProofOutputFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofOutputFile.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper for Perl-like regular expression matching.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TPRegexp.h:3,Wrap,Wrapper,3,core/base/inc/TPRegexp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TPRegexp.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveGeoNode.h:3,Wrap,Wrapper,3,graf3d/eve/inc/TEveGeoNode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveGeoNode.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for NLT projections).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveGeoShape.h:3,Wrap,Wrapper,3,graf3d/eve/inc/TEveGeoShape.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveGeoShape.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper for Tablegen'd function. enum Subtarget is not defined in any; // header files, so we need to wrap it in a function that takes unsigned; // instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,2,"['Wrap', 'wrap']","['Wrapper', 'wrap']"
Integrability,// Wrapper for all String/Memory Library Call Optimizations,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,1,['Wrap'],['Wrapper']
Integrability,// Wrapper for all floating point library call optimizations,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,1,['Wrap'],['Wrapper']
Integrability,// Wrapper for an MCSectionXCOFF.; // It can be a Csect or debug section or DWARF section and so on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp,1,['Wrap'],['Wrapper']
Integrability,// Wrapper for an overload set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:3,Wrap,Wrapper,3,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['Wrap'],['Wrapper']
Integrability,// Wrapper for function prototype sources. Wraps either a FunctionProtoType or; // an ObjCMethodDecl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:3,Wrap,Wrapper,3,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,2,['Wrap'],"['Wrapper', 'Wraps']"
Integrability,// Wrapper for getTargetShuffleMask with InUnary;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper for getting the safety from the parallel world.; // Takes care of caching mechanics and talking to the Safety function of parallel world.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:3,Wrap,Wrapper,3,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper for global binary operators that swap arguments",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPFunction.h:3,Wrap,Wrapper,3,bindings/pyroot/cppyy/CPyCppyy/src/CPPFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPFunction.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper for global free/static C++ functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPFunction.h:3,Wrap,Wrapper,3,bindings/pyroot/cppyy/CPyCppyy/src/CPPFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPFunction.h,1,['Wrap'],['Wrapper']
Integrability,// Wrapper for loops and exceptions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySortRegion.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySortRegion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySortRegion.h,1,['Wrap'],['Wrapper']
Integrability,// Wrapper for sample counters including range counter and branch counter,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,1,['Wrap'],['Wrapper']
Integrability,// Wrapper function used by driver for adding SDLs during link phase.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:3,Wrap,Wrapper,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,1,['Wrap'],['Wrapper']
Integrability,// Wrapper implementation using the closure mechanism.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,2,['Wrap'],['Wrapper']
Integrability,// Wrapper needed for tblgenned pseudo lowering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.h,2,['Wrap'],['Wrapper']
Integrability,"// Wrapper p.d.f adding an extended likelihood term to an existing p.d.f",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooExtendPdf.h:3,Wrap,Wrapper,3,roofit/roofitcore/inc/RooExtendPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooExtendPdf.h,1,['Wrap'],['Wrapper']
Integrability,// Wrapper structs/arrays that only contain vectors are passed just like; // vectors; strip them off if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:3,Wrap,Wrapper,3,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['Wrap'],['Wrapper']
Integrability,// Wrapper that holds the state needed to interact with the C API.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/RemarkParser.cpp:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/lib/Remarks/RemarkParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/RemarkParser.cpp,1,['Wrap'],['Wrapper']
Integrability,// Wrapper to fix template argument deduction failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h,2,['Wrap'],['Wrapper']
Integrability,// Wrapper to generate SMTSolverRef from BinarySymExpr.; // Sets the hasComparison and RetTy parameters. See getSMTSolverRef().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h:3,Wrap,Wrapper,3,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,1,['Wrap'],['Wrapper']
Integrability,// Wrapper to generate SMTSolverRef from SymbolCast data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h:3,Wrap,Wrapper,3,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper to generate SMTSolverRef from a range. If From == To, an; // equality will be created instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h:3,Wrap,Wrapper,3,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,1,['Wrap'],['Wrapper']
Integrability,// Wrapper to generate SMTSolverRef from unpacked binary symbolic; // expression. Sets the RetTy parameter. See getSMTSolverRef().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h:3,Wrap,Wrapper,3,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper to only selectively write one branch of the volume hierarchy to file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/inc/TGDMLWrite.h:3,Wrap,Wrapper,3,geom/gdml/inc/TGDMLWrite.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/inc/TGDMLWrite.h,1,['Wrap'],['Wrapper']
Integrability,"// Wrapper to query additional information for instructions like metadata or; // keywords like nsw, which provides conservative results if those cannot; // be safely used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:3,Wrap,Wrapper,3,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,1,['Wrap'],['Wrapper']
Integrability,// WrapperJT - A wrapper node for TargetJumpTable; // Add pseudo op to model memcpy for struct byval.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:3,Wrap,WrapperJT,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,2,"['Wrap', 'wrap']","['WrapperJT', 'wrapper']"
Integrability,// WrapperPIC - A wrapper node for TargetGlobalAddress in; // PIC mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:3,Wrap,WrapperPIC,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,2,"['Wrap', 'wrap']","['WrapperPIC', 'wrapper']"
Integrability,// Wrappers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:3,Wrap,Wrappers,3,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,1,['Wrap'],['Wrappers']
Integrability,"// Wrappers around the ISD opcodes of the same name. The output is GR128.; // Input operands may be GR64 or GR32, depending on the instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Wrap,Wrappers,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,2,"['Wrap', 'depend']","['Wrappers', 'depending']"
Integrability,"// Wrappers around the inner loop of an 8- or 16-bit ATOMIC_SWAP or; // ATOMIC_LOAD_<op>.; //; // Operand 0: the address of the containing 32-bit-aligned field; // Operand 1: the second operand of <op>, in the high bits of an i32; // for everything except ATOMIC_SWAPW; // Operand 2: how many bits to rotate the i32 left to bring the first; // operand into the high bits; // Operand 3: the negative of operand 2, for rotating the other way; // Operand 4: the width of the field in bits (8 or 16)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Wrap,Wrappers,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,1,['Wrap'],['Wrappers']
Integrability,// Wrappers for ISD::*_EXTEND and ISD::TRUNCATE to prevent DAG,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:3,Wrap,Wrappers,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,1,['Wrap'],['Wrappers']
Integrability,"// Wrappers for many device-side standard library functions, incl. math; // functions, became compiler builtins in CUDA-9 and have been removed from the; // CUDA headers. Clang now provides its own implementation of the wrappers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:3,Wrap,Wrappers,3,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,2,"['Wrap', 'wrap']","['Wrappers', 'wrappers']"
Integrability,"// Wrappers to make transition to TEveDigitSet as base easier",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveQuadSet.h:3,Wrap,Wrappers,3,graf3d/eve/inc/TEveQuadSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveQuadSet.h,1,['Wrap'],['Wrappers']
Integrability,// Wrapping the C bindings types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp:3,Wrap,Wrapping,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp,1,['Wrap'],['Wrapping']
Integrability,// Wraps Addr with a call to llvm.preserve.static.offset intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:3,Wrap,Wraps,3,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['Wrap'],['Wraps']
Integrability,// Wraps a TargetGlobalAddress that should be loaded using PC-relative; // accesses (LARL). Operand 0 is the address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Wrap,Wraps,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,1,['Wrap'],['Wraps']
Integrability,// Write a message into the extension block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp:11,message,message,11,interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp,1,['message'],['message']
Integrability,// Write all protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp:13,protocol,protocols,13,interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp,1,['protocol'],['protocols']
Integrability,// Write generic Traverse routine,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:26,rout,routine,26,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,1,['rout'],['routine']
Integrability,"// Write into the buffer, wrapping if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/circular_raw_ostream.cpp:26,wrap,wrapping,26,interpreter/llvm-project/llvm/lib/Support/circular_raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/circular_raw_ostream.cpp,1,['wrap'],['wrapping']
Integrability,"// Write out the dependency targets, trying to avoid overly long; // lines when possible. We try our best to emit exactly the same; // dependency file as GCC>=10, assuming the included files are the; // same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:17,depend,dependency,17,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,2,['depend'],['dependency']
Integrability,// Write out the path indices with a right arrow and the message as a row.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:57,message,message,57,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,1,['message'],['message']
Integrability,// Write out the protocols that are directly referenced by the @interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:17,protocol,protocols,17,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,2,"['interface', 'protocol']","['interface', 'protocols']"
Integrability,// Write out the protocols that are transitively referenced.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:17,protocol,protocols,17,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,1,['protocol'],['protocols']
Integrability,"// Write the line table. It depends on remapping working, so it must come; // after the source location offsets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:28,depend,depends,28,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['depend'],['depends']
Integrability,"// Write the mapping information describing our module dependencies and how; // each of those modules were mapped into our own offset/ID space, so that; // the reader can build the appropriate mapping to its own offset/ID space.; // The map consists solely of a blob with the following format:; // *(module-kind:i8; // module-name-len:i16 module-name:len*i8; // source-location-offset:i32; // identifier-id:i32; // preprocessed-entity-id:i32; // macro-definition-id:i32; // submodule-id:i32; // selector-id:i32; // declaration-id:i32; // c++-base-specifiers-id:i32; // type-id:i32); //; // module-kind is the ModuleKind enum value. If it is MK_PrebuiltModule,; // MK_ExplicitModule or MK_ImplicitModule, then the module-name is the; // module name. Otherwise, it is the module file name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:55,depend,dependencies,55,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['depend'],['dependencies']
Integrability,// Write the message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp:13,message,message,13,interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp,1,['message'],['message']
Integrability,"// Write the module/PCH depending on what mode we are on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:24,depend,depending,24,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['depend'],['depending']
Integrability,"// Write the wrapper code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingBaseClassInfo.cxx:13,wrap,wrapper,13,core/metacling/src/TClingBaseClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingBaseClassInfo.cxx,1,['wrap'],['wrapper']
Integrability,// Writer out root metadata for current protocol: struct _protocol_t,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:40,protocol,protocol,40,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,1,['protocol'],['protocol']
Integrability,// Writes the dependencies to specified path. The content is first sorted by; // OpCode and then by the filename (in alphabetical order).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h:14,depend,dependencies,14,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h,1,['depend'],['dependencies']
Integrability,"// X + Y.; // If Add has nuw wrap flag, then if either X or Y is non-zero the result is; // non-zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:29,wrap,wrap,29,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['wrap'],['wrap']
Integrability,"// X11 Synchronization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx:7,Synchroniz,Synchronization,7,graf2d/asimage/src/TASImage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx,2,['Synchroniz'],['Synchronization']
Integrability,"// X11 synchronization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/inc/Win32Constants.h:7,synchroniz,synchronization,7,core/winnt/inc/Win32Constants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/inc/Win32Constants.h,1,['synchroniz'],['synchronization']
Integrability,// XSAVE features are dependent on basic XSAVE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp:22,depend,dependent,22,interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp,1,['depend'],['dependent']
Integrability,"// XXX: Hardcoding to 1 for now.; //; // I think the StackWidth should be stored as metadata associated with the; // MachineFunction. This metadata can either be added by a frontend, or; // calculated by a R600 specific LLVM IR pass.; //; // The StackWidth determines how stack objects are laid out in memory.; // For a vector stack variable, like: int4 stack[2], the data will be stored; // in the following ways depending on the StackWidth.; //; // StackWidth = 1:; //; // T0.X = stack[0].x; // T1.X = stack[0].y; // T2.X = stack[0].z; // T3.X = stack[0].w; // T4.X = stack[1].x; // T5.X = stack[1].y; // T6.X = stack[1].z; // T7.X = stack[1].w; //; // StackWidth = 2:; //; // T0.X = stack[0].x; // T0.Y = stack[0].y; // T1.X = stack[0].z; // T1.Y = stack[0].w; // T2.X = stack[1].x; // T2.Y = stack[1].y; // T3.X = stack[1].z; // T3.Y = stack[1].w; //; // StackWidth = 4:; // T0.X = stack[0].x; // T0.Y = stack[0].y; // T0.Z = stack[0].z; // T0.W = stack[0].w; // T1.X = stack[1].x; // T1.Y = stack[1].y; // T1.Z = stack[1].z; // T1.W = stack[1].w",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUFrameLowering.cpp:414,depend,depending,414,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUFrameLowering.cpp,1,['depend'],['depending']
Integrability,"// XXXX This is stoopid. Need some more flaxible way od doing this.; // XXXX Make it dependant on projection parameters and on individual; // XXXX points (a function of r and z, eg).; // XXXX Also, we could represnet track with a bezier curve, trying; // XXXX to stretch it as far out as we can so the fewest number of; // XXXX points/directions needs to be transferred.; // Project points, store originals (needed for break-points).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveTrackProjected.cxx:85,depend,dependant,85,graf3d/eve7/src/REveTrackProjected.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveTrackProjected.cxx,1,['depend'],['dependant']
Integrability,"// XXXX We might want to send e.name, e.message, e.stack back to the server.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveManager.js:40,message,message,40,ui5/eve7/lib/EveManager.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveManager.js,1,['message'],['message']
Integrability,"// XrdProofd PROOF manager interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofMgrLite.h:27,interface,interface,27,proof/proof/inc/TProofMgrLite.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofMgrLite.h,1,['interface'],['interface']
Integrability,"// YAMLIn dynamically allocates for Interface file and in case of error,; // memory leak will occur unless wrapped around unique_ptr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp:36,Interface,Interface,36,interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp,2,"['Interface', 'wrap']","['Interface', 'wrapped']"
Integrability,"// Your constructor needs a name and title and then a list of the; // dependent variables and parameters used by this PDF. Use an; // underscore in the variable names to distinguish them from your; // own local versions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooNovosibirsk.h:70,depend,dependent,70,roofit/roofit/inc/RooNovosibirsk.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooNovosibirsk.h,1,['depend'],['dependent']
Integrability,"// Zero extends are a little more awkward. At the point we are matching; // this, we are looking for an AND with a (-1, 0, -1, 0) buildvector mask.; // That might be before of after a bitcast depending on how the and is; // placed. Because this has to look through bitcasts, it is currently only; // supported on LE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:192,depend,depending,192,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['depend'],['depending']
Integrability,// Zero/UNDEF insertion - zero out element and remove dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:54,depend,dependency,54,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['dependency']
Integrability,"// ZeroIsPoison is set, and zero is contained. We discern three cases, in; // which a zero can appear:; // 1) Lower is zero, handling cases of kind [0, 1), [0, 2), etc.; // 2) Upper is zero, wrapped set, handling cases of kind [3, 0], etc.; // 3) Zero contained in a wrapped set, e.g., [3, 2), [3, 1), etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:191,wrap,wrapped,191,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,4,['wrap'],['wrapped']
Integrability,"// [...] In addition, if the argument is the name or address of a; // set of overloaded functions and/or function templates, its; // associated classes and namespaces are the union of those; // associated with each of the members of the set: the namespace; // in which the function or function template is defined and the; // classes and namespaces associated with its (non-dependent); // parameter types and return type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:374,depend,dependent,374,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['depend'],['dependent']
Integrability,"// [any flop] C, undef -> NaN; // [any flop] undef, C -> NaN; // We could potentially specialize NaN/Inf constants vs. 'normal'; // constants (possibly differently depending on opcode and operand). This; // would allow returning undef sometimes. But it is always safe to fold to; // NaN because we can choose the undef operand as NaN, and any FP opcode; // with a NaN operand will propagate NaN.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:164,depend,depending,164,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['depend'],['depending']
Integrability,"// [basic.lookup.argdep]p4:; // Argument-dependent lookup finds all declarations of functions and; // function templates that; // - ...; // - are declared as a friend ([class.friend]) of any class with a; // reachable definition in the set of associated entities,; //; // FIXME: If there's a merged definition of D that is reachable, then; // the friend declaration should be considered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:41,depend,dependent,41,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['depend'],['dependent']
Integrability,"// [dcl.fct.def.coroutine]p15; // The expression co_await promise.final_suspend() shall not be; // potentially-throwing ([except.spec]).; //; // First time seeing an error, emit the error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:188,message,message,188,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['message'],['message']
Integrability,// [module.interface]p1:; // An export-declaration shall inhabit a namespace scope and appear in the; // purview of a module interface unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:11,interface,interface,11,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,2,['interface'],['interface']
Integrability,// [module.interface]p1:; // An export-declaration shall inhabit a namespace scope.; //; // So it is meaningless to talk about redeclaration which is not at namespace; // scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,interface,interface,11,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['interface'],['interface']
Integrability,// [module.interface]p6:; // A redeclaration of an entity X is implicitly exported if X was introduced by; // an exported declaration; otherwise it shall not be exported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,interface,interface,11,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['interface'],['interface']
Integrability,"// [module.interface]p7:; // A declaration is attached to a module as follows:; // - If the declaration is a non-dependent friend declaration that nominates a; // function with a declarator-id that is a qualified-id or template-id or that; // nominates a class other than with an elaborated-type-specifier with neither; // a nested-name-specifier nor a simple-template-id, it is attached to the; // module to which the friend is attached ([basic.link]).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,interface,interface,11,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,"['depend', 'interface']","['dependent', 'interface']"
Integrability,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:11,interface,interface,11,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,2,['interface'],['interface']
Integrability,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:107,interface,interface,107,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,12,"['depend', 'interface']","['dependency', 'interface']"
Integrability,"// [module.reach]/p2; // Additional translation units on; // which the point within the program has an interface dependency may be; // considered reachable, but it is unspecified which are and under what; // circumstances.; //; // The decision here is to treat all additional tranditional units as; // unreachable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:103,interface,interface,103,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,2,"['depend', 'interface']","['dependency', 'interface']"
Integrability,"// \class GenericSyncDependenceAnalysis; ///; /// \brief Locate join blocks for disjoint paths starting at a divergent branch.; ///; /// An analysis per divergent branch that returns the set of basic; /// blocks whose phi nodes become divergent due to divergent control.; /// These are the blocks that are reachable by two disjoint paths from; /// the branch, or cycle exits reachable along a path that is disjoint; /// from a path to the cycle latch.; // --- Above line is not a doxygen comment; intentionally left blank ---; //; // Originally implemented in SyncDependenceAnalysis.cpp for DivergenceAnalysis.; //; // The SyncDependenceAnalysis is used in the UniformityAnalysis to model; // control-induced divergence in phi nodes.; //; // -- Reference --; // The algorithm is an extension of Section 5 of; //; // An abstract interpretation for SPMD divergence; // on reducible control flow graphs.; // Julian Rosemann, Simon Moll and Sebastian Hack; // POPL '21; //; //; // -- Sync dependence --; // Sync dependence characterizes the control flow aspect of the; // propagation of branch divergence. For example,; //; // %cond = icmp slt i32 %tid, 10; // br i1 %cond, label %then, label %else; // then:; // br label %merge; // else:; // br label %merge; // merge:; // %a = phi i32 [ 0, %then ], [ 1, %else ]; //; // Suppose %tid holds the thread ID. Although %a is not data dependent on %tid; // because %tid is not on its use-def chains, %a is sync dependent on %tid; // because the branch ""br i1 %cond"" depends on %tid and affects which value %a; // is assigned to.; //; //; // -- Reduction to SSA construction --; // There are two disjoint paths from A to X, if a certain variant of SSA; // construction places a phi node in X under the following set-up scheme.; //; // This variant of SSA construction ignores incoming undef values.; // That is paths from the entry without a definition do not result in; // phi nodes.; //; // entry; // / \; // A \; // / \ Y; // B C /; // \ / \ /; // D E; // \ ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:986,depend,dependence,986,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,2,['depend'],['dependence']
Integrability,"// \param[in] inputDTypes vector of ETensorType for data-types of Input tensors; /// \return Parsed RModel object; ///; /// The `Parse()` function defined in `TMVA::Experimental::SOFIE::PyTorch` will; /// parse a trained PyTorch .pt model into a RModel Object. The parser uses; /// internal functions of PyTorch to convert any PyTorch model into its; /// equivalent ONNX Graph. For this conversion, dummy inputs are built which are; /// passed through the model and the applied operators are recorded for populating; /// the ONNX graph. The `Parse()` function requires the shapes and data-types of; /// the input tensors which are used for building the dummy inputs.; /// After the said conversion, the nodes of the ONNX graph are then traversed to; /// extract properties like Node type, Attributes, input & output tensor names.; /// Function `AddOperator()` is then called on the extracted nodes to add the; /// operator into the RModel object. The nodes are also checked for adding any; /// required routines for executing the generated Inference code.; ///; /// The internal function used to convert the model to graph object returns a list; /// which contains a Graph object and a dictionary of weights. This dictionary is; /// used to extract the Initialized tensors for the model. The names and data-types; /// of the Initialized tensors are extracted along with their values in NumPy array,; /// and after approapriate type-conversions, they are added into the RModel object.; ///; /// For adding the Input tensor infos, the names of the input tensors are extracted; /// from the PyTorch ONNX graph object. The vector of shapes & data-types passed; /// into the `Parse()` function are used to extract the data-type and the shape; /// of the input tensors. Extracted input tensor infos are then added into the; /// RModel object by calling the `AddInputTensorInfo()` function.; ///; /// For the output tensor infos, names of the output tensors are also extracted; /// from the Graph object and ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/RModelParser_PyTorch.cxx:1218,rout,routines,1218,tmva/pymva/src/RModelParser_PyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/RModelParser_PyTorch.cxx,1,['rout'],['routines']
Integrability,// _Unwind_CallPersonality() wrapper,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:29,wrap,wrapper,29,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,1,['wrap'],['wrapper']
Integrability,"// _Unwind_CallPersonality() wrapper function, which calls the personality",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:29,wrap,wrapper,29,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,1,['wrap'],['wrapper']
Integrability,// __DEVICE__ is a helper macro with common set of attributes for the wrappers; // we implement in this file. We need static in order to avoid emitting unused; // functions and __forceinline__ helps inlining these wrappers at -O1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:70,wrap,wrappers,70,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,4,['wrap'],['wrappers']
Integrability,"// __add__, depends on # of args (see __pos__)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx:12,depend,depends,12,bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,1,['depend'],['depends']
Integrability,"// __attribute__((objc_independent_class)); // FIXME: change this to 'raw' interface type, so we can used 'interface' type; // for the common case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:75,interface,interface,75,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,2,['interface'],['interface']
Integrability,// __clang_cuda_texture_intrinsics.h must be included first in order to provide; // implementation for __nv_tex_surf_handler that CUDA's headers depend on.; // The implementation requires c++11 and only works with CUDA-9 or newer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:145,depend,depend,145,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,1,['depend'],['depend']
Integrability,// __is_interface_class only returns true when CL is invoked in /CLR mode and; // even then only when it is used with the 'interface struct ...' syntax; // Clang doesn't support /CLR which makes this type trait moot.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:123,interface,interface,123,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['interface'],['interface']
Integrability,// __null is usually wrapped in a macro. Go up a macro if that is the case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:21,wrap,wrapped,21,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['wrap'],['wrapped']
Integrability,"// __s/getitem__, depends on return type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx:18,depend,depends,18,bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,1,['depend'],['depends']
Integrability,"// __wasm_lpad_context global variable.; // This variable should be thread local. If the target does not support TLS,; // we depend on CoalesceFeaturesAndStripAtomics to downgrade it to; // non-thread-local ones, in which case we don't allow this object to be; // linked with other objects using shared memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:125,depend,depend,125,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,1,['depend'],['depend']
Integrability,"// `#pragma message` is supported in well-known compilers including gcc, clang, icc, and MSVC. But not nvc++.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/config/__cplusplus.cxx:12,message,message,12,config/__cplusplus.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/config/__cplusplus.cxx,1,['message'],['message']
Integrability,"// `c` does not depend on `x`, so we don't expect any varied action in the output; // (at the moment, `Vary` calls are not displayed)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:16,depend,depend,16,tree/dataframe/test/dataframe_vary.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx,1,['depend'],['depend']
Integrability,// a * b + c; // The shape depends on which operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp:27,depend,depends,27,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,1,['depend'],['depends']
Integrability,"// abstract class which should provide http-based protocol for server",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpEngine.h:50,protocol,protocol,50,net/http/inc/THttpEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpEngine.h,1,['protocol'],['protocol']
Integrability,"// activation function to be used for output layers, depending on estimator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h:53,depend,depending,53,tmva/tmva/inc/TMVA/MethodANNBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h,1,['depend'],['depending']
Integrability,"// add MnConfig file to define before everything compiler; // dependent macros",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnMatrix.h:62,depend,dependent,62,math/minuit2/inc/Minuit2/MnMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnMatrix.h,1,['depend'],['dependent']
Integrability,"// add extra padding at beginning or end (depending if SAME_UPPER or SAME_LOWER); // need to check this!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Conv.hxx:42,depend,depending,42,tmva/sofie/inc/TMVA/ROperator_Conv.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Conv.hxx,2,['depend'],['depending']
Integrability,"// add needed blas routines and libs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/src/RModel.cxx:19,rout,routines,19,tmva/sofie/src/RModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/src/RModel.cxx,1,['rout'],['routines']
Integrability,"// add nsw/nuw (xor Y, signmask), signmask --> Y; // The no-wrapping add guarantees that the top bit will be set by the add.; // Therefore, the xor must be clearing the already set sign bit of Y.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:60,wrap,wrapping,60,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['wrap'],['wrapping']
Integrability,"// add prefix to diagnostic messages if second compiler instance is existing; // e.g. in CUDA mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:28,message,messages,28,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['message'],['messages']
Integrability,"// add term depending on only gradient of model function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:12,depend,depending,12,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,1,['depend'],['depending']
Integrability,"// addNodeToInterval - This method exists to assist the generic ProcessNode; // with the task of adding a node to the new interval, depending on the; // type of the source node. In the case of a CFG source graph (BasicBlock; // case), the BasicBlock itself is added to the interval.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h:132,depend,depending,132,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h,1,['depend'],['depending']
Integrability,"// addNodeToInterval - This method exists to assist the generic ProcessNode; // with the task of adding a node to the new interval, depending on the; // type of the source node. In the case of a CFG source graph (BasicBlock; // case), the BasicBlock itself is added to the interval. In the case of; // an IntervalPartition source graph (Interval case), all of the member; // BasicBlocks are added to the interval.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h:132,depend,depending,132,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h,1,['depend'],['depending']
Integrability,// addrmode5 output depends on the selection dag addressing dividing the; // offset by 4 that it then later multiplies. Do this here as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:20,depend,depends,20,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,1,['depend'],['depends']
Integrability,// advance to the end of the referenced protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:40,protocol,protocols,40,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,1,['protocol'],['protocols']
Integrability,"// advertise analytical integration; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx:24,integrat,integration,24,roofit/roofit/src/RooNonCPEigenDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx,1,['integrat'],['integration']
Integrability,"// alignof and sizeof should never enter this code path here, so we go; // the pointer route.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:87,rout,route,87,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['rout'],['route']
Integrability,"// allocate entry, even if no dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx:30,depend,dependencies,30,html/src/TDocOutput.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx,1,['depend'],['dependencies']
Integrability,"// allow to dump messages to std output",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebDisplayHandle.cxx:17,message,messages,17,gui/webdisplay/src/RWebDisplayHandle.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebDisplayHandle.cxx,1,['message'],['messages']
Integrability,"// already existing message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMessageHandler.cxx:20,message,message,20,core/base/src/TMessageHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMessageHandler.cxx,1,['message'],['message']
Integrability,"// always send Job id first! This is used in worker_loop to route the; // update_state call to the correct Job.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Job.cxx:60,rout,route,60,roofit/multiprocess/test/test_Job.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Job.cxx,2,['rout'],['route']
Integrability,"// an error message should be eventually be reported in the virtual single SetVariable methods",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h:12,message,message,12,math/mathcore/inc/Math/Minimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h,1,['message'],['message']
Integrability,// anonymous namespace; // ParseContext wraps information that is only necessary while parsing; // ObjectFile and can be discarded once parsing is done.; // Used by BTFParser::parse* auxiliary functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp:40,wrap,wraps,40,interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp,1,['wrap'],['wraps']
Integrability,// any message from server clear all warnings,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/browser/controller/Browser.controller.js:7,message,message,7,ui5/browser/controller/Browser.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/browser/controller/Browser.controller.js,1,['message'],['message']
Integrability,"// any protocol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:7,protocol,protocol,7,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,1,['protocol'],['protocol']
Integrability,"// apply cut off to avoid routine to explode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testIntegrationMultiDim.cxx:26,rout,routine,26,math/mathcore/test/testIntegrationMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testIntegrationMultiDim.cxx,1,['rout'],['routine']
Integrability,"// apply cut off to avoid routine to explode; //unsigned int size = (unsigned int) 1.E8; // apply cut off to avoid routine to explode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testMCIntegration.cxx:26,rout,routine,26,math/mathmore/test/testMCIntegration.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testMCIntegration.cxx,2,['rout'],['routine']
Integrability,// array of receivers of highlight messages,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveManager.js:35,message,messages,35,ui5/eve7/lib/EveManager.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveManager.js,1,['message'],['messages']
Integrability,"// as above for `3', plus ""`4' This indicates that the following text; // should be treated as being wrapped in an implicit extern ""C"" block.""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:101,wrap,wrapped,101,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,1,['wrap'],['wrapped']
Integrability,"// attempt to retrieve pointer through old-style buffer interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx:56,interface,interface,56,bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,1,['interface'],['interface']
Integrability,"// avoid mis-leading byte count error message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:38,message,message,38,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,2,['message'],['message']
Integrability,"// backward compatible interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TF1.h:23,interface,interface,23,hist/hist/inc/TF1.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TF1.h,2,['interface'],['interface']
Integrability,"// base class interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/SimplexSeedGenerator.cxx:14,interface,interface,14,math/minuit2/src/SimplexSeedGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/SimplexSeedGenerator.cxx,1,['interface'],['interface']
Integrability,// binary data can be send only as addition to draw message; // here data can be placed in the queue and processed when all other prerequicities are done,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/tree/controller/TreeViewer.controller.js:52,message,message,52,ui5/tree/controller/TreeViewer.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/tree/controller/TreeViewer.controller.js,1,['message'],['message']
Integrability,// binary data can be send only as addition to draw message; // here data can be placed in the queue and processed when all other prerequisites are done,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomHierarchy.controller.js:52,message,message,52,ui5/geom/controller/GeomHierarchy.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomHierarchy.controller.js,2,['message'],['message']
Integrability,"// bind the nll function in the right interface for the Minimizer class; // as a function of only the parameters (poi + nuisance parameters)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/LikelihoodInterval.cxx:38,interface,interface,38,roofit/roostats/src/LikelihoodInterval.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/LikelihoodInterval.cxx,1,['interface'],['interface']
Integrability,"// binning is parameterized, range will need special handling in integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooParamBinning.h:65,integrat,integration,65,roofit/roofitcore/inc/RooParamBinning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooParamBinning.h,1,['integrat'],['integration']
Integrability,"// bins on this axis are integrated over",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldBinning.cxx:25,integrat,integrated,25,hist/unfold/src/TUnfoldBinning.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldBinning.cxx,2,['integrat'],['integrated']
Integrability,"// bool GSLMultiRootFinder::AddFunction( const ROOT::Math::IMultiGenFunction & func) {; // // clone and add function to the list; // // If using a derivative algorithm the function is checked if it implements; // // the gradient interface. If this is not the case the type is set to non-derivatibe algo; // ROOT::Math::IGenMultiFunction * f = func.Clone();; // if (f != 0) return false;; // if (fUseDerivAlgo) {; // bool gradFunc = (dynamic_cast<ROOT::Math::IMultiGradFunction *> (f) != 0 );; // if (!gradFunc) {; // MATH_ERROR_MSG(""GSLMultiRootFinder::AddFunction"",""Function does not provide gradient interface"");; // MATH_WARN_MSG(""GSLMultiRootFinder::AddFunction"",""clear the function list"");; // ClearFunctions();; // return false;; // }; // }; // fFunctions.push_back(f);; // return true;; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootFinder.cxx:229,interface,interface,229,math/mathmore/src/GSLMultiRootFinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootFinder.cxx,2,['interface'],['interface']
Integrability,"// both limits are finite: use the plain trapezoid integrator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx:51,integrat,integrator,51,roofit/roofitcore/src/RooImproperIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx,1,['integrat'],['integrator']
Integrability,"// both limits are infinite: integrate over (-1,+1) using; // the plain trapezoid integrator...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx:29,integrat,integrate,29,roofit/roofitcore/src/RooImproperIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx,2,['integrat'],"['integrate', 'integrator']"
Integrability,"// buffer objects are allowed under ""user knows best"" (this includes the buffer; // interface to ctypes.c_void_p, which results in a void**)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:84,interface,interface,84,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['interface'],['interface']
Integrability,"// build wrapper function code",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:9,wrap,wrapper,9,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['wrap'],['wrapper']
Integrability,"// build_vector lo, (load ptr) -> load_d16_hi ptr, lo; // build_vector lo, (zextload ptr from i8) -> load_d16_hi_u8 ptr, lo; // build_vector lo, (sextload ptr from i8) -> load_d16_hi_i8 ptr, lo; // Need to check for possible indirect dependencies on the other half of the; // vector to avoid introducing a cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp:234,depend,dependencies,234,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,1,['depend'],['dependencies']
Integrability,"// by default do not use absolute tolerance in AdaptiveIntegration multidim.; // If an absolute tolerance is given integration of shar peaks often failed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx:115,integrat,integration,115,math/mathcore/src/IntegratorOptions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx,1,['integrat'],['integration']
Integrability,"// cache Error, Result and Status of integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h:37,integrat,integration,37,math/mathmore/inc/Math/GSLIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h,2,['integrat'],['integration']
Integrability,"// cache the new wrapper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:17,wrap,wrapper,17,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['wrap'],['wrapper']
Integrability,"// calculate cell value (depending on the given option 'cv')",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx:25,depend,depending,25,tmva/tmva/src/PDEFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx,1,['depend'],['depending']
Integrability,"// calculate now integral of x^n f(x); // wrapped the member function EvalNum in interface required by integrator using the functor class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:42,wrap,wrapped,42,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,3,"['integrat', 'interface', 'wrap']","['integrator', 'interface', 'wrapped']"
Integrability,"// calculate now integral of xf(x); // wrapped the member function EvalFirstMom in interface required by integrator using the functor class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:39,wrap,wrapped,39,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,3,"['integrat', 'interface', 'wrap']","['integrator', 'interface', 'wrapped']"
Integrability,"// calculate value of taylor expansion...; // (note: there's no chance to vectorize this one, since; // the value of the next iteration depend on the ones from; // the previous iteration)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooHeterogeneousMath.h:136,depend,depend,136,roofit/batchcompute/res/RooHeterogeneousMath.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooHeterogeneousMath.h,1,['depend'],['depend']
Integrability,"// calculation of the integral of the gradient functions; // for a function providing derivative w.r.t parameters; // x1 and x2 defines the integration interval , p the parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:140,integrat,integration,140,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,1,['integrat'],['integration']
Integrability,"// call routine from Fortran minuit (mnplot) to plot the vector of (x,y) points",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPlot.cxx:8,rout,routine,8,math/minuit2/src/MnPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPlot.cxx,1,['rout'],['routine']
Integrability,"// call routine from Fortran minuit (mnplot) to plot the vector of (x,y) points + minimum values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPlot.cxx:8,rout,routine,8,math/minuit2/src/MnPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPlot.cxx,1,['rout'],['routine']
Integrability,"// call the interface method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx:12,interface,interface,12,bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,1,['interface'],['interface']
Integrability,"// call wrapped method directly, no inheritance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CallContext.h:8,wrap,wrapped,8,bindings/pyroot/cppyy/CPyCppyy/src/CallContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CallContext.h,1,['wrap'],['wrapped']
Integrability,"// calling the MessageBox again does NOT work!*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH1Editor.cxx:15,Message,MessageBox,15,gui/ged/src/TH1Editor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH1Editor.cxx,2,['Message'],['MessageBox']
Integrability,"// canHandle makes sure that we _can_ correctly analyze the dependencies; // between A and B here -- for instance, we should not be dealing with heap; // load-store dependencies here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:60,depend,dependencies,60,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,2,['depend'],['dependencies']
Integrability,"// cannot clone this function for integrator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:34,integrat,integrator,34,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['integrat'],['integrator']
Integrability,"// cannot create dependency on iDep directly, use its first module instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx:17,depend,dependency,17,html/src/TDocOutput.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx,1,['depend'],['dependency']
Integrability,"// cansend = parseInt(msg.slice(i2 + 1, i3)), // TODO: take into account when sending messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:86,message,messages,86,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['message'],['messages']
Integrability,"// case FCN is built from Minuit interface so function object is created internally in Fitter class; // and needs to be cloned and managed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Fitter.cxx:33,interface,interface,33,math/mathcore/src/Fitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Fitter.cxx,1,['interface'],['interface']
Integrability,"// case of default handler; // encode class number in message id",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMessageHandler.cxx:54,message,message,54,core/base/src/TMessageHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMessageHandler.cxx,1,['message'],['message']
Integrability,// case of draw message from geometry viewer,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:16,message,message,16,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['message'],['message']
Integrability,"// case of polynomial function (no parameter dependency)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/WrappedTF1.cxx:45,depend,dependency,45,hist/hist/src/WrappedTF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/WrappedTF1.cxx,1,['depend'],['dependency']
Integrability,"// case of polynomial function (no parameter dependency) (case for dim = 1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Math/WrappedMultiTF1.h:45,depend,dependency,45,hist/hist/inc/Math/WrappedMultiTF1.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Math/WrappedMultiTF1.h,1,['depend'],['dependency']
Integrability,"// case of using RooFit for the integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:32,integrat,integration,32,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['integrat'],['integration']
Integrability,"// case where label bins are consecutive starting from first bin will work; // calling before a TH1::LabelsDeflate() will avoid this error message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:139,message,message,139,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['message'],['message']
Integrability,"// case with protocol, like: file:/data/file.root",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUrl.cxx:13,protocol,protocol,13,core/base/src/TUrl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUrl.cxx,1,['protocol'],['protocol']
Integrability,"// change names to be recognized by the plugin manager; // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:65,protocol,protocol,65,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,4,['protocol'],['protocol']
Integrability,"// check for a pre-existing, unused, wrapper if not found",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:37,wrap,wrapper,37,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['wrap'],['wrapper']
Integrability,"// check if Friedmans module is used.; // print a message concerning the options.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodRuleFit.cxx:50,message,message,50,tmva/tmva/src/MethodRuleFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodRuleFit.cxx,1,['message'],['message']
Integrability,"// check if any control messages still there to keep timer running",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:24,message,messages,24,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,1,['message'],['messages']
Integrability,"// check if message must be managed by this message handler",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMessageHandler.cxx:12,message,message,12,core/base/src/TMessageHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMessageHandler.cxx,2,['message'],['message']
Integrability,// check if object already shown in hierarchy (circular dependency),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:56,depend,dependency,56,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['depend'],['dependency']
Integrability,"// check if we actually depend on the plot variable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:24,depend,depend,24,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['depend'],['depend']
Integrability,// check if we could send at least one message more - for some meaningful actions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:39,message,message,39,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['message'],['message']
Integrability,"// check passing double_v interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/TFormulaVecTests.h:26,interface,interface,26,test/TFormulaVecTests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/TFormulaVecTests.h,2,['interface'],['interface']
Integrability,"// check protocol compatability; // protocol 1 is not supported anymore",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofSuperMaster.cxx:9,protocol,protocol,9,proof/proof/src/TProofSuperMaster.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofSuperMaster.cxx,2,['protocol'],['protocol']
Integrability,"// check protocol compatibility; // protocol 1 is not supported anymore",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:9,protocol,protocol,9,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['protocol'],['protocol']
Integrability,// check that PT is not incomplete/dependent,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:35,depend,dependent,35,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp,1,['depend'],['dependent']
Integrability,"// check that we have all variables to be integrated over on the LHS; // of the map, and all terms in the product do appear on the RHS",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx:42,integrat,integrated,42,roofit/roofitcore/src/RooProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx,1,['integrat'],['integrated']
Integrability,"// check whether we need to integrate over this term or not...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx:28,integrat,integrate,28,roofit/roofitcore/src/RooProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx,1,['integrat'],['integrate']
Integrability,// checkMachOAndArchFlags() checks to see if the ObjectFile is a Mach-O file; // and if it is and there is a list of architecture flags is specified then; // check to make sure this Mach-O file is one of those architectures or all; // architectures were specified. If not then an error is generated and this; // routine returns false. Else it returns true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp:312,rout,routine,312,interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,1,['rout'],['routine']
Integrability,// checkMachOAndArchFlags() checks to see if the SymbolicFile is a Mach-O file; // and if it is and there is a list of architecture flags is specified then; // check to make sure this Mach-O file is one of those architectures or all; // architectures was specificed. If not then an error is generated and this; // routine returns false. Else it returns true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:314,rout,routine,314,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,1,['rout'],['routine']
Integrability,// checkPointerTypesForAssignment - This is a very tricky routine (despite; // being closely modeled after the C99 spec:-). The odd characteristic of this; // routine is it effectively iqnores the qualifiers on the top level pointee.; // This circumvents the usual type rules specified in 6.2.7p1 & 6.7.5.[1-3].; // FIXME: add a couple examples in this comment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:58,rout,routine,58,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['rout'],['routine']
Integrability,"// clang currently supports native __float128 only on few targets, and; // this target does not have it. The most visible consequence of this is; // a specialization; // __is_floating_point_helper<__float128>; // in include/c++/6.3.0/type_traits:344 that clang then rejects. The; // specialization is protected by !if _GLIBCXX_USE_FLOAT128 (which is; // unconditionally set in c++config.h) and #if !__STRICT_ANSI__. Tweak; // the latter by disabling GNUMode.; // the nvptx backend doesn't support 128 bit float; // a error message is not necessary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:523,message,message,523,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['message'],['message']
Integrability,"// clang extension: this expr contains or references an error, and is; // considered dependent on how that error is resolved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:85,depend,dependent,85,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['depend'],['dependent']
Integrability,"// clang-format off; /**; * \class ROOT::Internal::RDF::RInterfaceBase; * \ingroup dataframe; * \brief The public interface to the RDataFrame federation of classes.; * \tparam Proxied One of the ""node"" base types (e.g. RLoopManager, RFilterBase). The user never specifies this type manually.; * \tparam DataSource The type of the RDataSource which is providing the data to the data frame. There is no source by default.; *; * The documentation of each method features a one liner illustrating how to use the method, for example showing how; * the majority of the template parameters are automatically deduced requiring no or very little effort by the user.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterfaceBase.hxx:114,interface,interface,114,tree/dataframe/inc/ROOT/RDF/RInterfaceBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterfaceBase.hxx,1,['interface'],['interface']
Integrability,"// clang-format off; /**; * \class ROOT::RDF::RInterface; * \ingroup dataframe; * \brief The public interface to the RDataFrame federation of classes.; * \tparam Proxied One of the ""node"" base types (e.g. RLoopManager, RFilterBase). The user never specifies this type manually.; * \tparam DataSource The type of the RDataSource which is providing the data to the data frame. There is no source by default.; *; * The documentation of each method features a one liner illustrating how to use the method, for example showing how; * the majority of the template parameters are automatically deduced requiring no or very little effort by the user.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:100,interface,interface,100,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['interface'],['interface']
Integrability,"// clang-format off; /**; * \class ROOT::RDataFrame; * \ingroup dataframe; * \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; on their machines completely transparently.<br>; Skip to the [class reference](#reference) or keep reading for the user guide. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; ~~~. Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; care of their execution. The implementation automatically puts in place several low level optimisations such as; multi-thread parallelization and caching. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:130,interface,interface,130,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,2,"['Interface', 'interface']","['Interface', 'interface']"
Integrability,"// clang-format off; /**; * \class TTreeReaderValue; * \ingroup treeplayer; * \brief An interface for reading values stored in ROOT columnar datasets; *; * The TTreeReaderValue is a type-safe tool to be used in association with a TTreeReader; * to access the values stored in TTree, TNtuple and TChain datasets.; * TTreeReaderValue can be also used to access collections such as `std::vector`s or TClonesArray; * stored in columnar datasets but it is recommended to use TTreeReaderArray instead as it offers; * several advantages.; *; * See the documentation of TTreeReader for more details and examples.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:88,interface,interface,88,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,1,['interface'],['interface']
Integrability,"// clang-format off; /**; \class ROOT::Experimental::Internal::RClusterPool; \ingroup NTuple; \brief Managed a set of clusters containing compressed and packed pages. The cluster pool steers the preloading of (partial) clusters. There is a two-step pipeline: in a first step,; compressed pages are read from clusters into a memory buffer. The second pipeline step decompresses the pages; and pushes them into the page pool. The actual logic of reading and unzipping is implemented by the page source.; The cluster pool only orchestrates the work queues for reading and unzipping. It uses one extra I/O thread for; reading waits for data from storage and generates no CPU load. The unzipping step of the pipeline therefore behaves differently depending on whether or not implicit multi-threading; is turned on. If it is turned off, i.e. in a single-threaded environment, the cluster pool will only read the; compressed pages and the page source has to uncompresses pages at a later point when data from the page is requested.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:742,depend,depending,742,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,1,['depend'],['depending']
Integrability,"// clang-format off; /**; \class ROOT::Experimental::Internal::RNTupleSerializer; \ingroup NTuple; \brief A helper class for serializing and deserialization of the RNTuple binary format. All serialization and deserialization routines return the number of bytes processed (written or read). The serialization routines can be called with a nullptr buffer, in which case only the size required to perform; a serialization is returned. Deserialization routines must be called with a buffer that is sufficiently large. Deserialization errors throw exceptions. Only when indicated or when passed as a parameter is the buffer size checked.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:225,rout,routines,225,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,3,['rout'],['routines']
Integrability,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageAllocator; \ingroup NTuple; \brief Abstract interface to allocate and release pages. The page allocator acquires and releases memory for pages. It does not load the page data, the returned pages; are empty but guaranteed to have enough contiguous space for the given number of elements.; The page allocator must be thread-safe.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx:112,interface,interface,112,tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx,1,['interface'],['interface']
Integrability,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageSink; \ingroup NTuple; \brief Abstract interface to write data into an ntuple. The page sink takes the list of columns and afterwards a series of page commits and cluster commits.; The user is responsible to commit clusters at a consistent point, i.e. when all pages corresponding to data; up to the given entry number are committed. An object of this class may either be a wrapper (for example a RPageSinkBuf) or a ""persistent"" sink,; inheriting from RPagePersistentSink.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:107,interface,interface,107,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageSinkBuf; \ingroup NTuple; \brief Wrapper sink that coalesces cluster column page writes; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx:101,Wrap,Wrapper,101,tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,1,['Wrap'],['Wrapper']
Integrability,"// clang-format off; /**; \class ROOT::Experimental::RNTupleDescriptor; \ingroup NTuple; \brief The on-storage meta-data of an ntuple. Represents the on-disk (on storage) information about an ntuple. The meta-data consists of a header and one or; several footers. The header carries the ntuple schema, i.e. the fields and the associated columns and their; relationships. The footer(s) carry information about one or several clusters. For every cluster, a footer stores; its location and size, and for every column the range of element indexes as well as a list of pages and page; locations. The descriptor provide machine-independent (de-)serialization of headers and footers, and it provides lookup routines; for ntuple objects (pages, clusters, ...). It is supposed to be usable by all RPageStorage implementations. The serialization does not use standard ROOT streamers in order to not let it depend on libCore. The serialization uses; the concept of frames: header, footer, and substructures have a preamble with version numbers and the size of the; writte struct. This allows for forward and backward compatibility when the meta-data evolves.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:700,rout,routines,700,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,2,"['depend', 'rout']","['depend', 'routines']"
Integrability,"// clang-format off; /**; \class ROOT::Experimental::RNTupleProcessor; \ingroup NTuple; \brief Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). Example usage (see ntpl012_processor.C for a full example):. ~~~{.cpp}; #include <ROOT/RNTupleProcessor.hxx>; using ROOT::Experimental::RNTupleProcessor;; using ROOT::Experimental::RNTupleOpenSpec;. std::vector<RNTupleOpenSpec> ntuples = {{""ntuple1"", ""ntuple1.root""}, {""ntuple2"", ""ntuple2.root""}};; auto processor = RNTupleProcessor::CreateChain(ntuples);. for (const auto &entry : processor) {; std::cout << ""pt = "" << *entry.GetPtr<float>(""pt"") << std::endl;; }; ~~~. An RNTupleProcessor is created by providing one or more RNTupleOpenSpecs, each of which contains the name and storage; location of a single RNTuple. The RNTuples are processed in the order in which they were provided. The RNTupleProcessor constructor also (optionally) accepts an RNTupleModel, which determines which fields should be; read. If no model is provided, a default model based on the descriptor of the first specified RNTuple will be used.; If a field that was present in the first RNTuple is not found in a subsequent one, an error will be thrown. The RNTupleProcessor provides an iterator which gives access to the REntry containing the field data for the current; entry. Additional bookkeeping information can be obtained through the RNTupleProcessor itself.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx:95,Interface,Interface,95,tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx,1,['Interface'],['Interface']
Integrability,"// clang-format off; /**; \class ROOT::VecOps::RVec; \brief A ""std::vector""-like collection of values implementing handy operation to analyse them; \tparam T The type of the contained objects. A RVec is a container designed to make analysis of values' collections fast and easy.; Its storage is contiguous in memory and its interface is designed such to resemble to the one; of the stl vector. In addition the interface features methods and; [external functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html) to ease the manipulation and analysis; of the data in the RVec. \note ROOT::VecOps::RVec can also be spelled simply ROOT::RVec. Shorthand aliases such as ROOT::RVecI or ROOT::RVecD; are also available as template instantiations of RVec of fundamental types. The full list of available aliases:; - RVecB (`bool`); - RVecC (`char`); - RVecD (`double`); - RVecF (`float`); - RVecI (`int`); - RVecL (`long`); - RVecLL (`long long`); - RVecU (`unsigned`); - RVecUL (`unsigned long`); - RVecULL (`unsigned long long`). \note RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or; other operations will be propagated potentially leaving the RVec object in an invalid state. \note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT naming convention in order; to make RVec a drop-in replacement for `std::vector`. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.1253756""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.1253756.svg"" alt=""DOI""></a>; \endhtmlonly. ## Table of Contents; - [Example](\ref example); - [Arithmetic operations, logical operations and mathematical functions](\ref operationsandfunctions); - [Owning and adopting memory](\ref owningandadoptingmemory); - [Sorting and manipulation of indices](\ref sorting); - [Usage in combination with RDataFrame](\ref usagetdataframe); - [Reference for the RVec class](\ref RVecdoxyref); - [Reference for RVec helper funct",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:324,interface,interface,324,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,2,['interface'],['interface']
Integrability,"// clang-format off; /**; \class TTreeReader; \ingroup treeplayer; \brief A simple, robust and fast interface to read values from ROOT columnar datasets such as TTree, TChain or TNtuple. TTreeReader is associated to TTreeReaderValue and TTreeReaderArray which are handles to concretely; access the information in the dataset. Example code can be found in; - tutorials/tree/hsimpleReader.C; - tutorials/tree/h1analysisTreeReader.C; - <a href=""https://github.com/root-project/roottest/tree/master/root/tree/reader"">This example</a>. You can generate a skeleton of `TTreeReaderValue<T>` and `TTreeReaderArray<T>` declarations; for all of a tree's branches using `TTree::MakeSelector()`. Roottest contains an; <a href=""https://github.com/root-project/roottest/tree/master/root/tree/reader"">example</a>; showing the full power. A simpler analysis example can be found below: it histograms a function of the px and py branches. ~~~{.cpp}; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C). #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"". void hsimpleReader() {; // Create a histogram for the values we read.; TH1F(""h1"", ""ntuple"", 100, -4, 4);. // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");. // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);. // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");. // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }. myHist->Draw();; }; ~~~. A more complete example including error handling and a few combinat",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:100,interface,interface,100,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['interface'],['interface']
Integrability,"// clang-format off; /**; \class TVirtualCollectionProxy; \brief Defines a common interface to inspect/change the contents of an object that represents a collection. Specifically, an object of a class that derives from TVirtualCollectionProxy relays accesses to any object that; matches the proxied collection type.; The interface provides two families of functions: (i) for direct manipulation, e.g. `Insert()` or `At()`; and; (ii) iterator-based, e.g. `GetFunctionCreateIterators()` or `GetFunctionNext()`.; TVirtualCollectionProxy objects are stateful; in particular, many functions require to set the object to operate; on via `PushProxy()` / `PopProxy()`. The `TPushPop` RAII class is provided for convenience.; A collection proxy for a given class can be permanently set using `TClass::CopyCollectionProxy()`.; The `Generate()` function should be overridden in derived classes to return a clean object of the most-derived class.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TVirtualCollectionProxy.h:82,interface,interface,82,core/cont/inc/TVirtualCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TVirtualCollectionProxy.h,2,['interface'],['interface']
Integrability,// clang-format off; // Each entry here is a link in the dependency chain starting from the; // extension that was added to the architecture first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/AArch64TargetParser.h:57,depend,dependency,57,interpreter/llvm-project/llvm/include/llvm/TargetParser/AArch64TargetParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/AArch64TargetParser.h,1,['depend'],['dependency']
Integrability,"// clang-format off; /// Given a callable with signature bool(T1, T2, ...) return a callable with same signature that returns the negated result; ///; /// The callable must have one single non-template definition of operator(). This is a limitation with respect to; /// std::not_fn, required for interoperability with RDataFrame.; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:296,interoperab,interoperability,296,tree/dataframe/inc/ROOT/RDFHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx,1,['interoperab'],['interoperability']
Integrability,"// clang-format off; /// Whether to wrap JavaScript import/export statements.; /// \code{.js}; /// true:; /// import {; /// VeryLongImportsAreAnnoying,; /// VeryLongImportsAreAnnoying,; /// VeryLongImportsAreAnnoying,; /// } from 'some/module.js'; ///; /// false:; /// import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from ""some/module.js""; /// \endcode; /// \version 3.9",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:36,wrap,wrap,36,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['wrap'],['wrap']
Integrability,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Book execution of a custom action using a user-defined helper object.; /// \tparam FirstColumn The type of the first column used by this action. Inferred together with OtherColumns if not present.; /// \tparam OtherColumns A list of the types of the other columns used by this action; /// \tparam Helper The type of the user-defined helper. See below for the required interface it should expose.; /// \param[in] helper The Action Helper to be scheduled.; /// \param[in] columns The names of the columns on which the helper acts.; /// \return the result of the helper wrapped in a RResultPtr.; ///; /// This method books a custom action for execution. The behavior of the action is completely dependent on the; /// Helper object provided by the caller. The required interface for the helper is described below (more; /// methods that the ones required can be present, e.g. a constructor that takes the number of worker threads is usually useful):; ///; /// ### Mandatory interface; ///; /// * `Helper` must publicly inherit from `ROOT::Detail::RDF::RActionImpl<Helper>`; /// * `Helper::Result_t`: public alias for the type of the result of this action helper. `Result_t` must be default-constructible.; /// * `Helper(Helper &&)`: a move-constructor is required. Copy-constructors are discouraged.; /// * `std::shared_ptr<Result_t> GetResultPtr() const`: return a shared_ptr to the result of this action (of type; /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:478,interface,interface,478,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,4,"['depend', 'interface', 'wrap']","['dependent', 'interface', 'wrapped']"
Integrability,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A C++ callable that computes the new value of the defined column.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; /// where:; /// - `T` is the type of the defined column; /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; /// being processed (see the class docs for more information).; ///; /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; /// starts rather than at every entry.; ///; /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; /// df.DefinePerSample(""weightbysample"",; /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; /// ~~~; // clang-format on; // TODO we could SFINAE on F's signature to provide friendlier compilation errors in case of signature mismatch",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1083,depend,depends,1083,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,2,"['depend', 'inject']","['depends', 'inject']"
Integrability,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined accumulation operation on the processed column values in each processing slot.; /// \tparam F The type of the aggregator callable. Automatically deduced.; /// \tparam U The type of the aggregator variable. Must be default-constructible, copy-constructible and copy-assignable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] aggregator A callable with signature `U(U,T)` or `void(U,T)`, where T is the type of the column, U is the type of the aggregator variable; /// \param[in] merger A callable with signature `U(U,U)` or `void(std::vector<U>&)` used to merge the results of the accumulations of each thread; /// \param[in] columnName The column to be aggregated. If omitted, the first default column is used instead.; /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// See previous Aggregate overload for more information.; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:975,wrap,wrapped,975,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['wrap'],['wrapped']
Integrability,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; ///; /// A reduction takes two values of a column and merges them into one (e.g.; /// by summing them, taking the maximum, etc). This action performs the; /// specified reduction operation on all processed column values, returning; /// a single value of the same type. The callable f must satisfy the general; /// requirements of a *processing function* besides having signature `T(T,T)`; /// where `T` is the type of column columnName.; ///; /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; /// overload.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; /// ~~~; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:530,wrap,wrapped,530,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['wrap'],['wrapped']
Integrability,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Return the sum of processed column values (*lazy action*).; /// \tparam T The type of the branch/column.; /// \param[in] columnName The name of the branch/column.; /// \param[in] initValue Optional initial value for the sum. If not present, the column values must be default-constructible.; /// \return the sum of the selected column wrapped in a RResultPtr.; ///; /// If T is not specified, RDataFrame will infer it from the data and just-in-time compile the correct; /// template specialization of this method.; /// If the type of the column is inferred, the return type is `double`, the type of the column otherwise.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column type (this invocation needs jitting internally); /// auto sum0 = myDf.Sum(""values"");; /// // Explicit column type; /// auto sum1 = myDf.Sum<double>(""values"");; /// ~~~; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:444,wrap,wrapped,444,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['wrap'],['wrapped']
Integrability,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns to disk, in a new TTree `treename` in file `filename`.; /// \param[in] treename The name of the output TTree.; /// \param[in] filename The name of the output TFile.; /// \param[in] columnNameRegexp The regular expression to match the column names to be selected. The presence of a '^' and a '$' at the end of the string is implicitly assumed if they are not specified. The dialect supported is PCRE via the TPRegexp class. An empty string signals the selection of all columns.; /// \param[in] options RSnapshotOptions struct with extra options to pass to TFile and TTree; /// \return a `RDataFrame` that wraps the snapshotted dataset.; ///; /// This function returns a `RDataFrame` built with the output tree as a source.; /// The types of the columns are automatically inferred and do not need to be specified.; ///; /// See above for a more complete description and example usages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:736,wrap,wraps,736,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['wrap'],['wraps']
Integrability,"// clang-format on; // clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column with a value dependent on the processing slot and the current entry.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function (excluding slot and entry).; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// This alternative implementation of `Define` is meant as a helper in writing entry-specific, thread-safe custom; /// columns. The expression must be a callable of signature R(unsigned int, ULong64_t, T1, T2, ...) where `T1, T2...`; /// are the types of the columns that the expression takes as input. The first parameter is reserved for an unsigned; /// integer representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with; /// different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1. The second parameter; /// is reserved for a `ULong64_t` representing the current entry being processed by the current thread.; ///; /// The following two `Define`s are equivalent, although `DefineSlotEntry` is slightly more performant:; /// ~~~{.cpp}; /// int function(unsigned int, ULong64_t, double, double);; /// Define(""x"", function, {""rdfslot_"", ""rdfentry_"", ""column1"", ""column2""}); /// DefineSlotEntry(""x"", function, {""column1"", ""column2""}); /// ~~~; ///; /// See Define() for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:163,depend,dependent,163,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['depend'],['dependent']
Integrability,"// clang-format on; // clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column with a value dependent on the processing slot.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function (excluding the slot number).; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// This alternative implementation of `Define` is meant as a helper to evaluate new column values in a thread-safe manner.; /// The expression must be a callable of signature R(unsigned int, T1, T2, ...) where `T1, T2...` are the types; /// of the columns that the expression takes as input. The first parameter is reserved for an unsigned integer; /// representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with; /// different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1.; ///; /// The following two calls are equivalent, although `DefineSlot` is slightly more performant:; /// ~~~{.cpp}; /// int function(unsigned int, double, double);; /// df.Define(""x"", function, {""rdfslot_"", ""column1"", ""column2""}); /// df.DefineSlot(""x"", function, {""column1"", ""column2""}); /// ~~~; ///; /// See Define() for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:163,depend,dependent,163,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['depend'],['dependent']
Integrability,"// clang-format on; // clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns to disk, in a new TTree `treename` in file `filename`.; /// \param[in] treename The name of the output TTree.; /// \param[in] filename The name of the output TFile.; /// \param[in] columnList The list of names of the columns/branches to be written.; /// \param[in] options RSnapshotOptions struct with extra options to pass to TFile and TTree.; /// \return a `RDataFrame` that wraps the snapshotted dataset.; ///; /// This function returns a `RDataFrame` built with the output tree as a source.; /// The types of the columns are automatically inferred and do not need to be specified.; ///; /// See above for a more complete description and example usages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:529,wrap,wraps,529,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['wrap'],['wraps']
Integrability,// clang-format on; /// Reference to an interface file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h:40,interface,interface,40,interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h,1,['interface'],['interface']
Integrability,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Gather filtering statistics.; /// \return the resulting `RCutFlowReport` instance wrapped in a RResultPtr.; ///; /// Calling `Report` on the main `RDataFrame` object gathers stats for; /// all named filters in the call graph. Calling this method on a; /// stored chain state (i.e. a graph node different from the first) gathers; /// the stats for all named filters in the chain section between the original; /// `RDataFrame` and that node (included). Stats are gathered in the same; /// order as the named filters have been added to the graph.; /// A RResultPtr<RCutFlowReport> is returned to allow inspection of the; /// effects cuts had.; ///; /// This action is *lazy*: upon invocation of; /// this method the calculation is booked but not executed. See RResultPtr; /// documentation.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto filtered = d.Filter(cut1, {""b1""}, ""Cut1"").Filter(cut2, {""b2""}, ""Cut2"");; /// auto cutReport = filtered3.Report();; /// cutReport->Print();; /// ~~~; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:191,wrap,wrapped,191,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['wrap'],['wrapped']
Integrability,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:297,wrap,wraps,297,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['wrap'],['wraps']
Integrability,// class AssociationIterator; /// Build a non-result-dependent generic selection expression accepting an; /// expression predicate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:53,depend,dependent,53,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['depend'],['dependent']
Integrability,// class DependenceAnalysis; /// Printer pass to dump DA results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:9,Depend,DependenceAnalysis,9,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,1,['Depend'],['DependenceAnalysis']
Integrability,// class DependenceAnalysisPrinterPass; /// Legacy pass manager pass to access dependence information,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:9,Depend,DependenceAnalysisPrinterPass,9,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,2,"['Depend', 'depend']","['DependenceAnalysisPrinterPass', 'dependence']"
Integrability,// class DependenceAnalysisWrapperPass; /// createDependenceAnalysisPass - This creates an instance of the; /// DependenceAnalysis wrapper pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:9,Depend,DependenceAnalysisWrapperPass,9,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,3,"['Depend', 'wrap']","['DependenceAnalysis', 'DependenceAnalysisWrapperPass', 'wrapper']"
Integrability,// class DependenceInfo; /// AnalysisPass to compute dependence information in a function,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:9,Depend,DependenceInfo,9,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,2,"['Depend', 'depend']","['DependenceInfo', 'dependence']"
Integrability,// class LongPollSocket; // ========================================================================================; /**; * @summary Class re-playing socket data from stored protocol; *; * @private; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:175,protocol,protocol,175,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['protocol'],['protocol']
Integrability,"// class RPagePersistentSink; // clang-format off; /**; \class ROOT::Experimental::Internal::RPageSource; \ingroup NTuple; \brief Abstract interface to read data from an ntuple. The page source is initialized with the columns of interest. Alias columns from projected fields are mapped to the; corresponding physical columns. Pages from the columns of interest can then be mapped into memory.; The page source also gives access to the ntuple's meta-data.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:139,interface,interface,139,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['interface'],['interface']
Integrability,"// class RResultBase; // clang-format off; /**; \class ROOT::Experimental::RResult; \ingroup Base; \brief The class is used as a return type for operations that can fail; wraps a value of type T or an RError. The RResult<T> class and their related classes are used for call chains that can throw exceptions,; such as I/O code paths. Throwing of the exception is deferred to allow for `if (result)` style error; checking where it makes sense. If an RResult in error state leaves the scope unchecked, it will throw. A function returning an RResult might look like this:. ~~~ {.cpp}; RResult<int> MyIOFunc(); {; int rv = syscall(...);; if (rv == -1); return R__FAIL(""user-facing error message"");; if (rv == kShortcut); return 42;; return R__FORWARD_RESULT(FuncThatReturnsRResultOfInt());; }; ~~~. Code using MyIOFunc might look like this:. ~~~ {.cpp}; auto result = MyIOOperation();; if (!result) {; // custom error handling or result.Throw(); }; switch (result.Inspect()) {; ...; }; ~~~. Note that RResult<void> can be used for a function without return value, like this. ~~~ {.cpp}; RResult<void> DoSomething(); {; if (failure); return R__FAIL(""user-facing error messge"");; return RResult<void>::Success();; }; ~~~. RResult<T>::Unwrap() can be used as a short hand for; ""give me the wrapped value or, in case of an error, throw"". For instance:. ~~~ {.cpp}; int value = FuncThatReturnsRResultOfInt().Unwrap(); // may throw; ~~~. There is no implict operator that converts RResult<T> to T. This is intentional to make it clear in the calling code; where an exception may be thrown.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:171,wrap,wraps,171,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,3,"['message', 'wrap']","['message', 'wrapped', 'wraps']"
Integrability,// class TDirectory; /**; * @summary Interface to read objects from ROOT files; *; * @desc Use {@link openFile} to create instance of the class; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:37,Interface,Interface,37,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Interface'],['Interface']
Integrability,// class TLocalFile; /**; * @summary Interface to read file in node.js; *; * @hideconstructor; * @desc Use {@link openFile} to create instance of the class; * @private; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:37,Interface,Interface,37,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Interface'],['Interface']
Integrability,"// class WebWindowHandle; /** @summary Method used to initialize connection to web window.; * @param {object} arg - arguments; * @param {string} [arg.socket_kind] - kind of connection longpoll|websocket, detected automatically from URL; * @param {number} [arg.credits = 10] - number of packets which can be send to server without acknowledge; * @param {object} arg.receiver - instance of receiver for websocket events, allows to initiate connection immediately; * @param {string} [arg.first_recv] - required prefix in the first message from RWebWindow, remain part of message will be returned in handle.first_msg; * @param {string} [arg.href] - URL to RWebWindow, using window.location.href by default; * @return {Promise} for ready-to-use {@link WebWindowHandle} instance */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:528,message,message,528,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,2,['message'],['message']
Integrability,"// class for which message has to be handled",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h:19,message,message,19,core/base/inc/TMessageHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h,1,['message'],['message']
Integrability,"// class to wrap a global function in a TFoamIntegrand function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:12,wrap,wrap,12,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,1,['wrap'],['wrap']
Integrability,"// class used to register integrator at loafing time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx:26,integrat,integrator,26,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,2,['integrat'],['integrator']
Integrability,"// class which wraps a pointer and implements a no-op increment operator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:15,wrap,wraps,15,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,1,['wrap'],['wraps']
Integrability,"// class wrapping evaluation of -TF1(x)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:9,wrap,wrapping,9,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['wrap'],['wrapping']
Integrability,"// class wrapping evaluation of -TF1(x) for multi-dimension",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:9,wrap,wrapping,9,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['wrap'],['wrapping']
Integrability,"// class wrapping evaluation of TF1(x) - y0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:9,wrap,wrapping,9,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['wrap'],['wrapping']
Integrability,"// class wrapping function evaluation directly in 1D interface (used for integration); // and implementing the methods for the momentum calculations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:9,wrap,wrapping,9,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,3,"['integrat', 'interface', 'wrap']","['integration', 'interface', 'wrapping']"
Integrability,"// clear all data members which depend on the unfolding results",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx:32,depend,depend,32,hist/unfold/src/TUnfoldSys.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx,1,['depend'],['depend']
Integrability,"// clear dirty flag as cache is up-to-date upon creation; // Introduce formal dependency of RooHistFunc on parameters so that const optimization code; // makes the correct decisions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx:78,depend,dependency,78,roofit/roofitcore/src/RooAbsCachedReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx,1,['depend'],['dependency']
Integrability,"// clear dirty flag as cache is up-to-date upon creation; // Introduce formal dependency of RooHistPdf on parameters so that const optimization code; // makes the correct decisions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:78,depend,dependency,78,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,1,['depend'],['dependency']
Integrability,"// client ""protocol"" version",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSocket.h:11,protocol,protocol,11,net/net/inc/TSocket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSocket.h,1,['protocol'],['protocol']
Integrability,"// client auth interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualAuth.h:15,interface,interface,15,core/base/inc/TVirtualAuth.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualAuth.h,2,['interface'],['interface']
Integrability,// code-object-version=X needs to be passed to clang-linker-wrapper to ensure; // that it is used by lld.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:60,wrap,wrapper,60,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['wrap'],['wrapper']
Integrability,"// coefficient for integral(T_0(x)) is 1 (implicit), integrate by hand; // T_0(x) and T_1(x), and use for n > 1: integral(T_n(x) dx) =; // (T_n+1(x) / (n + 1) - T_n-1(x) / (n - 1)) / 2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h:53,integrat,integrate,53,roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,1,['integrat'],['integrate']
Integrability,"// collect error message/trace (automatically clears exception, too)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx:17,message,message,17,bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,1,['message'],['message']
Integrability,"// complex logic with intermediate update; // while TTree reading not synchronized with drawing,; // next portion can appear before previous is drawn; // critical is last drawing which should wait for previous one; // therefore last_pr is kept as indication that promise is not yet processed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:70,synchroniz,synchronized,70,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['synchroniz'],['synchronized']
Integrability,// compute SplitIter for use by DependenceInfo::getSplitIteration(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:32,Depend,DependenceInfo,32,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['Depend'],['DependenceInfo']
Integrability,"// compute now the limit using the TGraph interpolations routine",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterResult.cxx:57,rout,routine,57,roofit/roostats/src/HypoTestInverterResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterResult.cxx,1,['rout'],['routine']
Integrability,"// compute psi +/- phi; // Depending on whether cosTheta is positive or negative and whether it; // is less than 1 in absolute value, different mathematically equivalent; // expressions are numerically stable.; // algorithm from; // adapted for the case 3-2-1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/src/3DConversions.cxx:27,Depend,Depending,27,math/genvector/src/3DConversions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/src/3DConversions.cxx,1,['Depend'],['Depending']
Integrability,"// concatSubVector - The function rebuilds the data to a correct expected; // order. An assumption(The shape of the matrix) was taken for the; // deinterleaved to work with lane's instructions like 'vpalign' or 'vphuf'.; // This function ensures that the data is built in correct way for the lane; // instructions. Each lane inside the vector is a 128-bit length.; //; // The 'InVec' argument contains the data in increasing order. In InVec[0] You; // can find the first 128 bit data. The number of different lanes inside a; // vector depends on the 'VecElems'.In general, the formula is; // VecElems * type / 128. The size of the array 'InVec' depends and equal to; // 'VecElems'.; // For VecElems = 16; // Invec[0] - |0| Vec[0] - |0|; // Invec[1] - |1| => Vec[1] - |1|; // Invec[2] - |2| Vec[2] - |2|; // For VecElems = 32; // Invec[0] - |0|1| Vec[0] - |0|3|; // Invec[1] - |2|3| => Vec[1] - |1|4|; // Invec[2] - |4|5| Vec[2] - |2|5|; // For VecElems = 64; // Invec[0] - |0|1|2 |3 | Vec[0] - |0|3|6|9 |; // Invec[1] - |4|5|6 |7 | => Vec[1] - |1|4|7|10|; // Invec[2] - |8|9|10|11| Vec[2] - |2|5|8|11|",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:535,depend,depends,535,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,2,['depend'],['depends']
Integrability,"// connect to proof startup message (to update progress bar)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:28,message,message,28,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['message'],['message']
Integrability,"// console.log(""EveManager web socket opened."");; // Presumably not needed at this point - known places where issues; // can cause server-client protocol breach are handled.; // window.onerror = this.globExceptionHandler.bind(this);; // console.log(""EveManager registered global error handler in window.onerror"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveManager.js:145,protocol,protocol,145,ui5/eve7/lib/EveManager.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveManager.js,1,['protocol'],['protocol']
Integrability,// console.log(`GET chid=0 message ${msg}`);,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:27,message,message,27,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['message'],['message']
Integrability,"// constructor for all types of integrations; // allocate workspace (only if not adaptive algorithm)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx:32,integrat,integrations,32,math/mathmore/src/GSLIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx,1,['integrat'],['integrations']
Integrability,"// constructor from external rng; // internal generator will be managed or not depending on; // how the GSLQRngWrapper is created",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLQuasiRandom.cxx:79,depend,depending,79,math/mathmore/src/GSLQuasiRandom.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLQuasiRandom.cxx,1,['depend'],['depending']
Integrability,"// constructor from external rng; // internal generator will be managed or not depending on; // how the GSLRngWrapper is created",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRndmEngines.cxx:79,depend,depending,79,math/mathmore/src/GSLRndmEngines.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRndmEngines.cxx,1,['depend'],['depending']
Integrability,"// constructor of GSL MCIntegrator. Vegas MC is set as default integration type if type == 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx:63,integrat,integration,63,math/mathmore/src/GSLMCIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx,1,['integrat'],['integration']
Integrability,"// constructor passing a multi-dimensional function interface; // constructor - without passing a function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx:52,interface,interface,52,math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,1,['interface'],['interface']
Integrability,// constructors; /** Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h:48,Integrat,Integrator,48,math/mathmore/inc/Math/GSLIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h,2,"['Integrat', 'integrat']","['Integrator', 'integration']"
Integrability,"// constructors; // /**; // constructor of GSL MCIntegrator using all the default options; // */; // GSLMCIntegrator( );; /** constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration. The possible types are defined in the MCIntegration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error (this parameter is actually not used and it can be ignored. The tolerance is fixed by the number of given calls); @param relTol desired relative Error (this parameter is actually not used and it can be ignored. The tolerance is fixed by the number of given calls); @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from the static method of ROOT::Math::IntegratorMultiDimOptions; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMCIntegrator.h:186,integrat,integration,186,math/mathmore/inc/Math/GSLMCIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMCIntegrator.h,3,"['Integrat', 'integrat']","['IntegratorMultiDimOptions', 'integration']"
Integrability,"// constructors; // GSLMCIntegrator::GSLMCIntegrator():; // fResult(0),fError(0),fStatus(-1),; // fWorkspace(0),; // fFunction(0); // {; // // constructor of GSL MCIntegrator.Vegas MC is set as default integration type; // //set random number generator; // fRng = new GSLRngWrapper();; // fRng->Allocate();; // // use the default options; // ROOT::Math::IntegratorMultiDimOptions opts; // this create the default options; // SetOptions(opts);; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx:202,integrat,integration,202,math/mathmore/src/GSLMCIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx,2,"['Integrat', 'integrat']","['IntegratorMultiDimOptions', 'integration']"
Integrability,// consume synchronized,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:11,synchroniz,synchronized,11,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['synchroniz'],['synchronized']
Integrability,// contract shape,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,contract,contract,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['contract'],['contract']
Integrability,"// contracting matrix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressLinear.cxx:3,contract,contracting,3,test/stressLinear.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressLinear.cxx,3,['contract'],['contracting']
Integrability,"// control synchronization of cache and packet sizes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TPacketizerAdaptive.h:11,synchroniz,synchronization,11,proof/proofplayer/inc/TPacketizerAdaptive.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TPacketizerAdaptive.h,1,['synchroniz'],['synchronization']
Integrability,// convenience wrappers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/SymbolicFile.h:15,wrap,wrappers,15,interpreter/llvm-project/llvm/include/llvm/Object/SymbolicFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/SymbolicFile.h,1,['wrap'],['wrappers']
Integrability,"// convert external number into name of Parameter (new interface returning a string)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserParameterState.cxx:55,interface,interface,55,math/minuit2/src/MnUserParameterState.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserParameterState.cxx,1,['interface'],['interface']
Integrability,"// convert tm struct to time_t, if values are given in UTC then; // no standard routine exists and we'll have to use our homegrown routine,; // if values are given in local time then use ""mktime""; // which also normalizes the tm struct as a byproduct",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTimeStamp.cxx:80,rout,routine,80,core/base/src/TTimeStamp.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTimeStamp.cxx,4,['rout'],['routine']
Integrability,"// copy constructor (needed for Cloning the object); // need special treatment because integrator; // has no copy constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:87,integrat,integrator,87,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['integrat'],['integrator']
Integrability,"// copy constructor; // copy constructor (deep copy or not depending on fFunctionCopied)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RichardsonDerivator.cxx:59,depend,depending,59,math/mathcore/src/RichardsonDerivator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RichardsonDerivator.cxx,1,['depend'],['depending']
Integrability,"// count per message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h:13,message,message,13,core/base/inc/TMessageHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h,1,['message'],['message']
Integrability,"// cout << ""RRI::ctor("" << GetName() << "") setting expensive object cache to "" << &expensiveObjectCache() << "" as taken from "" << function.GetName() << std::endl ;; // Use objects integrator configuration if none is specified",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:180,integrat,integrator,180,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['integrat'],['integrator']
Integrability,"// cout << ""RooLinearVar::isJacobianOK("" << GetName() << "") return false because slope depends on value of "" << arg->GetName() << endl ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinearVar.cxx:87,depend,depends,87,roofit/roofitcore/src/RooLinearVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinearVar.cxx,1,['depend'],['depends']
Integrability,"// cout << ""WVE integration of RooAddPdf without normalization, but have reference set, using ref set for normalization"" << std::endl ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:16,integrat,integration,16,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['integrat'],['integration']
Integrability,"// cout << ""adding following dependents to list of generated observables: "" ; pdfDep->Print(""1"") ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdGenContext.cxx:29,depend,dependents,29,roofit/roofitcore/src/RooProdGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdGenContext.cxx,1,['depend'],['dependents']
Integrability,"// cout << ""depends in value of ratio"" << endl ;; // Make specialize ratio instance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:12,depend,depends,12,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['depends']
Integrability,"// cout << ""does NOT depend on value of ratio"" << endl ;; // parg->Print(""t"") ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:21,depend,depend,21,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['depend']
Integrability,"// cout << GetName() << "": list of cross dependents for term "" << (*term) << "" set to "" << *crossDeps << endl ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:41,depend,dependents,41,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['dependents']
Integrability,"// cout << GetName() << "": list of imported dependents for term "" << (*term) << "" set to "" << impDeps << endl ;; // Make list of cross dependents (term is self contained for these dependents,; // but components import dependents from other components)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:44,depend,dependents,44,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,4,['depend'],['dependents']
Integrability,"// cout << GetName() << "": pdf = "" << pdf->GetName() << "" intset = "" << *pdfIntSet << "" pdfIntNoNormDeps = "" << pdfIntNoNormDeps << endl;; // Check if this PDF has dependents overlapping with one of the existing terms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:164,depend,dependents,164,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['dependents']
Integrability,"// cout << GetName() << "": pdf = "" << pdf->GetName() << "" pdfAllDeps = "" << pdfAllDeps << "" pdfNSet = "" << *pdfNSet << "" pdfCSet = "" << *pdfCSet << endl;; // Make list of normalization dependents for this PDF;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:185,depend,dependents,185,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['dependents']
Integrability,"// coverity[unchecked_value] We do not print error message, have not error; // return code and close the file anyway, not need to check the return value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx:51,message,message,51,io/io/src/TFilePrefetch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx,1,['message'],['message']
Integrability,"// create Integrator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/StatFunction.cxx:10,Integrat,Integrator,10,math/mathmore/test/StatFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/StatFunction.cxx,2,['Integrat'],['Integrator']
Integrability,"// create a vector of the fit contributions; // create function wrapper from an iterator of functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiFit.h:64,wrap,wrapper,64,math/mathmore/src/GSLMultiFit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiFit.h,3,['wrap'],['wrapper']
Integrability,"// create a wrapped function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/MultiNumGradFunction.h:12,wrap,wrapped,12,math/mathmore/inc/Math/MultiNumGradFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/MultiNumGradFunction.h,1,['wrap'],['wrapped']
Integrability,"// create a wrapper on the roorealsumfunc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx:12,wrap,wrapper,12,roofit/roofit/src/RooLagrangianMorphFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx,1,['wrap'],['wrapper']
Integrability,"// create concrete class for multidimensional integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Integrator.cxx:46,integrat,integration,46,math/mathcore/src/Integrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Integrator.cxx,1,['integrat'],['integration']
Integrability,"// create function wrapper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiMinimizer.h:19,wrap,wrapper,19,math/mathmore/src/GSLMultiMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiMinimizer.h,3,['wrap'],['wrapper']
Integrability,"// create function wrapper for minmizer; // a IMultiGenFunction type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/MnSim/demoMinimizer.cxx:19,wrap,wrapper,19,math/minuit2/test/MnSim/demoMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/MnSim/demoMinimizer.cxx,1,['wrap'],['wrapper']
Integrability,"// create gaussians and also the observables and parameters they depend on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/utils.h:65,depend,depend,65,roofit/multiprocess/test/utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/utils.h,2,['depend'],['depend']
Integrability,"// create semaphore to synchronize access (should use read/write lock)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx:23,synchroniz,synchronize,23,io/io/src/TMapFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx,1,['synchroniz'],['synchronize']
Integrability,"// create the concrete class for one-dimensional integration. Use the plug-in manager if needed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Integrator.cxx:49,integrat,integration,49,math/mathcore/src/Integrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Integrator.cxx,1,['integrat'],['integration']
Integrability,"// create wrapper class from TF1 (cannot use Functor, t.b.i.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:10,wrap,wrapper,10,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['wrap'],['wrapper']
Integrability,"// create wrapper if no re-use possible",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:10,wrap,wrapper,10,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['wrap'],['wrapper']
Integrability,// createLowerSwitchPass - Interface to this file...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:27,Interface,Interface,27,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,1,['Interface'],['Interface']
Integrability,"// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:58,depend,dependency,58,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['depend'],['dependency']
Integrability,// darwin_constant_cfstrings controls this. This is also dependent; // on other things like the runtime I believe. This is set even for C code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:57,depend,dependent,57,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,1,['depend'],['dependent']
Integrability,"// data members initialized to something different from zero:; // fA: filled from hist_A; // fDA: filled from hist_A; // fX0: filled from hist_A; // fL: filled depending on the regularisation scheme",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx:160,depend,depending,160,hist/unfold/src/TUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx,1,['depend'],['depending']
Integrability,"// deactivate used sec context if talking to proofd daemon running; // an old protocol (sec context disactivated remotely)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx:78,protocol,protocol,78,proof/proof/src/TSlave.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx,1,['protocol'],['protocol']
Integrability,"// debug result of Minos; // print error message in Minos; // Note that the only invalid condition can happen when the (npar-1) minimization fails; // The error is also invalid when the maximum number of calls is reached or a new function minimum is found; // in case of the parameter at the limit the error is not invalid.; // When the error is invalid the returned error is the Hessian error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Minuit2Minimizer.cxx:41,message,message,41,math/minuit2/src/Minuit2Minimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Minuit2Minimizer.cxx,1,['message'],['message']
Integrability,"// decode message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h:10,message,message,10,roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h,1,['message'],['message']
Integrability,"// delete function wrapper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootFinder.cxx:19,wrap,wrapper,19,math/mathmore/src/GSLMultiRootFinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootFinder.cxx,3,['wrap'],['wrapper']
Integrability,"// delta is the accuracy required in constructing the curve.; // If it is zero then the routine calculates a value otherwise; // it uses this value. (default is 0.0)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:88,rout,routine,88,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,1,['rout'],['routine']
Integrability,"// demonstrate minimal required interface for minimization; // create Minuit parameters without names; // starting values for parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/MnSim/DemoGaussSim.cxx:32,interface,interface,32,math/minuit2/test/MnSim/DemoGaussSim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/MnSim/DemoGaussSim.cxx,1,['interface'],['interface']
Integrability,"// depend on GSL linear algebra",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLInterpolator.cxx:3,depend,depend,3,math/mathmore/src/GSLInterpolator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLInterpolator.cxx,1,['depend'],['depend']
Integrability,// dependences caused by first iteration,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,depend,dependences,3,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,2,['depend'],['dependences']
Integrability,// dependences caused by last iteration,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,depend,dependences,3,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,2,['depend'],['dependences']
Integrability,"// dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TClassDocOutput.cxx:3,depend,dependencies,3,html/src/TClassDocOutput.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TClassDocOutput.cxx,1,['depend'],['dependencies']
Integrability,"// dependencies on other libraries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/inc/TDocInfo.h:3,depend,dependencies,3,html/inc/TDocInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/inc/TDocInfo.h,1,['depend'],['dependencies']
Integrability,"// depending of the buffer mode set the drawing window to either; // the canvas pixmap or to the canvas on-screen window",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx:3,depend,depending,3,graf2d/gpad/src/TCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx,1,['depend'],['depending']
Integrability,"// depending on how tasks are dispatched to worker threads and how quickly threads push and pop slot numbers from; // TSlotStack, the callback might be executed 1 to nSlots times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx:3,depend,depending,3,tree/dataframe/test/dataframe_callbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx,1,['depend'],['depending']
Integrability,"// depending on memory policy, some objects are no longer owned when passed to C++",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:3,depend,depending,3,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,2,['depend'],['depending']
Integrability,"// depending on memory policy, some objects need releasing when passed into functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:3,depend,depending,3,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,5,['depend'],['depending']
Integrability,"// depending on the object drawing option, the endcaps for error; // bar are drawn differently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLegend.cxx:3,depend,depending,3,graf2d/graf/src/TLegend.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLegend.cxx,1,['depend'],['depending']
Integrability,"// depending on type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGTableHeader.h:3,depend,depending,3,gui/gui/inc/TGTableHeader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGTableHeader.h,1,['depend'],['depending']
Integrability,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,depend,depends,3,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,6,"['Depend', 'depend', 'rout']","['Dependence', 'dependence', 'depends', 'routine']"
Integrability,"// depends on function shape; // test ROOT finder algorithm function with derivative",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/StatFunction.cxx:3,depend,depends,3,math/mathmore/test/StatFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/StatFunction.cxx,1,['depend'],['depends']
Integrability,"// dependsOn check needed until ParamHistFunc binBoundaries method fixed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx:3,depend,dependsOn,3,roofit/xroofit/src/xRooNLLVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx,1,['depend'],['dependsOn']
Integrability,// deps[i].base_addr = &<Dependencies[i].second>;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:25,Depend,Dependencies,25,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['Depend'],['Dependencies']
Integrability,// deps[i].flags = <Dependencies[i].first>;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:20,Depend,Dependencies,20,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['Depend'],['Dependencies']
Integrability,// deps[i].len = sizeof(<Dependencies[i].second>);,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:25,Depend,Dependencies,25,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['Depend'],['Dependencies']
Integrability,"// derivative with respect of the parameter to be integrated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:50,integrat,integrated,50,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,1,['integrat'],['integrated']
Integrability,"// derivatives should not depend on parameters since func is linear",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/WrappedTF1.cxx:26,depend,depend,26,hist/hist/src/WrappedTF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/WrappedTF1.cxx,1,['depend'],['depend']
Integrability,"// derivatives should not depend on parameters since; // function is linear",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Math/WrappedMultiTF1.h:26,depend,depend,26,hist/hist/inc/Math/WrappedMultiTF1.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Math/WrappedMultiTF1.h,1,['depend'],['depend']
Integrability,"// determine which observables need to be integrated over ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx:42,integrat,integrated,42,roofit/roofit/src/RooNDKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx,1,['integrat'],['integrated']
Integrability,"// dichroic filter interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h:19,interface,interface,19,geom/geom/inc/TGeoOpticalSurface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h,1,['interface'],['interface']
Integrability,"// did not run selector, error messages were already printed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofDraw.cxx:31,message,messages,31,proof/proofplayer/src/TProofDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofDraw.cxx,1,['message'],['messages']
Integrability,"// dielectric-Look-Up-Table DAVIS interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h:34,interface,interface,34,geom/geom/inc/TGeoOpticalSurface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h,1,['interface'],['interface']
Integrability,"// dielectric-Look-Up-Table interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h:28,interface,interface,28,geom/geom/inc/TGeoOpticalSurface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h,1,['interface'],['interface']
Integrability,"// dielectric-dielectric interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h:25,interface,interface,25,geom/geom/inc/TGeoOpticalSurface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h,1,['interface'],['interface']
Integrability,"// dielectric-metal interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h:20,interface,interface,20,geom/geom/inc/TGeoOpticalSurface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h,1,['interface'],['interface']
Integrability,"// do a Chi2 test; // switch off printing of info messages from chi2 test",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testDistSampler.cxx:50,message,messages,50,math/mathcore/test/testDistSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testDistSampler.cxx,2,['message'],['messages']
Integrability,"// do breakdown by removing parameters in blocks according to groups and seeing impact on variance; // this will give the correct sum but will be order-dependent if there are correlations between; // groups. therefore we will stick with group-by-group; // RooArgList pars(fr->floatParsFinal()); // pars to not condition on; // double variance = pow(dynamic_cast<RooRealVar*>(poi)->getError(),2);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:152,depend,dependent,152,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['depend'],['dependent']
Integrability,"// do certain settings depending on position of argument",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx:23,depend,depending,23,tree/treeplayer/src/TSelectorDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx,1,['depend'],['depending']
Integrability,"// do here to print message only one time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:20,message,message,20,hist/hist/src/TH1Merger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx,1,['message'],['message']
Integrability,"// do in here in case dependency on var",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:22,depend,dependency,22,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['depend'],['dependency']
Integrability,"// do not accept string to fill std::vector<char>; // TODO: this only tests for new-style buffers, which is too strict, but a; // generic check for Py_TYPE(fi)->tp_as_buffer is too loose (note that the; // main use case is numpy, which offers the new interface)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:251,interface,interface,251,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,1,['interface'],['interface']
Integrability,"// do not expose non-public methods as the Cling wrappers as those won't compile",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx:49,wrap,wrappers,49,bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,1,['wrap'],['wrappers']
Integrability,"// do not use GSL integrator which is not thread safe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:18,integrat,integrator,18,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,4,['integrat'],['integrator']
Integrability,"// do numerical integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/src/TUnuranContDist.cxx:16,integrat,integration,16,math/unuran/src/TUnuranContDist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/src/TUnuranContDist.cxx,1,['integrat'],['integration']
Integrability,"// does the model depend indirectly on this variable through an lvalue chain?; // otherwise, this variable will have to be generated with accept/reject",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx:18,depend,depend,18,roofit/roofitcore/src/RooGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx,1,['depend'],['depend']
Integrability,"// does the model depend on this variable directly, ie, like ""x"" in; // f(x) or f(x,g(x,y)) or even f(x,x) ?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx:18,depend,depend,18,roofit/roofitcore/src/RooGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx,1,['depend'],['depend']
Integrability,"// doesn't seem to exist .. gives an 'error message' and seems to work just fine without ... :); // fDrawButton->Connect(""Clicked()"",""TGNumberEntry"",fInput, ""ValueSet(Long_t)"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx:44,message,message,44,tmva/tmvagui/src/BDT_Reg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx,1,['message'],['message']
Integrability,"// doesn't seem to exist .. gives an 'error message' and seems to work just fine without ... :); // fDrawButton->Connect(""ValueSet(Long_t)"",""TGNumberEntry"",fInput, ""Clicked()"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx:44,message,message,44,tmva/tmvagui/src/BDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx,1,['message'],['message']
Integrability,"// don't emit signal when the default message handler is added; // as this happens in the TROOT ctor and the TQObject stuff is; // not yet properly initialized on some platforms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMessageHandler.cxx:38,message,message,38,core/base/src/TMessageHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMessageHandler.cxx,1,['message'],['message']
Integrability,// don't issue warning when protocol method is optional because primary; // class is not required to implement it and it is safe for protocol; // to implement it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:28,protocol,protocol,28,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['protocol'],['protocol']
Integrability,"// don't load it or any of its dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:31,depend,dependencies,31,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['depend'],['dependencies']
Integrability,"// don't need to integrate if doing a self-histogram",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:17,integrat,integrate,17,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['integrat'],['integrate']
Integrability,// drawing messages are created,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomViewer.controller.js:11,message,messages,11,ui5/geom/controller/GeomViewer.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomViewer.controller.js,1,['message'],['messages']
Integrability,"// dto2longs(d, i1, i2) returns (in i1 and i2) two unsigned ints; // representation of its double input. This is byte-ordering; // independent, and depends for complete portability ONLY on adherence; // to the IEEE 754 standard for 64-bit floating point representation.; // The first unsigned int contains the high-order bits in IEEE; thus; // 1.0 will always be 0x3FF00000, 00000000",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/BitReproducible.h:148,depend,depends,148,math/genvector/inc/Math/GenVector/BitReproducible.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/BitReproducible.h,1,['depend'],['depends']
Integrability,"// dtox(d) returns a 16-character string containing the (zero-filled) hex; // representation of its double input. This is byte-ordering; // independent, and depends for complete portability ONLY on adherence; // to the IEEE 754 standard for 64-bit floating point representation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/BitReproducible.h:157,depend,depends,157,math/genvector/inc/Math/GenVector/BitReproducible.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/BitReproducible.h,1,['depend'],['depends']
Integrability,"// due to the two-pass layout scheme for non-virtual-bases.; // * Virtual bases sometimes require a 'vtordisp' field that is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or may alias with the first; // field, even if they are of the same type.; // * The last zero size virtual base may be placed at the end of the struct; // potentially aliasing another object.; // * The ABI attempts to avoid aliasing of zero sized bases by adding padding; // between bases or vbases with specific properties. The criteria for; // add",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:2098,inject,injected,2098,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['inject'],['injected']
Integrability,"// dummy for testing; // iret |= FitUsingNewFitter<DUMMY>(h1,f1);; // use simply TF1 wrapper; // ROOT::Math::WrappedMultiTF1 f2(*f1);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testFitPerf.cxx:85,wrap,wrapper,85,roofit/roofit/test/testFitPerf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testFitPerf.cxx,1,['wrap'],['wrapper']
Integrability,"// e.g. ""default void f() {}"" in a Java interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:40,interface,interface,40,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['interface'],['interface']
Integrability,"// elements that depend on manager and need to be destroyed with it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveProjectionManager.h:17,depend,depend,17,graf3d/eve/inc/TEveProjectionManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveProjectionManager.h,2,['depend'],['depend']
Integrability,"// else create a wrapper function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:17,wrap,wrapper,17,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['wrap'],['wrapper']
Integrability,"// else, this is a message accessing a property on super.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp:19,message,message,19,interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp,1,['message'],['message']
Integrability,"// emitDbgValue can be called with:; // Source=[AssignRecord|DbgValueInst*|DbgAssignIntrinsic*|DPValue*]; // Since AssignRecord can be cast to one of the latter two types, and all; // other types have a shared interface, we use a template to handle the latter; // three types, and an explicit overload for AssignRecord that forwards to; // the template version with the right type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:210,interface,interface,210,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['interface'],['interface']
Integrability,"// emitGlobalDtorWithCXAAtExit will emit a call to either __cxa_thread_atexit; // or __cxa_atexit depending on whether this VarDecl is a thread-local storage; // or not. CXAAtExit controls only __cxa_atexit, so use it if it is enabled.; // We can always use __cxa_thread_atexit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:98,depend,depending,98,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['depend'],['depending']
Integrability,"// empty message signifies a Worker exited",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/mpi/src/TMPIFile.cxx:9,message,message,9,io/mpi/src/TMPIFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/mpi/src/TMPIFile.cxx,1,['message'],['message']
Integrability,// end (interface to eviction advisers); // Interface to priority advisers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:8,interface,interface,8,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,2,"['Interface', 'interface']","['Interface', 'interface']"
Integrability,// end (interface to priority advisers),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:8,interface,interface,8,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,1,['interface'],['interface']
Integrability,"// end C-linkage wrappers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:17,wrap,wrappers,17,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['wrap'],['wrappers']
Integrability,// end anonymous namespace; /* *** Helper Functions *** */; /// getConstantGEP() - Help routine to construct simple GEPs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:88,rout,routine,88,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['rout'],['routine']
Integrability,"// end anonymous namespace; // Check - We know that cond should be true, if not print an error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:95,message,message,95,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,1,['message'],['message']
Integrability,// end anonymous namespace; // Get the input data dependencies that must be ready before UseMI can issue.; // Return true if UseMI has any physreg operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:50,depend,dependencies,50,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['depend'],['dependencies']
Integrability,// end anonymous namespace; // Maximum number of dependencies that can be handled in the dependency matrix.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:49,depend,dependencies,49,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,2,['depend'],"['dependencies', 'dependency']"
Integrability,"// end anonymous namespace; // The recurrence AR has been shown to have no signed/unsigned wrap or something; // close to it. Typically, if we can prove NSW/NUW for AR, then we can just as; // easily prove NSW/NUW for its preincrement or postincrement sibling. This; // allows normalizing a sign/zero extended AddRec as such: {sext/zext(Step +; // Start),+,Step} => {(Step + sext/zext(Start),+,Step} As a result, the; // expression ""Step + sext/zext(PreIncAR)"" is congruent with; // ""sext/zext(PostIncAR)""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:91,wrap,wrap,91,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// end anonymous namespace; // setPreservesCFG - This function should be called to by the pass, iff they do; // not:; //; // 1. Add or remove basic blocks from the function; // 2. Modify terminator instructions in any way.; //; // This function annotates the AnalysisUsage info object to say that analyses; // that only depend on the CFG are preserved by this pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Pass.cpp:320,depend,depend,320,interpreter/llvm-project/llvm/lib/IR/Pass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Pass.cpp,1,['depend'],['depend']
Integrability,"// end anonymous namespace; /// AddBuiltinOperatorCandidates - Add the appropriate built-in; /// operator overloads to the candidate set (C++ [over.built]), based; /// on the operator @p Op and the arguments given. For example, if the; /// operator is a binary '+', this routine might add ""int; /// operator+(int, int)"" to cover integer addition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:271,rout,routine,271,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['rout'],['routine']
Integrability,"// end anonymous namespace; /// AddPointerWithMoreQualifiedTypeVariants - Add the pointer type @p Ty to; /// the set of pointer types along with any more-qualified variants of; /// that type. For example, if @p Ty is ""int const *"", this routine; /// will add ""int const *"", ""int const volatile *"", ""int const; /// restrict *"", and ""int const volatile restrict *"" to the set of; /// pointer types. Returns true if the add of @p Ty itself succeeded,; /// false otherwise.; ///; /// FIXME: what to do about extended qualifiers?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:237,rout,routine,237,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['rout'],['routine']
Integrability,"// end anonymous namespace; /// Calculate the resource constrained minimum initiation interval for the; /// specified loop. We use the DFA to model the resources needed for; /// each instruction, and we ignore dependences. A different DFA is created; /// for each cycle that is required. When adding a new instruction, we attempt; /// to add it to each existing DFA, until a legal space is found. If the; /// instruction cannot be reserved in an existing DFA, we create a new one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:210,depend,dependences,210,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependences']
Integrability,"// end anonymous namespace; /// Check consistency between two Objective-C type parameter lists, e.g.,; /// between a category/extension and an \@interface or between an \@class and an; /// \@interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:145,interface,interface,145,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['interface'],['interface']
Integrability,// end anonymous namespace; /// Determines whether a given type depends on the given parameter; /// list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:64,depend,depends,64,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['depends']
Integrability,// end anonymous namespace; /// Emit an alloca (or GlobalValue depending on target); /// for the specified parameter and set up LocalDeclMap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:63,depend,depending,63,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['depend'],['depending']
Integrability,"// end anonymous namespace; /// Figure out if the loop is worth full unrolling.; ///; /// Complete loop unrolling can make some loads constant, and we need to know; /// if that would expose any further optimization opportunities. This routine; /// estimates this optimization. It computes cost of unrolled loop; /// (UnrolledCost) and dynamic cost of the original loop (RolledDynamicCost). By; /// dynamic cost we mean that we won't count costs of blocks that are known not; /// to be executed (i.e. if we have a branch in the loop and we know that at the; /// given iteration its condition would be resolved to true, we won't add up the; /// cost of the 'false'-block).; /// \returns Optional value, holding the RolledDynamicCost and UnrolledCost. If; /// the analysis failed (no benefits expected from the unrolling, or the loop is; /// too big to analyze), the returned value is std::nullopt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:235,rout,routine,235,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['rout'],['routine']
Integrability,// end anonymous namespace; /// Integrate with the new Pass Manager,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:32,Integrat,Integrate,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,1,['Integrat'],['Integrate']
Integrability,"// end anonymous namespace; /// Rebuilds a type within the context of the current instantiation.; ///; /// The type \p T is part of the type of an out-of-line member definition of; /// a class template (or class template partial specialization) that was parsed; /// and constructed before we entered the scope of the class template (or; /// partial specialization thereof). This routine will rebuild that type now; /// that we have entered the declarator's scope, which may produce different; /// canonical types, e.g.,; ///; /// \code; /// template<typename T>; /// struct X {; /// typedef T* pointer;; /// pointer data();; /// };; ///; /// template<typename T>; /// typename X<T>::pointer X<T>::data() { ... }; /// \endcode; ///; /// Here, the type ""typename X<T>::pointer"" will be created as a DependentNameType,; /// since we do not know that we can look into X<T> when we parsed the type.; /// This function will rebuild the type, performing the lookup of ""pointer""; /// in X<T> and returning an ElaboratedType whose canonical type is the same; /// as the canonical type of T*, allowing the return types of the out-of-line; /// definition and the declaration to match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:379,rout,routine,379,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,"['Depend', 'rout']","['DependentNameType', 'routine']"
Integrability,// end anonymous namespace; /// Strip aggregate type wrapping.; ///; /// This removes no-op aggregate types wrapping an underlying type. It will; /// strip as many layers of types as it can without changing either the type; /// size or the allocated size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:53,wrap,wrapping,53,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,2,['wrap'],['wrapping']
Integrability,// end anonymous namespace; /// Takes the result of a dependency scan and prints error / dependency files; /// based on the result.; ///; /// \returns True on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:54,depend,dependency,54,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,2,['depend'],['dependency']
Integrability,// end anonymous namespace; /// Throws foreign C++ exception.; /// @param ignoreIt unused parameter that allows function to match implied; /// generated function contract.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:162,contract,contract,162,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,1,['contract'],['contract']
Integrability,"// end anonymous namespace; /// Tries to perform unqualified lookup of the type decls in bases for; /// dependent class.; /// \return \a NotFound if no any decls is found, \a FoundNotType if found not a; /// type decl, \a FoundType if only type decls are found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:104,depend,dependent,104,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// end anonymous namespace; /// We know that cond should be true, if not print an error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:88,message,message,88,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['message'],['message']
Integrability,"// end anonymous namespace; /// isVariadicMessage - Returns whether the given message is a variadic message,; /// where all arguments must be Objective-C types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:78,message,message,78,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,2,['message'],['message']
Integrability,"// end anonymous namespace; //===----------------------------------------------------------------------===//; // SPARC v9 ABI Implementation.; // Based on the SPARC Compliance Definition version 2.4.1.; //; // Function arguments a mapped to a nominal ""parameter array"" and promoted to; // registers depending on their type. Each argument occupies 8 or 16 bytes in; // the array, structs larger than 16 bytes are passed indirectly.; //; // One case requires special care:; //; // struct mixed {; // int i;; // float f;; // };; //; // When a struct mixed is passed by value, it only occupies 8 bytes in the; // parameter array, but the int is passed in an integer register, and the float; // is passed in a floating point register. This is represented as two arguments; // with the LLVM IR inreg attribute:; //; // declare void f(i32 inreg %i, float inreg %f); //; // The code generator will only allocate 4 bytes from the parameter array for; // the inreg arguments. All other arguments are allocated a multiple of 8; // bytes.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/Sparc.cpp:299,depend,depending,299,interpreter/llvm-project/clang/lib/CodeGen/Targets/Sparc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/Sparc.cpp,1,['depend'],['depending']
Integrability,// end class Z3Context; /// Wrapper for Z3 Sort,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp:28,Wrap,Wrapper,28,interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp,1,['Wrap'],['Wrapper']
Integrability,// end namespace ARM; //===--------------------------------------------------------------------===//; // ARMTargetLowering - ARM Implementation of the TargetLowering interface,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:166,interface,interface,166,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,1,['interface'],['interface']
Integrability,// end namespace Cephes; /* routines for efficient polynomial evaluation*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.h:28,rout,routines,28,math/mathcore/src/SpecFuncCephes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.h,1,['rout'],['routines']
Integrability,// end namespace Cephes; /*---------------------------------------------------------------------------*/; /*---------------------------------------------------------------------------*/; /* Routines used within this implementation */; /*; * calculates a value of a polynomial of the form:; * a[0]x^N+a[1]x^(N-1) + ... + a[N]; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.cxx:190,Rout,Routines,190,math/mathcore/src/SpecFuncCephes.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.cxx,1,['Rout'],['Routines']
Integrability,// end namespace GCOV; /// GCOVBuffer - A wrapper around MemoryBuffer to provide GCOV specific; /// read operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/GCOV.h:42,wrap,wrapper,42,interpreter/llvm-project/llvm/include/llvm/ProfileData/GCOV.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/GCOV.h,1,['wrap'],['wrapper']
Integrability,"// end namespace Integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/IntegrationTypes.h:17,Integrat,Integration,17,math/mathmore/inc/Math/IntegrationTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/IntegrationTypes.h,1,['Integrat'],['Integration']
Integrability,"// end namespace ROOT; // move implementations here to avoid circle dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Cylindrical3D.h:68,depend,dependencies,68,math/genvector/inc/Math/GenVector/Cylindrical3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Cylindrical3D.h,7,['depend'],['dependencies']
Integrability,"// end namespace ROOT; ////////////////////////////////////////////////////////////////////////////////; // macro STATIC_CHECK; // Invocation: STATIC_CHECK(expr, id); // where:; // expr is a compile-time integral or pointer expression; // id is a C++ identifier that does not need to be defined; // If expr is zero, id will appear in a compile-time error message.; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/StaticCheck.h:355,message,message,355,math/smatrix/inc/Math/StaticCheck.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/StaticCheck.h,1,['message'],['message']
Integrability,// end namespace X86; //===--------------------------------------------------------------------===//; // X86 Implementation of the TargetLowering interface,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:146,interface,interface,146,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['interface'],['interface']
Integrability,// end namespace adl_detail; /// Returns the begin iterator to \p range using `std::begin` and; /// function found through Argument-Dependent Lookup (ADL).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h:132,Depend,Dependent,132,interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h,1,['Depend'],['Dependent']
Integrability,// end namespace afdo_detail; // This class serves sample counts correlation for SampleProfileLoader by; // analyzing pseudo probes and their function descriptors injected by; // SampleProfileProber.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:163,inject,injected,163,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,1,['inject'],['injected']
Integrability,"// end namespace bfi_detail; /// Base class for BlockFrequencyInfoImpl; ///; /// BlockFrequencyInfoImplBase has supporting data structures and some; /// algorithms for BlockFrequencyInfoImplBase. Only algorithms that depend on; /// the block type (or that call such algorithms) are skipped here.; ///; /// Nevertheless, the majority of the overall algorithm documentation lives with; /// BlockFrequencyInfoImpl. See there for details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:217,depend,depend,217,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,1,['depend'],['depend']
Integrability,// end namespace dependencies,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:17,depend,dependencies,17,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,5,['depend'],['dependencies']
Integrability,"// end namespace dependency_directives_scan; /// Scan the input for the preprocessor directives that might have; /// an effect on the dependencies for a compilation unit.; ///; /// This function ignores all non-preprocessor code and anything that; /// can't affect what gets included.; ///; /// \returns false on success, true on error. If the diagnostic engine is not; /// null, an appropriate error is reported using the given input location; /// with the offset that corresponds to the \p Input buffer offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/DependencyDirectivesScanner.h:134,depend,dependencies,134,interpreter/llvm-project/clang/include/clang/Lex/DependencyDirectivesScanner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/DependencyDirectivesScanner.h,1,['depend'],['dependencies']
Integrability,"// end namespace detail; // Keeps the callable object that is passed in, and execute it at the; // destruction of the returned object (usually at the scope exit where the; // returned object is kept).; //; // Interface is specified by p0052r2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopeExit.h:209,Interface,Interface,209,interpreter/llvm-project/llvm/include/llvm/ADT/ScopeExit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopeExit.h,1,['Interface'],['Interface']
Integrability,"// end namespace detail; /// A sum type over pointer-like types.; ///; /// This is a normal tagged union across pointer-like types that uses the low; /// bits of the pointers to store the tag.; ///; /// Each member of the sum type is specified by passing a \c; /// PointerSumTypeMember specialization in the variadic member argument list.; /// This allows the user to control the particular tag value associated with; /// a particular type, use the same type for multiple different tags, and; /// customize the pointer-like traits used for a particular member. Note that; /// these *must* be specializations of \c PointerSumTypeMember, no other type; /// will suffice, even if it provides a compatible interface.; ///; /// This type implements all of the comparison operators and even hash table; /// support by comparing the underlying storage of the pointer values. It; /// doesn't support delegating to particular members for comparisons.; ///; /// It also default constructs to a zero tag with a null pointer, whatever that; /// would be. This means that the zero value for the tag type is significant; /// and may be desirable to set to a state that is particularly desirable to; /// default construct.; ///; /// Having a supported zero-valued tag also enables getting the address of a; /// pointer stored with that tag provided it is stored in its natural bit; /// representation. This works because in the case of a zero-valued tag, the; /// pointer's value is directly stored into this object and we can expose the; /// address of that internal storage. This is especially useful when building an; /// `ArrayRef` of a single pointer stored in a sum type.; ///; /// There is no support for constructing or accessing with a dynamic tag as; /// that would fundamentally violate the type safety provided by the sum type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:702,interface,interface,702,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,1,['interface'],['interface']
Integrability,"// end namespace detail; /// Allocate memory in an ever growing pool, as if by bump-pointer.; ///; /// This isn't strictly a bump-pointer allocator as it uses backing slabs of; /// memory rather than relying on a boundless contiguous heap. However, it has; /// bump-pointer semantics in that it is a monotonically growing pool of memory; /// where every allocation is found by merely allocating the next N bytes in; /// the slab, or the next N bytes in the next slab.; ///; /// Note that this also has a threshold for forcing allocations above a certain; /// size into their own slab.; ///; /// The BumpPtrAllocatorImpl template defaults to using a MallocAllocator; /// object, which wraps malloc, to allocate memory, but it can be changed to; /// use a custom allocator.; ///; /// The GrowthDelay specifies after how many allocated slabs the allocator; /// increases the size of the slabs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:684,wrap,wraps,684,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,1,['wrap'],['wraps']
Integrability,"// end namespace llvm; // If the D<shift> instruction has a shift amount that is greater; // than 31 (checked in calling routine), lower it to a D<shift>32 instruction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp:121,rout,routine,121,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp,1,['rout'],['routine']
Integrability,"// end namespace llvm; // Sorting all the loads/stores first, then for each load/store, checking the; // following load/store one by one, until reach the first non-dependent one and; // call target hook to see if they can cluster.; // If FastCluster is enabled, we assume that, all the loads/stores have been; // preprocessed and now, they didn't have dependencies on each other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:164,depend,dependent,164,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['depend'],"['dependencies', 'dependent']"
Integrability,"// end namespace llvm; /// When a new SCC is created for the graph we first update the; /// FunctionAnalysisManager in the Proxy's result.; /// As there might be function analysis results cached for the functions now in; /// that SCC, two forms of updates are required.; ///; /// First, a proxy from the SCC to the FunctionAnalysisManager needs to be; /// created so that any subsequent invalidation events to the SCC are; /// propagated to the function analysis results cached for functions within it.; ///; /// Second, if any of the functions within the SCC have analysis results with; /// outer analysis dependencies, then those dependencies would point to the; /// *wrong* SCC's analysis result. We forcibly invalidate the necessary; /// function analyses so that they don't retain stale handles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:607,depend,dependencies,607,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,2,['depend'],['dependencies']
Integrability,// end namespace object; /// Helper class for helping synchronize access to the global address map; /// table. Access to this class should be serialized under a mutex.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:54,synchroniz,synchronize,54,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['synchroniz'],['synchronize']
Integrability,"// end namespace object; /// JITEventListener - Abstract interface for use by the JIT to notify clients; /// about significant events during compilation. For example, to notify; /// profilers and debuggers that need to know where functions have been emitted.; ///; /// The default implementation of each method does nothing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITEventListener.h:57,interface,interface,57,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITEventListener.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITEventListener.h,1,['interface'],['interface']
Integrability,"// end of namespace TThreadedObjectUtils; /**; * \class ROOT::TThreadedObject; * \brief A wrapper to make object instances thread private, lazily.; * \tparam T Class of the object to be made thread private (e.g. TH1F); * \ingroup Parallelism; *; * A wrapper which makes objects thread private. The methods of the underlying; * object can be invoked via the arrow operator. The object is created in; * a specific thread lazily, i.e. upon invocation of one of its methods.; * The correct object pointer from within a particular thread can be accessed; * with the overloaded arrow operator or with the Get method.; * In case an elaborate thread management is in place, e.g. in presence of; * stream of operations or ""processing slots"", it is also possible to; * manually select the correct object pointer explicitly.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:90,wrap,wrapper,90,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,2,['wrap'],['wrapper']
Integrability,"// error message if not already set",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:9,message,message,9,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['message'],['message']
Integrability,"// error message of last operation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSQLServer.h:9,message,message,9,net/net/inc/TSQLServer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSQLServer.h,2,['message'],['message']
Integrability,"// evaluate cdf at poi value x by integrating poi from [xmin,x] and all the nuisances",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:34,integrat,integrating,34,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['integrat'],['integrating']
Integrability,"// evaluate posterior function at a poi value x by integrating all nuisance parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:51,integrat,integrating,51,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,2,['integrat'],['integrating']
Integrability,"// evaluate using cached function; /**; evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h:196,integrat,integration,196,math/mathmore/inc/Math/GSLIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h,2,['integrat'],['integration']
Integrability,"// evaluate using free function pointer (same GSL signature); /**; signature for function pointers used by GSL; */; //typedef double ( * GSLFuncPointer ) ( double, void * );; /**; evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h:290,integrat,integration,290,math/mathmore/inc/Math/GSLIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h,5,"['adapter', 'integrat']","['adapter', 'integration']"
Integrability,"// every 24th number generation, several random numbers are generated; // and wasted depending upon the fLuxury level.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TRandom1.cxx:85,depend,depending,85,math/mathcore/src/TRandom1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TRandom1.cxx,2,['depend'],['depending']
Integrability,"// exactRDIVtest - Tests the RDIV subscript pair for dependence.; // Things of the form [c1 + a*i] and [c2 + b*j],; // where i and j are induction variable, c1 and c2 are loop invariant,; // and a and b are constants.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Works in some cases that symbolicRDIVtest doesn't, and vice versa.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:53,depend,dependence,53,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,2,['depend'],['dependence']
Integrability,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:320,Depend,Dependence,320,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,4,"['Depend', 'depend']","['Dependence', 'dependence', 'dependencies', 'depends']"
Integrability,"// exchange protocol level between client and master and between; // master and slave",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:12,protocol,protocol,12,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,2,['protocol'],['protocol']
Integrability,"// export {...} from '...';; // An export followed by ""from 'some string';"" is a re-export from; // another module identified by a URI and is treated as a; // LT_ImportStatement (i.e. prevent wraps on it for long URIs).; // Just ""export {...};"" or ""export class ..."" should not be treated as; // an import in this sense.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:192,wrap,wraps,192,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['wrap'],['wraps']
Integrability,// f16 must be promoted before using the lowering in this routine.; // fp128 does not use this lowering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:58,rout,routine,58,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['rout'],['routine']
Integrability,"// fHtml->firstBlock = fHtml->lastBlock = 0;; // Adjust the context for text that wraps around the table, if; // requested by an ALIGN=RIGHT or ALIGN=LEFT attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx:82,wrap,wraps,82,gui/guihtml/src/TGHtmlTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx,1,['wrap'],['wraps']
Integrability,"// fRawLines->SetToolTipText(""Retrieve all type of lines, service messages included"");; // fRawLines->SetState(kButtonUp);; // vlines_buttons->AddFrame(fRawLines, new TGLayoutHints(kLHintsCenterY | kLHintsLeft, 2, 2, 2, 2));; //; // Add frames to the global picture; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressLog.cxx:66,message,messages,66,gui/sessionviewer/src/TProofProgressLog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressLog.cxx,1,['message'],['messages']
Integrability,"// facade: forward interface of MnUserParameters and MnUserTransformation; // via MnUserParameterState",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnApplication.cxx:19,interface,interface,19,math/minuit2/src/MnApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnApplication.cxx,2,['interface'],['interface']
Integrability,"// facade: forward interface of MnUserParameters and MnUserTransformation; // via MnUserParameterState; // access to parameters (row-wise)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnApplication.h:19,interface,interface,19,math/minuit2/inc/Minuit2/MnApplication.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnApplication.h,1,['interface'],['interface']
Integrability,"// fdiv contract 1.0, (sqrt contract x) -> rsq for f16; // fdiv contract -1.0, (sqrt contract x) -> fneg(rsq) for f16",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:8,contract,contract,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,4,['contract'],['contract']
Integrability,"// fdot2_f32_f16 always flushes fp32 denormal operand and output to zero,; // regardless of the denorm mode setting. Therefore,; // unsafe-fp-math/fp-contract is sufficient to allow generating fdot2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:150,contract,contract,150,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['contract'],['contract']
Integrability,"// ffunctions can be TF1 or TFormula depending on how they are created",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx:37,depend,depending,37,math/minuit/src/TLinearFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx,1,['depend'],['depending']
Integrability,"// fill the input tensor fXInput from the current Event data; // with the correct shape depending on the model used; // The input tensor is used for network prediction after training ; // using a single event. The network batch size must be equal to 1. ; // The architecture specified at compile time in ArchitectureImpl_t; // is used. This should be the CPU architecture",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:88,depend,depending,88,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,1,['depend'],['depending']
Integrability,// find a bridge between vertices that connects hole with an outer ring and link it,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:10,bridg,bridge,10,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['bridg'],['bridge']
Integrability,"// find the minimum using the Simplex method of Nelder and Mead (does not use function gradient); // method to find initial simplex is slightly different than in the original Fortran; // Minuit since has not been proofed that one to be better; // synchronize print levels",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/SimplexBuilder.cxx:247,synchroniz,synchronize,247,math/minuit2/src/SimplexBuilder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/SimplexBuilder.cxx,1,['synchroniz'],['synchronize']
Integrability,"// first call also loads dependent libraries declared via the rootmap file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx:25,depend,dependent,25,core/base/src/TPluginManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx,1,['depend'],['dependent']
Integrability,"// first message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMessageHandler.cxx:9,message,message,9,core/base/src/TMessageHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMessageHandler.cxx,1,['message'],['message']
Integrability,"// first message to provide config",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx:9,message,message,9,tutorials/webgui/ping/ping.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx,1,['message'],['message']
Integrability,// first received message via the channel is confirmation of established connection,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:18,message,message,18,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['message'],['message']
Integrability,"// flag to control a warning message when size of array in disk are bigger than what requested",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DataSetFactory.cxx:29,message,message,29,tmva/tmva/src/DataSetFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DataSetFactory.cxx,1,['message'],['message']
Integrability,"// flag to reset counter for error messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLInterpolator.h:35,message,messages,35,math/mathmore/src/GSLInterpolator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLInterpolator.h,1,['message'],['messages']
Integrability,"// foam distribution interface; //ClassDefOverride(TFoamSampler,1) //Distribution sampler class based on FOAM",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/inc/TFoamSampler.h:21,interface,interface,21,math/foam/inc/TFoamSampler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/inc/TFoamSampler.h,1,['interface'],['interface']
Integrability,"// fold (SRA (SHL X, ShlConst), SraConst); // into (SHL (sext_in_reg X), ShlConst - SraConst); // or (sext_in_reg X); // or (SRA (sext_in_reg X), SraConst - ShlConst); // depending on relation between SraConst and ShlConst.; // We only do this if (Size - ShlConst) is equal to 8, 16 or 32. That allows; // us to do the sext_in_reg from corresponding bit.; // sexts in X86 are MOVs. The MOVs have the same code size; // as above SHIFTs (only SHIFT on 1 has lower code size).; // However the MOVs have 2 advantages to a SHIFT:; // 1. MOVs can write to a register that differs from source; // 2. MOVs accept memory operands",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:171,depend,depending,171,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['depending']
Integrability,"// fold (fsub (fneg (fpext (fmul, x, y))), z); // -> (fneg (fma (fpext x)), (fpext y), z); // Note: This could be removed with appropriate canonicalization of the; // input expression into (fneg (fadd (fpext (fmul, x, y)), z). However, the; // orthogonal flags -fp-contract=fast and -enable-unsafe-fp-math prevent; // from implementing the canonicalization in visitFSUB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:265,contract,contract,265,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['contract'],['contract']
Integrability,"// fold (fsub (fpext (fneg (fmul, x, y))), z); // -> (fneg (fma (fpext x), (fpext y), z)); // Note: This could be removed with appropriate canonicalization of the; // input expression into (fneg (fadd (fpext (fmul, x, y)), z). However, the; // orthogonal flags -fp-contract=fast and -enable-unsafe-fp-math prevent; // from implementing the canonicalization in visitFSUB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:265,contract,contract,265,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['contract'],['contract']
Integrability,// for (let d=0;d<elem.ascounter.length;++d) {; // let dep = handle.arr[elem.ascounter[d]]; // dependent element; // if (dep.first_readentry < lmt) not_needed = false; // check that counter provide required data; // },MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:95,depend,dependent,95,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['depend'],['dependent']
Integrability,"// for Fumili the fit method function interface is required",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx:38,interface,interface,38,math/fumili/src/TFumiliMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx,4,['interface'],['interface']
Integrability,"// for a while, this node's parent pointed to something of type Node2!!; // how to fix??? - I fxied it with a new constructor to avoid the shared_ptr<Node2> calling the const; // Node2& constructor via getting wrapped in a Node2(shared_ptr<TObject>) call; // out.back()->fParent = _pdf;; // std::cout << "" type2 = "" << out.back()->fParent->get()->ClassName() << std::endl;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:210,wrap,wrapped,210,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['wrap'],['wrapped']
Integrability,"// for calls through C interface, require extra space for reporting exceptions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:23,interface,interface,23,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['interface'],['interface']
Integrability,"// for defining unused variables in the interfaces; // and have still them in the documentation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Util.h:40,interface,interfaces,40,math/mathcore/inc/Math/Util.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Util.h,1,['interface'],['interfaces']
Integrability,"// for library dependencies of module in library",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx:15,depend,dependencies,15,html/src/TDocOutput.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx,1,['depend'],['dependencies']
Integrability,"// for the enumerations defining the types; /** Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integration methods). In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h:89,Integrat,Integrator,89,math/mathcore/inc/Math/IntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h,5,"['Integrat', 'integrat']","['Integrator', 'IntegratorMultiDimOptions', 'integration']"
Integrability,"// for the enumerations defining the types; // constructors; /**; Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h:97,Integrat,Integrator,97,math/mathcore/inc/Math/Integrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h,4,"['Integrat', 'integrat']","['Integrator', 'IntegratorOneDimOptions', 'integration']"
Integrability,"// for timing measurements; // orientation of cut: depends on signal and background mean values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h:51,depend,depends,51,tmva/tmva/inc/TMVA/MethodBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h,1,['depend'],['depends']
Integrability,"// for wrapping in GSL ROOT engines",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRndmEngines.cxx:7,wrap,wrapping,7,math/mathmore/src/GSLRndmEngines.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRndmEngines.cxx,1,['wrap'],['wrapping']
Integrability,"// force one time initialization of gROOT before we start; // (otherwise it might be done as a side effect of gEnv->GetValue and; // TROOT's initialization will call this routine).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:171,rout,routine,171,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,1,['rout'],['routine']
Integrability,"// force popdown in case of Qt interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGComboBox.cxx:31,interface,interface,31,gui/gui/src/TGComboBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGComboBox.cxx,1,['interface'],['interface']
Integrability,"// force to create message queue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:19,message,message,19,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['message'],['message']
Integrability,// forward declaration of one protocol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,protocol,protocol,30,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocol']
Integrability,"// forward interface of last state",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FunctionMinimum.h:11,interface,interface,11,math/minuit2/inc/Minuit2/FunctionMinimum.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FunctionMinimum.h,1,['interface'],['interface']
Integrability,"// forwarding of relevant TH1 interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooPlot.h:30,interface,interface,30,roofit/roofitcore/inc/RooPlot.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooPlot.h,1,['interface'],['interface']
Integrability,"// found a branched object, wrap its address for the object it represents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TTreePyz.cxx:28,wrap,wrap,28,bindings/pyroot/pythonizations/src/TTreePyz.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TTreePyz.cxx,1,['wrap'],['wrap']
Integrability,"// found a leaf, extract value and wrap with a Python object according to its type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TTreePyz.cxx:35,wrap,wrap,35,bindings/pyroot/pythonizations/src/TTreePyz.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TTreePyz.cxx,1,['wrap'],['wrap']
Integrability,"// found server depending on nuisance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx:16,depend,depending,16,roofit/roostats/src/AsymptoticCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx,1,['depend'],['depending']
Integrability,"// found server not depending on the gob",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx:20,depend,depending,20,roofit/xroofit/src/xRooFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx,1,['depend'],['depending']
Integrability,"// frodo:; // Because of the Member and Proto recursion, this has become a bit; // complicated, so here is how it works:; //; // root [1] var.a.b.c[TAB]; //; // will generate the sucessive calls:; // MakeClassFromVarName(""var.a.b.c"", context, 0) returns the class of ""c""; // MakeClassFromVarName(""var.a.b"", context, 1) returns the class of ""b""; // MakeClassFromVarName(""var.a"", context, 2) returns the class of ""a""; // MakeClassFromVarName(""var"", context, 3); // need to make sure ""varName"" exists; // because ""DetermineClass()"" prints clumsy error message otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx:549,message,message,549,core/rint/src/TTabCom.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx,1,['message'],['message']
Integrability,"// from ParseUri; // Message type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:21,Message,Message,21,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['Message'],['Message']
Integrability,"// from auto-folding operations, e.g.; // (i32 ext (i16 ext i8)) would be folded to (i32 ext i8).; // To simplify the type legalization, we want to keep these; // single steps separate during type legalization.; // TL_[EXTEND|TRUNCATE] Inp, i128 _, i32 Opc; // * Inp is the original input to extend/truncate,; // * _ is a dummy operand with an illegal type (can be undef),; // * Opc is the original opcode.; // The legalization process (in Hexagon lowering code) will; // first deal with the ""real"" types (i.e. Inp and the result),; // and once all of them are processed, the wrapper node will; // be replaced with the original ISD node. The dummy illegal; // operand is there to make sure that the legalization hooks; // are called again after everything else is legal, giving; // us the opportunity to undo the wrapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:576,wrap,wrapper,576,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,2,['wrap'],"['wrapper', 'wrapping']"
Integrability,"// function for solving (from a Genfunction interface)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx:44,interface,interface,44,math/mathmore/src/GSLSimAnnealing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx,1,['interface'],['interface']
Integrability,"// function is cloned when creating the adapter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Fitter.cxx:40,adapter,adapter,40,math/mathcore/src/Fitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Fitter.cxx,1,['adapter'],['adapter']
Integrability,"// function performing outer product using mndspr (DSPR) routine from BLAS",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/LaOuterProduct.cxx:57,rout,routine,57,math/minuit2/src/LaOuterProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/LaOuterProduct.cxx,1,['rout'],['routine']
Integrability,"// function to test using R interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/stressGoFTest.cxx:28,interface,interface,28,math/mathcore/test/stressGoFTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/stressGoFTest.cxx,1,['interface'],['interface']
Integrability,"// function will be cloned inside the wrapper PDFIntegral of CDFWrapper classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GoFTest.cxx:38,wrap,wrapper,38,math/mathcore/src/GoFTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GoFTest.cxx,1,['wrap'],['wrapper']
Integrability,"// gShowPrefixStack determines how messages are printed, it acts on all threads;; // race conditions when writing to this do not cause failures",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPrint.cxx:35,message,messages,35,math/minuit2/src/MnPrint.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPrint.cxx,1,['message'],['messages']
Integrability,"// gbl namespace is injected in cppyy.py; // create the memory regulator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:20,inject,injected,20,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['injected']
Integrability,"// gcd doesn't divide Delta, no dependence",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:32,depend,dependence,32,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,3,['depend'],['dependence']
Integrability,"// genShuffleBland - Creates shuffle according to two vectors.This function is; // only works on instructions with lane inside 256 registers. According to; // the mask 'Mask' creates a new Mask 'Out' by the offset of the mask. The; // offset amount depends on the two integer, 'LowOffset' and 'HighOffset'.; // Where the 'LowOffset' refers to the first vector and the highOffset refers to; // the second vector.; // |a0....a5,b0....b4,c0....c4|a16..a21,b16..b20,c16..c20|; // |c5...c10,a5....a9,b5....b9|c21..c26,a22..a26,b21..b25|; // |b10..b15,c11..c15,a10..a15|b26..b31,c27..c31,a27..a31|; // For the sequence to work as a mirror to the load.; // We must consider the elements order as above.; // In this function we are combining two types of shuffles.; // The first one is vpshufed and the second is a type of ""blend"" shuffle.; // By computing the shuffle on a sequence of 16 elements(one lane) and add the; // correct offset. We are creating a vpsuffed + blend sequence between two; // shuffles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:249,depend,depends,249,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,1,['depend'],['depends']
Integrability,"// generate a random number (virtual interface)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MixMaxEngine.h:37,interface,interface,37,math/mathcore/inc/Math/MixMaxEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MixMaxEngine.h,1,['interface'],['interface']
Integrability,"// generate the wrapper and JIT it; ignore wrapper generation errors (will simply; // result in a nullptr that is reported upstream if necessary; often, however,; // there is a different overload available that will do)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:16,wrap,wrapper,16,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,2,['wrap'],['wrapper']
Integrability,"// generic protocol (no default port)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUrl.cxx:11,protocol,protocol,11,core/base/src/TUrl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUrl.cxx,1,['protocol'],['protocol']
Integrability,"// generic python callable: create a C++ wrapper function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:41,wrap,wrapper,41,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['wrap'],['wrapper']
Integrability,"// get back startup message of proofserv (we are now talking with; // the real proofserver and not anymore with the proofd front-end)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx:20,message,message,20,proof/proof/src/TSlave.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx,1,['message'],['message']
Integrability,"// get bin content, depending on histmap",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx:20,depend,depending,20,hist/unfold/src/TUnfoldSys.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx,1,['depend'],['depending']
Integrability,"// get first the class stored in message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMessage.cxx:33,message,message,33,net/net/src/TMessage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMessage.cxx,1,['message'],['message']
Integrability,"// get help message text",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodC50.h:12,message,message,12,tmva/rmva/inc/TMVA/MethodC50.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodC50.h,20,['message'],['message']
Integrability,"// get help message text; //; // typical length of text line:; // ""|--------------------------------------------------------------|""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/src/MethodC50.cxx:12,message,message,12,tmva/rmva/src/MethodC50.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/src/MethodC50.cxx,5,['message'],['message']
Integrability,"// get integrated likelihood (posterior function)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:7,integrat,integrated,7,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['integrat'],['integrated']
Integrability,"// get specific help message from classifier",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/IMethod.h:21,message,message,21,tmva/tmva/inc/TMVA/IMethod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/IMethod.h,1,['message'],['message']
Integrability,"// get the default value of the machine - use CINT interface until we have a poper PROOF interface that we can call",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ProofConfig.h:51,interface,interface,51,roofit/roostats/inc/RooStats/ProofConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ProofConfig.h,2,['interface'],['interface']
Integrability,"// get the first lib from the list of lib and dependent libs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:46,depend,dependent,46,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,['depend'],['dependent']
Integrability,"// get the pointer to the wrapped DT node",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/CCTreeWrapper.h:26,wrap,wrapped,26,tmva/tmva/inc/TMVA/CCTreeWrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/CCTreeWrapper.h,1,['wrap'],['wrapped']
Integrability,"// getBaseInfo works with (Opcode, LMUL, 0) if no SEW instrument,; // or (Opcode, LMUL, SEW) if SEW instrument is active, and depends on LMUL; // and SEW, or (Opcode, LMUL, 0) if does not depend on SEW.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp:126,depend,depends,126,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp,2,['depend'],"['depend', 'depends']"
Integrability,"// global accessor; //; // Adapts a TRandom random number generator to the interface of the ones in the; // standard library (STL) so that TRandom derived generators can be used with; // STL algorithms such as `std::shuffle`.; //; // Example:; // ```; // std::vector<double> v {0, 1, 2, 3, 4, 5};; // TRandom3StdEngine rng(seed);; // std::shuffle(v.begin(), v.end(), rng);; // ```; //; // Or at a lower level:; // ```; // std::vector<double> v {0, 1, 2, 3, 4, 5};; // RandomGenerator<TRandom3> rng(seed);; // std::shuffle(v.begin(), v.end(), rng);; // ```; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h:75,interface,interface,75,tmva/tmva/inc/TMVA/Tools.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h,1,['interface'],['interface']
Integrability,"// go through list of non-optional methods and properties in each protocol; // in the PotentialImplicitProtocols list. If class implements every one of the; // methods and properties, then this class conforms to this protocol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:66,protocol,protocol,66,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,2,['protocol'],['protocol']
Integrability,"// hack against selecting the message box itself",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldEditor.cxx:30,message,message,30,gui/guibuilder/src/TGuiBldEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldEditor.cxx,2,['message'],['message']
Integrability,"// handle button messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx:17,message,messages,17,tree/treeviewer/src/TTreeViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx,1,['message'],['messages']
Integrability,"// handle menu messages; // check if sent by Options menu",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx:15,message,messages,15,tree/treeviewer/src/TTreeViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx,1,['message'],['messages']
Integrability,"// handle messages sent from the listview (right panel)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx:10,message,messages,10,tree/treeviewer/src/TTreeViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx,1,['message'],['messages']
Integrability,"// handle mouse messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx:16,message,messages,16,tree/treeviewer/src/TTreeViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx,1,['message'],['messages']
Integrability,"// handle mouse messages in the list-tree (left panel)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx:16,message,messages,16,tree/treeviewer/src/TTreeViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx,1,['message'],['messages']
Integrability,"// handle slider messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx:17,message,messages,17,tree/treeviewer/src/TTreeViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx,1,['message'],['messages']
Integrability,"// happiness.; // The remaining lookup routines only work on global scope functions; // (""macros""), not in classes, namespaces etc - anything that looks like; // it has seen any trace of software development.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:39,rout,routines,39,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['rout'],['routines']
Integrability,"// hasPrivateSymbols is the opposite of isStripped, but we expose; // hasPrivateSymbols as a more intuitive interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/DIA/DIARawSymbol.cpp:108,interface,interface,108,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/DIA/DIARawSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/DIA/DIARawSymbol.cpp,1,['interface'],['interface']
Integrability,// has_FlowTraits<int> will cause an error with some compilers because; // it subclasses int. Using this wrapper only instantiates the; // real has_FlowTraits only if the template type is a class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:105,wrap,wrapper,105,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['wrap'],['wrapper']
Integrability,"// have a Define that depends on a varied column",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:22,depend,depends,22,tree/dataframe/test/dataframe_vary.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx,1,['depend'],['depends']
Integrability,"// have a Define that depends on multiple varied columns",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:22,depend,depends,22,tree/dataframe/test/dataframe_vary.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx,1,['depend'],['depends']
Integrability,"// have a jitted Define that depends on a varied column",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:29,depend,depends,29,tree/dataframe/test/dataframe_vary.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx,1,['depend'],['depends']
Integrability,"// helper class to wrap the functionality of the various HypoTestCalculators",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx:19,wrap,wrap,19,roofit/roostats/src/HypoTestInverter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx,1,['wrap'],['wrap']
Integrability,// helper routine for getMachineOpValue(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.h:10,rout,routine,10,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.h,1,['rout'],['routine']
Integrability,"// here start testing of HMAC in the begin of the message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:50,message,message,50,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['message'],['message']
Integrability,// high part of the register pair; // The following portion depends on both the data type and the operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:60,depend,depends,60,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,2,['depend'],['depends']
Integrability,"// holds a wrapper around TMinuit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MinuitFitter.h:11,wrap,wrapper,11,tmva/tmva/inc/TMVA/MinuitFitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MinuitFitter.h,1,['wrap'],['wrapper']
Integrability,// i16 -> i64 requires two dependent operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:27,depend,dependent,27,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['depend'],['dependent']
Integrability,"// ibucur: i think the user should have the possibility to display all the message; // levels should they want to; maybe a setPrintLevel would be appropriate; // (maybe for the other classes that use this approach as well)?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/MetropolisHastings.cxx:75,message,message,75,roofit/roostats/src/MetropolisHastings.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/MetropolisHastings.cxx,1,['message'],['message']
Integrability,// id<protocol-list>,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:6,protocol,protocol-list,6,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['protocol'],['protocol-list']
Integrability,// id<protocol> is an qualified id type; // id<protocol>* is not an qualified id type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:6,protocol,protocol,6,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,2,['protocol'],['protocol']
Integrability,"// if (!nastyprint) {; // printf(""Found nasty Hbook case!! You had an Hbook error message\n"");; // printf("" when creating the file (too many records)\n"");; // printf("" Hbook file should have been created with a bigger LRECL\n"");; // printf("" ROOT will try to recover\n"");; // nastyprint = 1;; // }; // nastycase = 1;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/main/src/h2root.cxx:82,message,message,82,main/src/h2root.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/main/src/h2root.cxx,1,['message'],['message']
Integrability,"// if (Name && SS.isNotEmpty()) {; // // We have a nested-name tag ('struct foo::bar').; // // Check for invalid 'foo::'.; // if (SS.isInvalid()) {; // Name = 0;; // goto CreateNewDecl;; // }; // // If this is a friend or a reference to a class in a dependent; // // context, don't try to make a decl for it.; // if (TUK == TUK_Friend || TUK == TUK_Reference) {; // DC = computeDeclContext(SS, false);; // if (!DC) {; // IsDependent = true;; // return 0;; // }; // } else {; // DC = computeDeclContext(SS, true);; // if (!DC) {; // Diag(SS.getRange().getBegin(),; // diag::err_dependent_nested_name_spec); // << SS.getRange();; // return 0;; // }; // }; // if (RequireCompleteDeclContext(SS, DC)); // return 0;; // SearchDC = DC;; // // Look-up name inside 'foo::'.; // LookupQualifiedName(Previous, DC);; // if (Previous.isAmbiguous()); // return 0;; // if (Previous.empty()) {; // // Name lookup did not find anything. However, if the; // // nested-name-specifier refers to the current instantiation,; // // and that current instantiation has any dependent base; // // classes, we might find something at instantiation time: treat; // // this as a dependent elaborated-type-specifier.; // // But this only makes any sense for reference-like lookups.; // if (Previous.wasNotFoundInCurrentInstantiation() &&; // (TUK == TUK_Reference || TUK == TUK_Friend)) {; // IsDependent = true;; // return 0;; // }; // // A tag 'foo::bar' must already exist.; // Diag(NameLoc, diag::err_not_tag_in_scope); // << Kind << Name << DC << SS.getRange();; // Name = 0;; // Invalid = true;; // goto CreateNewDecl;; // }; //} else",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:250,depend,dependent,250,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,3,['depend'],['dependent']
Integrability,"// if (fGlobs) {; // // must check GlobalObservables is in the list; // }; //; // if (auto globs = dynamic_cast<RooCmdArg*>(fOpts->find(""GlobalObservables""))) {; // // first remove any obs the pdf doesnt depend on; // auto _vars = std::unique_ptr<RooAbsCollection>( fPdf->getVariables() );; // auto _funcGlobs = std::unique_ptr<RooAbsCollection>(_vars->selectCommon(*globs->getSet(0)));; // fGlobs.reset( std::unique_ptr<RooAbsCollection>(globs->getSet(0)->selectCommon(*_funcGlobs))->snapshot() );; // globs->setSet(0,dynamic_cast<const RooArgSet&>(*_funcGlobs)); // globs in linked list has its own argset; // but args need to live as long as the func; // /*RooArgSet toRemove;; // for(auto a : *globs->getSet(0)) {; // if (!_vars->find(*a)) toRemove.add(*a);; // }; // const_cast<RooArgSet*>(globs->getSet(0))->remove(toRemove);; // fGlobs.reset( globs->getSet(0)->snapshot() );; // fGlobs->setAttribAll(""Constant"",true);; // const_cast<RooArgSet*>(globs->getSet(0))->replace(*fGlobs);*/; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx:204,depend,depend,204,roofit/xroofit/src/xRooNLLVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx,1,['depend'],['depend']
Integrability,"// if SrcCoeff doesn't divide Delta, then no dependence",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:45,depend,dependence,45,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,2,['depend'],['dependence']
Integrability,"// if a kPROOF_STOPPROCESS message is returned to kPROOF_GETPACKET; // GetNextPacket() will return 0 and the TPacketizer and hence; // TEventIter will be stopped",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:27,message,message,27,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['message']
Integrability,"// if both instructions don't reference memory, there's no dependence",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:59,depend,dependence,59,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// if cannot seek send urgent message to rootd to stop tranfer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFTP.cxx:30,message,message,30,net/net/src/TFTP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFTP.cxx,1,['message'],['message']
Integrability,"// if dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx:6,depend,dependencies,6,html/src/TDocOutput.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx,1,['depend'],['dependencies']
Integrability,"// if have any dependents and name isn't one of them then stop",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:15,depend,dependents,15,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['depend'],['dependents']
Integrability,"// if kTRUE - use debug & profile interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/inc/TGWin32ProxyDefs.h:34,interface,interface,34,graf2d/win32gdk/inc/TGWin32ProxyDefs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/inc/TGWin32ProxyDefs.h,1,['interface'],['interface']
Integrability,"// if multiple clients, see if only one client is in parentage route; // if so, then assume thats the only client we should replace in",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:63,rout,route,63,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,4,['rout'],['route']
Integrability,"// if nold == -1 , program uses binwidth input from calling routine",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:60,rout,routine,60,hist/hist/src/THLimitsFinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx,1,['rout'],['routine']
Integrability,"// if true handle messages also for derived classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h:18,message,messages,18,core/base/inc/TMessageHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h,1,['message'],['messages']
Integrability,"// if type = 0 use default specified via class IntegratorMultiDimOptions::SetDefaultIntegrator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:47,Integrat,IntegratorMultiDimOptions,47,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['Integrat'],['IntegratorMultiDimOptions']
Integrability,"// if we had return stmt update to execute the SVR init, even if the; // wrapper returns void.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp:73,wrap,wrapper,73,interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp,1,['wrap'],['wrapper']
Integrability,"// ignore the rest of the sent messages, but give the other end a second to; // actually send its stuff, instead of hanging in retry_send because the; // connection has died; a better solution would be if retry_send (in; // ZeroMQSvc::send) had a callback mechanism that could be used to break; // out when a child has died, but ok",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ.cpp:31,message,messages,31,roofit/roofitZMQ/test/test_ZMQ.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ.cpp,1,['message'],['messages']
Integrability,"// implement filling of projected histogram; // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; // inbin is the axis being integrated. Loop is done only on the selected bins; // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:172,integrat,integrated,172,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,1,['integrat'],['integrated']
Integrability,"// implement the TH1 interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooPlot.h:21,interface,interface,21,roofit/roofitcore/inc/RooPlot.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooPlot.h,1,['interface'],['interface']
Integrability,"// implementation of FCN static function used internally by TFumili.; // Adapt IMultiGenFunction interface to TFumili FCN static function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx:97,interface,interface,97,math/fumili/src/TFumiliMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx,1,['interface'],['interface']
Integrability,"// implementation of FCN static function used internally by TMinuit.; // Adapt IMultiGenFunction interface to TMinuit FCN static function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx:97,interface,interface,97,math/minuit/src/TMinuitMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx,1,['interface'],['interface']
Integrability,"// implementation of FCN static function used internally by TMinuit.; // Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; // provided gradient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx:98,interface,interface,98,math/minuit/src/TMinuitMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx,1,['interface'],['interface']
Integrability,"// import all dependents if importing a workspace, not for creating new objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx:14,depend,dependents,14,roofit/hs3/src/RooJSONFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx,1,['depend'],['dependents']
Integrability,"// import all the dependants of an object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx:18,depend,dependants,18,roofit/hs3/src/RooJSONFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx,1,['depend'],['dependants']
Integrability,"// in case of error messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:20,message,messages,20,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['messages']
Integrability,"// in case of transformation wrap objective function in a new transformation function; // and transform from external variables to internals ones type; // Transformations are supported only for gradient function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/BasicMinimizer.cxx:29,wrap,wrap,29,math/mathcore/src/BasicMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/BasicMinimizer.cxx,1,['wrap'],['wrap']
Integrability,"// in case of wrapped data the pointer stores the error and; // not the inverse",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/BinData.h:14,wrap,wrapped,14,math/mathcore/inc/Fit/BinData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/BinData.h,1,['wrap'],['wrapped']
Integrability,"// in case this TensorShapeProto has no dimension message: ONNX IR defines this to be a scalar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie_parsers/src/RModelParser_ONNX.cxx:50,message,message,50,tmva/sofie_parsers/src/RModelParser_ONNX.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie_parsers/src/RModelParser_ONNX.cxx,1,['message'],['message']
Integrability,"// include the extendedTerm, distributed evenly over the bins; // probably should be somehow dependent on data density though (i.e. bins with more data get more of it?)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:93,depend,dependent,93,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['depend'],['dependent']
Integrability,"// incomplete gamma function (complement integral); // igamc(a,x) = 1 - igam(a,x); //; // inf.; // -; // 1 | | -t a-1; // = ----- | e t dt.; // - | |; // | (a) -; // x; //; //; // In this implementation both arguments must be positive.; // The integral is evaluated by either a power series or; // continued fraction expansion, depending on the relative; // values of a and x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.cxx:328,depend,depending,328,math/mathcore/src/SpecFuncCephes.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.cxx,1,['depend'],['depending']
Integrability,// increase tolerance because the numeric integration algos are still different; /*randomizeParameters=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooFuncWrapper.cxx:42,integrat,integration,42,roofit/roofitcore/test/testRooFuncWrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooFuncWrapper.cxx,1,['integrat'],['integration']
Integrability,"// increase when client protocol changes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx:24,protocol,protocol,24,net/net/src/TSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx,1,['protocol'],['protocol']
Integrability,"// inherited interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TBackCompFitter.h:13,interface,interface,13,hist/hist/inc/TBackCompFitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TBackCompFitter.h,1,['interface'],['interface']
Integrability,"// initial route is just the sequential order",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx:11,rout,route,11,math/mathmore/test/simanTSP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx,1,['rout'],['route']
Integrability,"// initialization of (x,y,z) and factorization routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TGondzioSolver.cxx:47,rout,routine,47,math/quadp/src/TGondzioSolver.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TGondzioSolver.cxx,2,['rout'],['routine']
Integrability,"// initialize by setting integration type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx:25,integrat,integration,25,math/mathmore/src/GSLMCIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx,1,['integrat'],['integration']
Integrability,"// initialize for 1D sampling; // need to create 1D interface from Multidim one; // (to do: use directly 1D functions ??); // to do : add possibility for String API of UNURAN",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/src/TUnuranSampler.cxx:52,interface,interface,52,math/unuran/src/TUnuranSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/src/TUnuranSampler.cxx,1,['interface'],['interface']
Integrability,"// inject ROOT namespace for convenience",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/PyROOTModule.cxx:3,inject,inject,3,bindings/pyroot/pythonizations/src/PyROOTModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/PyROOTModule.cxx,1,['inject'],['inject']
Integrability,"// inject a FlexibleInterpVar ...; // get the list of clients BEFORE creating the new interpolation ... seems list of clients is inaccurate after",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:3,inject,inject,3,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['inject'],['inject']
Integrability,"// inject an interpolation node; // get the list of clients BEFORE creating the new interpolation ... seems list of clients is inaccurate after",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:3,inject,inject,3,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['inject'],['inject']
Integrability,"// inject custom data types",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Integrability,"// inject exception object proxy type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Integrability,"// inject identifiable nullptr and default",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Integrability,"// inject implementation for an overridden method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,1,['inject'],['inject']
Integrability,"// inject meta type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Integrability,"// inject method proxy type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Integrability,"// inject object proxy type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Integrability,"// inject property proxy type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Integrability,"// inject template proxy type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Integrability,"// install iterator protocol a la STL",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:20,protocol,protocol,20,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,1,['protocol'],['protocol']
Integrability,"// instance of the admin interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TNetFileStager.h:25,interface,interface,25,net/net/inc/TNetFileStager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TNetFileStager.h,1,['interface'],['interface']
Integrability,"// int socketpair(int domain, int type, int protocol, int sv[2]);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:44,protocol,protocol,44,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['protocol'],['protocol']
Integrability,"// integrate T_0(x) by hand",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h:3,integrat,integrate,3,roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,1,['integrat'],['integrate']
Integrability,"// integrate T_1(x) by hand...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h:3,integrat,integrate,3,roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,1,['integrat'],['integrate']
Integrability,"// integrate again ADAPTIve, with different rule",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testGSLIntegration.cxx:3,integrat,integrate,3,math/mathmore/test/testGSLIntegration.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testGSLIntegration.cxx,1,['integrat'],['integrate']
Integrability,"// integrate over full range of all observables - use bit 0 to indicate; // full range integration over all observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistPdf.cxx:3,integrat,integrate,3,roofit/roofitcore/src/RooHistPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistPdf.cxx,2,['integrat'],"['integrate', 'integration']"
Integrability,"// integrate to 16%",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats_tests.h:3,integrat,integrate,3,roofit/roostats/test/stressRooStats_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats_tests.h,1,['integrat'],['integrate']
Integrability,"// integrate to 84%",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats_tests.h:3,integrat,integrate,3,roofit/roostats/test/stressRooStats_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats_tests.h,1,['integrat'],['integrate']
Integrability,"// integrate using recursion relation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h:3,integrat,integrate,3,roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,1,['integrat'],['integrate']
Integrability,"// integration method using cached function; /**; evaluate the Integral over the defined interval (a,b) using the function previously set with Integrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h:3,integrat,integration,3,math/mathcore/inc/Math/Integrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h,4,"['Integrat', 'integrat']","['Integrator', 'integration']"
Integrability,"// integration methods using a function; /**; evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h:3,integrat,integration,3,math/mathcore/inc/Math/Integrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h,4,['integrat'],['integration']
Integrability,"// integrator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:3,integrat,integrator,3,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,2,['integrat'],['integrator']
Integrability,"// integrator (mutable because Integral() is not const",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:3,integrat,integrator,3,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['integrat'],['integrator']
Integrability,"// interface by parameter name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserTransformation.cxx:3,interface,interface,3,math/minuit2/src/MnUserTransformation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserTransformation.cxx,1,['interface'],['interface']
Integrability,"// interface for TClass generators",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClassGenerator.h:3,interface,interface,3,core/meta/inc/TClassGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClassGenerator.h,1,['interface'],['interface']
Integrability,"// interface from FunctionMinimum to be used after minimization; // use last state from the minimization without the need to re-create a new state; // do not reset function calls and keep updating them",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnHesse.cxx:3,interface,interface,3,math/minuit2/src/MnHesse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnHesse.cxx,1,['interface'],['interface']
Integrability,"// interface from MnUserParameterState; // create a new Minimum state and use that interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnHesse.cxx:3,interface,interface,3,math/minuit2/src/MnHesse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnHesse.cxx,2,['interface'],['interface']
Integrability,"// interface from minimum state",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPosDef.cxx:3,interface,interface,3,math/minuit2/src/MnPosDef.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPosDef.cxx,1,['interface'],['interface']
Integrability,"// interface name; // @interface can be followed by a lightweight generic; // specialization list, then either a base class or a category.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:3,interface,interface,3,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,2,['interface'],['interface']
Integrability,"// interface of the base class. Use DeltaGradient for op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/HessianGradientCalculator.cxx:3,interface,interface,3,math/minuit2/src/HessianGradientCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/HessianGradientCalculator.cxx,1,['interface'],['interface']
Integrability,"// interface using parameter name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserParameters.cxx:3,interface,interface,3,math/minuit2/src/MnUserParameters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserParameters.cxx,1,['interface'],['interface']
Integrability,"// internal interface from MinimumState and MnUserTransformation; // Function who does the real Hessian calculations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnHesse.cxx:12,interface,interface,12,math/minuit2/src/MnHesse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnHesse.cxx,1,['interface'],['interface']
Integrability,"// internal minuit messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Minuit2Minimizer.cxx:19,message,messages,19,math/minuit2/src/Minuit2Minimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Minuit2Minimizer.cxx,1,['message'],['messages']
Integrability,"// interpret 'adding' here as dependent on the object type ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:30,depend,dependent,30,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['depend'],['dependent']
Integrability,// isLegalToPruneDependencies - Is it legal to prune dependece between SUI; // and SUJ.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:53,depend,dependece,53,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,1,['depend'],['dependece']
Integrability,// isLegalToPruneDependencies - Is it legal to prune dependency between SUI; // and SUJ.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600Packetizer.cpp:53,depend,dependency,53,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600Packetizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600Packetizer.cpp,1,['depend'],['dependency']
Integrability,"// it is normal for this function to receive names of directories that do not exist.; // they should be ignored and should not generate any error messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx:146,message,messages,146,core/rint/src/TTabCom.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx,1,['message'],['messages']
Integrability,"// job ID must always be the first part of any result message/type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/NoopJob.h:54,message,message,54,roofit/multiprocess/test/NoopJob.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/NoopJob.h,3,['message'],['message']
Integrability,"// job_id must always be the first element of the result message!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/JobManager.cxx:57,message,message,57,roofit/multiprocess/src/JobManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/JobManager.cxx,1,['message'],['message']
Integrability,"// keep pruning the tree until reach the limit fAlpha; // build a wrapper tree to perform work on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/CCPruner.cxx:66,wrap,wrapper,66,tmva/tmva/src/CCPruner.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/CCPruner.cxx,1,['wrap'],['wrapper']
Integrability,"// lambdas use a compiler internal closure type, so we wrap; // them, then return the wrapper's type; // TODO: this current leaks the std::function; also, if possible,; // should instantiate through TClass rather then ProcessLine",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:55,wrap,wrap,55,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,2,['wrap'],"['wrap', 'wrapper']"
Integrability,"// leaving these lines uncommented is a heavy price to pay for only a warning message; // (which shouldn't appear anyway); // --> about 15% of time is spent in the final GetError().; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx:78,message,message,78,tmva/tmva/src/MethodMLP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx,1,['message'],['message']
Integrability,"// li rx, si; // load rt, ra, rx; // The dependent operand index in the second op(load). And the negative means; // it could be any one. ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:41,depend,dependent,41,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,1,['depend'],['dependent']
Integrability,// libdevice provides fast low precision and slow full-recision implementations; // for some functions. Which one gets selected depends on; // __CLANG_CUDA_APPROX_TRANSCENDENTALS__ which gets defined by clang if; // -ffast-math or -fgpu-approx-transcendentals are in effect.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h:128,depend,depends,128,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h,1,['depend'],['depends']
Integrability,"// libgcc_eh depends on libc, so resolve as much as possible,; // pull in any new requirements from libc and then get the rest; // of libgcc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp:13,depend,depends,13,interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp,1,['depend'],['depends']
Integrability,"// lighting uniforms depend on the camera so enforce an update; // now, in case this material supports lights - or later, when; // the next material that does gets activated:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:21,depend,depend,21,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['depend'],['depend']
Integrability,"// lines count - for error messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/LinkdefReader.h:27,message,messages,27,core/dictgen/res/LinkdefReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/LinkdefReader.h,1,['message'],['messages']
Integrability,"// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;; // if one belongs to the outer ring and another to a hole, it merges it into a single ring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:36,bridg,bridge,36,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['bridg'],['bridge']
Integrability,"// list of dependent classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TProtoClass.h:11,depend,dependent,11,core/meta/inc/TProtoClass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TProtoClass.h,1,['depend'],['dependent']
Integrability,"// list of error messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TStatus.h:17,message,messages,17,proof/proofplayer/inc/TStatus.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TStatus.h,1,['message'],['messages']
Integrability,"// list of info messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TStatus.h:16,message,messages,16,proof/proofplayer/inc/TStatus.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TStatus.h,1,['message'],['messages']
Integrability,"// list of special protocols",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TUrl.h:19,protocol,protocols,19,core/base/inc/TUrl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TUrl.h,1,['protocol'],['protocols']
Integrability,// llvm.amdgcn.rcp(llvm.amdgcn.sqrt(x)) -> llvm.amdgcn.rsq(x) if contractable; //; // llvm.amdgcn.rcp(llvm.sqrt(x)) -> llvm.amdgcn.rsq(x) if contractable and; // relaxed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:65,contract,contractable,65,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,2,['contract'],['contractable']
Integrability,// llvm::Error values must be consumed before being destroyed.; // Wrapping an error in fmt_consume explicitly indicates that the formatv_object; // should take ownership and consume it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatAdapters.h:67,Wrap,Wrapping,67,interpreter/llvm-project/llvm/include/llvm/Support/FormatAdapters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatAdapters.h,1,['Wrap'],['Wrapping']
Integrability,"// llvm::Module cannot contain:; // * variables and parameters with dependent context;; // * mangled names for parameters;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:68,depend,dependent,68,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['depend'],['dependent']
Integrability,"// load any dependent libraries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:12,depend,dependent,12,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['depend'],['dependent']
Integrability,"// logPdf for Poisson: ignore constant term depending on N",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:44,depend,depending,44,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,1,['depend'],['depending']
Integrability,"// logon details (method dependent ...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h:25,depend,dependent,25,net/auth/inc/TAuthenticate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h,1,['depend'],['dependent']
Integrability,"// look for this argument in the generating function's dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsNumGenerator.cxx:55,depend,dependents,55,roofit/roofitcore/src/RooAbsNumGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsNumGenerator.cxx,1,['depend'],['dependents']
Integrability,// look in dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:11,depend,dependencies,11,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,2,['depend'],['dependencies']
Integrability,"// lookup can be re-entered recursively if running on a single thread. Run any; // outstanding MUs in case this query depends on them, otherwise this lookup; // will starve waiting for a result from an MU that is stuck in the queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:118,depend,depends,118,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['depend'],['depends']
Integrability,"// lookup class to find list of dependent libraries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:32,depend,dependent,32,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['depend'],['dependent']
Integrability,"// lookup this argument in the cloned set of PDF dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx:49,depend,dependents,49,roofit/roofitcore/src/RooGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx,1,['depend'],['dependents']
Integrability,// lookupMethod - Lookup a instance/class method in the protocol and protocols; // it inherited.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:56,protocol,protocol,56,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,"// loop on the bins to be integrated (outbin should be called inbin)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:26,integrat,integrated,26,hist/hist/src/TH3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx,3,['integrat'],['integrated']
Integrability,"// loop on the dimensions depending no the orders",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Slice.hxx:26,depend,depending,26,tmva/sofie/inc/TMVA/ROperator_Slice.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Slice.hxx,1,['depend'],['depending']
Integrability,"// loop over all foams and print out a debug message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/PlotFoams.cxx:45,message,message,45,tmva/tmvagui/src/PlotFoams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/PlotFoams.cxx,1,['message'],['message']
Integrability,// loop over scene and add dependency,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/EveTable.controller.js:27,depend,dependency,27,ui5/eve7/controller/EveTable.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/EveTable.controller.js,2,['depend'],['dependency']
Integrability,// loop to extract all dependent painters,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:23,depend,dependent,23,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['depend'],['dependent']
Integrability,"// main interface for FindNextBoundary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h:8,interface,interface,8,geom/geom/inc/TGeoParallelWorld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h,1,['interface'],['interface']
Integrability,"// main interface for Safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h:8,interface,interface,8,geom/geom/inc/TGeoParallelWorld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h,1,['interface'],['interface']
Integrability,"// maintain interface with const char * for backward compatibility",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnUserParameters.h:12,interface,interface,12,math/minuit2/inc/Minuit2/MnUserParameters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnUserParameters.h,3,['interface'],['interface']
Integrability,"// make ROOT-independent C++ class for classifier response; // (classifier-specific implementation); // If no classifier name is given, help messages for all booked; // classifiers are printed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Factory.h:141,message,messages,141,tmva/tmva/inc/TMVA/Factory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Factory.h,1,['message'],['messages']
Integrability,"// make one label per line of the message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGMsgBox.cxx:34,message,message,34,gui/gui/src/TGMsgBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGMsgBox.cxx,1,['message'],['message']
Integrability,// make sure the mask is still a mask (wrap arounds may not be),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:39,wrap,wrap,39,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['wrap'],['wrap']
Integrability,"// make the message box non-resizable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TAdvancedGraphicsDialog.cxx:12,message,message,12,gui/fitpanel/src/TAdvancedGraphicsDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TAdvancedGraphicsDialog.cxx,9,['message'],['message']
Integrability,"// making our convolution much more accurate; // Numeric integration of this function suffers from roundoff errors, so the default 1.E-12 accuracy won't be reached.; // By reducing the tolerance, we get rid of a GSL warning, which was picked up by the log checkers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:57,integrat,integration,57,hist/hist/test/test_tf1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx,1,['integrat'],['integration']
Integrability,// map from ObjC class names/protocol (as; // IDs) to context IDs,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h:29,protocol,protocol,29,interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h,1,['protocol'],['protocol']
Integrability,"// mapAppendingVariable call can change AppendingInits if initalizer for; // the variable depends on another appending global, because of that inits; // need to be extracted and updated before the call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:90,depend,depends,90,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,1,['depend'],['depends']
Integrability,// mapped_iterator - This is a simple iterator adapter that causes a function to; // be applied whenever operator* is invoked on the iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:47,adapter,adapter,47,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['adapter'],['adapter']
Integrability,// memcopy dependency data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:11,depend,dependency,11,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['depend'],['dependency']
Integrability,// message,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp:3,message,message,3,interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp,1,['message'],['message']
Integrability,"// message buffer, only used by worker",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/mpi/inc/TMPIFile.h:3,message,message,3,io/mpi/inc/TMPIFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/mpi/inc/TMPIFile.h,1,['message'],['message']
Integrability,"// message comes from the master-worker SUB socket (first element):",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/worker.cxx:3,message,message,3,roofit/multiprocess/src/worker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/worker.cxx,1,['message'],['message']
Integrability,"// message comes from the master/queue socket (first element):",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx:3,message,message,3,roofit/multiprocess/src/Messenger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx,2,['message'],['message']
Integrability,"// message handled here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx:3,message,message,3,core/winnt/src/Win32Splash.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx,1,['message'],['message']
Integrability,"// message id (often matching specific enum in fClass)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h:3,message,message,3,core/base/inc/TMessageHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h,1,['message'],['message']
Integrability,"// message ids",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h:3,message,message,3,core/base/inc/TMessageHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h,1,['message'],['message']
Integrability,"// message logger",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Interval.cxx:3,message,message,3,tmva/tmva/src/Interval.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Interval.cxx,3,['message'],['message']
Integrability,"// message not handled",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx:3,message,message,3,core/winnt/src/Win32Splash.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx,1,['message'],['message']
Integrability,"// message on howto get the binary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitAPI.h:3,message,message,3,tmva/tmva/inc/TMVA/RuleFitAPI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitAPI.h,1,['message'],['message']
Integrability,"// message queue mutex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:3,message,message,3,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,1,['message'],['message']
Integrability,"// message sent from worker to the master",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:3,message,message,3,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['message']
Integrability,"// message types for MsgLogger; // define outside of Types class to facilite access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Types.h:3,message,message,3,tmva/tmva/inc/TMVA/Types.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Types.h,1,['message'],['message']
Integrability,"// messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx:3,message,messages,3,gui/gui/src/TGDNDManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx,1,['message'],['messages']
Integrability,"// method inheritaed from IFunction interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/MultiNumGradFunction.h:36,interface,interface,36,math/mathmore/inc/Math/MultiNumGradFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/MultiNumGradFunction.h,1,['interface'],['interface']
Integrability,"// method inherited from IFunction interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimTransformFunction.h:35,interface,interface,35,math/mathcore/inc/Math/MinimTransformFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimTransformFunction.h,1,['interface'],['interface']
Integrability,"// method to set the a generic integration function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx:31,integrat,integration,31,math/mathmore/src/GSLMCIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx,2,['integrat'],['integration']
Integrability,"// methods related to the new editor interface; //static methods for both interfaces",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualPadEditor.h:37,interface,interface,37,core/base/inc/TVirtualPadEditor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualPadEditor.h,2,['interface'],"['interface', 'interfaces']"
Integrability,"// methods related to the old editor interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualPadEditor.h:37,interface,interface,37,core/base/inc/TVirtualPadEditor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualPadEditor.h,1,['interface'],['interface']
Integrability,"// methods required by interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MultiDimParamFunctionAdapter.h:23,interface,interface,23,math/mathcore/inc/Math/MultiDimParamFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MultiDimParamFunctionAdapter.h,2,['interface'],['interface']
Integrability,"// methods to create integrators",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Integrator.cxx:21,integrat,integrators,21,math/mathcore/src/Integrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Integrator.cxx,1,['integrat'],['integrators']
Integrability,"// methods using GSLMonteFuncPointer; /**; evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param dim the dimension; @param a lower value of the integration interval; @param b upper value of the integration interval; @param p pointer to parameter array; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMCIntegrator.h:124,integrat,integration,124,math/mathmore/inc/Math/GSLMCIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMCIntegrator.h,4,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"// methods using IGenFunction; /**; evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h:116,integrat,integration,116,math/mathmore/inc/Math/GSLIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h,4,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"// might resize pad pixmap so should be called before any paint routine",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:64,rout,routine,64,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['rout'],['routine']
Integrability,"// minimize from a FCNBase and a MnUserparameterState - interface used by all the previous ones; // based on FCNBase. Create in this case a NumericalGradient calculator; // Create the minuit FCN wrapper (MnUserFcn) containing the transformation (int<->ext); // need MnUserFcn for difference int-ext parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/ModularFunctionMinimizer.cxx:56,interface,interface,56,math/minuit2/src/ModularFunctionMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/ModularFunctionMinimizer.cxx,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"// minimize from a function with gradient and a MnUserParameterState -; // interface based on function with gradient (external/analytical gradients); // Create in this case an AnalyticalGradient calculator; // Create the minuit FCN wrapper (MnUserFcn) containing the transformation (int<->ext)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/ModularFunctionMinimizer.cxx:75,interface,interface,75,math/minuit2/src/ModularFunctionMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/ModularFunctionMinimizer.cxx,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"// mirror dataset around dataset boundaries -- does not depend on event weights",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx:56,depend,depend,56,roofit/roofit/src/RooNDKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx,1,['depend'],['depend']
Integrability,"// missing protocol name.; // Save the protocol name, then consume it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:11,protocol,protocol,11,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,2,['protocol'],['protocol']
Integrability,"// move implementations here to avoid circle dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PxPyPzE4D.h:45,depend,dependencies,45,math/genvector/inc/Math/GenVector/PxPyPzE4D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PxPyPzE4D.h,1,['depend'],['dependencies']
Integrability,"// multi dim integrator options: implementation for static methods; /// print default options",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx:13,integrat,integrator,13,math/mathcore/src/IntegratorOptions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx,1,['integrat'],['integrator']
Integrability,// multipart messages requires special handling,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,message,messages,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['message'],['messages']
Integrability,"// must set fParallel to 1 for slaves since they do not; // report their fParallel with a LOG_DONE message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:99,message,message,99,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['message'],['message']
Integrability,"// namespace ARM; // Expands a PredBlockMask by adding an E or a T at the end, depending on Kind.; // e.g ExpandPredBlockMask(T, Then) = TT, ExpandPredBlockMask(TT, Else) = TTE,; // and so on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h:79,depend,depending,79,interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h,1,['depend'],['depending']
Integrability,"// namespace HistFactory; /**; * \ingroup HistFactory; * main function of the hist2workspace executable.; * It creates RooFit models from an xml config and files with histograms.; * See MakeModelAndMeasurementFast(), for further instructions.; * \param[in] argc number of CLI arguments; * \param[in] argv pointer to arguments; *; * -h Help; * -v Switch HistFactory message stream to INFO level.; * -vv Switch HistFactory message stream to DEBUG level.; * -disable_binned_fit_optimization Disable the binned fit optimization used in HistFactory since ROOT 6.28.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/hist2workspace.cxx:365,message,message,365,roofit/histfactory/src/hist2workspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/hist2workspace.cxx,2,['message'],['message']
Integrability,"// namespace Internal; /// A replacement for the TMVA::Reader legacy interface.; /// Performs inference for TMVA models stored as XML files.; /// For neural network inference consider using [SOFIE](https://github.com/root-project/root/blob/master/tmva/sofie/README.md) instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RReader.hxx:69,interface,interface,69,tmva/tmva/inc/TMVA/RReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RReader.hxx,1,['interface'],['interface']
Integrability,"// namespace Internal; /// Wraps any collection that can be used in range-based loops and applies; /// `static_cast<T>` or `dynamic_cast<T>` to each element.; /// \tparam T The new type to convert to.; /// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; /// \tparam Range_t The type of the input range, which should be usually a reference type to avoid copying.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RRangeCast.hxx:27,Wrap,Wraps,27,core/foundation/inc/ROOT/RRangeCast.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RRangeCast.hxx,1,['Wrap'],['Wraps']
Integrability,"// namespace PyROOT; // Methods offered by the interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/PyROOTModule.cxx:47,interface,interface,47,bindings/pyroot/pythonizations/src/PyROOTModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/PyROOTModule.cxx,1,['interface'],['interface']
Integrability,"// namespace ROOT; // clang-format off; /**; * \class TTreeReaderArray; * \ingroup treeplayer; * \brief An interface for reading collections stored in ROOT columnar datasets; *; * The TTreeReaderArray is a type-safe tool to be used in association with a TTreeReader; * to access the collections stored in TTree, TNtuple and TChain datasets.; * In order to access values which are not collections, the TTreeReaderValue class can; * be used.; *; * See the documentation of TTreeReader for more details and examples.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReaderArray.h:107,interface,interface,107,tree/treeplayer/inc/TTreeReaderArray.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReaderArray.h,1,['interface'],['interface']
Integrability,"// namespace ROOT; /// @brief TRangeDynCast is an adapter class that allows the typed iteration; /// through a TCollection.; ///; /// The typical use is:; /// ```{.cpp}; /// for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; /// if (!bcl) continue;; /// ... use bcl as a TBaseClass*; /// }; /// for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; /// if (!bcl) continue;; /// ... use bcl as a TBaseClass*; /// }; /// ```; /// \tparam T The new type to convert to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h:50,adapter,adapter,50,core/cont/inc/TCollection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h,1,['adapter'],['adapter']
Integrability,"// namespace RooFit; // Register this class with RooNumIntConfig; ////////////////////////////////////////////////////////////////////////////////; /// Register integrator plugins, their parameters and capabilities with RooNumIntFactory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRombergIntegrator.cxx:161,integrat,integrator,161,roofit/roofitcore/src/RooRombergIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRombergIntegrator.cxx,1,['integrat'],['integrator']
Integrability,"// namespace RooFit_internal; ////////////////////////////////////////////////////////////////////////////////; /// Register this class with RooNumIntConfig as a possible choice of numeric; /// integrator for one-dimensional integrals over finite and infinite domains",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx:194,integrat,integrator,194,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,1,['integrat'],['integrator']
Integrability,"// namespace SPIRV; //===----------------------------------------------------------------------===//; // Misc functions for looking up builtins and veryfying requirements using; // TableGen records; //===----------------------------------------------------------------------===//; /// Looks up the demangled builtin call in the SPIRVBuiltins.td records using; /// the provided \p DemangledCall and specified \p Set.; ///; /// The lookup follows the following algorithm, returning the first successful; /// match:; /// 1. Search with the plain demangled name (expecting a 1:1 match).; /// 2. Search with the prefix before or suffix after the demangled name; /// signyfying the type of the first argument.; ///; /// \returns Wrapper around the demangled call and found builtin definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:723,Wrap,Wrapper,723,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,1,['Wrap'],['Wrapper']
Integrability,// namespace detail; // Provide wrappers to std::sort which shuffle the elements before sorting; // to help uncover non-deterministic behavior (PR35135).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:32,wrap,wrappers,32,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['wrap'],['wrappers']
Integrability,"// namespace detail; /// Support for printing to std::ostream, for use with e.g. producing more; /// useful error messages with Google Test.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Testing/ADT/StringMapEntry.h:114,message,messages,114,interpreter/llvm-project/llvm/include/llvm/Testing/ADT/StringMapEntry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Testing/ADT/StringMapEntry.h,1,['message'],['messages']
Integrability,"// namespace hashing; /// Combine values into a single hash_code.; ///; /// This routine accepts a varying number of arguments of any type. It will; /// attempt to combine them into a single hash_code. For user-defined types it; /// attempts to call a \see hash_value overload (via ADL) for the type. For; /// integer and pointer types it directly combines their data into the; /// resulting hash_code.; ///; /// The result is suitable for returning from a user's hash_value; /// *implementation* for their user-defined type. Consumers of a type should; /// *not* call this routine, they should instead call 'hash_value'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:81,rout,routine,81,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,2,['rout'],['routine']
Integrability,"// namespace internal; // Note that this container stores unique results in a deterministic, but; // the location calls are in an unspecified order. Clients which desire; // a particular order for the location calls, such as alphabetical,; // should sort results after retrieval, because the order is dependent; // on how the LocationCalls are formatted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/NodeIntrospection.h:301,depend,dependent,301,interpreter/llvm-project/clang/include/clang/Tooling/NodeIntrospection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/NodeIntrospection.h,1,['depend'],['dependent']
Integrability,// namespace llvm; // Overloaded wrappers to go with the function template below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:33,wrap,wrappers,33,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,1,['wrap'],['wrappers']
Integrability,// namespace llvm; // The definition of AssumedTemplateStorage is factored out of TemplateName to; // resolve a cyclic dependency between it and DeclarationName (via Type).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclarationName.h:119,depend,dependency,119,interpreter/llvm-project/clang/include/clang/AST/DeclarationName.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclarationName.h,1,['depend'],['dependency']
Integrability,// namespace optional_detail; // Optional type which internal storage can be specialized by providing; // OptionalStorage. The interface follows std::optional.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CustomizableOptional.h:127,interface,interface,127,interpreter/llvm-project/clang/include/clang/Basic/CustomizableOptional.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CustomizableOptional.h,1,['interface'],['interface']
Integrability,// namespace sx; // This class defines the interface of a clang CFG Visitor.; // CFGWalker will invoke the following methods.; // Note that methods are not virtual; the visitor is templatized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyCommon.h:43,interface,interface,43,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyCommon.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyCommon.h,1,['interface'],['interface']
Integrability,"// namespace sys; /// This interface provides simple read-only access to a block of memory, and; /// provides simple methods for reading files and standard input into a memory; /// buffer. In addition to basic access to the characters in the file, this; /// interface guarantees you can read one character past the end of the file,; /// and that this character will read as '\0'.; ///; /// The '\0' guarantee is needed to support an optimization -- it's intended to; /// be more efficient for clients which are reading all the data to stop; /// reading when they encounter a '\0' than to continually check the file; /// position to see if it has reached the end of the file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h:27,interface,interface,27,interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,2,['interface'],['interface']
Integrability,// namespace vfs; /// Public interface to the memory profiler pass for instrumenting code to; /// profile memory accesses.; ///; /// The profiler itself is a function pass that works by inserting various; /// calls to the MemProfiler runtime library functions. The runtime library; /// essentially replaces malloc() and free() with custom implementations that; /// record data about the allocations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/MemProfiler.h:29,interface,interface,29,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/MemProfiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/MemProfiler.h,1,['interface'],['interface']
Integrability,"// namespace; /** @fn RooStats::ModelConfig::createNLL(); *; * Wrapper around RooAbsPdf::createNLL(), where; * the pdf and some configuration options are retrieved from the ModelConfig.; *; * The options taken from the ModelConfig are:; *; * * ConditionalObservables(); * * GlobalObservables(); * * ExternalConstraints(); *; * Except for the options above, you can still pass all the other command; * arguments supported by RooAbsPdf::createNLL().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/ModelConfig.cxx:63,Wrap,Wrapper,63,roofit/roofitcore/src/ModelConfig.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/ModelConfig.cxx,1,['Wrap'],['Wrapper']
Integrability,"// namespace; /** \class MinuitFcnGrad; *; * \brief Minuit-RooMinimizer interface which synchronizes parameter data and coordinates evaluation of likelihood; * (gradient) values; *; * This class provides an interface between RooFit and Minuit. It synchronizes parameter values from Minuit, calls; * calculator classes to evaluate likelihood and likelihood gradient values and returns them to Minuit. The Wrapper; * objects do the actual calculations. These are constructed inside the MinuitFcnGrad constructor using the RooAbsL; * likelihood passed in to the constructor, usually directly from RooMinimizer, with which this class is intimately; * coupled, being a RooAbsMinimizerFcn implementation. MinuitFcnGrad inherits from ROOT::Math::IMultiGradFunction as; * well, which allows it to be used as the FCN and GRAD parameters Minuit expects.; *; * \note The class is not intended for use by end-users. We recommend to either use RooMinimizer with a RooAbsL derived; * likelihood object, or to use a higher level entry point like RooAbsPdf::fitTo() or RooAbsPdf::createNLL().; */; /// \param[in] absL The input likelihood.; /// \param[in] context RooMinimizer that creates and owns this class.; /// \param[in] parameters The vector of ParameterSettings objects that describe the parameters used in the Minuit; /// \param[in] likelihoodMode Lmode; /// \param[in] likelihoodGradientMode Lgrad; /// \param[in] verbose true for verbose output; /// Fitter. Note that these must match the set used in the Fitter used by \p context! It can be passed in from; /// RooMinimizer with fitter()->Config().ParamsSettings().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx:72,interface,interface,72,roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx,5,"['Wrap', 'interface', 'synchroniz']","['Wrapper', 'interface', 'synchronizes']"
Integrability,"// namespace; /**; * \brief Split the dataset into subsets based on states of a categorical variable in this dataset.; *; * Returns a list of sub-datasets, which each dataset named after a given state; * name in the `splitCat`. The observables `splitCat` itself is no longer present; * in the sub-datasets.; *; * \note If you mean to split a dataset into sub-datasets that correspond to; * the individual channels of a RooSimultaneous, it is better to use; * RooAbsData::split(const RooSimultaneous &, bool), because then the; * sub-datasets only contain variables that the pdf for the corresponding; * channel depends on. This is much faster in case of many channels, and the; * resulting sub-datasets don't waste memory for unused columns.; *; * \param splitCat The categorical variable used for splitting the dataset.; * \param createEmptyDataSets Flag indicating whether to create empty datasets; * for missing categories (`false` by default).; *; * \return An owning pointer to a TList of subsets of the dataset.; * Returns `nullptr` if an error occurs.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:611,depend,depends,611,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['depend'],['depends']
Integrability,"// namespace; // Covers GitHub issue #10868 about the wrong integral for RooPoisson if; // integrated from a > 0 to infinity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooPoisson.cxx:91,integrat,integrated,91,roofit/roofit/test/testRooPoisson.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooPoisson.cxx,1,['integrat'],['integrated']
Integrability,// namespace; // Create wrappers for C Binding types (see CBindingWrapping.h).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/RemarkParser.cpp:24,wrap,wrappers,24,interpreter/llvm-project/llvm/lib/Remarks/RemarkParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/RemarkParser.cpp,1,['wrap'],['wrappers']
Integrability,"// namespace; // SymbolizerGetOpInfo() is the operand information call back function.; // This is called to get the symbolic information for operand(s) of an; // instruction when it is being done. This routine does this from; // the relocation information, symbol table, etc. That block of information; // is a pointer to the struct DisassembleInfo that was passed when the; // disassembler context was created and passed to back to here when; // called back by the disassembler for instruction operands that could have; // relocation information. The address of the instruction containing operand is; // at the Pc parameter. The immediate value the operand has is passed in; // op_info->Value and is at Offset past the start of the instruction and has a; // byte Size of 1, 2 or 4. The symbolc information is returned in TagBuf is the; // LLVMOpInfo1 struct defined in the header ""llvm-c/Disassembler.h"" as symbol; // names and addends of the symbolic expression to add for the operand. The; // value of TagType is currently 1 (for the LLVMOpInfo1 struct). If symbolic; // information is returned then this function returns 1 else it returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp:202,rout,routine,202,interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,1,['rout'],['routine']
Integrability,"// namespace; // Test that a simple fit with Gauss and Voigt yields the same values as with; // ROOT 6.18. The fit requires numeric integration for the Voigt. To suppress; // false positives, the precision for numeric integrals was increased by 1000x.; // This test uses Minuit2.; //; // Previously in: roottest/root/roofitstats/stabilityTests.cxx",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/stabilityTests.cxx:132,integrat,integration,132,roofit/roofit/test/stabilityTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/stabilityTests.cxx,1,['integrat'],['integration']
Integrability,"// namespace; // The tracked stack of loops. The stack indicates that which loops the; // simulated element contained by. The loops are marked depending if we decided; // to unroll them.; // TODO: The loop stack should not need to be in the program state since it is; // lexical in nature. Instead, the stack of loops should be tracked in the; // LocationContext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp:143,depend,depending,143,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp,1,['depend'],['depending']
Integrability,"// namespace; // These structs cannot be in the anon namespace becase they're used in RNTupleMerger's private interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:110,interface,interface,110,tree/ntuple/v7/src/RNTupleMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx,1,['interface'],['interface']
Integrability,"// namespace; // use reference wrapper for the Functor, such that the functor points to this RooMinimizerFcn by reference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizerFcn.cxx:31,wrap,wrapper,31,roofit/roofitcore/src/RooMinimizerFcn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizerFcn.cxx,1,['wrap'],['wrapper']
Integrability,"// namespace; /// Create observables of type RooRealVar. Creates 1 to 3 observables, depending on the type of the histogram.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx:85,depend,depending,85,roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,1,['depend'],['depending']
Integrability,// namespace; /// RegisterBuiltinPragmas - Install the standard preprocessor pragmas:; /// \#pragma GCC poison/system_header/dependency and \#pragma once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:125,depend,dependency,125,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['depend'],['dependency']
Integrability,// namespace; /// Run checkers for visiting obj-c messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:50,message,messages,50,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,1,['message'],['messages']
Integrability,// namespace; /// Strips any positional args and possible argv[0] from a command-line; /// provided by the user to construct a FixedCompilationDatabase.; ///; /// FixedCompilationDatabase requires a command line to be in this format as it; /// constructs the command line for each file by appending the name of the file; /// to be compiled. FixedCompilationDatabase also adds its own argv[0] to the; /// start of the command line although its value is not important as it's just; /// ignored by the Driver invoked by the ClangTool using the; /// FixedCompilationDatabase.; ///; /// FIXME: This functionality should probably be made available by; /// clang::driver::Driver although what the interface should look like is not; /// clear.; ///; /// \param[in] Args Args as provided by the user.; /// \return Resulting stripped command line.; /// \li true if successful.; /// \li false if \c Args cannot be used for compilation jobs (e.g.; /// contains an option like -E or -version).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:690,interface,interface,690,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,1,['interface'],['interface']
Integrability,// namespace; /// Wraps an identifier and optional source location for the identifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:18,Wrap,Wraps,18,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['Wrap'],['Wraps']
Integrability,"// namespace; ////////////////////////////////////////////////////////////////////////////////; /// Write code for a 'baseName' implementation with class name 'className',; /// taking RooAbsReal arguments with names listed in argNames and; /// RooAbsCategory arguments with names listed in catArgNames as; /// constructor arguments (use a comma separated list for multiple; /// arguments). The initial value expression is taken to be; /// 'expression' which can be any one-line C++ expression in terms of; /// variables that occur in 'vars'. Skeleton code for handling of; /// analytical integrals is added if hasAnaInt is true. You can add; /// optional expressions for analytical integrals to be advertised by; /// your class in the syntax; /// ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; /// where ""<intObsName>"" a name of the observable integrated over and; /// ""<CPPAnaIntExpression>"" is the C++ expression that calculates that; /// integral. Skeleton code for internal event generation is added; /// if hasIntGen is true; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx:881,integrat,integrated,881,roofit/roofitcore/src/RooClassFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx,1,['integrat'],['integrated']
Integrability,"// namespace; //===----------------------------------------------------------------------===//; // Public interface to the file; //===----------------------------------------------------------------------===//; /// ParseAST - Parse the entire file specified, notifying the ASTConsumer as; /// the file is parsed. This inserts the parsed decls into the translation unit; /// held by Ctx.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:106,interface,interface,106,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,1,['interface'],['interface']
Integrability,"// nbins[0] = number of bins for signal distributions. It depends on the number of entries, thus it's the same for all the input variables, but it isn't necessary for some ""weird"" reason.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariableGaussTransform.cxx:58,depend,depends,58,tmva/tmva/src/VariableGaussTransform.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariableGaussTransform.cxx,1,['depend'],['depends']
Integrability,"// need an adapter from a multi-dim function to a one-dimensional",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:11,adapter,adapter,11,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,1,['adapter'],['adapter']
Integrability,"// need to choose from dependent fundamentals, in following order:; // parentX (if not a glob), robs, globs, vars, args",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:23,depend,dependent,23,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['depend'],['dependent']
Integrability,"// need to copy the wrapper function, the instance created here will be deleted after SetFunction()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h:20,wrap,wrapper,20,math/mathcore/inc/Math/Integrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h,1,['wrap'],['wrapper']
Integrability,"// need to create the variation : note - if no variations existed up to now this will inject a new node; // so we should redirect ourself to the new node; // TODO: Do we need to redirect parents?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:86,inject,inject,86,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['inject'],['inject']
Integrability,"// need to get way to get dependencies .. can't pass all as causes circular dependencies issues.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:26,depend,dependencies,26,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,2,['depend'],['dependencies']
Integrability,"// need to handle special case of RooSimultaneous ... each pdf needs individually projecting over just its; // dependent obs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:111,depend,dependent,111,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['depend'],['dependent']
Integrability,"// need to initialize to zero s1 and s2 since; // GetStats fills only used elements depending on dimension and type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:84,depend,depending,84,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,3,['depend'],['depending']
Integrability,"// need to put here setter methods to resolve nasty cyclical dependencies; // I need to include other coordinate systems only when Cartesian is already defined; // since they depend on it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Cartesian2D.h:61,depend,dependencies,61,math/genvector/inc/Math/GenVector/Cartesian2D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Cartesian2D.h,4,['depend'],"['depend', 'dependencies']"
Integrability,"// need to swap out var for newVar; // replace ith element in list with new func, or inject into RooProduct",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:85,inject,inject,85,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['inject'],['inject']
Integrability,"// need to the replacement here for the error message before",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:46,message,message,46,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['message'],['message']
Integrability,"// need to use WithinDeltaFraction() because sometimes the integrating the; // posterior in this binary search seems to not have enough granularity to; // find an acceptable conf level (small no. of strange cases).; // WithinDeltaFraction causes the search to terminate when; // topCutoff is essentially equal to bottomCutoff (compared to the magnitude; // of their mean).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/MCMCInterval.cxx:59,integrat,integrating,59,roofit/roostats/src/MCMCInterval.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/MCMCInterval.cxx,1,['integrat'],['integrating']
Integrability,"// need typename keyword because qualified dependent names; // are not valid types unless preceded by 'typename'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/NodekNN.h:43,depend,dependent,43,tmva/tmva/inc/TMVA/NodekNN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/NodekNN.h,2,['depend'],['dependent']
Integrability,"// new constructs using STL iterator interface; // skip - need to solve the ambiguities",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/SVector.h:37,interface,interface,37,math/smatrix/inc/Math/SVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/SVector.h,1,['interface'],['interface']
Integrability,"// new is assumed; // if directory already exist, print error message and return",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:62,message,message,62,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['message'],['message']
Integrability,"// new message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMessageHandler.cxx:7,message,message,7,core/base/src/TMessageHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMessageHandler.cxx,1,['message'],['message']
Integrability,"// new-style buffer interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx:20,interface,interface,20,bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,1,['interface'],['interface']
Integrability,"// no captureStr has the string to display; // inject line breaks to avoid msgbox being too wide",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:47,inject,inject,47,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['inject'],['inject']
Integrability,"// no classifier specified, print all help messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx:43,message,messages,43,tmva/tmva/src/Factory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx,2,['message'],['messages']
Integrability,"// no error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinter.cpp:12,message,message,12,interpreter/cling/lib/Interpreter/ValuePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinter.cpp,1,['message'],['message']
Integrability,"// no integration to be done",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:6,integrat,integration,6,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['integrat'],['integration']
Integrability,// no need to re-scan histogram while result does not depend from axis selection,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:54,depend,depend,54,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,8,['depend'],['depend']
Integrability,"// no need to set parameters used a non-parametric wrapper to avoid allocating; // an array with parameter values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:51,wrap,wrapper,51,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,3,['wrap'],['wrapper']
Integrability,"// no type of layer specified - assume is dense layer as in old DNN interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:68,interface,interface,68,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,1,['interface'],['interface']
Integrability,"// no wrapper to run",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:6,wrap,wrapper,6,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['wrap'],['wrapper']
Integrability,"// no-op to comply with interface for RInterface::Fill",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_compgraph.cxx:24,interface,interface,24,tree/dataframe/test/dataframe_compgraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_compgraph.cxx,1,['interface'],['interface']
Integrability,"// nobody should ask for a varied filter for a variation on which this filter does not depend:; // they can just use the nominal filter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx:87,depend,depend,87,tree/dataframe/inc/ROOT/RDF/RFilter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx,3,['depend'],['depend']
Integrability,"// not a leave node ... for further traversal,; // we inject the children into priority queue based on distance to it's bounding box",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:54,inject,inject,54,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,2,['inject'],['inject']
Integrability,"// not compatible; // clarify error message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx:36,message,message,36,bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,1,['message'],['message']
Integrability,"// not enough energy for this decay; //; //------> the max weight depends on opt:; // opt == ""Fermi"" --> fermi energy dependence for cross section; // else --> constant cross section as function of TECM (default); //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TGenPhaseSpace.cxx:66,depend,depends,66,math/physics/src/TGenPhaseSpace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TGenPhaseSpace.cxx,2,['depend'],"['dependence', 'depends']"
Integrability,"// note that this routine assumes global entry numbers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMT.cxx:18,rout,routine,18,tree/treeplayer/src/TTreeProcessorMT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMT.cxx,1,['rout'],['routine']
Integrability,"// now come here if I have already found a lower/upper limit; // i.e. I am calling routine for the second time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterResult.cxx:83,rout,routine,83,roofit/roostats/src/HypoTestInverterResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterResult.cxx,1,['rout'],['routine']
Integrability,"// now it depends on concrete type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/vecgeom/src/TGeoVGShape.cxx:10,depend,depends,10,geom/vecgeom/src/TGeoVGShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/vecgeom/src/TGeoVGShape.cxx,1,['depend'],['depends']
Integrability,"// now pass the pointer to the wrapper function (may be null)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:31,wrap,wrapper,31,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['wrap'],['wrapper']
Integrability,// now server-side entity should be initialized and init message send from server side!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:57,message,message,57,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['message'],['message']
Integrability,"// number of different messages handled",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h:23,message,messages,23,core/base/inc/TMessageHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h,1,['message'],['messages']
Integrability,// objc_direct cannot be set on methods declared in the context of a protocol,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:69,protocol,protocol,69,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['protocol'],['protocol']
Integrability,"// object generating message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h:21,message,message,21,core/base/inc/TMessageHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h,1,['message'],['message']
Integrability,// ok to cast to 'id'.; // casting to id<p-list> is ok if bridge type adopts all of; // p-list protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:58,bridg,bridge,58,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,2,"['bridg', 'protocol']","['bridge', 'protocols']"
Integrability,"// one dim integrator options: implementation for static methods; /// print default options",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx:11,integrat,integrator,11,math/mathcore/src/IntegratorOptions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx,1,['integrat'],['integrator']
Integrability,"// only for the segmented integrators",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRombergIntegrator.cxx:26,integrat,integrators,26,roofit/roofitcore/src/RooRombergIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRombergIntegrator.cxx,1,['integrat'],['integrators']
Integrability,"// only if get OPTIONS message from client allow to change gPad",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:23,message,message,23,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,1,['message'],['message']
Integrability,"// only integrate over observables we actually depend on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:8,integrat,integrate,8,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,2,"['depend', 'integrat']","['depend', 'integrate']"
Integrability,"// operators; // NOTE: Because we do not want to change the behaviour of the Event class; // as a public interface, we use the explicit default assignment operator,; // which is similar to the implicit one but silences gcc9 warnings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Event.h:105,interface,interface,105,tmva/tmva/inc/TMVA/Event.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Event.h,1,['interface'],['interface']
Integrability,"// otherwise build error message and throw",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:25,message,message,25,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,1,['message'],['message']
Integrability,"// partition the integration range into subranges that can each be; // handled by RooIntegrator1D",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx:17,integrat,integration,17,roofit/roofitcore/src/RooImproperIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx,1,['integrat'],['integration']
Integrability,"// peek at incoming message (receive only)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TSystem.h:20,message,message,20,core/base/inc/TSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TSystem.h,1,['message'],['message']
Integrability,"// perf currently doesn't have an interface for unloading. But munmap()ing the; // code section does, so that's ok.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:34,interface,interface,34,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,1,['interface'],['interface']
Integrability,"// perform fit of histograms, or graphs using new fitting classes; // use same routines for fitting both graphs and histograms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitImpl.cxx:79,rout,routines,79,hist/hist/src/HFitImpl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitImpl.cxx,1,['rout'],['routines']
Integrability,"// perform product of matrix cov * hes * cov; // since we do not want to add matrix dependence do product by hand; // first do hes * cov",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Fitter.cxx:84,depend,dependence,84,math/mathcore/src/Fitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Fitter.cxx,1,['depend'],['dependence']
Integrability,"// plan to replace the above: return a SimpleInterval integrating; // over all other parameters except the one specified as argument; // virtual SimpleInterval* GetInterval( RooRealVar* parameter ) const { return 0; }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/BayesianCalculator.h:54,integrat,integrating,54,roofit/roostats/inc/RooStats/BayesianCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/BayesianCalculator.h,1,['integrat'],['integrating']
Integrability,"// plot projection of 2D binned data on y; // Reduce the 2-dimensional binned dataset to a 1-dimensional binned dataset; //; // All reduce() methods are interfaced in RooAbsData. All reduction techniques; // demonstrated on unbinned datasets can be applied to binned datasets as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:153,interface,interfaced,153,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['interface'],['interfaced']
Integrability,"// po_ext_end interface requires a basic block, but ignores its value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:14,interface,interface,14,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,1,['interface'],['interface']
Integrability,"// po_iterator requires this iterator, but the only interface needed is the; // value_type type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/PostOrderCFGView.h:52,interface,interface,52,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/PostOrderCFGView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/PostOrderCFGView.h,1,['interface'],['interface']
Integrability,"// pointer for distribution wrapper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/inc/TUnuran.h:28,wrap,wrapper,28,math/unuran/inc/TUnuran.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/inc/TUnuran.h,1,['wrap'],['wrapper']
Integrability,"// pointer to GSL generator wrapper (managed by the class)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLQuasiRandom.h:28,wrap,wrapper,28,math/mathmore/inc/Math/GSLQuasiRandom.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLQuasiRandom.h,2,['wrap'],['wrapper']
Integrability,"// pointer to abstract class providing function to integrate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:51,integrat,integrate,51,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,1,['integrat'],['integrate']
Integrability,"// polished surface wrapped in Teflon tape",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h:20,wrap,wrapped,20,geom/geom/inc/TGeoOpticalSurface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h,1,['wrap'],['wrapped']
Integrability,"// polished surface wrapped with ESR",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h:20,wrap,wrapped,20,geom/geom/inc/TGeoOpticalSurface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h,1,['wrap'],['wrapped']
Integrability,"// polished surface wrapped with ESR and coupled with opical grease",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h:20,wrap,wrapped,20,geom/geom/inc/TGeoOpticalSurface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h,1,['wrap'],['wrapped']
Integrability,// popcntw is longer to encode than popcntl and also has a false dependency; // on the dest that popcntl hasn't had since Cannon Lake.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:65,depend,dependency,65,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['dependency']
Integrability,"// popup menu with user actions; // These fields hold state information used by the HtmlAddStyle routine.; // We have to store this state information here since HtmlAddStyle; // operates incrementally. This information must be carried from; // one incremental execution to the next.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:97,rout,routine,97,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['rout'],['routine']
Integrability,// possibly dependent,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:12,depend,dependent,12,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependent']
Integrability,"// postfix-expression: p-e '[' expression ']'; // If we have a array postfix expression that starts on a new line and; // Objective-C is enabled, it is highly likely that the user forgot a; // semicolon after the base expression and that the array postfix-expr is; // actually another message send. In this case, do some look-ahead to see; // if the contents of the square brackets are obviously not a valid; // expression and recover by pretending there is no suffix.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:285,message,message,285,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['message'],['message']
Integrability,"// powi(X, Y) / X --> powi(X, Y-1); // This is legal when (Y - 1) can't wraparound, in which case reassoc and nnan; // are required.; // TODO: Multi-use may be also better off creating Powi(x,y-1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:72,wrap,wraparound,72,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['wrap'],['wraparound']
Integrability,"// preserve key for longpoll or when with session key used for HMAC hash of messages; // conn->fKey.clear();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:76,message,messages,76,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['message'],['messages']
Integrability,// prevent cyclic dependencies,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:18,depend,dependencies,18,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['depend'],['dependencies']
Integrability,"// print Modelconfig as an info message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/ModelConfig.cxx:32,message,message,32,roofit/roofitcore/src/ModelConfig.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/ModelConfig.cxx,1,['message'],['message']
Integrability,"// print a message when you have a significative difference since rval is computed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx:11,message,message,11,roofit/roostats/src/HypoTestInverter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx,1,['message'],['message']
Integrability,"// print a warning message in case something is not ok; // this for example is case when Covar was made posdef and fStatus=3",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Minuit2Minimizer.cxx:19,message,message,19,math/minuit2/src/Minuit2Minimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Minuit2Minimizer.cxx,1,['message'],['message']
Integrability,"// print after parallel processing to avoid synchronization issues",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Numerical2PGradientCalculator.cxx:44,synchroniz,synchronization,44,math/minuit2/src/Numerical2PGradientCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Numerical2PGradientCalculator.cxx,1,['synchroniz'],['synchronization']
Integrability,"// print help message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/IMethod.h:14,message,message,14,tmva/tmva/inc/TMVA/IMethod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/IMethod.h,2,['message'],['message']
Integrability,"// print message in case of invalid error also in printLevel0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Minuit2Minimizer.cxx:9,message,message,9,math/minuit2/src/Minuit2Minimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Minuit2Minimizer.cxx,1,['message'],['message']
Integrability,"// print message only when h is not zero",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx:9,message,message,9,math/minuit/src/TLinearFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx,1,['message'],['message']
Integrability,"// print method-specific help message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:30,message,message,30,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['message'],['message']
Integrability,"// print occasional progress messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCIntegrator.cxx:29,message,messages,29,roofit/roofitcore/src/RooMCIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCIntegrator.cxx,1,['message'],['messages']
Integrability,"// print the route and distance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx:13,rout,route,13,math/mathmore/test/simanTSP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx,1,['rout'],['route']
Integrability,"// print to debug stream, since these would normally be suppressed, and; // we do not want to increase the error count in the message service...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:126,message,message,126,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['message'],['message']
Integrability,"// print welcome message (to be called from, eg, .TMVAlogon)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h:17,message,message,17,tmva/tmva/inc/TMVA/Tools.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h,1,['message'],['message']
Integrability,"// printf(""Message = %d (%d)\n"", GET_MSG(msg), GET_SUBMSG(msg));",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSReactionDlg.cxx:11,Message,Message,11,test/periodic/XSReactionDlg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSReactionDlg.cxx,1,['Message'],['Message']
Integrability,"// printf(""first send message to queue...\n"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Messenger.cxx:22,message,message,22,roofit/multiprocess/test/test_Messenger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Messenger.cxx,1,['message'],['message']
Integrability,"// printf(""send another message to queue...\n"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Messenger.cxx:24,message,message,24,roofit/multiprocess/test/test_Messenger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Messenger.cxx,1,['message'],['message']
Integrability,"// prints classifier-specific help messages, dedicated to; // help with the optimisation and configuration options tuning.; // If no classifier name is given, help messages for all booked; // classifiers are printed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Factory.h:35,message,messages,35,tmva/tmva/inc/TMVA/Factory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Factory.h,2,['message'],['messages']
Integrability,// private interface,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:11,interface,interface,11,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['interface'],['interface']
Integrability,"// private utility routines",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MsgLogger.h:19,rout,routines,19,tmva/tmva/inc/TMVA/MsgLogger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MsgLogger.h,1,['rout'],['routines']
Integrability,"// process message sent to this widget.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx:11,message,message,11,test/guitest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx,2,['message'],['message']
Integrability,"// protocol changes:; // 1 -> 2: new arguments for Process() command, option added; // 2 -> 3: package manager enabling protocol changed; // 3 -> 4: introduction of multi-level-master support; // 4 -> 5: added friends support; // 5 -> 6: drop TFTP, support for asynchronous queries; // 6 -> 7: support for multisessions, archieve, retrieve, ...; // 7 -> 8: return number of entries in GetNextPacket; // 8 -> 9: support for stateless connection via xproofd; // 9 -> 10: new features requested, tested at CAF; // 10 -> 11: new merging strategy; // 11 -> 12: new progress message; // 12 -> 13: exchange version/architecture/compiler info; // 13 -> 14: new proofserv environment setting; // 14 -> 15: add support for entry lists; new version of TFileInfo; // 15 -> 16: add support for generic non-data based processing; // 16 -> 17: new dataset handling system; support for TFileCollection processing; // 17 -> 18: support for reconnection on daemon restarts; // 18 -> 19: TProofProgressStatus used in kPROOF_PROGRESS, kPROOF_STOPPROCESS; // and kPROOF_GETNEXTPACKET messages in Master - worker communication; // 19 -> 20: Fix the asynchronous mode (required changes in some messages); // 20 -> 21: Add support for session queuing; // 21 -> 22: Add support for switching from sync to async while running ('Ctrl-Z' functionality); // 22 -> 23: New dataset features (default tree name; classification per fileserver); // 23 -> 24: Merging optimization; // 24 -> 25: Handling of 'data' dir; group information; // 25 -> 26: Use new TProofProgressInfo class; // 26 -> 27: Use new file for updating the session status; // 27 -> 28: Support for multi-datasets, fix global pack dirs, fix AskStatistics,; // package download, dataset caching; // 28 -> 29: Support for config parameters in EnablePackage, idle-timeout; // 29 -> 30: Add information about data dir in TSlaveInfo; // 30 -> 31: Development cycle 5.29; // 31 -> 32: New log path trasmission; // 32 -> 33: Development cycle 5.29/04 (fixed worker activati",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:3,protocol,protocol,3,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,2,['protocol'],['protocol']
Integrability,// protocol name,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:3,protocol,protocol,3,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['protocol'],['protocol']
Integrability,"// protocol of last slave on master",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx:3,protocol,protocol,3,proof/proof/src/TSlave.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx,1,['protocol'],['protocol']
Integrability,"// protocol of remote daemon",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSocket.h:3,protocol,protocol,3,net/net/inc/TSocket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSocket.h,2,['protocol'],['protocol']
Integrability,"// protocol version number",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:3,protocol,protocol,3,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,1,['protocol'],['protocol']
Integrability,"// protocol: http, ftp, news, root, proof, ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TUrl.h:3,protocol,protocol,3,core/base/inc/TUrl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TUrl.h,1,['protocol'],['protocol']
Integrability,// protocols,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:3,protocol,protocols,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,3,['protocol'],['protocols']
Integrability,"// protocols less than 4 are incompatible",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx:3,protocol,protocols,3,proof/proof/src/TSlave.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx,1,['protocol'],['protocols']
Integrability,// provably dependent,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:12,depend,dependent,12,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependent']
Integrability,"// provide a help message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodDL.h:18,message,message,18,tmva/tmva/inc/TMVA/MethodDL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodDL.h,1,['message'],['message']
Integrability,// public interface,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/AppendingTypeTableBuilder.h:10,interface,interface,10,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/AppendingTypeTableBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/AppendingTypeTableBuilder.h,3,['interface'],['interface']
Integrability,"// r + i or just i, depending on HasBaseReg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:20,depend,depending,20,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,3,['depend'],['depending']
Integrability,"// range selection, shown depending on fDim",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/inc/ROOT/RFitPanelModel.hxx:26,depend,depending,26,gui/fitpanelv7/inc/ROOT/RFitPanelModel.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/inc/ROOT/RFitPanelModel.hxx,1,['depend'],['depending']
Integrability,"// rc has a peculiar algorithm to output VERSIONINFO VALUEs. Each VALUE; // is a mapping from the key (string) to the value (a sequence of ints or; // a sequence of strings).; //; // If integers are to be written: width of each integer written depends on; // whether it's been declared 'long' (it's DWORD then) or not (it's WORD).; // ValueLength defined in structure referenced below is then the total; // number of bytes taken by these integers.; //; // If strings are to be written: characters are always WORDs.; // Moreover, '\0' character is written after the last string, and between; // every two strings separated by comma (if strings are not comma-separated,; // they're simply concatenated). ValueLength is equal to the number of WORDs; // written (that is, half of the bytes written).; //; // Ref: msdn.microsoft.com/en-us/library/windows/desktop/ms646994.aspx",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp:244,depend,depends,244,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,1,['depend'],['depends']
Integrability,"// re-use existing wrapper if possible",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:19,wrap,wrapper,19,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['wrap'],['wrapper']
Integrability,"// reached a workspace, check for any pdf depending on parameter that isnt the ignore",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:42,depend,depending,42,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['depend'],['depending']
Integrability,"// receive message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h:11,message,message,11,roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h,2,['message'],['message']
Integrability,"// received draw messages; // if true, most operations are performed locally without involving server",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomViewer.controller.js:17,message,messages,17,ui5/geom/controller/GeomViewer.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomViewer.controller.js,2,['message'],['messages']
Integrability,"// redraw all objects in pad, inform dependent objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:37,depend,dependent,37,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['depend'],['dependent']
Integrability,"// register the wrapper if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Transaction.cpp:16,wrap,wrapper,16,interpreter/cling/lib/Interpreter/Transaction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Transaction.cpp,1,['wrap'],['wrapper']
Integrability,"// reinitialize collide grid because the filling depends on fUxmin and fUxmax (and ymin ymax too); // and these aren't filled on the first time we do the placement (they init to 0 and 1), but will be filled; // subsequently",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:49,depend,depends,49,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['depend'],['depends']
Integrability,"// remember connection; // record send event only for normal channel or very first message via ch0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:83,message,message,83,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['message'],['message']
Integrability,"// remove any existing compressed buffer before compressing modified message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMessage.cxx:69,message,message,69,net/net/src/TMessage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMessage.cxx,1,['message'],['message']
Integrability,"// remove because can create ambiguities; // template<class Function>; // double ROOT::Math::IntegratorOneDim::Integral(const Function & f) {; // ROOT::Math::WrappedFunction<const Function &> wf(f);; // SetFunction(wf,false); // no copy is needed in this case; // return Integral();; // }; // template<class Function>; // double ROOT::Math::IntegratorOneDim::IntegralLow(Function & f, double x) {; // ROOT::Math::WrappedFunction< Function &> wf(f);; // SetFunction(wf,false); // no copy is needed in this case; // return IntegralLow(x);; // }; // template<class Function>; // double ROOT::Math::IntegratorOneDim::IntegralUp(Function & f, double x) {; // ROOT::Math::WrappedFunction<Function &> wf(f);; // SetFunction(wf,false); // no copy is needed in this case; // return IntegralUp(x);; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h:93,Integrat,IntegratorOneDim,93,math/mathcore/inc/Math/Integrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h,6,"['Integrat', 'Wrap']","['IntegratorOneDim', 'WrappedFunction']"
Integrability,"// remove template constructor since is ambiguous; /** Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementing operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integration methods); */; // this is ambiguous; // template<class Function>; // IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; // fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; // SetFunction(f, dim);; // }; /// destructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h:97,Integrat,Integrator,97,math/mathcore/inc/Math/IntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h,8,"['Integrat', 'integrat']","['IntegrationMultiDim', 'Integrator', 'IntegratorMultiDim', 'integration']"
Integrability,"// require to block context menu command appearing after control ends, required in chrome which inject contextmenu when key released",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:96,inject,inject,96,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['inject'],['inject']
Integrability,"// reset counter for error messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLInterpolator.cxx:27,message,messages,27,math/mathmore/src/GSLInterpolator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLInterpolator.cxx,1,['message'],['messages']
Integrability,"// reset error message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:15,message,message,15,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['message'],['message']
Integrability,"// results depends on the files in $ROOTSYS/test",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressGUI.cxx:11,depend,depends,11,test/stressGUI.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressGUI.cxx,1,['depend'],['depends']
Integrability,"// retrieve the message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/mpi/src/TMPIFile.cxx:16,message,message,16,io/mpi/src/TMPIFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/mpi/src/TMPIFile.cxx,1,['message'],['message']
Integrability,"// retrieve the wrapper pointer and capture it in a temporary std::function,; // then try normal conversion a second time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:16,wrap,wrapper,16,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['wrap'],['wrapper']
Integrability,"// return 13th character and replace it by 'p', getting 14th character; // should NOT result in an error message since operator() does not use; // range checking",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/tstring.cxx:105,message,message,105,test/tstring.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/tstring.cxx,1,['message'],['message']
Integrability,"// return 13th character and replace it by 't', getting 14th character; // should result in an error message since operator[] uses range checking",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/tstring.cxx:101,message,message,101,test/tstring.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/tstring.cxx,1,['message'],['message']
Integrability,"// return default integrator name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx:18,integrat,integrator,18,math/mathcore/src/IntegratorOptions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx,2,['integrat'],['integrator']
Integrability,"// return default integrator type (enum)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx:18,integrat,integrator,18,math/mathcore/src/IntegratorOptions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx,2,['integrat'],['integrator']
Integrability,"// return number of function calls; // if original function does not support gradient it is wrapped in MultiNumGradFunction; // and we have NCalls available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMinimizer.cxx:92,wrap,wrapped,92,math/mathmore/src/GSLMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMinimizer.cxx,1,['wrap'],['wrapped']
Integrability,"// return object found, which may be (pointer wise) different than the; // input object (depending on what IsEqual() is doing)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TList.cxx:89,depend,depending,89,core/cont/src/TList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TList.cxx,1,['depend'],['depending']
Integrability,"// return wrapper around f that prepends an `unsigned int slot` parameter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:10,wrap,wrapper,10,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,1,['wrap'],['wrapper']
Integrability,"// returns true if filters are installed and message is not selected by any filter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnPrint.h:45,message,message,45,math/minuit2/inc/Minuit2/MnPrint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnPrint.h,1,['message'],['message']
Integrability,"// root/core/meta; // vim: sw=3; // Author: Paul Russo 30/07/2012; // Author: Vassil Vassilev 9/02/2013; /*************************************************************************; * Copyright (C) 1995-2023, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TClingCallFunc; Emulation of the CINT CallFunc class. The CINT C++ interpreter provides an interface for calling; functions through the generated wrappers in dictionaries with; the CallFunc class. This class provides the same functionality,; using an interface as close as possible to CallFunc but the; function metadata and calling service comes from the Cling; C++ interpreter and the Clang C++ compiler, not CINT.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx:565,interface,interface,565,core/metacling/src/TClingCallFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx,3,"['interface', 'wrap']","['interface', 'wrappers']"
Integrability,"// rootd protocol level",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TFTP.h:9,protocol,protocol,9,net/net/inc/TFTP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TFTP.h,1,['protocol'],['protocol']
Integrability,"// rough surface wrapped in Teflon tape",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h:17,wrap,wrapped,17,geom/geom/inc/TGeoOpticalSurface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h,1,['wrap'],['wrapped']
Integrability,"// rough surface wrapped with ESR",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h:17,wrap,wrapped,17,geom/geom/inc/TGeoOpticalSurface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h,1,['wrap'],['wrapped']
Integrability,"// rough surface wrapped with ESR and coupled with opical grease",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h:17,wrap,wrapped,17,geom/geom/inc/TGeoOpticalSurface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoOpticalSurface.h,1,['wrap'],['wrapped']
Integrability,"// routine from G. Petrucciani (from HiggsCombination CMS package)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx:3,rout,routine,3,roofit/roostats/src/HypoTestInverter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx,1,['rout'],['routine']
Integrability,"// routines for formatted output -----------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h:3,rout,routines,3,tmva/tmva/inc/TMVA/Tools.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h,1,['rout'],['routines']
Integrability,"// save attributes in a map to then format the new line which is of the form; // #pragma read sourceClass=""class1"" targetClass=""class2"" version=""[1-]"" source="""" target=""transient_"" code=""{ newObj->initializeTransientss(); }"";; // where ""#pragma read"" should not appear; // The check for the sanity of the pragma is delegated to the ProcessReadPragma routine",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx:350,rout,routine,350,core/dictgen/src/XMLReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx,1,['rout'],['routine']
Integrability,"// search by brute force the best route; // the full permutations will be Factorial (N_CITIES-1); // which is approx 4 E+7 for 12 cities",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx:34,rout,route,34,math/mathmore/test/simanTSP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx,1,['rout'],['route']
Integrability,"// secret session key used for hashing connections keys; // only if set, all messages from and to server signed with HMAC hash",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:77,message,messages,77,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['message'],['messages']
Integrability,"// select +z or -z depending on the side of the point",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoEltu.cxx:19,depend,depending,19,geom/geom/src/TGeoEltu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoEltu.cxx,1,['depend'],['depending']
Integrability,"// select histogram depending on if sig or bgd",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:20,depend,depending,20,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['depend'],['depending']
Integrability,"// send a dummy message to the GUI thread to kick it into life",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:16,message,message,16,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['message'],['message']
Integrability,"// send arbitrary text message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/geom/geom_threejs.cxx:23,message,message,23,tutorials/webgui/geom/geom_threejs.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/geom/geom_threejs.cxx,2,['message'],['message']
Integrability,"// send begin message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveManager.cxx:14,message,message,14,graf3d/eve7/src/REveManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveManager.cxx,1,['message'],['message']
Integrability,// send dummy message to server,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:14,message,message,14,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['message'],['message']
Integrability,"// send end changes message and log messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveManager.cxx:20,message,message,20,graf3d/eve7/src/REveManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveManager.cxx,2,['message'],"['message', 'messages']"
Integrability,// send initialization message with clones,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:23,message,message,23,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['message'],['message']
Integrability,// send message,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:8,message,message,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['message'],['message']
Integrability,"// send message to client;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TVirtualPacketizer.cxx:8,message,message,8,proof/proof/src/TVirtualPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TVirtualPacketizer.cxx,4,['message'],['message']
Integrability,"// send message to server",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx:8,message,message,8,roofit/roofitcore/src/RooRealMPFE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx,1,['message'],['message']
Integrability,// send only last message from many during 200 ms,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomViewer.controller.js:18,message,message,18,ui5/geom/controller/GeomViewer.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomViewer.controller.js,1,['message'],['message']
Integrability,"// send our protocol; // if we do not require authentication say it here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:12,protocol,protocol,12,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['protocol'],['protocol']
Integrability,// send ready message back when drawing completed,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:14,message,message,14,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['message'],['message']
Integrability,"// send urgent message to rootd to stop tranfer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFTP.cxx:15,message,message,15,net/net/src/TFTP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFTP.cxx,4,['message'],['message']
Integrability,// sequence counter of received messages,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:32,message,messages,32,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['message'],['messages']
Integrability,// sequence counter of send messages,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:28,message,messages,28,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['message'],['messages']
Integrability,"// set a new route (used by exh. search)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx:13,rout,route,13,math/mathmore/test/simanTSP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx,1,['rout'],['route']
Integrability,"// set cdf distribution using a generic function interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/src/TUnuranContDist.cxx:49,interface,interface,49,math/unuran/src/TUnuranContDist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/src/TUnuranContDist.cxx,2,['interface'],['interface']
Integrability,"// set font size first depending on size of projected axis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCaloLegoGL.cxx:23,depend,depending,23,graf3d/eve/src/TEveCaloLegoGL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCaloLegoGL.cxx,2,['depend'],['depending']
Integrability,"// set integration mode for VEGAS method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx:7,integrat,integration,7,math/mathmore/src/GSLMCIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx,1,['integrat'],['integration']
Integrability,"// set integration options",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx:7,integrat,integration,7,math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,3,['integrat'],['integration']
Integrability,"// set integration options; // std::cout << ""fEpsilon = "" << fEpsilon << std::endl;; // std::cout << opt.RelTolerance() << "" abs "" << opt.AbsTolerance() << std::endl;; //double tol = opt.RelTolerance(); fEpsilon = tol;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GaussLegendreIntegrator.cxx:7,integrat,integration,7,math/mathcore/src/GaussLegendreIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GaussLegendreIntegrator.cxx,1,['integrat'],['integration']
Integrability,// set interim receiver until first message arrives,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:36,message,message,36,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['message'],['message']
Integrability,"// set internally the type of integration method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMCIntegrator.h:30,integrat,integration,30,math/mathmore/inc/Math/GSLMCIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMCIntegrator.h,1,['integrat'],['integration']
Integrability,"// set message to reflect the redirectLocation and add bytes field",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:7,message,message,7,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,1,['message'],['message']
Integrability,"// set message type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Configurable.h:7,message,message,7,tmva/tmva/inc/TMVA/Configurable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Configurable.h,4,['message'],['message']
Integrability,"// set the default 1D integrator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx:22,integrat,integrator,22,math/mathcore/src/IntegratorOptions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx,2,['integrat'],['integrator']
Integrability,"// set the default integrator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx:19,integrat,integrator,19,math/mathcore/src/IntegratorOptions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx,2,['integrat'],['integrator']
Integrability,"// set the default number of points for the integration rule",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx:44,integrat,integration,44,math/mathcore/src/IntegratorOptions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx,1,['integrat'],['integration']
Integrability,"// set the fit function; // if option grad is specified use gradient; // need to create a wrapper for an automatic normalized TF1 ???",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitImpl.cxx:90,wrap,wrapper,90,hist/hist/src/HFitImpl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitImpl.cxx,1,['wrap'],['wrapper']
Integrability,"// set the instance variables, so that the various visit routines may use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:57,rout,routines,57,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['rout'],['routines']
Integrability,"// set the integrand function and create required wrapper; // to perform integral in (x) of a generic f(x,p)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h:50,wrap,wrapper,50,math/mathcore/inc/Fit/FitUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h,1,['wrap'],['wrapper']
Integrability,"// set the integration function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx:11,integrat,integration,11,math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,1,['integrat'],['integration']
Integrability,"// set the integration type using a string",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx:11,integrat,integration,11,math/mathmore/src/GSLMCIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx,1,['integrat'],['integration']
Integrability,"// sets up the matrix for the main linear system in; // ""augmented system"" form. The actual factorization is; // performed by a routine specific to either the sparse; // or dense case",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/inc/TQpLinSolverBase.h:128,rout,routine,128,math/quadp/inc/TQpLinSolverBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/inc/TQpLinSolverBase.h,1,['rout'],['routine']
Integrability,"// setup the timer for progress message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:32,message,message,32,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['message'],['message']
Integrability,"// sext(C + x + y + ...) --> (sext(D) + sext((C - D) + x + y + ...)); // if D + (C - D + x + y + ...) could be proven to not signed wrap; // where D maximizes the number of trailing zeros of (C - D + x + y + ...); //; // For instance, this will bring two seemingly different expressions:; // 1 + sext(5 + 20 * %x + 24 * %y) and; // sext(6 + 20 * %x + 24 * %y); // to the same form:; // 2 + sext(4 + 20 * %x + 24 * %y)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:132,wrap,wrap,132,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// sext(setcc x, y, cc) -> (select (setcc x, y, cc), T, 0); // Here, T can be 1 or -1, depending on the type of the setcc and; // getBooleanContents().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:87,depend,depending,87,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['depending']
Integrability,"// sext({C,+,Step}) --> (sext(D) + sext({C-D,+,Step}))<nuw><nsw>; // if D + (C - D + Step * n) could be proven to not signed wrap; // where D maximizes the number of trailing zeros of (C - D + Step * n)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:125,wrap,wrap,125,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// should change test to use Minimizer interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/fit/testGraphFit.cxx:39,interface,interface,39,math/mathcore/test/fit/testGraphFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/fit/testGraphFit.cxx,1,['interface'],['interface']
Integrability,"// silent warning messages coming when evaluating a RooAddPdf without a normalization set",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:18,message,messages,18,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,2,['message'],['messages']
Integrability,"// singlethread fences only synchronize with signal handlers on the same; // thread and thus only need to preserve instruction order, not actually; // enforce memory ordering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:28,synchroniz,synchronize,28,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,3,['synchroniz'],['synchronize']
Integrability,"// singular integration - look if we know about singular points",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx:12,integrat,integration,12,math/mathmore/src/GSLIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx,1,['integrat'],['integration']
Integrability,"// size of work array's in several routines",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TDecompBase.h:35,rout,routines,35,math/matrix/inc/TDecompBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TDecompBase.h,3,['rout'],['routines']
Integrability,// skip dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:8,depend,dependencies,8,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['depend'],['dependencies']
Integrability,// skip message name,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:8,message,message,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['message'],['message']
Integrability,// skip module dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp:15,depend,dependencies,15,interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp,1,['depend'],['dependencies']
Integrability,"// skip space at the beginning of the message reserved for the message length",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMessage.cxx:38,message,message,38,net/net/src/TMessage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMessage.cxx,2,['message'],['message']
Integrability,"// skip the ""file:"" protocol, if any",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:20,protocol,protocol,20,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['protocol'],['protocol']
Integrability,"// slice the message into lines:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MsgLogger.cxx:13,message,message,13,tmva/tmva/src/MsgLogger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MsgLogger.cxx,1,['message'],['message']
Integrability,"// slope and offset (to be set later, depend on m)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooMomentMorph.cxx:38,depend,depend,38,roofit/roofit/src/RooMomentMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooMomentMorph.cxx,2,['depend'],['depend']
Integrability,"// slope and offset (to be set later, depend on nuisance parameters)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooMomentMorphFuncND.cxx:38,depend,depend,38,roofit/roofit/src/RooMomentMorphFuncND.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooMomentMorphFuncND.cxx,1,['depend'],['depend']
Integrability,"// slot-method calling interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQConnection.h:23,interface,interface,23,core/base/inc/TQConnection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQConnection.h,1,['interface'],['interface']
Integrability,"// so that doesn't try to do an integral because we are passing integration onto fFunc in evaluate; // faster than full evaluation because doesnt make the integral dependent on the full expression",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:64,integrat,integration,64,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,2,"['depend', 'integrat']","['dependent', 'integration']"
Integrability,"// solve a*x = b, where a = u*d*u'. First solve u*d*x = b, overwriting b with x.; // k is the main loop index, decreasing from n-1 to 0 in steps of 1 or 2,; // depending on the size of the diagonal blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBK.cxx:160,depend,depending,160,math/matrix/src/TDecompBK.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBK.cxx,2,['depend'],['depending']
Integrability,"// solve the simulated annealing problem given starting point and objective function interface; // initial conditions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx:85,interface,interface,85,math/mathmore/src/GSLSimAnnealing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx,1,['interface'],['interface']
Integrability,"// space at the beginning of the message reserved for the message length",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMessage.cxx:33,message,message,33,net/net/src/TMessage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMessage.cxx,2,['message'],['message']
Integrability,"// special case is for the Gamma where one might define the global observable n and you have a Gamma(b, n+1, ...._; // in this case n+1 is the server and we don;t have a direct dependency, but we want to set n to the b value; // so in case of the Gamma ignore this test",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx:177,depend,dependency,177,roofit/roostats/src/AsymptoticCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx,1,['depend'],['dependency']
Integrability,"// special case is for the Gamma where one might define the global observable n and you have a; // Gamma(b, n+1, ...._ in this case n+1 is the server and we don;t have a direct dependency, but; // we want to set n to the b value so in case of the Gamma ignore this test",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx:177,depend,dependency,177,roofit/xroofit/src/xRooFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx,1,['depend'],['dependency']
Integrability,"// special case: [X, 0) -- not really wrapping around",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:38,wrap,wrapping,38,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['wrap'],['wrapping']
Integrability,"// special case: [X, INT_MIN) -- not really wrapping around",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:44,wrap,wrapping,44,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['wrap'],['wrapping']
Integrability,"// specialized functions (depending on the package); //smatrix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/matrix_op.h:26,depend,depending,26,math/smatrix/test/matrix_op.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/matrix_op.h,1,['depend'],['depending']
Integrability,"// specific method for one-dim; /// Set number of points for active integration rule.; /// - For the GSL adaptive integrator, `n = 1,2,3,4,5,6` correspond to the 15,21,31,41,51,61-point integration rules.; /// - For the GaussLegendre integrator, use values > 6, which correspond to the actual number of points being evaluated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h:68,integrat,integration,68,math/mathcore/inc/Math/IntegratorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h,4,['integrat'],"['integration', 'integrator']"
Integrability,"// specific minimizer options depending on minimizer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitImpl.cxx:30,depend,depending,30,hist/hist/src/HFitImpl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitImpl.cxx,1,['depend'],['depending']
Integrability,"// ssize_t sendto(int socket, const void *message, size_t length,; // int flags, const struct sockaddr *dest_addr,; // socklen_t dest_len);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:42,message,message,42,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['message'],['message']
Integrability,// st_other field is used to encode symbol visibility and platform-dependent; // flags and values. This method returns a name to value map that is used for; // parsing and encoding this field.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFYAML.cpp:67,depend,dependent,67,interpreter/llvm-project/llvm/lib/ObjectYAML/ELFYAML.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFYAML.cpp,1,['depend'],['dependent']
Integrability,"// start idx in the fist segment depends of second segment",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEvePolygonSetProjected.cxx:33,depend,depends,33,graf3d/eve/src/TEvePolygonSetProjected.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEvePolygonSetProjected.cxx,2,['depend'],['depends']
Integrability,"// start off with a reasonable size placeholder for wrappers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:52,wrap,wrappers,52,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['wrap'],['wrappers']
Integrability,"// starting of normal message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:22,message,message,22,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['message'],['message']
Integrability,"// static bool IsSupportedClass(TClass *cl); // {; // // Check if the Class is of an unsupported type; // using namespace ROOT::TMetaUtils;; //; // // Check if this is a collection of unique_ptrs; // if (ROOT::ESTLType::kNotSTL != cl->GetCollectionType()) {; // std::vector<std::string> out;; // int i;; // TClassEdit::GetSplit(cl->GetName(), out, i);; // std::string_view containedObjectTypeName(out[1].c_str());; // if (TClassEdit::IsUniquePtr(containedObjectTypeName)) {; // auto clName = cl->GetName();; // // Here we can use the new name for the error message; // Error(""CloseStreamerInfoROOTFile"", ""A collection of unique pointers was selected: %s. These are not supported. If you wish to perform I/O operations with %s, just select the same collection of raw C pointers.\n"", clName, clName);; // return false;; // }; // }; // return true;; //; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/rootpcm/src/rootclingIO.cxx:557,message,message,557,io/rootpcm/src/rootclingIO.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/rootpcm/src/rootclingIO.cxx,1,['message'],['message']
Integrability,"// static function; /// We need this to tell the children to die, because we can't talk; /// to them anymore during JobManager destruction, because that kills; /// the Messenger first. We do that with SIGTERMs. The sigterm_received(); /// should be checked in message loops to stop them when it's true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/ProcessManager.cxx:260,message,message,260,roofit/multiprocess/src/ProcessManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/ProcessManager.cxx,1,['message'],['message']
Integrability,"// static functions providing semi-low level interface to raw Unix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/inc/TUnixSystem.h:45,interface,interface,45,core/unix/inc/TUnixSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/inc/TUnixSystem.h,1,['interface'],['interface']
Integrability,"// static method to create a minimizer .; // not using PM so direct dependency on all libraries (Minuit, Minuit2, MathMore, etc...); // The default is the Minuit2 minimizer or GSL Minimizer; // should use enumerations instead of string ?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Factory.cxx:68,depend,dependency,68,math/mathcore/src/Factory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Factory.cxx,1,['depend'],['dependency']
Integrability,"// static methods for setting and retrieving the default options; /// Set the default Minimizer type and corresponding algorithms.; /// Here is the list of the available minimizers and their corresponding algorithms.; /// For some minimizers (e.g. Fumili) there are no specific algorithms available, then there is no need to specify it.; ///; /// \anchor ROOTMinimizers; /// ### ROOT Minimizers; ///; /// - Minuit Minimizer based on TMinuit, the legacy Minuit implementation. Here are the available algorithms:; /// - Migrad default algorithm based on the variable metric minimizer; /// - Minimize combination of Simplex and Migrad; /// - Simplex minimization algorithm not using the gradient information; /// - Scan brute function scan; /// - Minuit2 New C++ implementation of Minuit (the recommended one); /// - Migrad (default); /// - Minimize; /// - Simplex; /// - Fumili2 new implementation of Fumili integrated in Minuit2; /// - Fumili Minimizer using an approximation for the Hessian based on first derivatives of the model function (see TFumili). Works only for chi-squared and likelihood functions.; /// - Linear Linear minimizer (fitter) working only for linear functions (see TLinearFitter and TLinearMinimizer); /// - GSLMultiMin Minimizer from GSL based on the ROOT::Math::GSLMinimizer. Available algorithms are:; /// - BFGS2 (default); /// - BFGS; /// - ConjugateFR; /// - ConjugatePR; /// - SteepestDescent; /// - GSLMultiFit Minimizer based on GSL for minimizing only non linear least-squared functions (using an approximation similar to Fumili). See ROOT::Math::GSLMultiFit.; /// - GSLSimAn Simulated annealing minimizer from GSL (see ROOT::Math::GSLSimAnMinimizer). It is a stochastic minimization algorithm using only function values and not the gradient.; /// - Genetic Genetic minimization algorithms (see TMVA::Genetic); ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h:906,integrat,integrated,906,math/mathcore/inc/Math/MinimizerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h,1,['integrat'],['integrated']
Integrability,// static wrappers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h:10,wrap,wrappers,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,1,['wrap'],['wrappers']
Integrability,"// static_assert that sizeof(T) is not ""too big"".; //; // Because our policy guarantees at least one inlined element, it is possible; // for an arbitrarily large inlined element to allocate an arbitrarily large; // amount of inline storage. We generally consider it an antipattern for a; // SmallVector to allocate an excessive amount of inline storage, so we want; // to call attention to these cases and make sure that users are making an; // intentional decision if they request a lot of inline storage.; //; // We want this assertion to trigger in pathological cases, but otherwise; // not be too easy to hit. To accomplish that, the cutoff is actually somewhat; // larger than kPreferredSmallVectorSizeof (otherwise,; // `SmallVector<SmallVector<T>>` would be one easy way to trip it, and that; // pattern seems useful in practice).; //; // One wrinkle is that this assertion is in theory non-portable, since; // sizeof(T) is in general platform-dependent. However, we don't expect this; // to be much of an issue, because most LLVM development happens on 64-bit; // hosts, and therefore sizeof(T) is expected to *decrease* when compiled for; // 32-bit hosts, dodging the issue. The reverse situation, where development; // happens on a 32-bit host and then fails due to sizeof(T) *increasing* on a; // 64-bit host, is expected to be very rare.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:951,depend,dependent,951,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['depend'],['dependent']
Integrability,// static_cast<void> on a dependent type will not show up as CK_ToVoid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,depend,dependent,26,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependent']
Integrability,"// std::qsort on solaris wants the sorter to be extern ""C""; /////////////////////////////////////////////////////////////////////////////; /// Friend function for sorting strings, case insensitive; ///; ///; /// Input: name1 - pointer to the first string; /// name2 - pointer to the second string; ///; /// NOTE: This function compares its arguments and returns an integer less; /// than, equal to, or greater than zero, depending on whether name1; /// is lexicographically less than, equal to, or greater than name2,; /// but characters are forced to lower-case prior to comparison.; ///; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx:421,depend,depending,421,html/src/TDocOutput.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx,1,['depend'],['depending']
Integrability,"// std::vector<bool> is a special-case in C++, and its return type depends on; // the compiler: treat it special here as well",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:67,depend,depends,67,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,2,['depend'],['depends']
Integrability,"// still okay if this is some pointer type of builtin persuasion (general class; // won't work: the return type needs to understand the iterator protocol)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:145,protocol,protocol,145,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,1,['protocol'],['protocol']
Integrability,"// stop info message every time; // check if any of the open files have version numbers greater than our major version; // may not read correctly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:13,message,message,13,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['message'],['message']
Integrability,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:49,Depend,Dependence,49,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,7,"['Depend', 'depend']","['Dependence', 'dependence']"
Integrability,"// struct RDaosNTupleAnchor; // clang-format off; /**; \class ROOT::Experimental::Internal::RPageSinkDaos; \ingroup NTuple; \brief Storage provider that writes ntuple pages to into a DAOS container. Currently, an object is allocated for ntuple metadata (anchor/header/footer).; Objects can correspond to pages or clusters of pages depending on the RNTuple-DAOS mapping strategy.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx:331,depend,depending,331,tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx,1,['depend'],['depending']
Integrability,// struct TDescriptors {; // };; // struct TWorkspace {; // };; /*! The reference architecture class.; *; * Class template that contains the reference implementation of the low-level; * interface for the DNN implementation. The reference implementation uses the; * TMatrixT class template to represent matrices.; *; * \tparam AReal The floating point type used to represent scalars.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h:186,interface,interface,186,tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h,1,['interface'],['interface']
Integrability,// struct _category_t {; // const char * const name;; // struct _class_t *const cls;; // const struct _method_list_t * const instance_methods;; // const struct _method_list_t * const class_methods;; // const struct _protocol_list_t * const protocols;; // const struct _prop_list_t * const properties;; // const struct _prop_list_t * const class_properties;; // const uint32_t size;; // },MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:240,protocol,protocols,240,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['protocol'],['protocols']
Integrability,// struct _objc_category {; // char *category_name;; // char *class_name;; // struct _objc_method_list *instance_method;; // struct _objc_method_list *class_method;; // struct _objc_protocol_list *protocols;; // uint32_t size; // sizeof(struct _objc_category); // struct _objc_property_list *instance_properties;// category's @property; // struct _objc_property_list *class_properties;; // },MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:197,protocol,protocols,197,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['protocol'],['protocols']
Integrability,// struct _objc_class {; // Class isa;; // Class super_class;; // char *name;; // long version;; // long info;; // long instance_size;; // struct _objc_ivar_list *ivars;; // struct _objc_method_list *methods;; // struct _objc_cache *cache;; // struct _objc_protocol_list *protocols;; // char *ivar_layout;; // struct _objc_class_ext *ext;; // };,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:272,protocol,protocols,272,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['protocol'],['protocols']
Integrability,// struct _protocol_t {; // id isa; // NULL; // const char * const protocol_name;; // const struct _protocol_list_t * protocol_list; // super protocols; // const struct method_list_t * const instance_methods;; // const struct method_list_t * const class_methods;; // const struct method_list_t *optionalInstanceMethods;; // const struct method_list_t *optionalClassMethods;; // const struct _prop_list_t * properties;; // const uint32_t size; // sizeof(struct _protocol_t); // const uint32_t flags; // = 0; // const char ** extendedMethodTypes;; // const char *demangledName;; // const struct _prop_list_t * class_properties;; // }; // Holder for struct _protocol_list_t *,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:142,protocol,protocols,142,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['protocol'],['protocols']
Integrability,// struct objc_protocol_list *protocols;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:30,protocol,protocols,30,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,2,['protocol'],['protocols']
Integrability,"// subtlety: because we know this was a non-local dependency, we know; // it's safe to materialize anywhere between the instruction within; // DepInfo and the end of it's block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:50,depend,dependency,50,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['depend'],['dependency']
Integrability,"// successful completion; wrap exception options to make them raiseable, normal return otherwise",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx:26,wrap,wrap,26,bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,1,['wrap'],['wrap']
Integrability,"// suppress the ""root : looking for image ..."" messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx:47,message,messages,47,graf2d/asimage/src/TASImage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx,1,['message'],['messages']
Integrability,"// switch (code) {; // case 1: {; // double min = dm.min(rangeName);; // double max = dm.max(rangeName);; // if (max <= dm0); // return 0;; // else if (min < dm0); // min = dm0;; //; // bool doNumerical = false;; // if (A != 0); // doNumerical = true;; // else if (B < 0) {; // // If b<0, pdf can be negative at large dm, the integral should; // // only up to where pdf hits zero. Better solution should be; // // solve the zero and use it as max.; // // Here we check this whether pdf(max) < 0. If true, let numerical; // // integral take care of. ( kind of ugly!); // if (1 - exp(-(max - dm0) / C) + B * (max / dm0 - 1) < 0); // doNumerical = true;; // }; // if (!doNumerical) {; // return (max - min) + C * exp(dm0 / C) * (exp(-max / C) - exp(-min / C)) +; // B * (0.5 * (max * max - min * min) / dm0 - (max - min));; // } else {; // // In principle the integral for a!=0 can be done analytically.; // // It involves incomplete Gamma function, TMath::Gamma(a+1,m/c),; // // which is not defined for a < -1. And the whole expression is; // // not stable for m/c >> 1.; // // Do numerical integral; // RooArgSet vset(dm.arg(),""vset"");; // std::unique_ptr<RooAbsFunc> func{bindVars(vset)};; // RooRombergIntegrator integrator(*func,min,max);; // return integrator.integral();; // }; // }; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooDstD0BG.cxx:1215,integrat,integrator,1215,roofit/roofit/src/RooDstD0BG.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooDstD0BG.cxx,2,['integrat'],['integrator']
Integrability,"// switch off Minuit2 printing of INFO message (cut off is 1001)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Minuit2Minimizer.cxx:39,message,message,39,math/minuit2/src/Minuit2Minimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Minuit2Minimizer.cxx,1,['message'],['message']
Integrability,"// switch off printing of info messages from chi2 test",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranDiscrete.cxx:31,message,messages,31,math/unuran/test/unuranDiscrete.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranDiscrete.cxx,5,['message'],['messages']
Integrability,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:58,Depend,Dependence,58,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,6,"['Depend', 'depend']","['Dependence', 'dependence', 'dependences']"
Integrability,"// synchronize",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:3,synchroniz,synchronize,3,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['synchroniz'],['synchronize']
Integrability,"// synchronize!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistBufferedFill.hxx:3,synchroniz,synchronize,3,hist/histv7/inc/ROOT/RHistBufferedFill.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistBufferedFill.hxx,1,['synchroniz'],['synchronize']
Integrability,// synthesize declaration of helper functions needed in this routine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:61,rout,routine,61,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,3,['rout'],['routine']
Integrability,"// tMOVi8 usually doesn't start long dependency chains, and there are a lot; // of them, so always shrink them when CPSR doesn't have high latency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:37,depend,dependency,37,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,1,['depend'],['dependency']
Integrability,"// take address of first adapter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUUID.cxx:25,adapter,adapter,25,core/base/src/TUUID.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUUID.cxx,1,['adapter'],['adapter']
Integrability,"// take all geometry objects, then we have to treat them differently, depending on type.; // and update world-matrix / check visibility; // or setup secondary indices for sub-instance drawing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/GlViewerRCore.js:70,depend,depending,70,ui5/eve7/lib/GlViewerRCore.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/GlViewerRCore.js,1,['depend'],['depending']
Integrability,"// taken grom Geant3 routine GSMATE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMaterial.cxx:21,rout,routine,21,geom/geom/src/TGeoMaterial.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMaterial.cxx,1,['rout'],['routine']
Integrability,"// takes ownership of all sets; // Mark all observables as internally integrated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:70,integrat,integrated,70,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,1,['integrat'],['integrated']
Integrability,"// tell coverity that parm1 is a Long_t, and not an enum (even; // if we compare it with an enum value) and the meaning of; // parm1 depends on GET_MSG(msg) and GET_SUBMSG(msg); // coverity[mixed_enums]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootBrowserLite.cxx:133,depend,depends,133,gui/gui/src/TRootBrowserLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootBrowserLite.cxx,2,['depend'],['depends']
Integrability,"// temp before having new Integrator class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testGSLIntegration.cxx:26,Integrat,Integrator,26,math/mathmore/test/testGSLIntegration.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testGSLIntegration.cxx,1,['Integrat'],['Integrator']
Integrability,"// template <class T, unsigned int D, unsigned int D2> class MatRepStd;; /**; Expression wrapper class for Vector objects. @ingroup Expression; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Expression.h:89,wrap,wrapper,89,math/smatrix/inc/Math/Expression.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Expression.h,1,['wrap'],['wrapper']
Integrability,"// template methods for generic functors; /**; method to set the a generic integration function. @param f integration function. The function type must implement the assignment operator, <em> double operator() ( double x ) </em>. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h:75,integrat,integration,75,math/mathmore/inc/Math/GSLIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h,4,['integrat'],['integration']
Integrability,"// template methods for generic functors; /**; method to set the a generic integration function; @param f integration function. The function type must implement the assignment operator, <em> double operator() ( double x ) </em>. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h:75,integrat,integration,75,math/mathcore/inc/Math/Integrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h,2,['integrat'],['integration']
Integrability,"// test STL interface; // float p[2] = {1,2};",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/testSMatrix.cxx:12,interface,interface,12,math/smatrix/test/testSMatrix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/testSMatrix.cxx,1,['interface'],['interface']
Integrability,"// test TUnuran Sampler class using t he DistSampler interface ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranSampler.cxx:53,interface,interface,53,math/unuran/test/unuranSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranSampler.cxx,1,['interface'],['interface']
Integrability,"// test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx:73,depend,dependent,73,tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx,6,['depend'],['dependent']
Integrability,"// test messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Messenger_decl.h:8,message,messages,8,roofit/multiprocess/res/RooFit/MultiProcess/Messenger_decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Messenger_decl.h,1,['message'],['messages']
Integrability,"// test of multidimentional Integration; // Calculates an integral of a function; // in 2,3,..., 8 dimensions; // by using adaptive Genz Malik cubature; // and MonteCarlo methods:; // --PLAIN; // --VEGAS; // --MISER; //; // from; // IntegratorMultiDim class; // and GSLMCIntegrator class; //; // Compares time performance; // for different dimensions; // draws a graph; //; // Author: Magdalena Slawinska; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testMCIntegration.cxx:28,Integrat,Integration,28,math/mathmore/test/testMCIntegration.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testMCIntegration.cxx,2,['Integrat'],"['Integration', 'IntegratorMultiDim']"
Integrability,"// test tree nmin cut -> for debug purposes; // the routine will generate trees with stopping cut on N(eve) given by; // a fraction between [20,N(eve)-1].; //; // MakeForestRnd();; // exit(1);; //; // Init RuleFit object and create rule ensemble; // + make forest & rules",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodRuleFit.cxx:52,rout,routine,52,tmva/tmva/src/MethodRuleFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodRuleFit.cxx,1,['rout'],['routine']
Integrability,"// test unuran using the string interface to generate numbers according to the normal distributions; // compare CPU performancecwith TRandom::Gaus and opitonally GSL (using MathMore ) and CLHEP for; // generating normal distributed random numbers; //; // run within ROOT (.x unuranSimple.cxx+) or pass any extra parameter in the command line to get; // a graphics output; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranSimple.cxx:32,interface,interface,32,math/unuran/test/unuranSimple.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranSimple.cxx,1,['interface'],['interface']
Integrability,"// test using 1D Distribution object interface; // and compare results and CPU performances using TF1::GetRandom; //; // run within ROOT (.x unuranDistr.cxx+) or pass any extra parameter in the command line to get; // a graphics output",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranDistr.cxx:37,interface,interface,37,math/unuran/test/unuranDistr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranDistr.cxx,1,['interface'],['interface']
Integrability,"// test using Multi-dim (2D) Distribution object interface; // and compare results and CPU performances using TF2::GetRandom; //; // run within ROOT (.x unuranMulti2D.cxx+) or pass any extra parameter in the command line to get; // a graphics output",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranMulti2D.cxx:49,interface,interface,49,math/unuran/test/unuranMulti2D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranMulti2D.cxx,1,['interface'],['interface']
Integrability,"// test using Multi-dim Distribution object interface; // and compare results and CPU performances using TF3::GetRandom in case of 3D; // and test also case of dim = 10 and 100; //; // run within ROOT (.x unuranMultiDim.cxx+) or pass any extra parameter in the command line to get; // a graphics output",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranMultiDim.cxx:44,interface,interface,44,math/unuran/test/unuranMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranMultiDim.cxx,1,['interface'],['interface']
Integrability,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:629,depend,dependence,629,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:405,depend,dependence,405,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:301,depend,dependence,301,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,4,['depend'],['dependence']
Integrability,// text message for found query,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomHierarchy.controller.js:8,message,message,8,ui5/geom/controller/GeomHierarchy.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomHierarchy.controller.js,1,['message'],['message']
Integrability,"// the ""interface"" identifier; // Code completion after '@interface'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:8,interface,interface,8,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,2,['interface'],['interface']
Integrability,"// the ""protocol"" identifier",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:8,protocol,protocol,8,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocol']
Integrability,"// the 'if' part is that surrounded by the debug code.; // Intentionally accessing the deleted memory to check whether it has been changed as; // a consequence (side effect) of executing operator delete. If there no change, we; // can guess this is always the case and we can rely on the changes to fBits made; // by ~TObject to detect use-after-delete error (and print a message rather than; // stop the program with a segmentation fault)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx:372,message,message,372,core/base/src/TObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx,1,['message'],['message']
Integrability,"// the TClass constructor will print a Warning message for classes that don't exist; // so, ignore warnings temporarily.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx:47,message,message,47,core/rint/src/TTabCom.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx,2,['message'],['message']
Integrability,"// the beautiful greeting message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Factory.h:26,message,message,26,tmva/tmva/inc/TMVA/Factory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Factory.h,1,['message'],['message']
Integrability,"// the kPROOF_STOPPRPOCESS message is send after the worker receives zero; // as the reply to kPROOF_GETNEXTPACKET",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx:27,message,message,27,proof/proofplayer/src/TPacketizerAdaptive.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx,1,['message'],['message']
Integrability,"// the message was already compressed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMessage.cxx:7,message,message,7,net/net/src/TMessage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMessage.cxx,1,['message'],['message']
Integrability,"// the stuff that the clients have cached may depend on the normalization range",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:46,depend,depend,46,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,2,['depend'],['depend']
Integrability,// the templated records will be resposbible for injecting their templates,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:49,inject,injecting,49,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,1,['inject'],['injecting']
Integrability,// the type name; // Parse type arguments and protocol qualifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:46,protocol,protocol,46,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocol']
Integrability,// then begin the next message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:23,message,message,23,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,1,['message'],['message']
Integrability,"// then paint 3d frame (depending on bordermode)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:24,depend,depending,24,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,2,['depend'],['depending']
Integrability,"// then process incoming messages from sockets",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx:25,message,messages,25,roofit/multiprocess/src/Messenger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx,3,['message'],['messages']
Integrability,"// there is no accessible dependency file, let's assume the library has been; // modified",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:26,depend,dependency,26,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['depend'],['dependency']
Integrability,"// these overwrite higher input bits, otherwise the lower word of output; // depends only on the lower word of input. So check their uses read W.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:77,depend,depends,77,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,1,['depend'],['depends']
Integrability,// these variables need to be fixed in one step; // Group Connected Components for Unsafe Vars; // (Dependencies based on pointer assignments),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:100,Depend,Dependencies,100,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['Depend'],['Dependencies']
Integrability,"// this Defined quantity does not depend on this variation, so no need to create a varied RDefine",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx:34,depend,depend,34,tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx,2,['depend'],['depend']
Integrability,"// this call blocks until a message is received",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/mpi/src/TMPIFile.cxx:28,message,message,28,io/mpi/src/TMPIFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/mpi/src/TMPIFile.cxx,1,['message'],['message']
Integrability,"// this code is based on _lookupTable and uses linear interpolation, just as; // evaluate(); integration is done using the trapez rule",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooKeysPdf.cxx:93,integrat,integration,93,roofit/roofit/src/RooKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooKeysPdf.cxx,1,['integrat'],['integration']
Integrability,"// this is a limitation of TF1 interface - cannot fix a parameter to zero value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitImpl.cxx:31,interface,interface,31,hist/hist/src/HFitImpl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitImpl.cxx,1,['interface'],['interface']
Integrability,"// this is call-back, invoked when message received from client",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/geom/geom_threejs.cxx:35,message,message,35,tutorials/webgui/geom/geom_threejs.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/geom/geom_threejs.cxx,2,['message'],['message']
Integrability,"// this is call-back, invoked when message received via websocket",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomViewer.cxx:35,message,message,35,geom/webviewer/src/RGeomViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomViewer.cxx,5,['message'],['message']
Integrability,"// this is to avoid sending XdndPosition messages over and over; // if the target is not responding",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx:41,message,messages,41,gui/gui/src/TGDNDManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx,1,['message'],['messages']
Integrability,"// this message is too small to be compressed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMessage.cxx:8,message,message,8,net/net/src/TMessage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMessage.cxx,1,['message'],['message']
Integrability,"// this message makes only sense when the query is being processed,; // however the message can also be received if the user pressed; // ctrl-c, so ignore it!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:8,message,message,8,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,2,['message'],['message']
Integrability,// this number will be send to server with first message,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:49,message,message,49,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['message'],['message']
Integrability,"// this only works with c++14, use ROOT wrapper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx:40,wrap,wrapper,40,net/http/src/TRootSniffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx,1,['wrap'],['wrapper']
Integrability,// this routine is shared by 'omp distribute parallel for' and; // 'omp distribute': select the right EUB expression depending on the; // directive,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:8,rout,routine,8,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,2,"['depend', 'rout']","['depending', 'routine']"
Integrability,"// this set call-back, invoked when message received from client; // also at this moment thread id is configured which supposed to be used to handle requests",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx:36,message,message,36,tutorials/webgui/ping/ping.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx,1,['message'],['message']
Integrability,"// thread is set up in initialisation routine or Run().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx:38,rout,routine,38,core/thread/src/TThread.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx,1,['rout'],['routine']
Integrability,// thread locals generate different symbols depending on whether or not; // emulated TLS is enabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp:44,depend,depending,44,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp,1,['depend'],['depending']
Integrability,// to avoid cross-dependency between modules,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:18,depend,dependency,18,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['depend'],['dependency']
Integrability,"// to avoid dependency from TF1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx:12,depend,dependency,12,gui/fitpanelv7/src/RFitPanel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx,1,['depend'],['dependency']
Integrability,"// to avoid dependency from TF1; // if TF1 object deleted before - prevent second delete",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx:12,depend,dependency,12,gui/fitpanelv7/src/RFitPanel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx,1,['depend'],['dependency']
Integrability,"// to be added later; //double Integral(const GSLMonteFuncPointer & f);; //double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);; /**; return the type of the integration used; */; //MCIntegration::Type MCType() const;; /**; return the Result of the last Integral calculation; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMCIntegrator.h:176,integrat,integration,176,math/mathmore/inc/Math/GSLMCIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMCIntegrator.h,1,['integrat'],['integration']
Integrability,"// to get the data, we must call XConvertSelection with; // the timestamp in XdndDrop, wait for SelectionNotify; // to arrive to retrieve the data, and when we are finished,; // send a XdndFinished message to the source.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx:198,message,message,198,gui/gui/src/TGDNDManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx,1,['message'],['message']
Integrability,"// todo: at some point, take care of integrator configurations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONFactories_RooFitCore.cxx:37,integrat,integrator,37,roofit/hs3/src/JSONFactories_RooFitCore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONFactories_RooFitCore.cxx,1,['integrat'],['integrator']
Integrability,"// todo: if adding a pdf, should actually replace RooRealSumPdf with a RooAddPdf and put; // the sumPdf and *this* pdf inside that pdf; // only exception is the binSamplingPdf below to integrate unbinned functions across bins",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:185,integrat,integrate,185,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['integrat'],['integrate']
Integrability,"// training interface - called from MethodCFMlpANN class object; // sanity checks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCFMlpANN_Utils.cxx:12,interface,interface,12,tmva/tmva/src/MethodCFMlpANN_Utils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCFMlpANN_Utils.cxx,1,['interface'],['interface']
Integrability,"// translated from CERNLIB routine VAVRAN by B. List 14.5.2010",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/VavilovFast.cxx:27,rout,routine,27,math/mathmore/src/VavilovFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/VavilovFast.cxx,1,['rout'],['routine']
Integrability,"// try to initialize our numerical integration engine",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:35,integrat,integration,35,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['integrat'],['integration']
Integrability,"// try to reduce some error messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:28,message,messages,28,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['message'],['messages']
Integrability,"// try to reduce some error messages; //bool silentMode = (RooMsgService::instance().globalKillBelow() >= RooFit::ERROR || RooMsgService::instance().silentMode()) ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:28,message,messages,28,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['message'],['messages']
Integrability,"// tryAddEdge returns false if there is a dependency that makes adding; // the A->B edge impossible, otherwise it returns true;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:42,depend,dependency,42,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['depend'],['dependency']
Integrability,"// two-point derivatives always assumed necessary; // maximum number of cycles over step size depends on strategy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:94,depend,depends,94,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['depend'],['depends']
Integrability,"// type of integration; //enum Type { PLAIN, MISER, VEGAS};",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/MCIntegrationTypes.h:11,integrat,integration,11,math/mathmore/inc/Math/MCIntegrationTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/MCIntegrationTypes.h,1,['integrat'],['integration']
Integrability,"// type of integration; //for 1-dim integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AllIntegrationTypes.h:11,integrat,integration,11,math/mathcore/inc/Math/AllIntegrationTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AllIntegrationTypes.h,2,['integrat'],['integration']
Integrability,// typedef struct objc_object Protocol;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:30,Protocol,Protocol,30,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['Protocol'],['Protocol']
Integrability,// typeid is never type-dependent (C++ [temp.dep.expr]p4),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:24,depend,dependent,24,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,1,['depend'],['dependent']
Integrability,"// uint32_t list[1]; /* Protocol *, aka struct objc_protocol_t *; // (32-bit pointer) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp:24,Protocol,Protocol,24,interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,1,['Protocol'],['Protocol']
Integrability,"// unknown message code at this stage",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:11,message,message,11,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['message'],['message']
Integrability,"// unknown message, probably should be processed by other implementation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:11,message,message,11,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,1,['message'],['message']
Integrability,// unnamed namespace; //===----------------------------------------------------------------------===//; // Code beyond this point should not be synchronized with libc++abi.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/ItaniumDemangle.cpp:144,synchroniz,synchronized,144,interpreter/llvm-project/llvm/lib/Demangle/ItaniumDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/ItaniumDemangle.cpp,1,['synchroniz'],['synchronized']
Integrability,// unsigned wrap,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:12,wrap,wrap,12,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,1,['wrap'],['wrap']
Integrability,"// update sigmas (rho dependent)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx:22,depend,dependent,22,roofit/roofit/src/RooNDKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx,1,['depend'],['dependent']
Integrability,"// use ROOT integration method if there are nuisance parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:12,integrat,integration,12,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['integrat'],['integration']
Integrability,"// use a different integrator by default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooJeffreysPrior.cxx:19,integrat,integrator,19,roofit/roofit/src/RooJeffreysPrior.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooJeffreysPrior.cxx,1,['integrat'],['integrator']
Integrability,"// use default copy constructor and assignment operator; /// clone (required by the interface)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h:84,interface,interface,84,math/mathcore/inc/Math/WrappedFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h,4,['interface'],['interface']
Integrability,"// use default copy-ctor and assignment operators; // using ParamFunction::operator();; /**; Find the polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""https://www.gnu.org/software/gsl/doc/html/poly.html"">documentation</A> ); For the case of n = 4 by default an analytical algorithm is used from an implementation by; Andrew W. Steiner and Andy Buckley which is a translation from the original Cenrlib routine; (< HREF=""https://cds.cern.ch/record/2050876/files/c208.html"">RRTEQ4</A> ).; Note that depending on the coefficients the result could be not very accurate if the discriminant of the resolvent cubic; equation is very small. In that case it might be more robust to use the numerical method, by calling directly FindNumRoots(). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Polynomial.h:530,rout,routine,530,math/mathmore/inc/Math/Polynomial.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Polynomial.h,2,"['depend', 'rout']","['depending', 'routine']"
Integrability,"// use different mean value in function wrapper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:40,wrap,wrapper,40,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['wrap'],['wrapper']
Integrability,"// use directly function interfaces; //ROOT::Math::Functor f2( *f, 2);; //TUnuranMultiContDist dist(f2);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranMulti2D.cxx:25,interface,interfaces,25,math/unuran/test/unuranMulti2D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranMulti2D.cxx,1,['interface'],['interfaces']
Integrability,"// use generic function interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx:24,interface,interface,24,math/mathmore/src/GSLIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx,5,['interface'],['interface']
Integrability,"// use integration method if there are nuisance parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:7,integrat,integration,7,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['integrat'],['integration']
Integrability,"// use now plugin-manager for creating the GSL integrator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Integrator.cxx:47,integrat,integrator,47,math/mathcore/src/Integrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Integrator.cxx,1,['integrat'],['integrator']
Integrability,"// use range for step size or give some value depending on x if range is not defined",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:46,depend,depending,46,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['depend'],['depending']
Integrability,"// use simply TF1 wrapper; // ROOT::Math::WrappedMultiTF1 f(*func);; // ROOT::Math::WrappedTF1 f(*func);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testFitPerf.cxx:18,wrap,wrapper,18,roofit/roofit/test/testFitPerf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testFitPerf.cxx,1,['wrap'],['wrapper']
Integrability,"// use simply TF1 wrapper; // ROOT::Math::WrappedMultiTF1 f2(*f1);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/testNdimFit.cxx:18,wrap,wrapper,18,math/minuit2/test/testNdimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/testNdimFit.cxx,5,['wrap'],['wrapper']
Integrability,"// use still MySimAnFunc for initial routes and distance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx:37,rout,routes,37,math/mathmore/test/simanTSP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx,1,['rout'],['routes']
Integrability,// use the concatenated `hi` and `lo` registers; // to store doubleword values; // Fixme: Not triggering the use of both hi and low; // This will generate an error message,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:164,message,message,164,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['message'],['message']
Integrability,"// use the old default value here - the value is some kind of random as it depends on the scaleFactor (user unit); // (""50"" is transformed to the ""user space"" but then used in ""pdf space"")",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:75,depend,depends,75,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['depend'],['depends']
Integrability,"// used only to read an old message type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerFile.cxx:28,message,message,28,proof/proofplayer/src/TPacketizerFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerFile.cxx,2,['message'],['message']
Integrability,"// user interface for TF1 objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TF1Editor.h:8,interface,interface,8,gui/ged/inc/TF1Editor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TF1Editor.h,1,['interface'],['interface']
Integrability,// using decls differ if one says 'typename' and the other doesn't.; // FIXME: non-dependent using decls?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:83,depend,dependent,83,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"// using the new GetColumnReaders mechanism; // TODO consider changing the interface so we return all of these for all slots in one go",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:75,interface,interface,75,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,1,['interface'],['interface']
Integrability,// using typename qualifier::name (only in a dependent context),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:45,depend,dependent,45,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['depend'],['dependent']
Integrability,// v0 - v31 are aliases of q0 - q31 or d0 - d31 depending on size.; // By default we'll emit v0-v31 for this unless there's a modifier where; // we'll emit the correct register as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:48,depend,depending,48,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['depend'],['depending']
Integrability,// v4i32: make use of the PMULUDQ instruction to multiply 2 lanes of v4i32; // to v2i64 results at a time. The upper 32-bits contain the wrapped bits; // that can then be OR'd with the lower 32-bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:137,wrap,wrapped,137,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['wrap'],['wrapped']
Integrability,// value-dependent address space qualifier,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:9,depend,dependent,9,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['depend'],['dependent']
Integrability,"// vector-optimized iterator protocol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:29,protocol,protocol,29,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,1,['protocol'],['protocol']
Integrability,"// verify range and print out message; // if outside range, set to closest limit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodRuleFit.h:30,message,message,30,tmva/tmva/inc/TMVA/MethodRuleFit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodRuleFit.h,1,['message'],['message']
Integrability,"// verify range and print out message; // if outside range, set to given default value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodRuleFit.h:30,message,message,30,tmva/tmva/inc/TMVA/MethodRuleFit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodRuleFit.h,1,['message'],['message']
Integrability,// virtual interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/SymbolicFile.h:11,interface,interface,11,interpreter/llvm-project/llvm/include/llvm/Object/SymbolicFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/SymbolicFile.h,1,['interface'],['interface']
Integrability,"// virtual std::vector<double> Gradient(std::vector<double> const &) const;; // forward interface; // virtual double operator()(int npar, double* params,int iflag = 4) const;; /**; evaluate gradient hessian and function value needed by fumili; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliFCNAdapter.h:88,interface,interface,88,math/minuit2/inc/Minuit2/FumiliFCNAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliFCNAdapter.h,1,['interface'],['interface']
Integrability,"// virtual ~WrappedFunction() { /**/ }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h:12,Wrap,WrappedFunction,12,math/mathcore/inc/Math/WrappedFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h,2,['Wrap'],['WrappedFunction']
Integrability,"// void TFumiliMinimizer::FcnGrad( int &, double * g, double & f, double * x , int iflag ) {; // // implementation of FCN static function used internally by TFumili.; // // Adapt IMultiGradFunction interface to TFumili FCN static function in the case of user; // // provided gradient.; // ROOT::Math::IMultiGradFunction * gFunc = dynamic_cast<ROOT::Math::IMultiGradFunction *> ( fgFunc);; // assert(gFunc != 0);; // f = gFunc->operator()(x);; // // calculates also derivatives; // if (iflag == 2) gFunc->Gradient(x,g);; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx:198,interface,interface,198,math/fumili/src/TFumiliMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx,1,['interface'],['interface']
Integrability,"// wait a second so that all pull sockets are connected for round-robin distribution; // if you don't wait a second above, the push socket will ""round-robin"" all the messages to just one or two; // connected sockets",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ_load_balancing.cxx:166,message,messages,166,roofit/roofitZMQ/test/test_ZMQ_load_balancing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ_load_balancing.cxx,1,['message'],['messages']
Integrability,"// wait because there is a chance that message queue does not exist yet",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32ProxyBase.cxx:39,message,message,39,graf2d/win32gdk/src/TGWin32ProxyBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32ProxyBase.cxx,1,['message'],['message']
Integrability,// warn if instance method found for a Class message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:45,message,message,45,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['message'],['message']
Integrability,// warn in presence of __bridge casting to or from a toll free bridge cast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:63,bridg,bridge,63,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['bridg'],['bridge']
Integrability,"// we need to copy the pointer to the wrapped function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/MultiNumGradFunction.h:38,wrap,wrapped,38,math/mathmore/inc/Math/MultiNumGradFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/MultiNumGradFunction.h,1,['wrap'],['wrapped']
Integrability,"// we need to explicitly delete the ROOT wrapper class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRndmEngines.cxx:41,wrap,wrapper,41,math/mathmore/src/GSLRndmEngines.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRndmEngines.cxx,1,['wrap'],['wrapper']
Integrability,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:55,Depend,Dependence,55,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,9,"['Depend', 'depend']","['Dependence', 'dependence']"
Integrability,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:54,Depend,Dependence,54,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,7,"['Depend', 'depend']","['Dependence', 'dependence', 'dependences']"
Integrability,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:54,Depend,Dependence,54,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,7,"['Depend', 'depend']","['Dependence', 'dependence', 'dependences']"
Integrability,"// welcome message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitAPI.h:11,message,message,11,tmva/tmva/inc/TMVA/RuleFitAPI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitAPI.h,1,['message'],['message']
Integrability,"// what about nested types?; // Note: The split of CXXDecl information here is intentional, the; // gdb tests will depend on a certain ordering at printout. The debug; // information offsets are still correct if we merge them all together; // though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:115,depend,depend,115,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['depend'],['depend']
Integrability,"// when comparing an id<P> on lhs with a static type on rhs,; // see if static class implements all of id's protocols, directly or; // through its super class and categories.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:108,protocol,protocols,108,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,3,['protocol'],['protocols']
Integrability,"// when comparing an id<P> on rhs with a static type on lhs,; // see if static class implements all of id's protocols, directly or; // through its super class and categories.; // First, lhs protocols in the qualifier list must be found, direct; // or indirect in rhs's qualifier list or it is a mismatch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:108,protocol,protocols,108,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['protocol'],['protocols']
Integrability,"// while next module; // libCint is missing as we don't have class doc for it; // We need it for dependencies nevertheless, so add it by hand.; /*; sstrCluster << ""subgraph clusterlibCint {"" << std::endl; << ""style=filled;"" << std::endl; << ""color=lightgray;"" << std::endl; << ""label=\""libCint\"";"" << std::endl; << ""\""CINT\"" [style=filled,color=white,fontsize=10]"" << std::endl; << ""}"" << std::endl;; */; // simplify the library dependencies, by removing direct links; // that are equivalent to indirect ones, e.g. instead of having both; // A->C, A->B->C, keep only A->B->C.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx:97,depend,dependencies,97,html/src/TDocOutput.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx,2,['depend'],['dependencies']
Integrability,"// window handling listbox messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSStepButton.h:27,message,messages,27,test/periodic/XSStepButton.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSStepButton.h,1,['message'],['messages']
Integrability,"// with gcc on unix machines and on x86_64, we can gain by hand-coding; // exp(z) for the x87 coprocessor; other platforms have the default; // routines as fallback implementation, and compilers other than gcc on; // x86_64 generate better code with the default routines; also avoid; // the inline assembly code when the compiler is not optimising code, or; // is optimising for code size; // (we insist on __unix__ here, since the assemblers on other OSs; // typically do not speak AT&T syntax as gas does...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooHeterogeneousMath.h:144,rout,routines,144,roofit/batchcompute/res/RooHeterogeneousMath.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooHeterogeneousMath.h,2,['rout'],['routines']
Integrability,"// wrap in a RooSimultaneous",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testTestStatistics.cxx:3,wrap,wrap,3,roofit/roofitcore/test/testTestStatistics.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testTestStatistics.cxx,2,['wrap'],['wrap']
Integrability,// wrap needs to be able to steal the payload.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:3,wrap,wrap,3,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['wrap'],['wrap']
Integrability,// wrap-around sve register,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp:3,wrap,wrap-around,3,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp,1,['wrap'],['wrap-around']
Integrability,"// wrapped TString",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TObjString.h:3,wrap,wrapped,3,core/base/inc/TObjString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TObjString.h,1,['wrap'],['wrapped']
Integrability,"// wrapped function in interface for integral calculation; // using abs value of integral",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:3,wrap,wrapped,3,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,2,"['interface', 'wrap']","['interface', 'wrapped']"
Integrability,"// wrapped pdf of RooPolyFunc should match RooPolynomial; // EXPECT_FLOAT_EQ(wrapperpdf.getVal(), pdf.getVal())",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooPolyFunc.cxx:3,wrap,wrapped,3,roofit/roofitcore/test/testRooPolyFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooPolyFunc.cxx,2,['wrap'],"['wrapped', 'wrapperpdf']"
Integrability,"// wrapper around a cdf function to re-scale for the range",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GoFTest.cxx:3,wrap,wrapper,3,math/mathcore/src/GoFTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GoFTest.cxx,1,['wrap'],['wrapper']
Integrability,"// wrapper class for TMVA interface to evaluate objective function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genetic/src/GeneticMinimizer.cxx:3,wrap,wrapper,3,math/genetic/src/GeneticMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genetic/src/GeneticMinimizer.cxx,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"// wrapper class for a RooPdf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/WrapperRooPdf.h:3,wrap,wrapper,3,roofit/roofit/test/WrapperRooPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/WrapperRooPdf.h,1,['wrap'],['wrapper']
Integrability,"// wrapper class used to wrap ROOT random number engines with GSL interface; // @(#)root/mathmore:$Id$; // Author: L. Moneta Fri Aug 24 17:20:45 2007; /**********************************************************************; * *; * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; * *; * *; **********************************************************************/; // Header file for class GSLRngWrapper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRngROOTWrapper.h:3,wrap,wrapper,3,math/mathmore/src/GSLRngROOTWrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRngROOTWrapper.h,3,"['interface', 'wrap']","['interface', 'wrap', 'wrapper']"
Integrability,"// wrapper classes random and rng must exist during call to Step()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx:3,wrap,wrapper,3,math/mathmore/src/GSLSimAnnealing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx,1,['wrap'],['wrapper']
Integrability,"// wrapper for clhep",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testRandom.cxx:3,wrap,wrapper,3,math/mathmore/test/testRandom.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testRandom.cxx,1,['wrap'],['wrapper']
Integrability,"// wrapper for stdrand",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testRandom.cxx:3,wrap,wrapper,3,math/mathmore/test/testRandom.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testRandom.cxx,1,['wrap'],['wrapper']
Integrability,"// wrapper for the beta",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testStatFunc.cxx:3,wrap,wrapper,3,math/mathmore/test/testStatFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testStatFunc.cxx,1,['wrap'],['wrapper']
Integrability,// wrapper functions for calling on Matrix instead of tensors; /* impl using Matrix */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestActivationFunctions.h:3,wrap,wrapper,3,tmva/tmva/test/DNN/TestActivationFunctions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestActivationFunctions.h,1,['wrap'],['wrapper']
Integrability,"// wrapper name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:3,wrap,wrapper,3,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['wrap'],['wrapper']
Integrability,"// wrapper of all main methods for extraction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/inc/TGDMLWrite.h:3,wrap,wrapper,3,geom/gdml/inc/TGDMLWrite.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/inc/TGDMLWrite.h,1,['wrap'],['wrapper']
Integrability,"// wrapper to calculate eigenvalues of the covariance matrix using mneigen function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnEigen.cxx:3,wrap,wrapper,3,math/minuit2/src/MnEigen.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnEigen.cxx,1,['wrap'],['wrapper']
Integrability,"// wrappers to pdf to be integrated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testStatFunc.cxx:3,wrap,wrappers,3,math/mathmore/test/testStatFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testStatFunc.cxx,2,"['integrat', 'wrap']","['integrated', 'wrappers']"
Integrability,"// write custom message file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:16,message,message,16,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,2,['message'],['message']
Integrability,"// write the constructor wrapper only for concrete classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:25,wrap,wrapper,25,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['wrap'],['wrapper']
Integrability,// writes records to assembly file using MC library interface,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/CodeViewRecordIO.h:52,interface,interface,52,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/CodeViewRecordIO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/CodeViewRecordIO.h,1,['interface'],['interface']
Integrability,"// x - x -> 0, x ^ x -> 0. This is non-refining, because x is non-poison; // by assumption and this case never wraps, so nowrap flags can be; // ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:111,wrap,wraps,111,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['wrap'],['wraps']
Integrability,"// x86-32 OSX has a scheme where fwrite and fputs (and some other functions; // we don't care about) have two versions; on recent OSX, the one we want; // has a $UNIX2003 suffix. The two implementations are identical except; // for the return value in some edge cases. However, we don't want to; // generate code that depends on the old symbols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:318,depend,depends,318,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,1,['depend'],['depends']
Integrability,"// xmax < 0 so integrate from (-inf,xmax)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx:15,integrat,integrate,15,roofit/roofitcore/src/RooImproperIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx,1,['integrat'],['integrate']
Integrability,"// xmax >= 0 so integrate from (-inf,-1) and (-1,xmax)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx:16,integrat,integrate,16,roofit/roofitcore/src/RooImproperIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx,1,['integrat'],['integrate']
Integrability,"// xmin <= 0 so integrate from (xmin,+1) and (+1,+inf)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx:16,integrat,integrate,16,roofit/roofitcore/src/RooImproperIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx,1,['integrat'],['integrate']
Integrability,"// xmin > 0 so integrate from (xmin,+inf)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx:15,integrat,integrate,15,roofit/roofitcore/src/RooImproperIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx,1,['integrat'],['integrate']
Integrability,// z/OS XPLINK ADA Entry; // Wraps a TargetGlobalAddress that should be loaded from a function's; // AssociatedData Area (ADA). Tha ADA is passed to the function by the; // caller in the XPLink ABI defined register R5.; // Operand 0: the GlobalValue/External Symbol; // Operand 1: the ADA register; // Operand 2: the offset (0 for the first and 8 for the second element in the; // function descriptor),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:29,Wrap,Wraps,29,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,1,['Wrap'],['Wraps']
Integrability,// z/OS tool chain depends on LE data sets and the CSSLIB data set.; // These data sets can have different high level qualifiers (HLQs); // as each installation can define them differently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ZOS.cpp:19,depend,depends,19,interpreter/llvm-project/clang/lib/Driver/ToolChains/ZOS.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ZOS.cpp,1,['depend'],['depends']
Integrability,"// zext(C + x + y + ...) --> (zext(D) + zext((C - D) + x + y + ...)); // if D + (C - D + x + y + ...) could be proven to not unsigned wrap; // where D maximizes the number of trailing zeros of (C - D + x + y + ...); //; // Often address arithmetics contain expressions like; // (zext (add (shl X, C1), C2)), for instance, (zext (5 + (4 * X))).; // This transformation is useful while proving that such expressions are; // equal or differ by a small constant amount, see LoadStoreVectorizer pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:134,wrap,wrap,134,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// zext({C,+,Step}) --> (zext(D) + zext({C-D,+,Step}))<nuw><nsw>; // if D + (C - D + Step * n) could be proven to not unsigned wrap; // where D maximizes the number of trailing zeros of (C - D + Step * n)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:127,wrap,wrap,127,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// { if (fExtraOptions) delete fExtraOptions; }; // use default copy constructor and assignment operator; /** generic methods for retrieving options */; // methods implementing the IOptions interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GenAlgoOptions.h:190,interface,interface,190,math/mathcore/inc/Math/GenAlgoOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GenAlgoOptions.h,1,['interface'],['interface']
Integrability,"// {4-0} = szimm5; // The value we are trying to encode is an immediate between either the; // range of [1-7] or [1-15] depending on whether we are dealing with the; // u8/s8 or the u16/s16 variants respectively.; // This value is encoded as follows, if ShiftImm is the value within those; // ranges then the encoding szimm5 = ShiftImm + size, where size is either 8; // or 16.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:120,depend,depending,120,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,1,['depend'],['depending']
Integrability,"//! Interface to a 'XRD' staging",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/TNetXNGFileStager.h:4,Interface,Interface,4,net/netxng/inc/TNetXNGFileStager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/TNetXNGFileStager.h,1,['Interface'],['Interface']
Integrability,"//! Lower integration bound",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.h:10,integrat,integration,10,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.h,2,['integrat'],['integration']
Integrability,"//! The integration cache manager",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooRealSumFunc.h:8,integrat,integration,8,roofit/roofitcore/inc/RooRealSumFunc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooRealSumFunc.h,1,['integrat'],['integration']
Integrability,"//! Upper integration bound",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.h:10,integrat,integration,10,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.h,2,['integrat'],['integration']
Integrability,"//! message logger",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/FitterBase.h:4,message,message,4,tmva/tmva/inc/TMVA/FitterBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/FitterBase.h,7,['message'],['message']
Integrability,"//! message logger, static to save resources",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/TNeuron.cxx:4,message,message,4,tmva/tmva/src/TNeuron.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/TNeuron.cxx,2,['message'],['message']
Integrability,"//! object for interface with xml library",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/xml/inc/TXMLFile.h:15,interface,interface,15,io/xml/inc/TXMLFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/xml/inc/TXMLFile.h,1,['interface'],['interface']
Integrability,"//! pointer to wrapped node in the decision tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/CCTreeWrapper.h:15,wrap,wrapped,15,tmva/tmva/inc/TMVA/CCTreeWrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/CCTreeWrapper.h,1,['wrap'],['wrapped']
Integrability,//!< @brief index for next read - 1 (i.e. increment tail BEFORE read); /**; * @brief Multiple methods of LineWrapper may decide to flush part of the buffer to; * free up space. The contract of process() says that only 1 line is output. So; * this variable is used to track whether something has output a line. It is; * reset at the beginning of process() and checked at the end to decide if; * output has already occurred or is still needed.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h:181,contract,contract,181,core/dictgen/res/OptionParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h,1,['contract'],['contract']
Integrability,"//!Error message in case of checksum/version mismatch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TStreamerElement.h:9,message,message,9,core/meta/inc/TStreamerElement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TStreamerElement.h,1,['message'],['message']
Integrability,"//!Pointer to a wrapper around a custom convertion streamer member function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TStreamerElement.h:16,wrap,wrapper,16,core/meta/inc/TStreamerElement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TStreamerElement.h,1,['wrap'],['wrapper']
Integrability,"//!Pointer to a wrapper around a custom streamer member function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TStreamerElement.h:16,wrap,wrapper,16,core/meta/inc/TStreamerElement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TStreamerElement.h,1,['wrap'],['wrapper']
Integrability,"//!iterator in messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TStatus.h:15,message,messages,15,proof/proofplayer/inc/TStatus.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TStatus.h,1,['message'],['messages']
Integrability,"//""Unknown integration type"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx:11,integrat,integration,11,math/mathmore/src/GSLIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx,1,['integrat'],['integration']
Integrability,"//#define DEBUG; // if I use double32 or not depends on the dictionary; ////#define USE_DOUBLE32",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/testIO.cxx:45,depend,depends,45,math/smatrix/test/testIO.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/testIO.cxx,1,['depend'],['depends']
Integrability,"//******************************************************************************; ////////////////////////////////////////////////////////////////////////////////; /// Set visualization-parameter model element.; /// Calling of this function from outside of EVE should in principle; /// be avoided as it can lead to dis-synchronization of viz-tag and; /// viz-model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx:319,synchroniz,synchronization,319,graf3d/eve/src/TEveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx,1,['synchroniz'],['synchronization']
Integrability,"//*-*- IF NAA .EQ. -1 , PROGRAM USES BWID INPUT FROM CALLING ROUTINE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/mnbins.cxx:61,ROUT,ROUTINE,61,math/minuit2/src/mnbins.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/mnbins.cxx,1,['ROUT'],['ROUTINE']
Integrability,"//- C-linkage wrappers -------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:14,wrap,wrappers,14,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['wrap'],['wrappers']
Integrability,"//- WebAssemblyISelLowering.h - WebAssembly DAG Lowering Interface -*- C++ -*-//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interfaces that WebAssembly uses to lower LLVM; /// code into a selection DAG.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.h:57,Interface,Interface,57,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.h,2,"['Interface', 'interface']","['Interface', 'interfaces']"
Integrability,"//- X86Insertwait.cpp - Strict-Fp:Insert wait instruction X87 instructions --//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the pass which insert x86 wait instructions after each; // X87 instructions when strict float is enabled.; //; // The logic to insert a wait instruction after an X87 instruction is as below:; // 1. If the X87 instruction don't raise float exception nor is a load/store; // instruction, or is a x87 control instruction, don't insert wait.; // 2. If the X87 instruction is an instruction which the following instruction; // is an X87 exception synchronizing X87 instruction, don't insert wait.; // 3. For other situations, insert wait instruction.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp:842,synchroniz,synchronizing,842,interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp,1,['synchroniz'],['synchronizing']
Integrability,"//- class that has an STL-like interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/stltypes.h:31,interface,interface,31,bindings/pyroot/cppyy/cppyy/test/stltypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/stltypes.h,1,['interface'],['interface']
Integrability,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:53,Interface,Interface,53,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,1,['Interface'],['Interface']
Integrability,"//--- Machine specific routines ------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:23,rout,routines,23,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['rout'],['routines']
Integrability,"//--- file management interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileMerger.h:22,interface,interface,22,io/io/inc/TFileMerger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileMerger.h,1,['interface'],['interface']
Integrability,"//--- file merging interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileMerger.h:19,interface,interface,19,io/io/inc/TFileMerger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileMerger.h,1,['interface'],['interface']
Integrability,"//---- RPC ---------------------------------------------------------------------; ////////////////////////////////////////////////////////////////////////////////; /// Get Internet Protocol (IP) address of host.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:181,Protocol,Protocol,181,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['Protocol'],['Protocol']
Integrability,"//---- make the message box non-resizable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGColorDialog.cxx:16,message,message,16,gui/gui/src/TGColorDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGColorDialog.cxx,2,['message'],['message']
Integrability,"//----- Input handler for messages from TProofServ -----------------------------; ////////////////////////////////////////////////////////////////////////////////; /// Constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:26,message,messages,26,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['message'],['messages']
Integrability,"//----- Input handler for messages from client -----------------------; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:26,message,messages,26,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,1,['message'],['messages']
Integrability,"//----- Input handler for messages from parent or master -----------------------; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:26,message,messages,26,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,2,['message'],['messages']
Integrability,"//-------- GRAD functions---------------------------; //___________________________________________________________________________________; /**; Interface (abstract class) for multi-dimensional functions providing a gradient calculation.; The method ROOT::Math::IFunction::Gradient calculates the full gradient vector,; ROOT::Math::IFunction::Derivative calculates the partial derivative for each coordinate and; ROOT::Math::Fdf calculates the gradient and the function value at the same time.; The pure private virtual method DoDerivative() must be implemented by the derived classes, while; Gradient and FdF are by default implemented using DoDerivative, butthey can be overloaded by the; derived classes to improve the efficiency in the derivative calculation. Gradient interface (abstract class) defining the signature for calculating the gradient of a; multi-dimensional function.; Three methods are provided:; - Gradient(const double *x, double * grad) evaluate the full gradient vector at the vector value x; - Derivative(const double * x, int icoord) evaluate the partial derivative for the icoord coordinate; - FdF(const double *x, double &f, double * g) evaluate at the same time gradient and function/. @ingroup GenFunc; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h:146,Interface,Interface,146,math/mathcore/inc/Math/IFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h,2,"['Interface', 'interface']","['Interface', 'interface']"
Integrability,"//-------- Names of next three routines are a small homage to CMZ --------------; ////////////////////////////////////////////////////////////////////////////////; /// Return version id as an integer, i.e. ""2.22/04"" -> 22204.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:31,rout,routines,31,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['rout'],['routines']
Integrability,"//--------------------------------------------------------------------*- C++ -*-; // CLING - the C++ LLVM-based InterpreterG :); // author: Guilherme Amadio <amadio@cern.ch>; //; // This file is dual-licensed: you can choose to license it under the University; // of Illinois Open Source License or the GNU Lesser General Public License. See; // LICENSE.TXT for details.; //------------------------------------------------------------------------------; //; // This file implements a JITEventListener object that tells perf about JITted; // symbols using perf map files (/tmp/perf-%d.map, where %d = pid of process).; //; // Documentation for this perf jit interface is available at:; // https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/tools/perf/Documentation/jit-interface.txt; //; //------------------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/PerfJITEventListener.cpp:657,interface,interface,657,interpreter/cling/lib/Interpreter/PerfJITEventListener.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/PerfJITEventListener.cpp,2,['interface'],['interface']
Integrability,"//------------------------------------------------------------------------------; // Builder functions of this class are called by EveScene to create RCore; // objects representing an EveElement. They can have children if multiple RCore; // objects are required (e.g., mesh + lines + points).; //; // The top-level object returned by these builder functions will get additional; // properties injected by EveScene:; // - eve_el; // - scene.; //; // Object picking functions in GlViewerRCore will navigate up the parent hierarchy; // until an object with eve_el property is set.; // If secondary selection is enabled on the eve_el, instance picking will be called; // as well and the returned ID will be used as the index for secondary selection.; // This can be overriden by setting get_ctrl property of any RCore object to a function; // that takes a reference to the said argument and returns an instance of class; // EveElemControl.; // get_ctrl property needs to be set at least at the top-level object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveElementsRCore.js:393,inject,injected,393,ui5/eve7/lib/EveElementsRCore.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveElementsRCore.js,1,['inject'],['injected']
Integrability,//------------------------------------------------------------------------------; // WinCOFFObjectWriter class implementation; ////////////////////////////////////////////////////////////////////////////////; // MCObjectWriter interface implementations,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WinCOFFObjectWriter.cpp:227,interface,interface,227,interpreter/llvm-project/llvm/lib/MC/WinCOFFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WinCOFFObjectWriter.cpp,1,['interface'],['interface']
Integrability,//-----------------------------------------------------------------------------; // C Interface Routines; //-----------------------------------------------------------------------------,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:86,Interface,Interface,86,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,2,"['Interface', 'Rout']","['Interface', 'Routines']"
Integrability,"//---------------------------------------------------------------------------//; // AMD Kernel Code, and its dependencies //; //---------------------------------------------------------------------------//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:109,depend,dependencies,109,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['depend'],['dependencies']
Integrability,"//---------------------------------------------------------------------------; // Adapter class used to handle streaming collection of pointers; //---------------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TStreamerInfo.h:82,Adapter,Adapter,82,io/io/inc/TStreamerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TStreamerInfo.h,1,['Adapter'],['Adapter']
Integrability,//---------------------------------------------------------------------------; /// Interface to description of machine instruction set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrInfo.h:83,Interface,Interface,83,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrInfo.h,1,['Interface'],['Interface']
Integrability,//---------------------------------------------------------------------------; ///; /// TargetInstrInfo - Interface to description of machine instruction set; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:106,Interface,Interface,106,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['Interface'],['Interface']
Integrability,//---------------------------------------------------------------------------; ///; /// TargetIntrinsicInfo - Interface to description of machine instruction set; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetIntrinsicInfo.h:110,Interface,Interface,110,interpreter/llvm-project/llvm/include/llvm/Target/TargetIntrinsicInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetIntrinsicInfo.h,1,['Interface'],['Interface']
Integrability,"//-------------------------------------------------------------------; /// \cond ROOFIT_INTERNAL; // register integrator class; // create a derived class in order to call the protected method of the; // RoodaptiveGaussKronrodIntegrator1D",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx:110,integrat,integrator,110,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,1,['integrat'],['integrator']
Integrability,"//-------------------------------------------------------------------; //; // importFromFile(const char *filename); //; // Imports histogrammes from a file with the name ""filename"".; // Opens the file, scans it, if finds an object of the class TH1F or TH2F,; // imports it.; // All the other objects are ignored.; // In case of not a ROOT file returns an error message and takes no further; // action.; // This function is called when a user doubly clicks on the file icon; // in the file list view.; //; //--------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/histaction.cxx:361,message,message,361,test/histviewer/histaction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/histaction.cxx,1,['message'],['message']
Integrability,"//-------------------------------------------------------; //; // A small panel destined to provide graphical interface; // for ""Canvas Save"" action; //; // Author: Dmitry Vasiliev (LNS, Catania); //; //-------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/canvsave.h:110,interface,interface,110,test/histviewer/canvsave.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/canvsave.h,1,['interface'],['interface']
Integrability,"//----------------------------------------------------; //; // A small panel destined to provide graphical interface; // for ""Canvas Save"" action; //; // Author: Dmitry Vasiliev (LNS, Catania); //; //----------------------------------------------------; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/canvsave.cxx:107,interface,interface,107,test/histviewer/canvsave.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/canvsave.cxx,1,['interface'],['interface']
Integrability,//--------------------------------------------------; // This collection of wrappers is the intermediary between class opt and class; // parser to handle all the template nastiness.; // This overloaded function is selected by the generic parser.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:76,wrap,wrappers,76,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['wrap'],['wrappers']
Integrability,"/// ""Arrange"" the LLVM information for a call or type with the given; /// signature. This is largely an internal method; other clients; /// should use one of the above routines, which ultimately defer to; /// this.; ///; /// \param argTypes - must all actually be canonical as params",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.h:168,rout,routines,168,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.h,1,['rout'],['routines']
Integrability,"/// ""Clamp"" this state with \p R. The result is subtype dependent but it is; /// intended that information known in either state will be known in; /// this one afterwards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:56,depend,dependent,56,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['depend'],['dependent']
Integrability,"/// ""Clamp"" this state with \p R. The result is subtype dependent but it is; /// intended that only information assumed in both states will be assumed in; /// this one afterwards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:56,depend,dependent,56,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,2,['depend'],['dependent']
Integrability,"/// ""Forget"" about the partially-substituted pack template argument,; /// when performing an instantiation that must preserve the parameter pack; /// use.; ///; /// This routine is meant to be overridden by the template instantiator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:170,rout,routine,170,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// ""Remember"" the partially-substituted pack template argument; /// after performing an instantiation that must preserve the parameter pack; /// use.; ///; /// This routine is meant to be overridden by the template instantiator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:166,rout,routine,166,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// ""\#pragma clang deprecated(...)""; ///; /// The syntax is; /// \code; /// #pragma clang deprecate(MACRO_NAME [, Message]); /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:115,Message,Message,115,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['Message'],['Message']
Integrability,"/// ""\#pragma clang restrict_expansion(...)""; ///; /// The syntax is; /// \code; /// #pragma clang restrict_expansion(MACRO_NAME [, Message]); /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:132,Message,Message,132,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['Message'],['Message']
Integrability,"/// 'bind' clause, allowed on routine constructs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h:30,rout,routine,30,interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h,1,['rout'],['routine']
Integrability,"/// 'device_type' clause, allowed on Constructs, 'data', 'init', 'shutdown',; /// 'set', update', 'loop', 'routine', and Combined constructs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h:107,rout,routine,107,interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h,1,['rout'],['routine']
Integrability,"/// 'nohost' clause, allowed on 'routine' directives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h:33,rout,routine,33,interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h,1,['rout'],['routine']
Integrability,"/// 'seq' clause, allowed on 'loop' and 'routine' directives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h:41,rout,routine,41,interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h,1,['rout'],['routine']
Integrability,"/// 'vector' clause, allowed on 'loop', Combined, and 'routine' directives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h:55,rout,routine,55,interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h,1,['rout'],['routine']
Integrability,"/// 'worker' clause, allowed on 'loop', Combined, and 'routine' directives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h:55,rout,routine,55,interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenACCKinds.h,1,['rout'],['routine']
Integrability,"/// ******************************************************************; /// * *; /// * Runge-Kutta method for tracking a particle through a magnetic *; /// * field. Uses Nystroem algorithm (See Handbook Nat. Bur. of *; /// * Standards, procedure 25.5.20) *; /// * *; /// * Input parameters *; /// * CHARGE Particle charge *; /// * STEP Step size *; /// * VECT Initial co-ords,direction cosines,momentum *; /// * Output parameters *; /// * VOUT Output co-ords,direction cosines,momentum *; /// * User routine called *; /// * CALL GUFLD(X,F) *; /// * *; /// * ==>Called by : <USER>, GUSWIM *; /// * Authors R.Brun, M.Hansroul ********* *; /// * V.Perevoztchikov (CUT STEP implementation) *; /// * *; /// * *; /// ******************************************************************",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrackPropagator.cxx:500,rout,routine,500,graf3d/eve/src/TEveTrackPropagator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrackPropagator.cxx,2,['rout'],['routine']
Integrability,/// - Rewrite message expression for Objective-C setter and getters into; /// property-dot syntax.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:14,message,message,14,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,1,['message'],['message']
Integrability,"/// ::= .loh <lohName | lohId> label1, ..., labelN; /// The number of arguments depends on the loh identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:80,depend,depends,80,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['depend'],['depends']
Integrability,"/// <clause> [clause[ [,] clause] ... ]; ///; /// clauses: for error directive; /// 'at' '(' compilation | execution ')'; /// 'severity' '(' fatal | warning ')'; /// 'message' '(' msg-string ')'; /// ....",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:167,message,message,167,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,1,['message'],['message']
Integrability,"/// <summary>; /// Creates a new enumeration object in the same state as the current; /// enumeration object: the new object points to the same place in the; /// enumeration sequence.; /// </summary>; /// <param name=""ppenum"">A pointer to a pointer to a new <see; /// cref=""IEnumSetupInstances""/> interface. If the method fails, this; /// parameter is undefined.</param>; /// <returns>S_OK if a clone was returned; otherwise, E_OUTOFMEMORY.</returns>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:297,interface,interface,297,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,1,['interface'],['interface']
Integrability,"/// <summary>; /// Helper functions.; /// </summary>; /// <remarks>; /// You can query for this interface from the <see cref=""SetupConfiguration""/>; /// class.; /// </remarks>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:96,interface,interface,96,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,1,['interface'],['interface']
Integrability,"/// @brief A class to manage loop scopes using the RAII technique. To wrap your code around a loop,; /// simply place it between a brace inclosed scope with a call to beginLoop at the top. For e.g.; /// {; /// auto scope = ctx.beginLoop({<-set of vector observables to loop over->});; /// // your loop body code goes here.; /// }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h:70,wrap,wrap,70,roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h,1,['wrap'],['wrap']
Integrability,"/// @brief A function to save an expression that includes/depends on the result of the input node.; /// @param in The node on which the valueToSave depends on/belongs to.; /// @param valueToSave The actual string value to save as a temporary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx:58,depend,depends,58,roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx,2,['depend'],['depends']
Integrability,"/// @brief A variation of the previous addToCodeBody that takes in a bool value that determines; /// if input is independent. This overload exists because there might other ways to determine if; /// a value/collection of values is scope independent.; /// @param in String to add to the squashed code.; /// @param isScopeIndep The value determining if the input is scope dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx:370,depend,dependent,370,roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx,1,['depend'],['dependent']
Integrability,"/// @brief A wrapper class to store a C++ function of type 'double (*)(double*, double*)'.; /// The parameters can be accessed as params[<relative position of param in paramSet>] in the function body.; /// The observables can be accessed as obs[i + j], where i represents the observable position and j; /// represents the data entry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFuncWrapper.h:13,wrap,wrapper,13,roofit/roofitcore/inc/RooFuncWrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFuncWrapper.h,1,['wrap'],['wrapper']
Integrability,"/// @brief Create a RAII scope for iterating over vector observables. You can't use the result of vector observables; /// outside these loop scopes.; /// @param in A pointer to the calling class, used to determine the loop dependent variables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx:223,depend,dependent,223,roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx,1,['depend'],['dependent']
Integrability,"/// @brief Figure out the output size of a node. It is the size of the; /// vector observable that it depends on, or 1 if it doesn't depend on any; /// or is a reducer node.; /// @param key The node to look up the size for.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h:102,depend,depends,102,roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h,2,['depend'],"['depend', 'depends']"
Integrability,"/// @brief Function to calculate the integral of an un-normalized RooGaussian over x. To calculate the integral over; /// mean, just interchange the respective values of x and mean.; /// @param xMin Minimum value of variable to integrate wrt.; /// @param xMax Maximum value of of variable to integrate wrt.; /// @param mean Mean.; /// @param sigma Sigma.; /// @return The integral of an un-normalized RooGaussian over the value in x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h:228,integrat,integrate,228,roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,2,['integrat'],['integrate']
Integrability,"/// @brief Return false and print error messages if there is any unexpected; /// duplicates BIT constant in the class hierarchy or any of the bits; /// already registered.; /// If verbose is true, also print all the bit declare in this class; /// and all its bases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStatusBitsChecker.cxx:40,message,messages,40,core/meta/src/TStatusBitsChecker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStatusBitsChecker.cxx,1,['message'],['messages']
Integrability,"/// @brief Stores code that eventually gets injected into main code body.; /// Mainly used for placing decls outside of loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h:44,inject,injected,44,roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h,1,['inject'],['injected']
Integrability,"/// @brief TRangeStaticCast is an adapter class that allows the typed iteration; /// through a TCollection. This requires the collection to contain elements; /// of the type requested (or a derived class). Any deviation from this expectation; /// will only be caught/reported by an assert in debug builds.; ///; /// This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; ///; /// The typical use is:; /// ```{.cpp}; /// for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; /// ... use bcl as a TBaseClass*; /// }; /// for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; /// ... use bcl as a TBaseClass*; /// }; /// ```; /// \tparam T The new type to convert to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h:34,adapter,adapter,34,core/cont/inc/TCollection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h,1,['adapter'],['adapter']
Integrability,/// @file EveManager.js; /// used only together with OpenUI5; // TODO: add dependency from JSROOT components,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveManager.js:75,depend,dependency,75,ui5/eve7/lib/EveManager.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveManager.js,1,['depend'],['dependency']
Integrability,/// @file EveScene.js; // TODO: add dependency from JSROOT components,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveScene.js:36,depend,dependency,36,ui5/eve7/lib/EveScene.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveScene.js,1,['depend'],['dependency']
Integrability,/// @name ExecutionEngine interface implementation; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:26,interface,interface,26,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,1,['interface'],['interface']
Integrability,/// @name File Creation Interface; /// @{; /// Create a file to print a coverage view into.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h:24,Interface,Interface,24,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,1,['Interface'],['Interface']
Integrability,/// @name FunctionPass interface; //@{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:23,interface,interface,23,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,1,['interface'],['interface']
Integrability,"/// @name Helpers; /// @{; ///\brief Interface with nice name, forwarding to Visit.; ///; ///\param[in] MD - The MacroDirectiveInfo containing the IdentifierInfo and; /// MacroDirective to forward.; ///\returns true on success.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.h:37,Interface,Interface,37,interpreter/cling/lib/Interpreter/DeclUnloader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.h,1,['Interface'],['Interface']
Integrability,"/// @name High-Level Operations; /// @{; /// ExecuteAction - Execute the provided action against the compiler's; /// CompilerInvocation object.; ///; /// This function makes the following assumptions:; ///; /// - The invocation options should be initialized. This function does not; /// handle the '-help' or '-version' options, clients should handle those; /// directly.; ///; /// - The diagnostics engine should have already been created by the client.; ///; /// - No other CompilerInstance state should have been initialized (this is; /// an unchecked error).; ///; /// - Clients should have initialized any LLVM target features that may be; /// required.; ///; /// - Clients should eventually call llvm_shutdown() upon the completion of; /// this routine to ensure that any managed objects are properly destroyed.; ///; /// Note that this routine may write output to 'stderr'.; ///; /// \param Act - The action to execute.; /// \return - True on success.; //; // FIXME: Eliminate the llvm_shutdown requirement, that should either be part; // of the context or else not CompilerInstance specific.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h:751,rout,routine,751,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,2,['rout'],['routine']
Integrability,"/// @name Implementation Action Interface; /// @{; /// Prepare to execute the action on the given CompilerInstance.; ///; /// This is called before executing the action on any inputs, and can modify; /// the configuration as needed (including adjusting the input list).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h:32,Interface,Interface,32,interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,1,['Interface'],['Interface']
Integrability,/// @name MCAsmParser Interface; /// {,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:22,Interface,Interface,22,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['Interface'],['Interface']
Integrability,/// @name MCStreamer Interface; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:21,Interface,Interface,21,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,3,['Interface'],['Interface']
Integrability,/// @name MachineFunctionPass interface; //@{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegionInfo.h:30,interface,interface,30,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegionInfo.h,1,['interface'],['interface']
Integrability,/// @name Rendering Interface; /// @{; /// Render a header for the view.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h:20,Interface,Interface,20,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,1,['Interface'],['Interface']
Integrability,/// @name Status interface from llvm::sys::fs; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h:17,interface,interface,17,interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,1,['interface'],['interface']
Integrability,/// @name Target Relaxation Interfaces; /// @{; /// fixupNeedsRelaxation - Target specific predicate for whether a given; /// fixup requires the associated instruction to be relaxed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.h:28,Interface,Interfaces,28,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.h,1,['Interface'],['Interfaces']
Integrability,/// @returns true if class is dynamic or might be dynamic because the; /// definition is incomplete of dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:103,depend,dependent,103,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['depend'],['dependent']
Integrability,/// @returns true if class is non dynamic or might be non dynamic because the; /// definition is incomplete of dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:111,depend,dependent,111,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['depend'],['dependent']
Integrability,"/// @{; /// @name Helpers, which simplify node replacement; ///\brief Replaces given dependent AST node with an instantiation of; /// EvaluateT with the deduced type.; ///; /// @param[in] InstTy The deduced type used to create instantiation.; /// @param[in] SubTree The AST node or subtree, which is being replaced.; /// @param[in] ValuePrinterReq Whether to turn on the value printing or not; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.h:85,depend,dependent,85,interpreter/cling/lib/Interpreter/DynamicLookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.h,1,['depend'],['dependent']
Integrability,/// @}; /// @name (Private) Registration Interfaces; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:41,Interface,Interfaces,41,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,1,['Interface'],['Interfaces']
Integrability,"/// @}; /// @name Construction Utility Methods; /// @{; /// Create the diagnostics engine using the invocation's diagnostic options; /// and replace any existing one with it.; ///; /// Note that this routine also replaces the diagnostic client,; /// allocating one if one is not provided.; ///; /// \param Client If non-NULL, a diagnostic client that will be; /// attached to (and, then, owned by) the DiagnosticsEngine inside this AST; /// unit.; ///; /// \param ShouldOwnClient If Client is non-NULL, specifies whether; /// the diagnostic object should take ownership of the client.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h:200,rout,routine,200,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,1,['rout'],['routine']
Integrability,"/// @}; /// @name Function Accessors; /// @{; /// Look up the specified function in the module symbol table. Four; /// possibilities:; /// 1. If it does not exist, add a prototype for the function and return it.; /// 2. Otherwise, if the existing function has the correct prototype, return; /// the existing function.; /// 3. Finally, the function exists but has the wrong prototype: return the; /// function with a constantexpr cast to the right prototype.; ///; /// In all cases, the returned value is a FunctionCallee wrapper around the; /// 'FunctionType *T' passed in, as well as a 'Value*' either of the Function or; /// the bitcast to the function.; ///; /// Note: For library calls getOrInsertLibFunc() should be used instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:521,wrap,wrapper,521,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['wrap'],['wrapper']
Integrability,/// @}; /// @name Public Action Interface; /// @{; /// Prepare the action to execute on the given compiler instance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h:32,Interface,Interface,32,interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,1,['Interface'],['Interface']
Integrability,"/// @}; /// Adds a matcher to execute when running over the AST.; ///; /// This is similar to \c addMatcher(), but it uses the dynamic interface. It; /// is more flexible, but the lost type information enables a caller to pass; /// a matcher that cannot match anything.; ///; /// \returns \c true if the matcher is a valid top-level matcher, \c false; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchFinder.h:135,interface,interface,135,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchFinder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchFinder.h,1,['interface'],['interface']
Integrability,"/// @}; /// Create a ConstantFPSDNode wrapping a constant value.; /// If VT is a vector type, the constant is splatted into a BUILD_VECTOR.; ///; /// If only legal types can be produced, this does the necessary; /// transformations (e.g., if the vector element type is illegal).; /// The forms that take a double should only be used for simple constants; /// that can be exactly represented in VT. No checks are made.; /// @{",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:38,wrap,wrapping,38,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['wrap'],['wrapping']
Integrability,/// @}; /// The wrapped syntactic loop statement (ForStmt or CXXForRangeStmt).; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:16,wrap,wrapped,16,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,1,['wrap'],['wrapped']
Integrability,/// @}; /// This is a simple wrapper around an MDNode which provides a; /// higher-level interface by hiding the details of how alias analysis; /// information is encoded in its operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:29,wrap,wrapper,29,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,4,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,/// @}; /// \name Target Relaxation Interfaces; /// @{; /// Check whether the given instruction may need relaxation.; ///; /// \param Inst - The instruction to test.; /// \param STI - The MCSubtargetInfo in effect when the instruction was; /// encoded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmBackend.h:36,Interface,Interfaces,36,interpreter/llvm-project/llvm/include/llvm/MC/MCAsmBackend.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmBackend.h,1,['Interface'],['Interfaces']
Integrability,"/// @}; //===--------------------------------------------------------------------===//; // Accessors used to build up machine instructions.; /// Add the specified operand to the instruction. If it is an implicit; /// operand, it is added to the end of the operand list. If it is an; /// explicit operand it is added at the end of the explicit operand list; /// (before the first implicit operand).; ///; /// MF must be the machine function that was used to allocate this; /// instruction.; ///; /// MachineInstrBuilder provides a more convenient interface for creating; /// instructions and adding operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:546,interface,interface,546,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['interface'],['interface']
Integrability,"/// A ""must be executed context"" for a given program point PP is the set of; /// instructions, potentially before and after PP, that are executed always when; /// PP is reached. The MustBeExecutedContextExplorer an interface to explore; /// ""must be executed contexts"" in a module through the use of; /// MustBeExecutedIterator.; ///; /// The explorer exposes ""must be executed iterators"" that traverse the must be; /// executed context. There is little information sharing between iterators as; /// the expected use case involves few iterators for ""far apart"" instructions.; /// If that changes, we should consider caching more intermediate results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:215,interface,interface,215,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['interface'],['interface']
Integrability,"/// A (possibly-)qualified type.; ///; /// For efficiency, we don't store CV-qualified types as nodes on their; /// own: instead each reference to a type stores the qualifiers. This; /// greatly reduces the number of nodes we need to allocate for types (for; /// example we only need one for 'int', 'const int', 'volatile int',; /// 'const volatile int', etc).; ///; /// As an added efficiency bonus, instead of making this a pair, we; /// just store the two bits we care about in the low bits of the; /// pointer. To handle the packing/unpacking, we make QualType be a; /// simple wrapper class that acts like a smart pointer. A third bit; /// indicates whether there are extended qualifiers present, in which; /// case the pointer points to a special structure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:582,wrap,wrapper,582,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['wrap'],['wrapper']
Integrability,/// A 16-bit slice of the target address (which slice depends on the; /// instruction at the fixup location).; ///; /// Used to fix up MOVK/MOVN/MOVZ instructions.; ///; /// Fixup expression:; ///; /// Fixup <- (Target + Addend) >> Shift : uint16; ///; /// where Shift is encoded in the instruction at the fixup location.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h:54,depend,depends,54,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h,1,['depend'],['depends']
Integrability,/// A Clang invocation that's based on the original TU invocation and that has; /// been partially transformed into one that can perform explicit build of; /// a discovered modular dependency. Note that this still needs to be adjusted; /// for each individual module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:181,depend,dependency,181,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,1,['depend'],['dependency']
Integrability,/// A IdDeclInfo::DeclsTy::iterator that walks or not the parent declaration; /// contexts depending on 'LookInParentCtx'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/IdentifierResolver.h:91,depend,depending,91,interpreter/llvm-project/clang/include/clang/Sema/IdentifierResolver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/IdentifierResolver.h,1,['depend'],['depending']
Integrability,"/// A Module instance is used to store all the information related to an; /// LLVM module. Modules are the top level container of all other LLVM; /// Intermediate Representation (IR) objects. Each module directly contains a; /// list of globals variables, a list of functions, a list of libraries (or; /// other modules) this module depends on, a symbol table, and various data; /// about the target's characteristics.; ///; /// A module maintains a GlobalList object that is used to hold all; /// constant references to global variables in the module. When a global; /// variable is destroyed, it should have no entries in the GlobalList.; /// The main container class for the LLVM Intermediate Representation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:333,depend,depends,333,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['depend'],['depends']
Integrability,"/// A PCHContainerReader implementation that uses LLVM to; /// wraps Clang modules inside a COFF, ELF, or Mach-O container.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ObjectFilePCHContainerOperations.h:63,wrap,wraps,63,interpreter/llvm-project/clang/include/clang/CodeGen/ObjectFilePCHContainerOperations.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ObjectFilePCHContainerOperations.h,1,['wrap'],['wraps']
Integrability,"/// A PCHContainerWriter implementation that uses LLVM to; /// wraps Clang modules inside a COFF, ELF, or Mach-O container.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ObjectFilePCHContainerOperations.h:63,wrap,wraps,63,interpreter/llvm-project/clang/include/clang/CodeGen/ObjectFilePCHContainerOperations.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ObjectFilePCHContainerOperations.h,1,['wrap'],['wraps']
Integrability,"/// A RAII object that creates a link upon initialization and; /// removes it upon destruction.; ///; /// The link may be a soft or a hard link, depending on the platform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Testing/Support/SupportHelpers.h:145,depend,depending,145,interpreter/llvm-project/llvm/include/llvm/Testing/Support/SupportHelpers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Testing/Support/SupportHelpers.h,1,['depend'],['depending']
Integrability,"/// A RooAbsReal::Ref can be constructed from a `RooAbsReal&` or a `double`; /// that will be implicitly converted to a RooConstVar&. The RooAbsReal::Ref; /// can be used as a replacement for `RooAbsReal&`. With this type; /// definition, you can write RooFit interfaces that accept both RooAbsReal,; /// or simply a number that will be implicitly converted to a RooConstVar&.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:260,interface,interfaces,260,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['interface'],['interfaces']
Integrability,"/// A RooProdPdf with a fixed normalization set can be replaced by this class.; /// Its purpose is to provide the right client-server interface for the; /// evaluation of RooProdPdf cache elements that were created for a given; /// normalization set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:134,interface,interface,134,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['interface'],['interface']
Integrability,"/// A SARIF rule (\c reportingDescriptor object) contains information that; /// describes a reporting item generated by a tool. A reporting item is; /// either a result of analysis or notification of a condition encountered by; /// the tool. Rules are arbitrary but are identifiable by a hierarchical; /// rule-id.; ///; /// This builder provides an interface to create SARIF \c reportingDescriptor; /// objects via the \ref SarifRule::create static method.; ///; /// Reference:; /// 1. <a href=""https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317836"">reportingDescriptor object</a>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sarif.h:350,interface,interface,350,interpreter/llvm-project/clang/include/clang/Basic/Sarif.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sarif.h,1,['interface'],['interface']
Integrability,"/// A TObject-derived class to inject the memory regulation logic in the ROOT list of cleanups.; ///; /// The purpose of this class is to keep the responsibilities separate between; /// the TMemoryRegulator logic and the rest of ROOT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TMemoryRegulator.h:31,inject,inject,31,bindings/pyroot/pythonizations/src/TMemoryRegulator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TMemoryRegulator.h,1,['inject'],['inject']
Integrability,"/// A base class for data structure classes wishing to make iterators; /// (""handles"") pointing into themselves fail-fast. When building without; /// asserts, this class is empty and does nothing.; ///; /// DebugEpochBase does not by itself track handles pointing into itself. The; /// expectation is that routines touching the handles will poll on; /// isHandleInSync at appropriate points to assert that the handle they're using; /// is still valid.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h:306,rout,routines,306,interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h,1,['rout'],['routines']
Integrability,"/// A base class for iterator classes (""handles"") that wish to poll for; /// iterator invalidating modifications in the underlying data structure.; /// When LLVM is built without asserts, this class is empty and does nothing.; ///; /// HandleBase does not track the parent data structure by itself. It expects; /// the routines modifying the data structure to call incrementEpoch when they; /// make an iterator-invalidating modification.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h:319,rout,routines,319,interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h,1,['rout'],['routines']
Integrability,/// A base class holding non-template-dependant functionality of the AccelTable; /// class. Clients should not use this class directly but rather instantiate; /// AccelTable with a type derived from AccelTableData.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:38,depend,dependant,38,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,1,['depend'],['dependant']
Integrability,"/// A base class to help implement the function alias analysis results concept.; ///; /// Because of the nature of many alias analysis implementations, they often; /// only implement a subset of the interface. This base class will attempt to; /// implement the remaining portions of the interface in terms of simpler forms; /// of the interface where possible, and otherwise provide conservatively; /// correct fallback implementations.; ///; /// Implementors of an alias analysis should derive from this class, and then; /// override specific methods that they wish to customize. There is no need to; /// use virtual anywhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:199,interface,interface,199,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,3,['interface'],['interface']
Integrability,"/// A builtin binary operation expression such as ""x + y"" or ""x <= y"".; ///; /// This expression node kind describes a builtin binary operation,; /// such as ""x + y"" for integer values ""x"" and ""y"". The operands will; /// already have been converted to appropriate types (e.g., by; /// performing promotions or conversions).; ///; /// In C++, where operators may be overloaded, a different kind of; /// expression node (CXXOperatorCallExpr) is used to express the; /// invocation of an overloaded operator with operator syntax. Within; /// a C++ template, whether BinaryOperator or CXXOperatorCallExpr is; /// used to store an expression ""x + y"" depends on the subexpressions; /// for x and y. If neither x or y is type-dependent, and the ""+""; /// operator resolves to a built-in operation, BinaryOperator will be; /// used to express the computation (x and y may still be; /// value-dependent). If either x or y is type-dependent, or if the; /// ""+"" resolves to an overloaded operator, CXXOperatorCallExpr will; /// be used to express the computation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:645,depend,depends,645,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,4,['depend'],"['dependent', 'depends']"
Integrability,"/// A call may be vectorized in different ways depending on whether we have; /// vectorized variants available and whether the target supports masking.; /// This function analyzes all calls in the function at the supplied VF,; /// makes a decision based on the costs of available options, and stores that; /// decision in a map for use in planning and plan execution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:47,depend,depending,47,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['depend'],['depending']
Integrability,"/// A call to a literal operator (C++11 [over.literal]); /// written as a user-defined literal (C++11 [lit.ext]).; ///; /// Represents a user-defined literal, e.g. ""foo""_bar or 1.23_xyz. While this; /// is semantically equivalent to a normal call, this AST node provides better; /// information about the syntactic representation of the literal.; ///; /// Since literal operators are never found by ADL and can only be declared at; /// namespace scope, a user-defined literal is never dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:485,depend,dependent,485,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['depend'],['dependent']
Integrability,/// A check failed (with values to print).; ///; /// This calls the Message-only version so that the above is easier to set a; /// breakpoint on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:68,Message,Message-only,68,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['Message'],['Message-only']
Integrability,/// A check failed (with values to print).; ///; /// This calls the Message-only version so that the above is easier to set; /// a breakpoint on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:68,Message,Message-only,68,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,1,['Message'],['Message-only']
Integrability,"/// A check failed, so printout out the condition and the message.; ///; /// This provides a nice place to put a breakpoint if you want to see why; /// something is not correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:58,message,message,58,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,2,['message'],['message']
Integrability,/// A clang tool that runs the preprocessor in a mode that's optimized for; /// dependency scanning for the given compiler invocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:80,depend,dependency,80,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,1,['depend'],['dependency']
Integrability,/// A class for storing results from argument-dependent lookup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:46,depend,dependent,46,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['depend'],['dependent']
Integrability,/// A class that wrap the SHA1 algorithm.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SHA1.h:17,wrap,wrap,17,interpreter/llvm-project/llvm/include/llvm/Support/SHA1.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SHA1.h,1,['wrap'],['wrap']
Integrability,/// A class that wraps MachineInstrs and derives from FoldingSetNode in order to; /// be uniqued in a CSEMap. The tradeoff here is extra memory allocations for; /// UniqueMachineInstr vs making MachineInstr bigger.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:17,wrap,wraps,17,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,1,['wrap'],['wraps']
Integrability,/// A class that wraps the BLAKE3 algorithm.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BLAKE3.h:17,wrap,wraps,17,interpreter/llvm-project/llvm/include/llvm/Support/BLAKE3.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BLAKE3.h,1,['wrap'],['wraps']
Integrability,/// A code coverage view of a source file or function.; ///; /// A source coverage view and its nested sub-views form a file-oriented; /// representation of code coverage data. This view can be printed out by a; /// renderer which implements the Rendering Interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h:256,Interface,Interface,256,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,1,['Interface'],['Interface']
Integrability,"/// A collection of absolute paths to files that this module directly depends; /// on, not including transitive dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:70,depend,depends,70,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,2,['depend'],"['dependencies', 'depends']"
Integrability,"/// A collection of absolute paths to files that this translation unit; /// directly depends on, not including transitive dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:85,depend,depends,85,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,2,['depend'],"['dependencies', 'depends']"
Integrability,/// A collection of legacy interfaces for querying information about the; /// current executing process.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h:27,interface,interfaces,27,interpreter/llvm-project/llvm/include/llvm/Support/Process.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h,1,['interface'],['interfaces']
Integrability,"/// A collection of prebuilt modular dependencies this module directly depends; /// on, not including transitive dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:37,depend,dependencies,37,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,3,['depend'],"['dependencies', 'depends']"
Integrability,"/// A collection of prebuilt modules this translation unit directly depends; /// on, not including transitive dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:68,depend,depends,68,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,2,['depend'],"['dependencies', 'depends']"
Integrability,"/// A combiner-aware RAUW-like routine.; ///; /// This method is to be used when an instruction is found to be dead,; /// replaceable with another preexisting expression. Here we add all uses of; /// I to the worklist, replace all uses of I with the new value, then return; /// I, so that the inst combiner will know that I was modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h:31,rout,routine,31,interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,1,['rout'],['routine']
Integrability,/// A command line option to disable the pruning of chain dependences due to; /// an unrelated Phi.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:58,depend,dependences,58,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependences']
Integrability,/// A command line option to disable the pruning of loop carried order; /// dependences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:76,depend,dependences,76,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependences']
Integrability,"/// A command that has zero or more word-like arguments (number of word-like; /// arguments depends on command name) and a paragraph as an argument; /// (e. g., \\brief).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Comment.h:92,depend,depends,92,interpreter/llvm-project/clang/include/clang/AST/Comment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Comment.h,1,['depend'],['depends']
Integrability,/// A common refactoring action rule interface that defines the 'invoke'; /// function that performs the refactoring operation (either fully or; /// partially).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:37,interface,interface,37,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,1,['interface'],['interface']
Integrability,"/// A container of type source information.; ///; /// A client can read the relevant info using TypeLoc wrappers, e.g:; /// @code; /// TypeLoc TL = TypeSourceInfo->getTypeLoc();; /// TL.getBeginLoc().print(OS, SrcMgr);; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:104,wrap,wrappers,104,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['wrap'],['wrappers']
Integrability,"/// A convenience class for comparing CFGElements, since methods of CFGBlock; /// like operator[] return CFGElements by value. This is practically a wrapper; /// around a (CFGBlock, Index) pair.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CFG.h:149,wrap,wrapper,149,interpreter/llvm-project/clang/include/clang/Analysis/CFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CFG.h,1,['wrap'],['wrapper']
Integrability,/// A convenience class for splitting the methods of a protocol into; /// the four interesting groups.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:55,protocol,protocol,55,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['protocol'],['protocol']
Integrability,"/// A convenience helper which handles optional initial options populated from; /// an environment variable, expands response files recursively and parses; /// options.; ///; /// \param ErrorFn - Called on a formatted error message for missing arguments; /// or unknown options.; /// \return An InputArgList; on error this will contain all the options which; /// could be parsed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/OptTable.h:224,message,message,224,interpreter/llvm-project/llvm/include/llvm/Option/OptTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/OptTable.h,1,['message'],['message']
Integrability,/// A convenience routine for creating a decayed reference to a function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:18,rout,routine,18,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['rout'],['routine']
Integrability,/// A convenience wrapper around the \c isMustAlias helper interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,wrap,wrapper,18,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,/// A convenience wrapper around the \c isNoAlias helper interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,wrap,wrapper,18,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,4,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"/// A convenience wrapper around the above to handle trivial cases of; /// inserting a new call edge.; ///; /// This is trivial whenever the target is in the same SCC as the source or; /// the edge is an outgoing edge to some descendant SCC. In these cases; /// there is no change to the cyclic structure of SCCs or RefSCCs.; ///; /// To further make calling this convenient, it also handles inserting; /// already existing edges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:18,wrap,wrapper,18,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['wrap'],['wrapper']
Integrability,"/// A convenience wrapper around the above to handle trivial cases of; /// inserting a new ref edge.; ///; /// This is trivial whenever the target is in the same RefSCC as the source; /// or the edge is an outgoing edge to some descendant RefSCC. In these; /// cases there is no change to the cyclic structure of the RefSCCs.; ///; /// To further make calling this convenient, it also handles inserting; /// already existing edges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:18,wrap,wrapper,18,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['wrap'],['wrapper']
Integrability,/// A convenience wrapper around the primary \c alias interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,wrap,wrapper,18,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,4,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,/// A convenience wrapper around the primary \c getModRefInfoMask; /// interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,wrap,wrapper,18,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,/// A convenience wrapper around the primary \c pointsToConstantMemory; /// interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,wrap,wrapper,18,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,/// A convenience wrapper for constructing the memory location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,wrap,wrapper,18,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['wrap'],['wrapper']
Integrability,/// A convenience wrapper for setting entry count,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:18,wrap,wrapper,18,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,1,['wrap'],['wrapper']
Integrability,/// A convenience wrapper synthesizing a memory location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,wrap,wrapper,18,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,2,['wrap'],['wrapper']
Integrability,/// A convenience wrapper to synthesize a memory location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,wrap,wrapper,18,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['wrap'],['wrapper']
Integrability,/// A convenient wrapper around computeObjectUnderConstruction; /// and updateObjectsUnderConstruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h:17,wrap,wrapper,17,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h,1,['wrap'],['wrapper']
Integrability,/// A critical data dependency descriptor.; ///; /// Field RegID is set to the invalid register for memory dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:20,depend,dependency,20,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,2,['depend'],"['dependencies', 'dependency']"
Integrability,/// A customized wrapper for CFGBlock::getTerminatorCondition(); /// which returns the element for ObjCForCollectionStmts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:17,wrap,wrapper,17,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['wrap'],['wrapper']
Integrability,/// A data type for representing the result computed by \c; /// computeDependence. States whether it is okay to reorder the; /// instruction passed to \c computeDependence with at most one; /// dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:194,depend,dependency,194,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['depend'],['dependency']
Integrability,"/// A debug info location.; ///; /// This class is a wrapper around a tracking reference to an \a DILocation; /// pointer.; ///; /// To avoid extra includes, \a DebugLoc doubles the \a DILocation API with a; /// one based on relatively opaque \a MDNode pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugLoc.h:53,wrap,wrapper,53,interpreter/llvm-project/llvm/include/llvm/IR/DebugLoc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugLoc.h,1,['wrap'],['wrapper']
Integrability,"/// A default argument (C++ [dcl.fct.default]).; ///; /// This wraps up a function call argument that was created from the; /// corresponding parameter's default argument, when the call did not; /// explicitly supply arguments for all of the parameters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:63,wrap,wraps,63,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['wrap'],['wraps']
Integrability,/// A definition will return its interface declaration.; /// An interface declaration will return its definition.; /// Otherwise it will return itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:33,interface,interface,33,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,4,['interface'],['interface']
Integrability,/// A dependence is useful if the basic block of the defining instruction; /// is part of the trace of the user instruction. It is assumed that DefMI; /// dominates UseMI (see also isUsefulDominator).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:6,depend,dependence,6,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,1,['depend'],['dependence']
Integrability,"/// A dependent initialization, which could not be; /// type-checked due to the presence of dependent types or; /// dependently-typed expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:6,depend,dependent,6,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,3,['depend'],"['dependent', 'dependently-typed']"
Integrability,/// A dependent name that might instantiate to a template-name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:6,depend,dependent,6,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['depend'],['dependent']
Integrability,/// A dependent template name that has not been resolved to a; /// template (or set of templates).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h:6,depend,dependent,6,interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,1,['depend'],['dependent']
Integrability,/// A dependently-generated diagnostic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependentDiagnostic.h:6,depend,dependently-generated,6,interpreter/llvm-project/clang/include/clang/AST/DependentDiagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependentDiagnostic.h,1,['depend'],['dependently-generated']
Integrability,/// A diagnostic message which has been conditionally emitted pending; /// the complete parsing of the current declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h:17,message,message,17,interpreter/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h,1,['message'],['message']
Integrability,"/// A field in a dependent type, known only by its name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:17,depend,dependent,17,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['depend'],['dependent']
Integrability,"/// A flag indicating if we've emitted at least one class.; /// If we haven't, then we need to emit an empty protocol, to ensure that the; /// __start__objc_classes and __stop__objc_classes sections / exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:109,protocol,protocol,109,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['protocol'],['protocol']
Integrability,"/// A flag indicating if we've emitted at least one protocol reference.; /// If we haven't, then we need to emit an empty protocol, to ensure that the; /// __start__objc_protocol_refs and __stop__objc_protocol_refs sections; /// exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:52,protocol,protocol,52,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,2,['protocol'],['protocol']
Integrability,"/// A flag indicating if we've emitted at least one protocol.; /// If we haven't, then we need to emit an empty protocol, to ensure that the; /// __start__objc_protocols and __stop__objc_protocols sections exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:52,protocol,protocol,52,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,2,['protocol'],['protocol']
Integrability,"/// A forward iterator which reads text lines from a buffer.; ///; /// This class provides a forward iterator interface for reading one line at; /// a time from a buffer. When default constructed the iterator will be the; /// ""end"" iterator.; ///; /// The iterator is aware of what line number it is currently processing. It; /// strips blank lines by default, and comment lines given a comment-starting; /// character.; ///; /// Note that this iterator requires the buffer to be nul terminated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/LineIterator.h:110,interface,interface,110,interpreter/llvm-project/llvm/include/llvm/Support/LineIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/LineIterator.h,1,['interface'],['interface']
Integrability,/// A frontend action which simply wraps some other runtime-specified; /// frontend action.; ///; /// Deriving from this class allows an action to inject custom logic around; /// some existing action's behavior. It implements every virtual method in; /// the FrontendAction interface by forwarding to the wrapped action.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h:35,wrap,wraps,35,interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,4,"['inject', 'interface', 'wrap']","['inject', 'interface', 'wrapped', 'wraps']"
Integrability,"/// A function object that takes an ExecutorAddr as its first argument,; /// casts that address to a ClassT*, then calls the given method on that; /// pointer passing in the remaining function arguments. This utility; /// removes some of the boilerplate from writing wrappers for method calls.; ///; /// @code{.cpp}; /// class MyClass {; /// public:; /// void myMethod(uint32_t, bool) { ... }; /// };; ///; /// // SPS Method signature -- note MyClass object address as first argument.; /// using SPSMyMethodWrapperSignature =; /// SPSTuple<SPSExecutorAddr, uint32_t, bool>;; ///; /// WrapperFunctionResult; /// myMethodCallWrapper(const char *ArgData, size_t ArgSize) {; /// return WrapperFunction<SPSMyMethodWrapperSignature>::handle(; /// ArgData, ArgSize, makeMethodWrapperHandler(&MyClass::myMethod));; /// }; /// @endcode; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:267,wrap,wrappers,267,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,3,"['Wrap', 'wrap']","['WrapperFunction', 'WrapperFunctionResult', 'wrappers']"
Integrability,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:50,wrap,wrap,50,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,4,['wrap'],['wrap']
Integrability,"/// A function to deduce a loop pass type and wrap it in the templated; /// adaptor.; ///; /// If \p Pass is a loop pass, the returned adaptor will be in loop mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:46,wrap,wrap,46,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,1,['wrap'],['wrap']
Integrability,"/// A globally hashed type represents a hash value that is sufficient to; /// uniquely identify a record across multiple type streams or type sequences.; /// This works by, for any given record A which references B, replacing the; /// TypeIndex that refers to B with a previously-computed global hash for B. As; /// this is a recursive algorithm (e.g. the global hash of B also depends on the; /// global hashes of the types that B refers to), a global hash can uniquely; /// identify that A occurs in another stream that has a completely; /// different graph structure. Although the hash itself is slower to compute,; /// probing is much faster with a globally hashed type, because the hash itself; /// is considered ""as good as"" the original type. Since type records can be; /// quite large, this makes the equality comparison of the hash much faster than; /// equality comparison of a full record.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h:378,depend,depends,378,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h,1,['depend'],['depends']
Integrability,/// A handle to a particular switch case. It exposes a convenient interface; /// to both the case value and the successor block.; ///; /// We define this as a template and instantiate it to form both a const and; /// non-const handle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:66,interface,interface,66,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['interface'],['interface']
Integrability,"/// A handler or incoming WrapperFunctionResults -- either return values from; /// callWrapper* calls, or incoming JIT-dispatch requests.; ///; /// IncomingWFRHandlers are constructible from; /// unique_function<void(shared::WrapperFunctionResult)>s using the; /// runInPlace function or a RunWithDispatch object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h:26,Wrap,WrapperFunctionResults,26,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,2,['Wrap'],"['WrapperFunctionResult', 'WrapperFunctionResults']"
Integrability,"/// A helper class to unwrap a type down to a function for the; /// purposes of applying attributes there.; ///; /// Use:; /// FunctionTypeUnwrapper unwrapped(SemaRef, T);; /// if (unwrapped.isFunctionType()) {; /// const FunctionType *fn = unwrapped.get();; /// // change fn somehow; /// T = unwrapped.wrap(fn);; /// }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:303,wrap,wrap,303,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['wrap'],['wrap']
Integrability,/// A helper function for emitMacroExpansion to print the; /// macro expansion message,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:79,message,message,79,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,1,['message'],['message']
Integrability,"/// A helper struct providing information about the byte size of DW_FORM; /// values that vary in size depending on the DWARF version, address byte; /// size, or DWARF32/DWARF64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:103,depend,depending,103,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,1,['depend'],['depending']
Integrability,/// A key to identify a specific token. The token concept depends on the; /// underlying implementation -- it can be a spelled token from the original; /// source file or an expanded token.; /// The syntax-tree Leaf node holds a Key.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h:58,depend,depends,58,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h,1,['depend'],['depends']
Integrability,/// A legacy pass for the legacy pass manager that wraps the \c SROA pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:51,wrap,wraps,51,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['wrap'],['wraps']
Integrability,"/// A lightweight polymorphic wrapper around FieldRegion *. We'll use this; /// interface to store addinitional information about fields. As described; /// later, a list of these objects (i.e. ""fieldchain"") will be constructed and; /// used for printing note messages should an uninitialized value be found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:30,wrap,wrapper,30,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,3,"['interface', 'message', 'wrap']","['interface', 'messages', 'wrapper']"
Integrability,/// A lightweight wrapper around an expression operand.; ///; /// TODO: Store arguments directly and change \a DIExpression to store a; /// range of these.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h:18,wrap,wrapper,18,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,1,['wrap'],['wrapper']
Integrability,"/// A linked-list with a custom, local allocator.; ///; /// Expose a std::list-like interface that owns and uses a custom LLVM-style; /// allocator (e.g., BumpPtrAllocator), leveraging \a simple_ilist for the; /// implementation details.; ///; /// Because this list owns the allocator, calling \a splice() with a different; /// list isn't generally safe. As such, \a splice has been left out of the; /// interface entirely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h:84,interface,interface,84,interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h,2,['interface'],['interface']
Integrability,"/// A list of (pointer-difference, access size) pairs that can be used to; /// prove that there are no vectorization-preventing dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:128,depend,dependencies,128,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['depend'],['dependencies']
Integrability,"/// A list of Objective-C protocols, along with the source; /// locations at which they were referenced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:26,protocol,protocols,26,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['protocol'],['protocols']
Integrability,/// A list of dependent libraries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h:14,depend,dependent,14,interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,1,['depend'],['dependent']
Integrability,/// A list of extra dependencies (filename and kind) to be used for every; /// target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h:20,depend,dependencies,20,interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h,1,['depend'],['dependencies']
Integrability,"/// A list of macros of the form \c <definition>=<expansion> .; ///; /// Code will be parsed with macros expanded, in order to determine how to; /// interpret and format the macro arguments.; ///; /// For example, the code:; /// \code; /// A(a*b);; /// \endcode; ///; /// will usually be interpreted as a call to a function A, and the; /// multiplication expression will be formatted as ``a * b``.; ///; /// If we specify the macro definition:; /// \code{.yaml}; /// Macros:; /// - A(x)=x; /// \endcode; ///; /// the code will now be parsed as a declaration of the variable b of type a*,; /// and formatted as ``a* b`` (depending on pointer-binding rules).; ///; /// Features and restrictions:; /// * Both function-like macros and object-like macros are supported.; /// * Macro arguments must be used exactly once in the expansion.; /// * No recursive expansion; macros referencing other macros will be; /// ignored.; /// * Overloading by arity is supported: for example, given the macro; /// definitions A=x, A()=y, A(a)=a; ///; /// \code; /// A; -> x;; /// A(); -> y;; /// A(z); -> z;; /// A(a, b); // will not be expanded.; /// \endcode; ///; /// \version 17",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:620,depend,depending,620,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['depend'],['depending']
Integrability,"/// A list of module identifiers this module directly depends on, not; /// including transitive dependencies.; ///; /// This may include modules with a different context hash when it can be; /// determined that the differences are benign for this compilation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:54,depend,depends,54,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,2,['depend'],"['dependencies', 'depends']"
Integrability,"/// A list of modules this translation unit directly depends on, not including; /// transitive dependencies.; ///; /// This may include modules with a different context hash when it can be; /// determined that the differences are benign for this compilation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:53,depend,depends,53,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,2,['depend'],"['dependencies', 'depends']"
Integrability,/// A list of names to use as the targets in the dependency file; this list; /// must contain at least one entry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h:49,depend,dependency,49,interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h,1,['depend'],['dependency']
Integrability,/// A loaded pass plugin.; ///; /// An instance of this class wraps a loaded pass plugin and gives access to; /// its interface defined by the \c PassPluginLibraryInfo it exposes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h:62,wrap,wraps,62,interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,2,"['interface', 'wrap']","['interface', 'wraps']"
Integrability,/// A logger that simply writes messages to the specified ostream in real; /// time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Logger.h:32,message,messages,32,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Logger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Logger.h,1,['message'],['messages']
Integrability,"/// A manager for alias analyses.; ///; /// This class can have analyses registered with it and when run, it will run; /// all of them and aggregate their results into single AA results interface; /// that dispatches across all of the alias analysis results available.; ///; /// Note that the order in which analyses are registered is very significant.; /// That is the order in which the results will be aggregated and queried.; ///; /// This manager effectively wraps the AnalysisManager for registering alias; /// analyses. When you register your alias analysis with this manager, it will; /// ensure the analysis itself is registered with its AnalysisManager.; ///; /// The result of this analysis is only invalidated if one of the particular; /// aggregated AA results end up being invalidated. This removes the need to; /// explicitly preserve the results of `AAManager`. Note that analyses should no; /// longer be registered once the `AAManager` is run.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:186,interface,interface,186,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,2,"['interface', 'wrap']","['interface', 'wraps']"
Integrability,/// A map associating tag names with asynchronous wrapper function; /// implementations in the JIT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:50,wrap,wrapper,50,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['wrap'],['wrapper']
Integrability,"/// A map for assigning uninitialized regions to note messages. For example,; ///; /// struct A {; /// int x;; /// };; ///; /// A a;; ///; /// After analyzing `a`, the map will contain a pair for `a.x`'s region and; /// the note message ""uninitialized field 'this->x'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:54,message,messages,54,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,2,['message'],"['message', 'messages']"
Integrability,"/// A map from ValueType to SUList, used during DAG construction, as; /// a means of remembering which SUs depend on which memory locations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:107,depend,depend,107,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['depend'],['depend']
Integrability,"/// A map from continuous integer ranges to some value, with a very; /// specialized interface.; ///; /// CRM maps from integer ranges to values. The ranges are continuous, i.e.; /// where one ends, the next one begins. So if the map contains the stops I0-3,; /// the first range is from I0 to I1, the second from I1 to I2, the third from; /// I2 to I3 and the last from I3 to infinity.; ///; /// Ranges must be inserted in order. Inserting a new stop I4 into the map will; /// shrink the fourth range to I3 to I4 and add the new range I4 to inf.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ContinuousRangeMap.h:85,interface,interface,85,interpreter/llvm-project/clang/include/clang/Serialization/ContinuousRangeMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ContinuousRangeMap.h,1,['interface'],['interface']
Integrability,/// A map of in-memory object files that have been registered with the; /// JIT interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:80,interface,interface,80,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,1,['interface'],['interface']
Integrability,/// A mapping from intrinsics (=`llvm.assume` calls) to a value range; /// (=knowledge) that is encoded in them. How the value range is interpreted; /// depends on the RetainedKnowledgeKey that was used to get this out of the; /// RetainedKnowledgeMap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumeBundleQueries.h:153,depend,depends,153,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumeBundleQueries.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumeBundleQueries.h,1,['depend'],['depends']
Integrability,/// A memory dependence query can return one of three different answers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:13,depend,dependence,13,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['depend'],['dependence']
Integrability,/// A message that explains why the call is sensitive to taint.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:6,message,message,6,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,1,['message'],['message']
Integrability,"/// A method might not be available in the interface indicated by the static; /// type. However it might be available in the tracked type. In order to; /// properly substitute the type parameters we need the declaration context of; /// the method. The more specialized the enclosing class of the method is, the; /// more likely that the parameter substitution will be successful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:43,interface,interface,43,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,1,['interface'],['interface']
Integrability,"/// A mock class satisfying the interface expected by ReleaseModeModelRunner for; /// its `TGen` parameter. Useful to avoid conditional compilation complexity, as; /// a compile-time replacement for a real AOT-ed model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:32,interface,interface,32,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,1,['interface'],['interface']
Integrability,"/// A multiple-use def in the same block with no intervening memory or register; /// dependencies; move the def down, nest it with the current instruction, and; /// insert a tee to satisfy the rest of the uses. As an illustration, rewrite; /// this:; ///; /// Reg = INST ... // Def; /// INST ..., Reg, ... // Insert; /// INST ..., Reg, ...; /// INST ..., Reg, ...; ///; /// to this:; ///; /// DefReg = INST ... // Def (to become the new Insert); /// TeeReg, Reg = TEE_... DefReg; /// INST ..., TeeReg, ... // Insert; /// INST ..., Reg, ...; /// INST ..., Reg, ...; ///; /// with DefReg and TeeReg stackified. This eliminates a local.get from the; /// resulting code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:85,depend,dependencies,85,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,1,['depend'],['dependencies']
Integrability,"/// A mutex to synchronize the final page sink.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx:15,synchroniz,synchronize,15,tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,1,['synchroniz'],['synchronize']
Integrability,/// A new objc category class was added for an interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTMutationListener.h:47,interface,interface,47,interpreter/llvm-project/clang/include/clang/AST/ASTMutationListener.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTMutationListener.h,1,['interface'],['interface']
Integrability,"/// A node of a memory dependency graph. A MemoryGroup describes a set of; /// instructions with same memory dependencies.; ///; /// By construction, instructions of a MemoryGroup don't depend on each other.; /// At dispatch stage, instructions are mapped by the LSUnit to MemoryGroups.; /// A Memory group identifier is then stored as a ""token"" in field; /// Instruction::LSUTokenID of each dispatched instructions. That token is used; /// internally by the LSUnit to track memory dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:23,depend,dependency,23,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,4,['depend'],"['depend', 'dependencies', 'dependency']"
Integrability,"/// A non-RAII class containing all the information about a bound; /// opaque value. OpaqueValueMapping, below, is a RAII wrapper for; /// this which makes individual mappings very simple; using this; /// class directly is useful when you have a variable number of; /// opaque values or don't want the RAII functionality for some; /// reason.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:122,wrap,wrapper,122,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['wrap'],['wrapper']
Integrability,/// A non-dependent name that is a potential typo for a template name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:10,depend,dependent,10,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['depend'],['dependent']
Integrability,"/// A pair of WrapperFunctionCalls, one to be run at finalization time, one to; /// be run at deallocation time.; ///; /// AllocActionCallPairs should be constructed for paired operations (e.g.; /// __register_ehframe and __deregister_ehframe for eh-frame registration).; /// See comments for AllocActions for execution ordering.; ///; /// For unpaired operations one or the other member can be left unused, as; /// AllocationActionCalls with an FnAddr of zero will be skipped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/AllocationActions.h:14,Wrap,WrapperFunctionCalls,14,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/AllocationActions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/AllocationActions.h,1,['Wrap'],['WrapperFunctionCalls']
Integrability,"/// A pair<Value*, bool> where the bool is true if the dependence is a read; /// only dependence, false if read/write.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:55,depend,dependence,55,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,2,['depend'],['dependence']
Integrability,"/// A parser for options common to all command-line Clang tools.; ///; /// Parses a common subset of command-line arguments, locates and loads a; /// compilation commands database and runs a tool with user-specified action. It; /// also contains a help message for the common command-line options.; ///; /// An example of usage:; /// \code; /// #include ""clang/Frontend/FrontendActions.h""; /// #include ""clang/Tooling/CommonOptionsParser.h""; /// #include ""clang/Tooling/Tooling.h""; /// #include ""llvm/Support/CommandLine.h""; ///; /// using namespace clang::tooling;; /// using namespace llvm;; ///; /// static cl::OptionCategory MyToolCategory(""My tool options"");; /// static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);; /// static cl::extrahelp MoreHelp(""\nMore help text...\n"");; /// static cl::opt<bool> YourOwnOption(...);; /// ...; ///; /// int main(int argc, const char **argv) {; /// CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);; /// ClangTool Tool(OptionsParser.getCompilations(),; /// OptionsParser.getSourcePathList());; /// return Tool.run(newFrontendActionFactory<SyntaxOnlyAction>().get());; /// }; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h:253,message,message,253,interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h,1,['message'],['message']
Integrability,"/// A pass to simplify and canonicalize the CFG of a function.; ///; /// This pass iteratively simplifies the entire CFG of a function. It may change; /// or remove control flow to put the CFG into a canonical form expected by; /// other passes of the mid-level optimizer. Depending on the specified options,; /// it may further optimize control-flow to create non-canonical forms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:273,Depend,Depending,273,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,1,['Depend'],['Depending']
Integrability,"/// A piece of text that describes the parameter that corresponds; /// to the code-completion location within a function call, message send,; /// macro invocation, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:127,message,message,127,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['message'],['message']
Integrability,"/// A pointer to the depending/depended-on SUnit, and an enum; /// indicating the kind of the dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:21,depend,depending,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,3,['depend'],"['depended-on', 'dependency', 'depending']"
Integrability,/// A private abstract base class describing the concept of an individual alias; /// analysis implementation.; ///; /// This interface is implemented by any \c Model instantiation. It is also the; /// interface which a type used to instantiate the model must provide.; ///; /// All of these methods model methods by the same name in the \c; /// AAResults class. Only differences and specifics to how the; /// implementations are called are documented here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:125,interface,interface,125,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,2,['interface'],['interface']
Integrability,/// A private class template which derives from \c Concept and wraps some other; /// type.; ///; /// This models the concept by directly forwarding each interface point to the; /// wrapped type which must implement a compatible interface. This provides; /// a type erased binding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:63,wrap,wraps,63,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,4,"['interface', 'wrap']","['interface', 'wrapped', 'wraps']"
Integrability,"/// A qualified reference to a name whose declaration cannot; /// yet be resolved.; ///; /// DependentScopeDeclRefExpr is similar to DeclRefExpr in that; /// it expresses a reference to a declaration such as; /// X<T>::value. The difference, however, is that an; /// DependentScopeDeclRefExpr node is used only within C++ templates when; /// the qualification (e.g., X<T>::) refers to a dependent type. In; /// this case, X<T>::value cannot resolve to a declaration because the; /// declaration will differ from one instantiation of X<T> to the; /// next. Therefore, DependentScopeDeclRefExpr keeps track of the; /// qualifier (X<T>::) and the name of the entity being referenced; /// (""value""). Such expressions will instantiate to a DeclRefExpr once the; /// declaration can be found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:93,Depend,DependentScopeDeclRefExpr,93,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,4,"['Depend', 'depend']","['DependentScopeDeclRefExpr', 'dependent']"
Integrability,"/// A query AA is always scheduled as long as we do updates because it does; /// lazy computation that cannot be determined to be done from the outside.; /// However, while query AAs will not be fixed if they do not have outstanding; /// dependences, we will only schedule them like other AAs. If a query AA that; /// received a new query it needs to request an update via; /// `Attributor::requestUpdateForAA`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:238,depend,dependences,238,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['depend'],['dependences']
Integrability,"/// A refactoring action rule is a wrapper class around a specific refactoring; /// action rule (SourceChangeRefactoringRule, etc) that, in addition to invoking; /// the action, describes the requirements that determine when the action can be; /// initiated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:35,wrap,wrapper,35,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,1,['wrap'],['wrapper']
Integrability,/// A refactoring option is an interface that describes a value that; /// has an impact on the outcome of a refactoring.; ///; /// Refactoring options can be specified using command-line arguments when; /// the clang-refactor tool is used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h:31,interface,interface,31,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h,1,['interface'],['interface']
Integrability,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:233,depend,dependency,233,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,3,['depend'],"['dependence', 'dependency']"
Integrability,"/// A reference to a name which we were able to look up during; /// parsing but could not resolve to a specific declaration.; ///; /// This arises in several ways:; /// * we might be waiting for argument-dependent lookup;; /// * the name might resolve to an overloaded function;; /// and eventually:; /// * the lookup might have included a function template.; ///; /// These never include UnresolvedUsingValueDecls, which are always class; /// members and therefore appear only in UnresolvedMemberLookupExprs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:204,depend,dependent,204,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['depend'],['dependent']
Integrability,"/// A resource manager for processor resource units and groups.; ///; /// This class owns all the ResourceState objects, and it is responsible for; /// acting on requests from a Scheduler by updating the internal state of; /// ResourceState objects.; /// This class doesn't know about instruction itineraries and functional units.; /// In future, it can be extended to support itineraries too through the same; /// public interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:422,interface,interface,422,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['interface'],['interface']
Integrability,"/// A sequence of code fragments, references to parameters and code-generation; /// operations that together can be evaluated to (a fragment of) source code or; /// a diagnostic message, given a match result.; ///; /// We use a `shared_ptr` to allow for easy and cheap copying of stencils.; /// Since `StencilInterface` is an immutable interface, the sharing doesn't; /// impose any risks. Otherwise, we would have to add a virtual `copy` method to; /// the API and implement it for all derived classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:178,message,message,178,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,2,"['interface', 'message']","['interface', 'message']"
Integrability,/// A serializer that can write non-continuation leaf types. Only used as; /// a convenience function so that we can provide an interface method to; /// write an unserialized record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/GlobalTypeTableBuilder.h:128,interface,interface,128,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/GlobalTypeTableBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/GlobalTypeTableBuilder.h,2,['interface'],['interface']
Integrability,/// A set of interned synchronization scopes. The StringMap maps; /// synchronization scope names to their respective synchronization scope IDs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:22,synchroniz,synchronization,22,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,3,['synchroniz'],['synchronization']
Integrability,/// A set of live virtual registers and physical register units.; ///; /// This is a wrapper around a SparseSet which deals with mapping register unit; /// and virtual register indexes to an index usable by the sparse set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:85,wrap,wrapper,85,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,1,['wrap'],['wrapper']
Integrability,/// A set of registers which are live and cannot be changed to; /// break anti-dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:79,depend,dependencies,79,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,1,['depend'],['dependencies']
Integrability,/// A short general warning message that is appropriate for displaying in; /// the list of all reported bugs. It should describe what kind of bug is found; /// but does not need to try to go into details of that specific bug.; /// Grammatical conventions of getDescription() apply here as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h:28,message,message,28,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,1,['message'],['message']
Integrability,"/// A simple dependency action controller that uses a callback. If no callback; /// is provided, it is assumed that looking up module outputs is unreachable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:13,depend,dependency,13,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,1,['depend'],['dependency']
Integrability,/// A simple wrapper when you only need to notify checkers of pointer-escape; /// of some values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h:13,wrap,wrapper,13,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h,1,['wrap'],['wrapper']
Integrability,/// A single-use def in the same block with no intervening memory or register; /// dependencies; move the def down and nest it with the current instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:83,depend,dependencies,83,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,1,['depend'],['dependencies']
Integrability,"/// A special type used to provide an address that identifies a set of related; /// analyses. These sets are primarily used below to mark sets of analyses as; /// preserved.; ///; /// For example, a transformation can indicate that it preserves the CFG of a; /// function by preserving the appropriate AnalysisSetKey. An analysis that; /// depends only on the CFG can then check if that AnalysisSetKey is preserved;; /// if it is, the analysis knows that it itself is preserved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:340,depend,depends,340,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['depend'],['depends']
Integrability,/// A special wrapper for .cfi_escape that indicates GNU_ARGS_SIZE,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCDwarf.h:14,wrap,wrapper,14,interpreter/llvm-project/llvm/include/llvm/MC/MCDwarf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCDwarf.h,1,['wrap'],['wrapper']
Integrability,/// A state machine that detects the \#ifndef-wrapping a file; /// idiom for the multiple-include optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorLexer.h:46,wrap,wrapping,46,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorLexer.h,1,['wrap'],['wrapping']
Integrability,"/// A storage location for a record (struct, class, or union).; ///; /// Contains storage locations for all modeled fields of the record (also; /// referred to as ""children""). The child map is flat, so accessible members of; /// the base class are directly accessible as children of this location.; ///; /// Record storage locations may also contain so-called synthetic fields. These; /// are typically used to model the internal state of a class (e.g. the value; /// stored in a `std::optional`) without having to depend on that class's; /// implementation details. All `RecordStorageLocation`s of a given type should; /// have the same synthetic fields.; ///; /// The storage location for a field of reference type may be null. This; /// typically occurs in one of two situations:; /// - The record has not been fully initialized.; /// - The maximum depth for modelling a self-referential data structure has been; /// reached.; /// Storage locations for fields of all other types must be non-null.; ///; /// FIXME: Currently, the storage location of unions is modelled the same way as; /// that of structs or classes. Eventually, we need to change this modelling so; /// that all of the members of a given union have the same storage location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/StorageLocation.h:515,depend,depend,515,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/StorageLocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/StorageLocation.h,1,['depend'],['depend']
Integrability,/// A string containing the Objective-C selector entered thus far for a; /// message send.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:77,message,message,77,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,1,['message'],['message']
Integrability,/// A string to prefix to error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/SARIFDiagnosticPrinter.h:32,message,messages,32,interpreter/llvm-project/clang/include/clang/Frontend/SARIFDiagnosticPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/SARIFDiagnosticPrinter.h,2,['message'],['messages']
Integrability,/// A struct to pack the relevant information for an OpenMP depend clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:60,depend,depend,60,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['depend'],['depend']
Integrability,/// A template wrapper used to implement the polymorphic API.; ///; /// Can be instantiated for any object which provides a \c run method accepting; /// an \c IRUnitT& and an \c AnalysisManager<IRUnit>&. It requires the pass to; /// be a copyable object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h:15,wrap,wrapper,15,interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h,1,['wrap'],['wrapper']
Integrability,/// A templated base class for \c SmallPtrSet which provides the; /// typesafe interface that is common across all small sizes.; ///; /// This is particularly useful for passing around between interface boundaries; /// to avoid encoding a particular small size in the interface boundary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:79,interface,interface,79,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,3,['interface'],['interface']
Integrability,/// A temporary-object class for building up diff messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:50,message,messages,50,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,1,['message'],['messages']
Integrability,/// A temporary-object class for building up log messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:49,message,messages,49,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,1,['message'],['messages']
Integrability,/// A thin wrapper to store two values that we matched as div-rem pair.; /// We want this extra indirection to avoid dealing with RAUW'ing the map keys.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:11,wrap,wrapper,11,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,1,['wrap'],['wrapper']
Integrability,"/// A thread-safe stack of N indexes (0 to size - 1).; /// RSlotStack can be used to safely assign a ""processing slot"" number to; /// each thread in multi-thread applications.; /// In release builds, pop and push operations are unchecked, potentially; /// resulting in undefined behavior if more slot numbers than available are; /// requested.; /// An important design assumption is that a slot will almost always be available; /// when a thread asks for it, and if it is not available it will be very soon,; /// therefore a spinlock is used for synchronization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/RSlotStack.hxx:546,synchroniz,synchronization,546,core/imt/inc/ROOT/RSlotStack.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/RSlotStack.hxx,1,['synchroniz'],['synchronization']
Integrability,"/// A toplogical ordering of the SUnits, which is needed for changing; /// dependences and iterating over the SUnits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:75,depend,dependences,75,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['depend'],['dependences']
Integrability,/// A traits type that is used to handle pointer types and things that are just; /// wrappers for pointers as a uniform entity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PointerLikeTypeTraits.h:85,wrap,wrappers,85,interpreter/llvm-project/llvm/include/llvm/Support/PointerLikeTypeTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PointerLikeTypeTraits.h,1,['wrap'],['wrappers']
Integrability,"/// A trie to efficiently match against the entries of the compilation; /// database in order of matching suffix length.; ///; /// When a clang tool is supposed to operate on a specific file, we have to; /// find the corresponding file in the compilation database. Although entries; /// in the compilation database are keyed by filename, a simple string match; /// is insufficient because of symlinks. Commonly, a project hierarchy looks; /// like this:; /// /<project-root>/src/<path>/<somefile>.cc (used as input for the tool); /// /<project-root>/build/<symlink-to-src>/<path>/<somefile>.cc (stored in DB); ///; /// Furthermore, there might be symlinks inside the source folder or inside the; /// database, so that the same source file is translated with different build; /// options.; ///; /// For a given input file, the \c FileMatchTrie finds its entries in order; /// of matching suffix length. For each suffix length, there might be one or; /// more entries in the database. For each of those entries, it calls; /// \c llvm::sys::fs::equivalent() (injected as \c PathComparator). There might; /// be zero or more entries with the same matching suffix length that are; /// equivalent to the input file. Three cases are distinguished:; /// 0 equivalent files: Continue with the next suffix length.; /// 1 equivalent file: Best match found, return it.; /// >1 equivalent files: Match is ambiguous, return error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h:1056,inject,injected,1056,interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,1,['inject'],['injected']
Integrability,"/// A type-erased variant of the above invalidate method with the same core; /// API other than passing an analysis ID rather than an analysis type; /// parameter.; ///; /// This is sadly less efficient than the above routine, which leverages; /// the type parameter to avoid the type erasure overhead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:218,rout,routine,218,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['rout'],['routine']
Integrability,/// A union discriminated by the dependence kind.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:33,depend,dependence,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['depend'],['dependence']
Integrability,"/// A use of a default initializer in a constructor or in aggregate; /// initialization.; ///; /// This wraps a use of a C++ default initializer (technically,; /// a brace-or-equal-initializer for a non-static data member) when it; /// is implicitly used in a mem-initializer-list in a constructor; /// (C++11 [class.base.init]p8) or in aggregate initialization; /// (C++1y [dcl.init.aggr]p7).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:104,wrap,wraps,104,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['wrap'],['wraps']
Integrability,"/// A utility pass template to force an analysis result to be available.; ///; /// If there are extra arguments at the pass's run level there may also be; /// extra arguments to the analysis manager's \c getResult routine. We can't; /// guess how to effectively map the arguments from one to the other, and so; /// this specialization just ignores them.; ///; /// Specific patterns of run-method extra arguments and analysis manager extra; /// arguments will have to be defined as appropriate specializations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:214,rout,routine,214,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['rout'],['routine']
Integrability,/// A vector of metadata strings for dependent libraries for ELF.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:37,depend,dependent,37,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['depend'],['dependent']
Integrability,"/// A vector that has set insertion semantics.; ///; /// This adapter class provides a way to keep a set of things that also has the; /// property of a deterministic iteration order. The order of iteration is the; /// order of insertion.; ///; /// The key and value types are derived from the Set and Vector types; /// respectively. This allows the vector-type operations and set-type operations; /// to have different types. In particular, this is useful when storing pointers; /// as ""Foo *"" values but looking them up as ""const Foo *"" keys.; ///; /// No constraint is placed on the key and value types, although it is assumed; /// that value_type can be converted into key_type for insertion. Users must be; /// aware of any loss of information in this conversion. For example, setting; /// value_type to float and key_type to int can produce very surprising results,; /// but it is not explicitly disallowed.; ///; /// The parameter N specifies the ""small"" size of the container, which is the; /// number of elements upto which a linear scan over the Vector will be used; /// when searching for elements instead of checking Set, due to it being better; /// for performance. A value of 0 means that this mode of operation is not used,; /// and is the default value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:62,adapter,adapter,62,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,1,['adapter'],['adapter']
Integrability,"/// A verbose warning message that is appropriate for displaying next to; /// the source code that introduces the problem. The description should be; /// at least a full sentence starting with a capital letter. The period at; /// the end of the warning is traditionally omitted. If the description; /// consists of multiple sentences, periods between the sentences are; /// encouraged, but the period at the end of the description is still omitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h:22,message,message,22,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,1,['message'],['message']
Integrability,/// A virtual file system optimized for the dependency discovery.; ///; /// It is primarily designed to work with source files whose contents was; /// preprocessed to remove any tokens that are unlikely to affect the dependency; /// computation.; ///; /// This is not a thread safe VFS. A single instance is meant to be used only in; /// one thread. Multiple instances are allowed to service multiple threads; /// running in parallel.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:44,depend,dependency,44,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,2,['depend'],['dependency']
Integrability,"/// A virtual file system parsed from a YAML file.; ///; /// Currently, this class allows creating virtual files and directories. Virtual; /// files map to existing external files in \c ExternalFS, and virtual; /// directories may either map to existing directories in \c ExternalFS or list; /// their contents in the form of other virtual directories and/or files.; ///; /// The basic structure of the parsed file is:; /// \verbatim; /// {; /// 'version': <version number>,; /// <optional configuration>; /// 'roots': [; /// <directory entries>; /// ]; /// }; /// \endverbatim; ///; /// The roots may be absolute or relative. If relative they will be made; /// absolute against either current working directory or the directory where; /// the Overlay YAML file is located, depending on the 'root-relative'; /// configuration.; ///; /// All configuration options are optional.; /// 'case-sensitive': <boolean, default=(true for Posix, false for Windows)>; /// 'use-external-names': <boolean, default=true>; /// 'root-relative': <string, one of 'cwd' or 'overlay-dir', default='cwd'>; /// 'overlay-relative': <boolean, default=false>; /// 'fallthrough': <boolean, default=true, deprecated - use 'redirecting-with'; /// instead>; /// 'redirecting-with': <string, one of 'fallthrough', 'fallback', or; /// 'redirect-only', default='fallthrough'>; ///; /// To clarify, 'root-relative' option will prepend the current working; /// directory, or the overlay directory to the 'roots->name' field only if; /// 'roots->name' is a relative path. On the other hand, when 'overlay-relative'; /// is set to 'true', external paths will always be prepended with the overlay; /// directory, even if external paths are not relative paths. The; /// 'root-relative' option has no interaction with the 'overlay-relative'; /// option.; ///; /// Virtual directories that list their contents are represented as; /// \verbatim; /// {; /// 'type': 'directory',; /// 'name': <string>,; /// 'contents': [ <file or directory entr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h:774,depend,depending,774,interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,1,['depend'],['depending']
Integrability,"/// A visitor class for IR positions.; ///; /// Given a position P, the SubsumingPositionIterator allows to visit ""subsuming; /// positions"" wrt. attributes/information. Thus, if a piece of information; /// holds for a subsuming position, it also holds for the position P.; ///; /// The subsuming positions always include the initial position and then,; /// depending on the position kind, additionally the following ones:; /// - for IRP_RETURNED:; /// - the function (IRP_FUNCTION); /// - for IRP_ARGUMENT:; /// - the function (IRP_FUNCTION); /// - for IRP_CALL_SITE:; /// - the callee (IRP_FUNCTION), if known; /// - for IRP_CALL_SITE_RETURNED:; /// - the callee (IRP_RETURNED), if known; /// - the call site (IRP_FUNCTION); /// - the callee (IRP_FUNCTION), if known; /// - for IRP_CALL_SITE_ARGUMENT:; /// - the argument of the callee (IRP_ARGUMENT), if known; /// - the callee (IRP_FUNCTION), if known; /// - the position the call site argument is associated with if it is not; /// anchored to the call site, e.g., if it is an argument then the argument; /// (IRP_ARGUMENT)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:358,depend,depending,358,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['depend'],['depending']
Integrability,/// A visitor interface to visit all BoundNodes results for a; /// BoundNodesTree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h:14,interface,interface,14,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,1,['interface'],['interface']
Integrability,/// A wrap/unwrap function that leaves pointers unmodified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h:6,wrap,wrap,6,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h,1,['wrap'],['wrap']
Integrability,/// A wrapper analysis pass for the legacy pass manager that exposes a \c; /// MemoryDepnedenceResults instance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['wrap'],['wrapper']
Integrability,/// A wrapper around AnalysisUsage for the purpose of uniqueing. The wrapper; /// is used to avoid needing to make AnalysisUsage itself a folding set node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,2,['wrap'],['wrapper']
Integrability,/// A wrapper around ScalarEvolution used to add runtime SCEV checks. Applies; /// dynamic knowledge to simplify SCEV expressions and converts them to a; /// more usable form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:6,wrap,wrapper,6,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['wrap'],['wrapper']
Integrability,/// A wrapper around ScalarEvolution used to add runtime SCEV checks.; /// Applies dynamic knowledge to simplify SCEV expressions in the context; /// of existing SCEV assumptions. The analysis will also add a minimal set; /// of new predicates if this is required to enable vectorization and; /// unrolling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['wrap'],['wrapper']
Integrability,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,3,"['depend', 'wrap']","['dependences', 'wrap', 'wrapper']"
Integrability,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks.; /// Simplifies SCEV expressions in the context of existing SCEV assumptions.; /// The interleaved access analysis can also add new predicates (for example; /// by versioning strides of pointers).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['wrap'],['wrapper']
Integrability,/// A wrapper around a \c Token storing information about the; /// whitespace characters preceding it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:6,wrap,wrapper,6,interpreter/llvm-project/clang/lib/Format/FormatToken.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h,1,['wrap'],['wrapper']
Integrability,"/// A wrapper around a concrete RDefine, which forwards all calls to it; /// RJittedDefine is a placeholder that is put in the collection of custom columns in place of a RDefine; /// that will be just-in-time compiled. Jitted code will assign the concrete RDefine to this RJittedDefine; /// before the event-loop starts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx:6,wrap,wrapper,6,tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx,1,['wrap'],['wrapper']
Integrability,"/// A wrapper around a concrete RFilter, which forwards all calls to it; /// RJittedFilter is the type of the node returned by jitted Filter calls: the concrete filter can be created and set; /// at a later time, from jitted code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedFilter.hxx:6,wrap,wrapper,6,tree/dataframe/inc/ROOT/RDF/RJittedFilter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedFilter.hxx,1,['wrap'],['wrapper']
Integrability,"/// A wrapper around a concrete RVariation, which forwards all calls to it; /// RJittedVariation is a placeholder that is inserted in the computation graph in place of a RVariation; /// that will be just-in-time compiled. Jitted code will assign the concrete RVariation to this RJittedVariation; /// before the event-loop starts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedVariation.hxx:6,wrap,wrapper,6,tree/dataframe/inc/ROOT/RDF/RJittedVariation.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedVariation.hxx,1,['wrap'],['wrapper']
Integrability,"/// A wrapper around a set that has semantics for handling unions and; /// intersections with a ""universal"" set that contains all elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['wrap'],['wrapper']
Integrability,"/// A wrapper around a string literal that serves as a proxy for constructing; /// global tables of StringRefs with the length computed at compile time.; /// In order to avoid the invocation of a global constructor, StringLiteral; /// should *only* be used in a constexpr context, as such:; ///; /// constexpr StringLiteral S(""test"");; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,1,['wrap'],['wrapper']
Integrability,/// A wrapper around an ExplodedGraph that contains a single path from the root; /// to the error node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:6,wrap,wrapper,6,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['wrap'],['wrapper']
Integrability,/// A wrapper around an ExplodedGraph whose leafs are all error nodes. Can; /// conveniently retrieve bug paths from a single error node to the root.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:6,wrap,wrapper,6,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['wrap'],['wrapper']
Integrability,"/// A wrapper around identifyKnownObject. Accepts type information; /// about the object and produces a smaller identifier by relying on; /// the alignment information. Note that sub-classes may have different; /// alignment, so the most base class should be passed as template parameter; /// in order to obtain correct results. For that reason automatic template; /// parameter deduction is disabled.; /// \return An index uniquely and reproducibly identifying; /// an input pointer \p Ptr in the given allocator. This identifier is; /// different from the ones produced by identifyObject and; /// identifyAlignedObject.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,1,['wrap'],['wrapper']
Integrability,/// A wrapper around identifyObject that additionally asserts that; /// the object is indeed within the allocator.; /// \return An index uniquely and reproducibly identifying; /// an input pointer \p Ptr in the given allocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,1,['wrap'],['wrapper']
Integrability,/// A wrapper around std::string which contains a source range that's being; /// set during parsing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h,1,['wrap'],['wrapper']
Integrability,/// A wrapper around three concatenated vectors (chains) of nodes; it is used; /// to avoid extra instantiation of the vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:6,wrap,wrapper,6,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['wrap'],['wrapper']
Integrability,/// A wrapper around two concatenated vectors (chains) of jumps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:6,wrap,wrapper,6,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['wrap'],['wrapper']
Integrability,/// A wrapper around unsigned which contains a source range that's being set; /// during parsing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h,1,['wrap'],['wrapper']
Integrability,"/// A wrapper class around a pointer that always points to its canonical; /// declaration.; ///; /// CanonicalDeclPtr<decl_type> behaves just like decl_type*, except we call; /// decl_type::getCanonicalDecl() on construction.; ///; /// This is useful for hashtables that you want to be keyed on a declaration's; /// canonical decl -- if you use CanonicalDeclPtr as the key, you don't need to; /// remember to call getCanonicalDecl() everywhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h:6,wrap,wrapper,6,interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h,1,['wrap'],['wrapper']
Integrability,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,5,"['interface', 'wrap']","['interface', 'wrapper', 'wraps']"
Integrability,/// A wrapper class for inspecting calls to intrinsic functions.; /// This allows the standard isa/dyncast/cast functionality to work with calls; /// to intrinsic functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,1,['wrap'],['wrapper']
Integrability,/// A wrapper class to simplify modification of SwitchInst cases along with; /// their prof branch_weights metadata.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['wrap'],['wrapper']
Integrability,/// A wrapper for GetUnderlyingObjCPtr used for results memoization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,1,['wrap'],['wrapper']
Integrability,/// A wrapper for MCSymbolRefExpr that tells the assembly printer that the; /// symbol should be enclosed by generic().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h,1,['wrap'],['wrapper']
Integrability,/// A wrapper for holding a mask of the values from X86::AlignBranchBoundaryKind,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:6,wrap,wrapper,6,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,1,['wrap'],['wrapper']
Integrability,/// A wrapper interface to populate the PGO symtab with functions; /// decls from module \c M. This interface is used by transformation; /// passes such as indirect function call promotion. Variable \c InLTO; /// indicates if this is called from LTO optimization passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,3,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"/// A wrapper node for TargetConstantPool, TargetJumpTable,; /// TargetExternalSymbol, TargetGlobalAddress, TargetGlobalTLSAddress,; /// MCSymbol and TargetBlockAddress.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['wrap'],['wrapper']
Integrability,"/// A wrapper node for TargetConstantPool,; /// TargetExternalSymbol, and TargetGlobalAddress.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,2,['wrap'],['wrapper']
Integrability,/// A wrapper object for maintaining stacks to track the resursive AST visitor; /// walks for the purpose of assigning IDs to leaf-level conditions measured by; /// MC/DC. The object is created with a reference to the MCDCBitmapMap that was; /// created during the initial AST walk. The presence of a bitmap associated; /// with a boolean expression (top-level logical operator nest) indicates that; /// the boolean expression qualified for MC/DC. The resulting condition IDs; /// are preserved in a map reference that is also provided during object; /// creation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp:6,wrap,wrapper,6,interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,1,['wrap'],['wrapper']
Integrability,/// A wrapper of a binary basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,1,['wrap'],['wrapper']
Integrability,/// A wrapper of a jump between two basic blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,1,['wrap'],['wrapper']
Integrability,/// A wrapper of binary function with basic blocks and jumps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,1,['wrap'],['wrapper']
Integrability,"/// A wrapper of the comparator, to be passed to the set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,1,['wrap'],['wrapper']
Integrability,"/// A wrapper on raw_string_ostream that contains its own buffer rather than; /// having to point it at one elsewhere. (In other words, it works just like; /// std::ostringstream; also, this makes it convenient to declare a whole array; /// of them at once.); ///; /// We have to set this up using multiple inheritance, to ensure that the; /// string member has been constructed before raw_string_ostream's constructor; /// is given a pointer to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:6,wrap,wrapper,6,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,1,['wrap'],['wrapper']
Integrability,"/// A wrapper over a field name and an optional description; used in `AddField()` and `RUpdater::AddField()`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx:6,wrap,wrapper,6,tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx,1,['wrap'],['wrapper']
Integrability,"/// A wrapper pass around a callback which can be used to populate the; /// AAResults in the AAResultsWrapperPass from an external AA.; ///; /// The callback provided here will be used each time we prepare an AAResults; /// object, and will receive a reference to the function wrapper pass, the; /// function, and the AAResults object to populate. This should be used when; /// setting up a custom pass pipeline to inject a hook into the AA results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,3,"['inject', 'wrap']","['inject', 'wrapper']"
Integrability,/// A wrapper pass for external alias analyses. This just squirrels away the; /// callback used to run any analyses and register their results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['wrap'],['wrapper']
Integrability,/// A wrapper pass to provide the legacy pass manager access to a suitably; /// prepared AAResults object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['wrap'],['wrapper']
Integrability,/// A wrapper predicate designed for use with std::remove_if.; ///; /// This predicate wraps a predicate suitable for use with std::remove_if to; /// call M.erase(x) on each element which is slated for removal. This just; /// allows the predicate to be move only which we can't do with lambdas; /// today.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h,2,['wrap'],"['wrapper', 'wraps']"
Integrability,/// A wrapper predicate designed for use with std::remove_if.; ///; /// This predicate wraps a predicate suitable for use with std::remove_if to; /// call set_.erase(x) on each element which is slated for removal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:6,wrap,wrapper,6,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,2,['wrap'],"['wrapper', 'wraps']"
Integrability,/// A wrapper struct around the 'MachineOperand' struct that includes a source; /// range and other attributes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:6,wrap,wrapper,6,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,1,['wrap'],['wrapper']
Integrability,"/// AArch32 uses stubs for a number of purposes, like branch range extension; /// or interworking between Arm and Thumb instruction subsets.; ///; /// Stub implementations vary depending on CPU architecture (v4, v6, v7),; /// instruction subset and branch type (absolute/PC-relative).; ///; /// For each kind of stub, the StubsFlavor defines one concrete form that is; /// used throughout the LinkGraph.; ///; /// Stubs are often called ""veneers"" in the official docs and online.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch32.h:177,depend,depending,177,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch32.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch32.h,1,['depend'],['depending']
Integrability,"/// API to communicate dependencies between analyses during invalidation.; ///; /// When an analysis result embeds handles to other analysis results, it; /// needs to be invalidated both when its own information isn't preserved and; /// when any of its embedded analysis results end up invalidated. We pass an; /// \c Invalidator object as an argument to \c invalidate() in order to let; /// the analysis results themselves define the dependency graph on the fly.; /// This lets us avoid building an explicit representation of the; /// dependencies between analysis results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:23,depend,dependencies,23,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,3,['depend'],"['dependencies', 'dependency']"
Integrability,/// ARM EHABI Section 6.2 - The generic model; ///; /// An exception-handling table entry for the generic model is laid out as:; ///; /// 3 3; /// 1 0 0; /// +-+------------------------------+; /// |0| personality routine offset |; /// +-+------------------------------+; /// | personality routine data ... |; ///; ///; /// ARM EHABI Section 6.3 - The ARM-defined compact model; ///; /// An exception-handling table entry for the compact model looks like:; ///; /// 3 3 2 2 2 2; /// 1 0 8 7 4 3 0; /// +-+---+----+-----------------------+; /// |1| 0 | Ix | data for pers routine |; /// +-+---+----+-----------------------+; /// | more personality routine data |,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h:214,rout,routine,214,interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h,4,['rout'],['routine']
Integrability,/// ARM-defined Personality Routine Index,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ARMEHABI.h:28,Rout,Routine,28,interpreter/llvm-project/llvm/include/llvm/Support/ARMEHABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ARMEHABI.h,1,['Rout'],['Routine']
Integrability,"/// ASTConsumer - This is an abstract interface that should be implemented by; /// clients that read ASTs. This abstraction layer allows the client to be; /// independent of the AST producer (e.g. parser vs AST dump file reader, etc).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTConsumer.h:38,interface,interface,38,interpreter/llvm-project/clang/include/clang/AST/ASTConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTConsumer.h,1,['interface'],['interface']
Integrability,"/// Abbrev IDs initialized in the block info block.; /// Note: depending on the container type, some IDs might be uninitialized.; /// Warning: When adding more abbrev IDs, make sure to update the; /// BlockCodeSize (in the call to EnterSubblock).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/BitstreamRemarkSerializer.h:63,depend,depending,63,interpreter/llvm-project/llvm/include/llvm/Remarks/BitstreamRemarkSerializer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/BitstreamRemarkSerializer.h,1,['depend'],['depending']
Integrability,/// Abstract Attribute dependency graph,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:23,depend,dependency,23,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['depend'],['dependency']
Integrability,/// Abstract State interface; ///{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:19,interface,interface,19,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['interface'],['interface']
Integrability,/// Abstract base interface for LS (load/store) units in llvm-mca.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:18,interface,interface,18,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['interface'],['interface']
Integrability,/// Abstract interface for a consumer of code-completion; /// information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:13,interface,interface,13,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['interface'],['interface']
Integrability,"/// Abstract interface for a module loader.; ///; /// This abstract interface describes a module loader, which is responsible; /// for resolving a module name (e.g., ""std"") to an actual module file, and; /// then loading that module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h:13,interface,interface,13,interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,2,['interface'],['interface']
Integrability,"/// Abstract interface for callback invocations by the ASTReader.; ///; /// While reading an AST file, the ASTReader will call the methods of the; /// listener to pass on specific information. Some of the listener methods can; /// return true to indicate to the ASTReader that the information (and; /// consequently the AST file) is invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:13,interface,interface,13,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['interface'],['interface']
Integrability,"/// Abstract interface for external sources of AST nodes.; ///; /// External AST sources provide AST nodes constructed from some; /// external source, such as a precompiled header. External AST; /// sources can resolve types and declarations from abstract IDs into; /// actual type and declaration nodes, and read parts of declaration; /// contexts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h:13,interface,interface,13,interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,1,['interface'],['interface']
Integrability,/// Abstract interface for external sources of preprocessor; /// information.; ///; /// This abstract class allows an external sources (such as the \c ASTReader); /// to provide additional preprocessing information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ExternalPreprocessorSource.h:13,interface,interface,13,interpreter/llvm-project/clang/include/clang/Lex/ExternalPreprocessorSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ExternalPreprocessorSource.h,1,['interface'],['interface']
Integrability,"/// Abstract interface for implementation execution of LLVM modules,; /// designed to support both interpreter and just-in-time (JIT) compiler; /// implementations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:13,interface,interface,13,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['interface'],['interface']
Integrability,"/// Abstract interface for introducing a FileManager cache for 'stat'; /// system calls, which is used by precompiled and pretokenized headers to; /// improve performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileSystemStatCache.h:13,interface,interface,13,interpreter/llvm-project/clang/include/clang/Basic/FileSystemStatCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileSystemStatCache.h,1,['interface'],['interface']
Integrability,/// Abstract interface for registering debug objects in the executor process.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDebugObjectRegistrar.h:13,interface,interface,13,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDebugObjectRegistrar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDebugObjectRegistrar.h,1,['interface'],['interface']
Integrability,/// Abstract interface of slot tracker storage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSlotTracker.h:13,interface,interface,13,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSlotTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSlotTracker.h,1,['interface'],['interface']
Integrability,"/// Abstract interface to create a RVirtualCanvasPainter implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RVirtualCanvasPainter.hxx:13,interface,interface,13,graf2d/gpadv7/inc/ROOT/RVirtualCanvasPainter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RVirtualCanvasPainter.hxx,1,['interface'],['interface']
Integrability,"/// Abstract interface, implemented by clients of the front-end, which; /// formats and prints fully processed diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:13,interface,interface,13,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['interface'],['interface']
Integrability,"/// AbstractCallSite; ///; /// An abstract call site is a wrapper that allows to treat direct,; /// indirect, and callback calls the same. If an abstract call site; /// represents a direct or indirect call site it behaves like a stripped; /// down version of a normal call site object. The abstract call site can; /// also represent a callback call, thus the fact that the initially; /// called function (=broker) may invoke a third one (=callback callee).; /// In this case, the abstract call site hides the middle man, hence the; /// broker function. The result is a representation of the callback call,; /// inside the broker, but in the context of the original call to the broker.; ///; /// There are up to three functions involved when we talk about callback call; /// sites. The caller (1), which invokes the broker function. The broker; /// function (2), that will invoke the callee zero or more times. And finally; /// the callee (3), which is the target of the callback call.; ///; /// The abstract call site will handle the mapping from parameters to arguments; /// depending on the semantic of the broker function. However, it is important; /// to note that the mapping is often partial. Thus, some arguments of the; /// call/invoke instruction are mapped to parameters of the callee while others; /// are not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/AbstractCallSite.h:58,wrap,wrapper,58,interpreter/llvm-project/llvm/include/llvm/IR/AbstractCallSite.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/AbstractCallSite.h,2,"['depend', 'wrap']","['depending', 'wrapper']"
Integrability,"/// Access the wrapped object and allow to call its methods.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:15,wrap,wrapped,15,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,1,['wrap'],['wrapped']
Integrability,"/// Accumulate the constant address offset of this GEP if possible.; ///; /// This routine accepts an APInt into which it will accumulate the constant; /// offset of this GEP if the GEP is in fact constant. If the GEP is not; /// all-constant, it returns false and the value of the offset APInt is; /// undefined (it is *not* preserved!). The APInt passed into this routine; /// must be at least as wide as the IntPtr type for the address space of; /// the base GEP pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:83,rout,routine,83,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['rout'],['routine']
Integrability,"/// Accumulate the constant address offset of this GEP if possible.; ///; /// This routine accepts an APInt into which it will try to accumulate the; /// constant offset of this GEP.; ///; /// If \p ExternalAnalysis is provided it will be used to calculate a offset; /// when a operand of GEP is not constant.; /// For example, for a value \p ExternalAnalysis might try to calculate a; /// lower bound. If \p ExternalAnalysis is successful, it should return true.; ///; /// If the \p ExternalAnalysis returns false or the value returned by \p; /// ExternalAnalysis results in a overflow/underflow, this routine returns; /// false and the value of the offset APInt is undefined (it is *not*; /// preserved!).; ///; /// The APInt passed into this routine must be at exactly as wide as the; /// IntPtr type for the address space of the base GEP pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Operator.h:83,rout,routine,83,interpreter/llvm-project/llvm/include/llvm/IR/Operator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Operator.h,3,['rout'],['routine']
Integrability,/// Act on the result of classifying a name as an undeclared member of a; /// dependent base class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:78,depend,dependent,78,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['depend'],['dependent']
Integrability,/// ActOnCapScopeReturnStmt - Utility routine to type-check return statements; /// for capturing scopes.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:38,rout,routine,38,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['rout'],['routine']
Integrability,"/// ActOnConversionDeclarator - Called by ActOnDeclarator to complete; /// the declaration of the given C++ conversion function. This routine; /// is responsible for recording the conversion function in the C++; /// class, if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:134,rout,routine,134,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['rout'],['routine']
Integrability,/// ActOnDependentIdExpression - Handle a dependent id-expression that; /// was just parsed. This is only possible with an explicit scope; /// specifier naming a dependent type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:42,depend,dependent,42,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,['depend'],['dependent']
Integrability,/// ActOnForwardProtocolDeclaration - Handle \@protocol foo;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:47,protocol,protocol,47,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocol']
Integrability,"/// ActOnInitializerError - Given that there was an error parsing an; /// initializer for the given declaration, try to at least re-establish; /// invariants such as whether a variable's type is either dependent or; /// complete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:202,depend,dependent,202,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"/// ActOnLastBitfield - This routine handles synthesized bitfields rules for; /// class and class extensions. For every class \@interface and class; /// extension \@interface, if the last ivar is a bitfield of any type,; /// then add an implicit `char :0` ivar to the end of that interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,rout,routine,29,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,4,"['interface', 'rout']","['interface', 'routine']"
Integrability,"/// ActOnPragmaFPContract - Called on well formed; /// \#pragma {STDC,OPENCL} FP_CONTRACT and; /// \#pragma clang fp contract",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:117,contract,contract,117,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['contract'],['contract']
Integrability,/// ActOnPropertyImplDecl - This routine performs semantic checks and; /// builds the AST node for a property implementation declaration; declared; /// as \@synthesize or \@dynamic.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:33,rout,routine,33,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['rout'],['routine']
Integrability,"/// ActOnStartOfObjCMethodDef - This routine sets up parameters; invisible; /// and user declared, in the method definition's AST.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:37,rout,routine,37,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['rout'],['routine']
Integrability,/// ActOnTypedefedProtocols - this action finds protocol list as part of the; /// typedef'ed use for a qualified super class and adds them to the list; /// of the protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:48,protocol,protocol,48,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,/// Adapt a InMemoryFile for VFS' File interface. The goal is to make; /// \p InMemoryFileAdaptor mimic as much as possible the behavior of; /// \p RealFile.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:39,interface,interface,39,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['interface'],['interface']
Integrability,/// Adapter to write values to a stream in a particular byte order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/EndianStream.h:4,Adapter,Adapter,4,interpreter/llvm-project/llvm/include/llvm/Support/EndianStream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/EndianStream.h,1,['Adapter'],['Adapter']
Integrability,/// Add RequiredPass into list of lower level passes required by pass P.; /// RequiredPass is run on the fly by Pass Manager when P requests it; /// through getAnalysis interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h:169,interface,interface,169,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,3,['interface'],['interface']
Integrability,/// Add RequiredPass into list of lower level passes required by pass P.; /// RequiredPass is run on the fly by Pass Manager when P requests it; /// through getAnalysis interface.; /// This should be handled by specific pass manager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:169,interface,interface,169,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['interface'],['interface']
Integrability,"/// Add Succ as a successor of this MachineBasicBlock. The Predecessors list; /// of Succ is automatically updated. The probability is not provided because; /// BPI is not available (e.g. -O0 is used), in which case edge probabilities; /// won't be used. Using this interface can save some space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:266,interface,interface,266,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,1,['interface'],['interface']
Integrability,/// Add a DAG edge to the given SU with the given predecessor; /// dependence data.; ///; /// \returns true if the edge may be added without creating a cycle OR if an; /// equivalent edge already existed (false indicates failure).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:67,depend,dependence,67,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['depend'],['dependence']
Integrability,"/// Add a chain edge between a load and store if the store can be an; /// alias of the load on a subsequent iteration, i.e., a loop carried; /// dependence. This code is very similar to the code in ScheduleDAGInstrs; /// but that code doesn't create loop carried dependences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:145,depend,dependence,145,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['depend'],"['dependence', 'dependences']"
Integrability,/// Add a dependency \p Filename if it has not been seen before and; /// sawDependency() returns true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h:10,depend,dependency,10,interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,1,['depend'],['dependency']
Integrability,/// Add a node to the Registry: this is the interface between the plugin and; /// the executable.; ///; /// This function is exported by the executable and called by the plugin to; /// add a node to the executable's registry. Therefore it's not defined here; /// to avoid it being instantiated in the plugin and is instead defined in; /// the executable (see LLVM_INSTANTIATE_REGISTRY below).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Registry.h:44,interface,interface,44,interpreter/llvm-project/llvm/include/llvm/Support/Registry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Registry.h,1,['interface'],['interface']
Integrability,"/// Add a preprocessed function by giving the function a name,; /// a functional expression, and a string with a bracketed list of dependencies (eg ""SigXsecOverSM[0,3]"")",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Measurement.cxx:131,depend,dependencies,131,roofit/histfactory/src/Measurement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Measurement.cxx,1,['depend'],['dependencies']
Integrability,/// Add a small namespace to avoid name clashes with the classes used in; /// the streaming interface. We want these to be short for better; /// write/readability.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:92,interface,interface,92,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,1,['interface'],['interface']
Integrability,"/// Add a space in front of an Objective-C protocol list, i.e. use; /// ``Foo <Protocol>`` instead of ``Foo<Protocol>``.; /// \version 3.7",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:43,protocol,protocol,43,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,3,"['Protocol', 'protocol']","['Protocol', 'protocol']"
Integrability,/// Add a target-dependent attribute. Returns a new set because attribute sets; /// are immutable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h:17,depend,dependent,17,interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,1,['depend'],['dependent']
Integrability,"/// Add a variable that might potentially be captured by the; /// lambda and therefore the enclosing lambdas.; ///; /// This is also used by enclosing lambda's to speculatively capture; /// variables that nested lambda's - depending on their enclosing; /// specialization - might need to capture.; /// Consider:; /// void f(int, int); <-- don't capture; /// void f(const int&, double); <-- capture; /// void foo() {; /// const int x = 10;; /// auto L = [=](auto a) { // capture 'x'; /// return [=](auto b) {; /// f(x, a); // we may or may not need to capture 'x'; /// };; /// };; /// }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h:223,depend,depending,223,interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,1,['depend'],['depending']
Integrability,/// Add all of the Objective-C interface declarations that we find in; /// the given (translation unit) context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:31,interface,interface,31,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['interface'],['interface']
Integrability,"/// Add all of the Objective-C methods in the given Objective-C; /// container to the set of results.; ///; /// The container will be a class, protocol, category, or implementation of; /// any of the above. This mether will recurse to include methods from; /// the superclasses of classes along with their categories, protocols, and; /// implementations.; ///; /// \param Container the container in which we'll look to find methods.; ///; /// \param WantInstanceMethods Whether to add instance methods (only); if; /// false, this routine will add factory methods (only).; ///; /// \param CurContext the context in which we're performing the lookup that; /// finds methods.; ///; /// \param AllowSameLength Whether we allow a method to be added to the list; /// when it has the same number of parameters as we have selector identifiers.; ///; /// \param Results the structure into which we'll add results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:143,protocol,protocol,143,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,3,"['protocol', 'rout']","['protocol', 'protocols', 'routine']"
Integrability,/// Add all of the protocol declarations that we find in the given; /// (translation unit) context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,protocol,protocol,19,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['protocol'],['protocol']
Integrability,"/// Add an error to the diagnostics.; ///; /// All the context information will be kept on the error message.; /// \return a helper class to allow the caller to pass the arguments for the; /// error message, using the << operator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h:101,message,message,101,interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h,2,['message'],['message']
Integrability,/// Add artificial symbol dependency.; ///; /// The dependent symbol should stay alive as long as the primary is alive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h:26,depend,dependency,26,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,2,['depend'],"['dependency', 'dependent']"
Integrability,"/// Add attributes to \p Var which reflect the common attributes of \p; /// VariableDie, namely those which are not dependant on the active variant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:116,depend,dependant,116,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,1,['depend'],['dependant']
Integrability,"/// Add called function \p F with samples \p S.; /// Optionally scale sample count \p S by \p Weight.; ///; /// Sample counts accumulate using saturating arithmetic, to avoid wrapping; /// around unsigned integers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:175,wrap,wrapping,175,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['wrap'],['wrapping']
Integrability,/// Add dependencies that apply to all symbols covered by this instance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:8,depend,dependencies,8,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['depend'],['dependencies']
Integrability,/// Add function candidates found via argument-dependent lookup; /// to the set of overloading candidates.; ///; /// This routine performs argument-dependent name lookup based on the; /// given function name (which may also be an operator name) and adds; /// all of the overload candidates found by ADL to the overload; /// candidate set (C++ [basic.lookup.argdep]).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:47,depend,dependent,47,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,3,"['depend', 'rout']","['dependent', 'routine']"
Integrability,"/// Add information about a specific Objective-C class or protocol or a C++; /// namespace.; ///; /// \param Name The name of this class/protocol/namespace.; /// \param Kind Whether this is a class, a protocol, or a namespace.; /// \param Info Information about this class/protocol/namespace.; ///; /// \returns the ID of the class, protocol, or namespace, which can be used to; /// add properties and methods to the class/protocol/namespace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesWriter.h:58,protocol,protocol,58,interpreter/llvm-project/clang/include/clang/APINotes/APINotesWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesWriter.h,6,['protocol'],['protocol']
Integrability,"/// Add link options implied by the given module, including modules; /// it depends on, using a postorder walk.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:76,depend,depends,76,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['depend'],['depends']
Integrability,/// Add location info to ORE message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:29,message,message,29,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,1,['message'],['message']
Integrability,/// Add paths that require looking up outputs to the given dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:59,depend,dependencies,59,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,1,['depend'],['dependencies']
Integrability,"/// Add synthesized debug information to a module.; ///; /// \param M The module to add debug information to.; /// \param Functions A range of functions to add debug information to.; /// \param Banner A prefix string to add to debug/error messages.; /// \param ApplyToMF A call back that will add debug information to the; /// MachineFunction for a Function. If nullptr, then the; /// MachineFunction (if any) will not be modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:239,message,messages,239,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,1,['message'],['messages']
Integrability,/// Add the clang cc1 arguments for system include paths.; ///; /// This routine is responsible for adding the necessary cc1 arguments to; /// include headers from standard system header directories.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h:73,rout,routine,73,interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,1,['rout'],['routine']
Integrability,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:258,rout,routines,258,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,5,"['depend', 'inject', 'rout']","['dependencies', 'injecting', 'routine', 'routines']"
Integrability,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:258,rout,routines,258,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,6,"['depend', 'inject', 'rout']","['dependencies', 'injecting', 'injection', 'routine', 'routines']"
Integrability,"/// Add the declaration D into this context.; ///; /// This routine should be invoked when the declaration D has first; /// been declared, to place D into the context where it was; /// (lexically) defined. Every declaration must be added to one; /// (and only one!) context, where it can be visited via; /// [decls_begin(), decls_end()). Once a declaration has been added; /// to its lexical context, the corresponding DeclContext owns the; /// declaration.; ///; /// If D is also a NamedDecl, it will be made visible within its; /// semantic context via makeDeclVisibleInContext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:60,rout,routine,60,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['rout'],['routine']
Integrability,/// Add the declaration D to this context without modifying; /// any lookup tables.; ///; /// This is useful for some operations in dependent contexts where; /// the semantic context might not be dependent; this basically; /// only happens with friends.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:132,depend,dependent,132,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,2,['depend'],['dependent']
Integrability,"/// Add the extra weight 'RHS' to the existing weight 'LHS',; /// reducing the combined weight using any special properties of the operation.; /// The existing weight LHS represents the computation X op X op ... op X where; /// X occurs LHS times. The combined weight represents X op X op ... op X with; /// X occurring LHS + RHS times. If op is ""Xor"" for example then the combined; /// operation is equivalent to X if LHS + RHS is odd, or 0 if LHS + RHS is even;; /// the routine returns 1 in LHS in the first case, and 0 in LHS in the second.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:473,rout,routine,473,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['rout'],['routine']
Integrability,"/// Add the given statement or expression to the queue of; /// statements to emit.; ///; /// This routine should be used when emitting types and declarations; /// that have expressions as part of their formulation. Once the; /// type or declaration has been written, Emit() will write; /// the corresponding statements just after the record.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTRecordWriter.h:98,rout,routine,98,interpreter/llvm-project/clang/include/clang/Serialization/ASTRecordWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTRecordWriter.h,1,['rout'],['routine']
Integrability,/// Add the overload candidates named by callee and/or found by argument; /// dependent lookup to the given overload set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:78,depend,dependent,78,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['depend'],['dependent']
Integrability,/// Add the target-dependent attribute to the builder.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/AttributeMask.h:19,depend,dependent,19,interpreter/llvm-project/llvm/include/llvm/IR/AttributeMask.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/AttributeMask.h,2,['depend'],['dependent']
Integrability,"/// AddImplicitlyDeclaredMembersToClass - Adds any implicitly-declared; /// special functions, such as the default constructor, copy; /// constructor, or destructor, to the given C++ class (C++; /// [special]p1). This routine can only be executed just before the; /// definition of the class is complete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:218,rout,routine,218,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['rout'],['routine']
Integrability,"/// AddInstanceMethodToGlobalPool - All instance methods in a translation; /// unit are added to a global pool. This allows us to efficiently associate; /// a selector with a method declaraation for purposes of typechecking; /// messages sent to ""id"" (where the class of the object is unknown).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:229,message,messages,229,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['message'],['messages']
Integrability,"/// AddMemberPointerWithMoreQualifiedTypeVariants - Add the pointer type @p Ty; /// to the set of pointer types along with any more-qualified variants of; /// that type. For example, if @p Ty is ""int const *"", this routine; /// will add ""int const *"", ""int const volatile *"", ""int const; /// restrict *"", and ""int const volatile restrict *"" to the set of; /// pointer types. Returns true if the add of @p Ty itself succeeded,; /// false otherwise.; ///; /// FIXME: what to do about extended qualifiers?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:215,rout,routine,215,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['rout'],['routine']
Integrability,/// AddNodeIDNode - Generic routine for adding a nodes info to the NodeID; /// data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:28,rout,routine,28,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['rout'],['routine']
Integrability,/// AddNodeIDOperands - Various routines for adding operands to the NodeID data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:32,rout,routines,32,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,2,['rout'],['routines']
Integrability,/// Additional information about Order dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:39,depend,dependencies,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['depend'],['dependencies']
Integrability,/// Additional paths to search for `.include` directives when using the; /// integrated assembler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCTargetOptions.h:77,integrat,integrated,77,interpreter/llvm-project/llvm/include/llvm/MC/MCTargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCTargetOptions.h,1,['integrat'],['integrated']
Integrability,"/// Adds \p Inst into a partition that is not marked to contain; /// dependence cycles.; ///; // Initially we isolate memory instructions into as many partitions as; // possible, then later we may merge them back together.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:69,depend,dependence,69,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,1,['depend'],['dependence']
Integrability,/// Adds a MaterializationUnit for the object file in the given memory buffer; /// to the JITDylib for the given ResourceTracker. The interface for the; /// object will be built using the default object interface builder.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h:134,interface,interface,134,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h,2,['interface'],['interface']
Integrability,/// Adds a MaterializationUnit for the object file in the given memory buffer; /// to the given JITDylib. The interface for the object will be built using; /// the default object interface builder.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h:110,interface,interface,110,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h,2,['interface'],['interface']
Integrability,"/// Adds a chain edge between SUa and SUb, but only if both; /// AAResults and Target fail to deny the dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:103,depend,dependency,103,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['depend'],['dependency']
Integrability,"/// Adds a new ENDBR instruction to the beginning of the MBB.; /// The function will not add it if already exists.; /// It will add ENDBR32 or ENDBR64 opcode, depending on the target.; /// \returns true if the ENDBR was added and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectBranchTracking.cpp:159,depend,depending,159,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectBranchTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectBranchTracking.cpp,1,['depend'],['depending']
Integrability,"/// Adds a new replacement \p R to the current set of replacements.; /// \p R must have the same file path as all existing replacements.; /// Returns `success` if the replacement is successfully inserted; otherwise,; /// it returns an llvm::Error, i.e. there is a conflict between R and the; /// existing replacements (i.e. they are order-dependent) or R's file path is; /// different from the filepath of existing replacements. Callers must; /// explicitly check the Error returned, and the returned error can be; /// converted to a string message with `llvm::toString()`. This prevents users; /// from adding order-dependent replacements. To control the order in which; /// order-dependent replacements are applied, use merge({R}) with R referring; /// to the changed code after applying all existing replacements.; /// Two replacements A and B are considered order-independent if applying them; /// in either order produces the same result. Note that the range of the; /// replacement that is applied later still refers to the original code.; /// These include (but not restricted to) replacements that:; /// - don't overlap (being directly adjacent is fine) and; /// - are overlapping deletions.; /// - are insertions at the same offset and applying them in either order; /// has the same effect, i.e. X + Y = Y + X when inserting X and Y; /// respectively.; /// - are identical replacements, i.e. applying the same replacement twice; /// is equivalent to applying it once.; /// Examples:; /// 1. Replacement A(0, 0, ""a"") and B(0, 0, ""aa"") are order-independent since; /// applying them in either order gives replacement (0, 0, ""aaa"").; /// However, A(0, 0, ""a"") and B(0, 0, ""b"") are order-dependent since; /// applying A first gives (0, 0, ""ab"") while applying B first gives (B, A,; /// ""ba"").; /// 2. Replacement A(0, 2, ""123"") and B(0, 2, ""123"") are order-independent; /// since applying them in either order gives (0, 2, ""123"").; /// 3. Replacement A(0, 3, ""123"") and B(2, 3, ""321"") are order-",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:339,depend,dependent,339,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,4,"['depend', 'message']","['dependent', 'message']"
Integrability,"/// Adds a register data dependency if the instruction that defines the; /// virtual register used at OperIdx is mapped to an SUnit. Add a register; /// antidependency from this SUnit to instructions that occur later in the same; /// scheduling region if they write the virtual register.; ///; /// TODO: Handle ExitSU ""uses"" properly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:25,depend,dependency,25,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['depend'],['dependency']
Integrability,"/// Adds a replacement that inserts \p Text at \p Loc. If this; /// insertion conflicts with an existing insertion (at the same position),; /// this will be inserted before/after the existing insertion depending on; /// \p InsertAfter. Users should use `replace` with `Length=0` instead if they; /// do not want conflict resolving by default. If the conflicting replacement; /// is not an insertion, an error is returned.; ///; /// \returns An llvm::Error carrying ReplacementError on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:202,depend,depending,202,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,1,['depend'],['depending']
Integrability,/// Adds all constraints of the flow condition identified by `Token` and all; /// of its transitive dependencies to `Constraints`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysisContext.h:100,depend,dependencies,100,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysisContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysisContext.h,1,['depend'],['dependencies']
Integrability,"/// Adds an appropriate access operator (`.`, `->` or nothing, in the case of; /// implicit `this`) to the end of the given expression. Adds parentheses when; /// needed by the syntax and simplifies when possible. If `PLTypeClass` is; /// `Pointer`, for known pointer-like types (see `isKnownPointerLikeType`),; /// treats `operator->` and `operator*` like the built-in `->` and `*`; /// operators.; ///; /// `x` becomes `x->` or `x.`, depending on `E`'s type; /// `a+b` becomes `(a+b)->` or `(a+b).`, depending on `E`'s type; /// `&a` becomes `a.`; /// `*a` becomes `a->`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h:436,depend,depending,436,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,2,['depend'],['depending']
Integrability,"/// Adds an initializer symbol to the given MU interface.; /// The init symbol's name is guaranteed to be unique within I, and will be of; /// the form $.<ObjFileName>.__inits.<N>, where N is some integer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ObjectFileInterface.h:47,interface,interface,47,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ObjectFileInterface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ObjectFileInterface.h,1,['interface'],['interface']
Integrability,/// Adds dependencies as needed from all SUs in list to SU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:9,depend,dependencies,9,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['depend'],['dependencies']
Integrability,"/// Adds dependencies as needed from all SUs in map, to SU.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:9,depend,dependencies,9,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['depend'],['dependencies']
Integrability,"/// Adds dependencies as needed to SU, from all SUs mapped to V.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:9,depend,dependencies,9,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['depend'],['dependencies']
Integrability,/// Adds dependencies from instructions in the current list of; /// instructions being scheduled to scheduling barrier. We want to make sure; /// instructions which define registers that are either used by the; /// terminator or are live-out are properly scheduled. This is especially; /// important when the definition latency of the return value(s) are too; /// high to be hidden by the branch or when the liveout registers used by; /// instructions in the fallthrough block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:9,depend,dependencies,9,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['depend'],['dependencies']
Integrability,/// Adds direct modular dependencies that have already been built to the; /// ModuleDeps instance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:24,depend,dependencies,24,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,1,['depend'],['dependencies']
Integrability,"/// Adds helper function decls and wrapper functions that call the helper with; /// some additional prefix arguments.; ///; /// E.g. For wrapper ""foo"" with type i8(i8, i64), helper ""bar"", and prefix; /// args i32 4 and i16 12345, this function will add:; ///; /// declare i8 @bar(i32, i16, i8, i64); ///; /// define i8 @foo(i8, i64) {; /// entry:; /// %2 = call i8 @bar(i32 4, i16 12345, i8 %0, i64 %1); /// ret i8 %2; /// }; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:35,wrap,wrapper,35,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,2,['wrap'],['wrapper']
Integrability,"/// Adds register dependencies (data, anti, and output) from this SUnit; /// to following instructions in the same scheduling region that depend the; /// physical register referenced at OperIdx.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:18,depend,dependencies,18,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,2,['depend'],"['depend', 'dependencies']"
Integrability,"/// Adds register output and data dependencies from this SUnit to instructions; /// that occur later in the same scheduling region if they read from or write to; /// the virtual register defined at OperIdx.; ///; /// TODO: Hoist loop induction variable increments. This has to be; /// reevaluated. Generally, IV scheduling should be done before coalescing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:34,depend,dependencies,34,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['depend'],['dependencies']
Integrability,/// Adds replacements that are needed when the token is broken. Such as; /// wrapping a JavaScript string in parentheses after it gets broken with plus; /// signs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:77,wrap,wrapping,77,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h,1,['wrap'],['wrapping']
Integrability,"/// Adds the generated MemCheckBlock before \p LoopVectorPreHeader and adjusts; /// the branches to branch to the vector preheader or \p Bypass, depending on; /// the generated condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:145,depend,depending,145,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['depend'],['depending']
Integrability,"/// Adds the generated SCEVCheckBlock before \p LoopVectorPreHeader and; /// adjusts the branches to branch to the vector preheader or \p Bypass,; /// depending on the generated condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:151,depend,depending,151,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['depend'],['depending']
Integrability,"/// After substituting deduced template arguments, a dependent; /// parameter type did not match the corresponding argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:53,depend,dependent,53,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['depend'],['dependent']
Integrability,"/// After substituting deduced template arguments, an element of; /// a dependent parameter type did not match the corresponding element; /// of the corresponding argument (when deducing from an initializer list).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:72,depend,dependent,72,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['depend'],['dependent']
Integrability,/// Agent synchronization scope ID (single address space).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineModuleInfo.h:10,synchroniz,synchronization,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineModuleInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineModuleInfo.h,1,['synchroniz'],['synchronization']
Integrability,/// All of the protocols that have been declared.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:15,protocol,protocols,15,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['protocol'],['protocols']
Integrability,/// All the thread wrapper functions that have been used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:19,wrap,wrapper,19,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['wrap'],['wrapper']
Integrability,"/// Allocate an uninitialized TypeSourceInfo.; ///; /// The caller should initialize the memory held by TypeSourceInfo using; /// the TypeLoc wrappers.; ///; /// \param T the type that will be the basis for type source info. This type; /// should refer to how the declarator was written in source code, not to; /// what type semantic analysis resolved the declarator to.; ///; /// \param Size the size of the type info to create, or 0 if the size; /// should be calculated based on the type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:142,wrap,wrappers,142,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['wrap'],['wrappers']
Integrability,/// Allocate memory for a deserialized declaration.; ///; /// This routine must be used to allocate memory for any declaration that is; /// deserialized from a module file.; ///; /// \param Size The size of the allocated object.; /// \param Ctx The context in which we will allocate memory.; /// \param ID The global ID of the deserialized declaration.; /// \param Extra The amount of extra space to allocate after the object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:67,rout,routine,67,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['rout'],['routine']
Integrability,/// Allocated API-exposed wrappters for Diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:26,wrap,wrappters,26,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,1,['wrap'],['wrappters']
Integrability,/// Allocator - The wrapped allocator.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/RecyclingAllocator.h:20,wrap,wrapped,20,interpreter/llvm-project/llvm/include/llvm/Support/RecyclingAllocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/RecyclingAllocator.h,1,['wrap'],['wrapped']
Integrability,"/// Allow non-dependent types to differ, e.g., when performing; /// template argument deduction from a function call where conversions; /// may apply.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:14,depend,dependent,14,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,"/// Allow standard passes to be disabled by the command line, regardless of who; /// is adding the pass.; ///; /// StandardID is the pass identified in the standard pass pipeline and provided; /// to addPass(). It may be a target-specific ID in the case that the target; /// directly adds its own pass, but in that case we harmlessly fall through.; ///; /// TargetID is the pass that the target has configured to override StandardID.; ///; /// StandardID may be a pseudo ID. In that case TargetID is the name of the real; /// pass to run. This allows multiple options to control a single pass depending; /// on where in the pipeline that pass is added.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:593,depend,depending,593,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['depend'],['depending']
Integrability,"/// AllowFPOpFusion - This flag is set by the -fp-contract=xxx option.; /// This controls the creation of fused FP ops that store intermediate; /// results in higher precision than IEEE allows (E.g. FMAs).; ///; /// Fast mode - allows formation of fused FP ops whenever they're; /// profitable.; /// Standard mode - allow fusion only for 'blessed' FP ops. At present the; /// only blessed op is the fmuladd intrinsic. In the future more blessed ops; /// may be added.; /// Strict mode - allow fusion only if/when it can be proven that the excess; /// precision won't effect the result.; ///; /// Note: This option only controls formation of fused ops by the; /// optimizers. Fused operations that are explicitly specified (e.g. FMA; /// via the llvm.fma.* intrinsic) will always be honored, regardless of; /// the value of this option.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:50,contract,contract,50,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['contract'],['contract']
Integrability,"/// Allows the conversion of a \c Matcher<Type> to a \c; /// Matcher<QualType>.; ///; /// Depending on the constructor argument, the matcher is either strict, i.e.; /// does only matches in the absence of qualifiers, or not, i.e. simply; /// ignores any qualifiers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h:90,Depend,Depending,90,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,1,['Depend'],['Depending']
Integrability,"/// Allows the target to handle physreg-carried dependency; /// in target-specific way. Used from the ScheduleDAGSDNodes to decide whether; /// to add the edge to the dependency graph.; /// Def - input: Selection DAG node defininfg physical register; /// User - input: Selection DAG node using physical register; /// Op - input: Number of User operand; /// PhysReg - inout: set to the physical register if the edge is; /// necessary, unchanged otherwise; /// Cost - inout: physical register copy cost.; /// Returns 'true' is the edge is necessary, 'false' otherwise",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:48,depend,dependency,48,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['depend'],['dependency']
Integrability,/// Always wrap braces after a control statement.; /// \code; /// if (foo()); /// {; /// } else; /// {}; /// for (int i = 0; i < 10; ++i); /// {}; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:11,wrap,wrap,11,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['wrap'],['wrap']
Integrability,"/// An ELF note.; ///; /// Wraps a note header, providing methods for accessing the name and; /// descriptor safely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h:27,Wrap,Wraps,27,interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,1,['Wrap'],['Wraps']
Integrability,"/// An Iterator adapter using an InnerInvGraphT::iterator as a base iterator,; /// and storing the VertexIdentifier the iterator range comes from. The; /// dereference operator is then performed using a pointer to the graph's edge; /// set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:16,adapter,adapter,16,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,1,['adapter'],['adapter']
Integrability,"/// An Objective-C ""bridged"" cast expression, which casts between; /// Objective-C pointers and C pointers, transferring ownership in the process.; ///; /// \code; /// NSString *str = (__bridge_transfer NSString *)CFCreateString();; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:20,bridg,bridged,20,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,1,['bridg'],['bridged']
Integrability,/// An Objective-C object type followed by '<' is a specialization of; /// a parameterized class type or a protocol-qualified type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:107,protocol,protocol-qualified,107,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,2,['protocol'],['protocol-qualified']
Integrability,"/// An RAII wrapper used for the read-only access to `RPageSource::fDescriptor`. See `GetExclDescriptorGuard()``.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:12,wrap,wrapper,12,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['wrap'],['wrapper']
Integrability,"/// An RAII wrapper used for the writable access to `RPageSource::fDescriptor`. See `GetSharedDescriptorGuard()`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:12,wrap,wrapper,12,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['wrap'],['wrapper']
Integrability,"/// An RAII wrapper used to synchronize a page sink. See GetSinkGuard().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:12,wrap,wrapper,12,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,2,"['synchroniz', 'wrap']","['synchronize', 'wrapper']"
Integrability,/// An abstract interface for address space information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract interface for all align attributes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract interface for all dereferenceable attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract interface for all memory location attributes; /// (readnone/argmemonly/inaccessiblememonly/inaccessibleorargmemonly).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract interface for all noalias attributes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract interface for all nocapture attributes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract interface for all nonnull attributes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,2,['interface'],['interface']
Integrability,/// An abstract interface for all noundef attributes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract interface for indirect call information interference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract interface for liveness abstract attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract interface for llvm::GlobalValue information interference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract interface for memory access kind related attributes; /// (readnone/readonly/writeonly).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,"/// An abstract interface for potential values analysis.; ///; /// This AA collects potential values for each IR position.; /// An assumed set of potential values is initialized with the empty set (the; /// best state) and it will grow monotonically as we find more potential values; /// for this position.; /// The set might be forced to the worst state, that is, to contain every; /// possible value for this position in 2 cases.; /// 1. We surpassed the \p MaxPotentialValues threshold. This includes the; /// case that this position is affected (e.g. because of an operation) by a; /// Value that is in the worst state.; /// 2. We tried to initialize on a Value that we cannot handle (e.g. an; /// operator we do not currently handle).; ///; /// For non constant integers see AAPotentialValues.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,"/// An abstract interface for privatizability.; ///; /// A pointer is privatizable if it can be replaced by a new, private one.; /// Privatizing pointer reduces the use count, interaction between unrelated; /// code parts.; ///; /// In order for a pointer to be privatizable its value cannot be observed; /// (=nocapture), it is (for now) not written (=readonly & noalias), we know; /// what values are necessary to make the private copy look like the original; /// one, and the values we need can be loaded (=dereferenceable).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract interface for range value analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract interface for struct information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract interface for value simplify abstract attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract interface that consumes the various refactoring results that can; /// be produced by refactoring actions.; ///; /// A valid refactoring result must be handled by a \c handle method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h:16,interface,interface,16,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h,1,['interface'],['interface']
Integrability,/// An abstract interface that should be implemented by listeners; /// that want to be notified when an AST entity gets modified after its; /// initial creation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTMutationListener.h:16,interface,interface,16,interpreter/llvm-project/clang/include/clang/AST/ASTMutationListener.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTMutationListener.h,1,['interface'],['interface']
Integrability,/// An abstract interface that should be implemented by; /// clients that read ASTs and then require further semantic; /// analysis of the entities in those ASTs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/SemaConsumer.h:16,interface,interface,16,interpreter/llvm-project/clang/include/clang/Sema/SemaConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/SemaConsumer.h,1,['interface'],['interface']
Integrability,/// An abstract interface that should be implemented by; /// external AST sources that also provide information for semantic; /// analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h:16,interface,interface,16,interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,2,['interface'],['interface']
Integrability,/// An abstract interface to determine reachability of point A to B.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,"/// An abstract interface to track if a value leaves it's defining function; /// instance.; /// TODO: We should make it a ternary AA tracking uniqueness, and uniqueness; /// wrt. the Attributor analysis separately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// An abstract representation of regular/ObjC call/message targets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:52,message,message,52,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['message'],['message']
Integrability,/// An abstract state for querying live call edges.; /// This interface uses the Attributor's optimistic liveness; /// information to compute the edges that are alive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:62,interface,interface,62,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,"/// An adapter for std::invoke_result that falls back to std::result_of if the former is not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/TypeTraits.hxx:7,adapter,adapter,7,core/foundation/inc/ROOT/TypeTraits.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/TypeTraits.hxx,1,['adapter'],['adapter']
Integrability,"/// An adapter that can be used to translate diagnostics from one or more; /// llvm::SourceMgr instances to a ,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceMgrAdapter.h:7,adapter,adapter,7,interpreter/llvm-project/clang/include/clang/Basic/SourceMgrAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceMgrAdapter.h,1,['adapter'],['adapter']
Integrability,"/// An alias for raw pointers for indicating that the return type of a RooFit; /// function is an owning pointer that must be deleted by the caller. For; /// RooFit developers, it can be very useful to make this an alias to; /// std::unique_ptr<T>, in order to check that your code has no memory; /// problems. Changing this alias is equivalent to forcing all code immediately; /// wraps the result of functions returning a RooFit::OwningPtr<T> in a; /// std::unique_ptr<T>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Config.h:382,wrap,wraps,382,roofit/roofitcore/inc/RooFit/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Config.h,1,['wrap'],['wraps']
Integrability,"/// An analysis over an ""inner"" IR unit that provides access to an; /// analysis manager over a ""outer"" IR unit. The inner unit must be contained; /// in the outer unit.; ///; /// For example OuterAnalysisManagerProxy<ModuleAnalysisManager, Function> is an; /// analysis over Functions (the ""inner"" unit) which provides access to a Module; /// analysis manager. The ModuleAnalysisManager is the ""outer"" manager being; /// proxied, and Modules are the ""outer"" IR unit. The inner/outer relationship; /// is valid because each Function is contained in one Module.; ///; /// This proxy only exposes the const interface of the outer analysis manager,; /// to indicate that you cannot cause an outer analysis to run from within an; /// inner pass. Instead, you must rely on the \c getCachedResult API. This is; /// due to keeping potential future concurrency in mind. To give an example,; /// running a module analysis before any function passes may give a different; /// result than running it in a function pass. Both may be valid, but it would; /// produce non-deterministic results. GlobalsAA is a good analysis example,; /// because the cached information has the mod/ref info for all memory for each; /// function at the time the analysis was computed. The information is still; /// valid after a function transformation, but it may be *different* if; /// recomputed after that transform. GlobalsAA is never invalidated.; ///; /// This proxy doesn't manage invalidation in any way -- that is handled by the; /// recursive return path of each layer of the pass manager. A consequence of; /// this is the outer analyses may be stale. We invalidate the outer analyses; /// only when we're done running passes over the inner IR units.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:605,interface,interface,605,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['interface'],['interface']
Integrability,/// An analysis pass which caches information about the Function.; /// Records the function level information used by GCRoots.; /// This pass depends on `CollectorMetadataAnalysis`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:142,depend,depends,142,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,1,['depend'],['depends']
Integrability,/// An asynchronous wrapper-function callable from the executor via; /// jit-dispatch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:20,wrap,wrapper-function,20,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['wrap'],['wrapper-function']
Integrability,"/// An atomic change is used to create and group a set of source edits,; /// e.g. replacements or header insertions. Edits in an AtomicChange should be; /// related, e.g. replacements for the same type reference and the corresponding; /// header insertion/deletion.; ///; /// An AtomicChange is uniquely identified by a key and will either be fully; /// applied or not applied at all.; ///; /// Calling setError on an AtomicChange stores the error message and marks it as; /// bad, i.e. none of its source edits will be applied.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:448,message,message,448,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,1,['message'],['message']
Integrability,"/// An edge in the solution space from \c Previous->State to \c State,; /// inserting a newline dependent on the \c NewLine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:96,depend,dependent,96,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['depend'],['dependent']
Integrability,"/// An error that has already been reported.; ///; /// This class is designed to support a function whose callers may need to know; /// whether the function encountered and reported an error but never need to; /// know the nature of that error. For example, the function has a return type; /// of \c Error and always returns either \c ErrorReported or \c ErrorSuccess.; /// That interface is similar to that of a function returning bool to indicate; /// an error except, in the former case, (1) there is no confusion over polarity; /// and (2) the caller must either check the result or explicitly ignore it with; /// a call like \c consumeError.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:379,interface,interface,379,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['interface'],['interface']
Integrability,"/// An expression that sends a message to the given Objective-C; /// object or class.; ///; /// The following contains two message send expressions:; ///; /// \code; /// [[NSString alloc] initWithString:@""Hello""]; /// \endcode; ///; /// The innermost message send invokes the ""alloc"" class method on the; /// NSString class, while the outermost message send invokes the; /// ""initWithString"" instance method on the object returned from; /// NSString's ""alloc"". In all, an Objective-C message send can take; /// on four different (although related) forms:; ///; /// 1. Send to an object instance.; /// 2. Send to a class.; /// 3. Send to the superclass instance of the current class.; /// 4. Send to the superclass of the current class.; ///; /// All four kinds of message sends are modeled by the ObjCMessageExpr; /// class, and can be distinguished via \c getReceiverKind(). Example:; ///; /// The ""void *"" trailing objects are actually ONE void * (the; /// receiver pointer), and NumArgs Expr *. But due to the; /// implementation of children(), these must be together contiguously.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:31,message,message,31,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,6,['message'],['message']
Integrability,"/// An in-memory representation of a file system entity that is of interest to; /// the dependency scanning filesystem.; ///; /// It represents one of the following:; /// - opened file with contents and a stat value,; /// - opened file with contents, directive tokens and a stat value,; /// - directory entry with its stat value,; /// - filesystem error.; ///; /// Single instance of this class can be shared across different filenames (e.g.; /// a regular file and a symlink). For this reason the status filename is empty; /// and is only materialized by \c EntryRef that knows the requested filename.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:88,depend,dependency,88,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['depend'],['dependency']
Integrability,"/// An individual dependency scanning worker that is able to run on its own; /// thread.; ///; /// The worker computes the dependencies for the input files by preprocessing; /// sources either using a fast mode where the source files are minimized, or; /// using the regular processing run.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:18,depend,dependency,18,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,2,['depend'],"['dependencies', 'dependency']"
Integrability,/// An input file. This is a symbol table wrapper that only exposes the; /// information that an LTO client should need in order to do symbol resolution.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h:42,wrap,wrapper,42,interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,1,['wrap'],['wrapper']
Integrability,/// An interface for Itanium __cxa_atexit interposer implementations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h:7,interface,interface,7,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,1,['interface'],['interface']
Integrability,/// An interface for a SAT solver that can be used by dataflow analyses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Solver.h:7,interface,interface,7,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Solver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Solver.h,1,['interface'],['interface']
Integrability,"/// An interface for accessing data in a stream-like format, but which; /// discourages copying. Instead of specifying a buffer in which to copy; /// data on a read, the API returns an ArrayRef to data owned by the stream's; /// implementation. Since implementations may not necessarily store data in a; /// single contiguous buffer (or even in memory at all), in such cases a it may; /// be necessary for an implementation to cache such a buffer so that it can; /// return it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStream.h:7,interface,interface,7,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStream.h,1,['interface'],['interface']
Integrability,/// An interface for collecting the dependencies of a compilation. Users should; /// use \c attachToPreprocessor and \c attachToASTReader to get all of the; /// dependencies.; /// FIXME: Migrate DependencyGraphGen to use this interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h:7,interface,interface,7,interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,5,"['Depend', 'depend', 'interface']","['DependencyGraphGen', 'dependencies', 'interface']"
Integrability,/// An interface for virtual file systems to provide an iterator over the; /// (non-recursive) contents of a directory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h:7,interface,interface,7,interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,1,['interface'],['interface']
Integrability,"/// An interface layer with SCEV used to manage how we see SCEV expressions; /// for values in the context of existing predicates. We can add new; /// predicates, but we cannot remove them.; ///; /// This layer has multiple purposes:; /// - provides a simple interface for SCEV versioning.; /// - guarantees that the order of transformations applied on a SCEV; /// expression for a single Value is consistent across two different; /// getSCEV calls. This means that, for example, once we've obtained; /// an AddRec expression for a certain value through expression; /// rewriting, we will continue to get an AddRec expression for that; /// Value.; /// - lowers the number of expression rewrites.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:7,interface,interface,7,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,2,['interface'],['interface']
Integrability,/// An interface that declares functions that handle different refactoring; /// option types.; ///; /// A valid refactoring option type must have a corresponding \c visit; /// declaration in this interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h:7,interface,interface,7,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h,2,['interface'],['interface']
Integrability,/// An interface that subclasses the \c RefactoringResultConsumer interface; /// that stores the reference to the TU-specific diagnostics engine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h:7,interface,interface,7,interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h,2,['interface'],['interface']
Integrability,/// An interface to create LLVM-IR for OpenMP directives.; ///; /// Each OpenMP directive has a corresponding public generator method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:7,interface,interface,7,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['interface'],['interface']
Integrability,"/// An interface to query the internal state of an abstract attribute.; ///; /// The abstract state is a minimal interface that allows the Attributor to; /// communicate with the abstract attributes about their internal state without; /// enforcing or exposing implementation details, e.g., the (existence of an); /// underlying lattice.; ///; /// It is sufficient to be able to query if a state is (1) valid or invalid, (2); /// at a fixpoint, and to indicate to the state that (3) an optimistic fixpoint; /// was reached or (4) a pessimistic fixpoint was enforced.; ///; /// All methods need to be implemented by the subclass. For the common use case,; /// a single boolean state or a bit-encoded state, the BooleanState and; /// {Inc,Dec,Bit}IntegerState classes are already provided. An abstract; /// attribute can inherit from them to get the abstract state interface and; /// additional methods to directly modify the state based if needed. See the; /// class comments for help.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:7,interface,interface,7,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,3,['interface'],['interface']
Integrability,"/// An interface to set and retrieve a workspace.; /// This is needed for all generic objects that can be saved in a workspace, which itself depend; /// on the workspace (e.g. the RooStats::ModelConfig).; /// Because of a circular dependency, a workspace with a ModelConfig cannot be (deep) cloned.; /// The handle hides this dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooWorkspaceHandle.h:7,interface,interface,7,roofit/roofitcore/inc/RooWorkspaceHandle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooWorkspaceHandle.h,4,"['depend', 'interface']","['depend', 'dependency', 'interface']"
Integrability,"/// An internal RPageSink that enables multiple RNTupleFillContext to write into a single common RPageSink.; ///; /// The setup with two contexts looks as follows:; ///; /// +------ owned by RNTupleFillContext ------+; /// | |; /// RPageSinkBuf --- forwards to ---> RPageSynchronizingSink ---+; /// (and owns) |; /// (via raw fInnerSink ptr) +-- RPageSink (usually a persistent sink); /// |; /// RPageSinkBuf --- forwards to ---> RPageSynchronizingSink ---+; /// | (and owns) |; /// | |; /// +------ owned by RNTupleFillContext ------+; ///; /// The mutex used by the synchronizing sinks is owned by the RNTupleParallelWriter that also owns the original model,; /// the ""final"" sink (usually a persistent sink) and keeps weak_ptr's of the contexts (to make sure they are destroyed; /// before the writer is destructed).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleParallelWriter.cxx:568,synchroniz,synchronizing,568,tree/ntuple/v7/src/RNTupleParallelWriter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleParallelWriter.cxx,1,['synchroniz'],['synchronizing']
Integrability,"/// An iterator adaptor that filters the elements of given inner iterators.; ///; /// The predicate parameter should be a callable object that accepts the wrapped; /// iterator's reference type and returns a bool. When incrementing or; /// decrementing the iterator, it will call the predicate on each element and; /// skip any where it returns false.; ///; /// \code; /// int A[] = { 1, 2, 3, 4 };; /// auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });; /// // R contains { 1, 3 }.; /// \endcode; ///; /// Note: filter_iterator_base implements support for forward iteration.; /// filter_iterator_impl exists to provide support for bidirectional iteration,; /// conditional on whether the wrapped iterator supports it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:155,wrap,wrapped,155,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,2,['wrap'],['wrapped']
Integrability,/// An iterator over the dependent diagnostics in a dependent context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependentDiagnostic.h:25,depend,dependent,25,interpreter/llvm-project/clang/include/clang/AST/DependentDiagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependentDiagnostic.h,2,['depend'],['dependent']
Integrability,"/// An iterator over the qualifiers on the object type. Provided; /// for convenience. This will always iterate over the full set of; /// protocols on a type, not just those provided directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:138,protocol,protocols,138,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['protocol'],['protocols']
Integrability,"/// An iterator that walks over all of the known identifiers; /// in the lookup table.; ///; /// Since this iterator uses an abstract interface via virtual; /// functions, it uses an object-oriented interface rather than the; /// more standard C++ STL iterator interface. In this OO-style; /// iteration, the single function \c Next() provides dereference,; /// advance, and end-of-sequence checking in a single; /// operation. Subclasses of this iterator type will provide the; /// actual functionality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:134,interface,interface,134,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,3,['interface'],['interface']
Integrability,/// An offload action combines host or/and device actions according to the; /// programming model implementation needs and propagates the offloading kind to; /// its dependences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h:166,depend,dependences,166,interpreter/llvm-project/clang/include/clang/Driver/Action.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h,1,['depend'],['dependences']
Integrability,"/// An opaque object representing a hash code.; ///; /// This object represents the result of hashing some entity. It is intended to; /// be used to implement hashtables or other hashing-based data structures.; /// While it wraps and exposes a numeric value, this value should not be; /// trusted to be stable or predictable across processes or executions.; ///; /// In order to obtain the hash_code for an object 'x':; /// \code; /// using llvm::hash_value;; /// llvm::hash_code code = hash_value(x);; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:224,wrap,wraps,224,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['wrap'],['wraps']
Integrability,"/// An unwrapped line is a sequence of \c Token, that we would like to; /// put on a single line if there was no column limit.; ///; /// This is used as a main interface between the \c UnwrappedLineParser and the; /// \c UnwrappedLineFormatter. The key property is that changing the formatting; /// within an unwrapped line does not affect any other unwrapped lines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h:160,interface,interface,160,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h,1,['interface'],['interface']
Integrability,/// Analyses memory accesses in a loop.; ///; /// Checks whether run time pointer checks are needed and builds sets for data; /// dependence checking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:130,depend,dependence,130,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependence']
Integrability,/// Analysis pass providing the \c TargetTransformInfo.; ///; /// The core idea of the TargetIRAnalysis is to expose an interface through; /// which LLVM targets can analyze and provide information about the middle; /// end's target-independent IR. This supports use cases such as target-aware; /// cost modeling of IR constructs.; ///; /// This is a function analysis because much of the cost modeling for targets; /// is done in a subtarget specific way and LLVM supports compiling different; /// functions targeting different subtargets in order to support runtime; /// dispatch according to the observed subtarget.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:120,interface,interface,120,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['interface'],['interface']
Integrability,/// Analysis providing profile information.; ///; /// This is an immutable analysis pass that provides ability to query global; /// (program-level) profile information. The main APIs are isHotCount and; /// isColdCount that tells whether a given profile count is considered hot/cold; /// based on the profile summary. This also provides convenience methods to; /// check whether a function is hot or cold.; // FIXME: Provide convenience methods to determine hotness/coldness of other IR; // units. This would require making this depend on BFI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:529,depend,depend,529,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,1,['depend'],['depend']
Integrability,"/// Analyze \p InputUnitEntryPair for the type name and possibly assign; /// built type name to the DIE's type info.; /// NOTE: while analyzing types we may create different kind of names; /// for the same type depending on whether the type is part of another type.; /// f.e. DW_TAG_formal_parameter would receive ""{02}01"" name when; /// examined alone. Or ""{0}int"" name when it is a part of a function name:; /// {a}void foo({0}int). The \p AssignNameToTypeDescriptor tells whether; /// the type name is part of another type name and then should not be assigned; /// to DIE type descriptor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/SyntheticTypeNameBuilder.h:211,depend,depending,211,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/SyntheticTypeNameBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/SyntheticTypeNameBuilder.h,1,['depend'],['depending']
Integrability,"/// Analyze a call site for potential inlining.; ///; /// Returns true if inlining this call is viable, and false if it is not; /// viable. It computes the cost and adjusts the threshold based on numerous; /// factors and heuristics. If this method returns false but the computed cost; /// is below the computed threshold, then inlining was forcibly disabled by; /// some artifact of the routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:388,rout,routine,388,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['rout'],['routine']
Integrability,"/// Analyze data dependencies that exist between memory loads or stores,; /// in the graph nodes and create edges between them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:17,depend,dependencies,17,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,1,['depend'],['dependencies']
Integrability,/// Analyze dead branches to find those whose branches are the sources; /// of control dependences impacting a live block. Those branches are; /// marked live.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:87,depend,dependences,87,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,1,['depend'],['dependences']
Integrability,"/// Analyze the branching code at the end of MBB and parse it into the; /// MachineBranchPredicate structure if possible. Returns false on success; /// and true on failure.; ///; /// If AllowModify is true, then this routine is allowed to modify the basic; /// block (e.g. delete instructions after the unconditional branch).; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:217,rout,routine,217,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['rout'],['routine']
Integrability,"/// Analyze the branching code at the end of MBB, returning; /// true if it cannot be understood (e.g. it's a switch dispatch or isn't; /// implemented for a target). Upon success, this returns false and returns; /// with the following information in various cases:; ///; /// 1. If this block ends with no branches (it just falls through to its succ); /// just return false, leaving TBB/FBB null.; /// 2. If this block ends with only an unconditional branch, it sets TBB to be; /// the destination block.; /// 3. If this block ends with a conditional branch and it falls through to a; /// successor block, it sets TBB to be the branch destination block and a; /// list of operands that evaluate the condition. These operands can be; /// passed to other TargetInstrInfo methods to create new branches.; /// 4. If this block ends with a conditional branch followed by an; /// unconditional branch, it returns the 'true' destination in TBB, the; /// 'false' destination in FBB, and a list of operands that evaluate the; /// condition. These operands can be passed to other TargetInstrInfo; /// methods to create new branches.; ///; /// Note that RemoveBranch and insertBranch must be implemented to support; /// cases where this method returns success.; ///; /// If AllowModify is true, then this routine is allowed to modify the basic; /// block (e.g. delete instructions after the unconditional branch).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCInstrInfo.cpp:1294,rout,routine,1294,interpreter/llvm-project/llvm/lib/Target/ARC/ARCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCInstrInfo.cpp,1,['rout'],['routine']
Integrability,"/// Analyze the branching code at the end of MBB, returning; /// true if it cannot be understood (e.g. it's a switch dispatch or isn't; /// implemented for a target). Upon success, this returns false and returns; /// with the following information in various cases:; ///; /// 1. If this block ends with no branches (it just falls through to its succ); /// just return false, leaving TBB/FBB null.; /// 2. If this block ends with only an unconditional branch, it sets TBB to be; /// the destination block.; /// 3. If this block ends with a conditional branch and it falls through to a; /// successor block, it sets TBB to be the branch destination block and a; /// list of operands that evaluate the condition. These operands can be; /// passed to other TargetInstrInfo methods to create new branches.; /// 4. If this block ends with a conditional branch followed by an; /// unconditional branch, it returns the 'true' destination in TBB, the; /// 'false' destination in FBB, and a list of operands that evaluate the; /// condition. These operands can be passed to other TargetInstrInfo; /// methods to create new branches.; ///; /// Note that removeBranch and insertBranch must be implemented to support; /// cases where this method returns success.; ///; /// If AllowModify is true, then this routine is allowed to modify the basic; /// block (e.g. delete instructions after the unconditional branch).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:1294,rout,routine,1294,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,1,['rout'],['routine']
Integrability,"/// Analyze the branching code at the end of MBB, returning; /// true if it cannot be understood (e.g. it's a switch dispatch or isn't; /// implemented for a target). Upon success, this returns false and returns; /// with the following information in various cases:; ///; /// 1. If this block ends with no branches (it just falls through to its succ); /// just return false, leaving TBB/FBB null.; /// 2. If this block ends with only an unconditional branch, it sets TBB to be; /// the destination block.; /// 3. If this block ends with a conditional branch and it falls through to a; /// successor block, it sets TBB to be the branch destination block and a; /// list of operands that evaluate the condition. These operands can be; /// passed to other TargetInstrInfo methods to create new branches.; /// 4. If this block ends with a conditional branch followed by an; /// unconditional branch, it returns the 'true' destination in TBB, the; /// 'false' destination in FBB, and a list of operands that evaluate the; /// condition. These operands can be passed to other TargetInstrInfo; /// methods to create new branches.; ///; /// Note that removeBranch and insertBranch must be implemented to support; /// cases where this method returns success.; ///; /// If AllowModify is true, then this routine is allowed to modify the basic; /// block (e.g. delete instructions after the unconditional branch).; ///; /// The CFG information in MBB.Predecessors and MBB.Successors must be valid; /// before calling this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:1294,rout,routine,1294,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['rout'],['routine']
Integrability,/// Analyze the specified pointer to see if it can be expressed as a base; /// pointer plus a constant offset. Return the base and offset to the caller.; ///; /// This is a wrapper around Value::stripAndAccumulateConstantOffsets that; /// creates and later unpacks the required APInt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:173,wrap,wrapper,173,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['wrap'],['wrapper']
Integrability,/// Annotate memory instructions in the versioned loop with no-alias; /// metadata based on the memchecks issued.; ///; /// This is just wrapper that calls prepareNoAliasMetadata and; /// annotateInstWithNoAlias on the instructions of the versioned loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h:137,wrap,wrapper,137,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h,1,['wrap'],['wrapper']
Integrability,"/// AntiDepBreak - Anti-dependence breaking object, or NULL if none",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:24,depend,dependence,24,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['depend'],['dependence']
Integrability,/// AntiDepEdges - Return in Edges the anti- and output- dependencies; /// in SU that we want to consider for breaking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:57,depend,dependencies,57,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,1,['depend'],['dependencies']
Integrability,/// Append F to the list of global ctors of module M with the given Priority.; /// This wraps the function in the appropriate structure and stores it along; /// side other global constructors. For details see; /// https://llvm.org/docs/LangRef.html#the-llvm-global-ctors-global-variable,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:88,wrap,wraps,88,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,1,['wrap'],['wraps']
Integrability,/// Append the host offload info of this action and propagate it to its; /// dependences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h:77,depend,dependences,77,interpreter/llvm-project/clang/include/clang/Driver/Action.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h,1,['depend'],['dependences']
Integrability,/// Appends a dependent lib to the appropriate metadata value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:14,depend,dependent,14,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['depend'],['dependent']
Integrability,"/// Applies all AtomicChanges in \p Changes to the \p Code.; ///; /// This completely ignores the file path in each change and replaces them with; /// \p FilePath, i.e. callers are responsible for ensuring all changes are for; /// the same file.; ///; /// \returns The changed code if all changes are applied successfully;; /// otherwise, an llvm::Error carrying llvm::StringError is returned (the Error; /// message can be converted to string with `llvm::toString()` and the; /// error_code should be ignored).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:409,message,message,409,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,1,['message'],['message']
Integrability,"/// Applies all replacements in \p Replaces to \p Code.; ///; /// This completely ignores the path stored in each replacement. If all; /// replacements are applied successfully, this returns the code with; /// replacements applied; otherwise, an llvm::Error carrying llvm::StringError; /// is returned (the Error message can be converted to string using; /// `llvm::toString()` and 'std::error_code` in the `Error` should be ignored).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:313,message,message,313,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,1,['message'],['message']
Integrability,"/// Apply Objective-C protocol qualifiers to the given type.; /// If this is for the canonical type of a type parameter, we can apply; /// protocol qualifiers on the ObjCObjectPointerType.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:22,protocol,protocol,22,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['protocol'],['protocol']
Integrability,/// Apply Objective-C protocol qualifiers to the given type.; /// \param allowOnPointerType specifies if we can apply protocol; /// qualifiers on ObjCObjectPointerType. It can be set to true when; /// constructing the canonical type of a Objective-C type parameter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:22,protocol,protocol,22,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,2,['protocol'],['protocol']
Integrability,"/// Apply any changes implied by the discovered dependencies to the given; /// invocation, (e.g. disable implicit modules, add explicit module paths).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:48,depend,dependencies,48,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,1,['depend'],['dependencies']
Integrability,/// Apply changes to the instruction if needed. The changes are need; /// to improve the scheduling and depend up on the final schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:104,depend,depend,104,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['depend']
Integrability,/// Apply graph abstraction to groups of nodes that belong to a strongly; /// connected component of the graph to create larger compound nodes; /// called pi-blocks. The purpose of this abstraction is to isolate sets of; /// program elements that need to stay together during codegen and turn; /// the dependence graph into an acyclic graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:302,depend,dependence,302,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,1,['depend'],['dependence']
Integrability,/// Are we compiling a standard c++ module interface?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h:43,interface,interface,43,interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,1,['interface'],['interface']
Integrability,"/// Argument handling is mostly uniform between the four places that; /// make these decisions: function formal arguments, call; /// instruction args, call instruction returns and function; /// returns. However, once a decision has been made on where an; /// argument should go, exactly what happens can vary slightly. This; /// class abstracts the differences.; ///; /// ValueAssigner should not depend on any specific function state, and; /// only determine the types and locations for arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:397,depend,depend,397,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,1,['depend'],['depend']
Integrability,/// Arguments collected via the streaming interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:42,interface,interface,42,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,2,['interface'],['interface']
Integrability,"/// Arrange the argument and result information for the function type; /// through which to perform a send to the given Objective-C method,; /// using the given receiver type. The receiver type is not always; /// the 'self' type of the method or even an Objective-C pointer type.; /// This is *not* the right method for actually performing such a; /// message send, due to the possibility of optional arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:352,message,message,352,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['message'],['message']
Integrability,"/// As a rule of thumb, the alignment is equal to the size of the type. There are, however, various exceptions; /// to this rule depending on OS and CPU architecture. So enforce the alignment to be explicitly spelled out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:129,depend,depending,129,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['depend'],['depending']
Integrability,"/// Assign a complexity or rank value to LLVM Values. This is used to reduce; /// the amount of pattern matching needed for compares and commutative; /// instructions. For example, if we have:; /// icmp ugt X, Constant; /// or; /// xor (add X, Constant), cast Z; ///; /// We do not have to consider the commuted variants of these patterns because; /// canonicalization based on complexity guarantees the above ordering.; ///; /// This routine maps IR values to various complexity ranks:; /// 0 -> undef; /// 1 -> Constants; /// 2 -> Other non-instructions; /// 3 -> Arguments; /// 4 -> Cast and (f)neg/not instructions; /// 5 -> Other instructions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h:435,rout,routine,435,interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,1,['rout'],['routine']
Integrability,"/// Assign a node to be computed in the GPU. Scan it's clients and also assign them; /// in case they only depend on GPU nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Evaluator.cxx:107,depend,depend,107,roofit/roofitcore/src/RooFit/Evaluator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Evaluator.cxx,1,['depend'],['depend']
Integrability,/// Assign counters to regions and configure them for PGO of a given; /// function. Does nothing if instrumentation is not enabled and either; /// generates global variables or associates PGO data with each of the; /// counters depending on whether we are generating or using instrumentation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.h:228,depend,depending,228,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.h,1,['depend'],['depending']
Integrability,"/// Assign serial numbers to values from left function, and values from; /// right function.; /// Explanation:; /// Being comparing functions we need to compare values we meet at left and; /// right sides.; /// Its easy to sort things out for external values. It just should be; /// the same value at left and right.; /// But for local values (those were introduced inside function body); /// we have to ensure they were introduced at exactly the same place,; /// and plays the same role.; /// Let's assign serial number to each value when we meet it first time.; /// Values that were met at same place will be with same serial numbers.; /// In this case it would be good to explain few points about values assigned; /// to BBs and other ways of implementation (see below).; ///; /// 1. Safety of BB reordering.; /// It's safe to change the order of BasicBlocks in function.; /// Relationship with other functions and serial numbering will not be; /// changed in this case.; /// As follows from FunctionComparator::compare(), we do CFG walk: we start; /// from the entry, and then take each terminator. So it doesn't matter how in; /// fact BBs are ordered in function. And since cmpValues are called during; /// this walk, the numbering depends only on how BBs located inside the CFG.; /// So the answer is - yes. We will get the same numbering.; ///; /// 2. Impossibility to use dominance properties of values.; /// If we compare two instruction operands: first is usage of local; /// variable AL from function FL, and second is usage of local variable AR; /// from FR, we could compare their origins and check whether they are; /// defined at the same place.; /// But, we are still not able to compare operands of PHI nodes, since those; /// could be operands from further BBs we didn't scan yet.; /// So it's impossible to use dominance properties in general.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:1238,depend,depends,1238,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,1,['depend'],['depends']
Integrability,/// Assign the register class depending on the number of; /// bits set in the writemask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:30,depend,depending,30,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['depend'],['depending']
Integrability,"/// Assuming that this is a dominator of TBI, determine if it contains; /// useful instruction depths. A dominating block can be above the current; /// trace head, and any dependencies from such a far away dominator are not; /// expected to affect the critical path.; ///; /// Also returns true when TBI == this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:172,depend,dependencies,172,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,1,['depend'],['dependencies']
Integrability,/// AtomicPropertySetterGetterRules - This routine enforces the rule (via; /// warning) when atomic property has one but not the other user-declared; /// setter or getter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:43,rout,routine,43,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['rout'],['routine']
Integrability,"/// Attach body to a C++0x range-based for statement.; ///; /// By default, performs semantic analysis to finish the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:166,rout,routine,166,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Attach the body to a new case statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,rout,routine,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Attach the body to the switch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,rout,routine,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// AttachDependencyGraphGen - Create a dependency graph generator, and attach; /// it to the given preprocessor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h:40,depend,dependency,40,interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,1,['depend'],['dependency']
Integrability,/// Attempt to be ABI-compatible with code generated by Clang 14.0.x.; /// This causes clang to:; /// - mangle dependent nested names incorrectly.; /// - make trivial only those defaulted copy constructors with a; /// parameter-type-list equivalent to the parameter-type-list of an; /// implicit declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h:111,depend,dependent,111,interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,1,['depend'],['dependent']
Integrability,"/// Attempt to behave like MSVC in situations where lookup of an unqualified; /// type name has failed in a dependent context. In these situations, we; /// automatically form a DependentTypeName that will retry lookup in a related; /// scope during instantiation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:108,depend,dependent,108,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['Depend', 'depend']","['DependentTypeName', 'dependent']"
Integrability,"/// Attempt to build or re-use a precompiled preamble when (re-)parsing; /// the source file.; ///; /// This routine will compute the preamble of the main source file. If a; /// non-trivial preamble is found, it will precompile that preamble into a; /// precompiled header so that the precompiled preamble can be used to reduce; /// reparsing time. If a precompiled preamble has already been constructed,; /// this routine will determine if it is still valid and, if so, avoid; /// rebuilding the precompiled preamble.; ///; /// \param AllowRebuild When true (the default), this routine is; /// allowed to rebuild the precompiled preamble if it is found to be; /// out-of-date.; ///; /// \param MaxLines When non-zero, the maximum number of lines that; /// can occur within the preamble.; ///; /// \returns If the precompiled preamble can be used, returns a newly-allocated; /// buffer that should be used in place of the main file when doing so.; /// Otherwise, returns a NULL pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:109,rout,routine,109,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,3,['rout'],['routine']
Integrability,"/// Attempt to classify the name at the current token position. This may; /// form a type, scope or primary expression annotation, or replace the token; /// with a typo-corrected keyword. This is only appropriate when the current; /// name must refer to an entity which has already been declared.; ///; /// \param CCC Indicates how to perform typo-correction for this name. If NULL,; /// no typo correction will be performed.; /// \param AllowImplicitTypename Whether we are in a context where a dependent; /// nested-name-specifier without typename is treated as a type (e.g.; /// T::type).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:496,depend,dependent,496,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['depend'],['dependent']
Integrability,"/// Attempt to convert the given expression to a type which is accepted; /// by the given converter.; ///; /// This routine will attempt to convert an expression of class type to a; /// type accepted by the specified converter. In C++11 and before, the class; /// must have a single non-explicit conversion function converting to a matching; /// type. In C++1y, there can be multiple such conversion functions, but only; /// one target type.; ///; /// \param Loc The source location of the construct that requires the; /// conversion.; ///; /// \param From The expression we're converting from.; ///; /// \param Converter Used to control and diagnose the conversion process.; ///; /// \returns The expression, converted to an integral or enumeration type if; /// successful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:116,rout,routine,116,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['rout'],['routine']
Integrability,/// Attempt to eliminate a load whose dependencies are; /// non-local by performing PHI construction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:38,depend,dependencies,38,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['depend'],['dependencies']
Integrability,"/// Attempt to load the given module.; ///; /// This routine attempts to load the module described by the given; /// parameters. If there is a module cache, this may implicitly compile the; /// module before loading it.; ///; /// \param ImportLoc The location of the 'import' keyword.; ///; /// \param Path The identifiers (and their locations) of the module; /// ""path"", e.g., ""std.vector"" would be split into ""std"" and ""vector"".; ///; /// \param Visibility The visibility provided for the names in the loaded; /// module.; ///; /// \param IsInclusionDirective Indicates that this module is being loaded; /// implicitly, due to the presence of an inclusion directive. Otherwise,; /// it is being loaded due to an import declaration.; ///; /// \returns If successful, returns the loaded module. Otherwise, returns; /// NULL to indicate that the module could not be loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h:53,rout,routine,53,interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,1,['rout'],['routine']
Integrability,"/// Attempt to recover from an ill-formed use of a non-dependent name in a; /// template, where the non-dependent name was declared after the template; /// was defined. This is common in code written for a compilers which do not; /// correctly implement two-stage name lookup.; ///; /// Returns true if a viable candidate was found and a diagnostic was issued.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:55,depend,dependent,55,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['depend'],['dependent']
Integrability,"/// Attempt to recover from ill-formed use of a non-dependent operator in a; /// template, where the non-dependent operator was declared after the template; /// was defined.; ///; /// Returns true if a viable candidate was found and a diagnostic was issued.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:52,depend,dependent,52,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['depend'],['dependent']
Integrability,"/// Attempts to assign any available port and interface, returning either the; /// port number or an Error upon failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPServer.h:46,interface,interface,46,interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPServer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPServer.h,1,['interface'],['interface']
Integrability,"/// Attempts to assign the requested port and interface, returning an Error; /// upon failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPServer.h:46,interface,interface,46,interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPServer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPServer.h,1,['interface'],['interface']
Integrability,"/// Attempts to merge distinct values `Val1` and `Val2` in `Env1` and `Env2`,; /// respectively, of the same type `Type`. Merging generally produces a single; /// value that (soundly) approximates the two inputs, although the actual; /// meaning depends on `Model`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:246,depend,depends,246,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,1,['depend'],['depends']
Integrability,/// Attempts to read an IFS interface file from a StringRef buffer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSHandler.h:28,interface,interface,28,interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSHandler.h,1,['interface'],['interface']
Integrability,/// Attempts to write an IFS interface file to a raw_ostream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSHandler.h:29,interface,interface,29,interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSHandler.h,1,['interface'],['interface']
Integrability,/// Attributes of a target dependent hardware loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:27,depend,dependent,27,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['depend'],['dependent']
Integrability,"/// AttributesMatch - This routine checks list of attributes for two; /// decls. It returns false, if there is a mismatch in kind of; /// attributes seen in the decls. It returns true if the two decls; /// have list of same kind of attributes. Furthermore, when there; /// are availability attributes in the two decls, it sets the; /// AvailabilityArgsMatch to false if availability attributes have; /// different versions, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:27,rout,routine,27,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,1,['rout'],['routine']
Integrability,"/// AuditedType - This routine audits the type AT and returns false if it is one of known; /// CF object types or of the ""void *"" variety. It returns true if we don't care about the type; /// such as a non-pointer or pointers which have no ownership issues (such as ""int *"").",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:23,rout,routine,23,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,1,['rout'],['routine']
Integrability,"/// AvailabilityAttrsMatch - This routine checks that if comparing two; /// availability attributes, all their components match. It returns; /// true, if not dealing with availability or when all components of; /// availability attributes match. This routine is only called when; /// the attributes are of the same kind.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:34,rout,routine,34,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,2,['rout'],['routine']
Integrability,"/// BF16_TO_FP, FP_TO_BF16 - These operators are used to perform promotions; /// and truncation for bfloat16. These nodes form a semi-softened interface; /// for dealing with bf16 (as an i16), which is often a storage-only type but; /// has native conversions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:143,interface,interface,143,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['interface'],['interface']
Integrability,"/// BITCAST - This operator converts between integer, vector and FP; /// values, as if the value was stored to memory with one type and loaded; /// from the same address with the other type (or equivalently for vector; /// format conversions, etc). The source and result are required to have; /// the same bit size (e.g. f32 <-> i32). This can also be used for; /// int-to-int or fp-to-fp conversions, but that is a noop, deleted by; /// getNode().; ///; /// This operator is subtly different from the bitcast instruction from; /// LLVM-IR since this node may change the bits in the register. For; /// example, this occurs on big-endian NEON and big-endian MSA where the; /// layout of the bits in the register depends on the vector type and this; /// operator acts as a shuffle operation for some vector type combinations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:711,depend,depends,711,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['depend'],['depends']
Integrability,/// Base class and interface for reading profiling data of any known instrprof; /// format. Provides an iterator over NamedInstrProfRecords.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h:19,interface,interface,19,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,1,['interface'],['interface']
Integrability,/// Base class for CUDA/HIP action builder. It injects device code in; /// the host backend action.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:47,inject,injects,47,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['inject'],['injects']
Integrability,"/// Base class for all errors indicating malformed binary files.; ///; /// Having a subclass for all malformed binary files allows archive-walking; /// code to skip malformed files without having to understand every possible; /// way that a binary file might be malformed.; ///; /// Currently inherits from ECError for easy interoperability with; /// std::error_code, but this will be removed in the future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Error.h:324,interoperab,interoperability,324,interpreter/llvm-project/llvm/include/llvm/Object/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Error.h,1,['interoperab'],['interoperability']
Integrability,/// Base class for instructions consumed by the simulation pipeline.; ///; /// This class tracks data dependencies as well as generic properties; /// of the instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:102,depend,dependencies,102,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['depend'],['dependencies']
Integrability,"/// Base class for non-leaf nodes of the computational graph.; /// It only exposes the bare minimum interface required to work as a generic part of the computation graph.; /// RDataFrames and results of transformations can be cast to this type via ROOT::RDF::RNode (or ROOT.RDF.AsRNode in PyROOT).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RNodeBase.hxx:100,interface,interface,100,tree/dataframe/inc/ROOT/RDF/RNodeBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RNodeBase.hxx,1,['interface'],['interface']
Integrability,"/// Base class of the Configurations for the member wise looping routines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TStreamerInfoActions.h:65,rout,routines,65,io/io/inc/TStreamerInfoActions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TStreamerInfoActions.h,1,['rout'],['routines']
Integrability,"/// Base class which can be used to help build a TTI implementation.; ///; /// This class provides as much implementation of the TTI interface as is; /// possible using the target independent parts of the code generator.; ///; /// In order to subclass it, your class must implement a getST() method to; /// return the subtarget, and a getTLI() method to return the target lowering.; /// We need these methods implemented in the derived class so that this class; /// doesn't have to duplicate storage for them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:133,interface,interface,133,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,1,['interface'],['interface']
Integrability,"/// Base struct for all ""concrete attribute"" deductions.; ///; /// The abstract attribute is a minimal interface that allows the Attributor to; /// orchestrate the abstract/fixpoint analysis. The design allows to hide away; /// implementation choices made for the subclasses but also to structure their; /// implementation and simplify the use of other abstract attributes in-flight.; ///; /// To allow easy creation of new attributes, most methods have default; /// implementations. The ones that do not are generally straight forward, except; /// `AbstractAttribute::updateImpl` which is the location of most reasoning; /// associated with the abstract attribute. The update is invoked by the; /// Attributor in case the situation used to justify the current optimistic; /// state might have changed. The Attributor determines this automatically; /// by monitoring the `Attributor::getAAFor` calls made by abstract attributes.; ///; /// The `updateImpl` method should inspect the IR and other abstract attributes; /// in-flight to justify the best possible (=optimistic) state. The actual; /// implementation is, similar to the underlying abstract state encoding, not; /// exposed. In the most common case, the `updateImpl` will go through a list of; /// reasons why its optimistic state is valid given the current information. If; /// any combination of them holds and is sufficient to justify the current; /// optimistic state, the method shall return UNCHAGED. If not, the optimistic; /// state is adjusted to the situation and the method shall return CHANGED.; ///; /// If the manifestation of the ""concrete attribute"" deduced by the subclass; /// differs from the ""default"" behavior, which is a (set of) LLVM-IR; /// attribute(s) for an argument, call site argument, function return value, or; /// function, the `AbstractAttribute::manifest` method should be overloaded.; ///; /// NOTE: If the state obtained via getState() is INVALID, thus if; /// AbstractAttribute::getState().isValidState() ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:103,interface,interface,103,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,/// Base type for MachOBuilder load command wrappers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOBuilder.h:44,wrap,wrappers,44,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOBuilder.h,1,['wrap'],['wrappers']
Integrability,"/// Base wrapper for a particular ""section"" of type source info.; ///; /// A client should use the TypeLoc subclasses through castAs()/getAs(); /// in order to get at the actual information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TypeLoc.h:9,wrap,wrapper,9,interpreter/llvm-project/clang/include/clang/AST/TypeLoc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TypeLoc.h,1,['wrap'],['wrapper']
Integrability,"/// Before the llvm-mca pipeline dispatches an instruction, it first checks; /// for any register or resource dependencies / hazards. If it doesn't find; /// any, this method will be invoked to determine if there are any custom; /// hazards that the instruction needs to wait for.; /// The return value of this method is the number of cycles that the; /// instruction needs to wait for.; /// It's safe to underestimate the number of cycles to wait for since these; /// checks will be invoked again before the intruction gets dispatched.; /// However, it's not safe (accurate) to overestimate the number of cycles; /// to wait for since the instruction will wait for AT LEAST that number of; /// cycles before attempting to be dispatched again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h:110,depend,dependencies,110,interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,1,['depend'],['dependencies']
Integrability,"/// Behaves the same as handleErrors, except that by contract all errors; /// *must* be handled by the given handlers (i.e. there must be no remaining; /// errors after running the handlers, or llvm_unreachable is called).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:53,contract,contract,53,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['contract'],['contract']
Integrability,"/// BlockType - The function type of the block, if one was given.; /// Its return type may be BuiltinType::Dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h:107,Depend,Dependent,107,interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,1,['Depend'],['Dependent']
Integrability,/// Boolean conversion: This ThreadSafeModule will evaluate to true if it; /// wraps a non-null module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h:79,wrap,wraps,79,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h,1,['wrap'],['wraps']
Integrability,/// Boolean wrapper for outputDiff which handles errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkSizeDiff.cpp:12,wrap,wrapper,12,interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkSizeDiff.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkSizeDiff.cpp,1,['wrap'],['wrapper']
Integrability,"/// Bounds of the node, laid out in memory as `[min_x, max_x, min_y, max_y, ...]`. Users should; /// not really depend on a specific order and instead use `get_bbox()` and extract the `min`; /// and/or `max` components accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/node.h:112,depend,depend,112,geom/geom/inc/bvh/v2/node.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/node.h,1,['depend'],['depend']
Integrability,/// BranchFolderPass - Wrap branch folder in a machine function pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:23,Wrap,Wrap,23,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['Wrap'],['Wrap']
Integrability,"/// Break false dependencies on undefined register reads.; /// Walk the block backward computing precise liveness. This is expensive, so; /// we only do it on demand. Note that the occurrence of undefined register; /// reads that should be broken is very rare, but when they occur we may have; /// many in a single block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:16,depend,dependencies,16,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,1,['depend'],['dependencies']
Integrability,/// BreakAntiDependencies - Identifiy anti-dependencies within the; /// ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:43,depend,dependencies,43,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,1,['depend'],['dependencies']
Integrability,/// Breaking between template declaration and ``concept`` is allowed. The; /// actual behavior depends on the content and line breaking rules and; /// penalties.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:95,depend,depends,95,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['depend'],['depends']
Integrability,"/// Bridging via __bridge, which does nothing but reinterpret; /// the bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h:4,Bridg,Bridging,4,interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h,1,['Bridg'],['Bridging']
Integrability,"/// Bridging via __bridge_retain, which makes an ARC object available; /// as a +1 C pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h:4,Bridg,Bridging,4,interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h,1,['Bridg'],['Bridging']
Integrability,"/// Bridging via __bridge_transfer, which transfers ownership of an; /// Objective-C pointer into ARC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h:4,Bridg,Bridging,4,interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h,1,['Bridg'],['Bridging']
Integrability,/// Build 'message' clause with message string argument; ///; /// \param MS Argument of the clause (message string).; /// \param StartLoc Starting location of the clause.; /// \param LParenLoc Location of '('.; /// \param EndLoc Ending location of the clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:11,message,message,11,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,3,['message'],['message']
Integrability,/// Build DeclarationFragments for an Objective-C interface declaration; /// ObjCInterfaceDecl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/DeclarationFragments.h:50,interface,interface,50,interpreter/llvm-project/clang/include/clang/ExtractAPI/DeclarationFragments.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/DeclarationFragments.h,1,['interface'],['interface']
Integrability,/// Build DeclarationFragments for an Objective-C protocol declaration; /// ObjCProtocolDecl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/DeclarationFragments.h:50,protocol,protocol,50,interpreter/llvm-project/clang/include/clang/ExtractAPI/DeclarationFragments.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/DeclarationFragments.h,1,['protocol'],['protocol']
Integrability,/// Build a an Objective-C protocol-qualified 'id' type where no; /// base type was specified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:27,protocol,protocol-qualified,27,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['protocol'],['protocol-qualified']
Integrability,"/// Build a call to 'begin' or 'end' for a C++11 for-range statement. If the; /// given LookupResult is non-empty, it is assumed to describe a member which; /// will be invoked. Otherwise, the function will be found via argument; /// dependent lookup.; /// CallExpr is set to a valid expression and FRS_Success returned on success,; /// otherwise CallExpr is set to ExprError() and some non-success value; /// is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:234,depend,dependent,234,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['depend'],['dependent']
Integrability,/// Build a dependent bit-precise int given its value type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:12,depend,dependent,12,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependent']
Integrability,"/// Build a function type.; ///; /// This routine checks the function type according to C++ rules and; /// under the assumption that the result type and parameter types have; /// just been instantiated from a template. It therefore duplicates; /// some of the behavior of GetTypeForDeclarator, but in a much; /// simpler form that is only suitable for this narrow use case.; ///; /// \param T The return type of the function.; ///; /// \param ParamTypes The parameter types of the function. This array; /// will be modified to account for adjustments to the types of the; /// function parameters.; ///; /// \param Loc The location of the entity whose type involves this; /// function type or, if there is no such entity, the location of the; /// type that will have function type.; ///; /// \param Entity The name of the entity that involves the function; /// type, if known.; ///; /// \param EPI Extra information about the function type. Usually this will; /// be taken from an existing function with the same prototype.; ///; /// \returns A suitable function type, if there are no errors. The; /// unqualified type will always be a FunctionProtoType.; /// Otherwise, returns a NULL type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:42,rout,routine,42,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['rout'],['routine']
Integrability,"/// Build a new ""if"" statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:143,rout,routine,143,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new (previously unresolved) declaration reference; /// expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:191,rout,routine,191,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ ""delete"" expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,rout,routine,153,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ ""named"" cast expression, such as static_cast or; /// reinterpret_cast.; ///; /// By default, this routine dispatches to one of the more-specific routines; /// for a particular named case, e.g., RebuildCXXStaticCastExpr().; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:118,rout,routine,118,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,3,['rout'],"['routine', 'routines']"
Integrability,"/// Build a new C++ ""new"" expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:150,rout,routine,150,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ ""this"" expression.; ///; /// By default, builds a new ""this"" expression without performing any; /// semantic analysis. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:168,rout,routine,168,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ __builtin_bit_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:163,rout,routine,163,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ __uuidof(expr) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:159,rout,routine,159,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ __uuidof(type) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:159,rout,routine,159,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ catch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:148,rout,routine,148,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ const_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,rout,routine,155,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ default-argument expression.; ///; /// By default, builds a new default-argument expression, which does not; /// require any semantic analysis. Subclasses may override this routine to; /// provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:193,rout,routine,193,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ dynamic_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ exception declaration.; ///; /// By default, performs semantic analysis to build the new decaration.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,rout,routine,155,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ functional-style cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:166,rout,routine,166,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ reinterpret_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:161,rout,routine,161,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ static_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,rout,routine,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ throw expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:150,rout,routine,150,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ try statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:146,rout,routine,146,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ typeid(expr) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ typeid(type) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++ zero-initialization expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:164,rout,routine,164,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++0x range-based for statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,rout,routine,160,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['rout'],['routine']
Integrability,"/// Build a new C++11 decltype type.; ///; /// By default, performs semantic analysis when building the decltype type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,rout,routine,153,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C++11 default-initialization expression.; ///; /// By default, builds a new default field initialization expression, which; /// does not require any semantic analysis. Subclasses may override this; /// routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:218,rout,routine,218,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new C-style cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,rout,routine,153,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new DependentAddressSpaceType or return the pointee; /// type variable with the correct address space (retrieved from; /// AddrSpaceExpr) applied to it. The former will be returned in cases; /// where the address space remains dependent.; ///; /// By default, performs semantic analysis when building the type with address; /// space applied. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:16,Depend,DependentAddressSpaceType,16,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,3,"['Depend', 'depend', 'rout']","['DependentAddressSpaceType', 'dependent', 'routine']"
Integrability,"/// Build a new FieldDecl and check its well-formedness.; ///; /// This routine builds a new FieldDecl given the fields name, type,; /// record, etc. \p PrevDecl should refer to any previous declaration; /// with the same name and in the same scope as the field to be; /// created.; ///; /// \returns a new FieldDecl.; ///; /// \todo The Declarator argument is a hack. It will be removed once",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:72,rout,routine,72,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['rout'],['routine']
Integrability,"/// Build a new GNU statement expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,rout,routine,154,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new MS style inline asm statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,rout,routine,158,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new Objective-C ""isa"" expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,rout,routine,158,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new Objective-C \@autoreleasepool statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:168,rout,routine,168,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new Objective-C \@catch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,rout,routine,158,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new Objective-C \@encode expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:161,rout,routine,161,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new Objective-C \@finally statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,rout,routine,160,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new Objective-C \@synchronized statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:30,synchroniz,synchronized,30,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,"['rout', 'synchroniz']","['routine', 'synchronized']"
Integrability,"/// Build a new Objective-C \@throw statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,rout,routine,158,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new Objective-C \@try statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,rout,routine,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new Objective-C array literal.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,rout,routine,155,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new Objective-C boxed expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,rout,routine,158,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,/// Build a new Objective-C class message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:34,message,message,34,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['message'],['message']
Integrability,"/// Build a new Objective-C dictionary literal.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,rout,routine,160,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new Objective-C fast enumeration statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:167,rout,routine,167,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,/// Build a new Objective-C instance message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:37,message,message,37,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['message'],['message']
Integrability,/// Build a new Objective-C instance/class message to 'super'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:43,message,message,43,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['message'],['message']
Integrability,"/// Build a new Objective-C ivar reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:167,rout,routine,167,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new Objective-C property reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:171,rout,routine,171,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'affinity' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'align' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,rout,routine,154,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'aligned' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,rout,routine,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'allocate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'allocator' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,rout,routine,158,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'at' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:151,rout,routine,151,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'bind' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,rout,routine,153,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'collapse' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'copyin' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,rout,routine,155,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'copyprivate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,rout,routine,160,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'default' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,rout,routine,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'defaultmap' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:159,rout,routine,159,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'depend' pseudo clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:24,depend,depend,24,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,"['depend', 'rout']","['depend', 'routine']"
Integrability,"/// Build a new OpenMP 'depobj' pseudo clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:162,rout,routine,162,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'destroy' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,rout,routine,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'detach' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:151,rout,routine,151,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'device' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:151,rout,routine,151,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'dist_schedule' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:162,rout,routine,162,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'doacross' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'exclusive' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,rout,routine,158,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'filter' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,rout,routine,155,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'final' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,rout,routine,154,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'firstprivate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:161,rout,routine,161,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'flush' pseudo clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:161,rout,routine,161,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'from' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,rout,routine,149,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'grainsize' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,rout,routine,154,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'has_device_addr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:164,rout,routine,164,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'hint' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,rout,routine,149,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'if' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:151,rout,routine,151,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'in_reduction' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'inclusive' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,rout,routine,158,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'init' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,rout,routine,153,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'is_device_ptr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:162,rout,routine,162,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'lastprivate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,rout,routine,160,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'linear' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,rout,routine,155,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'map' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:152,rout,routine,152,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'message' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:24,message,message,24,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,"['message', 'rout']","['message', 'routine']"
Integrability,"/// Build a new OpenMP 'nocontext' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,rout,routine,158,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'nontemporal' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,rout,routine,160,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'novariants' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:159,rout,routine,159,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'num_tasks' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,rout,routine,154,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'num_teams' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,rout,routine,154,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'num_threads' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,rout,routine,160,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'ompx_attribute' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:163,rout,routine,163,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'ompx_bare' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,rout,routine,158,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'ompx_dyn_cgroup_mem' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:168,rout,routine,168,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'order' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,rout,routine,154,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'ordered' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,rout,routine,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'priority' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,rout,routine,153,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'private' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,rout,routine,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'proc_bind' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,rout,routine,158,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'reduction' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,rout,routine,154,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'safelen' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,rout,routine,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'schedule' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'severity' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'shared' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,rout,routine,155,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'simdlen' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,rout,routine,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'task_reduction' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:159,rout,routine,159,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'thread_limit' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'to' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:147,rout,routine,147,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'use' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:152,rout,routine,152,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'use_device_addr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:164,rout,routine,164,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'use_device_ptr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:163,rout,routine,163,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new OpenMP 'uses_allocators' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:164,rout,routine,164,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,/// Build a new OpenMP Canonical loop.; ///; /// Ensures that the outermost loop in @p LoopStmt is wrapped by a; /// OMPCanonicalLoop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:99,wrap,wrapped,99,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['wrap'],['wrapped']
Integrability,"/// Build a new OpenMP executable directive.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,rout,routine,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new \c va_arg expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:150,rout,routine,150,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new __builtin_choose_expr expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:162,rout,routine,162,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new address-of-label expression.; ///; /// By default, performs semantic analysis, using the name of the label; /// rather than attempting to map the label statement itself.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:220,rout,routine,220,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new array section expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,rout,routine,154,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new array shaping expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,rout,routine,154,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new array subscript expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,rout,routine,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new array type given the element type, size; /// modifier, size of the array (if known), size expression, and index type; /// qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.; /// Also by default, all of the other Rebuild*Array",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:263,rout,routine,263,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new array type trait expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new atomic operation expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new atomic type given its value type.; ///; /// By default, performs semantic analysis when building the atomic type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:164,rout,routine,164,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new attributed statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,rout,routine,149,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new binary operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,rout,routine,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new block pointer type given its pointee type.; ///; /// By default, performs semantic analysis when building the block pointer; /// type. Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:180,rout,routine,180,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new builtin offsetof expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new call expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:145,rout,routine,145,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new case statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:143,rout,routine,143,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new co_await expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,rout,routine,149,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['rout'],['routine']
Integrability,"/// Build a new co_return statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:148,rout,routine,148,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new co_yield expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,rout,routine,149,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new compound literal expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new compound statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:147,rout,routine,147,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new conditional operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:161,rout,routine,161,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new constant array type given the element type, size; /// modifier, (known) size of the array, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:247,rout,routine,247,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new declaration statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:150,rout,routine,150,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new default statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:146,rout,routine,146,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new dependent-sized array type given the element type,; /// size modifier, size expression, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:16,depend,dependent-sized,16,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,"['depend', 'rout']","['dependent-sized', 'routine']"
Integrability,"/// Build a new designated initializer expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:163,rout,routine,163,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new do-while statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:147,rout,routine,147,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new expression in parentheses.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,rout,routine,155,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new expression list in parentheses.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,rout,routine,160,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new expression pack expansion.; ///; /// By default, performs semantic analysis to build a new pack expansion; /// for an expression. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:175,rout,routine,175,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new expression representing a call to a source location; /// builtin.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:194,rout,routine,194,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new expression that references a declaration.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:170,rout,routine,170,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['rout'],['routine']
Integrability,"/// Build a new expression trait expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new extended vector element access expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:171,rout,routine,171,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new extended vector type given the element type and; /// number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:203,rout,routine,203,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new for statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:142,rout,routine,142,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new function type.; ///; /// By default, performs semantic analysis when building the function type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:147,rout,routine,147,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new generic selection expression with a type predicate.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:180,rout,routine,180,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new generic selection expression with an expression predicate.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:187,rout,routine,187,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new goto statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:143,rout,routine,143,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new incomplete array type given the element type, size; /// modifier, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:222,rout,routine,222,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new indirect goto statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:152,rout,routine,152,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new initializer list expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new inline asm statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,rout,routine,149,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new iterator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,rout,routine,149,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new label statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:144,rout,routine,144,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new matrix subscript expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,/// Build a new matrix type given the type and dependently-defined; /// dimensions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,depend,dependently-defined,47,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependently-defined']
Integrability,"/// Build a new member access expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,rout,routine,154,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new member pointer type given the pointee type and the; /// class type it refers into.; ///; /// By default, performs semantic analysis when building the member pointer; /// type. Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:221,rout,routine,221,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new member reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,rout,routine,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['rout'],['routine']
Integrability,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1061,rout,routine,1061,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,2,"['depend', 'rout']","['dependent', 'routine']"
Integrability,"/// Build a new noexcept expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,rout,routine,149,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new object-construction expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,rout,routine,160,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,3,['rout'],['routine']
Integrability,"/// Build a new overloaded operator call expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// The semantic analysis provides the behavior of template instantiation,; /// copying with transformations that turn what looks like an overloaded; /// operator call into a use of a builtin operator, performing; /// argument-dependent lookup, etc. Subclasses may override this routine to; /// provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:359,depend,dependent,359,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,"['depend', 'rout']","['dependent', 'routine']"
Integrability,"/// Build a new pack expansion type.; ///; /// By default, builds a new PackExpansionType type from the given pattern.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,rout,routine,153,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new parenthesized type.; ///; /// By default, builds a new ParenType type from the inner type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:141,rout,routine,141,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new pointer type given its pointee type.; ///; /// By default, performs semantic analysis when building the pointer type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:168,rout,routine,168,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new potentially dependently-sized extended vector type; /// given the element type and number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:28,depend,dependently-sized,28,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,4,"['depend', 'rout']","['dependently-sized', 'routine']"
Integrability,"/// Build a new predefined expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:151,rout,routine,151,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new pseudo-destructor expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,rout,routine,158,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new qualified name type.; ///; /// By default, builds a new ElaboratedType type from the keyword,; /// the nested-name-specifier and the named type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:195,rout,routine,195,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new qualified type given its unqualified type and type location.; ///; /// By default, this routine adds type qualifiers only to types that can; /// have qualifiers, and silently suppresses those qualifiers that are not; /// permitted. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:104,rout,routine,104,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['rout'],['routine']
Integrability,"/// Build a new reference type given the type it references.; ///; /// By default, performs semantic analysis when building the; /// reference type. Subclasses may override this routine to provide; /// different behavior.; ///; /// \param LValue whether the type was written with an lvalue sigil; /// or an rvalue sigil.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:178,rout,routine,178,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new return statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:145,rout,routine,145,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new rewritten operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:159,rout,routine,159,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new shuffle vector expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,rout,routine,155,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new sizeof, alignof or vec step expression with an; /// expression argument.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:201,rout,routine,201,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new sizeof, alignof or vec_step expression with a; /// type argument.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:194,rout,routine,194,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new template argument pack expansion.; ///; /// By default, performs semantic analysis to build a new pack expansion; /// for a template argument. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:188,rout,routine,188,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new template name given a nested name specifier and the; /// name that is referred to as a template.; ///; /// By default, performs semantic analysis to determine whether the name can; /// be resolved to a specific template, then builds the appropriate kind of; /// template name. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:322,rout,routine,322,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new template name given a nested name specifier and the; /// overloaded operator name that is referred to as a template.; ///; /// By default, performs semantic analysis to determine whether the name can; /// be resolved to a specific template, then builds the appropriate kind of; /// template name. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:342,rout,routine,342,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new template name given a nested name specifier, a flag; /// indicating whether the ""template"" keyword was provided, and the template; /// that the template name refers to.; ///; /// By default, builds the new template name directly. Subclasses may override; /// this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:280,rout,routine,280,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new template name given a template template parameter pack; /// and the; ///; /// By default, performs semantic analysis to determine whether the name can; /// be resolved to a specific template, then builds the appropriate kind of; /// template name. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:293,rout,routine,293,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new template specialization type.; ///; /// By default, performs semantic analysis when building the template; /// specialization type. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:177,rout,routine,177,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new template-id expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:152,rout,routine,152,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new type trait expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:151,rout,routine,151,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new typename type that refers to a template-id.; ///; /// By default, builds a new DependentNameType type from the; /// nested-name-specifier and the given type. Subclasses may override; /// this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:95,Depend,DependentNameType,95,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,"['Depend', 'rout']","['DependentNameType', 'routine']"
Integrability,"/// Build a new typename type that refers to an identifier.; ///; /// By default, performs semantic analysis when building the typename type; /// (or elaborated type). Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:197,rout,routine,197,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new typeof(expr) type.; ///; /// By default, performs semantic analysis when building the typeof type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,rout,routine,149,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new unary operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,rout,routine,155,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new value-initialized expression.; ///; /// By default, builds the implicit value initialization without performing; /// any semantic analysis. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:185,rout,routine,185,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new variable-length array type given the element type,; /// size modifier, size expression, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:244,rout,routine,244,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new vector type given the element type and; /// number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:194,rout,routine,194,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Build a new while statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:144,rout,routine,144,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,/// Build a non-result-dependent generic selection expression accepting a; /// type predicate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:23,depend,dependent,23,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['depend'],['dependent']
Integrability,/// Build a result-dependent generic selection expression accepting a type; /// predicate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:19,depend,dependent,19,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['depend'],['dependent']
Integrability,/// Build a result-dependent generic selection expression accepting an; /// expression predicate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:19,depend,dependent,19,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['depend'],['dependent']
Integrability,/// Build a specialized and/or protocol-qualified Objective-C type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:31,protocol,protocol-qualified,31,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['protocol'],['protocol-qualified']
Integrability,"/// Build a wrapper struct that has 8-byte alignment. All heap allocations; /// should provide this much alignment at least, but this makes it clear we; /// specifically rely on this amount of alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:12,wrap,wrapper,12,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['wrap'],['wrapper']
Integrability,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:31,message,message,31,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,10,"['message', 'rout']","['message', 'messages', 'routine']"
Integrability,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:34,message,message,34,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,10,"['message', 'rout']","['message', 'messages', 'routine']"
Integrability,"/// Build an Objective-C object type.; ///; /// By default, performs semantic analysis when building the object type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:152,rout,routine,152,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,/// Build an empty clause.; ///; /// \param N Number of variables.; /// \param NumLoops Number of loops that is associated with this depend; /// clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:133,depend,depend,133,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['depend'],['depend']
Integrability,"/// Build and insert G_BRCOND \p Tst, \p Dest; ///; /// G_BRCOND is a conditional branch to \p Dest.; ///; /// \pre setBasicBlock or setMI must have been called.; /// \pre \p Tst must be a generic virtual register with scalar; /// type. At the beginning of legalization, this will be a single; /// bit (s1). Targets with interesting flags registers may change; /// this. For a wider type, whether the branch is taken must only; /// depend on bit 0 (for now).; ///; /// \return The newly created instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h:432,depend,depend,432,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,1,['depend'],['depend']
Integrability,"/// Build and insert \p Res = G_MERGE_VALUES \p Op0, ...; /// or \p Res = G_BUILD_VECTOR \p Op0, ...; /// or \p Res = G_CONCAT_VECTORS \p Op0, ...; ///; /// G_MERGE_VALUES combines the input elements contiguously into a larger; /// register. It is used when the destination register is not a vector.; /// G_BUILD_VECTOR combines scalar inputs into a vector register.; /// G_CONCAT_VECTORS combines vector inputs into a vector register.; ///; /// \pre setBasicBlock or setMI must have been called.; /// \pre The entire register \p Res (and no more) must be covered by the input; /// registers.; /// \pre The type of all \p Ops registers must be identical.; ///; /// \return a MachineInstrBuilder for the newly created instruction. The; /// opcode of the new instruction will depend on the types of both; /// the destination and the sources.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h:774,depend,depend,774,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,1,['depend'],['depend']
Integrability,"/// Build and insert \p Res = G_SEXT \p Op, \p Res = G_TRUNC \p Op, or; /// \p Res = COPY \p Op depending on the differing sizes of \p Res and \p Op.; /// ///; /// \pre setBasicBlock or setMI must have been called.; /// \pre \p Res must be a generic virtual register with scalar or vector type.; /// \pre \p Op must be a generic virtual register with scalar or vector type.; ///; /// \return The newly created instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h:96,depend,depending,96,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,1,['depend'],['depending']
Integrability,"/// Build and insert \p Res = G_ZEXT \p Op, \p Res = G_TRUNC \p Op, or; /// \p Res = COPY \p Op depending on the differing sizes of \p Res and \p Op.; /// ///; /// \pre setBasicBlock or setMI must have been called.; /// \pre \p Res must be a generic virtual register with scalar or vector type.; /// \pre \p Op must be a generic virtual register with scalar or vector type.; ///; /// \return The newly created instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h:96,depend,depending,96,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,1,['depend'],['depending']
Integrability,"/// Build and insert \p Res = \p ExtOpc, \p Res = G_TRUNC \p; /// Op, or \p Res = COPY \p Op depending on the differing sizes of \p Res and; /// \p Op.; /// ///; /// \pre setBasicBlock or setMI must have been called.; /// \pre \p Res must be a generic virtual register with scalar or vector type.; /// \pre \p Op must be a generic virtual register with scalar or vector type.; ///; /// \return The newly created instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h:93,depend,depending,93,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,1,['depend'],['depending']
Integrability,"/// Build calls to await_ready, await_suspend, and await_resume for a co_await; /// expression.; /// The generated AST tries to clean up temporary objects as early as; /// possible so that they don't live across suspension points if possible.; /// Having temporary objects living across suspension points unnecessarily can; /// lead to large frame size, and also lead to memory corruptions if the; /// coroutine frame is destroyed after coming back from suspension. This is done; /// by wrapping both the await_ready call and the await_suspend call with; /// ExprWithCleanups. In the end of this function, we also need to explicitly; /// set cleanup state so that the CoawaitExpr is also wrapped with an; /// ExprWithCleanups to clean up the awaiter associated with the co_await; /// expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:487,wrap,wrapping,487,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,2,['wrap'],"['wrapped', 'wrapping']"
Integrability,/// Build clause with number of variables \a N.; ///; /// \param StartLoc Starting location of the clause.; /// \param LParenLoc Location of '('.; /// \param EndLoc Ending location of the clause.; /// \param N Number of the variables in the clause.; /// \param NumLoops Number of loops that is associated with this depend; /// clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:315,depend,depend,315,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['depend'],['depend']
Integrability,/// Build loop data with counter value for depend clauses in ordered; /// directives.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:43,depend,depend,43,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['depend'],['depend']
Integrability,"/// Build the cloned blocks for an unswitched copy of the given loop.; ///; /// The cloned blocks are inserted before the loop preheader (`LoopPH`) and; /// after the split block (`SplitBB`) that will be used to select between the; /// cloned and original loop.; ///; /// This routine handles cloning all of the necessary loop blocks and exit; /// blocks including rewriting their instructions and the relevant PHI nodes.; /// Any loop blocks or exit blocks which are dominated by a different successor; /// than the one for this clone of the loop blocks can be trivially skipped. We; /// use the `DominatingSucc` map to determine whether a block satisfies that; /// property with a simple map lookup.; ///; /// It also correctly creates the unconditional branch in the cloned; /// unswitched parent block to only point at the unswitched successor.; ///; /// This does not handle most of the necessary updates to `LoopInfo`. Only exit; /// block splitting is correctly reflected in `LoopInfo`, essentially all of; /// the cloned blocks (and their loops) are left without full `LoopInfo`; /// updates. This also doesn't fully update `DominatorTree`. It adds the cloned; /// blocks to them but doesn't create the cloned `DominatorTree` structure and; /// instead the caller must recompute an accurate DT. It *does* correctly; /// update the `AssumptionCache` provided in `AC`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:277,rout,routine,277,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['rout'],['routine']
Integrability,"/// Build the coroutine body statements that require a non-dependent; /// promise type in order to construct.; ///; /// For example different new/delete overloads are selected depending on; /// if the promise type provides `unhandled_exception()`, and therefore they; /// cannot be built until the promise type is complete so that we can perform; /// name lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h:59,depend,dependent,59,interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,2,['depend'],"['dependent', 'depending']"
Integrability,"/// Build the coroutine body statements, including the; /// ""promise dependent"" statements when the promise type is not dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h:69,depend,dependent,69,interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,2,['depend'],['dependent']
Integrability,/// Build the internal SCCs for a RefSCC from a sequence of nodes.; ///; /// Appends the SCCs to the provided vector and updates the map with their; /// indices. Both the vector and map must be empty when passed into this; /// routine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:227,rout,routine,227,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['rout'],['routine']
Integrability,"/// Build the location list for all DBG_VALUEs in the function that; /// describe the same variable. The resulting DebugLocEntries will have; /// strict monotonically increasing begin addresses and will never; /// overlap. If the resulting list has only one entry that is valid; /// throughout variable's scope return true.; //; // See the definition of DbgValueHistoryMap::Entry for an explanation of the; // different kinds of history map entries. One thing to be aware of is that if; // a debug value is ended by another entry (rather than being valid until the; // end of the function), that entry's instruction may or may not be included in; // the range, depending on if the entry is a clobbering entry (it has an; // instruction that clobbers one or more preceding locations), or if it is an; // (overlapping) debug value entry. This distinction can be seen in the example; // below. The first debug value is ended by the clobbering entry 2, and the; // second and third debug values are ended by the overlapping debug value entry; // 4.; //; // Input:; //; // History map entries [type, end index, mi]; //; // 0 | [DbgValue, 2, DBG_VALUE $reg0, [...] (fragment 0, 32)]; // 1 | | [DbgValue, 4, DBG_VALUE $reg1, [...] (fragment 32, 32)]; // 2 | | [Clobber, $reg0 = [...], -, -]; // 3 | | [DbgValue, 4, DBG_VALUE 123, [...] (fragment 64, 32)]; // 4 [DbgValue, ~0, DBG_VALUE @g, [...] (fragment 0, 96)]; //; // Output [start, end) [Value...]:; //; // [0-1) [(reg0, fragment 0, 32)]; // [1-3) [(reg0, fragment 0, 32), (reg1, fragment 32, 32)]; // [3-4) [(reg1, fragment 32, 32), (123, fragment 64, 32)]; // [4-) [(@g, fragment 0, 96)]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:661,depend,depending,661,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['depend'],['depending']
Integrability,/// BuildAddressSpaceAttr - Builds a DependentAddressSpaceType if an expression; /// is uninstantiated. If instantiated it will apply the appropriate address; /// space to the type. This function allows dependent template variables to be; /// used in conjunction with the address_space attribute,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:37,Depend,DependentAddressSpaceType,37,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,2,"['Depend', 'depend']","['DependentAddressSpaceType', 'dependent']"
Integrability,/// BuildAppleKextVirtualCall - This routine is to support gcc's kext ABI making; /// indirect call to virtual functions. It makes the call through indexing; /// into the vtable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:37,rout,routine,37,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,1,['rout'],['routine']
Integrability,/// BuildByrefInfo - This routine changes a __block variable declared as T x; /// into:; ///; /// struct {; /// void *__isa;; /// void *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__copy_helper; // only if needed; /// void *__destroy_helper; // only if needed; /// void *__byref_variable_layout;// only if needed; /// char padding[X]; // only if needed; /// T x;; /// } x; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:26,rout,routine,26,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['rout'],['routine']
Integrability,"/// BuildObjCBoxedExpr - builds an ObjCBoxedExpr AST node for the; /// '@' prefixed parenthesized expression. The type of the expression will; /// either be ""NSNumber *"", ""NSString *"" or ""NSValue *"" depending on the type; /// of ValueType, which is allowed to be a built-in numeric type, ""char *"",; /// ""const char *"" or C structure with attribute 'objc_boxable'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:199,depend,depending,199,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['depend'],['depending']
Integrability,/// BuildVirtualCall - This routine makes indirect vtable call for; /// call to virtual destructors. It returns 0 if it could not do it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:28,rout,routine,28,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,1,['rout'],['routine']
Integrability,/// Builder interface. It doesn't build anything or keep any state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:12,interface,interface,12,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['interface'],['interface']
Integrability,/// Builder interface. Specify how to create the initial instruction itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:12,interface,interface,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,1,['interface'],['interface']
Integrability,"/// Builds a canonical type from a QualType.; ///; /// This routine is inherently unsafe, because it requires the user to; /// ensure that the given type is a canonical type with the correct; // (dynamic) type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h:60,rout,routine,60,interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h,1,['rout'],['routine']
Integrability,"/// Builds a dependency file when attached to a Preprocessor (for includes) and; /// ASTReader (for module imports), and writes it out at the end of processing; /// a source file. Users should attach to the ast reader whenever a module is; /// loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h:13,depend,dependency,13,interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,1,['depend'],['dependency']
Integrability,"/// Builds a specifier combining a prefix and an identifier.; ///; /// The prefix must be dependent, since nested name specifiers; /// referencing an identifier are only permitted when the identifier; /// cannot be resolved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h:90,depend,dependent,90,interpreter/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h,1,['depend'],['dependent']
Integrability,"/// Builds a specifier that consists of just an identifier.; ///; /// The nested-name-specifier is assumed to be dependent, but has no; /// prefix because the prefix is implied by something outside of the; /// nested name specifier, e.g., in ""x->Base::f"", the ""x"" has a dependent; /// type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h:113,depend,dependent,113,interpreter/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h,2,['depend'],['dependent']
Integrability,"/// Builds a statement that copies/moves the given entity from \p From to; /// \c To.; ///; /// This routine is used to copy/move the members of a class with an; /// implicitly-declared copy/move assignment operator. When the entities being; /// copied are arrays, this routine builds for loops to copy them.; ///; /// \param S The Sema object used for type-checking.; ///; /// \param Loc The location where the implicit copy/move is being generated.; ///; /// \param T The type of the expressions being copied/moved. Both expressions; /// must have this type.; ///; /// \param To The expression we are copying/moving to.; ///; /// \param From The expression we are copying/moving from.; ///; /// \param CopyingBaseSubobject Whether we're copying/moving a base subobject.; /// Otherwise, it's a non-static member subobject.; ///; /// \param Copying Whether we're copying or moving.; ///; /// \param Depth Internal parameter recording the depth of the recursion.; ///; /// \returns A statement or a loop that copies the expressions, or StmtResult(0); /// if a memcpy should be used instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:101,rout,routine,101,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['rout'],['routine']
Integrability,/// Builds a string representing ambiguous paths from a; /// specific derived class to different subobjects of the same base; /// class.; ///; /// This function builds a string that can be used in error messages; /// to show the different paths that one can take through the; /// inheritance hierarchy to go from the derived class to different; /// subobjects of a base class. The result looks something like this:; /// @code; /// struct D -> struct B -> struct A; /// struct D -> struct C -> struct A; /// @endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:203,message,messages,203,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['message'],['messages']
Integrability,/// C++ wrapper function result: Same as CWrapperFunctionResult but; /// auto-releases memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:8,wrap,wrapper,8,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,1,['wrap'],['wrapper']
Integrability,"/// CHAIN = STORE_VEC_BE CHAIN, VSRC, Ptr - Occurs only for little endian.; /// Maps directly to one of stxvd2x/stxvw4x/stxvh8x/stxvb16x depending on; /// the vector type to store vector in big-endian element order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:137,depend,depending,137,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['depend'],['depending']
Integrability,"/// CRTP base class providing obvious overloads for the core \c; /// Allocate() methods of LLVM-style allocators.; ///; /// This base class both documents the full public interface exposed by all; /// LLVM-style allocators, and redirects all of the overloads to a single core; /// set of methods which the derived class must define.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h:171,interface,interface,171,interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h,1,['interface'],['interface']
Integrability,"/// CRTP base class which implements the entire standard iterator facade; /// in terms of a minimal subset of the interface.; ///; /// Use this when it is reasonable to implement most of the iterator; /// functionality in terms of a core subset. If you need special behavior or; /// there are performance implications for this, you may want to override the; /// relevant members instead.; ///; /// Note, one abstraction that this does *not* provide is implementing; /// subtraction in terms of addition by negating the difference. Negation isn't; /// always information preserving, and I can see very reasonable iterator; /// designs where this doesn't work well. It doesn't really force much added; /// boilerplate anyways.; ///; /// Another abstraction that this doesn't provide is implementing increment in; /// terms of addition of one. These aren't equivalent for all iterator; /// categories, and respecting that adds a lot of complexity for little gain.; ///; /// Iterators are expected to have const rules analogous to pointers, with a; /// single, const-qualified operator*() that returns ReferenceT. This matches; /// the second and third pointers in the following example:; /// \code; /// int Value;; /// { int *I = &Value; } // ReferenceT 'int&'; /// { int *const I = &Value; } // ReferenceT 'int&'; const; /// { const int *I = &Value; } // ReferenceT 'const int&'; /// { const int *const I = &Value; } // ReferenceT 'const int&'; const; /// \endcode; /// If an iterator facade returns a handle to its own state, then T (and; /// PointerT and ReferenceT) should usually be const-qualified. Otherwise, if; /// clients are expected to modify the handle itself, the field can be declared; /// mutable or use const_cast.; ///; /// Classes wishing to use `iterator_facade_base` should implement the following; /// methods:; ///; /// Forward Iterators:; /// (All of the following methods); /// - DerivedT &operator=(const DerivedT &R);; /// - bool operator==(const DerivedT &R) const;; /// - T &",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:114,interface,interface,114,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,1,['interface'],['interface']
Integrability,"/// Cache of forward declarations for methods belonging to the interface.; /// The extra bit on the DISubprogram specifies whether a method is; /// ""objc_direct"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:63,interface,interface,63,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['interface'],['interface']
Integrability,/// Cache of previously constructed interfaces which may change.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:36,interface,interfaces,36,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['interface'],['interfaces']
Integrability,/// Cache storing single nonlocal def for the instruction.; /// It is set when nonlocal def would be found in function returning only; /// local dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:145,depend,dependencies,145,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['depend'],['dependencies']
Integrability,/// Caching wrapper around VBTableBuilder::enumerateVBTables().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:12,wrap,wrapper,12,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['wrap'],['wrapper']
Integrability,/// Calculate the new column for a line wrap before the next token.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:40,wrap,wrap,40,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,1,['wrap'],['wrap']
Integrability,"/// Calculate the nullability of the result of a message expr based on the; /// nullability of the receiver, the nullability of the return value, and the; /// constraints.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:49,message,message,49,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['message'],['message']
Integrability,/// Calculates control-dependent range for the given def at the given context; /// by looking at dominating conditions inside of the loop,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:23,depend,dependent,23,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['depend'],['dependent']
Integrability,"/// Calculates the SHA-1 state variable E from the SHA-1 state variables in; /// the 128-bit vector of [4 x i32] in \a __X, adds that to the next set of; /// four message elements in the 128-bit vector of [4 x i32] in \a __Y, and; /// returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1NEXTE instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing the current SHA-1 state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing the next four elements of the; /// message.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:163,message,message,163,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h,2,['message'],['message']
Integrability,"/// Call ReleasePred for each predecessor, then update register live def/gen.; /// Always update LiveRegDefs for a register dependence even if the current SU; /// also defines the register. This effectively create one large live range; /// across a sequence of two-address node. This is important because the; /// entire chain must be scheduled together. Example:; ///; /// flags = (3) add; /// flags = (2) addc flags; /// flags = (1) addc flags; ///; /// results in; ///; /// LiveRegDefs[flags] = 3; /// LiveRegGens[flags] = 1; ///; /// If (2) addc is unscheduled, then (1) addc must also be unscheduled to avoid; /// interference on flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:124,depend,dependence,124,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['depend'],['dependence']
Integrability,"/// Call a wrapper function. Caller should be callable as; /// WrapperFunctionResult Fn(const char *ArgData, size_t ArgSize);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:11,wrap,wrapper,11,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,2,"['Wrap', 'wrap']","['WrapperFunctionResult', 'wrapper']"
Integrability,"/// Call an async wrapper function.; /// Caller should be callable as; /// void Fn(unique_function<void(WrapperFunctionResult)> SendResult,; /// WrapperFunctionResult ArgBuffer);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:18,wrap,wrapper,18,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,3,"['Wrap', 'wrap']","['WrapperFunctionResult', 'wrapper']"
Integrability,/// Call sites that get wrapped by a gc.statepoint (currently only in; /// RewriteStatepointsForGC and potentially in other passes in the future) can; /// have attributes that describe properties of gc.statepoint call they will be; /// eventually be wrapped in. This struct is used represent such directives.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Statepoint.h:24,wrap,wrapped,24,interpreter/llvm-project/llvm/include/llvm/IR/Statepoint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Statepoint.h,2,['wrap'],['wrapped']
Integrability,"/// Call the appropriate runtime routine to initialize it before start; /// of loop.; /// This is used for non static scheduled types and when the ordered; /// clause is present on the loop construct.; /// Depending on the loop schedule, it is necessary to call some runtime; /// routine before start of the OpenMP loop to get the loop upper / lower; /// bounds \a LB and \a UB and stride \a ST.; ///; /// \param CGF Reference to current CodeGenFunction.; /// \param Loc Clang source location.; /// \param ScheduleKind Schedule kind, specified by the 'schedule' clause.; /// \param IVSize Size of the iteration variable in bits.; /// \param IVSigned Sign of the iteration variable.; /// \param Ordered true if loop is ordered, false otherwise.; /// \param DispatchValues struct containing llvm values for lower bound, upper; /// bound, and chunk expression.; /// For the default (nullptr) value, the chunk 1 will be used.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:33,rout,routine,33,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,3,"['Depend', 'rout']","['Depending', 'routine']"
Integrability,"/// Call the appropriate runtime routine to initialize it before start; /// of loop.; ///; /// This is used only in case of static schedule, when the user did not; /// specify a ordered clause on the loop construct.; /// Depending on the loop schedule, it is necessary to call some runtime; /// routine before start of the OpenMP loop to get the loop upper / lower; /// bounds LB and UB and stride ST.; ///; /// \param CGF Reference to current CodeGenFunction.; /// \param Loc Clang source location.; /// \param DKind Kind of the directive.; /// \param ScheduleKind Schedule kind, specified by the 'schedule' clause.; /// \param Values Input arguments for the construct.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:33,rout,routine,33,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,6,"['Depend', 'rout']","['Depending', 'routine']"
Integrability,/// Call the appropriate runtime routine to notify that we finished; /// all the work with current loop.; ///; /// \param CGF Reference to current CodeGenFunction.; /// \param Loc Clang source location.; /// \param DKind Kind of the directive for which the static finish is emitted.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:33,rout,routine,33,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,2,['rout'],['routine']
Integrability,/// Call the appropriate runtime routine to notify that we finished; /// iteration of the ordered loop with the dynamic scheduling.; ///; /// \param CGF Reference to current CodeGenFunction.; /// \param Loc Clang source location.; /// \param IVSize Size of the iteration variable in bits.; /// \param IVSigned Sign of the iteration variable.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:33,rout,routine,33,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,2,['rout'],['routine']
Integrability,/// Call the node-specific routine that folds each particular type of node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,rout,routine,27,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['rout'],['routine']
Integrability,"/// Call the node-specific routine that knows how to fold each; /// particular type of node. If that doesn't do anything, try the; /// target-specific DAG combines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,rout,routine,27,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['rout'],['routine']
Integrability,"/// Call to handle an incoming message.; ///; /// Returns 'Disconnect' if the message is a 'detach' message from the remote; /// otherwise returns 'Continue'. If the server has moved to an error state,; /// returns an error, which should be reported and treated as a 'Disconnect'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.h:31,message,message,31,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.h,3,['message'],['message']
Integrability,"/// Callback for generating the atomic reduction body, may be null. The IR; /// produced by this will be used to atomically combine two values during; /// reduction. If null, the implementation will use the non-atomic version; /// along with the appropriate synchronization mechanisms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:258,synchroniz,synchronization,258,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['synchroniz'],['synchronization']
Integrability,/// Callback invoked when a \#pragma message directive is read.; /// \param Loc The location of the message directive.; /// \param Namespace The namespace of the message directive.; /// \param Kind The type of the message directive.; /// \param Str The text of the message directive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PPCallbacks.h:37,message,message,37,interpreter/llvm-project/clang/include/clang/Lex/PPCallbacks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PPCallbacks.h,5,['message'],['message']
Integrability,"/// Callback that records textual includes and direct modular includes/imports; /// during preprocessing. At the end of the main file, it also collects; /// transitive modular dependencies and passes everything to the; /// \c DependencyConsumer of the parent \c ModuleDepCollector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:176,depend,dependencies,176,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,2,"['Depend', 'depend']","['DependencyConsumer', 'dependencies']"
Integrability,/// Callback to register the dependencies for a given query.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:29,depend,dependencies,29,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['depend'],['dependencies']
Integrability,/// Callbacks for computing dependency information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:28,depend,dependency,28,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,1,['depend'],['dependency']
Integrability,/// Called after executing the action on the synthesized input buffer.; ///; /// Executes both Wrapper and ExtractAPIBase end source file; /// actions. This is the place where all the gathered symbol graph; /// information is emited.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/FrontendActions.h:95,Wrap,Wrapper,95,interpreter/llvm-project/clang/include/clang/ExtractAPI/FrontendActions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/FrontendActions.h,1,['Wrap'],['Wrapper']
Integrability,/// Called by ActOnProperty and HandlePropertyInClassExtension to; /// handle creating the ObjcPropertyDecl for a category or \@interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:128,interface,interface,128,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['interface'],['interface']
Integrability,/// Called by CoreEngine.; /// Used to generate successor nodes for temporary destructors depending; /// on whether the corresponding constructor was visited.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h:90,depend,depending,90,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h,1,['depend'],['depending']
Integrability,/// Called by JITLink to notify the context that the object has been; /// finalized (i.e. emitted to memory and memory permissions set). If all of; /// this objects dependencies have also been finalized then the code is ready; /// to run.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:165,depend,dependencies,165,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['depend'],['dependencies']
Integrability,"/// Called by the framework or user code to report some event.; /// The event is associated with the current context (program point).; /// The Emit function produces the log message. It may or may not be called,; /// depending on if the logger is interested; it should have no side effects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Logger.h:174,message,message,174,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Logger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Logger.h,2,"['depend', 'message']","['depending', 'message']"
Integrability,/// Called during setup of the client to indicate that the client is ready; /// to receive messages.; ///; /// Transport objects should not access the client until this method is; /// called.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h:91,message,messages,91,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h,1,['message'],['messages']
Integrability,/// Called on well-formed 'depend' clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:27,depend,depend,27,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['depend'],['depend']
Integrability,/// Called on well-formed 'message' clause.; /// passing string for message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:27,message,message,27,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['message'],['message']
Integrability,/// Called when a new file is seen. Return true if \p Filename should be added; /// to the list of dependencies.; ///; /// The default implementation ignores <built-in> and system files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h:99,depend,dependencies,99,interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,1,['depend'],['dependencies']
Integrability,/// Called when the preprocessor is in 'dependency scanning lexing mode' and; /// is skipping a conditional block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Lexer.h:40,depend,dependency,40,interpreter/llvm-project/clang/include/clang/Lex/Lexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Lexer.h,1,['depend'],['dependency']
Integrability,/// Called when the preprocessor is in 'dependency scanning lexing mode'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Lexer.h:40,depend,dependency,40,interpreter/llvm-project/clang/include/clang/Lex/Lexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Lexer.h,1,['depend'],['dependency']
Integrability,/// Cannot tell whether this is a narrowing conversion because the; /// expression is value-dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:92,depend,dependent,92,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,1,['depend'],['dependent']
Integrability,"/// Canonicalize metadata arguments to intrinsics.; ///; /// To support bitcode upgrades (and assembly semantic sugar) for \a; /// MetadataAsValue, we need to canonicalize certain metadata.; ///; /// - nullptr is replaced by an empty MDNode.; /// - An MDNode with a single null operand is replaced by an empty MDNode.; /// - An MDNode whose only operand is a \a ConstantAsMetadata gets skipped.; ///; /// This maintains readability of bitcode from when metadata was a type of; /// value, and these bridges were unnecessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:498,bridg,bridges,498,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,1,['bridg'],['bridges']
Integrability,"/// Capture a change in pressure for a single pressure set. UnitInc may be; /// expressed in terms of upward or downward pressure depending on the client; /// and will be dynamically adjusted for current liveness.; ///; /// Pressure increments are tiny, typically 1-2 units, and this is only for; /// heuristics, so we don't check UnitInc overflow. Instead, we may have a; /// higher level assert that pressure is consistent within a region. We also; /// effectively ignore dead defs which don't affect heuristics much.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:130,depend,depending,130,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,1,['depend'],['depending']
Integrability,"/// Capture state between an inlining decision having had been made, and; /// its impact being observable. When collecting model training data, this; /// allows recording features/decisions/partial reward data sets.; ///; /// Derivations of this type are expected to be tightly coupled with their; /// InliningAdvisors. The base type implements the minimal contractual; /// obligations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:357,contract,contractual,357,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,1,['contract'],['contractual']
Integrability,"/// Capture the given expression as the result of this pseudo-object; /// operation. This routine is safe against expressions which may; /// already be captured.; ///; /// \returns the captured expression, which will be the; /// same as the input if the input was already captured",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:90,rout,routine,90,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,1,['rout'],['routine']
Integrability,"/// Captures attributes that affect generating LLVM-IR using the; /// OpenMPIRBuilder and related classes. Note that not all attributes are; /// required for all classes or functions. In some use cases the configuration; /// is not necessary at all, because because the only functions that are called; /// are ones that are not dependent on the configuration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:328,depend,dependent,328,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['depend'],['dependent']
Integrability,"/// Carry out call site analysis, in order to evaluate inlinability.; /// NOTE: the type is currently used as implementation detail of functions such; /// as llvm::getInlineCost. Note the function_ref constructor parameters - the; /// expectation is that they come from the outer scope, from the wrapper; /// functions. If we want to support constructing CallAnalyzer objects where; /// lambdas are provided inline at construction, or where the object needs to; /// otherwise survive past the scope of the provided functions, we need to; /// revisit the argument types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:296,wrap,wrapper,296,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['wrap'],['wrapper']
Integrability,"/// Cast a call or invoke instruction to the given type.; ///; /// When promoting a call site, the return type of the call site might not match; /// that of the callee. If this is the case, we have to cast the returned value; /// to the correct type. The location of the cast depends on if we have a call; /// or invoke instruction.; ///; /// For example, if the call instruction below requires a bitcast after; /// promotion:; ///; /// orig_bb:; /// %t0 = call i32 @func(); /// ...; ///; /// The bitcast is placed after the call instruction:; ///; /// orig_bb:; /// ; Uses of the original return value are replaced by uses of the bitcast.; /// %t0 = call i32 @func(); /// %t1 = bitcast i32 %t0 to ...; /// ...; ///; /// A similar transformation is performed for invoke instructions. However,; /// since invokes are terminating, a new block is created for the bitcast. For; /// example, if the invoke instruction below requires a bitcast after promotion:; ///; /// orig_bb:; /// %t0 = invoke i32 @func() to label %normal_dst unwind label %unwind_dst; ///; /// The edge between the original block and the invoke's normal destination is; /// split, and the bitcast is placed there:; ///; /// orig_bb:; /// %t0 = invoke i32 @func() to label %split_bb unwind label %unwind_dst; ///; /// split_bb:; /// ; Uses of the original return value are replaced by uses of the bitcast.; /// %t1 = bitcast i32 %t0 to ...; /// br label %normal_dst; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:276,depend,depends,276,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,1,['depend'],['depends']
Integrability,"/// Change message level (and topics) while this object is alive, reset when it goes out of scope.; /// \param[in] lvl The desired message level. Defaults to verbose.; /// \param[in] extraTopics Extra topics to be switched on. These will only switched on in the last stream to prevent; /// all streams are printing. \param[in] removeTopics Message topics to be switched off \param[in]; /// overrideExternalLevel Override the user message level.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooHelpers.h:11,message,message,11,roofit/roofitcore/inc/RooHelpers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooHelpers.h,4,"['Message', 'message']","['Message', 'message']"
Integrability,"/// Check a function for errors, useful for use when debugging a; /// pass.; ///; /// If there are no errors, the function returns false. If an error is found,; /// a message describing the error is written to OS (if non-null) and true is; /// returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h:167,message,message,167,interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,1,['message'],['message']
Integrability,/// Check a message send to see if it's likely to cause a retain cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:12,message,message,12,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['message'],['message']
Integrability,"/// Check a module for errors.; ///; /// If there are no errors, the function returns false. If an error is; /// found, a message describing the error is written to OS (if; /// non-null) and true is returned.; ///; /// \return true if the module is broken. If BrokenDebugInfo is; /// supplied, DebugInfo verification failures won't be considered as; /// error and instead *BrokenDebugInfo will be set to true. Debug; /// info errors can be ""recovered"" from by stripping the debug info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h:122,message,message,122,interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,1,['message'],['message']
Integrability,"/// Check a template argument against its corresponding; /// non-type template parameter.; ///; /// This routine implements the semantics of C++ [temp.arg.nontype].; /// If an error occurred, it returns ExprError(); otherwise, it; /// returns the converted template argument. \p ParamType is the; /// type of the non-type template parameter after it has been instantiated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:105,rout,routine,105,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['rout'],['routine']
Integrability,"/// Check a template argument against its corresponding; /// template template parameter.; ///; /// This routine implements the semantics of C++ [temp.arg.template].; /// It returns true if an error occurred, and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:105,rout,routine,105,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['rout'],['routine']
Integrability,"/// Check a template argument against its corresponding; /// template type parameter.; ///; /// This routine implements the semantics of C++ [temp.arg.type]. It; /// returns true if an error occurred, and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:101,rout,routine,101,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['rout'],['routine']
Integrability,/// Check case of non-existing \@interface decl.; /// (legacy objective-c \@implementation decl without an \@interface decl).; /// Add implementations's ivar to the synthesize class's ivar list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,interface,interface,33,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['interface'],['interface']
Integrability,/// Check dependend DIEs for incompatible placement.; /// Make placement to be consistent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:10,depend,dependend,10,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,1,['depend'],['dependend']
Integrability,"/// Check for class dependent properties at Finish.; /// \returns true if D1 and D2 may be equivalent,; /// false if they are for sure not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h:20,depend,dependent,20,interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,1,['depend'],['dependent']
Integrability,/// Check for duplicate interface declaration for this category,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,interface,interface,24,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['interface'],['interface']
Integrability,/// Check if DstReg can be replaced with SrcReg depending on the register; /// constraints.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h:48,depend,depending,48,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h,1,['depend'],['depending']
Integrability,"/// Check if \p E is a C++ ""this"" pointer wrapped in value-preserving casts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:42,wrap,wrapped,42,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['wrap'],['wrapped']
Integrability,"/// Check if a single argument falls into a specific ""range"".; /// A range is formed as a set of intervals.; /// E.g. \code {['A', 'Z'], ['a', 'z'], ['_', '_']} \endcode; /// The intervals are closed intervals that contain one or more values.; ///; /// The default constructed RangeConstraint has an empty range, applying; /// such constraint does not involve any assumptions, thus the State remains; /// unchanged. This is meaningful, if the range is dependent on a looked up; /// type (e.g. [0, Socklen_tMax]). If the type is not found, then the range; /// is default initialized to be empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:452,depend,dependent,452,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['depend'],['dependent']
Integrability,"/// Check if a type has any reference to a declaration that is inside the body; /// of a function.; /// The \c CheckType(QualType) function should be used to determine; /// this property.; ///; /// The type visitor visits one type object only (not recursive).; /// To find all referenced declarations we must discover all type objects until; /// the canonical type is reached (walk over typedef and similar objects). This; /// is done by loop over all ""sugar"" type objects. For every such type we must; /// check all declarations that are referenced from it. For this check the; /// visitor is used. In the visit functions all referenced declarations except; /// the one that follows in the sugar chain (if any) must be checked. For this; /// check the same visitor is re-used (it has no state-dependent data).; ///; /// The visit functions have 3 possible return values:; /// - True, found a declaration inside \c ParentDC.; /// - False, found declarations only outside \c ParentDC and it is not possible; /// to find more declarations (the ""sugar"" chain does not continue).; /// - Empty optional value, found no declarations or only outside \c ParentDC,; /// but it is possible to find more declarations in the type ""sugar"" chain.; /// The loop over the ""sugar"" types can be implemented by using type visit; /// functions only (call \c CheckType with the desugared type). With the current; /// solution no visit function is needed if the type has only a desugared type; /// as data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:794,depend,dependent,794,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['depend'],['dependent']
Integrability,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:54,rout,routine,54,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,1,['rout'],['routine']
Integrability,"/// Check if all components that depend on `obs` are binned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealSumPdf.cxx:33,depend,depend,33,roofit/roofitcore/src/RooRealSumPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealSumPdf.cxx,1,['depend'],['depend']
Integrability,/// Check if dependencies have incompatible placement.; /// If that is the case modify placement to be compatible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:13,depend,dependencies,13,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,1,['depend'],['dependencies']
Integrability,"/// Check if dependencies have incompatible placement.; /// If that is the case modify placement to be compatible.; /// \returns true if any placement was updated, otherwise returns false.; /// This method should be called as a followup processing after; /// resolveDependenciesAndMarkLiveness().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:13,depend,dependencies,13,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,1,['depend'],['dependencies']
Integrability,/// Check if instruction IR only depends on memory instructions that are; /// currently executing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:33,depend,depends,33,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['depend'],['depends']
Integrability,/// Check if passed in Decl is a pointer type.; /// Note that this function may produce an error message.; /// \return true if the Decl is a pointer type; false otherwise,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:97,message,message,97,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['message'],['message']
Integrability,/// Check if protocol lists are the same and diagnose if they are different.; ///; /// Returns true if found a mismatch and diagnosed it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRDiagsEmitter.h:13,protocol,protocol,13,interpreter/llvm-project/clang/include/clang/AST/ODRDiagsEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRDiagsEmitter.h,1,['protocol'],['protocol']
Integrability,/// Check if shrink wrapping is enabled for this target and function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:20,wrap,wrapping,20,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['wrap'],['wrapping']
Integrability,"/// Check if the any of the methods inside the interface are annotated with; /// the invalidation annotation, update the IvarInfo accordingly.; /// \param LookForPartial is set when we are searching for partial; /// invalidators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:47,interface,interface,47,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,1,['interface'],['interface']
Integrability,/// Check if the instruction MI can be safely moved over a set of instructions; /// whose side-effects (in terms of register defs and uses) are expressed in; /// the maps Defs and Uses. These maps reflect the conditional defs and uses; /// that depend on the same predicate register to allow moving instructions; /// over instructions predicated on the opposite condition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:245,depend,depend,245,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['depend'],['depend']
Integrability,"/// Check if the instruction \p I is executed in an aligned region, that is,; /// the synchronizing effects before and after \p I are both aligned barriers.; /// This effectively means all threads execute \p I together.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:86,synchroniz,synchronizing,86,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['synchroniz'],['synchronizing']
Integrability,/// Check if the toolchain should use AsmParser to parse inlineAsm when; /// integrated assembler is not default.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h:77,integrat,integrated,77,interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,1,['integrat'],['integrated']
Integrability,/// Check if the toolchain should use the integrated assembler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h:42,integrat,integrated,42,interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,1,['integrat'],['integrated']
Integrability,/// Check if the toolchain should use the integrated backend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h:42,integrat,integrated,42,interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,1,['integrat'],['integrated']
Integrability,/// Check if there is a dependent call earlier that does not have anything in; /// between the Retain and the call that can affect the reference count of their; /// shared pointer argument. Note that Retain need not be in BB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:24,depend,dependent,24,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['depend'],['dependent']
Integrability,/// Check if this action have any offload kinds. Note that host offload kinds; /// are only set if the action is a dependence to a host offload action.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h:115,depend,dependence,115,interpreter/llvm-project/clang/include/clang/Driver/Action.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h,1,['depend'],['dependence']
Integrability,"/// Check if we can emit a run-time no-alias check for \p Access.; ///; /// Returns true if we can emit a run-time no alias check for \p Access.; /// If we can check this access, this also adds it to a dependence set and; /// adds a run-time to check for it to \p RtCheck. If \p Assume is true,; /// we will attempt to use additional run-time checks in order to get; /// the bounds of the pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:202,depend,dependence,202,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependence']
Integrability,"/// Check null or non-null-ness of an argument that is of pointer type.; /// The argument is meant to be a buffer that has a size constraint, and it; /// is allowed to have a NULL value if the size is 0. The size can depend on; /// 1 or 2 additional arguments, if one of these is 0 the buffer is allowed to; /// be NULL. This is useful for functions like `fread` which have this special; /// property.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:217,depend,depend,217,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['depend'],['depend']
Integrability,/// Check original debug information after a pass.; ///; /// \param M The module to collect debug information from.; /// \param Functions A range of functions to collect debug information from.; /// \param DebugInfoBeforePass DI metadata before a pass.; /// \param Banner A prefix string to add to debug/error messages.; /// \param NameOfWrappedPass A name of a pass to add to debug/error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:310,message,messages,310,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,2,['message'],['messages']
Integrability,"/// Check specified statement that it is suitable for 'atomic update'; /// constructs and extract 'x', 'expr' and Operation from the original; /// expression. If DiagId and NoteId == 0, then only check is performed; /// without error notification.; /// \param DiagId Diagnostic which should be emitted if error is found.; /// \param NoteId Diagnostic note for the main error message.; /// \return true if statement is not an update expression, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:375,message,message,375,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['message'],['message']
Integrability,"/// Check that implicit conversion sequences can be formed for each argument; /// whose corresponding parameter has a non-dependent type, per DR1391's; /// [temp.deduct.call]p10.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:122,depend,dependent,122,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['depend'],['dependent']
Integrability,"/// Check that the given Index expression is a valid array designator; /// value. This is essentially just a wrapper around; /// VerifyIntegerConstantExpression that also checks for negative values; /// and produces a reasonable diagnostic if there is a; /// failure. Returns the index expression, possibly with an implicit cast; /// added, on success. If everything went okay, Value will receive the; /// value of the constant expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:109,wrap,wrapper,109,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['wrap'],['wrapper']
Integrability,"/// Check that the given field is initialized within a constexpr constructor.; ///; /// \param Dcl The constexpr constructor being checked.; /// \param Field The field being checked. This may be a member of an anonymous; /// struct or union nested within the class being checked.; /// \param Inits All declarations, including anonymous struct/union members and; /// indirect members, for which any initialization was provided.; /// \param Diagnosed Whether we've emitted the error message yet. Used to attach; /// multiple notes for different members to the same error.; /// \param Kind Whether we're diagnosing a constructor as written or determining; /// whether the formal requirements are satisfied.; /// \return \c false if we're checking for validity and the constructor does; /// not satisfy the requirements on a constexpr constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:481,message,message,481,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['message'],['message']
Integrability,"/// Check that the integration over a subrange works when using an analytical; /// convolution with the RooTruthModel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooTruthModel.cxx:19,integrat,integration,19,roofit/roofitcore/test/testRooTruthModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooTruthModel.cxx,1,['integrat'],['integration']
Integrability,"/// Check that there is no dependencies preventing if conversion.; ///; /// If instruction uses any values that are defined in the head basic block,; /// the defining instructions are added to InsertAfter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:27,depend,dependencies,27,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,1,['depend'],['dependencies']
Integrability,"/// Check the constraints on operands to unary expression and type; /// traits.; ///; /// This will complete any types necessary, and validate the various constraints; /// on those operands.; ///; /// The UsualUnaryConversions() function is *not* called by this routine.; /// C99 6.3.2.1p[2-4] all state:; /// Except when it is the operand of the sizeof operator ...; ///; /// C++ [expr.sizeof]p4; /// The lvalue-to-rvalue, array-to-pointer, and function-to-pointer; /// standard conversions are not applied to the operand of sizeof.; ///; /// This policy is followed for all of the unary trait expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:262,rout,routine,262,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['rout'],['routine']
Integrability,/// Check the dependence for two accesses with the same stride \p Stride.; /// \p Distance is the positive distance and \p TypeByteSize is type size in; /// bytes.; ///; /// \returns true if they are independent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:14,depend,dependence,14,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependence']
Integrability,"/// Check the validity of a binary arithmetic operation w.r.t. pointer; /// operands.; ///; /// This routine will diagnose any invalid arithmetic on pointer operands much; /// like \see checkArithmeticOpPointerOperand. However, it has special logic; /// for emitting a single diagnostic even for operations where both LHS and RHS; /// are (potentially problematic) pointers.; ///; /// \returns True when the operand is valid to use (even if as an extension).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:101,rout,routine,101,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['rout'],['routine']
Integrability,/// Check then save referenced protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,protocol,protocols,31,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocols']
Integrability,/// Check this Objective-C property against a property declared in the; /// given protocol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:82,protocol,protocol,82,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['protocol'],['protocol']
Integrability,"/// Check whether _Complex long double should use the ""fp2ret"" flavor; /// of Objective-C message passing on this target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:90,message,message,90,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['message'],['message']
Integrability,"/// Check whether a compaction lowering can be done by dropping even/odd; /// elements and compute how many times even/odd elements must be dropped.; ///; /// This handles shuffles which take every Nth element where N is a power of; /// two. Example shuffle masks:; ///; /// (even); /// N = 1: 0, 2, 4, 6, 8, 10, 12, 14, 0, 2, 4, 6, 8, 10, 12, 14; /// N = 1: 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30; /// N = 2: 0, 4, 8, 12, 0, 4, 8, 12, 0, 4, 8, 12, 0, 4, 8, 12; /// N = 2: 0, 4, 8, 12, 16, 20, 24, 28, 0, 4, 8, 12, 16, 20, 24, 28; /// N = 3: 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8; /// N = 3: 0, 8, 16, 24, 0, 8, 16, 24, 0, 8, 16, 24, 0, 8, 16, 24; ///; /// (odd); /// N = 1: 1, 3, 5, 7, 9, 11, 13, 15, 0, 2, 4, 6, 8, 10, 12, 14; /// N = 1: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31; ///; /// Any of these lanes can of course be undef.; ///; /// This routine only supports N <= 3.; /// FIXME: Evaluate whether either AVX or AVX-512 have any opportunities here; /// for larger N.; ///; /// \returns N above, or the number of times even/odd elements must be dropped; /// if there is such a number. Otherwise returns zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:894,rout,routine,894,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['rout'],['routine']
Integrability,/// Check whether a pointer address cannot wrap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:43,wrap,wrap,43,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['wrap'],['wrap']
Integrability,"/// Check whether a specialization is well-formed in the current; /// context.; ///; /// This routine determines whether a template specialization can be declared; /// in the current context (C++ [temp.expl.spec]p2).; ///; /// \param S the semantic analysis object for which this check is being; /// performed.; ///; /// \param Specialized the entity being specialized or instantiated, which; /// may be a kind of template (class template, function template, etc.) or; /// a member of a class template (member function, static data member,; /// member class).; ///; /// \param PrevDecl the previous declaration of this entity, if any.; ///; /// \param Loc the location of the explicit specialization or instantiation of; /// this entity.; ///; /// \param IsPartialSpecialization whether this is a partial specialization of; /// a class template.; ///; /// \returns true if there was an error that we cannot recover from, false; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:94,rout,routine,94,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['rout'],['routine']
Integrability,/// Check whether or not Save and Restore points are still interesting for; /// shrink-wrapping.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:87,wrap,wrapping,87,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['wrap'],['wrapping']
Integrability,/// Check whether or not the given \p MBB can be used as a epilogue; /// for the target.; /// The epilogue will be inserted before the first terminator of that block.; /// This method is used by the shrink-wrapping pass to decide if; /// \p MBB will be correctly handled by the target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.h:206,wrap,wrapping,206,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.h,2,['wrap'],['wrapping']
Integrability,"/// Check whether or not the given \p MBB can be used as a epilogue; /// for the target.; /// The epilogue will be inserted before the first terminator of that block.; /// This method is used by the shrink-wrapping pass to decide if; /// \p MBB will be correctly handled by the target.; /// As soon as the target enable shrink-wrapping without overriding; /// this method, we assume that each basic block is a valid; /// epilogue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:206,wrap,wrapping,206,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,2,['wrap'],['wrapping']
Integrability,"/// Check whether or not the given \p MBB can be used as a prologue; /// for the target.; /// The prologue will be inserted first in this basic block.; /// This method is used by the shrink-wrapping pass to decide if; /// \p MBB will be correctly handled by the target.; /// As soon as the target enable shrink-wrapping without overriding; /// this method, we assume that each basic block is a valid; /// prologue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:190,wrap,wrapping,190,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,4,['wrap'],['wrapping']
Integrability,/// Check whether specified \p CUDie is a Clang module reference.; /// if \p Quiet is false then display error messages.; /// \return first == true if CUDie is a Clang module reference.; /// second == true if module is already loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h:111,message,messages,111,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,2,['message'],['messages']
Integrability,"/// Check whether the constant contains a sequence of contiguous ones,; /// which might be interrupted by one or two chunks. If so, materialize the; /// sequence of contiguous ones with an ORR instruction.; /// Materialize the chunks which are either interrupting the sequence or outside; /// of the sequence with a MOVK instruction.; ///; /// Assuming S is a chunk which starts the sequence (1...0...), E is a chunk; /// which ends the sequence (0...1...). Then we are looking for constants which; /// contain at least one S and E chunk.; /// E.g. |E|A|B|S|, |A|E|B|S| or |A|B|E|S|.; ///; /// We are also looking for constants like |S|A|B|E| where the contiguous; /// sequence of ones wraps around the MSB into the LSB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp:686,wrap,wraps,686,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp,1,['wrap'],['wraps']
Integrability,/// Check whether the data dependence could prevent store-load; /// forwarding.; ///; /// \return false if we shouldn't vectorize at all or avoid larger; /// vectorization factors by limiting MinDepDistBytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:27,depend,dependence,27,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['depend'],['dependence']
Integrability,/// Check whether the dependencies between the accesses are safe.; ///; /// Only checks sets with elements in \p CheckDeps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:22,depend,dependencies,22,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['depend'],['dependencies']
Integrability,/// Check whether the given call has no side-effects.; /// Specifically checks for math routimes which sometimes set errno.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:88,rout,routimes,88,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,1,['rout'],['routimes']
Integrability,"/// Check whether the given real type should use the ""fpret"" flavor of; /// Objective-C message passing on this target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:88,message,message,88,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['message'],['message']
Integrability,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:39,depend,dependence,39,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,5,['depend'],['dependence']
Integrability,"/// Check whether this array fits the idiom of a flexible array member,; /// depending on the value of -fstrict-flex-array.; /// When IgnoreTemplateOrMacroSubstitution is set, it doesn't consider sizes; /// resulting from the substitution of a macro or a template as special sizes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:77,depend,depending,77,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['depend'],['depending']
Integrability,"/// CheckAssignmentConstraints (C99 6.5.16) - This routine currently; /// has code to accommodate several GCC extensions when type checking; /// pointers. Here are some objectionable examples that GCC considers warnings:; ///; /// int a, *pint;; /// short *pshort;; /// struct foo *pfoo;; ///; /// pint = pshort; // warning: assignment from incompatible pointer type; /// a = pint; // warning: assignment makes integer from pointer without a cast; /// pint = a; // warning: assignment makes pointer from integer without a cast; /// pint = pfoo; // warning: assignment from incompatible pointer type; ///; /// As a result, the code for dealing with pointers is more complex than the; /// C99 spec dictates.; ///; /// Sets 'Kind' for any result kind except Incompatible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:51,rout,routine,51,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['rout'],['routine']
Integrability,"/// CheckConstructorDeclarator - Called by ActOnDeclarator to check; /// the well-formedness of the constructor declarator @p D with type @p; /// R. If there are any errors in the declarator, this routine will; /// emit diagnostics and set the invalid bit to true. In any case, the type; /// will be updated to reflect a well-formed type for the constructor and; /// returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:197,rout,routine,197,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['rout'],['routine']
Integrability,"/// CheckConversionDeclarator - Called by ActOnDeclarator to check the; /// well-formednes of the conversion function declarator @p D with; /// type @p R. If there are any errors in the declarator, this routine; /// will emit diagnostics and return true. Otherwise, it will return; /// false. Either way, the type @p R will be updated to reflect a; /// well-formed type for the conversion operator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:203,rout,routine,203,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['rout'],['routine']
Integrability,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:375,rout,routine,375,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['rout'],['routine']
Integrability,"/// CheckDestructorDeclarator - Called by ActOnDeclarator to check; /// the well-formednes of the destructor declarator @p D with type @p; /// R. If there are any errors in the declarator, this routine will; /// emit diagnostics and set the declarator to invalid. Even if this happens,; /// will be updated to reflect a well-formed type for the destructor and; /// returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:194,rout,routine,194,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['rout'],['routine']
Integrability,"/// CheckExtraCXXDefaultArguments - Check for any extra default; /// arguments in the declarator, which is not a function declaration; /// or definition and therefore is not permitted to have default; /// arguments. This routine should be invoked for every declarator; /// that is not a function declaration or definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:221,rout,routine,221,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['rout'],['routine']
Integrability,"/// CheckForPhysRegDependency - Check if the dependency between def and use of; /// a specified operand is a physical register dependency. If so, returns the; /// register and the cost of copying the register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:45,depend,dependency,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,2,['depend'],['dependency']
Integrability,/// CheckImplementationIvars - This routine checks if the instance variables; /// listed in the implelementation match those listed in the interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:36,rout,routine,36,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['interface', 'rout']","['interface', 'routine']"
Integrability,"/// CheckIncrementDecrementOperand - unlike most ""Check"" methods, this routine; /// doesn't need to call UsualUnaryConversions or UsualArithmeticConversions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:71,rout,routine,71,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['rout'],['routine']
Integrability,/// CheckKeyForObjCARCConversion - This routine suggests bridge casting of CF; /// objects used as dictionary subscript key objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:40,rout,routine,40,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,2,"['bridg', 'rout']","['bridge', 'routine']"
Integrability,"/// CheckMemberPointerConversion - Check the member pointer conversion from the; /// expression From to the type ToType. This routine checks for ambiguous or; /// virtual or inaccessible base-to-derived member pointer conversions; /// for which IsMemberPointerConversion has already returned true. It returns; /// true and produces a diagnostic if there was an error, or returns false; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:126,rout,routine,126,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['rout'],['routine']
Integrability,/// CheckMessageArgumentTypes - Check types in an Obj-C message send.; /// \param Method - May be null.; /// \param [out] ReturnType - The return type of the send.; /// \return true iff there were any incompatible types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:56,message,message,56,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['message'],['message']
Integrability,"/// CheckPointerConversion - Check the pointer conversion from the; /// expression From to the type ToType. This routine checks for; /// ambiguous or inaccessible derived-to-base pointer; /// conversions for which IsPointerConversion has already returned; /// true. It returns true and produces a diagnostic if there was an; /// error, or returns false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:113,rout,routine,113,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['rout'],['routine']
Integrability,"/// CheckProtocolMethodDefs - This routine checks unimplemented methods; /// Declared in protocol, and those referenced by it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:35,rout,routine,35,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,"['protocol', 'rout']","['protocol', 'routine']"
Integrability,"/// CheckSubscriptingKind - This routine decide what type; /// of indexing represented by ""FromE"" is being done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:33,rout,routine,33,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,1,['rout'],['routine']
Integrability,/// Checking non-dependent argument conversions failed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:17,depend,dependent,17,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['depend'],['dependent']
Integrability,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:434,Depend,Depending,434,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['Depend'],['Depending']
Integrability,/// Checks if \p MI is TargetOpcode::G_FMUL and contractable either; /// due to global flags or MachineInstr flags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:48,contract,contractable,48,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['contract'],['contractable']
Integrability,"/// Checks if a bundle of instructions can be scheduled, i.e. has no; /// cyclic dependencies. This is only a dry-run, no instructions are; /// actually moved at this stage.; /// \returns the scheduling bundle. The returned Optional value is not; /// std::nullopt if \p VL is allowed to be scheduled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:81,depend,dependencies,81,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependencies']
Integrability,/// Checks if the function is some form of interrupt service routine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRMachineFunctionInfo.h:61,rout,routine,61,interpreter/llvm-project/llvm/lib/Target/AVR/AVRMachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRMachineFunctionInfo.h,1,['rout'],['routine']
Integrability,/// Checks if the new declaration declared in dependent context must be; /// put in the same redeclaration chain as the specified declaration.; ///; /// \param D Declaration that is checked.; /// \param PrevDecl Previous declaration found with proper lookup method for the; /// same declaration name.; /// \returns True if D must be added to the redeclaration chain which PrevDecl; /// belongs to.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:46,depend,dependent,46,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,/// Checks if the provide statement depends on the loop counter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:36,depend,depends,36,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['depend'],['depends']
Integrability,/// Checks if the specified entry \p E needs to be delayed because of its; /// dependency nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:79,depend,dependency,79,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['depend'],['dependency']
Integrability,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:18,depend,dependences,18,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,3,['depend'],"['dependence', 'dependences', 'dependencies']"
Integrability,"/// Checks that the given nested-name qualifier used in a using decl; /// in the current context is appropriately related to the current; /// scope. If an error is found, diagnoses it and returns true.; /// R is nullptr, if the caller has not (yet) done a lookup, otherwise it's the; /// result of that lookup. UD is likewise nullptr, except when we have an; /// already-populated UsingDecl whose shadow decls contain the same information; /// (i.e. we're instantiating a UsingDecl with non-dependent scope).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:491,depend,dependent,491,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"/// Checks the bisect limit to determine if the specified pass should run.; ///; /// The method prints the name of the pass, its assigned bisect number, and; /// whether or not the pass will be executed. It returns true if the pass; /// should run, i.e. if the bisect limit is set to -1 or has not yet been; /// exceeded.; ///; /// Most passes should not call this routine directly. Instead, it is called; /// through helper routines provided by the base classes of the pass. For; /// instance, function passes should call FunctionPass::skipFunction().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h:365,rout,routine,365,interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h,2,['rout'],"['routine', 'routines']"
Integrability,/// Checks to see if the @p O ObjectFile is a Mach-O file and if it is and there; /// is a list of architecture flags specified then check to make sure this; /// Mach-O file is one of those architectures or all architectures was; /// specificed. If not then an error is generated and this routine returns; /// false. Else it returns true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-size/llvm-size.cpp:289,rout,routine,289,interpreter/llvm-project/llvm/tools/llvm-size/llvm-size.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-size/llvm-size.cpp,1,['rout'],['routine']
Integrability,"/// Checks whether one class is derived from another, inclusively.; /// Properly indicates when it couldn't be determined due to; /// dependence.; ///; /// This should probably be donated to AST or at least Sema.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:134,depend,dependence,134,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['depend'],['dependence']
Integrability,/// Clang integrated assembler tool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.h:10,integrat,integrated,10,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.h,1,['integrat'],['integrated']
Integrability,/// Class interface for this class/category implementation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:10,interface,interface,10,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['interface'],['interface']
Integrability,"/// Class to determine where the safe point to insert the; /// prologue and epilogue are.; /// Unlike the paper from Fred C. Chow, PLDI'88, that introduces the; /// shrink-wrapping term for prologue/epilogue placement, this pass; /// does not rely on expensive data-flow analysis. Instead we use the; /// dominance properties and loop information to decide which point; /// are safe for such insertion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:172,wrap,wrapping,172,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['wrap'],['wrapping']
Integrability,"/// Class to encapsulate the logic for formatting a diagnostic message.; ///; /// Actual ""printing"" logic is implemented by subclasses.; ///; /// This class provides an interface for building and emitting; /// diagnostic, including all of the macro backtraces, caret diagnostics, FixIt; /// Hints, and code snippets. In the presence of macros this involves; /// a recursive process, synthesizing notes for each macro expansion.; ///; /// A brief worklist:; /// FIXME: Sink the recursive printing of template instantiations into this; /// class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/DiagnosticRenderer.h:63,message,message,63,interpreter/llvm-project/clang/include/clang/Frontend/DiagnosticRenderer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/DiagnosticRenderer.h,2,"['interface', 'message']","['interface', 'message']"
Integrability,"/// Class to encapsulate the logic for formatting and printing a textual; /// diagnostic message.; ///; /// This class provides an interface for building and emitting a textual; /// diagnostic, including all of the macro backtraces, caret diagnostics, FixIt; /// Hints, and code snippets. In the presence of macros this involves; /// a recursive process, synthesizing notes for each macro expansion.; ///; /// The purpose of this class is to isolate the implementation of printing; /// beautiful text diagnostics from any particular interfaces. The Clang; /// DiagnosticClient is implemented through this class as is diagnostic; /// printing coming out of libclang.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/TextDiagnostic.h:89,message,message,89,interpreter/llvm-project/clang/include/clang/Frontend/TextDiagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/TextDiagnostic.h,3,"['interface', 'message']","['interface', 'interfaces', 'message']"
Integrability,"/// Class to represent target extensions types, which are generally; /// unintrospectable from target-independent optimizations.; ///; /// Target extension types have a string name, and optionally have type and/or; /// integer parameters. The exact meaning of any parameters is dependent on the; /// target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h:278,depend,dependent,278,interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,1,['depend'],['dependent']
Integrability,"/// Class to wrap a pointer and delete the memory associated to it; /// correctly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:13,wrap,wrap,13,tree/dataframe/inc/ROOT/RDataSource.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx,1,['wrap'],['wrap']
Integrability,"/// Class which can be overriden by targets to enforce instruction; /// dependencies and behaviours that aren't expressed well enough; /// within the scheduling model for mca to automatically simulate; /// them properly.; /// If you implement this class for your target, make sure to also implement; /// a target specific InstrPostProcess class as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h:72,depend,dependencies,72,interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,1,['depend'],['dependencies']
Integrability,/// Class which implements the core thread safety analysis routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:59,rout,routines,59,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,1,['rout'],['routines']
Integrability,"/// ClassImplementsProtocol - Checks that 'lProto' protocol; /// has been implemented in IDecl class, its super class or categories (if; /// lookupCategory is true).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:51,protocol,protocol,51,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,2,['protocol'],['protocol']
Integrability,"/// Classes behaving as a collection of elements that can be queried via the `TVirtualCollectionProxy` interface; /// The use of a collection proxy for a particular class can be enabled via:; /// ```; /// namespace ROOT::Experimental {; /// template <> struct IsCollectionProxy<Classname> : std::true_type {};; /// }; /// ```; /// Alternatively, this can be achieved by adding a member type to the class definition as follows:; /// ```; /// class Classname {; /// public:; /// using IsCollectionProxy = std::true_type;; /// };; /// ```",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx:103,interface,interface,103,tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx,1,['interface'],['interface']
Integrability,"/// Clear the cache payload but retain slot mapping w.r.t to; /// normalization and integration sets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:84,integrat,integration,84,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,1,['integrat'],['integration']
Integrability,/// Clear the error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:20,message,message,20,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['message'],['message']
Integrability,/// Clears all dependency information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,depend,dependency,15,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependency']
Integrability,"/// Clients of various APIs that cause global effects on; /// the DAG can optionally implement this interface. This allows the clients; /// to handle the various sorts of updates that happen.; ///; /// A DAGUpdateListener automatically registers itself with DAG when it is; /// constructed, and removes itself when destroyed in RAII fashion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:100,interface,interface,100,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['interface'],['interface']
Integrability,/// CmpProtocolNames - Comparison predicate for sorting protocols; /// alphabetically.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:56,protocol,protocols,56,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['protocol'],['protocols']
Integrability,"/// Code completion interfaces.; /// Start completion of code. Returns a handle to be passed to; /// cling_complete_next() to iterate over the completion options. Returns nulptr; /// if no completions are known.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/Jupyter/Kernel.cpp:20,interface,interfaces,20,interpreter/cling/tools/Jupyter/Kernel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/Jupyter/Kernel.cpp,1,['interface'],['interfaces']
Integrability,/// Code completion occurred where a protocol name is expected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:37,protocol,protocol,37,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['protocol'],['protocol']
Integrability,/// Code completion occurred where an Objective-C message receiver; /// is expected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:50,message,message,50,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['message'],['message']
Integrability,"/// Code completion occurred within an Objective-C interface,; /// protocol, or category interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:51,interface,interface,51,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,3,"['interface', 'protocol']","['interface', 'protocol']"
Integrability,"/// Code completion occurred within the instance variable list of; /// an Objective-C interface, implementation, or category implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:86,interface,interface,86,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['interface'],['interface']
Integrability,"/// Code completion occurs within an Objective-C interface, protocol,; /// or category.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:49,interface,interface,49,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['interface', 'protocol']","['interface', 'protocol']"
Integrability,"/// Code completion occurs within the list of instance variables; /// in an Objective-C interface, protocol, category, or implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:88,interface,interface,88,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['interface', 'protocol']","['interface', 'protocol']"
Integrability,/// Code completion where an Objective-C class message is expected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:47,message,message,47,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['message'],['message']
Integrability,/// Code completion where an Objective-C instance message is; /// expected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:50,message,message,50,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['message'],['message']
Integrability,"/// CodeInjector is an interface which is responsible for injecting AST; /// of function definitions that may not be available in the original source.; ///; /// The getBody function will be called each time the static analyzer examines a; /// function call that has no definition available in the current translation; /// unit. If the returned statement is not a null pointer, it is assumed to be; /// the body of a function which will be used for the analysis. The source of; /// the body can be arbitrary, but it is advised to use memoization to avoid; /// unnecessary reparsing of the external source that provides the body of the; /// functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CodeInjector.h:23,interface,interface,23,interpreter/llvm-project/clang/include/clang/Analysis/CodeInjector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CodeInjector.h,2,"['inject', 'interface']","['injecting', 'interface']"
Integrability,"/// Collect Uniform and Scalar values for the given \p VF.; /// The sets depend on CM decision for Load/Store instructions; /// that may be vectorized as interleave, gather-scatter or scalarized.; /// Also make a decision on what to do about call instructions in the loop; /// at that VF -- scalarize, call a known vector routine, or call a; /// vector intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:73,depend,depend,73,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,"['depend', 'rout']","['depend', 'routine']"
Integrability,"/// Collect all pairs of <virtual path, real path> entries from the; /// \p YAMLFilePath. This is used by the module dependency collector to forward; /// the entries into the reproducer output VFS YAML file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h:117,depend,dependency,117,interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,1,['depend'],['dependency']
Integrability,"/// Collect all potential values \p LI could read into \p PotentialValues. That; /// is, the only values read by \p LI are assumed to be known and all are in; /// \p PotentialValues. \p PotentialValueOrigins will contain all the; /// instructions that might have put a potential value into \p PotentialValues.; /// Dependences onto \p QueryingAA are properly tracked, \p; /// UsedAssumedInformation will inform the caller if assumed information was; /// used.; ///; /// \returns True if the assumed potential copies are all in \p PotentialValues,; /// false if something went wrong and the copies could not be; /// determined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:315,Depend,Dependences,315,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['Depend'],['Dependences']
Integrability,"/// Collect all potential values of the one stored by \p SI into; /// \p PotentialCopies. That is, the only copies that were made via the; /// store are assumed to be known and all are in \p PotentialCopies. Dependences; /// onto \p QueryingAA are properly tracked, \p UsedAssumedInformation will; /// inform the caller if assumed information was used.; ///; /// \returns True if the assumed potential copies are all in \p PotentialCopies,; /// false if something went wrong and the copies could not be; /// determined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:208,Depend,Dependences,208,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['Depend'],['Dependences']
Integrability,"/// Collect all the data dependency infos coming from any pair of memory; /// accesses from \p Src to \p Dst, and store them into \p Deps. Return true; /// if a dependence exists, and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:25,depend,dependency,25,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,2,['depend'],"['dependence', 'dependency']"
Integrability,/// Collect original debug information before a pass.; ///; /// \param M The module to collect debug information from.; /// \param Functions A range of functions to collect debug information from.; /// \param DebugInfoBeforePass DI metadata before a pass.; /// \param Banner A prefix string to add to debug/error messages.; /// \param NameOfWrappedPass A name of a pass to add to debug/error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:313,message,messages,313,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,2,['message'],['messages']
Integrability,/// Collect references to parseable Swift interfaces in imported; /// DW_TAG_module blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:42,interface,interfaces,42,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,3,['interface'],['interfaces']
Integrability,/// Collect the dependences from LoopAccessInfo.; ///; /// We process the dependences once during the interleaved access analysis to; /// enable constant-time dependence queries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:16,depend,dependences,16,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,3,['depend'],"['dependence', 'dependences']"
Integrability,"/// Collect the module dependency in P1689 format for C++20 named modules.; ///; /// \param MakeformatOutput The output parameter for dependency information; /// in make format if the command line requires to generate make-format; /// dependency information by `-MD -MF <dep_file>`.; ///; /// \param MakeformatOutputPath The output parameter for the path to; /// \param MakeformatOutput.; ///; /// \returns A \c StringError with the diagnostic output if clang errors; /// occurred, P1689 dependency format rules otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:23,depend,dependency,23,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,4,['depend'],['dependency']
Integrability,"/// Collect unswitch candidates by invariant conditions that are not immediately; /// present in the loop. However, they can be injected into the code if we; /// decide it's profitable.; /// An example of such conditions is following:; ///; /// for (...) {; /// x = load ...; /// if (! x <u C1) break;; /// if (! x <u C2) break;; /// <do something>; /// }; ///; /// We can unswitch by condition ""C1 <=u C2"". If that is true, then ""x <u C1 <=; /// C2"" automatically implies ""x <u C2"", so we can get rid of one of; /// loop-variant checks in unswitched loop version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:128,inject,injected,128,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['inject'],['injected']
Integrability,/// CollectImmediateProperties - This routine collects all properties in; /// the class and its conforming protocols; but not those in its super class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:38,rout,routine,38,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,2,"['protocol', 'rout']","['protocols', 'routine']"
Integrability,/// CollectInheritedProtocols - Collect all protocols in current class and; /// those inherited by it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:44,protocol,protocols,44,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['protocol'],['protocols']
Integrability,/// CollectSuperClassPropertyImplementations - This routine collects list of; /// properties to be implemented in super class(s) and also coming from their; /// conforming protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:52,rout,routine,52,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,2,"['protocol', 'rout']","['protocols', 'routine']"
Integrability,"/// CollectVRQualifiers - This routine returns Volatile/Restrict qualifiers,; /// if any, found in visible type conversion functions found in ArgExpr's type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:31,rout,routine,31,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['rout'],['routine']
Integrability,"/// Collects all enabled checkers in the field EnabledCheckers. It preserves; /// the order of insertion, as dependencies have to be enabled before the; /// checkers that depend on them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h:109,depend,dependencies,109,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h,2,['depend'],"['depend', 'dependencies']"
Integrability,"/// Collects all of the declaration contexts that are semantically; /// connected to this declaration context.; ///; /// For declaration contexts that have multiple semantically connected but; /// syntactically distinct contexts, such as C++ namespaces, this routine; /// retrieves the complete set of such declaration contexts in source order.; /// For example, given:; ///; /// \code; /// namespace N {; /// int x;; /// }; /// namespace N {; /// int y;; /// }; /// \endcode; ///; /// The \c Contexts parameter will contain both definitions of N.; ///; /// \param Contexts Will be cleared and set to the set of declaration; /// contexts that are semanticaly connected to this declaration context,; /// in source order, including this context (which may be the only result,; /// for non-namespace contexts).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:259,rout,routine,259,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['rout'],['routine']
Integrability,/// Collects modular and non-modular dependencies of the main file by attaching; /// \c ModuleDepCollectorPP to the preprocessor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:37,depend,dependencies,37,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,1,['depend'],['dependencies']
Integrability,/// Collects the dependencies for imported modules into a directory. Users; /// should attach to the AST reader whenever a module is loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h:17,depend,dependencies,17,interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,1,['depend'],['dependencies']
Integrability,/// Collects weak dependencies in \p enabledData.Checkers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:18,depend,dependencies,18,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,1,['depend'],['dependencies']
Integrability,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:415,rout,routine,415,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['rout'],['routine']
Integrability,"/// Combine stores to match the type of value being stored.; ///; /// The core idea here is that the memory does not have any intrinsic type and; /// where we can we should match the type of a store to the type of value being; /// stored.; ///; /// However, this routine must never change the width of a store or the number of; /// stores as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows stores to more closely model the types; /// of their incoming values.; ///; /// Currently, we also refuse to change the precise type used for an atomic or; /// volatile store. This is debatable, and might be reasonable to change later.; /// However, it is risky in case some backend or other part of LLVM is relying; /// on the exact type stored to select appropriate atomic operations.; ///; /// \returns true if the store was successfully combined away. This indicates; /// the caller must erase the store instruction. We have to let the caller erase; /// the store instruction as otherwise there is no way to signal whether it was; /// combined or not: IC.EraseInstFromFunction returns a null pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:263,rout,routine,263,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['rout'],['routine']
Integrability,/// CommaSeparateAndAddOccurrence - A wrapper around Handler->addOccurrence(); /// that does special handling of cl::CommaSeparated options.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp:38,wrap,wrapper,38,interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,1,['wrap'],['wrapper']
Integrability,"/// Common Interface to generate OMP inlined regions; ///; /// \param OMPD Directive to generate inlined region for; /// \param EntryCall Call to the entry OMP Runtime Function; /// \param ExitCall Call to the ending OMP Runtime Function; /// \param BodyGenCB Body code generation callback.; /// \param FiniCB Finalization Callback. Will be called when finalizing region; /// \param Conditional indicate if the entry call result will be used; /// to evaluate a conditional of whether a thread will execute; /// body code or not.; /// \param HasFinalize indicate if the directive will require finalization; /// and has a finalization callback in the stack that; /// should be called.; /// \param IsCancellable if HasFinalize is set to true, indicate if the; /// the directive should be cancellable.; /// \return The insertion point after the region",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:11,Interface,Interface,11,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['Interface'],['Interface']
Integrability,"/// Common base class for placeholders for types that get replaced by; /// placeholder type deduction: C++11 auto, C++14 decltype(auto), C++17 deduced; /// class template types, and constrained type names.; ///; /// These types are usually a placeholder for a deduced type. However, before; /// the initializer is attached, or (usually) if the initializer is; /// type-dependent, there is no deduced type and the type is canonical. In; /// the latter case, it is also a dependent type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:369,depend,dependent,369,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,2,['depend'],['dependent']
Integrability,"/// Common interface for generating entry calls for OMP Directives.; /// if the directive has a region/body, It will set the insertion; /// point to the body; ///; /// \param OMPD Directive to generate entry blocks for; /// \param EntryCall Call to the entry OMP Runtime Function; /// \param ExitBB block where the region ends.; /// \param Conditional indicate if the entry call result will be used; /// to evaluate a conditional of whether a thread will execute; /// body code or not.; ///; /// \return The insertion position in exit block",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:11,interface,interface,11,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['interface'],['interface']
Integrability,/// Common interface to finalize the region; ///; /// \param OMPD Directive to generate exiting code for; /// \param FinIP Insertion point for emitting Finalization code and exit call; /// \param ExitCall Call to the ending OMP Runtime Function; /// \param HasFinalize indicate if the directive will require finalization; /// and has a finalization callback in the stack that; /// should be called.; ///; /// \return The insertion position in exit block,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:11,interface,interface,11,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['interface'],['interface']
Integrability,"/// Common utility function tightly tied to the options listed here. Initializes; /// a TargetOptions object with CodeGen flags and returns it.; /// \p TheTriple is used to determine the default value for options if; /// options are not explicitly specified. If those triple dependant options; /// value do not have effect for your component, a default Triple() could be; /// passed in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h:275,depend,dependant,275,interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h,1,['depend'],['dependant']
Integrability,"/// Compare given type to the type of the wrapped result and throw if the types don't match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx:42,wrap,wrapped,42,tree/dataframe/inc/ROOT/RResultHandle.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx,1,['wrap'],['wrapped']
Integrability,/// Compare routine for std::is_sorted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h:12,rout,routine,12,interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,2,['rout'],['routine']
Integrability,/// Compare routine for std::lower_bound,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h:12,rout,routine,12,interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,1,['rout'],['routine']
Integrability,"/// CompareDerivedToBaseConversions - Compares two standard conversion; /// sequences to determine whether they can be ranked based on their; /// various kinds of derived-to-base conversions (C++; /// [over.ics.rank]p4b3). As part of these checks, we also look at; /// conversions between Objective-C interface types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:301,interface,interface,301,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['interface'],['interface']
Integrability,/// Comparison operators for Remark objects and dependent objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/Remark.h:48,depend,dependent,48,interpreter/llvm-project/llvm/include/llvm/Remarks/Remark.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/Remark.h,1,['depend'],['dependent']
Integrability,/// Comparison routine for Objective-C protocols to be used with; /// llvm::array_pod_sort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:15,rout,routine,15,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,"['protocol', 'rout']","['protocols', 'routine']"
Integrability,"/// Compatibility method with multi-dimensional interface for Gradient and function evaluation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h:48,interface,interface,48,math/mathcore/inc/Math/IFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h,1,['interface'],['interface']
Integrability,"/// Compatibility method with multi-dimensional interface for Gradient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h:48,interface,interface,48,math/mathcore/inc/Math/IFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h,1,['interface'],['interface']
Integrability,"/// Compatibility method with multi-dimensional interface for partial derivative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h:48,interface,interface,48,math/mathcore/inc/Math/IFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h,1,['interface'],['interface']
Integrability,"/// CompilerInstance - Helper class for managing a single instance of the Clang; /// compiler.; ///; /// The CompilerInstance serves two purposes:; /// (1) It manages the various objects which are necessary to run the compiler,; /// for example the preprocessor, the target information, and the AST; /// context.; /// (2) It provides utility routines for constructing and manipulating the; /// common Clang objects.; ///; /// The compiler instance generally owns the instance of all the objects that it; /// manages. However, clients can still share objects by manually setting the; /// object and retaking ownership prior to destroying the CompilerInstance.; ///; /// The compiler instance is intended to simplify clients, but not to lock them; /// in to the compiler instance for everything. When possible, utility functions; /// come in two forms; a short form that reuses the CompilerInstance objects,; /// and a long form that takes explicit instances of any required objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h:342,rout,routines,342,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,1,['rout'],['routines']
Integrability,/// Compiling a C++ modules interface unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h:28,interface,interface,28,interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,1,['interface'],['interface']
Integrability,/// Completely target-dependent object reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:22,depend,dependent,22,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['depend'],['dependent']
Integrability,"/// Completes the merge of two function declarations that are; /// known to be compatible.; ///; /// This routine handles the merging of attributes and other; /// properties of function declarations from the old declaration to; /// the new declaration, once we know that New is in fact a; /// redeclaration of Old.; ///; /// \returns false",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,rout,routine,106,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['rout'],['routine']
Integrability,"/// Compute This := This - B; /// TODO: We should be able to use set_subtract from SetOperations.h, but; /// SetVector interface is inconsistent with DenseSet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:119,interface,interface,119,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,1,['interface'],['interface']
Integrability,"/// Compute This := This u S, return whether 'This' changed.; /// TODO: We should be able to use set_union from SetOperations.h, but; /// SetVector interface is inconsistent with DenseSet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:148,interface,interface,148,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,1,['interface'],['interface']
Integrability,"/// Compute an integer value from splatting an i8 across the given; /// number of bytes.; ///; /// Note that this routine assumes an i8 is a byte. If that isn't true, don't; /// call this routine.; /// FIXME: Heed the advice above.; ///; /// \param V The i8 value to splat.; /// \param Size The number of bytes in the output (assuming i8 is one byte)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:114,rout,routine,114,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,2,['rout'],['routine']
Integrability,"/// Compute an ordered list of the dependence graph nodes, which; /// indicates the order that the nodes will be scheduled. This is a; /// two-level algorithm. First, a partial order is created, which; /// consists of a list of sets ordered from highest to lowest priority.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:35,depend,dependence,35,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependence']
Integrability,"/// Compute and return the use operand latency of a given pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overridden; /// by a target. Use computeOperandLatency to get the best estimate of; /// latency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:291,interface,interface,291,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['interface'],['interface']
Integrability,/// Compute and set dependence bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:20,depend,dependence,20,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['depend'],['dependence']
Integrability,"/// Compute bin index for all values of the observable(s) in `evalData`, and return their volumes or inverse volumes, depending; /// on the configuration chosen in the constructor.; /// If a bin is not valid, return a volume of 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinWidthFunction.cxx:118,depend,depending,118,roofit/roofitcore/src/RooBinWidthFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinWidthFunction.cxx,1,['depend'],['depending']
Integrability,"/// Compute current bin of observable, and return its volume or inverse volume, depending; /// on configuration chosen in the constructor.; /// If the bin is not valid, return a volume of 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinWidthFunction.cxx:80,depend,depending,80,roofit/roofitcore/src/RooBinWidthFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinWidthFunction.cxx,1,['depend'],['depending']
Integrability,/// Compute operand latency based on the available machine model.; ///; /// Compute and return the latency of the given data dependent def and use; /// when the operand indices are already known. UseMI may be NULL for an; /// unknown user.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:125,depend,dependent,125,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,1,['depend'],['dependent']
Integrability,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:223,depend,dependent,223,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['depend'],['dependent']
Integrability,"/// Compute suitable alignment to access this slice of the *new*; /// alloca.; ///; /// You can optionally pass a type to this routine and if that type's ABI; /// alignment is itself suitable, this will return zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:127,rout,routine,127,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['rout'],['routine']
Integrability,/// Compute target triple from args.; ///; /// This routine provides the logic to compute a target triple from various; /// args passed to the driver and the default triple string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:52,rout,routine,52,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['rout'],['routine']
Integrability,/// Compute the ABI information of a swiftcall function. This is a; /// private interface for Clang.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/SwiftCallingConv.h:80,interface,interface,80,interpreter/llvm-project/clang/include/clang/CodeGen/SwiftCallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/SwiftCallingConv.h,1,['interface'],['interface']
Integrability,"/// Compute the DeclContext that is associated with the given type.; ///; /// \param T the type for which we are attempting to find a DeclContext.; ///; /// \returns the declaration context represented by the type T,; /// or NULL if the declaration context cannot be computed (e.g., because it is; /// dependent and not the current instantiation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:302,depend,dependent,302,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['depend'],['dependent']
Integrability,"/// Compute the DeclContext that is associated with the given; /// scope specifier.; ///; /// \param SS the C++ scope specifier as it appears in the source; ///; /// \param EnteringContext when true, we will be entering the context of; /// this scope specifier, so we can retrieve the declaration context of a; /// class template or class template partial specialization even if it is; /// not the current instantiation.; ///; /// \returns the declaration context represented by the scope specifier @p SS,; /// or NULL if the declaration context cannot be computed (e.g., because it is; /// dependent and not the current instantiation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:591,depend,dependent,591,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['depend'],['dependent']
Integrability,"/// Compute the VTs needed for the low/hi parts of a type, dependent on an; /// enveloping VT that has been split into two identical pieces. Sets the; /// HisIsEmpty flag when hi type has zero storage size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:59,depend,dependent,59,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['depend'],['dependent']
Integrability,/// Compute the bitmask of lanes actually written by DefMI.; /// Set Redef if there are any partial register definitions that depend on the; /// previous value of the register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:126,depend,depend,126,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['depend'],['depend']
Integrability,"/// Compute the list of required libraries for a given list of; /// components, in an order suitable for passing to a linker (that is, libraries; /// appear prior to their dependencies).; ///; /// \param Components - The names of the components to find libraries for.; /// \param IncludeNonInstalled - Whether non-installed components should be; /// reported.; /// \param GetComponentNames - True if one would prefer the component names.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:172,depend,dependencies,172,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,1,['depend'],['dependencies']
Integrability,"/// Compute the number of times the backedge of the specified loop will; /// execute if its exit condition were a conditional branch of ExitCond.; ///; /// \p ControlsOnlyExit is true if ExitCond directly controls the only exit; /// branch. In this case, we can assume that the loop exits only if the; /// condition is true and can infer that failing to meet the condition prior; /// to integer wraparound results in undefined behavior.; ///; /// If \p AllowPredicates is set, this call will try to use a minimal set of; /// SCEV predicates in order to return an exact answer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:395,wrap,wraparound,395,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['wrap'],['wraparound']
Integrability,"/// Compute the pointer-to-function type to which a message send; /// should be casted in order to correctly call the given method; /// with the given arguments.; ///; /// \param method - may be null; /// \param resultType - the result type to use if there's no method; /// \param callArgs - the actual arguments, including implicit ones",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp:52,message,message,52,interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp,1,['message'],['message']
Integrability,/// Compute the scheduling start slot for the instruction. The start slot; /// depends on any predecessor or successor nodes scheduled already.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:79,depend,depends,79,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['depends']
Integrability,/// Compute the set of GlobalValue that depends from V.; /// The recursion stops as soon as a GlobalValue is met.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:40,depend,depends,40,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,1,['depend'],['depends']
Integrability,"/// Compute the type-, value-, and instantiation-dependence of a; /// declaration reference; /// based on the declaration being referenced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:49,depend,dependence,49,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,1,['depend'],['dependence']
Integrability,/// Computes A * B. When computation wraps around sets the error and returns; /// false. Otherwise assigns the result to A and returns true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp:37,wrap,wraps,37,interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp,1,['wrap'],['wraps']
Integrability,/// Computes A + B. When computation wraps around sets the error and returns; /// false. Otherwise assigns the result to A and returns true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp:37,wrap,wraps,37,interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp,1,['wrap'],['wraps']
Integrability,"/// Computes a zero-based global bin index, given...; ///; /// - A set of zero-based per-axis bin indices; /// - The number of considered bins on each axis (can be either `GetNBinsNoOver`; /// or `GetNBins` depending on what you are trying to do); /// - A policy of treating all bins qs regular (i.e. no negative indices)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:207,depend,depending,207,hist/histv7/inc/ROOT/RHistImpl.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx,1,['depend'],['depending']
Integrability,/// Computes dependencies of a reference with the name having template arguments; /// with \p TA dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:13,depend,dependencies,13,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,2,['depend'],['dependencies']
Integrability,/// Computes instruction latency as max of latency of defined operands.; ///; /// \param Root is a machine instruction that could be replaced by NewRoot.; /// It is used to compute a more accurate latency information for NewRoot in; /// case there is a dependent instruction in the same trace (\p BlockTrace); /// \param NewRoot is the instruction for which the latency is computed; /// \param BlockTrace is a trace of machine instructions; ///; /// \returns Latency of \p NewRoot,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:253,depend,dependent,253,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,1,['depend'],['dependent']
Integrability,"/// Computes the source location just past the end of the; /// token at this source location.; ///; /// This routine can be used to produce a source location that; /// points just past the end of the token referenced by \p Loc, and; /// is generally used when a diagnostic needs to point just after a; /// token where it expected something different that it received. If; /// the returned source location would not be meaningful (e.g., if; /// it points into a macro), this routine returns an invalid; /// source location.; ///; /// \param Offset an offset from the end of the token, where the source; /// location should refer to. The default offset (0) produces a source; /// location pointing just past the end of the token; an offset of 1 produces; /// a source location pointing to the last character in the token, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Lexer.h:109,rout,routine,109,interpreter/llvm-project/clang/include/clang/Lex/Lexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Lexer.h,6,['rout'],['routine']
Integrability,"/// Computes zero-based local bin indices, given...; ///; /// - A zero-based global bin index; /// - The number of considered bins on each axis (can be either `GetNBinsNoOver`; /// or `GetNBins` depending on what you are trying to do); /// - A policy of treating all bins as regular (i.e. no negative indices)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:195,depend,depending,195,hist/histv7/inc/ROOT/RHistImpl.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx,1,['depend'],['depending']
Integrability,/// Concrete implementation of a pure data dependence graph builder. This class; /// provides custom implementation for the pure-virtual functions used in the; /// generic dependence graph build algorithm.; ///; /// For information about time complexity of the build algorithm see the; /// comments near the declaration of AbstractDependenceGraphBuilder.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:43,depend,dependence,43,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,2,['depend'],['dependence']
Integrability,"/// Conditionally limit the maximum size of the scalar.; /// For example, when the maximum size of one type depends on the size of; /// another such as extracting N bits from an M bit container.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:108,depend,depends,108,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,1,['depend'],['depends']
Integrability,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:158,depend,depending,158,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['depend'],['depending']
Integrability,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:157,depend,depending,157,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['depend'],['depending']
Integrability,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:157,depend,depending,157,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['depend'],['depending']
Integrability,/// Const iterator that walks over the capture initialization; /// arguments.; /// FIXME: This interface is prone to being used incorrectly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:95,interface,interface,95,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['interface'],['interface']
Integrability,"/// Constant fold a zext, sext or trunc, depending on IsSigned and whether the; /// DestTy is wider or narrower than C. Returns nullptr on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:41,depend,depending,41,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,1,['depend'],['depending']
Integrability,/// Constant iteration adapter for range-for loops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:23,adapter,adapter,23,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['adapter'],['adapter']
Integrability,"/// ConstantDataArray pointer. nullptr indicates a zeroinitializer (a valid; /// initializer, it just doesn't fit the ConstantDataArray interface).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:136,interface,interface,136,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['interface'],['interface']
Integrability,/// ConstantFoldAttrArgs - Folds attribute arguments into ConstantExprs; /// (unless they are value dependent or type dependent). Returns false; /// and emits a diagnostic if one or more of the arguments could not be; /// folded into a constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:100,depend,dependent,100,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['depend'],['dependent']
Integrability,/// Constrains the given list of clone groups with the given constraint.; ///; /// The constraint is expected to have a method with the signature; /// `void constrain(std::vector<CloneDetector::CloneGroup> &Sequences)`; /// as this is the interface that the CloneDetector uses for applying the; /// constraint. The constraint is supposed to directly modify the passed list; /// so that all clones in the list fulfill the specific property this; /// constraint ensures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CloneDetection.h:239,interface,interface,239,interpreter/llvm-project/clang/include/clang/Analysis/CloneDetection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CloneDetection.h,1,['interface'],['interface']
Integrability,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:110,Depend,Dependence,110,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,6,"['Depend', 'depend']","['Dependence', 'dependence']"
Integrability,"/// Construct a ConditionTruthVal indicating the constraint is constrained; /// to either true or false, depending on the boolean value provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h:105,depend,depending,105,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h,1,['depend'],['depending']
Integrability,"/// Construct a MachineMemOperand object with the specified PtrInfo, flags,; /// size, and base alignment. For atomic operations the synchronization scope; /// and atomic ordering requirements must also be specified. For cmpxchg; /// atomic operations the atomic ordering requirements when store does not; /// occur must also be specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:133,synchroniz,synchronization,133,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,1,['synchroniz'],['synchronization']
Integrability,/// Construct a TTI object using a type implementing the \c Concept; /// API below.; ///; /// This is used by targets to construct a TTI wrapping their target-specific; /// implementation that encodes appropriate costs for their target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:137,wrap,wrapping,137,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['wrap'],['wrapping']
Integrability,"/// Construct a WrapperFrontendAction from an existing action, taking; /// ownership of it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h:16,Wrap,WrapperFrontendAction,16,interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,1,['Wrap'],['WrapperFrontendAction']
Integrability,/// Construct a \c Matcher<T> interface around the dynamic matcher.; ///; /// This method asserts that \c canConvertTo() is \c true. Callers; /// should call \c canConvertTo() first to make sure that \c this is; /// compatible with T.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h:30,interface,interface,30,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,1,['interface'],['interface']
Integrability,/// Construct a dependency scanning tool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:16,depend,dependency,16,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,1,['depend'],['dependency']
Integrability,/// Construct a new Mach-O writer instance.; ///; /// This routine takes ownership of the target writer subclass.; ///; /// \param MOTW - The target specific Mach-O writer subclass.; /// \param OS - The stream to write to.; /// \returns The constructed object writer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCMachObjectWriter.h:59,rout,routine,59,interpreter/llvm-project/llvm/include/llvm/MC/MCMachObjectWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCMachObjectWriter.h,1,['rout'],['routine']
Integrability,"/// Construct a new RooWrapperPdf.; /// \param[in] name A name to identify this object.; /// \param[in] title Title (for e.g. plotting); /// \param[in] inputFunction Any RooAbsReal that should be converted into a PDF. Although it's possible; /// \param[in] selfNormalized The return value the RooAbsPdf::selfNormalized() function for the wrapped PDF object.; /// If it is `true`, then no automatic normalization will be; /// performed when evaluating the function. In this case, the; /// effect RooWrapperPdf is not to change the evaluated values,; /// but only to wrap the function in something that is of type; /// RooAbsPdf, which can be useful if some interface reqiures it.; /// to pass a PDF, it only makes sense for non-PDF functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooWrapperPdf.h:338,wrap,wrapped,338,roofit/roofitcore/inc/RooWrapperPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooWrapperPdf.h,3,"['interface', 'wrap']","['interface', 'wrap', 'wrapped']"
Integrability,/// Construct a new expression that refers to the given; /// integral template argument with the given source-location; /// information.; ///; /// This routine takes care of the mapping from an integral template; /// argument (which may have any integral type) to the appropriate; /// literal value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:152,rout,routine,152,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['rout'],['routine']
Integrability,"/// Construct a template argument that is a template pack expansion.; ///; /// This form of template argument is generally used for template template; /// parameters. However, the template name could be a dependent template; /// name that ends up being instantiated to a function template whose address; /// is taken.; ///; /// \param Name The template name.; ///; /// \param NumExpansions The number of expansions that will be generated by; /// instantiating; ///; /// \param IsDefaulted If 'true', implies that this TemplateArgument; /// corresponds to a default template parameter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h:205,depend,dependent,205,interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,1,['depend'],['dependent']
Integrability,"/// Construct a template argument that is a template.; ///; /// This form of template argument is generally used for template template; /// parameters. However, the template name could be a dependent template; /// name that ends up being instantiated to a function template whose address; /// is taken.; ///; /// \param Name The template name.; ///; /// \param IsDefaulted If 'true', implies that this TemplateArgument; /// corresponds to a default template parameter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h:190,depend,dependent,190,interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,1,['depend'],['dependent']
Integrability,"/// Construct a template argument that is an expression.; ///; /// This form of template argument only occurs in template argument; /// lists used for dependent types and for expression; it will not; /// occur in a non-dependent, canonical template argument list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h:151,depend,dependent,151,interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,2,['depend'],['dependent']
Integrability,/// Construct a template argument that refers to a (non-dependent); /// declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h:56,depend,dependent,56,interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,1,['depend'],['dependent']
Integrability,"/// Construct a writer, optionally enabling ""Compatibility Mode"" as defined; /// in the MessagePack specification.; ///; /// When in \p Compatible mode, the writer will write \c Str16 formats; /// instead of \c Str8 formats, and will refuse to write any \c Bin formats.; ///; /// \param OS stream to output MessagePack objects to.; /// \param Compatible when set, write in ""Compatibility Mode"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h:88,Message,MessagePack,88,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h,2,['Message'],['MessagePack']
Integrability,"/// Construct adapter from a batch of values.; /// - If `batch.size() == 1`, always return the value at `batch[0]`.; /// - Else, return `batch[i]`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/BracketAdapters.h:14,adapter,adapter,14,roofit/roofitmore/src/BracketAdapters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/BracketAdapters.h,1,['adapter'],['adapter']
Integrability,"/// Construct adapter from a fallback value and a batch of values.; /// - If `batch.empty()`, always return `payload`.; /// - Else, return `batch[i]`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/BracketAdapters.h:14,adapter,adapter,14,roofit/roofitmore/src/BracketAdapters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/BracketAdapters.h,1,['adapter'],['adapter']
Integrability,/// Construct an empty Objective-C bridged cast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:35,bridg,bridged,35,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,1,['bridg'],['bridged']
Integrability,"/// Construct from ROOT's `kWarning, kError, ...` and strings specifying location and message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/inc/ROOT/TestSupport.hxx:86,message,message,86,core/testsupport/inc/ROOT/TestSupport.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/inc/ROOT/TestSupport.hxx,1,['message'],['message']
Integrability,/// Construct the Diagnostic message for the given ExplodedNode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h:29,message,message,29,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,1,['message'],['message']
Integrability,"/// Constructor for 1-sample tests with a user specified distribution implementing the ROOT::Math::IGenFunction interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GoFTest.h:112,interface,interface,112,math/mathcore/inc/Math/GoFTest.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GoFTest.h,1,['interface'],['interface']
Integrability,/// Constructor version that obtains the offload kinds from the device; /// dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h:76,depend,dependencies,76,interpreter/llvm-project/clang/include/clang/Driver/Action.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h,1,['depend'],['dependencies']
Integrability,/// Constructs a Stack hint for the given symbol.; ///; /// The class knows how to construct the stack hint message based on; /// traversing the CallExpr associated with the call and checking if the given; /// symbol is returned or is one of the arguments.; /// The hint can be customized by redefining 'getMessageForX()' methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h:108,message,message,108,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,1,['message'],['message']
Integrability,"/// Constructs a `MemberExpr` that accesses the named member (\p Member) of the; /// object bound to \p BaseId. The access is constructed idiomatically: if \p; /// BaseId is bound to `e` and \p Member identifies member `m`, then returns; /// `e->m`, when e is a pointer, `e2->m` when e = `*e2` and `e.m` otherwise.; /// Additionally, `e` is wrapped in parentheses, if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:341,wrap,wrapped,341,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,1,['wrap'],['wrapped']
Integrability,"/// Constructs a diagnostic message with anoffset to the diagnostic; /// within the file where the problem occurred.; ///; /// \param Loc Should be a file location, it is not meaningful for a macro; /// location.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h:28,message,message,28,interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h,1,['message'],['message']
Integrability,"/// Constructs a new 256-bit integer vector by first duplicating a; /// 256-bit integer vector given in the first parameter, and then replacing; /// either the upper or the lower 128 bits with the contents of a 128-bit; /// integer vector in the second parameter.; ///; /// The immediate integer parameter determines between the upper or the lower; /// 128 bits.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256i _mm256_insertf128_si256(__m256i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VINSERTF128 </c> instruction.; ///; /// \param V1; /// A 256-bit integer vector. This vector is copied to the result first, and; /// then either the upper or the lower 128 bits of the result will be; /// replaced by the contents of \a V2.; /// \param V2; /// A 128-bit integer vector. The contents of this parameter are written to; /// either the upper or the lower 128 bits of the result depending on the; /// value of parameter \a M.; /// \param M; /// An immediate integer. The least significant bit determines how the values; /// from the two parameters are interleaved: \n; /// If bit [0] of \a M is 0, \a V2 are copied to bits [127:0] of the result,; /// and bits [255:128] of \a V1 are copied to bits [255:128] of the; /// result. \n; /// If bit [0] of \a M is 1, \a V2 are copied to bits [255:128] of the; /// result, and bits [127:0] of \a V1 are copied to bits [127:0] of the; /// result.; /// \returns A 256-bit integer vector containing the interleaved values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:941,depend,depending,941,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['depend'],['depending']
Integrability,"/// Constructs a new 256-bit vector of [4 x double] by first duplicating; /// a 256-bit vector of [4 x double] given in the first parameter, and then; /// replacing either the upper or the lower 128 bits with the contents of a; /// 128-bit vector of [2 x double] in the second parameter.; ///; /// The immediate integer parameter determines between the upper or the lower; /// 128 bits.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_insertf128_pd(__m256d V1, __m128d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VINSERTF128 </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [4 x double]. This vector is copied to the result; /// first, and then either the upper or the lower 128 bits of the result will; /// be replaced by the contents of \a V2.; /// \param V2; /// A 128-bit vector of [2 x double]. The contents of this parameter are; /// written to either the upper or the lower 128 bits of the result depending; /// on the value of parameter \a M.; /// \param M; /// An immediate integer. The least significant bit determines how the values; /// from the two parameters are interleaved: \n; /// If bit [0] of \a M is 0, \a V2 are copied to bits [127:0] of the result,; /// and bits [255:128] of \a V1 are copied to bits [255:128] of the; /// result. \n; /// If bit [0] of \a M is 1, \a V2 are copied to bits [255:128] of the; /// result, and bits [127:0] of \a V1 are copied to bits [127:0] of the; /// result.; /// \returns A 256-bit vector of [4 x double] containing the interleaved values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:978,depend,depending,978,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['depend'],['depending']
Integrability,"/// Constructs an IncomingWFRHandler from a function object by creating a new; /// function object that dispatches the original using a TaskDispatcher,; /// wrapping the original as a GenericNamedTask.; ///; /// This is the default approach for running WFR handlers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h:157,wrap,wrapping,157,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,1,['wrap'],['wrapping']
Integrability,"/// Constructs an IncomingWFRHandler from a function object that is callable; /// as void(shared::WrapperFunctionResult). The function object will be called; /// directly. This should be used with care as it may block listener threads; /// in remote EPCs. It is only suitable for simple tasks (e.g. setting a; /// future), or for performing some quick analysis before dispatching ""real""; /// work as a Task.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h:98,Wrap,WrapperFunctionResult,98,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,1,['Wrap'],['WrapperFunctionResult']
Integrability,"/// Constructs an expression that idiomatically takes the address of the; /// expression bound to \p ExprId. \p ExprId is wrapped in parentheses, if; /// needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:122,wrap,wrapped,122,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,1,['wrap'],['wrapped']
Integrability,"/// Constructs an idiomatic dereferencing of the expression bound to \p ExprId.; /// \p ExprId is wrapped in parentheses, if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:98,wrap,wrapped,98,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,1,['wrap'],['wrapped']
Integrability,"/// Constructs and returns the recurrence indicating how much this; /// expression steps by. If this is a polynomial of degree N, it; /// returns a chrec of degree N-1. We cannot determine whether; /// the step recurrence has self-wraparound.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:231,wrap,wraparound,231,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,1,['wrap'],['wraparound']
Integrability,"/// Consume an Error and return the raw enum value contained within it, and; /// the optional error message. The Error must either be a success value, or; /// contain a single InstrProfError.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:100,message,message,100,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,1,['message'],['message']
Integrability,"/// Consume the construction context layer, together with its parent layers,; /// and wrap it up into a complete construction context. May return null; /// if layers do not form any supported construction context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/ConstructionContext.h:86,wrap,wrap,86,interpreter/llvm-project/clang/include/clang/Analysis/ConstructionContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/ConstructionContext.h,1,['wrap'],['wrap']
Integrability,"/// Consume the current code-completion token.; ///; /// This routine can be called to consume the code-completion token and; /// continue processing in special cases where \c cutOffParsing() isn't; /// desired, such as token caching or completion with lookahead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:62,rout,routine,62,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['rout'],['routine']
Integrability,/// Container that keeps information about each dependence of this unbundling; /// action.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h:48,depend,dependence,48,interpreter/llvm-project/clang/include/clang/Driver/Action.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h,1,['depend'],['dependence']
Integrability,"/// Contains all (FullName, CmdLineOption) pairs. Similarly to dependencies,; /// we only modify the actual CheckerInfo and PackageInfo objects once all; /// of them have been added.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerRegistryData.h:63,depend,dependencies,63,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerRegistryData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerRegistryData.h,1,['depend'],['dependencies']
Integrability,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:797,depend,dependencies,797,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependencies']
Integrability,/// Contains all variable-referring-expressions that refer; /// to local variables that are usable as constant expressions and; /// do not involve an odr-use (they may still need to be captured; /// if the enclosing full-expression is instantiation dependent).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h:249,depend,dependent,249,interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,1,['depend'],['dependent']
Integrability,"/// Contains declarations and definitions that could be; /// ""interesting"" to the ASTConsumer, when we get that AST consumer.; ///; /// ""Interesting"" declarations are those that have data that may; /// need to be emitted, such as inline function definitions or; /// Objective-C protocols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:278,protocol,protocols,278,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['protocol'],['protocols']
Integrability,/// Contains number of loop (starts from 1) on which loop counter condition; /// expression of this loop depends on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:105,depend,depends,105,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['depend'],['depends']
Integrability,/// Contains number of loop (starts from 1) on which loop counter init; /// expression of this loop depends on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:100,depend,depends,100,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['depend'],['depends']
Integrability,/// ContractNodes - Turn multiple matcher node patterns like 'MoveChild+Record'; /// into single compound nodes like RecordChild.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp:4,Contract,ContractNodes,4,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,1,['Contract'],['ContractNodes']
Integrability,/// Control dependence sources need to be live for this block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:12,depend,dependence,12,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,1,['depend'],['dependence']
Integrability,"/// Control of individual brace wrapping cases.; ///; /// If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; /// each individual brace case should be handled. Otherwise, this is ignored.; /// \code{.yaml}; /// # Example of usage:; /// BreakBeforeBraces: Custom; /// BraceWrapping:; /// AfterEnum: true; /// AfterStruct: false; /// SplitEmptyFunction: false; /// \endcode; /// \version 3.8",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:32,wrap,wrapping,32,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['wrap'],['wrapping']
Integrability,"/// ControllingExprOrType is either a TypeSourceInfo * or an Expr *. FIXME:; /// it'd be better to split this interface into two so we don't take a; /// void *, but see the FIXME on ActOnGenericSelectionExpr as to why that; /// isn't a trivial change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:110,interface,interface,110,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['interface'],['interface']
Integrability,"/// ControllingExprOrType is either an opaque pointer coming out of a; /// ParsedType or an Expr *. FIXME: it'd be better to split this interface; /// into two so we don't take a void *, but that's awkward because one of; /// the operands is either a ParsedType or an Expr *, which doesn't lend; /// itself to generic code very well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:136,interface,interface,136,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['interface'],['interface']
Integrability,"/// Controls bin-packing Objective-C protocol conformance list; /// items into as few lines as possible when they go over ``ColumnLimit``.; ///; /// If ``Auto`` (the default), delegates to the value in; /// ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; /// protocol conformance list items into as few lines as possible; /// whenever they go over ``ColumnLimit``.; ///; /// If ``Always``, always bin-packs Objective-C protocol conformance; /// list items into as few lines as possible whenever they go over; /// ``ColumnLimit``.; ///; /// If ``Never``, lays out Objective-C protocol conformance list items; /// onto individual lines whenever they go over ``ColumnLimit``.; ///; /// \code{.objc}; /// Always (or Auto, if BinPackParameters=true):; /// @interface ccccccccccccc () <; /// ccccccccccccc, ccccccccccccc,; /// ccccccccccccc, ccccccccccccc> {; /// }; ///; /// Never (or Auto, if BinPackParameters=false):; /// @interface ddddddddddddd () <; /// ddddddddddddd,; /// ddddddddddddd,; /// ddddddddddddd,; /// ddddddddddddd> {; /// }; /// \endcode; /// \version 7",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:37,protocol,protocol,37,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,6,"['interface', 'protocol']","['interface', 'protocol']"
Integrability,"/// Convenience function for printing options or checkers and their; /// description in a formatted manner. If \p MinLineWidth is set to 0, no line; /// breaks are introduced for the description.; ///; /// Format, depending whether the option name's length is less than; /// \p EntryWidth:; ///; /// <padding>EntryName<padding>Description; /// <---------padding--------->Description; /// <---------padding--------->Description; ///; /// <padding>VeryVeryLongEntryName; /// <---------padding--------->Description; /// <---------padding--------->Description; /// ^~~~~~~~~InitialPad; /// ^~~~~~~~~~~~~~~~~~EntryWidth; /// ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~MinLineWidth",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h:214,depend,depending,214,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h,1,['depend'],['depending']
Integrability,"/// Convenience method to copy supported exact, fast-math, and (optionally); /// wrapping flags from V to this instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:81,wrap,wrapping,81,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['wrap'],['wrapping']
Integrability,/// Convenience routine for collecting lexical block information for a list; /// of lexical scopes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:16,rout,routine,16,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['rout'],['routine']
Integrability,/// Convenience wrapper,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/DeadArgumentElimination.h:16,wrap,wrapper,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/DeadArgumentElimination.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/DeadArgumentElimination.h,2,['wrap'],['wrapper']
Integrability,/// Convenience wrapper around TargetLowering::getSetCCResultType,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,wrap,wrapper,16,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['wrap'],['wrapper']
Integrability,"/// Convenience wrapper class used to distinguish between pdf/data owning and non-owning constructors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/TestStatistics/RooAbsL.h:16,wrap,wrapper,16,roofit/roofitcore/inc/RooFit/TestStatistics/RooAbsL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/TestStatistics/RooAbsL.h,1,['wrap'],['wrapper']
Integrability,/// Convenience wrapper to make a fallible_iterator end value from an instance; /// of an underlying iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:16,wrap,wrapper,16,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,1,['wrap'],['wrapper']
Integrability,/// Convenience wrapper to make a fallible_iterator value from an instance; /// of an underlying iterator and an Error reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:16,wrap,wrapper,16,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,1,['wrap'],['wrapper']
Integrability,"/// Conversion operators. These are all single input single output; /// operations. For all of these, the result type must be strictly; /// wider or narrower (depending on the operation) than the source; /// type.; /// SIGN_EXTEND - Used for integer types, replicating the sign bit; /// into new bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:159,depend,depending,159,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['depend'],['depending']
Integrability,"/// Convert Op, which must be of integer type, to the; /// integer type VT, by either any/sign/zero-extending (depending on IsAny /; /// IsSigned) or truncating it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:111,depend,depending,111,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['depend'],['depending']
Integrability,"/// Convert Op, which must be of integer type, to the; /// integer type VT, by either sign/zero-extending (depending on IsSigned) or; /// truncating it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:107,depend,depending,107,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['depend'],['depending']
Integrability,"/// Convert a template-argument that we parsed as a type into a template, if; /// possible. C++ permits injected-class-names to perform dual service as; /// template template arguments and as template type arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:104,inject,injected-class-names,104,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['inject'],['injected-class-names']
Integrability,/// Convert a thread-local variable reference into a sequence of instructions to; /// compute the variable's address for the local exec TLS model of ELF targets.; /// The sequence depends on the maximum TLS area size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:180,depend,depends,180,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['depend'],['depends']
Integrability,"/// Convert a value read from an index section to the internal representation.; ///; /// The conversion depends on the index section version, which is expected; /// to be either 2 for pre-standard GNU proposal or 5 for DWARFv5 package file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnitIndex.h:104,depend,depends,104,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnitIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnitIndex.h,1,['depend'],['depends']
Integrability,"/// Convert from an ""exit count"" (i.e. ""backedge taken count"") to a ""trip; /// count"". A ""trip count"" is the number of times the header of the loop; /// will execute if an exit is taken after the specified number of backedges; /// have been taken. (e.g. TripCount = ExitCount + 1). Note that the; /// expression can overflow if ExitCount = UINT_MAX. If EvalTy is not wide; /// enough to hold the result without overflow, result unsigned wraps with; /// 2s-complement semantics. ex: EC = 255 (i8), TC = 0 (i8)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:437,wrap,wraps,437,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['wrap'],['wraps']
Integrability,"/// Convert the given type to a string suitable for printing as part of; /// a diagnostic.; ///; /// There are four main criteria when determining whether we should have an; /// a.k.a. clause when pretty-printing a type:; ///; /// 1) Some types provide very minimal sugar that doesn't impede the; /// user's understanding --- for example, elaborated type; /// specifiers. If this is all the sugar we see, we don't want an; /// a.k.a. clause.; /// 2) Some types are technically sugared but are much more familiar; /// when seen in their sugared form --- for example, va_list,; /// vector types, and the magic Objective C types. We don't; /// want to desugar these, even if we do produce an a.k.a. clause.; /// 3) Some types may have already been desugared previously in this diagnostic.; /// if this is the case, doing another ""aka"" would just be clutter.; /// 4) Two different types within the same diagnostic have the same output; /// string. In this case, force an a.k.a with the desugared type when; /// doing so will provide additional information.; ///; /// \param Context the context in which the type was allocated; /// \param Ty the type to print; /// \param QualTypeVals pointer values to QualTypes which are used in the; /// diagnostic message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:1246,message,message,1246,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,1,['message'],['message']
Integrability,/// Convert the internal value for a section kind to an on-disk value.; ///; /// The conversion depends on the version of the index section.; /// IndexVersion is expected to be either 2 for pre-standard GNU proposal; /// or 5 for DWARFv5 package file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnitIndex.h:96,depend,depends,96,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnitIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnitIndex.h,1,['depend'],['depends']
Integrability,"/// ConvertArgumentsForCall - Converts the arguments specified in; /// Args/NumArgs to the parameter types of the function FDecl with; /// function prototype Proto. Call is the call expression itself, and; /// Fn is the function expression. For a C++ member function, this; /// routine does not attempt to convert the object argument. Returns; /// true if the call is ill-formed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:278,rout,routine,278,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['rout'],['routine']
Integrability,"/// ConvertTypeForMem - Convert type T into a llvm::Type. This differs from; /// ConvertType in that it is used to convert to the memory representation for; /// a type. For example, the scalar representation for _Bool is i1, but the; /// memory representation is usually i8 or i32, depending on the target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp:282,depend,depending,282,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp,2,['depend'],['depending']
Integrability,"/// Cope with a name conflict when importing a declaration into the; /// given context.; ///; /// This routine is invoked whenever there is a name conflict while; /// importing a declaration. The returned name will become the name of the; /// imported declaration. By default, the returned name is the same as the; /// original name, leaving the conflict unresolve such that name lookup; /// for this name is likely to find an ambiguity later.; ///; /// Subclasses may override this routine to resolve the conflict, e.g., by; /// renaming the declaration being imported.; ///; /// \param Name the name of the declaration being imported, which conflicts; /// with other declarations.; ///; /// \param DC the declaration context (in the ""to"" AST context) in which; /// the name is being imported.; ///; /// \param IDNS the identifier namespace in which the name will be found.; ///; /// \param Decls the set of declarations with the same name as the; /// declaration being imported.; ///; /// \param NumDecls the number of conflicting declarations in \p Decls.; ///; /// \returns the name that the newly-imported declaration should have. Or; /// an error if we can't handle the name conflict.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:103,rout,routine,103,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,2,['rout'],['routine']
Integrability,"/// Copy \p V or return a reference, depending on \a ValueParamT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:37,depend,depending,37,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['depend'],['depending']
Integrability,/// CoreFoundation does not have any language interoperability,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h:46,interoperab,interoperability,46,interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,1,['interoperab'],['interoperability']
Integrability,"/// Crash recovery helper object.; ///; /// This class implements support for running operations in a safe context so; /// that crashes (memory errors, stack overflow, assertion violations) can be; /// detected and control restored to the crashing thread. Crash detection is; /// purely ""best effort"", the exact set of failures which can be recovered from; /// is platform dependent.; ///; /// Clients make use of this code by first calling; /// CrashRecoveryContext::Enable(), and then executing unsafe operations via a; /// CrashRecoveryContext object. For example:; ///; /// \code; /// void actual_work(void *);; ///; /// void foo() {; /// CrashRecoveryContext CRC;; ///; /// if (!CRC.RunSafely(actual_work, 0)) {; /// ... a crash was detected, report error to user ...; /// }; ///; /// ... no crash was detected ...; /// }; /// \endcode; ///; /// To assist recovery the class allows specifying set of actions that will be; /// executed in any case, whether crash occurs or not. These actions may be used; /// to reclaim resources in the case of crash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:373,depend,dependent,373,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,1,['depend'],['dependent']
Integrability,/// Create InstrProfSymtab from a set of names iteratable from; /// \p IterRange. This interface is used by IndexedProfReader.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:87,interface,interface,87,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,1,['interface'],['interface']
Integrability,/// Create a BitCast or AddrSpaceCast for a pointer type depending on; /// the address space.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h:57,depend,depending,57,interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,1,['depend'],['depending']
Integrability,/// Create a DISubprogram describing the function; /// represented in the given FunctionDecl wrapped in a GlobalDecl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:93,wrap,wrapped,93,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['wrap'],['wrapped']
Integrability,/// Create a ExecutorProcessControl-based DebugObjectRegistrar that emits debug; /// objects to the GDB JIT interface. This will use the EPC's lookupSymbols; /// method to find the registration/deregistration function addresses by name.; ///; /// If RegistrationFunctionsDylib is non-None then it will be searched to find; /// the registration functions. If it is None then the process dylib will be; /// loaded to find the registration functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDebugObjectRegistrar.h:108,interface,interface,108,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDebugObjectRegistrar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDebugObjectRegistrar.h,1,['interface'],['interface']
Integrability,"/// Create a NoteTag that displays the message if the 'errno' memory region is; /// marked as interesting, and resets the interestingness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h:39,message,message,39,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h,1,['message'],['message']
Integrability,/// Create a WrapperFunctionCall from a target function and arg buffer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:13,Wrap,WrapperFunctionCall,13,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,1,['Wrap'],['WrapperFunctionCall']
Integrability,/// Create a WrapperFunctionCall using the given SPS serializer to serialize; /// the arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:13,Wrap,WrapperFunctionCall,13,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,1,['Wrap'],['WrapperFunctionCall']
Integrability,/// Create a WrapperFunctionResult by taking ownership of a; /// CWrapperFunctionResult.; ///; /// Warning: This should only be used by clients writing wrapper-function; /// caller utilities (like TargetProcessControl).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:13,Wrap,WrapperFunctionResult,13,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,2,"['Wrap', 'wrap']","['WrapperFunctionResult', 'wrapper-function']"
Integrability,/// Create a WrapperFunctionResult with the given size and return a pointer; /// to the underlying memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:13,Wrap,WrapperFunctionResult,13,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,1,['Wrap'],['WrapperFunctionResult']
Integrability,"/// Create a call expression.; /// \param Fn The callee expression,; /// \param Args The argument array,; /// \param Ty The type of the call expression (which is *not* the return; /// type in general),; /// \param VK The value kind of the call expression (lvalue, rvalue, ...),; /// \param RParenLoc The location of the right parenthesis in the call; /// expression.; /// \param FPFeatures Floating-point features associated with the call,; /// \param MinNumArgs Specifies the minimum number of arguments. The actual; /// number of arguments will be the greater of Args.size(); /// and MinNumArgs. This is used in a few places to allocate; /// enough storage for the default arguments.; /// \param UsesADL Specifies whether the callee was found through; /// argument-dependent lookup.; ///; /// Note that you can use CreateTemporary if you need a temporary call; /// expression on the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:767,depend,dependent,767,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['depend'],['dependent']
Integrability,/// Create a call to the experimental.gc.result intrinsic to extract; /// the result from a call wrapped in a statepoint.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:97,wrap,wrapped,97,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['wrap'],['wrapped']
Integrability,"/// Create a class message send.; ///; /// \param Context The ASTContext in which this expression will be created.; ///; /// \param T The result type of this message.; ///; /// \param VK The value kind of this message. A message returning; /// a l-value or r-value reference will be an l-value or x-value,; /// respectively.; ///; /// \param LBracLoc The location of the open square bracket '['.; ///; /// \param Receiver The type of the receiver, including; /// source-location information.; ///; /// \param Sel The selector used to determine which method gets called.; ///; /// \param Method The Objective-C method against which this message; /// send was type-checked. May be nullptr.; ///; /// \param Args The message send arguments.; ///; /// \param RBracLoc The location of the closing square bracket ']'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:19,message,message,19,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,6,['message'],['message']
Integrability,/// Create a default WrapperFunctionResult.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:21,Wrap,WrapperFunctionResult,21,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,1,['Wrap'],['WrapperFunctionResult']
Integrability,/// Create a dependency file for `-d` option.; ///; /// This functionality is really only for the benefit of the build system.; /// It is similar to GCC's `-M*` family of options.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/Main.cpp:13,depend,dependency,13,interpreter/llvm-project/llvm/lib/TableGen/Main.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/Main.cpp,1,['depend'],['dependency']
Integrability,/// Create a global module fragment for a C++ module interface unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:53,interface,interface,53,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,1,['interface'],['interface']
Integrability,"/// Create a global module fragment for a C++ module unit.; ///; /// We model the global module fragment as a submodule of the module; /// interface unit. Unfortunately, we can't create the module interface; /// unit's Module until later, because we don't know what it will be called; /// usually. See C++20 [module.unit]/7.2 for the case we could know its; /// parent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:139,interface,interface,139,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,2,['interface'],['interface']
Integrability,"/// Create a link from \a from to \a to.; ///; /// The link may be a soft or a hard link, depending on the platform. The caller; /// may not assume which one. Currently on windows it creates a hard link since; /// soft links require extra privileges. On unix, it creates a soft link since; /// hard links don't work on SMB file systems.; ///; /// @param to The path to hard link to.; /// @param from The path to hard link from. This is created.; /// @returns errc::success if the link was created, otherwise a platform; /// specific error_code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:90,depend,depending,90,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['depend'],['depending']
Integrability,"/// Create a local file system cache which uses the given cache name, temporary; /// file prefix, cache directory and file callback. This function does not; /// immediately create the cache directory if it does not yet exist; this is; /// done lazily the first time a file is added. The cache name appears in error; /// messages for errors during caching. The temporary file prefix is used in the; /// temporary file naming scheme used when writing files atomically.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h:320,message,messages,320,interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,1,['message'],['messages']
Integrability,"/// Create a mapping for the value numbering of the calling; /// IRSimilarityCandidate, to a different separate set of numbers, based on; /// the canonical ordering in \p SourceCand. These are defined based on the; /// canonical mapping defined between \p SoureCandLarge and; /// \p TargetCandLarge. These IRSimilarityCandidates are already structurally; /// similar, and fully encapsulate the IRSimilarityCandidates in question.; /// These are used as a ""bridge"" from the \p SourceCand to the target.; ///; /// \param [in, out] SourceCand - The IRSimilarityCandidate to create a; /// canonical numbering from.; /// \param SoureCandLarge - The IRSimilarityCandidate fully containing; /// \p SourceCand.; /// \param TargetCandLarge - The IRSimilarityCandidate fully containing; /// this Candidate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:456,bridg,bridge,456,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,1,['bridg'],['bridge']
Integrability,/// Create a memory dependence edge going from \p Src to \p Tgt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:20,depend,dependence,20,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,1,['depend'],['dependence']
Integrability,"/// Create a message send to super.; ///; /// \param Context The ASTContext in which this expression will be created.; ///; /// \param T The result type of this message.; ///; /// \param VK The value kind of this message. A message returning; /// a l-value or r-value reference will be an l-value or x-value,; /// respectively.; ///; /// \param LBracLoc The location of the open square bracket '['.; ///; /// \param SuperLoc The location of the ""super"" keyword.; ///; /// \param IsInstanceSuper Whether this is an instance ""super""; /// message (otherwise, it's a class ""super"" message).; ///; /// \param Sel The selector used to determine which method gets called.; ///; /// \param Method The Objective-C method against which this message; /// send was type-checked. May be nullptr.; ///; /// \param Args The message send arguments.; ///; /// \param RBracLoc The location of the closing square bracket ']'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:13,message,message,13,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,8,['message'],['message']
Integrability,"/// Create a new AST node representation for '#pragma omp tile'.; ///; /// \param C Context of the AST.; /// \param StartLoc Location of the introducer (e.g. the 'omp' token).; /// \param EndLoc Location of the directive's end (e.g. the tok::eod).; /// \param Clauses The directive's clauses.; /// \param NumLoops Number of associated loops (number of items in the; /// 'sizes' clause).; /// \param AssociatedStmt The outermost associated loop.; /// \param TransformedStmt The loop nest after tiling, or nullptr in; /// dependent contexts.; /// \param PreInits Helper preinits statements for the loop nest.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:520,depend,dependent,520,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,1,['depend'],['dependent']
Integrability,"/// Create a new AST node representation for '#pragma omp unroll'.; ///; /// \param C Context of the AST.; /// \param StartLoc Location of the introducer (e.g. the 'omp' token).; /// \param EndLoc Location of the directive's end (e.g. the tok::eod).; /// \param Clauses The directive's clauses.; /// \param AssociatedStmt The outermost associated loop.; /// \param TransformedStmt The loop nest after tiling, or nullptr in; /// dependent contexts.; /// \param PreInits Helper preinits statements for the loop nest.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:428,depend,dependent,428,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,1,['depend'],['dependent']
Integrability,/// Create a new module for a C++ module implementation unit.; /// The interface module for this implementation (implicitly imported) must; /// exist and be loaded and present in the modules map.; ///; /// \returns The newly-created module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:71,interface,interface,71,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,1,['interface'],['interface']
Integrability,"/// Create a new module for a C++ module interface unit.; /// The module must not already exist, and will be configured for the current; /// compilation.; ///; /// Note that this also sets the current module to the newly-created module.; ///; /// \returns The newly-created module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:41,interface,interface,41,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,1,['interface'],['interface']
Integrability,/// Create a non-result-dependent generic selection expression accepting a; /// type predicate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:24,depend,dependent,24,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['depend'],['dependent']
Integrability,/// Create a non-result-dependent generic selection expression accepting an; /// expression predicate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:24,depend,dependent,24,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['depend'],['dependent']
Integrability,/// Create a result-dependent generic selection expression accepting a type; /// predicate,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:20,depend,dependent,20,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['depend'],['dependent']
Integrability,/// Create a result-dependent generic selection expression accepting an; /// expression predicate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:20,depend,dependent,20,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['depend'],['dependent']
Integrability,/// Create a runtime call for __tgt_interop_destroy; ///; /// \param Loc The insert and source location description.; /// \param InteropVar variable to be allocated; /// \param Device devide to which offloading will occur; /// \param NumDependences number of dependence variables; /// \param DependenceAddress pointer to dependence variables; /// \param HaveNowaitClause does nowait clause exist; ///; /// \returns CallInst to the __tgt_interop_destroy call,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:259,depend,dependence,259,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,3,"['Depend', 'depend']","['DependenceAddress', 'dependence']"
Integrability,/// Create a runtime call for __tgt_interop_init; ///; /// \param Loc The insert and source location description.; /// \param InteropVar variable to be allocated; /// \param InteropType type of interop operation; /// \param Device devide to which offloading will occur; /// \param NumDependences number of dependence variables; /// \param DependenceAddress pointer to dependence variables; /// \param HaveNowaitClause does nowait clause exist; ///; /// \returns CallInst to the __tgt_interop_init call,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:306,depend,dependence,306,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,3,"['Depend', 'depend']","['DependenceAddress', 'dependence']"
Integrability,/// Create a runtime call for __tgt_interop_use; ///; /// \param Loc The insert and source location description.; /// \param InteropVar variable to be allocated; /// \param Device devide to which offloading will occur; /// \param NumDependences number of dependence variables; /// \param DependenceAddress pointer to dependence variables; /// \param HaveNowaitClause does nowait clause exist; ///; /// \returns CallInst to the __tgt_interop_use call,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:255,depend,dependence,255,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,3,"['Depend', 'depend']","['DependenceAddress', 'dependence']"
Integrability,"/// Create a sequential execution region within a merged parallel region,; /// encapsulated in a master construct with a barrier for synchronization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:133,synchroniz,synchronization,133,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['synchroniz'],['synchronization']
Integrability,"/// Create a shallow wrapper for \p F such that \p F has internal linkage; /// afterwards. It also sets the original \p F 's name to anonymous; ///; /// A wrapper is a function with the same type (and attributes) as \p F; /// that will only call \p F and return the result, if any.; ///; /// Assuming the declaration of looks like:; /// rty F(aty0 arg0, ..., atyN argN);; ///; /// The wrapper will then look as follows:; /// rty wrapper(aty0 arg0, ..., atyN argN) {; /// return F(arg0, ..., argN);; /// }; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:21,wrap,wrapper,21,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,4,['wrap'],['wrapper']
Integrability,/// Create a subprogram describing the forward declaration; /// represented in the given FunctionDecl wrapped in a GlobalDecl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:102,wrap,wrapped,102,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['wrap'],['wrapped']
Integrability,"/// Create a verifier pass.; ///; /// Check a module or function for validity. This is essentially a pass wrapped; /// around the above verifyFunction and verifyModule routines and; /// functionality. When the pass detects a verification error it is always; /// printed to stderr, and by default they are fatal. You can override that by; /// passing \c false to \p FatalErrors.; ///; /// Note that this creates a pass suitable for the legacy pass manager. It has; /// nothing to do with \c VerifierPass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h:106,wrap,wrapped,106,interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,2,"['rout', 'wrap']","['routines', 'wrapped']"
Integrability,"/// Create a writer, potentially wrapping the sink in a RPageSinkBuf.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:33,wrap,wrapping,33,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,1,['wrap'],['wrapping']
Integrability,/// Create an Objective-C protocol reference at the given location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h:26,protocol,protocol,26,interpreter/llvm-project/clang/tools/libclang/CXCursor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h,1,['protocol'],['protocol']
Integrability,/// Create an OpenCL kernel for an enqueued block. The kernel function is; /// a wrapper for the block invoke function with target-specific calling; /// convention and ABI as an OpenCL kernel. The wrapper function accepts; /// block context and block arguments in target-specific way and calls; /// the original block invoke function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h:81,wrap,wrapper,81,interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,2,['wrap'],['wrapper']
Integrability,/// Create an analysis pass wrapper around a TTI object.; ///; /// This analysis pass just holds the TTI instance and makes it available to; /// clients.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:28,wrap,wrapper,28,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['wrap'],['wrapper']
Integrability,/// Create an artificial edge between FirstSU and SecondSU.; /// Make data dependencies from the FirstSU also dependent on the SecondSU to; /// prevent them from being scheduled between the FirstSU and the SecondSU; /// and vice-versa.; /// Fusing more than 2 instructions is not currently supported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h:75,depend,dependencies,75,interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h,2,['depend'],"['dependencies', 'dependent']"
Integrability,"/// Create an assume intrinsic call that represents an alignment; /// assumption on the provided pointer.; ///; /// An optional offset can be provided, and if it is provided, the offset; /// must be subtracted from the provided pointer to get the pointer with the; /// specified alignment.; ///; /// This overload handles the condition where the Alignment is dependent; /// on an existing value rather than a static value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:359,depend,dependent,359,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['depend'],['dependent']
Integrability,"/// Create an empty Objective-C message expression, to be; /// filled in by subsequent calls.; ///; /// \param Context The context in which the message send will be created.; ///; /// \param NumArgs The number of message arguments, not including; /// the receiver.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:32,message,message,32,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,3,['message'],['message']
Integrability,/// Create an extra user-specified \p OffloadFile.; /// TODO: We should find a way to wrap these as libraries instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:86,wrap,wrap,86,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,1,['wrap'],['wrap']
Integrability,"/// Create an implicit import of the given module at the given; /// source location, for error recovery, if possible.; ///; /// This routine is typically used when an entity found by name lookup; /// is actually hidden within a module that we know about but the user; /// has forgotten to import.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:133,rout,routine,133,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['rout'],['routine']
Integrability,"/// Create an instance message send.; ///; /// \param Context The ASTContext in which this expression will be created.; ///; /// \param T The result type of this message.; ///; /// \param VK The value kind of this message. A message returning; /// a l-value or r-value reference will be an l-value or x-value,; /// respectively.; ///; /// \param LBracLoc The location of the open square bracket '['.; ///; /// \param Receiver The expression used to produce the object that; /// will receive this message.; ///; /// \param Sel The selector used to determine which method gets called.; ///; /// \param Method The Objective-C method against which this message; /// send was type-checked. May be nullptr.; ///; /// \param Args The message send arguments.; ///; /// \param RBracLoc The location of the closing square bracket ']'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:23,message,message,23,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,7,['message'],['message']
Integrability,"/// Create and add an Objective-C interface record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:34,interface,interface,34,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,1,['interface'],['interface']
Integrability,"/// Create and add an Objective-C protocol record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:34,protocol,protocol,34,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,1,['protocol'],['protocol']
Integrability,/// Create either a UnaryOperator or BinaryOperator depending on \p Opc.; /// Correct number of operands must be passed accordingly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:52,depend,depending,52,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['depend'],['depending']
Integrability,"/// Create initial VPlan skeleton, having an ""entry"" VPBasicBlock (wrapping; /// original scalar pre-header) which contains SCEV expansions that need to; /// happen before the CFG is modified; a VPBasicBlock for the vector; /// pre-header, followed by a region for the vector loop, followed by the; /// middle VPBasicBlock.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:67,wrap,wrapping,67,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['wrap'],['wrapping']
Integrability,"/// Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:116,integrat,integration,116,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['integrat'],['integration']
Integrability,"/// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while; /// using specified configuration for any numeric integration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:178,integrat,integration,178,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['integrat'],['integration']
Integrability,"/// Create the AST consumer object for this action, if supported.; ///; /// This routine is called as part of BeginSourceFile(), which will; /// fail if the AST consumer cannot be created. This will not be called if the; /// action has indicated that it only uses the preprocessor.; ///; /// \param CI - The current compiler instance, provided as a convenience, see; /// getCompilerInstance().; ///; /// \param InFile - The current input file, provided as a convenience, see; /// getCurrentFile().; ///; /// \return The new AST consumer, or null on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h:81,rout,routine,81,interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,1,['rout'],['routine']
Integrability,"/// Create the default output file (from the invocation's options) and add it; /// to the list of tracked output files.; ///; /// The files created by this are usually removed on signal, and, depending; /// on FrontendOptions, may also use a temporary file (that is, the data is; /// written to a temporary file which will atomically replace the target; /// output on success).; ///; /// \return - Null on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h:192,depend,depending,192,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,1,['depend'],['depending']
Integrability,/// Create using the default object interface builder function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h:36,interface,interface,36,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h,1,['interface'],['interface']
Integrability,/// CreateBuiltinBinOp - Creates a new built-in binary operation with; /// operator @p Opc at location @c TokLoc. This routine only supports; /// built-in operations; ActOnBinOp handles overloaded operators.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:119,rout,routine,119,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['rout'],['routine']
Integrability,"/// CreateDefaultAlignedTempAlloca - This creates an alloca with the; /// default ABI alignment of the given LLVM type.; ///; /// IMPORTANT NOTE: This is *not* generally the right alignment for; /// any given AST type that happens to have been lowered to the; /// given IR type. This should only ever be used for function-local,; /// IR-driven manipulations like saving and restoring a value. Do; /// not hand this address off to arbitrary IRGen routines, and especially; /// do not pass it as an argument to a function that might expect a; /// properly ABI-aligned value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:446,rout,routines,446,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['rout'],['routines']
Integrability,"/// CreateIRTemp - Create a temporary IR object of the given type, with; /// appropriate alignment. This routine should only be used when an temporary; /// value needs to be stored into an alloca (for example, to avoid explicit; /// PHI construction), but the type is the IR type, not the type appropriate; /// for storing in memory.; ///; /// That is, this is exactly equivalent to CreateMemTemp, but calling; /// ConvertType instead of ConvertTypeForMem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:105,rout,routine,105,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['rout'],['routine']
Integrability,"/// CreateMetadataVar - Create a global variable with internal; /// linkage for use by the Objective-C runtime.; ///; /// This is a convenience wrapper which not only creates the; /// variable, but also sets the section and alignment and adds the; /// global to the ""llvm.used"" list.; ///; /// \param Name - The variable name.; /// \param Init - The variable initializer; this is also used to; /// define the type of the variable.; /// \param Section - The section the variable should go into, or empty.; /// \param Align - The alignment for the variable, or 0.; /// \param AddToUsed - Whether the variable should be added to; /// ""llvm.used"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:144,wrap,wrapper,144,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['wrap'],['wrapper']
Integrability,"/// Create_PragmaLexer: Lexer constructor - Create a new lexer object for; /// _Pragma expansion. This has a variety of magic semantics that this method; /// sets up. It returns a new'd Lexer that must be delete'd when done.; ///; /// On entrance to this routine, TokStartLoc is a macro location which has a; /// spelling loc that indicates the bytes to be lexed for the token and an; /// expansion location that indicates where all lexed tokens should be; /// ""expanded from"".; ///; /// TODO: It would really be nice to make _Pragma just be a wrapper around a; /// normal lexer that remaps tokens as they fly by. This would require making; /// Preprocessor::Lex virtual. Given that, we could just dump in a magic lexer; /// interface that could handle this stuff. This would pull GetMappedTokenLoc; /// out of the critical path of the lexer!; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:255,rout,routine,255,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,3,"['interface', 'rout', 'wrap']","['interface', 'routine', 'wrapper']"
Integrability,/// Creates Break False Dependencies pass. \see BreakFalseDeps.cpp,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:24,Depend,Dependencies,24,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['Depend'],['Dependencies']
Integrability,"/// Creates SourceManager and necessary dependencies (e.g. VFS, FileManager).; /// The main file in the SourceManager will be \p FileName with \p Content.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:40,depend,dependencies,40,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['depend'],['dependencies']
Integrability,/// Creates a BoolValue wrapping a particular formula.; ///; /// Passing in the same formula will result in the same BoolValue.; /// FIXME: Interning BoolValues but not other Values is inconsistent.; /// Decide whether we want Value interning or not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Arena.h:24,wrap,wrapping,24,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Arena.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Arena.h,1,['wrap'],['wrapping']
Integrability,"/// Creates a fresh atom and wraps in in an AtomicBoolValue.; /// FIXME: For now, identical-address AtomicBoolValue <=> identical atom.; /// Stop relying on pointer identity and remove this guarantee.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Arena.h:29,wrap,wraps,29,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Arena.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Arena.h,1,['wrap'],['wraps']
Integrability,"/// Creates a metadata symbol associated with a specific region.; ///; /// VisitCount can be used to differentiate regions corresponding to; /// different loop iterations, thus, making the symbol path-dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h:201,depend,dependent,201,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,1,['depend'],['dependent']
Integrability,"/// Creates a new refactoring action rule that constructs and invokes the; /// \c RuleType rule when all of the requirements are satisfied.; ///; /// This function takes in a list of values whose type derives from; /// \c RefactoringActionRuleRequirement. These values describe the initiation; /// requirements that have to be satisfied by the refactoring engine before; /// the provided action rule can be constructed and invoked. The engine; /// verifies that the requirements are satisfied by evaluating them (using the; /// 'evaluate' member function) and checking that the results don't contain; /// any errors. Once all requirements are satisfied, the provided refactoring; /// rule is constructed by passing in the values returned by the requirements'; /// evaluate functions as arguments to the constructor. The rule is then invoked; /// immediately after construction.; ///; /// The separation of requirements, their evaluation and the invocation of the; /// refactoring action rule allows the refactoring clients to:; /// - Disable refactoring action rules whose requirements are not supported.; /// - Gather the set of options and define a command-line / visual interface; /// that allows users to input these options without ever invoking the; /// action.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:1173,interface,interface,1173,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,1,['interface'],['interface']
Integrability,"/// Creates a value appropriate for `Type`, if `Type` is supported, otherwise; /// return null.; ///; /// Recursively initializes storage locations and values until it sees a; /// self-referential pointer or reference type. `Visited` is used to track; /// which types appeared in the reference/pointer chain in order to avoid; /// creating a cyclic dependency with self-referential pointers/references.; ///; /// Requirements:; ///; /// `Type` must not be null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h:349,depend,dependency,349,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h,1,['depend'],['dependency']
Integrability,"/// Creates a wrapping RooBinSamplingPdf if appropriate.; /// \param[in] pdf The input pdf.; /// \param[in] data The dataset to be used in the fit, used to figure out the; /// observables and whether the dataset is binned.; /// \param[in] precision Precision argument for all created RooBinSamplingPdfs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:14,wrap,wrapping,14,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['wrap'],['wrapping']
Integrability,/// Creates an empty clause with \a N variables.; ///; /// \param C AST context.; /// \param N The number of variables.; /// \param NumLoops Number of loops that is associated with this depend; /// clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:186,depend,depend,186,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['depend'],['depend']
Integrability,/// Creates clause for 'depobj' directive.; ///; /// \param C AST context.; /// \param StartLoc Starting location of the clause.; /// \param LParenLoc Location of '('.; /// \param ArgumentLoc Location of the argument.; /// \param DK Dependence kind.; /// \param EndLoc Ending location of the clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:233,Depend,Dependence,233,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['Depend'],['Dependence']
Integrability,/// Creates clause with a list of expressions \a VL.; ///; /// \param C AST context.; /// \param StartLoc Starting location of the clause.; /// \param LParenLoc Location of '('.; /// \param EndLoc Ending location of the clause.; /// \param DepType The dependence type.; /// \param DepLoc Location of the dependence type.; /// \param ColonLoc Location of ':'.; /// \param VL List of references to the expressions.; /// \param NumLoops Number of loops that associated with the clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:252,depend,dependence,252,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,2,['depend'],['dependence']
Integrability,/// Creates clause with a list of variables \a VL.; ///; /// \param C AST context.; /// \param StartLoc Starting location of the clause.; /// \param LParenLoc Location of '('.; /// \param EndLoc Ending location of the clause.; /// \param Data Dependency type and source locations.; /// \param VL List of references to the variables.; /// \param NumLoops Number of loops that is associated with this depend; /// clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:243,Depend,Dependency,243,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,2,"['Depend', 'depend']","['Dependency', 'depend']"
Integrability,/// Creates wrapper class for PPCallbacks so we can also process information; /// about includes that are inside of a preamble. Called after BeforeExecute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h:12,wrap,wrapper,12,interpreter/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h,1,['wrap'],['wrapper']
Integrability,/// Critical path length. This is the number of cycles in the longest data; /// dependency chain through the trace. This is only valid when both; /// HasValidInstrDepths and HasValidInstrHeights are set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:80,depend,dependency,80,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,1,['depend'],['dependency']
Integrability,/// Cross register the analysis managers through their proxies.; ///; /// This is an interface that can be used to cross register each; /// AnalysisManager with all the others analysis managers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:85,interface,interface,85,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,1,['interface'],['interface']
Integrability,"/// Cross-check the analytical integration code with the normal Gaussian.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooBifurGauss.cxx:31,integrat,integration,31,roofit/roofit/test/testRooBifurGauss.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooBifurGauss.cxx,1,['integrat'],['integration']
Integrability,/// Cursor - The primary query interface for the block interference cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:31,interface,interface,31,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,1,['interface'],['interface']
Integrability,/// CvtQTToAstBitMask - utility routine to produce an AST bitmask for; /// objective-c's type qualifier from the parser version of the same info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:32,rout,routine,32,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['rout'],['routine']
Integrability,"/// DAGDeltaAlgorithm - Implements a ""delta debugging"" algorithm for minimizing; /// directed acyclic graphs using a predicate function.; ///; /// The result of the algorithm is a subset of the input change set which is; /// guaranteed to satisfy the predicate, assuming that the input set did. For; /// well formed predicates, the result set is guaranteed to be such that; /// removing any single element not required by the dependencies on the other; /// elements would falsify the predicate.; ///; /// The DAG should be used to represent dependencies in the changes which are; /// likely to hold across the predicate function. That is, for a particular; /// changeset S and predicate P:; ///; /// P(S) => P(S union pred(S)); ///; /// The minimization algorithm uses this dependency information to attempt to; /// eagerly prune large subsets of changes. As with \see DeltaAlgorithm, the DAG; /// is not required to satisfy this property, but the algorithm will run; /// substantially fewer tests with appropriate dependencies. \see DeltaAlgorithm; /// for more information on the properties which the predicate function itself; /// should satisfy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:426,depend,dependencies,426,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,4,['depend'],"['dependencies', 'dependency']"
Integrability,/// Data Dependence Graph Node; /// The graph can represent the following types of nodes:; /// 1. Single instruction node containing just one instruction.; /// 2. Multiple instruction node where two or more instructions from; /// the same basic block are merged into one node.; /// 3. Pi-block node which is a group of other DDG nodes that are part of a; /// strongly-connected component of the graph.; /// A pi-block node contains more than one single or multiple instruction; /// nodes. The root node cannot be part of a pi-block.; /// 4. Root node is a special node that connects to all components such that; /// there is always a path from it to any node in the graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:9,Depend,Dependence,9,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,1,['Depend'],['Dependence']
Integrability,/// Data Dependency Graph,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:9,Depend,Dependency,9,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,1,['Depend'],['Dependency']
Integrability,/// Data Dependency Graph Edge.; /// An edge in the DDG can represent a def-use relationship or; /// a memory dependence based on the result of DependenceAnalysis.; /// A rooted edge connects the root node to one of the components; /// of the graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:9,Depend,Dependency,9,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,3,"['Depend', 'depend']","['DependenceAnalysis', 'Dependency', 'dependence']"
Integrability,/// DebugifyCustomPassManager wraps each pass with the debugify passes if; /// needed.; /// NOTE: We support legacy custom pass manager only.; /// TODO: Add New PM support for custom pass manager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:30,wrap,wraps,30,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,1,['wrap'],['wraps']
Integrability,/// Decide whether to extend the lifetime of the receiver of a; /// returns-inner-pointer message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:90,message,message,90,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['message'],['message']
Integrability,"/// Declarations in this context are formally odr-used, but this is a; /// dependent context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:75,depend,dependent,75,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependent']
Integrability,/// Deduce the dependency target based on the output file and input files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:15,depend,dependency,15,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,1,['depend'],['dependency']
Integrability,"/// Deduce the type for an auto type-specifier (C++11 [dcl.spec.auto]p6); ///; /// Note that this is done even if the initializer is dependent. (This is; /// necessary to support partial ordering of templates using 'auto'.); /// A dependent type will be produced when deducing from a dependent type.; ///; /// \param Type the type pattern using the auto type-specifier.; /// \param Init the initializer for the variable whose type is to be deduced.; /// \param Result if type deduction was successful, this will be set to the; /// deduced type.; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; /// \param DependentDeduction Set if we should permit deduction in; /// dependent cases. This is necessary for template partial ordering with; /// 'auto' template parameters. The template parameter depth to be used; /// should be specified in the 'Info' parameter.; /// \param IgnoreConstraints Set if we should not fail if the deduced type does; /// not satisfy the type-constraint in the auto type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:133,depend,dependent,133,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,5,"['Depend', 'depend']","['DependentDeduction', 'dependent']"
Integrability,"/// Deduce the value of the given non-type template parameter; /// from the given type- or value-dependent expression.; ///; /// \returns true if deduction succeeded, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:97,depend,dependent,97,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,"/// DeepCollectObjCIvars -; /// This routine first collects all declared, but not synthesized, ivars in; /// super class and then collects all ivars, including those synthesized for; /// current class. This routine is used for implementation of current class; /// when all ivars, declared and synthesized are known.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:37,rout,routine,37,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['rout'],['routine']
Integrability,/// Default wrap function to use on this host.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h:12,wrap,wrap,12,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h,1,['wrap'],['wrap']
Integrability,/// DefaultSynthesizeProperties - This routine default synthesizes all; /// properties which must be synthesized in the class's \@implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:39,rout,routine,39,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['rout'],['routine']
Integrability,"/// Define the ""body"" of the conversion from a lambda object to a; /// block pointer.; ///; /// This routine doesn't actually define a sensible body; rather, it fills; /// in the initialization expression needed to copy the lambda object into; /// the block, and IR generation actually generates the real body of the; /// block pointer conversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:101,rout,routine,101,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['rout'],['routine']
Integrability,"/// Define the ""body"" of the conversion from a lambda object to a; /// function pointer.; ///; /// This routine doesn't actually define a sensible body; rather, it fills; /// in the initialization expression needed to copy the lambda object into; /// the block, and IR generation actually generates the real body of the; /// block pointer conversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:104,rout,routine,104,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['rout'],['routine']
Integrability,"/// DefinedProtocols - Protocols which have actually been; /// defined. We should not need this, see FIXME in GenerateProtocol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:23,Protocol,Protocols,23,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Protocol'],['Protocols']
Integrability,"/// Defines interfaces for operating ""Token"" in the clang syntax-tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h:12,interface,interfaces,12,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h,1,['interface'],['interfaces']
Integrability,/// Defines the interface file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h,1,['interface'],['interface']
Integrability,/// Defines the interface for synch scope model.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SyncScope.h:16,interface,interface,16,interpreter/llvm-project/clang/include/clang/Basic/SyncScope.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SyncScope.h,1,['interface'],['interface']
Integrability,"/// Defines the object file and target independent interfaces used by the; /// assembler backend to write native file format object files.; ///; /// The object writer contains a few callbacks used by the assembler to allow; /// the object writer to modify the assembler data structures at appropriate; /// points. Once assembly is complete, the object writer is given the; /// MCAssembler instance, which contains all the symbol and section data which; /// should be emitted as part of writeObject().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCObjectWriter.h:51,interface,interfaces,51,interpreter/llvm-project/llvm/include/llvm/MC/MCObjectWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCObjectWriter.h,1,['interface'],['interfaces']
Integrability,"/// Defines the scope in which this symbol should be visible:; /// Default -- Visible in the public interface of the linkage unit.; /// Hidden -- Visible within the linkage unit, but not exported from it.; /// Local -- Visible only within the LinkGraph.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:100,interface,interface,100,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['interface'],['interface']
Integrability,"/// Definitions of declarations injected also into cling.; /// NOTE: this could also stay in a header #included here and into cling, but; /// for the sake of simplicity we just redeclare them here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/demo/cling-demo.cpp:32,inject,injected,32,interpreter/cling/tools/demo/cling-demo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/demo/cling-demo.cpp,1,['inject'],['injected']
Integrability,"/// DelayForLiveRegsBottomUp - Returns true if it is necessary to delay; /// scheduling of the given node to satisfy live physical register dependencies.; /// If the specific node is the last one that's available to schedule, do; /// whatever is necessary (i.e. backtracking or cloning) to make it possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:140,depend,dependencies,140,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,2,['depend'],['dependencies']
Integrability,"/// Delete all of the instructions in `DeadInsts`, and all other instructions; /// that deleting these in turn causes to be trivially dead.; ///; /// The initial instructions in the provided vector must all have empty use; /// lists and satisfy `isInstructionTriviallyDead`.; ///; /// `DeadInsts` will be used as scratch storage for this routine and will be; /// empty afterward.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:338,rout,routine,338,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,1,['rout'],['routine']
Integrability,/// Dependece between memory access instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:4,Depend,Dependece,4,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['Depend'],['Dependece']
Integrability,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Depend,Dependence,4,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,10,"['Depend', 'depend']","['Dependence', 'dependence', 'dependences']"
Integrability,/// Dependence information used to create memory dependence edges in the; /// graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:4,Depend,Dependence,4,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,2,"['Depend', 'depend']","['Dependence', 'dependence']"
Integrability,/// Dependence kind for RTL.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h:4,Depend,Dependence,4,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,1,['Depend'],['Dependence']
Integrability,/// Dependence type (sink or source).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:4,Depend,Dependence,4,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['Depend'],['Dependence']
Integrability,/// Dependence type location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:4,Depend,Dependence,4,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['Depend'],['Dependence']
Integrability,/// Dependence types that don't prevent vectorization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:4,Depend,Dependence,4,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['Depend'],['Dependence']
Integrability,"/// Dependence::DVEntry - Each level in the distance/direction vector; /// has a direction (or perhaps a union of several directions), and; /// perhaps a distance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Depend,Dependence,4,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,1,['Depend'],['Dependence']
Integrability,/// DependenceInfo - This class is the main dependence-analysis driver.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Depend,DependenceInfo,4,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,2,"['Depend', 'depend']","['DependenceInfo', 'dependence-analysis']"
Integrability,/// Dependencies - This is the list of all included files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h:4,Depend,Dependencies,4,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,1,['Depend'],['Dependencies']
Integrability,"/// Dependency scanner callbacks that are used during scanning to influence the; /// behaviour of the scan - for example, to customize the scanned invocations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:4,Depend,Dependency,4,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,1,['Depend'],['Dependency']
Integrability,"/// Dependency type (one of in, out, inout).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:4,Depend,Dependency,4,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['Depend'],['Dependency']
Integrability,/// Dependency type and source locations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:4,Depend,Dependency,4,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['Depend'],['Dependency']
Integrability,/// Dependency type location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:4,Depend,Dependency,4,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['Depend'],['Dependency']
Integrability,/// DependencyOutputFormat - Format for the compiler dependency file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h:4,Depend,DependencyOutputFormat,4,interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h,2,"['Depend', 'depend']","['DependencyOutputFormat', 'dependency']"
Integrability,/// DependencyOutputOptions - Options for controlling the compiler dependency; /// file generation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h:4,Depend,DependencyOutputOptions,4,interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h,2,"['Depend', 'depend']","['DependencyOutputOptions', 'dependency']"
Integrability,/// Dependent Library Specifiers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/IRSymtab.h:4,Depend,Dependent,4,interpreter/llvm-project/llvm/include/llvm/Object/IRSymtab.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/IRSymtab.h,1,['Depend'],['Dependent']
Integrability,"/// Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a; /// single line.; /// \version 9",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:4,Depend,Dependent,4,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['Depend'],['Dependent']
Integrability,"/// Dependent on the value, ``if (a) return;`` can be put on a single line.; /// \version 3.3",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:4,Depend,Dependent,4,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['Depend'],['Dependent']
Integrability,"/// Dependent on the value, ``int f() { return 0; }`` can be put on a; /// single line.; /// \version 3.5",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:4,Depend,Dependent,4,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['Depend'],['Dependent']
Integrability,"/// Dependent on the value, ``while (true) { continue; }`` can be put on a; /// single line.; /// \version 3.5",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:4,Depend,Dependent,4,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['Depend'],['Dependent']
Integrability,"/// Dependent on the value, multiple ``#include`` blocks can be sorted; /// as one and divided based on category.; /// \version 6",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h:4,Depend,Dependent,4,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h,1,['Depend'],['Dependent']
Integrability,/// Dependent variable map for CodeGenDAGPattern variant generation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:4,Depend,Dependent,4,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['Depend'],['Dependent']
Integrability,/// Depending on the bind clause of OMPD_loop map the directive to new; /// directives.; /// 1) loop bind(parallel) --> OMPD_for; /// 2) loop bind(teams) --> OMPD_distribute; /// 3) loop bind(thread) --> OMPD_simd; /// This is being handled in Sema instead of Codegen because of the need for; /// rigorous semantic checking in the new mapped directives.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Depend,Depending,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Depend'],['Depending']
Integrability,"/// Depending on uarch and/or optimizing for size, we might prefer to use a; /// vector operation in place of the typical scalar operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Depend,Depending,4,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['Depend'],['Depending']
Integrability,"/// Depending on wither the location corresponds to a macro, return; /// either the macro name or the token spelling.; ///; /// This could be useful when checkers' logic depends on whether a function; /// is called with a given macro argument. For example:; /// s = socket(AF_INET,..); /// If AF_INET is a macro, the result should be treated as a source of taint.; ///; /// \sa clang::Lexer::getSpelling(), clang::Lexer::getImmediateMacroName().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h:4,Depend,Depending,4,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h,2,"['Depend', 'depend']","['Depending', 'depends']"
Integrability,"/// Depth that GatherAllAliases should continue looking for chain; /// dependencies when trying to find a more preferable chain. As an; /// approximation, this should be more than the number of consecutive stores; /// expected to be merged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:71,depend,dependencies,71,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['depend'],['dependencies']
Integrability,/// Describes API notes data for an Objective-C class or protocol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/Types.h:57,protocol,protocol,57,interpreter/llvm-project/clang/include/clang/APINotes/Types.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/Types.h,1,['protocol'],['protocol']
Integrability,/// Describes a declarator chunk wrapping a pointer that marks inference as; /// unexpected.; // These values must be kept in sync with diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:33,wrap,wrapping,33,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['wrap'],['wrapping']
Integrability,"/// Describes a module, including its file name and dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:52,depend,dependencies,52,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,1,['depend'],['dependencies']
Integrability,"/// Describes an explicit type conversion that uses functional; /// notion but could not be resolved because one or more arguments are; /// type-dependent.; ///; /// The explicit type conversions expressed by; /// CXXUnresolvedConstructExpr have the form <tt>T(a1, a2, ..., aN)</tt>,; /// where \c T is some type and \c a1, \c a2, ..., \c aN are values, and; /// either \c T is a dependent type or one or more of the <tt>a</tt>'s is; /// type-dependent. For example, this would occur in a template such; /// as:; ///; /// \code; /// template<typename T, typename A1>; /// inline T make_a(const A1& a1) {; /// return T(a1);; /// }; /// \endcode; ///; /// When the returned expression is instantiated, it may resolve to a; /// constructor call, conversion function call, or some kind of type; /// conversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:145,depend,dependent,145,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,3,['depend'],['dependent']
Integrability,/// Describes the kind of message expression indicated by a message; /// send that starts with an identifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:26,message,message,26,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['message'],['message']
Integrability,/// Describes the syntax that was used in a documentation command.; ///; /// Exact values of this enumeration are important because they used to select; /// parts of diagnostic messages. Audit diagnostics before changing or adding; /// a new value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Comment.h:177,message,messages,177,interpreter/llvm-project/clang/include/clang/AST/Comment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Comment.h,1,['message'],['messages']
Integrability,"/// Destroy the callee-destroyed arguments of the given method,; /// if it has any. Used for nil-receiver paths in message sends.; /// Never does anything if the method does not satisfy; /// hasParamDestroyedInCallee().; ///; /// \param callArgs - just the formal arguments, not including implicit; /// arguments such as self and cmd",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h:115,message,message,115,interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,1,['message'],['message']
Integrability,/// Detailed information about the processor of the system that generated this; /// minidump. Its interpretation depends on the ProcessorArchitecture enum.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Minidump.h:113,depend,depends,113,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Minidump.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Minidump.h,1,['depend'],['depends']
Integrability,/// Detect 0-sample input profile and report to output stream. This interface; /// should be called after loadProfiles().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:68,interface,interface,68,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,1,['interface'],['interface']
Integrability,/// Determine if the SCEV can be evaluated at loop's entry. It is true if it; /// doesn't depend on a SCEVUnknown of an instruction which is dominated by; /// the header of loop L.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:90,depend,depend,90,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['depend'],['depend']
Integrability,"/// Determine if the raw_ostream provided is connected to a terminal. If so,; /// generate a warning message to errs() advising against display of bitcode; /// and return true. Otherwise just return false.; /// Check for output written to a console",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SystemUtils.h:101,message,message,101,interpreter/llvm-project/llvm/include/llvm/Support/SystemUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SystemUtils.h,1,['message'],['message']
Integrability,"/// Determine opportunities to derive 'default' attributes in \p F and create; /// abstract attribute objects for them.; ///; /// \param F The function that is checked for attribute opportunities.; ///; /// Note that abstract attribute instances are generally created even if the; /// IR already contains the information they would deduce. The most important; /// reason for this is the single interface, the one of the abstract attribute; /// instance, which can be queried without the need to look at the IR in; /// various places.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:394,interface,interface,394,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['interface'],['interface']
Integrability,"/// Determine the availability of the given declaration based on; /// the target platform.; ///; /// When it returns an availability result other than \c AR_Available,; /// if the \p Message parameter is non-NULL, it will be set to a; /// string describing why the entity is unavailable.; ///; /// FIXME: Make these strings localizable, since they end up in; /// diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:183,Message,Message,183,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,1,['Message'],['Message']
Integrability,"/// Determine the availability of the given declaration.; ///; /// This routine will determine the most restrictive availability of; /// the given declaration (e.g., preferring 'unavailable' to; /// 'deprecated').; ///; /// \param Message If non-NULL and the result is not \c; /// AR_Available, will be set to a (possibly empty) message; /// describing why the declaration has not been introduced, is; /// deprecated, or is unavailable.; ///; /// \param EnclosingVersion The version to compare with. If empty, assume the; /// deployment target version.; ///; /// \param RealizedPlatform If non-NULL and the availability result is found; /// in an available attribute it will set to the platform which is written in; /// the available attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:72,rout,routine,72,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,3,"['Message', 'message', 'rout']","['Message', 'message', 'routine']"
Integrability,"/// Determine the edit distance between this string and another; /// string.; ///; /// \param Other the string to compare this string against.; ///; /// \param AllowReplacements whether to allow character; /// replacements (change one character into another) as a single; /// operation, rather than as two operations (an insertion and a; /// removal).; ///; /// \param MaxEditDistance If non-zero, the maximum edit distance that; /// this routine is allowed to compute. If the edit distance will exceed; /// that maximum, returns \c MaxEditDistance+1.; ///; /// \returns the minimum number of character insertions, removals,; /// or (if \p AllowReplacements is \c true) replacements needed to; /// transform one of the given strings into the other. If zero,; /// the strings are identical.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:439,rout,routine,439,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,1,['rout'],['routine']
Integrability,"/// Determine the edit distance between two sequences.; ///; /// \param FromArray the first sequence to compare.; ///; /// \param ToArray the second sequence to compare.; ///; /// \param Map A Functor to apply to each item of the sequences before; /// comparison.; ///; /// \param AllowReplacements whether to allow element replacements (change one; /// element into another) as a single operation, rather than as two operations; /// (an insertion and a removal).; ///; /// \param MaxEditDistance If non-zero, the maximum edit distance that this; /// routine is allowed to compute. If the edit distance will exceed that; /// maximum, returns \c MaxEditDistance+1.; ///; /// \returns the minimum number of element insertions, removals, or (if; /// \p AllowReplacements is \c true) replacements needed to transform one of; /// the given sequences into the other. If zero, the sequences are identical.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/edit_distance.h:551,rout,routine,551,interpreter/llvm-project/llvm/include/llvm/ADT/edit_distance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/edit_distance.h,1,['rout'],['routine']
Integrability,/// Determine the kind of receiver that this message is being; /// sent to.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:45,message,message,45,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,1,['message'],['message']
Integrability,/// Determine the number of arguments in the given pack expansion; /// type.; ///; /// This routine assumes that the number of arguments in the expansion is; /// consistent across all of the unexpanded parameter packs in its pattern.; ///; /// Returns an empty Optional if the type can't be expanded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:92,rout,routine,92,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['rout'],['routine']
Integrability,"/// Determine the number of levels of enclosing template parameters. This is; /// only usable while parsing. Note that this does not include dependent; /// contexts in which no template parameters have yet been declared, such as; /// in a terse function template or generic lambda before the first 'auto' is; /// encountered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:141,depend,dependent,141,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['depend'],['dependent']
Integrability,"/// Determine the result of a message send expression based on; /// the type of the receiver, the method expected to receive the message,; /// and the form of the message send.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:30,message,message,30,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,3,['message'],['message']
Integrability,"/// Determine the result type of a message send based on the receiver type,; /// method, and the kind of message send.; ///; /// This is the ""base"" result type, which will still need to be adjusted; /// to account for nullability.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:35,message,message,35,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,2,['message'],['message']
Integrability,"/// Determine the type of a (typically non-lvalue) expression with the; /// specified result type.; ///; /// This routine should be used for expressions for which the return type is; /// explicitly specified (e.g., in a cast or call) and isn't necessarily; /// an lvalue. It removes a top-level reference (since there are no; /// expressions of reference type) and deletes top-level cvr-qualifiers; /// from non-class types (in C++) or all types (in C).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:114,rout,routine,114,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['rout'],['routine']
Integrability,/// Determine the type of an expression that sends a message to this; /// function with the given receiver type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:53,message,message,53,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['message'],['message']
Integrability,/// Determine the type of an expression that sends a message to this; /// function. This replaces the type parameters with the types they would; /// get if the receiver was parameterless (e.g. it may replace the type; /// parameter with 'id').,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:53,message,message,53,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['message'],['message']
Integrability,/// Determine transitive dependences of unpipelineable instructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:25,depend,dependences,25,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependences']
Integrability,"/// Determine whether a declaration is acceptable to name lookup.; ///; /// This routine determines whether the declaration D is acceptable in the; /// current lookup context, taking into account the current template; /// instantiation stack. During template instantiation, a declaration is; /// acceptable if it is acceptable from a module containing any entity on the; /// template instantiation path (by instantiating a template, you allow it to; /// see the declarations that your module can see, including those later on in; /// your module).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:81,rout,routine,81,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['rout'],['routine']
Integrability,/// Determine whether a given function template has a simple explicit specifier; /// or a non-value-dependent explicit-specification that evaluates to true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:100,depend,dependent,100,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['depend'],['dependent']
Integrability,/// Determine whether a substitution into this declaration would occur as; /// part of a substitution into a dependent local scope. Such a substitution; /// transitively substitutes into all constructs nested within this; /// declaration.; ///; /// This recognizes non-defining declarations as well as members of local; /// classes and lambdas:; /// \code; /// template<typename T> void foo() { void bar(); }; /// template<typename T> void foo2() { class ABC { void bar(); }; }; /// template<typename T> inline int x = [](){ return 0; }();; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:109,depend,dependent,109,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['depend'],['dependent']
Integrability,"/// Determine whether any of the given template arguments are dependent.; ///; /// The converted arguments should be supplied when known; whether an; /// argument is dependent can depend on the conversions performed on it; /// (for example, a 'const int' passed as a template argument might be; /// dependent if the parameter is a reference but non-dependent if the; /// parameter is an int).; ///; /// Note that the \p Args parameter is unused: this is intentional, to remind; /// the caller that they need to pass in the converted arguments, not the; /// specified arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:62,depend,dependent,62,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,5,['depend'],"['depend', 'dependent']"
Integrability,/// Determine whether no result was found because we could not; /// search into dependent base classes of the current instantiation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:80,depend,dependent,80,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['depend'],['dependent']
Integrability,"/// Determine whether one partial specialization, P1, is at least as; /// specialized than another, P2.; ///; /// \tparam TemplateLikeDecl The kind of P2, which must be a; /// TemplateDecl or {Class,Var}TemplatePartialSpecializationDecl.; /// \param T1 The injected-class-name of P1 (faked for a variable template).; /// \param T2 The injected-class-name of P2 (faked for a variable template).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:257,inject,injected-class-name,257,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,2,['inject'],['injected-class-name']
Integrability,"/// Determine whether overloading is allowed for a new function; /// declaration considering prior declarations of the same name.; ///; /// This routine determines whether overloading is possible, not; /// whether a new declaration actually overloads a previous one.; /// It will return true in C++ (where overloads are alway permitted); /// or, as a C extension, when either the new declaration or a; /// previous one is declared with the 'overloadable' attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:145,rout,routine,145,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['rout'],['routine']
Integrability,/// Determine whether the Category is derived from external class interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:66,interface,interface,66,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,1,['interface'],['interface']
Integrability,/// Determine whether the allow-contract flag is set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:32,contract,contract,32,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['contract'],['contract']
Integrability,"/// Determine whether the consumer will be interested in seeing; /// this declaration (via HandleTopLevelDecl).; ///; /// This routine should return true for anything that might affect; /// code generation, e.g., inline function definitions, Objective-C; /// declarations with metadata, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:127,rout,routine,127,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['rout'],['routine']
Integrability,"/// Determine whether the declaration that will be produced from; /// this declaration will be a function.; ///; /// A declaration can declare a function even if the declarator itself; /// isn't a function declarator, if the type specifier refers to a function; /// type. This routine checks for both cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h:277,rout,routine,277,interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,1,['rout'],['routine']
Integrability,"/// Determine whether the given New declaration is an overload of the; /// declarations in Old. This routine returns Ovl_Match or Ovl_NonFunction if; /// New and Old cannot be overloaded, e.g., if New has the same signature as; /// some function in Old (C++ 1.3.10) or if the Old declarations aren't; /// functions (or function templates) at all. When it does return Ovl_Match or; /// Ovl_NonFunction, MatchedDecl will point to the decl that New cannot be; /// overloaded with. This decl may be a UsingShadowDecl on top of the underlying; /// declaration.; ///; /// Example: Given the following input:; ///; /// void f(int, float); // #1; /// void f(int, int); // #2; /// int f(int, int); // #3; ///; /// When we process #1, there is no previous declaration of ""f"", so IsOverload; /// will not be used.; ///; /// When we process #2, Old contains only the FunctionDecl for #1. By comparing; /// the parameter types, we see that #1 and #2 are overloaded (since they have; /// different signatures), so this routine returns Ovl_Overload; MatchedDecl is; /// unchanged.; ///; /// When we process #3, Old is an overload set containing #1 and #2. We compare; /// the signatures of #3 to #1 (they're overloaded, so we do nothing) and then; /// #3 to #2. Since the signatures of #3 and #2 are identical (return types of; /// functions are not part of the signature), IsOverload returns Ovl_Match and; /// MatchedDecl will be set to point to the FunctionDecl for #2.; ///; /// 'NewIsUsingShadowDecl' indicates that 'New' is being introduced into a class; /// by a using declaration. The rules for whether to hide shadow declarations; /// ignore some properties which otherwise figure into a function template's; /// signature.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:101,rout,routine,101,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['rout'],['routine']
Integrability,"/// Determine whether the given call argument should be dropped, e.g.,; /// because it is a default argument.; ///; /// Subclasses can provide an alternative implementation of this routine to; /// determine which kinds of call arguments get dropped. By default,; /// CXXDefaultArgument nodes are dropped (prior to transformation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:181,rout,routine,181,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,"/// Determine whether the given class is a base class of the given; /// class, including looking at dependent bases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:100,depend,dependent,100,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"/// Determine whether the given context is dependent on template parameters at; /// level \p Level or below.; ///; /// Sometimes we only substitute an inner set of template arguments and leave; /// the outer templates alone. In such cases, contexts dependent only on the; /// outer levels are not effectively dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:43,depend,dependent,43,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,3,['depend'],['dependent']
Integrability,"/// Determine whether the given declarator contains any unexpanded; /// parameter packs.; ///; /// This routine is used by the parser to disambiguate function declarators; /// with an ellipsis prior to the ')', e.g.,; ///; /// \code; /// void f(T...);; /// \endcode; ///; /// To determine whether we have an (unnamed) function parameter pack or; /// a variadic function.; ///; /// \returns true if the declarator contains any unexpanded parameter packs,; /// false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:104,rout,routine,104,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['rout'],['routine']
Integrability,"/// Determine whether the given template parameter lists are; /// equivalent.; ///; /// \param New The new template parameter list, typically written in the; /// source code as part of a new template declaration.; ///; /// \param Old The old template parameter list, typically found via; /// name lookup of the template declared with this template parameter; /// list.; ///; /// \param Complain If true, this routine will produce a diagnostic if; /// the template parameter lists are not equivalent.; ///; /// \param Kind describes how we are to match the template parameter lists.; ///; /// \param TemplateArgLoc If this source location is valid, then we; /// are actually checking the template parameter list of a template; /// argument (New) against the template parameter list of its; /// corresponding template template parameter (Old). We produce; /// slightly different diagnostics in this scenario.; ///; /// \returns True if the template parameter lists are equal, false; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:409,rout,routine,409,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['rout'],['routine']
Integrability,"/// Determine whether the given type T is a ""bridgable"" Objective-C type,; /// which is either an Objective-C object pointer type or an",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:45,bridg,bridgable,45,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['bridg'],['bridgable']
Integrability,"/// Determine whether the given type T is a ""bridgeable"" C type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:45,bridg,bridgeable,45,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['bridg'],['bridgeable']
Integrability,"/// Determine whether the given type \p T has already been; /// transformed.; ///; /// For the purposes of template instantiation, a type has already been; /// transformed if it is NULL or if it is not dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:202,depend,dependent,202,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['depend'],['dependent']
Integrability,"/// Determine whether the given type \p T has already been; /// transformed.; ///; /// For the purposes of type reconstruction, a type has already been; /// transformed if it is NULL or if it is not dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:199,depend,dependent,199,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"/// Determine whether the given type \p T has already been; /// transformed.; ///; /// Subclasses can provide an alternative implementation of this routine; /// to short-circuit evaluation when it is known that a given type will; /// not change. For example, template instantiation need not traverse; /// non-dependent types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:148,rout,routine,148,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,"['depend', 'rout']","['dependent', 'routine']"
Integrability,"/// Determine whether the given type can have a nullability; /// specifier applied to it, i.e., if it is any kind of pointer type.; ///; /// \param ResultIfUnknown The value to return if we don't yet know whether; /// this type can have nullability because it is dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:263,depend,dependent,263,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['depend'],['dependent']
Integrability,"/// Determine whether the next set of tokens contains a type-id.; ///; /// The context parameter states what context we're parsing right; /// now, which affects how this routine copes with the token; /// following the type-id. If the context is TypeIdInParens, we have; /// already parsed the '(' and we will cease lookahead when we hit; /// the corresponding ')'. If the context is; /// TypeIdAsTemplateArgument, we've already parsed the '<' or ','; /// before this template argument, and will cease lookahead when we; /// hit a '>', '>>' (in C++0x), or ','; or, in C++0x, an ellipsis immediately; /// preceding such. Returns true for a type-id and false for an expression.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; ///; /// type-id:; /// type-specifier-seq abstract-declarator[opt]; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:170,rout,routine,170,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['rout'],['routine']
Integrability,/// Determine whether the no signed wrap flag is set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:36,wrap,wrap,36,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['wrap'],['wrap']
Integrability,/// Determine whether the no unsigned wrap flag is set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:38,wrap,wrap,38,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['wrap'],['wrap']
Integrability,"/// Determine whether the parser is currently referring to a an; /// Objective-C message send, using a simplified heuristic to avoid overhead.; ///; /// This routine will only return true for a subset of valid message-send; /// expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:81,message,message,81,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,3,"['message', 'rout']","['message', 'message-send', 'routine']"
Integrability,"/// Determine whether the use of this declaration is valid, and; /// emit any corresponding diagnostics.; ///; /// This routine diagnoses various problems with referencing; /// declarations that can occur when using a declaration. For example,; /// it might warn if a deprecated or unavailable declaration is being; /// used, or produce an error (and return true) if a C++0x deleted; /// function is being used.; ///; /// \returns true if there was an error (this declaration cannot be; /// referenced), false otherwise.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:120,rout,routine,120,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['rout'],['routine']
Integrability,"/// Determine whether there is a template argument to be used for; /// deduction.; ///; /// This routine ""expands"" argument packs in-place, overriding its input; /// parameters so that \c Args[ArgIdx] will be the available template argument.; ///; /// \returns true if there is another template argument (which will be at; /// \c Args[ArgIdx]), false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:97,rout,routine,97,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['rout'],['routine']
Integrability,"/// Determine whether this class has a member with the given name, possibly; /// in a non-dependent base class.; ///; /// No check for ambiguity is performed, so this should never be used when; /// implementing language semantics, but it may be appropriate for warnings,; /// static analysis, or similar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:90,depend,dependent,90,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['depend'],['dependent']
Integrability,/// Determine whether this class has any dependent base classes which; /// are not the current instantiation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:41,depend,dependent,41,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['depend'],['dependent']
Integrability,"/// Determine whether this class is derived from the class \p Base.; ///; /// This routine only determines whether this class is derived from \p Base,; /// but does not account for factors that may make a Derived -> Base class; /// ill-formed, such as private/protected inheritance or multiple, ambiguous; /// base class subobjects.; ///; /// \param Base the base class we are searching for.; ///; /// \returns true if this class is derived from Base, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:83,rout,routine,83,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['rout'],['routine']
Integrability,"/// Determine whether this class is derived from the type \p Base.; ///; /// This routine only determines whether this class is derived from \p Base,; /// but does not account for factors that may make a Derived -> Base class; /// ill-formed, such as private/protected inheritance or multiple, ambiguous; /// base class subobjects.; ///; /// \param Base the base class we are searching for.; ///; /// \param Paths will contain the paths taken from the current class to the; /// given \p Base class.; ///; /// \returns true if this class is derived from \p Base, false otherwise.; ///; /// \todo add a separate parameter to configure IsDerivedFrom, rather than; /// tangling input and output in \p Paths",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:82,rout,routine,82,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['rout'],['routine']
Integrability,"/// Determine whether this class is virtually derived from; /// the class \p Base.; ///; /// This routine only determines whether this class is virtually; /// derived from \p Base, but does not account for factors that may; /// make a Derived -> Base class ill-formed, such as; /// private/protected inheritance or multiple, ambiguous base class; /// subobjects.; ///; /// \param Base the base class we are searching for.; ///; /// \returns true if this class is virtually derived from Base,; /// false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:98,rout,routine,98,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['rout'],['routine']
Integrability,"/// Determine whether this declaration is marked 'deprecated'.; ///; /// \param Message If non-NULL and the declaration is deprecated,; /// this will be set to the message describing why the declaration; /// was deprecated (which may be empty).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:80,Message,Message,80,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,2,"['Message', 'message']","['Message', 'message']"
Integrability,"/// Determine whether this declaration is marked 'unavailable'.; ///; /// \param Message If non-NULL and the declaration is unavailable,; /// this will be set to the message describing why the declaration; /// was made unavailable (which may be empty).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:81,Message,Message,81,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,2,"['Message', 'message']","['Message', 'message']"
Integrability,"/// Determine whether this dependent class is a current instantiation,; /// when viewed from within the given context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:27,depend,dependent,27,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['depend'],['dependent']
Integrability,"/// Determine whether this expression is a default function argument.; ///; /// Default arguments are implicitly generated in the abstract syntax tree; /// by semantic analysis for function calls, object constructions, etc. in; /// C++. Default arguments are represented by \c CXXDefaultArgExpr nodes;; /// this routine also looks through any implicit casts to determine whether; /// the expression is a default argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:312,rout,routine,312,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['rout'],['routine']
Integrability,"/// Determine whether this file is intended to be safe from; /// multiple inclusions, e.g., it has \#pragma once or a controlling; /// macro.; ///; /// This routine does not consider the effect of \#import",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:157,rout,routine,157,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['rout'],['routine']
Integrability,"/// Determine whether this function type has a non-throwing exception; /// specification. If this depends on template arguments, returns; /// \c ResultIfDependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:98,depend,depends,98,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['depend'],['depends']
Integrability,/// Determine whether this is an class message to either a; /// specified class or to super.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:39,message,message,39,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,1,['message'],['message']
Integrability,/// Determine whether this is an instance message to either a; /// computed object or to super.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:42,message,message,42,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,1,['message'],['message']
Integrability,"/// Determine whether this lambda expression was known to be dependent; /// at the time it was created, even if its context does not appear to be; /// dependent.; ///; /// This flag is a workaround for an issue with parsing, where default; /// arguments are parsed before their enclosing function declarations have; /// been created. This means that any lambda expressions within those; /// default arguments will have as their DeclContext the context enclosing; /// the function declaration, which may be non-dependent even when the; /// function declaration itself is dependent. This flag indicates when we; /// know that the lambda is dependent despite that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:61,depend,dependent,61,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,5,['depend'],['dependent']
Integrability,/// Determine whether this method has a result type that is related; /// to the message receiver's type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:80,message,message,80,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['message'],['message']
Integrability,/// Determine whether this protocol has a definition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:27,protocol,protocol,27,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['protocol'],['protocol']
Integrability,/// Determine whether this specifier is known to correspond to an explicit; /// declaration. Returns false if the specifier is absent or has an; /// expression that is value-dependent or evaluates to false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:174,depend,dependent,174,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['depend'],['dependent']
Integrability,"/// Determine whether this type is an instantiation-dependent type,; /// meaning that the type involves a template parameter (even if the; /// definition does not actually depend on the type substituted for that; /// template parameter).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:52,depend,dependent,52,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,2,['depend'],"['depend', 'dependent']"
Integrability,"/// Determine whether this type is an integral type.; ///; /// This routine determines whether the given type is an integral type per; /// C++ [basic.fundamental]p7. Although the C standard does not define the; /// term ""integral type"", it has a similar term ""integer type"", and in C++; /// the two terms are equivalent. However, C's ""integer type"" includes; /// enumeration types, while C++'s ""integer type"" does not. The \c ASTContext; /// parameter is used to determine whether we should be following the C or; /// C++ rules when determining whether this type is an integral/integer type.; ///; /// For cases where C permits ""an integer type"" and C++ permits ""an integral; /// type"", use this routine.; ///; /// For cases where C permits ""an integer type"" and C++ permits ""an integral; /// or enumeration type"", use \c isIntegralOrEnumerationType() instead.; ///; /// \param Ctx The context in which this type occurs.; ///; /// \returns true if the type is considered an integral type, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:68,rout,routine,68,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,2,['rout'],['routine']
Integrability,/// Determine whether we are currently at the start of an Objective-C; /// class message that appears to be missing the open bracket '['.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:81,message,message,81,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['message'],['message']
Integrability,"/// Determine whether we should expand a pack expansion with the; /// given set of parameter packs into separate arguments by repeatedly; /// transforming the pattern.; ///; /// By default, the transformer never tries to expand pack expansions.; /// Subclasses can override this routine to provide different behavior.; ///; /// \param EllipsisLoc The location of the ellipsis that identifies the; /// pack expansion.; ///; /// \param PatternRange The source range that covers the entire pattern of; /// the pack expansion.; ///; /// \param Unexpanded The set of unexpanded parameter packs within the; /// pattern.; ///; /// \param ShouldExpand Will be set to \c true if the transformer should; /// expand the corresponding pack expansions into separate arguments. When; /// set, \c NumExpansions must also be set.; ///; /// \param RetainExpansion Whether the caller should add an unexpanded; /// pack expansion after all of the expanded arguments. This is used; /// when extending explicitly-specified template argument packs per; /// C++0x [temp.arg.explicit]p9.; ///; /// \param NumExpansions The number of separate arguments that will be in; /// the expanded form of the corresponding pack expansion. This is both an; /// input and an output parameter, which can be set by the caller if the; /// number of expansions is known a priori (e.g., due to a prior substitution); /// and will be set by the callee when the number of expansions is known.; /// The callee must set this value when \c ShouldExpand is \c true; it may; /// set this value in other cases.; ///; /// \returns true if an error occurred (e.g., because the parameter packs; /// are to be instantiated with arguments of different lengths), false; /// otherwise. If false, \c ShouldExpand (and possibly \c NumExpansions); /// must be set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:279,rout,routine,279,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['rout'],['routine']
Integrability,/// Determine which kind of bridge is being performed via this cast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:28,bridg,bridge,28,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,1,['bridg'],['bridge']
Integrability,"/// Determines if a character is likely to be displayed correctly on the; /// terminal. Exact implementation would have to depend on the specific; /// terminal, so we define the semantic that should be suitable for generic case; /// of a terminal capable to output Unicode characters.; ///; /// Printable codepoints are those in the categories L, M, N, P, S and Zs; /// \return true if the character is considered printable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Unicode.h:123,depend,depend,123,interpreter/llvm-project/llvm/include/llvm/Support/Unicode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Unicode.h,1,['depend'],['depend']
Integrability,/// Determines if the given callback holds for all the direct; /// or indirect base classes of this type.; ///; /// The class itself does not count as a base class. This routine; /// returns false if the class has non-computable base classes.; ///; /// \param BaseMatches Callback invoked for each (direct or indirect) base; /// class of this type until a call returns false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:170,rout,routine,170,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['rout'],['routine']
Integrability,/// Determines if this is an ObjC interface type that may accept type; /// parameters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:34,interface,interface,34,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['interface'],['interface']
Integrability,/// Determines if this variable's alignment is dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:47,depend,dependent,47,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['depend'],['dependent']
Integrability,"/// Determines if type B can be substituted for type A. Returns true if we can; /// guarantee that anything that the user will do to an object of type A can; /// also be done to an object of type B. This is trivially true if the two; /// types are the same, or if B is a subclass of A. It becomes more complex; /// in cases where protocols are involved.; ///; /// Object types in Objective-C describe the minimum requirements for an; /// object, rather than providing a complete description of a type. For; /// example, if A is a subclass of B, then B* may refer to an instance of A.; /// The principle of substitutability means that we may use an instance of A; /// anywhere that we may use an instance of B - it will implement all of the; /// ivars of B and all of the methods of B.; ///; /// This substitutability is important when type checking methods, because; /// the implementation may have stricter type definitions than the interface.; /// The interface specifies minimum requirements, but the implementation may; /// have more accurate ones. For example, a method may privately accept; /// instances of B, but only publish that it accepts instances of A. Any; /// object passed to it will be type checked against B, and so will implicitly; /// by a valid A*. Similarly, a method may return a subclass of the class that; /// it is declared as returning.; ///; /// This is most important when considering subclassing. A method in a; /// subclass must accept any object as an argument that its superclass's; /// implementation accepts. It may, however, accept a more general type; /// without breaking substitutability (i.e. you can still use the subclass; /// anywhere that you can use the superclass, but not vice versa). The; /// converse requirement applies to return types: the return type for a; /// subclass method must be a valid object of the kind that the superclass; /// advertises, but it may be specified more accurately. This avoids the need; /// for explicit down-casting by cal",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:330,protocol,protocols,330,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,3,"['interface', 'protocol']","['interface', 'protocols']"
Integrability,"/// Determines the active Scope associated with the given declaration; /// context.; ///; /// This routine maps a declaration context to the active Scope object that; /// represents that declaration context in the parser. It is typically used; /// from ""scope-less"" code (e.g., template instantiation, lazy creation of; /// declarations) that injects a name for name-lookup purposes and, therefore,; /// must update the Scope.; ///; /// \returns The scope corresponding to the given declaraion context, or NULL; /// if no such scope is open.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:99,rout,routine,99,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,2,"['inject', 'rout']","['injects', 'routine']"
Integrability,"/// Determines the name of a token as used within the front end.; ///; /// The name of a token will be an internal name (such as ""l_square""); /// and should not be used as part of diagnostic messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TokenKinds.h:191,message,messages,191,interpreter/llvm-project/clang/include/clang/Basic/TokenKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TokenKinds.h,1,['message'],['messages']
Integrability,"/// Determines the range for the affine non-self-wrapping SCEVAddRecExpr {\p; /// Start,+,\p Step}<nw>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:49,wrap,wrapping,49,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['wrap'],['wrapping']
Integrability,"/// Determines the spelling of simple punctuation tokens like; /// '!' or '%', and returns NULL for literal and annotation tokens.; ///; /// This routine only retrieves the ""simple"" spelling of the token,; /// and will not produce any alternative spellings (e.g., a; /// digraph). For the actual spelling of a given Token, use; /// Preprocessor::getSpelling().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TokenKinds.h:146,rout,routine,146,interpreter/llvm-project/clang/include/clang/Basic/TokenKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TokenKinds.h,1,['rout'],['routine']
Integrability,"/// Determines whether the given declaration is an out-of-scope; /// previous declaration.; ///; /// This routine should be invoked when name lookup has found a; /// previous declaration (PrevDecl) that is not in the scope where a; /// new declaration by the same name is being introduced. If the new; /// declaration occurs in a local scope, previous declarations with; /// linkage may still be considered previous declarations (C99; /// 6.2.2p4-5, C++ [basic.link]p6).; ///; /// \param PrevDecl the previous declaration found by name; /// lookup; ///; /// \param DC the context in which the new declaration is being; /// declared.; ///; /// \returns true if PrevDecl is an out-of-scope previous declaration; /// for a new delcaration with the same name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,rout,routine,106,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['rout'],['routine']
Integrability,"/// Determines whether the name itself is dependent, e.g., because it; /// involves a C++ type that is itself dependent.; ///; /// Note that this does not capture all of the notions of ""dependent name"",; /// because an identifier can be a dependent name if it is used as the; /// callee in a call expression with dependent arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclarationName.h:42,depend,dependent,42,interpreter/llvm-project/clang/include/clang/AST/DeclarationName.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclarationName.h,5,['depend'],['dependent']
Integrability,"/// Determines whether the type of this expression depends on; /// - a template parameter (C++ [temp.dep.expr], which means that its type; /// could change from one template instantiation to the next); /// - or an error; ///; /// For example, the expressions ""x"" and ""x + y"" are type-dependent in; /// the following code, but ""y"" is not type-dependent:; /// @code; /// template<typename T>; /// void add(T x, int y) {; /// x + y;; /// }; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:51,depend,depends,51,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,3,['depend'],"['dependent', 'depends']"
Integrability,"/// Determines whether the value of this expression depends on; /// - a template parameter (C++ [temp.dep.constexpr]); /// - or an error, whose resolution is unknown; ///; /// For example, the array bound of ""Chars"" in the following example is; /// value-dependent.; /// @code; /// template<int Size, char (&Chars)[Size]> struct meta_string;; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:52,depend,depends,52,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,2,['depend'],"['dependent', 'depends']"
Integrability,"/// Determines whether there is a user-defined conversion sequence; /// (C++ [over.ics.user]) that converts expression From to the type; /// ToType. If such a conversion exists, User will contain the; /// user-defined conversion sequence that performs such a conversion; /// and this routine will return true. Otherwise, this routine returns; /// false and User is unspecified.; ///; /// \param AllowExplicit true if the conversion should consider C++0x; /// ""explicit"" conversion functions as well as non-explicit conversion; /// functions (C++0x [class.conv.fct]p2).; ///; /// \param AllowObjCConversionOnExplicit true if the conversion should; /// allow an extra Objective-C pointer conversion on uses of explicit; /// constructors. Requires \c AllowExplicit to also be set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:284,rout,routine,284,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['rout'],['routine']
Integrability,/// Determines whether this context is dependent on a; /// template parameter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:39,depend,dependent,39,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['depend'],['dependent']
Integrability,"/// Determines whether this declaration represents the; /// injected class name.; ///; /// The injected class name in C++ is the name of the class that; /// appears inside the class itself. For example:; ///; /// \code; /// struct C {; /// // C is implicitly declared here as a synonym for the class name.; /// };; ///; /// C::C c; // same as ""C c;""; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:60,inject,injected,60,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,2,['inject'],['injected']
Integrability,/// Determines whether this is a dependent template name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h:33,depend,dependent,33,interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,1,['depend'],['dependent']
Integrability,/// Determines whether this is a template name that somehow; /// depends on a template parameter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h:65,depend,depends,65,interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,1,['depend'],['depends']
