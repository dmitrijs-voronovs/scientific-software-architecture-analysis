quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Usability,"is possible; to position further geometrical structures inside or to divide them further more; (see TGeoVolume::Divide()). The primitive shapes supported by the package are basically the GEANT3; shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; planes. All basic primitives inherits from class TGeoBBox since the bounding box; of a solid is essential for the tracking algorithms. They also implement the; virtual methods defined in the virtual class TGeoShape (point and segment; classification). User-defined primitives can be direcly plugged into the modeler; provided that they override these methods. Composite shapes will be soon supported; by the modeler. In order to build a TGeoCompositeShape, one will have to define; first the primitive components. The object that handle boolean; operations among components is called TGeoBoolCombinator and it has to be; constructed providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:4680,simpl,simple,4680,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['simpl'],['simple']
Usability,"is sense. The fitting method. The fit is performed using the Normal Equations method with Cholesky; decomposition. Why should it be used?. The linear fitter is considerably faster than general non-linear; fitters and doesn't require to set the initial values of parameters. Using the fitter:. 1.Adding the data points:; 1.1 To store or not to store the input data?; - There are 2 options in the constructor - to store or not; store the input data. The advantages of storing the data; are that you'll be able to reset the fitting model without; adding all the points again, and that for very large sets; of points the chisquare is calculated more precisely.; The obvious disadvantage is the amount of memory used to; keep all the points.; - Before you start adding the points, you can change the; store/not store option by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula syntax:; -Additive parts are separated by 2 plus signes ""++""; --for example ""1 ++ x"" - for fitting a straight line; -All standard functions, undrestood by TFormula, can be used; as additive parts; --TMath functions can be used too; -Functions, used as additive parts, shouldn't have any parameters,; even if those parameters are set.; --for example, if normalizing a sum of a gaus(0, 1) and a; gaus(0, 2), don't use the built-in ""gaus"" of TFormula,; because it has parameters, take TMath::Gaus(x, 0, 1) instead.; -Polynomials can be used like ""pol3"", ..""polN""; -If fitting a more than 3-dimensional formula, variables should; be numbered as follows:; -- x[0], x[1], x[2]... For example, to fit ""1 ++ x[0] ++ x[1] ++ x[2] ++ x[3]*x[3]""; 2.2 Setting the formula:; 2.2.1 If fitting a 1-2-3-dimensional",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLinearFitter.html:1669,simpl,simply,1669,root/html528/TLinearFitter.html,https://root.cern,https://root.cern/root/html528/TLinearFitter.html,6,['simpl'],['simply']
Usability,"is the address of a pointer to an object of class; 2362/// classname. The class dictionary must be available (ClassDef; 2363/// in class header).; 2364///; 2365/// Note: See the comments in TBranchElement::SetAddress() for a more; 2366/// detailed discussion of the meaning of the addr parameter.; 2367///; 2368/// This option requires access to the library where the; 2369/// corresponding class is defined. Accessing one single data; 2370/// member in the object implies reading the full object.; 2371///; 2372/// By default the branch buffers are stored in the same file as the Tree.; 2373/// use TBranch::SetFile to specify a different file; 2374///; 2375/// IMPORTANT NOTE about branch names:; 2376///; 2377/// And in general, in case two or more master branches contain subbranches; 2378/// with identical names, one must add a ""."" (dot) character at the end; 2379/// of the master branch name. This will force the name of the subbranches; 2380/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2381/// This situation happens when the top level object; 2382/// has two or more members referencing the same class.; 2383/// For example, if a Tree has two branches B1 and B2 corresponding; 2384/// to objects of the same class MyClass, one can do:; 2385/// ~~~ {.cpp}; 2386/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2387/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 2388/// ~~~; 2389/// if MyClass has 3 members a,b,c, the two instructions above will generate; 2390/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; 2391///; 2392/// bufsize is the buffer size in bytes for this branch; 2393/// The default value is 32000 bytes and should be ok for most cases.; 2394/// You can specify a larger value (e.g. 256000) if your Tree is not split; 2395/// and each entry is large (Megabytes); 2396/// A small value for bufsize is optimum if you intend to access; 2397/// the entries in the Tree randomly and your Tree is in split mode.; 2398///; 2399/// Use splitlevel < 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:94442,simpl,simply,94442,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['simpl'],['simply']
Usability,"is tutorial shows how a histogram can be filled in parallel with a multiprocess approach ;  mt001_fillHistos.CFill histograms in parallel and write them on file ;  mt101_fillNtuples.CFill n-tuples in distinct workers ;  mt102_readNtuplesFillHistosAndFit.CRead n-tuples in distinct workers, fill histograms, merge them and fit ;  mt201_parallelHistoFill.CParallel fill of a histogram ;  mtbb001_fillHistos.CFill histograms in parallel and write them on file ;  mtbb101_fillNtuples.CFill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.CParallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallelMergeTest.C;  pclient.CClient program to test parallel sockets ;  pserv.CServer program to test parallel sockets ;  spy.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:133906,simpl,simple,133906,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"isable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4254 of file RooAbsReal.cxx. ◆ Class(). static TClass * RooAbsReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 548 of file RooAbsReal.h. ◆ clearEvalErrorLog(). void RooAbsReal::clearEvalErrorLog ; (; ). static . Clear the stack of evaluation error messages. ; Definition at line 3542 of file RooAbsReal.cxx. ◆ copyCache(). void RooAbsReal::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value of another RooAbsArg to our cache. ; Warning: This function just copies the cached values of source, it is the callers responsibility to make sure the cache is clean. ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, and RooRealVar.; Definition at line 2997 of file RooAbsReal.cxx. ◆ createChi2() [1/4]. RooAbsReal::createChi2 ; (; RooDataHist & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Create a \( \chi^2 \) variable from a histogra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:78078,clear,clearEvalErrorLog,78078,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['clear'],['clearEvalErrorLog']
Usability,"isable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4330 of file RooAbsReal.cxx. ◆ Class(). static TClass * RooAbsReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 558 of file RooAbsReal.h. ◆ clearEvalErrorLog(). void RooAbsReal::clearEvalErrorLog ; (; ). static . Clear the stack of evaluation error messages. ; Definition at line 3622 of file RooAbsReal.cxx. ◆ copyCache(). void RooAbsReal::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value of another RooAbsArg to our cache. ; Warning: This function just copies the cached values of source, it is the callers responsibility to make sure the cache is clean. ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, and RooRealVar.; Definition at line 3082 of file RooAbsReal.cxx. ◆ createChi2() [1/4]. RooAbsReal::createChi2 ; (; RooDataHist & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Create a \( \chi^2 \) variable from a histogra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:79346,clear,clearEvalErrorLog,79346,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['clear'],['clearEvalErrorLog']
Usability,"ise) ;  ; void setMonitoring (std::shared_ptr< Monitoring > ptrMonitoring);  prepared for monitoring ;  ; virtual void setProgressLimits (double minProgress=0, double maxProgress=100);  ; virtual void startTraining ();  ; size_t testRepetitions () const;  how often is the test data tested ;  ; bool useMultithreading () const;  is multithreading turned on? ;  . Public Attributes; std::vector< double > m_ams;  ; double m_cutValue;  ; std::string m_fileNameNetConfig;  ; std::string m_fileNameResult;  ; std::vector< double > m_input;  ; std::vector< double > m_output;  ; std::vector< Pattern > * m_pResultPatternContainer;  ; size_t m_scaleToNumEvents;  ; std::vector< double > m_significances;  ; double m_sumOfBkgWeights;  ; double m_sumOfSigWeights;  ; std::vector< double > m_targets;  ; std::vector< double > m_weights;  ;  Public Attributes inherited from TMVA::DNN::Settings; size_t count_dE;  ; size_t count_E;  ; size_t count_mb_dE;  ; size_t count_mb_E;  ; double fLearningRate;  ; MinimizerType fMinimizerType;  ; double fMomentum;  ; int fRepetitions;  ; size_t m_batchSize;  mini-batch size ;  ; size_t m_convergenceCount;  ; size_t m_convergenceSteps;  number of steps without improvement to consider the DNN to have converged ;  ; std::vector< double > m_dropOut;  ; double m_dropRepetitions;  ; double m_factorWeightDecay;  ; size_t m_maxConvergenceCount;  ; double m_maxProgress;  current limits for the progress bar ;  ; double m_minError;  ; double m_minProgress;  current limits for the progress bar ;  ; EnumRegularization m_regularization;  ; size_t m_testRepetitions;  ; Timer m_timer;  timer for monitoring ;  . Additional Inherited Members;  Protected Attributes inherited from TMVA::DNN::Settings; std::shared_ptr< Monitoring > fMonitoring;  ; bool m_useMultithreading;  . #include <TMVA/NeuralNet.h>. Inheritance diagram for TMVA::DNN::ClassificationSettings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:5912,progress bar,progress bar,5912,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,2,['progress bar'],['progress bar']
Usability,"iseActions(TClass *oldClass, Int_t version) overrideReturn the set of action necessary to stream in this collection member-wise coming from the old value...Definition TGenCollectionProxy.cxx:1747; TGenCollectionProxy::fReadMemberWiseTObjArray * fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read)Definition TGenCollectionProxy.h:291; TGenCollectionProxy::DeleteItemvirtual void DeleteItem(Bool_t force, void *ptr) constCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:1350; TGenCollectionProxy::GetCollectionClassTClass * GetCollectionClass() const overrideReturn a pointer to the TClass representing the container.Definition TGenCollectionProxy.cxx:985; TGenCollectionProxy::fStagedStaged_t fStagedOptimization: Keep staged array once they were created.Definition TGenCollectionProxy.h:319; TGenCollectionProxy::fSizeMethod fSizeContainer accessors: size of container.Definition TGenCollectionProxy.h:302; TGenCollectionProxy::fClearMethod fClearMethod cache for container accessors: clear container.Definition TGenCollectionProxy.h:301; TGenCollectionProxy::fFeedFeedfunc_t fFeedContainer accessors: block feed.Definition TGenCollectionProxy.h:308; TGenCollectionProxy::GetFunctionCreateIteratorsCreateIterators_t GetFunctionCreateIterators(Bool_t read=kTRUE) overrideSee typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena); begin_...Definition TGenCollectionProxy.cxx:1607; TGenCollectionProxy::fValDiffint fValDiffOffset between two consecutive value_types (memory layout).Definition TGenCollectionProxy.h:316; TGenCollectionProxy::ReadBuffervirtual void ReadBuffer(TBuffer &b, void *obj)Definition TGenCollectionProxy.cxx:1419; TGenCollectionProxy::fProxyKeptProxies_t fProxyKeptOptimization: Keep proxies once they were created.Definition TGenCollectionProxy.h:318; TGenCollectionProxy::SizeofUInt_t Sizeof() const overrideReturn the sizeof the collection object.Definition TGenCollectionProxy.cxx:1014; TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:85503,clear,clear,85503,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['clear'],['clear']
Usability,"ision of two histograms ;  TwoHistoFit2D.C Example to fit two histograms at the same time ;  vectorizedFit.C use it for fitting an histogram ;  ► fitsio;  FITS_tutorial1.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial2.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial3.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial4.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial5.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ;  FITS_tutorial7.COpen a FITS file that contains a catalog of astronomical objects and dump some of its columns ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:106841,simpl,simple,106841,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,['simpl'],['simple']
Usability,"isionTree(); destructor. void SetParentTreeInNodes(TMVA::Node* n = __null); descend a tree to find all its leaf nodes, fill max depth reached in the; tree at the same time. TMVA::DecisionTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = 262656); re-create a new tree (decision tree or search tree) from XML. UInt_t BuildTree(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node = __null); building the decision tree by recursively calling the splitting of; one (root-) node into two daughter nodes (returns the number of nodes). void FillTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTree.html:10564,clear,clear,10564,root/html602/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTree.html,1,['clear'],['clear']
Usability,"isionTree(); destructor. void SetParentTreeInNodes(TMVA::Node* n = __null); descend a tree to find all its leaf nodes, fill max depth reached in the; tree at the same time. TMVA::DecisionTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); re-create a new tree (decision tree or search tree) from XML. UInt_t BuildTree(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node = __null); building the decision tree by recursively calling the splitting of; one (root-) node into two daughter nodes (returns the number of nodes). void FillTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__DecisionTree.html:10572,clear,clear,10572,root/html604/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html,1,['clear'],['clear']
Usability,"ist of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; List of all members ; TGVProgressBar Class Reference. . Definition at line 122 of file TGProgressBar.h. Public Member Functions;  TGVProgressBar (const TGWindow *p, EBarType type, UInt_t h);  Simple constructor allow you to create either a standard progress bar, or a more fancy progress bar (fancy means: double sized border, white background and a bit wider to allow for text to be printed in the bar. ;  ;  TGVProgressBar (const TGWindow *p=nullptr, UInt_t w=kProgressBarTextWidth, UInt_t h=4, Pixel_t back=GetWhitePixel(), Pixel_t barcolor=GetDefaultSelectedBackground(), GContext_t norm=GetDefaultGC()(), FontStruct_t font=GetDefaultFontStruct(), UInt_t options=kDoubleBorder|kSunkenFrame);  Constructor. ;  ;  ~TGVProgressBar () override;  ; TGDimension GetDefaultSize () const override;  std::cout << fWidth << ""x"" << fHeight << std::endl; ;  ; TClass * IsA () const override;  ; void Percent (Bool_t) override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a vertical progress bar as a C++ statement(s) on output stream out. ;  ; void ShowPos (Bool_t) override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGProgressBar;  TGProgressBar (const TGWindow *p, UInt_t w, UInt_t h, Pixel_t back=GetWhitePixel(), Pixel_t barcolor=GetDefaultSelectedBackground(), GContext_t norm=GetDefaultGC()(), FontStruct_t font=GetDefaultFontStruct(), UInt_t options=kDoubleBorder|kSunkenFrame);  Create progress bar. ;  ;  ~TGProgressBar () override;  ; virtual void Format (const char *format=""%.2f"");  Set format for displaying a value. ;  ; Pixel_t GetBarColor () const;  ; EBarType GetBarType () const;  ; EFillType GetFillType () const;  ; FontStruct_t GetFontStruct () const;  ; TString GetFormat () const;  ; Float_t G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGVProgressBar.html:1244,progress bar,progress bar,1244,doc/master/classTGVProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGVProgressBar.html,1,['progress bar'],['progress bar']
Usability,"ist< T > IL);  ; template<typename V , unsigned M, typename = std::enable_if<std::is_convertible<V, bool>::value>> ; RVecN operator[] (const RVecN< V, M > &conds) const;  ; reference operator[] (size_type idx);  ; const_reference operator[] (size_type idx) const;  ;  Public Member Functions inherited from ROOT::Detail::VecOps::RVecImpl< T >;  RVecImpl (const RVecImpl &)=delete;  ;  ~RVecImpl ();  ; template<typename in_iter , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type> ; void append (in_iter in_start, in_iter in_end);  Add the specified range to the end of the SmallVector. ;  ; void append (size_type NumInputs, const T &Elt);  Append NumInputs copies of Elt to the end. ;  ; void append (std::initializer_list< T > IL);  ; template<typename in_iter , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type> ; void assign (in_iter in_start, in_iter in_end);  ; void assign (size_type NumElts, const T &Elt);  ; void assign (std::initializer_list< T > IL);  ; void clear ();  ; template<typename... ArgTypes> ; reference emplace_back (ArgTypes &&...Args);  ; iterator erase (const_iterator CI);  ; iterator erase (const_iterator CS, const_iterator CE);  ; iterator insert (iterator I, const T &Elt);  ; template<typename ItTy , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<ItTy>::iterator_category, std::input_iterator_tag>::value>::type> ; iterator insert (iterator I, ItTy From, ItTy To);  ; iterator insert (iterator I, size_type NumToInsert, const T &Elt);  ; void insert (iterator I, std::initializer_list< T > IL);  ; iterator insert (iterator I, T &&Elt);  ; RVecImpl & operator= (const RVecImpl &RHS);  ; RVecImpl & operator= (RVecImpl &&RHS);  ; void pop_back_n (size_type NumItems);  ; T pop_back_val ();  ; void reserve (size_type N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVecN.html:4110,clear,clear,4110,doc/master/classROOT_1_1VecOps_1_1RVecN.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVecN.html,1,['clear'],['clear']
Usability,"it package, which remains one of the fastest tools for neural networks studies.; 5.12.2 The MLP; The multilayer perceptron is a simple feed-forward network with the following structure showed on the left. It is made of neurons characterized by a bias and weighted links in between - let’s call those links synapses. The input neurons receive the inputs, normalize them and forward them to the first hidden layer. Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers.; Such a structure is very useful because of two theorems:; 1- A linear combination of sigmoids can approximate any continuous function.; 2- Trained with output=1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X.; 5.12.3 Learning Methods; The aim of all learning methods is to minimize the total error on a set of weighted examples. The error is defined as the sum in quadrate, divided by two, of the error on each individual output neuron. In all methods implemented in this library, one needs to compute the first derivative of that error with respect to the weights. Exploiting the well-known properties of the derivative, one can express this derivative as the product of the local partial derivative by the weighted sum of the outputs derivatives (for a neuron) or as the product of the input value with the local partial derivative of the output neuron (for a synapse). This computation is called “back-propagation of the errors”. Six learning methods are implemented.; 5.12.3.1 Stochastic Minimization; This is the most trivial learning method. The Robbins-Monro stochastic approximation is applied to multilayer perceptrons. The weights are updated after each example according to the formula:; \[; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); \]; with:; \[; \Delta w_{",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:231870,learn,learning,231870,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['learn'],['learning']
Usability,it tutorial macro #903 ;  rf903_numintcache.py;  ► roostats;  CreateExampleFile.C;  FourBinInstructional.C This example is a generalization of the on/off problem ;  HybridInstructional.C Example demonstrating usage of HybridCalcultor ;  HybridOriginalDemo.C Example on how to use the HybridCalculatorOriginal class ;  HybridStandardForm.C A hypothesis testing example based on number counting with background uncertainty ;  IntervalExamples.C Example showing confidence intervals with four techniques ;  JeffreysPriorDemo.C tutorial demonstrating and validates the RooJeffreysPrior class ;  ModelInspector.CRooStats Model Inspector ;  MultivariateGaussianTest.C Comparison of MCMC and PLC in a multi-variate gaussian problem ;  NuMuToNuE_Oscillation.cxx;  NuMuToNuE_Oscillation.h;  OneSidedFrequentistUpperLimitWithBands.C OneSidedFrequentistUpperLimitWithBands ;  rs101_limitexample.C 'Limit Example' RooStats tutorial macro #101 This tutorial shows an example of creating a simple model for a number counting experiment with uncertainty on both the background rate and signal efficiency ;  rs102_hypotestwithshapes.C rs102_hypotestwithshapes for RooStats project ;  rs301_splot.C SPlot tutorial ;  rs401c_FeldmanCousins.C Produces an interval on the mean signal in a number counting experiment with known background using the Feldman-Cousins technique ;  rs401d_FeldmanCousins.C 'Neutrino Oscillation Example from Feldman & Cousins' ;  rs601_HLFactoryexample.C 'High Level Factory Example' RooStats tutorial macro #601 ;  rs602_HLFactoryCombinationexample.C 'High Level Factory Example' RooStats tutorial macro #602 ;  rs603_HLFactoryElaborateExample.C 'High Level Factory Example' RooStats tutorial macro #602 ;  rs701_BayesianCalculator.C 'Bayesian Calculator' RooStats tutorial macro #701 ;  rs801_HypoTestInverterOriginal.C 'Hypothesis Test Inversion' RooStats tutorial macro #801 ;  rs_bernsteinCorrection.C 'Bernstein Correction' RooStats tutorial macro ;  rs_numberCountingCombination.C 'Numb,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:159485,simpl,simple,159485,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"it).Definition TGMenu.cxx:1782; TGPopupMenu::DisableEntryvirtual void DisableEntry(Int_t id)Disable entry (disabled entries appear in a sunken relieve).Definition TGMenu.cxx:1724; TGPopupMenu::UnCheckEntryvirtual void UnCheckEntry(Int_t id)Uncheck menu entry (i.e. remove check mark).Definition TGMenu.cxx:1807; TGPopupMenu::Associatevirtual void Associate(const TGWindow *w)Definition TGMenu.h:206; TGPopupMenu::AddSeparatorvirtual void AddSeparator(TGMenuEntry *before=nullptr)Add a menu separator to the menu.Definition TGMenu.cxx:1060; TGPopupMenu::AddEntryvirtual void AddEntry(TGHotString *s, Int_t id, void *ud=nullptr, const TGPicture *p=nullptr, TGMenuEntry *before=nullptr)Add a menu entry.Definition TGMenu.cxx:990; TGProgressBar::SetPositionvoid SetPosition(Float_t pos)Set progress position between [min,max].Definition TGProgressBar.cxx:92; TGProgressBar::SetFillTypevoid SetFillType(EFillType type)Set fill type.Definition TGProgressBar.cxx:136; TGProgressBar::SetBarColorvirtual void SetBarColor(Pixel_t color)Set progress bar color.Definition TGProgressBar.cxx:156; TGProgressBar::kBlockFill@ kBlockFillDefinition TGProgressBar.h:23; TGSelectBoxThis class represent a specialized expression editor for TTVLVEntry 'true name' and 'alias' data memb...Definition TTVLVContainer.h:157; TGSelectBox::EditedEntryTTVLVEntry * EditedEntry()Definition TTVLVContainer.h:181; TGSelectBox::InsertTextvoid InsertText(const char *text)Insert text in text entry.Definition TTVLVContainer.cxx:825; TGSelectBox::GrabPointervoid GrabPointer()Just focus the cursor inside.Definition TTVLVContainer.cxx:755; TGSelectBox::SetLabelvoid SetLabel(const char *title)Set label of selection box.Definition TTVLVContainer.cxx:769; TGSelectBox::SetEntryvoid SetEntry(TTVLVEntry *entry)Connect one entry.Definition TTVLVContainer.cxx:814; TGSelectBox::GetInstancestatic TGSelectBox * GetInstance()Return the pointer to the instantiated singleton.Definition TTVLVContainer.cxx:747; TGStatusBarProvides a StatusBar w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:127437,progress bar,progress bar,127437,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,it;  GaussFunction.h;  MinimizerTypes.h;  testFitPerf.cxx;  ► genvector;  vectorOperation.cxx;  ► mandelbrot;  main.cpp;  main.h;  mandel.cpp;  mandel.h;  ► matrix;  main.cpp;  ► polarcoord;  main.cpp;  ► smatrix;  matrix_op_vec.h;  matrix_util.h;  testKalman.cxx;  testOperations.cxx;  TestTimer.h;  tsc.h;  ► include;  ► Vc;  ► avx;  casts.h;  const.h;  const_data.h;  debug.h;  helperimpl.h;  intrinsics.h;  limits.h;  macros.h;  mask.h;  math.h;  shuffle.h;  sorthelper.h;  types.h;  undomacros.h;  vector.h;  vectorhelper.h;  writemaskedvector.h;  ► common;  aliasingentryhelper.h;  bitscanintrinsics.h;  deinterleave.h;  exponential.h;  fix_clang_emmintrin.h;  iif.h;  interleavedmemory.h;  logarithm.h;  macros.h;  memory.h;  memorybase.h;  memoryfwd.h;  operand.h;  operators.h;  storage.h;  support.h;  trigonometric.h;  types.h;  undomacros.h;  vectortuple.h;  windows_fix_intrin.h;  ► internal;  namespace.h;  ► scalar;  helperimpl.h;  limits.h;  macros.h;  mask.h;  math.h;  types.h;  undomacros.h;  vector.h;  writemaskedvector.h;  ► sse;  casts.h;  const.h;  const_data.h;  debug.h;  helperimpl.h;  intrinsics.h;  limits.h;  macros.h;  mask.h;  math.h;  shuffle.h;  types.h;  undomacros.h;  vector.h;  vectorhelper.h;  cpuid.h;  global.h;  support.h;  vector.h;  version.h;  ► src;  avx_sorthelper.cpp;  const.cpp;  cpuid.cpp;  support.cpp;  trigonometric.cpp;  ► tests;  arithmetics.cpp;  casts.cpp;  const.h;  convert-sincos-reference.cpp;  deinterleave.cpp;  expandandmerge.cpp;  gather.cpp;  implicit_type_conversion.cpp;  implicit_type_conversion_failures.cpp;  linkTest0.cpp;  linkTest1.cpp;  linkTestLib0.cpp;  linkTestLib1.cpp;  linkTestLib2.cpp;  linkTestLib3.cpp;  load.cpp;  mask.cpp;  math.cpp;  memory.cpp;  scalaraccess.cpp;  scatter.cpp;  sse_blend.cpp;  stlcontainer.cpp;  store.cpp;  supportfunctions.cpp;  swizzles.cpp;  ulp.h;  unittest.h;  utils.cpp;  vectormemoryhelper.h;  makeTest.py;  ► vdt;  ► include;  ► vdt;  asin.h;  atan.h;  atan2.h;  cos.h;  exp.h;  inv.h;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:58768,undo,undomacros,58768,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['undo'],['undomacros']
Usability,"itance tree; For an example of obj->Inspect(), see “Inspecting Objects”.; 15.1.2 Collections; To store an object in a ROOT collection, it must be a descendent of TObject. This is convenient if you want to store objects of different classes in the same collection and execute the method of the same name on all members of the collection. For example, the list of graphics primitives are in a ROOT collection called TList. When the canvas is drawn, the Paint method is executed on the entire collection. Each member may be a different class, and if the Paint method is not implemented, TObject::Paint will be executed.; 15.1.3 Input/Output; The TObject::Write method is the interface to the ROOT I/O system. It streams the object into a buffer using the Streamer method. It supports cycle numbers and automatic schema evolution. See “Input/Output”.; 15.1.4 Paint/Draw; These graphics methods are defaults; their implementation in TObject does not use the graphics subsystem. The TObject::Draw method is simply a call to AppendPad. The Paint method is empty. The default is provided so that one can call Paint in a collection. The method GetDrawOption returns the draw option that was used when the object was drawn on the canvas. This is especially relevant with histograms and graphs.; 15.1.5 Clone/DrawClone; Two useful methods are Clone and DrawClone. The Clone method takes a snapshot of the object with the Streamer and creates a new object. The DrawClone method does the same thing and in addition draws the clone.; 15.1.6 Browse; This method is called if the object is browse-able and is to be displayed in the object browser. For example the TTree implementation of Browse, calls the Browse method for each branch. The TBranch::Browse method displays the name of each leaf. For the object’s Browse method to be called, the IsFolder() method must be overridden to return true. This does not mean it has to be a folder, it just means that it is browse-able.; 15.1.7 SavePrimitive; This method is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:807271,simpl,simply,807271,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simply']
Usability,"ite; kWriteDelete; };. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-12 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBenchmark.html:7132,resume,resume,7132,root/html534/TBenchmark.html,https://root.cern,https://root.cern/root/html534/TBenchmark.html,1,['resume'],['resume']
Usability,"iterator to be incremented and an iterator that points to the end of the collection, respectively. ;  ;  Static Public Attributes inherited from TVirtualCollectionProxy; static const Int_t fgIteratorArenaSize = 16;  The size of a small buffer that can be allocated on the stack to store iterator-specific information. ;  ;  Protected Types inherited from TGenCollectionProxy; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedMapProxy.html:11411,clear,clear,11411,doc/master/classTEmulatedMapProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedMapProxy.html,1,['clear'],['clear']
Usability,"iterator, (*pattern_it).output ().at (0),; 861 (*pattern_it).weight ());; 862 ++output_iterator;; 863 }; 864 }; 865 }; 866 testError += testPatternError; /// batch.size ();; 867 }; 868 // testError /= testPattern.size ();; 869 }; 870 settings.endTestCycle ();; 871// testError /= weightSum;; 872 ; 873 settings.computeResult (*this, weights);; 874 ; 875 hasConverged = settings.hasConverged (testError);; 876 if (!hasConverged && !isWeightsForDrop); 877 {; 878 dropOutWeightFactor (weights, dropFractions, true); // inverse; 879 isWeightsForDrop = true;; 880 }; 881 }; 882 ++testCycleCount;; 883 ++dropOutChangeCount;; 884 ; 885 ; 886// settings.resetPlot (""errors"");; 887 settings.addPoint (""trainErrors"", cycleCount, trainError);; 888 settings.addPoint (""testErrors"", cycleCount, testError);; 889 settings.plot (""trainErrors"", ""C"", 1, kBlue);; 890 settings.plot (""testErrors"", ""C"", 1, kMagenta);; 891 ; 892 ; 893 // setup error plots and progress bar variables for JsMVA; 894 if (fInteractive){; 895 fInteractive->AddPoint(cycleCount, trainError, testError);; 896 if (*fExitFromTraining) break;; 897 *fIPyCurrentIter = 100*(double)settings.maxConvergenceCount () /(double)settings.convergenceSteps ();; 898 }; 899 ; 900 if (hasConverged); 901 break;; 902 ; 903 if ((int)cycleCount % 10 == 0) {; 904 ; 905 TString convText = TString::Format( ""(train/test/epo/conv/maxco): %.3g/%.3g/%d/%d/%d"",; 906 trainError,; 907 testError,; 908 (int)cycleCount,; 909 (int)settings.convergenceCount (),; 910 (int)settings.maxConvergenceCount ());; 911 double progress = 100*(double)settings.maxConvergenceCount () /(double)settings.convergenceSteps ();; 912 settings.cycle (progress, convText);; 913 }; 914 }; 915 while (true);; 916 settings.endTrainCycle (trainError);; 917 ; 918 TString convText = TString::Format( ""(train/test/epoch): %.4g/%.4g/%d"", trainError, testError, (int)cycleCount);; 919 double progress = 100*(double)settings.maxConvergenceCount() /(double)settings.convergenceSteps ();; 920 settings.cy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:27067,progress bar,progress bar,27067,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['progress bar'],['progress bar']
Usability,"ith Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » News Workshops. Here the list with ROOT workshops:. ROOT 2018 ; ROOT 2015 ; ROOT 2013 (slides); ROOT 2007 (slides); ROOT 2005 (slides); ROOT 2007; ROOT 2002 (slides); ROOT 2001 (slides); ROOT 2000 (slides); ROOT 1999 slides ; And PROOF workshops:; PROOF 2007 (slides). Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/workshops.html:2351,guid,guidelines,2351,d/workshops.html,https://root.cern,https://root.cern/d/workshops.html,1,['guid'],['guidelines']
Usability,"ith a TTreeTableInterface ;  numberEntry.CThis macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry ;  QtFileDialog.CThis is a small ROOT macro to use Qt 3.3 class: QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ;  simpleTableTest.CThis TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface ;  Slider3Demo.CSimple macro showing capabilities of triple slider ;  splitbuttonTest.CA simple example that shows the usage of a TGSplitButton ;  splitterHorizontal.CThis macro gives an example of how to create a horizontal splitter ;  splitterVertical.CThis macro gives an example of how to create a vertical splitter ;  staffTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  statusBar.CThis macro gives an example of how to create a status bar related to an embedded canvas that shows the info of the selected object, exactly as the status bar of any canvas window ;  textEntries.CThis macro gives an example of how to set/change text entry attributes ;  textviewostream.CThis macro gives an example of how to use the TGTextViewostream widget ;  WorldMap.CThis macro shows how to use a TGImageMap class ;  ► hist;  candledecay.C Candle Decay, illustrate a time development of a certain value ;  candlehisto.C Example showing how to combine the various candle plot options ;  candleplot.C Example of candle plot with 2-D histograms ;  candleplotoption.C Example showin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:121453,simpl,simple,121453,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,4,['simpl'],['simple']
Usability,"ith a TTreeTableInterface ;  numberEntry.CThis macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry ;  QtFileDialog.CThis is a small ROOT macro to use Qt 3.3 class: QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ;  simpleTableTest.CThis TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface ;  Slider3Demo.CSimple macro showing capabilities of triple slider ;  splitbuttonTest.CA simple example that shows the usage of a TGSplitButton ;  splitterHorizontal.CThis macro gives an example of how to create a horizontal splitter ;  splitterVertical.CThis macro gives an example of how to create a vertical splitter ;  staffTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  statusBar.CThis macro gives an example of how to create a status bar related to an embedded canvas that shows the info of the selected object, exactly as the status bar of any canvas window ;  textEntries.CThis macro gives an example of how to set/change text entry attributes ;  textviewostream.CThis macro gives an example of how to use the TGTextViewostream widget ;  WorldMap.CThis macro shows how to use a TGImageMap class ;  ► hist;  candleplot.C Example of candle plot with 2-D histograms ;  candleplotoption.C Example showing how to combine the various candle plot options ;  candleplotstack.C Example showing how a THStack with candle plot option ;  candleplotwhiskers.C Example of c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:120686,simpl,simple,120686,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"ith complicated, phase space; : dependent nonlinear correlations.; : ; : Please consult the Users Guide for the format of the formula string; : and the allowed parameter ranges:; : documentation/tmva/UsersGuide/TMVAUsersGuide.pdf; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : The FDA performance depends on the complexity and fidelity of the; : user-defined discriminator function. As a general rule, it should; : be able to reproduce the discrimination power of any linear; : discriminant analysis. To reach into the nonlinear domain, it is; : useful to inspect the correlation profiles of the input variables,; : and add quadratic and higher polynomial terms between variables as; : necessary. Comparison with more involved nonlinear classifiers can; : be used as a guide.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : Depending on the function used, the choice of ""FitMethod"" is; : crucial for getting valuable solutions with FDA. As a guideline it; : is recommended to start with ""FitMethod=MINUIT"". When more complex; : functions are used where MINUIT does not converge to reasonable; : results, the user should switch to non-gradient FitMethods such; : as GeneticAlgorithm (GA) or Monte Carlo (MC). It might prove to be; : useful to combine GA (or MC) with MINUIT by setting the option; : ""Converger=MINUIT"". GA (MC) will then set the starting parameters; : for MINUIT such that the basic quality of GA (MC) of finding global; : minima is combined with the efficacy of MINUIT of finding local; : minima.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; FitterBase : <GeneticFitter> Optimisation, please be patient ... (inaccurate progress timing for GA); : Elapsed time: 0.901 sec ; FDA_GA : Results for parameter fit using ""GA"" fitter:; : -----------------------; : Parameter: Fit result:; : -----------------------; : Par(0): 0.525294; : Par(1): 0; : Par(2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:39923,guid,guideline,39923,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['guid'],['guideline']
Usability,"ith less then 10 effective; number of events'; igood=2'There is a bin in the 2nd histogram with less then 10 effective; number of events'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'. - chi2 - chisquare of the test; - ndf - number of degrees of freedom (important, when both histograms have the same; empty bins); - res - normalized residuals for further analysis. Double_t Chisquare(TF1* f1, Option_t* option = """") const; Compute and return the chisquare of this histogram with respect to a function; The chisquare is computed by weighting each histogram point by the bin error; By default the full range of the histogram is used.; Use option ""R"" for restricting the chisquare calculation to the given range of the function. void ClearUnderflowAndOverflow(); Remove all the content from the underflow and overflow bins, without changing the number of entries; After calling this method, every undeflow and overflow bins will have content 0.0; The Sumw2 is also cleared, since there is no more content in the bins. Double_t ComputeIntegral(Bool_t onlyPositive = false); Compute integral (cumulative sum of bins); The result stored in fIntegral is used by the GetRandom functions.; This function is automatically called by GetRandom when the fIntegral; array does not exist or when the number of entries in the histogram; has changed since the previous call to GetRandom.; The resulting integral is normalized to 1; If the routine is called with the onlyPositive flag set an error will; be produced in case of negative bin content and a NaN value returned. Double_t * GetIntegral(); Return a pointer to the array of bins integral.; if the pointer fIntegral is null, TH1::ComputeIntegral is called; The array dimension is the number of bins in the histograms; including underflow and overflow (fNCells); the last value integral[fNCells] is set to the number of entries of; the histogram. TH1 * GetCumulative(Bool_t forward = kTRUE, const char* suffix = ""_cumulative"") const; Retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:60628,clear,cleared,60628,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['clear'],['cleared']
Usability,"itialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent); virtual voidUpdateValueClass(const TClass* oldcl, TClass* newcl). private:. TGenCollectionProxy&operator=(const TGenCollectionProxy&); TGenCollectionProxy(). Data Members; public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t); static TGenCollectionProxy::(anonymous)kBIT_ISSTRING; static TGenCollectionProxy::(anonymous)kBIT_ISTSTRING; static TGenCollectionProxy::(anonymous)kBOOL_t; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsAssociative; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsEmulated; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kNeedDelete. protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tfCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tfConstructContainer accessors: block construct; map<string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tfDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tfFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tfFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tfFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tfFunctionDeleteIterator; TVirtualCollectionProxy::DeleteTwoIterators_tfFunctionDeleteTwoIterators; TVirtualCollectionProxy::Next_tfFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenCollectionProxy.html:4344,clear,clear,4344,root/html602/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy.html,2,['clear'],['clear']
Usability,iting nested parallelism through TTaskGroup ;  mt303_AsyncSimple.C Shows how to run items of work asynchronously with Async ;  mt304_AsyncNested.C Calculate Fibonacci numbers exploiting nested parallelism through Async ;  mt304_fillHistos.CFill histograms in parallel with automatic binning ;  mt305_TFuture.C Shows how to use the Future class of ROOT as a wrapper of std::future ;  mtbb001_fillHistos.C Fill histograms in parallel and write them on file ;  mtbb101_fillNtuples.C Fill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.C Parallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallelMergeTest.C;  pclient.CClient program to test parallel sockets ;  pserv.CServer program to test parallel sockets ;  spy.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:136305,simpl,simple,136305,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,"ition BinData.h:56; ROOT::Fit::BinData::kNoError@ kNoErrorDefinition BinData.h:56; ROOT::Fit::BinData::kCoordError@ kCoordErrorDefinition BinData.h:56; ROOT::Fit::BinData::kAsymError@ kAsymErrorDefinition BinData.h:56; ROOT::Fit::BinData::kValueError@ kValueErrorDefinition BinData.h:56; ROOT::Fit::BinData::GetPointconst double * GetPoint(unsigned int ipoint, double &value, double &invError) constretrieve in a single call a pointer to the coordinate data, value and inverse error for the given fit...Definition BinData.h:439; ROOT::Fit::DataRangeclass describing the range in the coordinates it supports multiple range in a coordinate.Definition DataRange.h:35; ROOT::Fit::FitDataBase class for all the fit data types: Stores the coordinates and the DataOptions.Definition FitData.h:56; ROOT::Fit::FitData::fMaxPointsunsigned int fMaxPointsDefinition FitData.h:384; ROOT::Fit::FitData::fWrappedbool fWrappedDefinition FitData.h:376; ROOT::Fit::FitData::fDimunsigned int fDimDefinition FitData.h:386; ROOT::Fit::FitData::Coordsconst double * Coords(unsigned int ipoint) constreturn a pointer to the coordinates data for the given fit pointDefinition FitData.h:236; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28; ValueDefinition functioncalls.h:15. mathmathcoreincFitBinData.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:39 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:31822,simpl,simple,31822,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['simpl'],['simple']
Usability,"ition TQCommand.cxx:588. Merged commands It possible to group several commands together so an end user can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; gPad#define gPadDefinition TVirtualPad.h:308; TQCommand::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the list of merged commands.Definition TQCommand.cxx:360. Macro commands ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);; ...; During Redo operation commands composing macro command are executed sequentially in direct order (first in first out). During Undo, they are executed in reverse order (last in first out).; Undo manager. TQUndoManager is recorder of undo and redo operations. This is command history list which can be traversed backwards and upwards performing undo and redo operations. To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);; TQCommand::TQUndoManagerfriend class TQUndoManagerDefinition TQCommand.h:29; TQUndoManagerRecorder of operations for undo and redo.Definition TQCommand.h:103; TQUndoManager::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the stack of commands.Definition TQCommand.cxx:959; TQUndoManager::Add automatically invokes execution of command's Redo method. Use TQUndoManager::Undo to undo commands in history list. Redo is Undo for undo action. Use TQUndoManager::Redo method for that ; Definition at line 27 of file TQCommand.h. Public Member Functions;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:3872,undo,undo,3872,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"ition at line 1186 of file TApplication.cxx. ◆ HandleException(). void TApplication::HandleException ; (; Int_t ; sig). virtual . Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingException) trapped in TSystem. ; Specific TApplication implementations may want something different here. ; Reimplemented in TRint, and TProofServ.; Definition at line 590 of file TApplication.cxx. ◆ HandleIdleTimer(). void TApplication::HandleIdleTimer ; (; ). virtual . Handle idle timeout. ; When this timer expires the registered idle command will be executed by this routine and a signal will be emitted. ; Definition at line 577 of file TApplication.cxx. ◆ HandleTermInput(). virtual Bool_t TApplication::HandleTermInput ; (; ). inlinevirtual . Reimplemented in TRint.; Definition at line 116 of file TApplication.h. ◆ Help(). void TApplication::Help ; (; const char * ; line). protectedvirtual . The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ; NoteYou can use "".?"" as the short version of "".help"" ; Parameters. [in]linecommand from the command line . Definition at line 1208 of file TApplication.cxx. ◆ Hide(). virtual void TApplication::Hide ; (; ). inlinevirtual . Definition at line 130 of file TApplication.h. ◆ Iconify(). virtual void TApplication::Iconify ; (; ). inlinevirtual . Definition at line 131 of file TApplication.h. ◆ Init(). virtual void TApplication::Init ; (; ). inlinevirtual . Definition at line 117 of file TApplication.h. ◆ InitializeGraphics(). void TApplication::InitializeGraphics ; (; Bool_t ; only_web = kFALSE). Initialize the graphics environment. ; IfParameters. only_webis specified, only web-related part of graphics is loaded . Definition at line 244 of file TApplication.cxx. ◆ InputFiles(). TObjArray * TApplication::InputFiles ; (; ); const. inline . Definition at line 146 of file TApplication.h. ◆ IsA(). TClass * TApplication::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplication.html:29034,guid,guide,29034,doc/master/classTApplication.html,https://root.cern,https://root.cern/doc/master/classTApplication.html,1,['guid'],['guide']
Usability,"ition; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoConeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoConeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifing current parameters. void DoUndo(); Slot for undoing current operation. void DoRmin1(); Slot for Rmin1. void DoRmax1(); Slot for Rmax1. void DoRmin2(); Slot for Rmin2. void DoRmax2(); Slot for Rmax2. void DoDz(); Slot for Dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeEditor.html:21598,undo,undoing,21598,root/html534/TGeoConeEditor.html,https://root.cern,https://root.cern/root/html534/TGeoConeEditor.html,1,['undo'],['undoing']
Usability,"itive types, basic types, and Cling sometimes calls them fundamental types.; When we say, “writing an object to a file”, we actually mean writing the current values of the data members. The most common way to do this is to decompose (also called the serialization of) the object into its data members and write them to disk. The decomposition is the job of the Streamer. Every class with ambitions to be stored in a file has a Streamerthat decomposes it and “streams” its members into a buffer.; The methods of the class are not written to the file, it contains only the persistent data members. To decompose the parent classes, the Streamercalls the Streamerof the parent classes. It moves up the inheritance tree until it reaches an ancestor without a parent. To serialize the object data members it calls their Streamer. They in turn move up their own inheritance tree and so forth. The simple data members are written to the buffer directly. Eventually the buffer contains all simple data members of all the classes that make up this particular object. Data members that are references (as MyClass &fObj;) are never saved, it is always the responsibility of the object’s constructor to set them properly.; 11.3.1 Automatically Generated Streamers; A Streamerusually calls other Streamers: the Streamerof its parents and data members. This architecture depends on all classes having Streamers, because eventually they will be called. To ensure that a class has a Streamer, rootcling automatically creates one in the ClassDef macro that is defined in $ROOTSYS/include/Rtypes.h. ClassDef defines several methods for any class, and one of them is the Streamer. The automatically generated Streameris complete and can be used as long as no customization is needed.; The Event class is defined in $ROOTSYS/test/Event.h. Looking at the class definition, we find that it inherits from TObject. It is a simple example of a class with diverse data members.; class Event : public TObject {; private:; TDirect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:466856,simpl,simple,466856,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"itle, RooAbsReal& nll, const RooArgSet& observables); Constructor of profile likelihood given input likelihood nll w.r.t; the given set of variables. The input log likelihood is minimized w.r.t; to all other variables of the likelihood at each evaluation and the; value of the global log likelihood minimum is always subtracted. RooProfileLL(const RooProfileLL& other, const char* name = 0); Copy constructor. ~RooProfileLL(); Destructor. const RooArgSet& bestFitParams() const. const RooArgSet& bestFitObs() const. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Optimized implementation of createProfile for profile likelihoods.; Return profile of original function in terms of stated parameters; of interest rather than profiling recursively. void initializeMinimizer() const. Double_t evaluate() const; Evaluate profile likelihood by minimizing likelihood w.r.t. all; parameters that are not considered observables of this profile; likelihood object. void validateAbsMin() const; Check that parameters and likelihood value for 'best fit' are still valid. If not,; because the best fit has never been calculated, or because constant parameters have; changed value or parameters have changed const/float status, the minimum is recalculated. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ). TObject* clone(const char* newname) const; { return new RooProfileLL(*this,newname); }. void setAlwaysStartFromMin(Bool_t flag); { _startFromMin = flag ; }. Bool_t alwaysStartFromMin() const; { return _startFromMin ; }. MINIMIZER* minimizer(); { return _minimizer ; }. RooAbsReal& nll(); { return const_cast<RooAbsReal&>(_nll.arg()) ; }. void clearAbsMin(); { _absMinValid = kFALSE ; }. Int_t numEval() const; { return _neval ; }. » Last changed: Tue Jun 2 15:33:08 2015 » Last generated: 2015-06-02 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooProfileLL.html:40251,clear,clearAbsMin,40251,root/html604/RooProfileLL.html,https://root.cern,https://root.cern/root/html604/RooProfileLL.html,1,['clear'],['clearAbsMin']
Usability,"itlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidTTree::Browse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THbookTree.html:3919,undo,undo,3919,root/html528/THbookTree.html,https://root.cern,https://root.cern/root/html528/THbookTree.html,6,['undo'],['undo']
Usability,"itor objects. ;  ; void MarkBad (TSocket *s, const char *reason=0);  Add slave with socket s to the bad slave list and remove if from the active list and from the two monitor objects. ;  ; Int_t ModifyWorkerLists (const char *ord, Bool_t add, Bool_t save);  Modify the worker active/inactive list by making the worker identified by the ordinal number 'ord' active (add == TRUE) or inactive (add == FALSE). ;  ; void NotifyLogMsg (const char *msg, const char *sfx=""\n"");  Notify locally 'msg' to the appropriate units (file, stdout, window) If defined, 'sfx' is added after 'msg' (typically a line-feed);. ;  ; void operator= (const TProof &);  ; void ParseConfigField (const char *config);  The config file field may contain special instructions which need to be parsed at the beginning, e.g. ;  ; Int_t Ping (ESlaves list);  Ping PROOF slaves. Returns the number of slaves that responded. ;  ; void PrintProgress (Long64_t total, Long64_t processed, Float_t procTime=-1., Long64_t bytesread=-1);  Print a progress bar on stderr. Used in batch mode. ;  ; Bool_t Prompt (const char *p);  Prompt the question 'p' requiring an answer y,Y,n,N Return kTRUE is the answer was y or Y, kFALSE in all other cases. ;  ; void RecvLogFile (TSocket *s, Int_t size);  Receive the log file of the slave with socket s. ;  ; void RedirectWorker (TSocket *s, TSlave *sl, Int_t output_size);  Redirect output of worker sl to some merger. ;  ; void ReleaseMonitor (TMonitor *mon);  Release the used monitor to be used, making sure to delete newly created monitors. ;  ; void ResetMergePrg ();  Reset the merge progress notificator. ;  ; void ResetMergers ();  ; Int_t RestoreActiveList ();  Restore saved list of active workers. ;  ; void SaveActiveList ();  Save current list of active workers. ;  ; Int_t SendCommand (const char *cmd, ESlaves list=kActive);  Send command to be executed on the PROOF master and/or slaves. ;  ; Int_t SendCurrentState (ESlaves list=kActive);  Transfer the current state of the master to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:51711,progress bar,progress bar,51711,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['progress bar'],['progress bar']
Usability,itor.cxx. ◆ CreateBinTab(). void TH1Editor::CreateBinTab ; (; ). protected . Create binning tab. ; Definition at line 340 of file TH1Editor.cxx. ◆ Dividers(). Int_t * TH1Editor::Dividers ; (; Int_t ; n). Return an array of dividers of n (without the trivial divider n). ; The number of dividers is saved in the first entry. ; Definition at line 2417 of file TH1Editor.cxx. ◆ DoAddB(). void TH1Editor::DoAddB ; (; Bool_t ; on). virtual . Slot connected to the bar Add check box. ; Definition at line 948 of file TH1Editor.cxx. ◆ DoAddBar(). void TH1Editor::DoAddBar ; (; Bool_t ; on). virtual . Slot connected to the bar Add check box. ; Definition at line 991 of file TH1Editor.cxx. ◆ DoAddMarker(). void TH1Editor::DoAddMarker ; (; Bool_t ; on). virtual . Slot connected to the show markers check box. ; Definition at line 902 of file TH1Editor.cxx. ◆ DoAddSimple(). void TH1Editor::DoAddSimple ; (; Bool_t ; on). virtual . Slot connected to fAddSimple check box for drawing a simple histogram without errors (== HIST draw option) in combination with some other draw options. ; It draws an additional line on the top of the bins. ; Definition at line 1092 of file TH1Editor.cxx. ◆ DoApply(). void TH1Editor::DoApply ; (; ). virtual . Slot connected to the Apply button of the Binning tab. ; Definition at line 2128 of file TH1Editor.cxx. ◆ DoAxisRange(). void TH1Editor::DoAxisRange ; (; ). virtual . Slot connected to the number entry fields containing the Max/Min value of the x-axis. ; Definition at line 1658 of file TH1Editor.cxx. ◆ DoBarOffset(). void TH1Editor::DoBarOffset ; (; ). virtual . Slot connected to the Bar Offset of the Bar Charts. ; Definition at line 1404 of file TH1Editor.cxx. ◆ DoBarWidth(). void TH1Editor::DoBarWidth ; (; ). virtual . Slot connected to the Bar Width of the Bar Charts. ; Definition at line 1394 of file TH1Editor.cxx. ◆ DoBinLabel(). void TH1Editor::DoBinLabel ; (; ). virtual . Slot connected to the Bin number entry of the Rebinning tab. ; Definition at ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1Editor.html:47339,simpl,simple,47339,doc/master/classTH1Editor.html,https://root.cern,https://root.cern/doc/master/classTH1Editor.html,1,['simpl'],['simple']
Usability,"its are set.; 1152/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 1153/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 1154/// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; 1155/// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; 1156///; 1157///; 1158/// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; 1159/// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; 1171/// The chi-square is then computed as the sum of the quantity below at each data point:; 1172///; 1173/// \f[; 1174/// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; 1175/// \f]; 1176///; 1177/// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; 1178/// function `f(x)`.; 1179///; 1180/// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; 1181///; 1182/// The approach used to approximate the uncertainty in y because of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:40720,simpl,simple,40720,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['simpl'],['simple']
Usability,"its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is cleaned; upon destruction. Let's consider positioning now our wire in the middle of a gas chamber. We; need first to define the gas chamber :. TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"", ptrGAS, 0, 1, 1);. Now we can put the wire inside :. chamber->AddNode(wire_co, 1);. If we inspect now the chamber volume in a browser, we will notice that it has; one daughter. Of course the gas has some container also, but let's keep it like; that for the sake of simplicity. The full prototype of AddNode() is :. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t usernumber,; TGeoMatrix *matrix=gGeoIdentity). Since we did not supplied the third argument, the wire will be positioned with; an identity transformation inside the chamber. One will notice that the inner; radii of the wire and chamber are both zero - therefore, aren't the two volumes; overlapping ? The answer is no, the modeler is even relaying on the fact that; any daughter is fully contained by its mother. On the other hand, neither of; the nodes positioned inside a volume should overlap with each other. We will; see that there are allowed some exceptions to those rules. Overlapping volumes. Positioning volumes that does not overlap their neighbours nor extrude; their container is sometimes quite strong constraint. Some parts of the geometry; might overlap naturally, e.g. two crossing tubes. The modeller supports such; cases only if the overlapping",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:5867,simpl,simplicity,5867,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,9,['simpl'],['simplicity']
Usability,"its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is cleaned; upon destruction. Let's consider positioning now our wire in the middle of a gas chamber. We; need first to define the gas chamber :. TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"", ptrGAS, 0, 1, 1);. Now we can put the wire inside :. chamber->AddNode(wire_co, 1);. If we inspect now the chamber volume in a browser, we will notice that it has; one daughter. Of course the gas has some container also, but let's keep it like; that for the sake of simplicity. The full prototype of AddNode() is :. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t usernumber,; TGeoMatrix *matrix=gGeoIdentity). Since we did not supplied the third argument, the wire will be positioned with; an identity transformation inside the chamber. One will notice that the inner; radii of the wire and chamber are both zero - therefore, aren't the two volumes; overlapping ? The answer is no, the modeler is even relaying on the fact that; any daughter is fully contained by its mother. On the other hand, neither of; the nodes positioned inside a volume should overlap with each other. We will; see that there are allowed some exceptions to those rules. Overlapping volumes. Positioning volumes that does not overlap their neighbours nor extrude; their container is sometimes quite strong contrain. Some parts of the geometry; might overlap naturally, e.g. two crossing tubes. The modeller supports such; cases only if the overlapping n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolume.html:5847,simpl,simplicity,5847,root/html528/TGeoVolume.html,https://root.cern,https://root.cern/root/html528/TGeoVolume.html,9,['simpl'],['simplicity']
Usability,"its { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TBranchBrowsable.h>. Inheritance diagram for TMethodBrowsable:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~TMethodBrowsable(). TMethodBrowsable::~TMethodBrowsable ; (; ). inlineoverride . Definition at line 105 of file TBranchBrowsable.h. ◆ TMethodBrowsable(). TMethodBrowsable::TMethodBrowsable ; (; const TBranch * ; branch, . TMethod * ; m, . const TVirtualBranchBrowsable * ; parent = nullptr . ). protected . Constructor. ; Links a TBranchElement to a TMethod, allowing the TBrowser to browse simple methods.; The c'tor sets the name for a method ""Class::Method(params) const"" to ""Method(params)"", title to TMethod::GetPrototype ; Definition at line 409 of file TBranchBrowsable.cxx. Member Function Documentation. ◆ Class(). static TClass * TMethodBrowsable::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMethodBrowsable::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMethodBrowsable::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 128 of file TBranchBrowsable.h. ◆ DeclFileName(). static const char * TMethodBrowsable::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 128 of file TBranchBrowsable.h. ◆ GetBrowsableMethodsForClass(). void TMethodBrowsable::GetBrowsableMethodsForClass ; (; TClass * ; cl, . TList & ; li . ). staticprotected ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethodBrowsable.html:16280,simpl,simple,16280,doc/master/classTMethodBrowsable.html,https://root.cern,https://root.cern/doc/master/classTMethodBrowsable.html,1,['simpl'],['simple']
Usability,"itsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggleGroup. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TToggleGroup.html:7141,clear,clears,7141,root/html604/TToggleGroup.html,https://root.cern,https://root.cern/root/html604/TToggleGroup.html,1,['clear'],['clears']
Usability,"itsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggleGroup. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TToggleGroup.html:7141,clear,clears,7141,root/html602/TToggleGroup.html,https://root.cern,https://root.cern/root/html602/TToggleGroup.html,1,['clear'],['clears']
Usability,"itted by Anonymous (not verified) on Thu, 07/23/2015 - 21:48 Permalink . Other Python bindings . I noticed that there are multiple other ways to call C++ code from Python, one of them being included in the Boost library. What would it do to the complexity (and dependencies) to use an interface that doesn't build on top of CINT/Reflex?. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:49 Permalink . Re: Other Python bindings . Hi Bram,; Thanks for your question. The main issue about the boost binding is that it is - as far as I understand - completely static and intrusive. PyROOT on the other hand is based on refection data, and it has features that e.g. the Boost binding doesn't offer (e.g. the mapping of concepts). Other bindings (e.g. SWIG-based ones) are difficult to maintain, not compatible with C++, and don't offer PyROOT's features either. So the cost is both on the implementation side and the feature side. Thus why not simply use PyROOT? :-); Note that we will soon have a PyROOT that builds on top of clang, as part of ROOT 6. I think Wim (the author of PyROOT) plans to port it to a version without ROOT, likely involving PyPy. So that might be exactly what you are looking for :-); Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:49 Permalink . Re: Other Python bindings . Hi Bram, Axel,; let me add to that (and point out that none of the mentioned tools are intrusive, btw.). The biggest problem with boost.python (with pyste; standalone it is a non-starter) and SWIG is that you need to run a separate tool to create and compile bindings. On top, these bindings are compiled against a specific version of Python, making for a distribution headache (just see the non-pickup of Python3 because of this problem). Compare: dictionaries are already available for all the most important classes in experiments, the EDM, because they are generated for I/O needs. They also do not depend on Python, and thus not on any specific version (onl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:6205,simpl,simply,6205,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['simpl'],['simply']
Usability,"ity and TUnfoldBinning ;  testUnfold6.C Test program for the class TUnfoldBinning ;  testUnfold7a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  draw_subpads.cxx;  draw_th1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxx;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:165140,learn,learn,165140,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['learn'],['learn']
Usability,"ity. The ; : linearity property of this classifier is reflected in the ; : metric with which ""far apart"" and ""close vicinity"" are ; : determined: the covariance matrix of the discriminating; : variable space.); : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Optimal performance for Fisher discriminants is obtained for ; : linearly correlated Gaussian-distributed variables. Any deviation; : from this ideal reduces the achievable separation power. In ; : particular, no discrimination at all is achieved for a variable; : that has the same sample mean for signal and background, even if ; : the shapes of the distributions are very different. Thus, Fisher ; : discriminants often benefit from suitable transformations of the ; : input variables. For example, if a variable x in [-1,1] has a ; : a parabolic signal distributions, and a uniform background; : distributions, their mean value is zero in both cases, leading ; : to no separation. The simple transformation x -> |x| renders this ; : variable powerful for the use in a Fisher discriminant.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : <None>; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; Fisher : Results for Fisher coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : m_jj: -0.051; : m_jjj: +0.192; : m_lv: +0.045; : m_jlv: +0.059; : m_bb: -0.211; : m_wbb: +0.549; : m_wwbb: -0.778; : (offset): +0.136; : -----------------------; : Elapsed time for training with 14000 events: 0.0105 sec ; Fisher : [dataset] : Evaluation of Fisher on training sample (14000 events); : Elapsed time for evaluation of 14000 events: 0.0038 sec ; : <CreateMVAPdfs> Separation from histogram (PDF): 0.090 (0.000); : Dataset[dataset] : Evaluation of Fisher on training sample; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Fisher.weights.xml␛[0m; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:20156,simpl,simple,20156,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['simpl'],['simple']
Usability,"ity. The ; : linearity property of this classifier is reflected in the ; : metric with which ""far apart"" and ""close vicinity"" are ; : determined: the covariance matrix of the discriminating; : variable space.); : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Optimal performance for Fisher discriminants is obtained for ; : linearly correlated Gaussian-distributed variables. Any deviation; : from this ideal reduces the achievable separation power. In ; : particular, no discrimination at all is achieved for a variable; : that has the same sample mean for signal and background, even if ; : the shapes of the distributions are very different. Thus, Fisher ; : discriminants often benefit from suitable transformations of the ; : input variables. For example, if a variable x in [-1,1] has a ; : a parabolic signal distributions, and a uniform background; : distributions, their mean value is zero in both cases, leading ; : to no separation. The simple transformation x -> |x| renders this ; : variable powerful for the use in a Fisher discriminant.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : <None>; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; Fisher : Results for Fisher coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : m_jj: -0.051; : m_jjj: +0.192; : m_lv: +0.045; : m_jlv: +0.059; : m_bb: -0.211; : m_wbb: +0.549; : m_wwbb: -0.778; : (offset): +0.136; : -----------------------; : Elapsed time for training with 14000 events: 0.0116 sec ; Fisher : [dataset] : Evaluation of Fisher on training sample (14000 events); : Elapsed time for evaluation of 14000 events: 0.00388 sec ; : <CreateMVAPdfs> Separation from histogram (PDF): 0.090 (0.000); : Dataset[dataset] : Evaluation of Fisher on training sample; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Fisher.weights.xml␛[0m;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:20093,simpl,simple,20093,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['simpl'],['simple']
Usability,"ium-r-normal ""Arial"" 0 5; *-* 5 : helvetica-medium-o-normal ""Arial"" 1 5; *-* 6 : helvetica-bold-r-normal ""Arial"" 0 8; *-* 7 : helvetica-bold-o-normal ""Arial"" 1 8; *-* 8 : courier-medium-r-normal ""Courier New"" 0 5; *-* 9 : courier-medium-o-normal ""Courier New"" 1 5; *-* 10 : courier-bold-r-normal ""Courier New"" 0 8; *-* 11 : courier-bold-o-normal ""Courier New"" 1 8; *-* 12 : symbol-medium-r-normal ""Symbol"" 0 6; *-* 13 : times-medium-r-normal ""Times New Roman"" 0 5; *-* 14 : ""Wingdings"" 0 5. void SetTextSize(Float_t textsize); Set current text size*-*-; *-* =====================. void UpdateWindow(Int_t mode); Update display.; mode : (1) update; (0) sync. Int_t WriteGIF(char* name). Writes the current active window into pixmap file.; The format is defined by the file name extension; like ""png"",""jpg"",""bmp"" . . .; If no extension is provided the ""png"" format is used by default. Returns 1 in case of success,; 0 otherwise; Note: this method may not produce the expected result been called; ---- from the ROOT prompt by simple reason:; The active window will be console window; rather the last selected ROOT canvas. void WritePixmap(Int_t wid, UInt_t w, UInt_t h, char* pxname); Write the pixmap wd in the bitmap file pxname in JPEG.; wd : Pixmap address; w,h : Width and height of the pixmap.; if w = h = -1 the size of the pimxap is equal the size the wd size; pxname : pixmap file name; The format is defined by the file name extension; like ""png"",""jpg"",""bmp"" . . .; If no or some unknown extension is provided then; the ""png"" format is used by default; --; Take in account the special ROOT filename syntax 26.12.2006 vf; ""gif+NN"" - an animated GIF file is produced, where NN is delay in 10ms units. Int_t LoadQt(const char* shareLibFileName); Make sure we load the GUI DLL from the gui thread. Int_t processQtEvents(Int_t maxtime = 300); Force processing the Qt events only without entering the ROOT event loop. void operator=(const TGQt& ). TGQt(). Bool_t IsHandleValid(Window_t id). » Author",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGQt.html:34011,simpl,simple,34011,root/html528/TGQt.html,https://root.cern,https://root.cern/root/html528/TGQt.html,3,['simpl'],['simple']
Usability,"ivatives implementation class using GSL ;  CGSLRootFinderBase class for GSL Root-Finding algorithms for one dimensional functions which do not use function derivatives ;  CGSLRootFinderDerivBase class for GSL Root-Finding algorithms for one dimensional functions which use function derivatives ;  CGSLRootFSolverRoot-Finder implementation class using GSL ;  CGSLSimAnFuncGSLSimAnFunc class description ;  CGSLSimAnMinimizerGSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL ;  CGSLSimAnnealingGSLSimAnnealing class for performing a simulated annealing search of a multidimensional function ;  CGSLSimAnParamsStructure holding the simulated annealing parameters ;  CGSLVegasIntegrationWorkspaceWorkspace for VEGAS ;  CIBaseFunctionMultiDimDocumentation for the abstract class IBaseFunctionMultiDim ;  CIBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evaluate the function given a value (simple double) by implementing operator() (const double ) ;  CIBaseParamDocumentation for the abstract class IBaseParam ;  CIGradientFunctionMultiDimInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:36695,simpl,simple,36695,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['simpl'],['simple']
Usability,"ivatives implementation class using GSL ;  CGSLRootFinderBase class for GSL Root-Finding algorithms for one dimensional functions which do not use function derivatives ;  CGSLRootFinderDerivBase class for GSL Root-Finding algorithms for one dimensional functions which use function derivatives ;  CGSLRootFSolverRoot-Finder implementation class using GSL ;  CGSLSimAnFuncGSLSimAnFunc class description ;  CGSLSimAnMinimizerGSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL ;  CGSLSimAnnealingGSLSimAnnealing class for performing a simulated annealing search of a multidimensional function ;  CGSLSimAnParamsStructure holding the simulated annealing parameters ;  CGSLVegasIntegrationWorkspaceWorkspace for VEGAS ;  CIBaseFunctionMultiDimDocumentation for the abstract class IBaseFunctionMultiDim ;  CIBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evaluate the function given a value (simple double) by implementing operator() (const double ) ;  CIBaseParamDocumentation for the abstract class IBaseParam ;  CIGradientFunctionMultiDimInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxillary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:32627,simpl,simple,32627,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['simpl'],['simple']
Usability,"ive shapes supported by the package are basically the GEANT3 shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel planes. All basic primitives inherits from class TGeoBBox since the bounding box of a solid is essential for the tracking algorithms. They also implement the virtual methods defined in the virtual class TGeoShape (point and segment classification). User-defined primitives can be directly plugged into the modeler provided that they override these methods. Composite shapes will be soon supported by the modeler. In order to build a TGeoCompositeShape, one will have to define first the primitive components. The object that handle boolean operations among components is called TGeoBoolCombinator and it has to be constructed providing a string boolean expression between the components names. Example for building a simple geometry; ; void rootgeom(bool vis = true); {; // gStyle->SetCanvasPreferGL(true);; ; TGeoManager *geom = new TGeoManager(""simple1"", ""Simple geometry"");; ; //--- define some materials; TGeoMaterial *matVacuum = new TGeoMaterial(""Vacuum"", 0,0,0);; TGeoMaterial *matAl = new TGeoMaterial(""Al"", 26.98,13,2.7);; // //--- define some media; TGeoMedium *Vacuum = new TGeoMedium(""Vacuum"",1, matVacuum);; TGeoMedium *Al = new TGeoMedium(""Root Material"",2, matAl);; ; //--- define the transformations; TGeoTranslation *tr1 = new TGeoTranslation(20., 0, 0.);; TGeoTranslation *tr2 = new TGeoTranslation(10., 0., 0.);; TGeoTranslation *tr3 = new TGeoTranslation(10., 20., 0.);; TGeoTranslation *tr4 = new TGeoTranslation(5., 10., 0.);; TGeoTranslation *tr5 = new TGeoTranslation(20., 0., 0.);; TGeoTranslation *tr6 = new TGeoTranslation(-5., 0., 0.);; TGeoTranslation *tr7 = new TGeoTranslation(7.5, 7.5, 0.);; TGeoRotation *rot1 = new TGeoRotation(""rot1"", 90., 0., 90., 270., 0., 0.);; TGeoCombiTrans *combi1 = new TGeoCombiTrans(7.5, -7.5, 0., rot1);; TGeoTranslation *tr8 = new TGeoTranslation(7.5, -5., 0.);; TGeoTranslation *tr9 = new TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:4977,simpl,simple,4977,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['simpl'],['simple']
Usability,"ivide(N,Xmin,Xmax,""X"");; Create a new volume by dividing an existing one (GEANT3 like).; Divides MOTHER into NDIV divisions called NAME along axis IAXIS starting at coordinate value START and having size STEP. The created volumes will have tracking media ID=NUMED (if NUMED=0 -> same media as MOTHER).; The behavior of the division operation can be triggered using OPTION (case insensitive):. Ndivide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3); NXdivide range starting with START in NDIV cells (GSDVN2 in G3); Sdivide all range with given STEP; NDIV is computed and divisions will be centered in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3); SXsame as DVS, but from START position (GSDVS2, GSDVT2 in G3). Volume Assemblies; In general, geometry contains structures of positioned volumes that have to be grouped and handled together, for different possible reasons. One of these is that the structure has to be replicated in several parts of the geometry, or it may simply happen that they really represent a single object, too complex to be described by a primitive shape.; Usually handling structures like these can be easily done by positioning all components in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as ""overlapping"" (see also ""Overlapping Volumes""); Representing the container as a composite shape - the Boolean union of all components (see also ""Composite Shapes""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigation ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:50516,simpl,simply,50516,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simply']
Usability,"ividual file (each sample is simply a single file).; 376 /// In the multithreaded case, the idea is to accumulate the higher event entry value until; 377 /// the total number of events in a given file is reached.; 378 void registerNewSample(unsigned int /*slot*/, const ROOT::RDF::RSampleInfo &id); 379 {; 380 std::lock_guard<std::mutex> lock(fSampleNameToEventEntriesMutex);; 381 fSampleNameToEventEntries[id.AsString()] =; 382 std::max(id.EntryRange().second, fSampleNameToEventEntries[id.AsString()]);; 383 }; 384 ; 385 /// Thread-safe callback for RDataFrame.; 386 /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the; 387 /// fPrintInterval). \param slot Ignored. \param value Ignored.; 388 template <typename T>; 389 void operator()(unsigned int /*slot*/, T &value); 390 {; 391 operator()(value);; 392 }; 393 // clang-format off; 394 /// Thread-safe callback for RDataFrame.; 395 /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the fPrintInterval).; 396 /// \param value Ignored.; 397 // clang-format on; 398 template <typename T>; 399 void operator()(T & /*value*/); 400 {; 401 using namespace std::chrono;; 402 // ***************************************************; 403 // Warning: Here, everything needs to be thread safe:; 404 // ***************************************************; 405 fProcessedEvents += fIncrement;; 406 ; 407 // We only print every n seconds.; 408 if (duration_cast<seconds>(system_clock::now() - fLastPrintTime) < fPrintInterval) {; 409 return;; 410 }; 411 ; 412 // ***************************************************; 413 // Protected by lock from here:; 414 // ***************************************************; 415 if (!fPrintMutex.try_lock()); 416 return;; 417 std::lock_guard<std::mutex> lockGuard(fPrintMutex, std::adopt_lock);; 418 ; 419 std::size_t eventCount;; 420 seconds elapsedSeconds;; 421 std::tie(eventCount, elapsedSeconds) = RecordEvtCou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:18837,progress bar,progress bar,18837,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['progress bar'],['progress bar']
Usability,"ization actions. Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that. TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; TGeoManager::GetListOfNavigatorsTGeoNavigatorArray * GetListOfNavigators() constGet list of navigators for the calling thread.Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:66241,simpl,simple,66241,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"ize Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2073 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2106 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2128 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2145 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2160 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:49499,learn,learning,49499,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['learn'],['learning']
Usability,"izerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; In the following we will give some brief description of the minimization packages. The packages all implement the ROOT::Math::Minimizer interface which can be use for finding the minimum of a multi-dimensional function. The interface is documented in the Mathematical Library Chapter.; In addition packages like Minuit or Minuit2 provide their own interfaces.; 5.9 MINUIT (Old TMInuit Version); This package was originally written in FORTRAN by Fred James and part of PACKLIB (patch D506). It has been converted to a C++ class by René Brun. The current implementation in C++ is a straightforward conversion of the original FORTRAN version. The main changes are:. The variables in the various Minuit labeled common blocks have been changed to the TMinuit class data members; The internal arrays with a maximum dimension depending on the maximum number of parameters are now data members’ arrays with a dynamic dimension such that one can fit very large problems by simply initializing the TMinuit constructor with the maximum number of parameters; The include file Minuit.h has been commented as much as possible using existing comments in the code or the printed documentation; The original Minuit subroutines are now member functions; Constructors and destructor have been added; Instead of passing the FCN function in the argument list, the addresses of this function is stored as pointer in the data members of the class. This is by far more elegant and flexible in an interactive environment. The member function SetFCN can be used to define this pointer; The ROOT static function Printf is provided to replace all format statements and to print on currently defined output file; The functions SetObjectFit/GetObjectFit can be used inside the FCN function to set/get a referenced object instead of using global variables; By default fGraphicsMode is true. When ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:214434,simpl,simply,214434,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simply']
Usability,"j]) {; 5032 cle->Destructor(r[j]);; 5033 r[j] = 0;; 5034 }; 5035 }; 5036 }; 5037 ; 5038 if (etype == kBase) {; 5039 if (cle->Property() & kIsAbstract) {; 5040 TVirtualStreamerInfo *einfo = cle->GetStreamerInfoAbstractEmulated();; 5041 if (einfo) einfo->Destructor(eaddr, kTRUE);; 5042 } else {; 5043 cle->Destructor(eaddr, kTRUE);; 5044 }; 5045 }; 5046 ; 5047 if (etype == kObject || etype == kAny ||; 5048 etype == kTObject || etype == kTString || etype == kTNamed) {; 5049 // A data member is destroyed, but not deleted.; 5050 cle->Destructor(eaddr, kTRUE);; 5051 }; 5052 ; 5053 if (etype == kSTL) {; 5054 // A data member is destroyed, but not deleted.; 5055 TVirtualCollectionProxy *pr = cle->GetCollectionProxy();; 5056 if (!pr) {; 5057 if (strcmp(ele->GetName(),""This"")==0) {; 5058 // missing information, avoid infinite loop; 5059 // by doing nothing ....; 5060 } else {; 5061 cle->Destructor(eaddr, kTRUE);; 5062 }; 5063 } else {; 5064 if (ele->TestBit(TStreamerElement::kDoNotDelete)) {; 5065 TVirtualCollectionProxy::TPushPop env(cle->GetCollectionProxy(), eaddr); // used for both this 'clear' and the 'clear' inside destructor.; 5066 cle->GetCollectionProxy()->Clear(); // empty the collection without deleting the pointer; 5067 pr->Destructor(eaddr, kTRUE);; 5068 } else {; 5069 pr->Destructor(eaddr, kTRUE);; 5070 }; 5071 }; 5072 }; 5073 ; 5074 if (etype == kObject + kOffsetL || etype == kAny + kOffsetL ||; 5075 etype == kTObject + kOffsetL || etype == kTString + kOffsetL ||; 5076 etype == kTNamed + kOffsetL || etype == kSTL + kOffsetL) {; 5077 // For a data member which is an array of objects, we; 5078 // destroy the objects, but do not delete them.; 5079 Int_t len = ele->GetArrayLength();; 5080 Int_t size = cle->Size();; 5081 char* r = eaddr + (size * (len - 1));; 5082 for (Int_t j = len - 1; j >= 0; --j, r -= size) {; 5083 cle->Destructor(r, kTRUE);; 5084 }; 5085 }; 5086 } // iter over elements; 5087 ; 5088 if (!dtorOnly) {; 5089 delete[] p;; 5090 }; 5091}; 5092 ; 5093///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:201950,clear,clear,201950,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,2,['clear'],['clear']
Usability,"ject is created by the streamer during the disk-read operation. void SetRho(TFoamIntegrand* Rho); User may use this method to set (register) random number generator used by; the given instance of the FOAM event generator. Note that single r.n. generator; may serve several FOAM objects. void ResetRho(TFoamIntegrand* Rho); User may optionally reset the distribution using this method; Usually it is done when FOAM object is restored from the disk.; IMPORTANT: this method deletes existing distribution object registered in the FOAM object.; In particular such an object is created by the streamer diring the disk-read operation.; This method is used only in very special cases, because the distribution in most cases; should be ""owned"" by the FOAM object and should not be replaced by another one after initialization. void SetRhoInt(void* Rho); User may use this to set pointer to the global function (not descending; from TFoamIntegrand) serving as a distribution for FOAM.; It is useful for simple interactive applications.; Note that persistency for FOAM object will not work in the case of such; a distribution. Double_t Eval(Double_t* ); Internal subprogram.; Evaluates distribution to be generated. void GenerCel2(TFoamCell*& ); Internal subprogram.; Return randomly chosen active cell with probability equal to its; contribution into total driver integral using interpolation search. void MakeEvent(void); User subprogram.; It generates randomly point/vector according to user-defined distribution.; Prior initialization with help of Initialize() is mandatory.; Generated MC point/vector is available using GetMCvect and the MC weight with GetMCwt.; MC point is generated with wt=1 or with variable weight, see OptRej switch. void GetMCvect(Double_t* ); User may get generated MC point/vector with help of this method. Double_t GetMCwt(Double_t& ); User may get weight MC weight using this method. void GetMCwt(Double_t& ); User may get weight MC weight using this method. Double_t MCgenerate(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFoam.html:20206,simpl,simple,20206,root/html528/TFoam.html,https://root.cern,https://root.cern/root/html528/TFoam.html,3,['simpl'],['simple']
Usability,"ject. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; TObject * Clone (const char *newname="""") const override;  Make a complete copy of the underlying object. ;  ; virtual Double_t ComputeIntegral (Bool_t onlyPositive=false);  Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Perform the automatic addition of the histogram to the given directory. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a line. ;  ; virtual Bool_t Divide (const TH1 *h1);  Divide this histogram by h1. ;  ; virtual Bool_t Divide (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""");  Replace contents of this histogram by the division of h1 by h2. ;  ; virtual Bool_t Divide (TF1 *f1, Double_t c1=1);  Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2), errors are also recalc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLTH3Composition.html:14619,clear,cleared,14619,doc/master/classTGLTH3Composition.html,https://root.cern,https://root.cern/doc/master/classTGLTH3Composition.html,15,['clear'],['cleared']
Usability,"ject. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; TObject * Clone (const char *newname="""") const override;  Make a complete copy of the underlying object. ;  ; virtual Double_t ComputeIntegral (Bool_t onlyPositive=false);  Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Perform the automatic addition of the histogram to the given directory. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a line. ;  ; void Draw (Option_t *option="""") override;  Draw this histogram with options. ;  ; virtual TH1 * DrawCopy (Option_t *option="""", const char *name_postfix=""_copy"") const;  Copy this histogram and Draw in the current pad. ;  ; virtual TH1 * DrawNormalized (Option_t *option="""", Double_t norm=1) const;  Draw a normalized copy of this histogram. ;  ; virtual void DrawPanel ();  Display a panel with all histo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile.html:12570,clear,cleared,12570,doc/master/classTProfile.html,https://root.cern,https://root.cern/doc/master/classTProfile.html,3,['clear'],['cleared']
Usability,"ject. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Perform the automatic addition of the histogram to the given directory. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a line. ;  ; virtual Bool_t Divide (const TH1 *h1);  Divide this histogram by h1. ;  ; virtual Bool_t Divide (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""");  Replace contents of this histogram by the division of h1 by h2. ;  ; void Draw (Option_t *option="""") override;  Draw this histogram with options. ;  ; virtual TH1 * DrawCopy (Option_t *option="""", const char *name_postfix=""_copy"") const;  Copy this histogram and Draw in the current pad. ;  ; virtual TH1 * DrawNormalized (Option_t *option="""", Double_t norm=1) const;  Draw a normalized copy of this histogram. ;  ; virtual void DrawPanel ();  Display a panel with all histogram drawing options. ;  ; virtual void Eval (TF1 *f1, Option_t *option=""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:21063,clear,cleared,21063,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,2,['clear'],['cleared']
Usability,"ject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←. TQUndoManager. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:19366,undo,undo,19366,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,2,['undo'],['undo']
Usability,"ject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_tTTUBE::fAspectRatiodefines (the ellipse semi-axis in Y)/(the ellipse semi-axis in X); Double_t*TTUBE::fCoTab! Table of cos(fPhi1) .... cos(fPhil+fDphi1); Float_tTTUBE::fDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tfRmax2outside radius at the high z limit; Float_tTTUBE::fRminellipse semi-axis in X inside; Float_tfRmin2inside radius at the high z limit; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCONE(); CONE shape default constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmin1, Float_t rmax1, Float_t rmin2, Float_t rmax2); CONE shape normal constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmax1, Float_t rmax2 = 0); CONE shape ""simplified"" constructor. ~TCONE(); CONE shape default destructor. void SetPoints(Double_t* points) const; Create CONE points. TCONE(). Float_t GetRmin2() const; {return fRmin2;}. Float_t GetRmax2() const; {return fRmax2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TCONE.html:10001,simpl,simplified,10001,root/html604/TCONE.html,https://root.cern,https://root.cern/root/html604/TCONE.html,1,['simpl'],['simplified']
Usability,"ject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_tTTUBE::fAspectRatiodefines (the ellipse semi-axis in Y)/(the ellipse semi-axis in X); Double_t*TTUBE::fCoTab! Table of cos(fPhi1) .... cos(fPhil+fDphi1); Float_tTTUBE::fDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tfRmax2outside radius at the high z limit; Float_tTTUBE::fRminellipse semi-axis in X inside; Float_tfRmin2inside radius at the high z limit; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCONE(); CONE shape default constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmin1, Float_t rmax1, Float_t rmin2, Float_t rmax2); CONE shape normal constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmax1, Float_t rmax2 = 0); CONE shape ""simplified"" constructor. ~TCONE(); CONE shape default destructor. void SetPoints(Double_t* points) const; Create CONE points. TCONE(). Float_t GetRmin2() const; {return fRmin2;}. Float_t GetRmax2() const; {return fRmax2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCONE.html:10001,simpl,simplified,10001,root/html602/TCONE.html,https://root.cern,https://root.cern/root/html602/TCONE.html,1,['simpl'],['simplified']
Usability,"ject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofProgressStatus&operator+=(const TProofProgressStatus& st); TProofProgressStatusoperator-(TProofProgressStatus& st); TProofProgressStatus&operator-=(const TProofProgressStatus& st); TProofProgressStatus&operator=(const TProofProgressStatus&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBytesRead(Long64_t bytesRead); voidSetCPUTime(Double_t procTime); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEntries(Long64_t entries); voidSetLastEntries(Long64_t entries); voidSetLastProcTime(Double_t procTime); voidSetLastUpdate(Double_t updtTime = 0); voidSetLearnTime(Double_t learnTime); static voidTObject::SetObjectStat(Bool_t stat); voidSetProcTime(Double_t procTime); voidSetReadCalls(Long64_t readCalls); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofProgressStatus.html:5136,learn,learnTime,5136,root/html530/TProofProgressStatus.html,https://root.cern,https://root.cern/root/html530/TProofProgressStatus.html,2,['learn'],['learnTime']
Usability,"jectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Types; using LegacyIterator_t = TIteratorToSTLInterface< Storage_t >;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual bool canBeAdded (const RooAbsArg &arg, bool silent) const =0;  Determine whether it's possible to add a given RooAbsArg to the collection or not. ;  ; void clearStructureTags ();  ; void deleteList ();  Delete contents of the list. ;  ; void makeStructureTag ();  ; void makeTypedStructureTag ();  ; TNamed * structureTag ();  ; TNamed * typedStructureTag ();  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; template<class T > ; static void assert_is_no_temporary (T &&);  . Protected Attributes; bool _allRRV = true;  All contents are RRV. ;  ; Storage_t _list;  Actual object storage. ;  ; TString _name;  Our name. ;  ; bool _ownCont = false;  Flag to identify a list that owns its contents. ;  ; TNamed * _structureTag {nullptr};  ! Structure tag ;  ; TNamed * _typedStructureTag {nullptr};  ! Typed structure tag ;  . Private Types; using HashAssistedFind = RooFit::Detail::HashAssistedFind;  . Private Member Functions; void insert (RooAbsArg *);  Insert an element into the owned ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:24454,clear,clearStructureTags,24454,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,2,['clear'],['clearStructureTags']
Usability,"jects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » News Blog. ROOT::RWhy! ; ## Background. ROOT is implementing new interfaces following new interface styles. We follow [C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md) where reasonable in our context. Most noticeably this means. - use of references as parameters instead... more . The status of reflection in C++ ; When the C++ committee met in Jacksonville two months ago, something big happened: the reflection study group, SG7, decided what the basic “language"" of reflected C++ should look like. What does that mean? Why do you care? Let me, the co-author of the only “blessed proposal"", explain:. Almost... more . ROOT::TSeq::GetSize() or ROOT::seq::size()? ; Hi,. It's time to resume this blog - on what the ROOT team is up to; what happens at the C++ meetings; and a bit of behind-the-scenes of cling and ROOT. We have started to develop towards ROOT 7 and [its new interfaces](http://indico.cern.ch/event/349459/session/1/contribution/3). We will have... more . ROOT6 and Backward Compatibility ; Hi everyone, dear Matt!. Matt Walker has posted an extensive review of ROOT and what he would hope the future of ROOT to be. Because I think many of his comments are good ones, and because I have heard some of them from several people in the past, I decided to give the answer to an audience that'... more . Main Histogram Changes in ROOT 6 ;  Here is a list of the main changes which have been applied to the histogram classes in ROOT 6. These changes affect the behaviour of the histogram classes and explain why for some cases the same code would give a different outcome than in ROOT 5. .  . Rebinning/Extension of axis... more . Rainbow ? ; The rainbow colormap is not the best choice to represent data using pseudo colors. This arti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog.html:2574,resume,resume,2574,d/blog.html,https://root.cern,https://root.cern/d/blog.html,1,['resume'],['resume']
Usability,"k () override;  Intercept changes to cache operation mode and forward to cache elements. ;  ; void optimizeCacheMode (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  Intercept calls to perform automatic optimization of cache mode operation. ;  ; void printCompactTreeHook (std::ostream &, const char *) override;  Add details on cache contents when printing in tree mode. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Intercept server redirect calls. ;  ; void setClearOnRedirect (bool flag);  ; void sterilize () override;  Clear the cache payload but retain slot mapping w.r.t to normalization and integration sets. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooCacheManager< RooAbsCacheElement >;  RooCacheManager (const RooCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooCacheManager (Int_t maxSize=2);  Constructor for simple caches without RooAbsArg payload. ;  ;  RooCacheManager (RooAbsArg *owner, Int_t maxSize=2);  Constructor for simple caches with RooAbsArg derived payload. ;  ;  ~RooCacheManager () override;  Destructor. ;  ; Int_t cacheSize () const;  Return size of cache. ;  ; RooAbsCacheElement * getObj (const RooArgSet *nset, const RooArgSet *iset, Int_t *sterileIdx, const char *isetRangeName);  ; RooAbsCacheElement * getObj (const RooArgSet *nset, const RooArgSet *iset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Retrieve payload object indexed on nset,uset amd isetRangeName If sterileIdx is not null, it is set to the index of the sterile slot in cacse such a slot is recycled. ;  ; RooAbsCacheElement * getObj (const RooArgSet *nset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Getter function without integration set. ;  ; RooAbsCacheElement * getObjByIndex (Int_t index) const;  Retrieve payload object by slot index. ;  ; Int_t lastInd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:2624,simpl,simple,2624,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['simpl'],['simple']
Usability,k searching function (class TSpectrum) ;  SearchHR3.C Example to illustrate the influence of number of iterations in deconvolution in high resolution peak searching function (class TSpectrum) ;  Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlselect.C;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorit,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:154465,simpl,simple,154465,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['simpl'],['simple']
Usability,"kDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; const TMatrixDSym&covarianceMatrix() const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMultiVarGaussian.html:3333,clear,clearValueAndShapeDirty,3333,root/html532/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html532/RooMultiVarGaussian.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"kRaw (the actual filling of tessellation) is split, as the X3D viewer requires two publication passes - one to establish the full tessellation capacity for all shapes, and another to actually add them. Splitting avoids having to do the expensive tessellation on the first pass. 9.13.4.4 Shape Specific TBuffer3D Derived Classes; Currently we provide the following shape specific classes, which the GL Viewer can take advantage of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres (GL Viewer only supports solid spheres at present - cut / hollow ones will be requested as tessellated objects by client.); TBuffer3DTube - basic tube with inner/outer radius and length.; TBuffer3DTubeSeg - angle tube segment.; TBuffer3DCutTube - angle tube segment with plane cut ends. See the above example from TGeoSphere::GetBuffer3D and also equivalent functions in TGeoTube, TGeoTubeSeg and TGeoCtub. Anyone is free to add new TBuffer3D classes, but it should be clear that one or more viewers will require updating to be able to take advantage of them. Hence we only provide classes which existing viewers can benefit from. The number of native shapes in GL Viewer will be expanded in the future.; 9.13.4.5 Master / Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference frames:. fLocalFrame: indicates if any positions in the buffer (bounding box and tessellation vertexes) are in local or master (world frame).; fLocalMaster: is a standard 4x4 translation matrix (OpenGL column major ordering) for placing the object into the 3D master frame. If fLocalFrame is false, fLocalMaster should contain an identity matrix. This is set by default, and can be reset using the TBuffer3D::SetLocalMasterIdentity() method.; 9.13.4.6 Bounding Boxes; You are not obliged to complete the kBoundingBox section, as any viewer requiring one internally (GL Viewer) will build it if you do not provide. However to do this the viewer will force you to p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:411360,clear,clear,411360,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['clear'],['clear']
Usability,"kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }; pointsOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t pointsDefinition TGWin32VirtualXProxy.cxx:148; Our construction method is optimized to save memory, and differs a bit from the constraints above. In particular, the division axis is chosen as the one with the biggest spread, and the point to create the splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree; 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developed to simplify using it together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ...; ...; datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKDTree.html:4455,simpl,simplify,4455,doc/master/classTKDTree.html,https://root.cern,https://root.cern/doc/master/classTKDTree.html,1,['simpl'],['simplify']
Usability,"ke advantage of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres*; TBuffer3DTubeSeg - angle tube segment; TBuffer3DCutTube - angle tube segment with plane cut ends. OpenGL only supports solid spheres at present - cut/hollow ones will be requested tessellated.; Anyone is free to add new TBuffer3D classes, but it should be clear that the viewers require updating to be able to take advantage of them. The number of native shapes in OpenGL will be expanded over time.; BoundingBox: You are not obliged to complete this, as any viewer requiring one internally (OpenGL) will build one for you if you do not provide. However to do this the viewer will force you to provide the raw tessellation, and the resulting box will be axis aligned with the overall scene, which is non-ideal for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(), for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference frames: fLocalFrame & fLocalMaster. fLocalFrame indicates if any positions in the buffer (bounding box and tessellation vertexes) are in local or master (world frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL column major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function. Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference frame.; Add a physical placement (copy) of this logical object (described in local reference frame). The second case is very typical in geometry packages, GEANT4, where we have very large number repeated placements of relatively few logical (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:6536,simpl,simpler,6536,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,1,['simpl'],['simpler']
Usability,"ke advantage of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres*; TBuffer3DTubeSeg - angle tube segment; TBuffer3DCutTube - angle tube segment with plane cut ends. OpenGL only supports solid spheres at present - cut/hollow ones will be requested tessellated.; Anyone is free to add new TBuffer3D classes, but it should be clear that the viewers require updating to be able to take advantage of them. The number of native shapes in OpenGL will be expanded over time.; BoundingBox: You are not obliged to complete this, as any viewer requiring one internally (OpenGL) will build one for you if you do not provide. However to do this the viewer will force you to provide the raw tessellation, and the resulting box will be axis aligned with the overall scene, which is non-ideal for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(), for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference frames: fLocalFrame & fLocalMaster. fLocalFrame indicates if any positions in the buffer (bounding box and tessellation vertexes) are in local or master (world frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL column major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects. There are two cases of object addition:. Add this object as a single independent entity in the world reference frame.; Add a physical placement (copy) of this logical object (described in local reference frame). The second case is very typical in geometry packages, GEANT4, where we have very large number repeated placements of relatively few logical ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer3D.html:4470,simpl,simpler,4470,doc/master/classTBuffer3D.html,https://root.cern,https://root.cern/doc/master/classTBuffer3D.html,1,['simpl'],['simpler']
Usability,"ke sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree.Definition TTree.cxx:7881; TTree::GetPlayerTVirtualTreePlayer * GetPlayer()Load the TTreePlayer (if not already done).Definition TTree.cxx:6305; TTree::MakeProxyvirtual Int_t MakeProxy(const char *classname, const char *macrofilename=nullptr, const char *cutfilename=nullptr, const char *option=nullptr, Int_t maxUnrolling=3)Generate a skeleton analysis class for this Tree using TBranchProxy.Definition TTree.cxx:6768; TTree::kSplitCollectionOfPointers@ kSplitCollectionOfPointersDefinition TTree.h:266; TTree::fTargetMemoryRatioFloat_t fTargetMemoryRatio! Ratio for memory usage in uncompressed buffers versus actual occupancy.Definition TTree.h:146; TTree::GetIndexValuesvirtual Double_t * GetIndexValues()Definition TTree.h:522; TTree::GetListOfAliasesvirtual TList * GetListOfAliases() constDefinition TTree.h:531; TTree::ReadStreamvirtual Long64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from an input stream.Definition TTree.cxx:7615; TTree::SetDebugvirtual void SetDebug(Int_t level=1, Long64_t min=0, Long64_t max=9999999)Set the debug level and the debug range.Definition TTree.cxx:8928; TTree::fScanFieldInt_t fScanFieldNumber of runs before prompting in Scan.Definition TTree.h:92; TTree::GetWeightvirtual Double_t GetWeight() constDefinition TTree.h:584; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetFriendvirtual TTree * GetFriend(const char *) constReturn a pointer to the TTree friend whose name or alias is friendname.Definition TTree.cxx:5975; TTree::GetVarTTreeFormula * GetVar(Int_t i)Definition TTree.h:564; TTree::SetNotifyvirtual void SetNotify(TObject *obj)Sets the address of the object to be notified when the tree is loaded.Definition TTree.cxx:9231; TTree::GetMaximumvirtual Double_t GetMaximum(const char *columname)Return max",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:61696,simpl,simply,61696,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['simpl'],['simply']
Usability,"ke_shared<Browsable::RWrapper>(""root"", elem_root));; 118 ; 119 std::unique_ptr<Browsable::RHolder> rootfiles = std::make_unique<Browsable::TObjectHolder>(gROOT->GetListOfFiles(), kFALSE);; 120 auto elem_files = Browsable::RProvider::Browse(rootfiles);; 121 if (elem_files) {; 122 auto files = std::make_shared<Browsable::RWrapper>(""ROOT Files"", elem_files);; 123 files->SetExpandByDefault(true);; 124 comp->Add(files);; 125 // if there are any open files, make them visible by default; 126 if (elem_files->GetNumChilds() > 0); 127 seldir = {};; 128 }; 129 ; 130 SetTopElement(comp);; 131 ; 132 SetWorkingPath(seldir);; 133}; 134 ; 135/////////////////////////////////////////////////////////////////////; 136/// Reset all data correspondent to last request; 137 ; 138void RBrowserData::ResetLastRequestData(bool with_element); 139{; 140 fLastAllChilds = false;; 141 fLastSortedItems.clear();; 142 fLastSortMethod.clear();; 143 fLastItems.clear();; 144 if (with_element) {; 145 fLastPath.clear();; 146 fLastElement.reset();; 147 }; 148}; 149 ; 150/////////////////////////////////////////////////////////////////////////; 151/// Decompose path to elements; 152/// Returns array of names for each element in the path, first element either ""/"" or "".""; 153/// If returned array empty - it is error; 154 ; 155Browsable::RElementPath_t RBrowserData::DecomposePath(const std::string &strpath, bool relative_to_work_element); 156{; 157 Browsable::RElementPath_t arr;; 158 if (relative_to_work_element) arr = fWorkingPath;; 159 ; 160 if (strpath.empty()); 161 return arr;; 162 ; 163 auto arr2 = Browsable::RElement::ParsePath(strpath);; 164 arr.insert(arr.end(), arr2.begin(), arr2.end());; 165 return arr;; 166}; 167 ; 168/////////////////////////////////////////////////////////////////////////; 169/// Process browser request; 170 ; 171bool RBrowserData::ProcessBrowserRequest(const RBrowserRequest &request, RBrowserReply &reply); 172{; 173 auto path = fWorkingPath;; 174 path.insert(path.end(), request.pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:4646,clear,clear,4646,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['clear'],['clear']
Usability,keeps same size as canvas ; Definition at line 79 of file TRootCanvas.h. ◆ fButton. Int_t TRootCanvas::fButton. private . currently pressed button ; Definition at line 80 of file TRootCanvas.h. ◆ fCanvasContainer. TRootContainer* TRootCanvas::fCanvasContainer. private . container in canvas widget ; Definition at line 40 of file TRootCanvas.h. ◆ fCanvasID. Int_t TRootCanvas::fCanvasID. private . index in fWindows array of TGX11 ; Definition at line 78 of file TRootCanvas.h. ◆ fCanvasLayout. TGLayoutHints* TRootCanvas::fCanvasLayout. private . layout for canvas widget ; Definition at line 54 of file TRootCanvas.h. ◆ fCanvasWindow. TGCanvas* TRootCanvas::fCanvasWindow. private . canvas widget ; Definition at line 39 of file TRootCanvas.h. ◆ fDockLayout. TGLayoutHints* TRootCanvas::fDockLayout. private . layout hints for dockable frame widget ; Definition at line 72 of file TRootCanvas.h. ◆ fEditClearMenu. TGPopupMenu* TRootCanvas::fEditClearMenu. private . clear cascade submenu ; Definition at line 45 of file TRootCanvas.h. ◆ fEditMenu. TGPopupMenu* TRootCanvas::fEditMenu. private . edit menu ; Definition at line 44 of file TRootCanvas.h. ◆ fEditor. TVirtualPadEditor* TRootCanvas::fEditor. private . pointer to currently loaded pad editor ; Definition at line 76 of file TRootCanvas.h. ◆ fEditorFrame. TGCompositeFrame* TRootCanvas::fEditorFrame. private . side frame for current pad editor ; Definition at line 58 of file TRootCanvas.h. ◆ fEditorLayout. TGLayoutHints* TRootCanvas::fEditorLayout. private . layout for editor frame ; Definition at line 59 of file TRootCanvas.h. ◆ fEmbedded. Bool_t TRootCanvas::fEmbedded. private . true if embedded in any other frame (e.g. in the browser) ; Definition at line 77 of file TRootCanvas.h. ◆ fFileMenu. TGPopupMenu* TRootCanvas::fFileMenu. private . file menu ; Definition at line 42 of file TRootCanvas.h. ◆ fFileSaveMenu. TGPopupMenu* TRootCanvas::fFileSaveMenu. private . save cascade submenu ; Definition at line 43 of file TRootCanv,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootCanvas.html:55224,clear,clear,55224,doc/master/classTRootCanvas.html,https://root.cern,https://root.cern/doc/master/classTRootCanvas.html,1,['clear'],['clear']
Usability,"knots (see BuildCoeff) for more on this ;  CTSplinePolyBase class for TSpline knot ;  CTSplinePoly3Class for TSpline3 knot ;  CTSplinePoly5Class for TSpline5 knot ;  CTSPlot;  CTSQLClassColumnInfo;  CTSQLClassInfoContains information about tables specific to one class and version ;  CTSQLColumnData;  CTSQLColumnInfo;  CTSQLFileAccess an SQL db via the TFile interface ;  CTSQLiteResult;  CTSQLiteRow;  CTSQLiteServer;  CTSQLiteStatement;  CTSQLMonitoringWriter;  CTSQLObjectDataTSQLObjectData is used in TBufferSQL2 class in reading procedure ;  CTSQLObjectDataPoolXML object keeper class ;  CTSQLObjectInfoInfo (classname, version) about object in database ;  CTSQLResult;  CTSQLRow;  CTSQLServer;  CTSQLStatement;  CTSQLStructureThis is hierarchical structure, which is created when data is written by TBufferSQL2 ;  CTSQLTableData;  CTSQLTableInfo;  CTSSLSocket;  CTStatisticStatistical variable, defined by its mean and variance (RMS) ;  CTStatsFeedbackUtility class to display PROOF stats feedback histos during queries ;  CTStatusThis class holds the status of an ongoing operation and collects error messages ;  CTStdExceptionHandler;  CTStopwatchStopwatch class ;  CTStorageStorage manager ;  CTStreamerArtificial;  CTStreamerBase;  CTStreamerBasicPointer;  CTStreamerBasicType;  CTStreamerElement;  ►CTStreamerInfoDescribe Streamer information for one class version ;  CTCompInfo;  CTPointerCollectionAdapter;  CTStreamerLoop;  CTStreamerObject;  CTStreamerObjectAny;  CTStreamerObjectAnyPointer;  CTStreamerObjectPointer;  CTStreamerSTL;  CTStreamerSTLstring;  CTStreamerString;  ►CTStringBasic string class ;  CLongStr_t;  CRawStr_t;  CRep_t;  CShortStr_t;  CUStr_t;  CTStringLongATTENTION: this class is obsolete ;  CTStringTokenProvides iteration through tokens of a given string ;  CTStructNode;  CTStructNodeEditor;  CTStructNodeProperty;  CTStructViewer;  CTStructViewerGUI;  CTStyleTStyle objects may be created to define special styles ;  CTStyleDialog;  CTStyleManager;  CTStylePr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:206344,feedback,feedback,206344,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['feedback'],['feedback']
Usability,"known branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:132456,learn,learning,132456,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['learn'],['learning']
Usability,"l . Close the current gVirtualX pixmap. ; Implements TVirtualPadPainter.; Definition at line 333 of file TPadPainter.cxx. ◆ DrawBox(). void TPadPainter::DrawBox ; (; Double_t ; x1, . Double_t ; y1, . Double_t ; x2, . Double_t ; y2, . EBoxMode ; mode . ). overridevirtual . Paint a simple box. ; Implements TVirtualPadPainter.; Definition at line 390 of file TPadPainter.cxx. ◆ DrawFillArea() [1/2]. void TPadPainter::DrawFillArea ; (; Int_t ; n, . const Double_t * ; x, . const Double_t * ; y . ). overridevirtual . Paint filled area. ; Implements TVirtualPadPainter.; Definition at line 411 of file TPadPainter.cxx. ◆ DrawFillArea() [2/2]. void TPadPainter::DrawFillArea ; (; Int_t ; n, . const Float_t * ; x, . const Float_t * ; y . ). overridevirtual . Paint filled area. ; Implements TVirtualPadPainter.; Definition at line 425 of file TPadPainter.cxx. ◆ DrawLine(). void TPadPainter::DrawLine ; (; Double_t ; x1, . Double_t ; y1, . Double_t ; x2, . Double_t ; y2 . ). overridevirtual . Paint a simple line. ; Implements TVirtualPadPainter.; Definition at line 360 of file TPadPainter.cxx. ◆ DrawLineNDC(). void TPadPainter::DrawLineNDC ; (; Double_t ; u1, . Double_t ; v1, . Double_t ; u2, . Double_t ; v2 . ). overridevirtual . Paint a simple line in normalized coordinates. ; Implements TVirtualPadPainter.; Definition at line 375 of file TPadPainter.cxx. ◆ DrawPixels(). void TPadPainter::DrawPixels ; (; const unsigned char * ; pixelData, . UInt_t ; width, . UInt_t ; height, . Int_t ; dstX, . Int_t ; dstY, . Bool_t ; enableAlphaBlending . ). overridevirtual . Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. ; Implements TVirtualPadPainter.; Definition at line 351 of file TPadPainter.cxx. ◆ DrawPolyLine() [1/2]. void TPadPainter::DrawPolyLine ; (; Int_t ; n, . const Double_t * ; x, . const Double_t * ; y . ). overridevirtual . Paint Polyline. ; Implements TVirtualPadPainter.; Definition at line 438 of file TPadPainter.cxx. ◆ DrawPolyLine() [2/2]. void TPadPainter::DrawPolyLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPadPainter.html:8922,simpl,simple,8922,doc/master/classTPadPainter.html,https://root.cern,https://root.cern/doc/master/classTPadPainter.html,1,['simpl'],['simple']
Usability,"l == TMath::QuietNaN() ) { x = TMath::QuietNaN(); y = TMath::QuietNaN(); return;}; 1216 ; 1217 if (!rng) rng = gRandom;; 1218 Double_t r1 = rng->Rndm();; 1219 Int_t ibin = TMath::BinarySearch(nbins,fIntegral,(Double_t) r1);; 1220 Int_t biny = ibin/nbinsx;; 1221 Int_t binx = ibin - nbinsx*biny;; 1222 x = fXaxis.GetBinLowEdge(binx+1);; 1223 if (r1 > fIntegral[ibin]) x +=; 1224 fXaxis.GetBinWidth(binx+1)*(r1-fIntegral[ibin])/(fIntegral[ibin+1] - fIntegral[ibin]);; 1225 y = fYaxis.GetBinLowEdge(biny+1) + fYaxis.GetBinWidth(biny+1)*rng->Rndm();; 1226}; 1227 ; 1228 ; 1229////////////////////////////////////////////////////////////////////////////////; 1230/// Fill the array stats from the contents of this histogram; 1231/// The array stats must be correctly dimensioned in the calling program.; 1232/// ~~~ {.cpp}; 1233/// stats[0] = sumw; 1234/// stats[1] = sumw2; 1235/// stats[2] = sumwx; 1236/// stats[3] = sumwx2; 1237/// stats[4] = sumwy; 1238/// stats[5] = sumwy2; 1239/// stats[6] = sumwxy; 1240/// ~~~; 1241///; 1242/// If no axis-subranges are specified (via TAxis::SetRange), the array stats; 1243/// is simply a copy of the statistics quantities computed at filling time.; 1244/// If sub-ranges are specified, the function recomputes these quantities; 1245/// from the bin contents in the current axis ranges.; 1246///; 1247/// Note that the mean value/StdDev is computed using the bins in the currently; 1248/// defined ranges (see TAxis::SetRange). By default the ranges include; 1249/// all bins from 1 to nbins included, excluding underflows and overflows.; 1250/// To force the underflows and overflows in the computation, one must; 1251/// call the static function TH1::StatOverflows(kTRUE) before filling; 1252/// the histogram.; 1253 ; 1254void TH2::GetStats(Double_t *stats) const; 1255{; 1256 if (fBuffer) ((TH2*)this)->BufferEmpty();; 1257 ; 1258 if ((fTsumw == 0 && fEntries > 0) || fXaxis.TestBit(TAxis::kAxisRange) || fYaxis.TestBit(TAxis::kAxisRange)) {; 1259 std::fill",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:49997,simpl,simply,49997,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['simpl'],['simply']
Usability,"l RooFitResult*chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:3619,clear,clearValueDirty,3619,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,2,['clear'],['clearValueDirty']
Usability,"l as for raw-data visualization.; Papers describing Eve (older ones still using the old name - Reve):. [EVE - Event Visualization Environment of the ROOT framework] (http://pos.sissa.it//archive/conferences/070/103/ACAT08_103.pdf) presented at ACAT 2008.; [Event Visualization Environment of the ALICE experiment] (http://indico.cern.ch/contributionDisplay.py?contribId=25&confId=13356) presented at ROOT Workshop 2007.; [Raw-data display and visual reconstruction validation in ALICE] (http://indico.cern.ch/contributionDisplay.py?contribId=442&sessionId=23&confId=3580) presented at CHEP 2007. Eve is built on top of ROOT's GUI, GL and GED infrastructure and delivers the following main features:. Base-classes for representation of visual objects that can be presented in list-tree views, object-editors and rendered via OpenGL (TEveElement and sub-classes).; Application manager class TEveManager for top-level management of elements, GUI components, geometries and events;; Classes for presentation of full TGeo geometries (TEveGeoNode and TEveGeoTopNode) as well as of simplifed geometries via extraction of shape-data (TEveGeoShape). CMS geometry. Classes for presentation of trajectories or tracks (TEveTrack, TEveTrackPropagator) and hits or clusters (TEvePointSet, TEvePointSetArray). A simulated ALICE pp@14TeV event in 3D. Base-classes for presentation of raw-data or digits (TEveDigitSet, TEveQuadSet and TEveBoxSet). A collection of objects can be assigned common signal-to-color mapping (TEveRGBAPelette) and surrounding frame (TEveFrameBox). Hexagonal and rectangular digits. Base-classes for 2D projections with dynamically controllable fish-eye magnification of the vertex region (TEveProjectionManager and TEveProjection). Tracks, points and geometries can be projected automatically. R-phi and Rho-z projections are currently supported. A r-phi projection with fish-eye transformation of a simulated ALICE pp@14TeV event. TriangleSet class for presentation of generic triangle mesh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__TEve.html:1577,simpl,simplifed,1577,doc/master/group__TEve.html,https://root.cern,https://root.cern/doc/master/group__TEve.html,1,['simpl'],['simplifed']
Usability,l container. ; Definition at line 193 of file TGDockableFrame.cxx. Member Function Documentation. ◆ Class(). static TClass * TGUndockedFrame::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGUndockedFrame::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGUndockedFrame::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 78 of file TGDockableFrame.h. ◆ CloseWindow(). void TGUndockedFrame::CloseWindow ; (; ). overridevirtual . Close undocked frame (called via WM close button). ; Reimplemented from TGMainFrame.; Definition at line 213 of file TGDockableFrame.cxx. ◆ DeclFileName(). static const char * TGUndockedFrame::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 78 of file TGDockableFrame.h. ◆ FixSize(). void TGUndockedFrame::FixSize ; (; ). Fix the size of the undocked frame so it cannot be changed via the WM. ; Definition at line 203 of file TGDockableFrame.cxx. ◆ IsA(). TClass * TGUndockedFrame::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGTransientFrame.; Definition at line 78 of file TGDockableFrame.h. ◆ operator=(). TGUndockedFrame & TGUndockedFrame::operator= ; (; const TGUndockedFrame & ; ). privatedelete . ◆ Streamer(). void TGUndockedFrame::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGTransientFrame. ◆ StreamerNVirtual(). void TGUndockedFrame::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 78 of file TGDockableFrame.h. Member Data Documentation. ◆ fDockable. TGDockableFrame* TGUndockedFrame::fDockable. protected . orignal dockable frame ; Definition at line 69 of file TGDockableFrame.h. Libraries for TGUndockedFrame:. [legend]; The documentation for this class was generated from t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGUndockedFrame.html:37893,undo,undocked,37893,doc/master/classTGUndockedFrame.html,https://root.cern,https://root.cern/doc/master/classTGUndockedFrame.html,1,['undo'],['undocked']
Usability,"l each element of the matrix A and write the result into A. ;  ; static void ReconstructInput (TMatrixT< AReal > &compressedInput, TMatrixT< AReal > &reconstructedInput, TMatrixT< AReal > &fWeights);  ; static void SoftmaxAE (TMatrixT< AReal > &A);  ; static void SqrtElementWise (TMatrixT< AReal > &A);  Square root each element of the matrix A and write the result into A. ;  ; static void SquareElementWise (TMatrixT< AReal > &A);  Square each element of the matrix A and write the result into A. ;  ; static void SumColumns (TMatrixT< AReal > &B, const TMatrixT< AReal > &A);  Sum columns of (m x n) matrix A and write the results into the first m elements in A. ;  ; static void UpdateParams (TMatrixT< AReal > &x, TMatrixT< AReal > &tildeX, TMatrixT< AReal > &y, TMatrixT< AReal > &z, TMatrixT< AReal > &fVBiases, TMatrixT< AReal > &fHBiases, TMatrixT< AReal > &fWeights, TMatrixT< AReal > &VBiasError, TMatrixT< AReal > &HBiasError, AReal learningRate, size_t fBatchSize);  ; static void UpdateParamsLogReg (TMatrixT< AReal > &input, TMatrixT< AReal > &output, TMatrixT< AReal > &difference, TMatrixT< AReal > &p, TMatrixT< AReal > &fWeights, TMatrixT< AReal > &fBiases, AReal learningRate, size_t fBatchSize);  ; Forward Propagation; Low-level functions required for the forward propagation of activations through the network. . static void MultiplyTranspose (TMatrixT< Scalar_t > &output, const TMatrixT< Scalar_t > &input, const TMatrixT< Scalar_t > &weights);  Matrix-multiply input with the transpose of weights and write the results into output. ;  ; static void AddRowWise (TMatrixT< Scalar_t > &output, const TMatrixT< Scalar_t > &biases);  Add the vectors biases row-wise to the matrix output. ;  ; Backward Propagation; Low-level functions required for the forward propagation of activations through the network. . static void Backward (TMatrixT< Scalar_t > &activationGradientsBackward, TMatrixT< Scalar_t > &weightGradients, TMatrixT< Scalar_t > &biasGradients, TMatrixT< Scalar_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html:3679,learn,learningRate,3679,doc/master/classTMVA_1_1DNN_1_1TReference.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html,2,['learn'],['learningRate']
Usability,"l entry).; When using SortBasketsByEntry the baskets with the lowest starting entry are written first. (i.e. the baskets are sorted by the index/number of the first entry they contain). This means that on the file the baskets will be in the order in which they will be needed when reading the whole tree sequentially.; For examples of CloneTree, see tutorials:. copytree.C: A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1; copytree2.C: A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1 . Reimplemented in TNtuple.; Definition at line 3139 of file TTree.cxx. ◆ CopyAddresses(). void TTree::CopyAddresses ; (; TTree * ; tree, . bool ; undo = false . ). virtual . Set branch addresses of passed tree equal to ours. ; If undo is true, reset the branch addresses instead of copying them. This ensures 'separation' of a cloned tree from its original. ; Definition at line 3299 of file TTree.cxx. ◆ CopyEntries(). Long64_t TTree::CopyEntries ; (; TTree * ; tree, . Long64_t ; nentries = -1, . Option_t * ; option = """", . bool ; needCopyAddresses = false . ). virtual . Copy nentries from given tree to this tree. ; This routines assumes that the branches that intended to be copied are already connected. The typical case is that this tree was created using tree->CloneTree(0).; By default copy all entries.; Returns number of bytes copied to this tree.; If 'option' contains the word 'fast' and nentries is -1, the cloning will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).; When 'fast' is specified, 'option' can also contains a sorting order for the baskets in the output file.; There are currently 3 supported sorting order:. SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsBy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:106517,undo,undo,106517,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['undo'],['undo']
Usability,l functions which do not use function derivatives. More...;  ; class  GSLRootFinderDeriv;  Base class for GSL Root-Finding algorithms for one dimensional functions which use function derivatives. More...;  ; class  GSLRootFSolver;  Root-Finder implementation class using GSL. More...;  ; class  GSLSimAnFunc;  GSLSimAnFunc class description. More...;  ; class  GSLSimAnMinimizer;  GSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL. More...;  ; class  GSLSimAnnealing;  GSLSimAnnealing class for performing a simulated annealing search of a multidimensional function. More...;  ; struct  GSLSimAnParams;  structure holding the simulated annealing parameters More...;  ; class  GSLVegasIntegrationWorkspace;  workspace for VEGAS More...;  ; class  IBaseFunctionMultiDimTempl;  Documentation for the abstract class IBaseFunctionMultiDim. More...;  ; class  IBaseFunctionOneDim;  Interface (abstract class) for generic functions objects of one-dimension Provides a method to evaluate the function given a value (simple double) by implementing operator() (const double ). More...;  ; class  IBaseParam;  Documentation for the abstract class IBaseParam. More...;  ; class  IGradientFunctionMultiDimTempl;  Interface (abstract class) for multi-dimensional functions providing a gradient calculation. More...;  ; class  IGradientFunctionOneDim;  Interface (abstract class) for one-dimensional functions providing a gradient calculation. More...;  ; class  IGradientMultiDimTempl;  ; class  IMinimizer1D;  Interface class for numerical methods for one-dimensional minimization. More...;  ; class  IntegrandTransform;  Auxiliary inner class for mapping infinite and semi-infinite integrals. More...;  ; class  IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  IntegratorOneDim;  User Class for performing numerical integra,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:16463,simpl,simple,16463,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['simpl'],['simple']
Usability,"l list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:2982,clear,clearShapeDirty,2982,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,1,['clear'],['clearShapeDirty']
Usability,"l user and/or internal Minuit representation of the parameters and errors; transformation internal <-> external on demand; ;  CMnUserTransformationClass dealing with the transformation between user specified parameters (external) and internal parameters used for minimization ;  CMnVectorTransform;  CModularFunctionMinimizerBase common class providing the API for all the minimizer Various Minimize methods are provided varying on the type of FCN function passesd and on the objects used for the parameters ;  CMPIProcess;  CMPITerminate;  CNegativeG2LineSearchIn case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive ;  CNumerical2PGradientCalculatorClass performing the numerical gradient calculation ;  CParametricFunctionFunction which has parameters ;  CScanBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CScanMinimizerClass implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class ;  CSimplexBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CSimplexMinimizerClass implementing the required methods for a minimization using Simplex ;  CSimplexParametersClass describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process ;  CSimplexSeedGeneratorGenerate Simplex starting point (state) ;  CSinParameterTransformationClass for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one ;  CSqrtLowParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CSqrtUpParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CStackAllocatorStackAllocator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:69893,simpl,simplex,69893,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['simpl'],['simplex']
Usability,"l void InitImpl (RNTupleModel &model)=0;  ; RSealedPage SealPage (const RPage &page, const RColumnElementBase &element);  Helper for streaming a page. ;  ;  Protected Member Functions inherited from ROOT::Experimental::Internal::RPageStorage; void WaitForAllTasks ();  . Protected Attributes; std::unique_ptr< RNTupleCompressor > fCompressor;  Helper to zip pages and header/footer; includes a 16MB (kMAXZIPBUF) zip buffer. ;  ; std::unique_ptr< RNTupleWriteOptions > fOptions;  ;  Protected Attributes inherited from ROOT::Experimental::Internal::RPageStorage; Detail::RNTupleMetrics fMetrics;  ; std::string fNTupleName;  ; std::unique_ptr< RPageAllocator > fPageAllocator;  For the time being, we will use the heap allocator for all sources and sinks. This may change in the future. ;  ; RTaskScheduler * fTaskScheduler = nullptr;  . Private Attributes; bool fIsInitialized = false;  Flag if sink was initialized. ;  ; std::vector< Callback_t > fOnDatasetCommitCallbacks;  ; std::vector< unsigned char > fSealPageBuffer;  Used as destination buffer in the simple SealPage overload. ;  ; RWritePageMemoryManager fWritePageMemoryManager;  Used in ReservePage to maintain the page buffer budget. ;  . Additional Inherited Members;  Static Public Attributes inherited from ROOT::Experimental::Internal::RPageStorage; static constexpr std::size_t kNBytesPageChecksum = sizeof(std::uint64_t);  The page checksum is a 64bit xxhash3. ;  . #include <ROOT/RPageStorage.hxx>. Inheritance diagram for ROOT::Experimental::Internal::RPageSink:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Callback_t. using ROOT::Experimental::Internal::RPageSink::Callback_t = std::function<void(RPageSink &)>. Definition at line 258 of file RPageStorage.hxx. Constructor & Destructor Documentation. ◆ RPageSink() [1/3]. ROOT::Experimental::Internal::RPageSink::RPageSink ; (; std::string_view ; ntupleName, . const RNTupleWriteOptions & ; opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html:6662,simpl,simple,6662,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html,1,['simpl'],['simple']
Usability,"l, . Long64_t ; processed . ). Update progress bar and status labels. ; Definition at line 2745 of file TSessionViewer.cxx. ◆ ResetProgressDialog(). void TSessionQueryFrame::ResetProgressDialog ; (; const char * ; selec, . Int_t ; files, . Long64_t ; first, . Long64_t ; entries . ). Reset progress frame information fields. ; Definition at line 2905 of file TSessionViewer.cxx. ◆ Streamer(). void TSessionQueryFrame::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGCompositeFrame. ◆ StreamerNVirtual(). void TSessionQueryFrame::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 448 of file TSessionViewer.h. ◆ UpdateButtons(). void TSessionQueryFrame::UpdateButtons ; (; TQueryDescription * ; desc). Update buttons state for the current query status. ; Definition at line 3229 of file TSessionViewer.cxx. ◆ UpdateHistos(). void TSessionQueryFrame::UpdateHistos ; (; TList * ; objs). Update feedback histograms. ; Definition at line 2572 of file TSessionViewer.cxx. ◆ UpdateInfos(). void TSessionQueryFrame::UpdateInfos ; (; ). Update query information (header) text view. ; Definition at line 3337 of file TSessionViewer.cxx. Member Data Documentation. ◆ fBtnAbort. TGTextButton* TSessionQueryFrame::fBtnAbort. private . Definition at line 386 of file TSessionViewer.h. ◆ fBtnFinalize. TGTextButton* TSessionQueryFrame::fBtnFinalize. private . Definition at line 384 of file TSessionViewer.h. ◆ fBtnRetrieve. TGTextButton* TSessionQueryFrame::fBtnRetrieve. private . Definition at line 388 of file TSessionViewer.h. ◆ fBtnSave. TGTextButton* TSessionQueryFrame::fBtnSave. private . Definition at line 389 of file TSessionViewer.h. ◆ fBtnShowLog. TGTextButton* TSessionQueryFrame::fBtnShowLog. private . Definition at line 387 of file TSessionViewer.h. ◆ fBtnStop. TGTextButton* TSessionQueryFrame::fBtnStop. private . Definition at line 385 of file TSessionViewer.h. ◆ fBtnSubmit. TGTextButton* T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionQueryFrame.html:38258,feedback,feedback,38258,doc/master/classTSessionQueryFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionQueryFrame.html,1,['feedback'],['feedback']
Usability,"l, TClass* newcl); voidWriteItems(int nElements, TBuffer& b). private:. TEmulatedCollectionProxy&operator=(const TEmulatedCollectionProxy&). Data Members; public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t); static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISTSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBOOL_t; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsAssociative; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsEmulated; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kNeedDelete. protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tTGenCollectionProxy::fCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tTGenCollectionProxy::fConstructContainer accessors: block construct; map<string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tTGenCollectionProxy::fDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*TGenCollectionProxy::fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tTGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::fFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::fFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::fFunctionDeleteI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEmulatedCollectionProxy.html:4896,clear,clear,4896,root/html602/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TEmulatedCollectionProxy.html,2,['clear'],['clear']
Usability,"l,int> type = GetType(name);; 105 fUseDerivAlgo = type.first;; 106 fType = type.second;; 107}; 108 ; 109 ; 110int GSLMultiRootFinder::AddFunction(const ROOT::Math::IMultiGenFunction & func) {; 111 // add a new function in the vector; 112 ROOT::Math::IMultiGenFunction * f = func.Clone();; 113 if (!f) return 0;; 114 fFunctions.push_back(f);; 115 return fFunctions.size();; 116}; 117 ; 118void GSLMultiRootFinder::ClearFunctions() {; 119 // clear the function list; 120 for (unsigned int i = 0; i < fFunctions.size(); ++i) {; 121 if (fFunctions[i] != nullptr ) delete fFunctions[i];; 122 fFunctions[i] = nullptr;; 123 }; 124 fFunctions.clear();; 125}; 126 ; 127void GSLMultiRootFinder::Clear() {; 128 // clear the function list and the solver; 129 ClearFunctions();; 130 if (fSolver) Clear();; 131 fSolver = nullptr;; 132}; 133 ; 134 ; 135const double * GSLMultiRootFinder::X() const {; 136 // return x; 137 return (fSolver != nullptr) ? fSolver->X() : nullptr;; 138}; 139const double * GSLMultiRootFinder::Dx() const {; 140 // return x; 141 return (fSolver != nullptr) ? fSolver->Dx() : nullptr;; 142}; 143const double * GSLMultiRootFinder::FVal() const {; 144 // return x; 145 return (fSolver != nullptr) ? fSolver->FVal() : nullptr;; 146}; 147const char * GSLMultiRootFinder::Name() const {; 148 // get GSL name; 149 return (fSolver != nullptr) ? fSolver->Name().c_str() : """";; 150}; 151 ; 152// bool GSLMultiRootFinder::AddFunction( const ROOT::Math::IMultiGenFunction & func) {; 153// // clone and add function to the list; 154// // If using a derivative algorithm the function is checked if it implements; 155// // the gradient interface. If this is not the case the type is set to non-derivatibe algo; 156// ROOT::Math::IGenMultiFunction * f = func.Clone();; 157// if (f != 0) return false;; 158// if (fUseDerivAlgo) {; 159// bool gradFunc = (dynamic_cast<ROOT::Math::IMultiGradFunction *> (f) != 0 );; 160// if (!gradFunc) {; 161// MATH_ERROR_MSG(""GSLMultiRootFinder::AddFunction"",""Function do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html:4096,clear,clear,4096,doc/master/GSLMultiRootFinder_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html,2,['clear'],['clear']
Usability,"l->GetClassPointer()->CanSplit()); 2428 {; 2429 continue;; 2430 }; 2431 }; 2432 if (nextel->GetOffset() == TStreamerInfo::kMissing) {; 2433 // This element will be 'skipped', it's TBranchElement's fObject will null; 2434 // and thus can not be used to execute the artificial StreamerElements; 2435 continue;; 2436 }; 2437 if (nextel->IsA() != TStreamerArtificial::Class(); 2438 || nextel->GetType() == TStreamerInfo::kCacheDelete ) {; 2439 continue;; 2440 }; 2441 // NOTE: We should verify that the rule's source are 'before'; 2442 // or 'at' this branch.; 2443 // fprintf(stderr,""%s/%d[%zu] pushd %zu %s\n"",GetName(),fID,fIDs.size(),i,nextel->GetName());; 2444 fNewIDs.push_back(i);; 2445 fNewIDs.back().fElement = nextel;; 2446 fNewIDs.back().fInfo = fInfo;; 2447 }; 2448 } else if (elt && offset==TStreamerInfo::kMissing) {; 2449 // Still re-assign fID properly.; 2450 fNewIDs.clear();; 2451 size_t ndata = fInfo->GetNelement();; 2452 for (size_t i = 0; i < ndata; ++i) {; 2453 if (fInfo->GetElement(i) == elt) {; 2454 fID = i;; 2455 break;; 2456 }; 2457 }; 2458 } else {; 2459 // We have not even found the element .. this is strange :(; 2460 // fNewIDs.clear();; 2461 // fID = -3;; 2462 // SetBit(kDoNotProcess);; 2463 }; 2464 if (fOnfileObject==nullptr && (fType==31 || fType==41 || (0 <= fType && fType <=2) ) && fInfo->GetNelement(); 2465 && fInfo->GetElement(0)->GetType() == TStreamerInfo::kCacheNew); 2466 {; 2467 SetOnfileObject(fInfo);; 2468 }; 2469 }; 2470 if (fType == 3 || fType == 4 || (fType == 0 && fID == -2) || fType == 2) {; 2471 // Need to add the rule targeting transient members.; 2472 TStreamerInfo *localInfo = fInfo;; 2473 if (fType == 3 || fType == 4) {; 2474 // Don't we have real version information?; 2475 // Not unless there is a subbranch with a non-split element of the class.; 2476 // Search for the correct version.; 2477 localInfo = FindOnfileInfo(fClonesClass, fBranches);; 2478 }; 2479 ; 2480 TString prefix(GetFullName());; 2481 if (fType == 2 && fID >= 0) {;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:87723,clear,clear,87723,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['clear'],['clear']
Usability,"l; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreechoose at each node splitting a random set of variables; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; Int_tfUseNvarsthe number of variables used in randomised trees;; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseSearchTreecut scan done with binary trees or simple event loop.; vector<Double_t>fVariableImportancethe relative importance of the different variables; static const Int_tfgDebugLeveldebug level determining some printout/control plots etc.; static const Int_tfgRandomSeedset nonzero for debugging and zero for random seeds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DecisionTree(); default constructor using the GiniIndex as separation criterion,; no restrictions on minium number of events in a leave note or the; separation gain in the node splitting. DecisionTree(TMVA::SeparationBase* sepType, Float_t minSize, Int_t nCuts, TMVA::DataSetInfo* = __null, UInt_t cls = 0, Bool_t randomisedTree = kFALSE, Int_t useNvars = 0, Bool_t usePoissonNvars = kFALSE, UInt_t nMaxDepth = 9999999, Int_t iSeed = fgRandomSeed, Float_t purityLimit = 0.5, Int_t treeID = 0); constructor specifying the separation type, the min number of; events in a no that is still subjected to furthe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTree.html:8350,simpl,simple,8350,root/html602/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTree.html,2,['simpl'],['simple']
Usability,"l</A>.; 91 ; 92 ; 93@ingroup Integration; 94 ; 95*/; 96 ; 97 ; 98class IntegratorOneDim {; 99 ; 100public:; 101 ; 102 typedef IntegrationOneDim::Type Type; // for the enumerations defining the types; 103 ; 104 // constructors; 105 ; 106 ; 107 /**; 108 Constructor of one dimensional Integrator, default type is adaptive; 109 ; 110 @param type integration type (adaptive, non-adaptive, etc..); 111 @param absTol desired absolute Error; 112 @param relTol desired relative Error; 113 @param size maximum number of sub-intervals; 114 @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type); 115 ; 116 Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); 117 Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); 118 lower rules are indicated for singular functions while higher for smooth functions to get better accuracies; 119 ; 120 NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions; 121 */; 122 explicit; 123 IntegratorOneDim(IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = -1, double relTol = -1, unsigned int size = 0, unsigned int rule = 0) :; 124 fIntegrator(nullptr), fFunc(nullptr); 125 {; 126 fIntegrator = CreateIntegrator(type, absTol, relTol, size, rule);; 127 }; 128 ; 129 /**; 130 Constructor of one dimensional Integrator passing a function interface; 131 ; 132 @param f integration function (1D interface). It is copied inside; 133 @param type integration type (adaptive, non-adaptive, etc..); 134 @param absTol desired absolute tolerance. The algorithm will stop when either the absolute OR the relative tolerance are satisfied.; 135 @param relTol desired relative tolerance; 136 @param size maximum number of sub-intervals; 137 @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Integrator_8h_source.html:4155,simpl,simple,4155,doc/master/Integrator_8h_source.html,https://root.cern,https://root.cern/doc/master/Integrator_8h_source.html,1,['simpl'],['simple']
Usability,"lFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 144 of file TGProgressBar.h. ◆ DoRedraw(). void TGVProgressBar::DoRedraw ; (; ). overrideprotectedvirtual . Draw vertical progress bar. ; Implements TGProgressBar.; Definition at line 359 of file TGProgressBar.cxx. ◆ GetDefaultSize(). TGDimension TGVProgressBar::GetDefaultSize ; (; ); const. inlineoverridevirtual . std::cout << fWidth << ""x"" << fHeight << std::endl; ; Reimplemented from TGFrame.; Definition at line 138 of file TGProgressBar.h. ◆ IsA(). TClass * TGVProgressBar::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGProgressBar.; Definition at line 144 of file TGProgressBar.h. ◆ Percent(). void TGVProgressBar::Percent ; (; Bool_t ; ). inlineoverridevirtual . Reimplemented from TGProgressBar.; Definition at line 142 of file TGProgressBar.h. ◆ SavePrimitive(). void TGVProgressBar::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a vertical progress bar as a C++ statement(s) on output stream out. ; Reimplemented from TGProgressBar.; Definition at line 438 of file TGProgressBar.cxx. ◆ ShowPos(). void TGVProgressBar::ShowPos ; (; Bool_t ; ). inlineoverridevirtual . Reimplemented from TGProgressBar.; Definition at line 141 of file TGProgressBar.h. ◆ Streamer(). void TGVProgressBar::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGProgressBar. ◆ StreamerNVirtual(). void TGVProgressBar::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 144 of file TGProgressBar.h. Libraries for TGVProgressBar:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGProgressBar.h; gui/gui/src/TGProgressBar.cxx. TGVProgressBar. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:41 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGVProgressBar.html:33466,progress bar,progress bar,33466,doc/master/classTGVProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGVProgressBar.html,1,['progress bar'],['progress bar']
Usability,"lX. Font_t GetTextFont() const; Delegate to gVirtualX. Float_t GetTextSize() const; Delegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); Paint te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPadPainter.html:5200,simpl,simple,5200,root/html528/TPadPainter.html,https://root.cern,https://root.cern/root/html528/TPadPainter.html,3,['simpl'],['simple']
Usability,"l_t JoinProcess(TList* workers); Not implemented: meaningful only in the remote player. Returns kFALSE. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(Bool_t savememvalues = kFALSE); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); Update automatic binning parameters for given object ""name"". TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet (may not be used in this class). void SetupFeedback(); Set up feedback (may not be used in this class). void StopFeedback(); Stop feedback (may not be used in this class). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (may not be used in this class). void HandleGetTreeHeader(TMessage* mess); Handle tree header request. void HandleRecvHisto(TMessage* mess); Receive histo from slave. Int_t DrawCanvas(TObject* obj); Draw the object if it is a canvas.; Return 0 in case of success, 1 if it is not a canvas or libProofDraw; is not available. Int_t GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); Parse the arguments from var, sel and opt and fill the selector and; object name accordingly.; Return 0 in case of success, 1 if libProofDraw is not available. void FeedBackCanvas(const char* name, Bool_t create); Create/destroy a named canvas for feedback. Long64_t GetCacheSize(); Return the size in bytes of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:20905,feedback,feedback,20905,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,2,['feedback'],['feedback']
Usability,"l_t ShouldImport(TEveElement* el); Returns true if element el should be imported. Behaviour depends on the value of the fImportEmpty member:; false - el or any of its children must be projectable (default);; true - always import. void UpdateDependentElsAndScenes(TEveElement* root); Update dependent elements' bounding box and mark scenes; containing element root or its children as requiring a repaint. TEveElement* ImportElementsRecurse(TEveElement* el, TEveElement* parent); If el is TEveProjectable add projected instance else add plain; TEveElementList to parent. Call the same function on el's; children. Returns the projected replica of el. Can be 0, if el and none of; its children are projectable. TEveElement* ImportElements(TEveElement* el, TEveElement* ext_list = 0); Recursively import elements and apply projection to the newly; imported objects. If ext_list is not 0 the new element is also added to the list.; This simplifies construction of complex views where projected; elements are distributed into several scenes for optimization of; updates and rendering. Returns the projected replica of el. Can be 0, if el and none of; its children are projectable. TEveElement* SubImportElements(TEveElement* el, TEveElement* proj_parent); Recursively import elements and apply projection to the newly; imported objects. The proj_parent argument should be a projected replica of parent; of element 'el'. This allows to insert projected children of; a given element when they are added after the projection has; been already performed on the parent.; This is called from TEveElement::ProjectChild(). Returns the projected replica of el. Can be 0, if el and none of; its children are projectable. Int_t SubImportChildren(TEveElement* el, TEveElement* proj_parent); Recursively import childer elements of el and apply projection; to the newly imported objects. The proj_parent argument should be a projected replica of; element 'el'. This allows to insert projected children of; a given element ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveProjectionManager.html:22919,simpl,simplifies,22919,root/html528/TEveProjectionManager.html,https://root.cern,https://root.cern/root/html528/TEveProjectionManager.html,6,['simpl'],['simplifies']
Usability,"l_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_thasChanged(Bool_t clearState); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooChangeTracker.html:15113,clear,clearState,15113,root/html530/RooChangeTracker.html,https://root.cern,https://root.cern/root/html530/RooChangeTracker.html,2,['clear'],['clearState']
Usability,"l_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_thasChanged(Bool_t clearState); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChangeTracker.html:14807,clear,clearState,14807,root/html526/RooChangeTracker.html,https://root.cern,https://root.cern/root/html526/RooChangeTracker.html,2,['clear'],['clearState']
Usability,"lag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBoxEditor.html:21445,undo,undoing,21445,root/html534/TGeoBBoxEditor.html,https://root.cern,https://root.cern/root/html534/TGeoBBoxEditor.html,1,['undo'],['undoing']
Usability,"lass More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. Mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:6552,simpl,simple,6552,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,3,['simpl'],['simple']
Usability,"lass Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t > Class Template Reference. ; template<typename Architecture_t, typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>>; class TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >Adam Optimizer class. ; This class represents the Adam Optimizer. ; Definition at line 45 of file Adam.h. Public Types; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  ;  Public Types inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  . Public Member Functions;  TAdam (DeepNet_t &deepNet, Scalar_t learningRate=0.001, Scalar_t beta1=0.9, Scalar_t beta2=0.999, Scalar_t epsilon=1e-7);  Constructor. ;  ;  ~TAdam ()=default;  Destructor. ;  ; Scalar_t GetBeta1 () const;  Getters. ;  ; Scalar_t GetBeta2 () const;  ; Scalar_t GetEpsilon () const;  ; std::vector< std::vector< Matrix_t > > & GetFirstMomentBiases ();  ; std::vector< Matrix_t > & GetFirstMomentBiasesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetFirstMomentWeights ();  ; std::vector< Matrix_t > & GetFirstMomentWeightsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetSecondMomentBiases ();  ; std::vector< Matrix_t > & GetSecondMomentBiasesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetSecondMomentWeights ();  ; std::vector< Matrix_t > & GetSecondMomentWeightsAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html:1088,learn,learningRate,1088,doc/master/classTMVA_1_1DNN_1_1TAdam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html,1,['learn'],['learningRate']
Usability,"lass description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::BuildConfig. class RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__BuildConfig.html:1093,simpl,simple,1093,root/html526/RooSimWSTool__BuildConfig.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__BuildConfig.html,4,['simpl'],['simple']
Usability,"lass member (or .?).\n""; 1259 "" Specifying '::Member' is optional."");; 1260 Printf("" .help edit : show line editing shortcuts (or .?)"");; 1261 Printf("" .license : show license"");; 1262 Printf("" .libraries : show loaded libraries"");; 1263 Printf("" .ls : list contents of current TDirectory"");; 1264 Printf("" .pwd : show current TDirectory, pad and style"");; 1265 Printf("" .quit (or .exit) : quit ROOT (long form of .q)"");; 1266 Printf("" .R [user@]host[:dir] [-l user] [-d dbg] [script] :\n""; 1267 "" launch process in a remote host"");; 1268 Printf("" .qqq : quit ROOT - mandatory"");; 1269 Printf("" .qqqqq : exit process immediately"");; 1270 Printf("" .qqqqqqq : abort process"");; 1271 Printf("" .which [file] : show path of macro file"");; 1272 Printf("" .![OS_command] : execute OS-specific shell command"");; 1273 Printf("" .!root -? : print ROOT usage (CLI options)"");; 1274 return;; 1275 } else {; 1276 // If the user wants to use the extended "".help scopeName"" command to access; 1277 // the online reference guide, we first check if the command starts correctly.; 1278 if ((!strippedCommand.BeginsWith("".help "")) && (!strippedCommand.BeginsWith("".? ""))) {; 1279 Error(""Help"", ""Unknown command!"");; 1280 return;; 1281 }; 1282 // We remove the command "".help"" or "".?"" from the TString.; 1283 if (strippedCommand.BeginsWith("".? "")) {; 1284 strippedCommand.Remove(0, 3);; 1285 } else {; 1286 strippedCommand.Remove(0, 5);; 1287 }; 1288 // We strip the command line after removing "".help"" or "".?"".; 1289 strippedCommand = strippedCommand.Strip(TString::kBoth);; 1290 ; 1291 if (strippedCommand == ""edit"") {; 1292 Printf(""\n ROOT terminal keyboard shortcuts (GNU-readline style)."");; 1293 #ifdef R__MACOSX; 1294 #define FOOTNOTE "" *""; 1295 Printf(""* Some of these commands might be intercepted by macOS predefined system shortcuts."");; 1296 // https://apple.stackexchange.com/questions/18043/how-can-i-make-ctrlright-left-arrow-stop-changing-desktops-in-lion; 1297 #else; 1298 #define FOOTNOTE """"; 1299 #endif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:50977,guid,guide,50977,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['guid'],['guide']
Usability,"lass provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactoryA factory for building PDFs and data for a number counting combination ;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspectorUtility class to plot conditional MLE of nuisance parameters vs ;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:7931,simpl,simple,7931,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,5,['simpl'],['simple']
Usability,"lass()) {; 6283 unroll = Unroll(name, clParent, clOfBase, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6284 }; 6285 if (unroll < 0) {; 6286 // FIXME: We could not split because we are abstract, should we be doing this?; 6287 if (namelen) {; 6288 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6289 } else {; 6290 branchname.Form(""%s"", elem->GetFullName());; 6291 }; 6292 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, nullptr, basketsize, 0, btype);; 6293 branch->SetParentClass(clParent);; 6294 fBranches.Add(branch);; 6295 }; 6296 } else if (clOfBase->GetListOfRealData()->GetSize()) {; 6297 // -- Create a branch for a non-empty base class.; 6298 if (namelen) {; 6299 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6300 // Elide the base class name when creating the sub-branches.; 6301 // Note: The branch names for sub-branches of a base class branch; 6302 // do not represent the full class hierarchy because we do; 6303 // this, however it does keep the branch names for the; 6304 // inherited data members simple.; 6305 TBranchElement* branch = new TBranchElement(this, name, sinfo, elemID, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6306 // Then reset it to the proper name.; 6307 branch->SetName(branchname);; 6308 branch->SetTitle(branchname);; 6309 branch->SetParentClass(clParent);; 6310 fBranches.Add(branch);; 6311 } else {; 6312 branchname.Form(""%s"", elem->GetFullName());; 6313 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6314 branch->SetParentClass(clParent);; 6315 fBranches.Add(branch);; 6316 }; 6317 }; 6318 } else {; 6319 // -- This is a data member of cl.; 6320 if (namelen) {; 6321 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6322 } else {; 6323 branchname.Form(""%s"", elem->GetFullName());; 6324 }; 6325 if ((splitlevel > 1) && ((elem->IsA() =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:237208,simpl,simple,237208,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['simpl'],['simple']
Usability,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Integration.html:4183,simpl,simple,4183,doc/master/group__Integration.html,https://root.cern,https://root.cern/doc/master/group__Integration.html,1,['simpl'],['simple']
Usability,"lasses, structures, and arrays are composite types. Simple types are also called primitive types, basic types, and Cling sometimes calls them fundamental types.; When we say, “writing an object to a file”, we actually mean writing the current values of the data members. The most common way to do this is to decompose (also called the serialization of) the object into its data members and write them to disk. The decomposition is the job of the Streamer. Every class with ambitions to be stored in a file has a Streamerthat decomposes it and “streams” its members into a buffer.; The methods of the class are not written to the file, it contains only the persistent data members. To decompose the parent classes, the Streamercalls the Streamerof the parent classes. It moves up the inheritance tree until it reaches an ancestor without a parent. To serialize the object data members it calls their Streamer. They in turn move up their own inheritance tree and so forth. The simple data members are written to the buffer directly. Eventually the buffer contains all simple data members of all the classes that make up this particular object. Data members that are references (as MyClass &fObj;) are never saved, it is always the responsibility of the object’s constructor to set them properly.; 11.3.1 Automatically Generated Streamers; A Streamerusually calls other Streamers: the Streamerof its parents and data members. This architecture depends on all classes having Streamers, because eventually they will be called. To ensure that a class has a Streamer, rootcling automatically creates one in the ClassDef macro that is defined in $ROOTSYS/include/Rtypes.h. ClassDef defines several methods for any class, and one of them is the Streamer. The automatically generated Streameris complete and can be used as long as no customization is needed.; The Event class is defined in $ROOTSYS/test/Event.h. Looking at the class definition, we find that it inherits from TObject. It is a simple example of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:466765,simpl,simple,466765,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"lassification.py;   TMVA Classification Example Using a Recurrent Neural Network ;  ;  TMVA_SOFIE_GNN.py;  ;  TMVA_SOFIE_GNN_Application.C;  ;  TMVA_SOFIE_GNN_Parser.py;  ;  TMVA_SOFIE_Inference.py;   This macro provides an example of using a trained model with Keras and make inference using SOFIE directly from Numpy This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ;  ;  TMVA_SOFIE_Keras.C;   This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ;  ;  TMVA_SOFIE_Keras_HiggsModel.C;   This macro run the SOFIE parser on the Keras model obtaining running TMVA_Higgs_Classification.C You need to run that macro before this one ;  ;  TMVA_SOFIE_Models.py;   Example of inference with SOFIE using a set of models trained with Keras. ;  ;  TMVA_SOFIE_ONNX.C;   This macro provides a simple example for the parsing of ONNX files into RModel object and further generating the .hxx header files for inference. ;  ;  TMVA_SOFIE_PyTorch.C;   This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ;  ;  TMVA_SOFIE_RDataFrame.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model Then you need to run the macro TMVA_SOFIE_Keras_HiggsModel.C to generate the corresponding header file using SOFIE. ;  ;  TMVA_SOFIE_RDataFrame.py;   Example of inference with SOFIE and RDataFrame, of a model trained with Keras. ;  ;  TMVA_SOFIE_RDataFrame_JIT.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras mode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:3495,simpl,simple,3495,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,1,['simpl'],['simple']
Usability,"lassname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser* b); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual voidTChain::CanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConnectProof(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidTChain::CreatePackets(); Int_tDebug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTChain::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofChain.html:3543,undo,undo,3543,root/html528/TProofChain.html,https://root.cern,https://root.cern/root/html528/TProofChain.html,6,['undo'],['undo']
Usability,"lated uncertainties of A, regularisation scheme and binning schemes ; Parameters. [in]hist_Amatrix that describes the migrations ; [in]histmapmapping of the histogram axes to the unfolding output ; [in]regmode(default=kRegModeSize) global regularisation mode ; [in]constraint(default=kEConstraintArea) type of constraint ; [in]densityMode(default=kDensityModeBinWidthAndUser) regularisation scale factors to construct the matrix L ; [in]outputBins(default=nullptr) binning scheme for truth (unfolding output) ; [in]inputBins(default=nullptr) binning scheme for measurement (unfolding input) ; [in]regularisationDistribution(default=nullptr) selectin of regularized distribution ; [in]regularisationAxisSteering(default=nullptr) detailed regularisation steeringfor selected distribution. The parameters hist_A, histmap, constraint are explained with the TUnfoldSys constructor. ; The parameters outputBins,inputBins set the binning schemes. If these arguments are zero, simple binning schemes are constructed which correspond to the axes of the histogram hist_A. ; The parameters regmode, densityMode, regularisationDistribution, regularisationAxisSteering together control how the initial matrix L of regularisation conditions is constructed. as explained in RegularizeDistribution(). ; Definition at line 220 of file TUnfoldDensity.cxx. ◆ ~TUnfoldDensity(). TUnfoldDensity::~TUnfoldDensity ; (; void ; ). override . Definition at line 170 of file TUnfoldDensity.cxx. Member Function Documentation. ◆ Class(). static TClass * TUnfoldDensity::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TUnfoldDensity::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TUnfoldDensity::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 205 of file TUnfoldDensity.h. ◆ DeclFileName(). static const char * TUnfoldDensity::DeclFileName ; (; ). inlinestatic . ReturnsName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:42650,simpl,simple,42650,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['simpl'],['simple']
Usability,"layCreation(). void TGeoVolume::ReplayCreation ; (; const TGeoVolume * ; other). Recreate the content of the other volume without pointer copying. ; Voxels are ignored and supposed to be created in a later step via Voxelize. ; Definition at line 1292 of file TGeoVolume.cxx. ◆ ResetTransparency(). void TGeoVolume::ResetTransparency ; (; Char_t ; transparency = -1). inline . Definition at line 383 of file TGeoVolume.h. ◆ SaveAs(). void TGeoVolume::SaveAs ; (; const char * ; filename = """", . Option_t * ; option = """" . ); const. overridevirtual . Save geometry having this as top volume as a C++ macro. ; Reimplemented from TObject.; Definition at line 1447 of file TGeoVolume.cxx. ◆ SavePrimitive(). void TGeoVolume::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TObject.; Definition at line 1535 of file TGeoVolume.cxx. ◆ SelectVolume(). void TGeoVolume::SelectVolume ; (; Bool_t ; clear = kFALSE). Select this volume as matching an arbitrary criteria. ; The volume is added to a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need to be reset at the end by calling the method with CLEAR=true. This will also clear the list. ; Definition at line 2325 of file TGeoVolume.cxx. ◆ SetActiveDaughters(). void TGeoVolume::SetActiveDaughters ; (; Bool_t ; flag = kTRUE). inline . Definition at line 213 of file TGeoVolume.h. ◆ SetActivity(). void TGeoVolume::SetActivity ; (; Bool_t ; flag = kTRUE). inline . Definition at line 212 of file TGeoVolume.h. ◆ SetAdded(). void TGeoVolume::SetAdded ; (; ). inline . Definition at line 215 of file TGeoVolume.h. ◆ SetAsTopVolume(). void TGeoVolume::SetAsTopVolume ; (; ). Set this volume as the TOP one (the whole geometry starts from here) ; Definition at line 2051 of file TGeoVolume.cxx. ◆ SetAttVisibility(). void TGeoVolume::SetAttVisibility ; (; Bool_t ; vis). inline . Definition at line 233 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:63344,clear,clear,63344,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['clear'],['clear']
Usability,"ld));; 1077 theY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 1078 if (theGraph->InheritsFrom(""TCutG"")) {; 1079 //make sure first and last point are the same; 1080 if (ipoint == 0) {; 1081 theX[theNpoints-1] = theX[0];; 1082 theY[theNpoints-1] = theY[0];; 1083 }; 1084 if (ipoint == theNpoints-1) {; 1085 theX[0] = theX[theNpoints-1];; 1086 theY[0] = theY[theNpoints-1];; 1087 }; 1088 }; 1089 }; 1090 badcase = kFALSE;; 1091 x.clear();; 1092 y.clear();; 1093 gPad->Modified(kTRUE);; 1094 gVirtualX->SetLineColor(-1);; 1095 }; 1096}; 1097 ; 1098 ; 1099////////////////////////////////////////////////////////////////////////////////; 1100 ; 1101char *TGraphPainter::GetObjectInfoHelper(TGraph * /*theGraph*/, Int_t /*px*/, Int_t /*py*/) const; 1102{; 1103 return (char*)"""";; 1104}; 1105 ; 1106 ; 1107////////////////////////////////////////////////////////////////////////////////; 1108/// Return the highlighted point for theGraph; 1109 ; 1110Int_t TGraphPainter::GetHighlightPoint(TGraph *theGraph) const; 1111{; 1112 if (theGraph == gHighlightGraph) return gHighlightPoint;; 1113 else return -1;; 1114}; 1115 ; 1116 ; 1117////////////////////////////////////////////////////////////////////////////////; 1118/// Set highlight (enable/disable) mode for theGraph; 1119 ; 1120void TGraphPainter::SetHighlight(TGraph *theGraph); 1121{; 1122 gHighlightPoint = -1; // must be -1; 1123 gHighlightGraph = nullptr;; 1124 if (theGraph->IsHighlight()) return;; 1125 ; 1126 // delete previous highlight marker; 1127 if (gHighlightMarker) gHighlightMarker.reset(nullptr);; 1128 // emit Highlighted() signal (user can check on disabled); 1129 if (gPad->GetCanvas()) gPad->GetCanvas()->Highlighted(gPad, theGraph, gHighlightPoint, -1);; 1130}; 1131 ; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Check on highlight point; 1135 ; 1136void TGraphPainter::HighlightPoint(TGraph *theGraph, Int_t hpoint, Int_t distance); 1137{; 1138 // call from Distanceto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:40105,clear,clear,40105,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"ldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; virtual void attachToTree (TTree &t, Int_t bufSize=32000)=0;  Overloadable function for derived classes to implement attachment as branch to a TTree. ;  ; virtual void attachToVStore (RooVectorDataStore &vstore)=0;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true)=0;  ; virtual void fillTreeBranch (TTree &t)=0;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual bool isValid () const;  WVE (08/21/01) Probably obsolete now. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:34459,clear,clearShapeDirty,34459,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,3,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,"ldX2 = GetX2();; 155 oldY2 = GetY2();; 156 ndcsav = TestBit(kLineNDC);; 157 if (!opaque) {; 158 gVirtualX->SetLineColor(-1);; 159 TAttLine::Modify(); //Change line attributes only if necessary; 160 }; 161 ; 162 // No break !!!; 163 ; 164 case kMouseMotion:; 165 ; 166 if (TestBit(kLineNDC)) {; 167 px1 = gPad->UtoPixel(GetX1());; 168 py1 = gPad->VtoPixel(GetY1());; 169 px2 = gPad->UtoPixel(GetX2());; 170 py2 = gPad->VtoPixel(GetY2());; 171 } else {; 172 px1 = gPad->XtoAbsPixel(gPad->XtoPad(GetX1()));; 173 py1 = gPad->YtoAbsPixel(gPad->YtoPad(GetY1()));; 174 px2 = gPad->XtoAbsPixel(gPad->XtoPad(GetX2()));; 175 py2 = gPad->YtoAbsPixel(gPad->YtoPad(GetY2()));; 176 }; 177 p1 = p2 = pL = kFALSE;; 178 ; 179 d1 = abs(px1 - px) + abs(py1-py); //simply take sum of pixels differences; 180 if (d1 < kMaxDiff) { //*-*================>OK take point number 1; 181 px1old = px1; py1old = py1;; 182 p1 = kTRUE;; 183 gPad->SetCursor(kPointer);; 184 return;; 185 }; 186 d2 = abs(px2 - px) + abs(py2-py); //simply take sum of pixels differences; 187 if (d2 < kMaxDiff) { //*-*================>OK take point number 2; 188 px2old = px2; py2old = py2;; 189 p2 = kTRUE;; 190 gPad->SetCursor(kPointer);; 191 return;; 192 }; 193 ; 194 pL = kTRUE;; 195 pxold = px; pyold = py;; 196 gPad->SetCursor(kMove);; 197 ; 198 break;; 199 ; 200 case kArrowKeyRelease:; 201 case kButton1Motion:; 202 ; 203 if (p1) {; 204 if (!opaque) {; 205 gVirtualX->DrawLine(px1old, py1old, px2, py2);; 206 gVirtualX->DrawLine(px, py, px2, py2);; 207 } else {; 208 if (ndcsav) {; 209 SetNDC(kFALSE);; 210 SetX2(gPad->GetX1() + oldX2*(gPad->GetX2()-gPad->GetX1()));; 211 SetY2(gPad->GetY1() + oldY2*(gPad->GetY2()-gPad->GetY1()));; 212 }; 213 SetX1(gPad->AbsPixeltoX(px));; 214 SetY1(gPad->AbsPixeltoY(py));; 215 }; 216 px1old = px;; 217 py1old = py;; 218 }; 219 if (p2) {; 220 if (!opaque) {; 221 gVirtualX->DrawLine(px1, py1, px2old, py2old);; 222 gVirtualX->DrawLine(px1, py1, px, py);; 223 } else {; 224 if (ndcsav) {; 225 SetNDC(kFALSE);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLine_8cxx_source.html:5873,simpl,simply,5873,doc/master/TLine_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html,1,['simpl'],['simply']
Usability,"lding ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation Tutorials. ROOT offers a rich set of code examples that allow you to see ROOT's building blocks ""in action"", as part of more complex programs. They are separated in two categories: C++ or python scripts and Jupyter notebooks.; The tutorials are available for all major ROOT releases. These are the links for the latest git snapshot. All scripts are available also in the form of a ROOTBook which can be visualized in NBViewer or tried out interactively in SWAN. Just look for these badges:. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/tutorials.html:2587,guid,guidelines,2587,d/tutorials.html,https://root.cern,https://root.cern/d/tutorials.html,1,['guid'],['guidelines']
Usability,"lding ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials Using a Macro to Read a TTree. Why using a macro?; As real analyses don't fit into simple TTree::Draw() invocations, and as it is quite cumbersome to type the same lines again and again in the Root prompt, simply create macros for commonly used code. A macro is a file that is interpreted by ROOT.; Creating and Editing the Macro; Create a macro (e.g. AnalyzeTree.C) using your favorite text editor, e.g. with vi, emacs, wordpad, Eclipse, Visual Studio,... The macro should start with the proper #include statements and should contain the function declaration with the same name than the macro itself. As we know we're going to use TFile and TTree (at least), we can already include their headers TFile.h and TTree.h. Then come the function implementation.; Function Implementation; Lets start with something simple: calculate the sum of all event sizes. For this we need a new variable of type int. Create (declare) it at the beginning of the function, and don't forget to initialize it to 0. At the end, the code in AnalyzeTree.C should look like this:; #include ""TFile.h""; #include ""TTree.h"". void AnalyzeTree(); {; // Variables used to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:1998,simpl,simple,1998,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,2,['simpl'],"['simple', 'simply']"
Usability,"le = BIT(17);; 32 ; 33ClassImp(TStyle);; 34 ; 35/** \class TStyle; 36\ingroup Base; 37 \ingroup GraphicsAtt; 38 ; 39TStyle objects may be created to define special styles.; 40By default ROOT creates a default style that can be accessed via; 41the gStyle pointer.; 42 ; 43This class includes functions to set some of the following object attributes.; 44 - Canvas; 45 - Pad; 46 - Histogram axis; 47 - Lines; 48 - Fill areas; 49 - Text; 50 - Markers; 51 - Functions; 52 - Histogram Statistics and Titles; 53 ; 54All objects that can be drawn in a pad inherit from one or more attribute classes; 55like TAttLine, TAttFill, TAttText, TAttMarker. When the objects are created, their; 56default attributes are taken from the current style. The current style is an object; 57of the class[TStyle](https://root.cern/doc/master/classTStyle.html) and can be; 58referenced via the global variable `gStyle` (in TStyle.h).; 59 ; 60ROOT provides two styles called ""Default"" and ""Plain"". The ""Default""; 61style is created simply by:; 62 ; 63~~~ {.cpp}; 64 auto default = new TStyle(""Default"",""Default Style"");; 65~~~; 66 ; 67The `Plain` style can be used if you are working on a monochrome display or; 68if you want to get a ""conventional"" Postscript output. These are the instructions; 69in the ROOT constructor to create the `Plain` style.; 70 ; 71```; 72auto plain = new TStyle(""Plain"",""Plain Style (no colors/fill areas)"");; 73 ; 74 plain->SetCanvasBorderMode(0);; 75 plain->SetPadBorderMode(0);; 76 plain->SetPadColor(0);; 77 plain->SetCanvasColor(0);; 78 plain->SetTitleColor(0);; 79 plain->SetStatColor(0);; 80```; 81 ; 82You can set the current style with:; 83 ; 84```; 85gROOT->SetStyle(style_name);; 86```; 87 ; 88You can get a pointer to an existing style with:; 89 ; 90```; 91auto style = gROOT->GetStyle(style_name);; 92```; 93 ; 94You can create additional styles with:; 95 ; 96```; 97 TStyle *st1 = new TStyle(""st1"",""my style"");; 98 st1->Set....; 99 st1->cd(); this becomes now the current style gStyle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStyle_8cxx_source.html:2048,simpl,simply,2048,doc/master/TStyle_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html,1,['simpl'],['simply']
Usability,"le = df_available.Define(""twice"", ""col * 2""); 1629 ; 1630# Conversely, if we want to select the entries for which the column has missing; 1631# values, we do the following; 1632df_missingcol = df.FilterMissing(""col""); 1633# Following operations in the same branch of the computation graph clearly; 1634# cannot access that same column, since there would be no value to read; 1635df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); 1636\endcode; 1637 ; 1638\code{.cpp}; 1639ROOT::RDataFrame df{dataset};; 1640 ; 1641// Anytime an entry from ""col"" is missing, the entire entry will be filtered out; 1642auto df_available = df.FilterAvailable(""col"");; 1643auto df_twicecol = df_available.Define(""twice"", ""col * 2"");; 1644 ; 1645// Conversely, if we want to select the entries for which the column has missing; 1646// values, we do the following; 1647auto df_missingcol = df.FilterMissing(""col"");; 1648// Following operations in the same branch of the computation graph clearly; 1649// cannot access that same column, since there would be no value to read; 1650auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; 1651\endcode; 1652 ; 1653#### DefaultValueFor; 1654 ; 1655DefaultValueFor creates a node of the computation graph which just forwards the; 1656values of the columns necessary for other downstream nodes, when they are; 1657available. In case a value of the input column passed to this function is not; 1658available, the node will provide the default value passed to this function call; 1659instead. Example:; 1660 ; 1661\code{.py}; 1662df = ROOT.RDataFrame(dataset); 1663# Anytime an entry from ""col"" is missing, the value will be the default one; 1664default_value = ... # Some sensible default value here; 1665df = df.DefaultValueFor(""col"", default_value) ; 1666df = df.Define(""twice"", ""col * 2""); 1667\endcode; 1668 ; 1669\code{.cpp}; 1670ROOT::RDataFrame df{dataset};; 1671// Anytime an entry from ""col"" is missing, the value will be the defaul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:91847,clear,clearly,91847,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['clear'],['clearly']
Usability,"le > m_prevGradientsvector remembers the gradients of the previous stepDefinition NeuralNet.h:373; TMVA::DNN::Steepest::m_alphadouble m_alphainternal parameter (learningRate)Definition NeuralNet.h:371; TMVA::DNN::Steepest::m_localWeightsstd::vector< double > m_localWeightslocal weights for reuse in thread.Definition NeuralNet.h:375; TMVA::DNN::Steepest::operator()double operator()(Function &fitnessFunction, Weights &weights, PassThrough &passThrough)operator to call the steepest gradient descent algorithmDefinition NeuralNet.icc:271; TMVA::DNN::Steepest::SteepestSteepest(double learningRate=1e-4, double momentum=0.5, size_t repetitions=10)c'torDefinition NeuralNet.h:348; TMVA::IPythonInteractiveThis class is needed by JsMVA, and it's a helper class for tracking errors during the training in Jup...Definition MethodBase.h:94; TMVA::TimerTiming information for training and evaluation of MVA methods.Definition Timer.h:58; TMVA::Timer::DrawProgressBarvoid DrawProgressBar(Int_t, const TString &comment="""")draws progress bar in color or B&W caution:Definition Timer.cxx:202; TStringBasic string class.Definition TString.h:139; double; unsigned int; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMVA::DNN::sumOfSquaresdouble sumOfSquares(ItOutput itOutputBegin, ItOutput itOutputEnd, ItTruth itTruthBegin, ItTruth itTruthEnd, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc itInvActFnc, double patternWeight); TMVA::DNN::uniformDoubledouble uniformDouble(double minValue, double maxValue)Definition NeuralNet.cxx:43; TMVA::DNN::forwardvoid forward(const LAYERDATA &prevLayerData, LAYERDATA &currLayerData)apply the weights (and functions) in forward direction of the DNNDefinition NeuralNet.icc:546; TMVA::DNN::applyFunctionsvoid applyFunctions(ItValue itValue, ItValue itValueEnd, ItFunction itFunction); TMVA::DNN::operator|ModeOutputValues operator|(ModeOutputValues lhs, ModeOutputValues rhs)Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:79682,progress bar,progress bar,79682,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['progress bar'],['progress bar']
Usability,"le RVec.hxx. ◆ append() [3/3]. template<typename T > . void ROOT::Detail::VecOps::RVecImpl< T >::append ; (; std::initializer_list< T > ; IL). inline . Definition at line 674 of file RVec.hxx. ◆ assign() [1/3]. template<typename T > . template<typename in_iter , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type> . void ROOT::Detail::VecOps::RVecImpl< T >::assign ; (; in_iter ; in_start, . in_iter ; in_end . ). inline . Definition at line 692 of file RVec.hxx. ◆ assign() [2/3]. template<typename T > . void ROOT::Detail::VecOps::RVecImpl< T >::assign ; (; size_type ; NumElts, . const T & ; Elt . ). inline . Definition at line 680 of file RVec.hxx. ◆ assign() [3/3]. template<typename T > . void ROOT::Detail::VecOps::RVecImpl< T >::assign ; (; std::initializer_list< T > ; IL). inline . Definition at line 698 of file RVec.hxx. ◆ clear(). template<typename T > . void ROOT::Detail::VecOps::RVecImpl< T >::clear ; (; ). inline . Definition at line 586 of file RVec.hxx. ◆ emplace_back(). template<typename T > . template<typename... ArgTypes> . reference ROOT::Detail::VecOps::RVecImpl< T >::emplace_back ; (; ArgTypes &&... ; Args). inline . Definition at line 920 of file RVec.hxx. ◆ erase() [1/2]. template<typename T > . iterator ROOT::Detail::VecOps::RVecImpl< T >::erase ; (; const_iterator ; CI). inline . Definition at line 704 of file RVec.hxx. ◆ erase() [2/2]. template<typename T > . iterator ROOT::Detail::VecOps::RVecImpl< T >::erase ; (; const_iterator ; CS, . const_iterator ; CE . ). inline . Definition at line 721 of file RVec.hxx. ◆ insert() [1/5]. template<typename T > . iterator ROOT::Detail::VecOps::RVecImpl< T >::insert ; (; iterator ; I, . const T & ; Elt . ). inline . Definition at line 773 of file RVec.hxx. ◆ insert() [2/5]. template<typename T > . template<typename ItTy , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1VecOps_1_1RVecImpl.html:10645,clear,clear,10645,doc/master/classROOT_1_1Detail_1_1VecOps_1_1RVecImpl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1VecOps_1_1RVecImpl.html,1,['clear'],['clear']
Usability,"le TToggleGroup.cxx. Member Function Documentation. ◆ Add(). Int_t TToggleGroup::Add ; (; TToggle * ; t, . Bool_t ; select = 1 . ). virtual . Add a new toggle. ; Definition at line 63 of file TToggleGroup.cxx. ◆ At(). virtual TToggle * TToggleGroup::At ; (; Int_t ; idx). inlinevirtual . Definition at line 41 of file TToggleGroup.h. ◆ Class(). static TClass * TToggleGroup::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TToggleGroup::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TToggleGroup::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 57 of file TToggleGroup.h. ◆ DeclFileName(). static const char * TToggleGroup::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 57 of file TToggleGroup.h. ◆ DeleteAll(). void TToggleGroup::DeleteAll ; (; ). virtual . Disposes of all objects and clears array. ; Definition at line 116 of file TToggleGroup.cxx. ◆ First(). virtual TToggle * TToggleGroup::First ; (; ). inlinevirtual . Definition at line 47 of file TToggleGroup.h. ◆ GetTogglesCount(). virtual Int_t TToggleGroup::GetTogglesCount ; (; ). inlinevirtual . Definition at line 40 of file TToggleGroup.h. ◆ IndexOf(). virtual Int_t TToggleGroup::IndexOf ; (; TToggle * ; t). inlinevirtual . Definition at line 50 of file TToggleGroup.h. ◆ InsertAt(). Int_t TToggleGroup::InsertAt ; (; TToggle * ; t, . Int_t ; pos, . Bool_t ; select = 1 . ). virtual . Add a new toggle at a specific position. ; Definition at line 77 of file TToggleGroup.cxx. ◆ IsA(). TClass * TToggleGroup::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 57 of file TToggleGroup.h. ◆ Last(). virtual TToggle * TToggleGroup::Last ; (; ). inlinevirtual . Definition at line 48 of file TToggleGroup.h. ◆ operator=(). TToggleGroup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTToggleGroup.html:13586,clear,clears,13586,doc/master/classTToggleGroup.html,https://root.cern,https://root.cern/doc/master/classTToggleGroup.html,1,['clear'],['clears']
Usability,"le TTree.h. ◆ Branch() [8/13]. template<typename T , std::size_t N> . TBranch * TTree::Branch ; (; const char * ; name, . std::array< T, N > * ; obj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Definition at line 405 of file TTree.h. ◆ Branch() [9/13]. template<class T > . TBranch * TTree::Branch ; (; const char * ; name, . T ** ; addobj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Add a new branch, and infer the data type from the array addobj being passed. ; NoteThis and the previous overload should cover most cases for creating a branch. Try to use these two whenever possible, unless e.g. type conversions are needed.; Parameters. [in]nameName of the branch to be created. ; [in]addobjArray of the objects to be added. When calling Fill(), the current value of the type/object will be saved. ; [in]bufsizehe buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc. The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes). A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 370 of file TTree.h. ◆ Branch() [10/13]. template<class T > . TBranch * TTree::Branch ; (; const char * ; name, . T * ; obj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Add a new branch, and infer the data type from the type of obj being passed. ; NoteThis and the next overload should cover most cases for creating a branch. Try to use these two whenever possible, unless e.g. type conversions are needed.; Parameters. [in]nameName of the branch to be created. ; [in]objAddress of the object to be adde",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:81772,simpl,simple,81772,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['simpl'],['simple']
Usability,"le error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; gPad#define gPadDefinition TVirtualPad.h:308; TQCommand::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the list of merged commands.Definition TQCommand.cxx:360. Macro commands ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);; ...; During Redo operation commands composing macro command are executed sequentially in direct order (first in first out). During Undo, they are executed in reverse order (last in first out).; Undo manager. TQUndoManager is recorder of undo and redo operations. This is command history list which can be traversed backwards and upwards performing undo and redo operations. To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);; TQCommand::TQUndoManagerfriend class TQUndoManagerDefinition TQCommand.h:29; TQUndoManagerRecorder of operations for undo and redo.Definition TQCommand.h:103; TQUndoManager::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the stack of commands.Definition TQCommand.cxx:959; TQUndoManager::Add automatically invokes execution of command's Redo method. Use TQUndoManager::Undo to undo commands in history list. Redo is Undo for undo action. Use TQUndoManager::Redo method for that ; Definition at line 27 of file TQCommand.h. Public Member Functions;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; void Add (TObject *obj) override;  ; void Add (TObject *obj, Option_t *opt) override;  Add command to the list of merged commands. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:4258,undo,undo,4258,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"le momentum = 0.5,; 350 size_t repetitions = 10); 351 : m_repetitions (repetitions); 352 , m_alpha (learningRate); 353 , m_beta (momentum); 354 {}; 355 ; 356 /*! \brief operator to call the steepest gradient descent algorithm; 357 *; 358 * entry point to start the minimization procedure; 359 *; 360 * \param fitnessFunction (templated) function which has to be provided. This function is minimized; 361 * \param weights (templated) a reference to a container of weights. The result of the minimization procedure; 362 * is returned via this reference (needs to support std::begin and std::end; 363 * \param passThrough (templated) object which can hold any data which the fitness function needs. This object; 364 * is not touched by the minimizer; This object is provided to the fitness function when; 365 * called; 366 */; 367 template <typename Function, typename Weights, typename PassThrough>; 368 double operator() (Function& fitnessFunction, Weights& weights, PassThrough& passThrough);; 369 ; 370 ; 371 double m_alpha; ///< internal parameter (learningRate); 372 double m_beta; ///< internal parameter (momentum); 373 std::vector<double> m_prevGradients; ///< vector remembers the gradients of the previous step; 374 ; 375 std::vector<double> m_localWeights; ///< local weights for reuse in thread.; 376 std::vector<double> m_localGradients; ///< local gradients for reuse in thread.; 377 };; 378 ; 379 ; 380 ; 381 ; 382 ; 383 ; 384 ; 385 ; 386 ; 387 ; 388 ; 389 ; 390 ; 391 ; 392 ; 393 ; 394 ; 395 ; 396 template <typename ItOutput, typename ItTruth, typename ItDelta, typename ItInvActFnc>; 397 double sumOfSquares (ItOutput itOutputBegin, ItOutput itOutputEnd, ItTruth itTruthBegin, ItTruth itTruthEnd, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc itInvActFnc, double patternWeight);; 398 ; 399 ; 400 ; 401 template <typename ItProbability, typename ItTruth, typename ItDelta, typename ItInvActFnc>; 402 double crossEntropy (ItProbability itProbabilityBegin, ItProbability itProbability",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:10153,learn,learningRate,10153,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['learn'],['learningRate']
Usability,"le show how to put some annotation on a 3D plot using 3D polylines ;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  bent.py Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfit.C Draw and fit a TGraph2DErrors ;  graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ;  graphpalettecolor.C Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  graphpolar.C Create and draw a polar graph ;  graphpolar2.C Create and draw a polar graph with PI axis ;  graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ;  graphShade.C Show how to shade an area between two graphs ;  graphstruct.C Draw a simple graph structure ;  graphtext.C Draw a graph with text attached to each point ;  gtime.C Example of TGraphTime ;  gtime2.C Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program ;  hlGraph1.CThis tutorial demonstrates how to use the highlight mode on graph ;  hlGraph2.CThis tutorial demonstrates how to use the highlight mode on graph ;  labels1.C Setting alphanumeric labels in a 1-d histogram ;  labels2.C Setting alphanumeric labels ;  motorcycle.C Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ;  multigraph.C Create and Draw a TMultiGraph ;  multigraphpalettecolor.C Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  multipalette.C Draw color plots using different color palettes ;  seism.C Strip chart example ;  splines_test.C Examples of use of the spline classes ;  surfaces.C Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:118948,simpl,simple,118948,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"le show how to put some annotation on a 3D plot using 3D polylines ;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  bent.py Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfit.C Draw and fit a TGraph2DErrors ;  graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ;  graphpalettecolor.C Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  graphpolar.C Create and draw a polar graph ;  graphpolar2.C Create and draw a polar graph with PI axis ;  graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ;  graphShade.C Show how to shade an area between two graphs ;  graphstruct.C Draw a simple graph structure ;  graphtext.C Draw a graph with text attached to each point ;  gtime.C Example of TGraphTime ;  gtime2.C Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program ;  labels1.C Setting alphanumeric labels in a 1-d histogram ;  labels2.C Setting alphanumeric labels ;  motorcycle.C Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ;  multigraph.C Create and Draw a TMultiGraph ;  multigraphpalettecolor.C Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  multipalette.C Draw color plots using different color palettes ;  seism.C Strip chart example ;  splines_test.C Examples of use of the spline classes ;  surfaces.C Draw 2-Dim functions ;  timeonaxis.C This macro illustrates the use of the time mode on the axis with different time intervals and time formats ;  timeonaxis2.C D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:115151,simpl,simple,115151,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,['simpl'],['simple']
Usability,le* xlow = Coords( fNPoints-1 );; 630 ; 631 double binVolume = 1.0;; 632 for ( unsigned int j = 0; j < fDim; j++ ); 633 {; 634 binVolume *= ( xup[j] - xlow[j] );; 635 }; 636 ; 637 // store the minimum bin volume found as reference for future normalizations; 638 if ( fNPoints == 1 ); 639 fRefVolume = binVolume;; 640 else if ( binVolume < fRefVolume ); 641 fRefVolume = binVolume;; 642 }; 643 ; 644 ; 645 void BinData::InitDataVector (); 646 {; 647 fData.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 648 fDataPtr = fData.empty() ? nullptr : &fData.front();; 649 }; 650 ; 651 void BinData::InitializeErrors(); 652 {; 653 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 654 kAsymError == fErrorType || kNoError == fErrorType );; 655 ; 656 if ( fpTmpCoordErrorVector ); 657 {; 658 delete[] fpTmpCoordErrorVector;; 659 fpTmpCoordErrorVector = nullptr;; 660 }; 661 ; 662 if ( kNoError == fErrorType ); 663 {; 664 fCoordErrors.clear();; 665 fCoordErrorsPtr.clear();; 666 ; 667 fDataErrorHigh.clear();; 668 fDataErrorHighPtr = nullptr;; 669 ; 670 fDataErrorLow.clear();; 671 fDataErrorLowPtr = nullptr;; 672 ; 673 fDataError.clear();; 674 fDataErrorPtr = nullptr;; 675 ; 676 return;; 677 }; 678 ; 679 if ( kCoordError == fErrorType || kAsymError == fErrorType ); 680 {; 681 fCoordErrorsPtr.resize( fDim );; 682 fCoordErrors.resize( fDim );; 683 for( unsigned int i=0; i < fDim; i++ ); 684 {; 685 fCoordErrors[i].resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 686 ; 687 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 688 }; 689 ; 690 fpTmpCoordErrorVector = new double[fDim];; 691 }; 692 else; 693 {; 694 fCoordErrors.clear();; 695 fCoordErrorsPtr.clear();; 696 }; 697 ; 698 if ( kValueError == fErrorType || kCoordError == fErrorType ); 699 {; 700 fDataError.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 701 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 702 ; 703 fDataErrorHigh.clear();; 704,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:20461,clear,clear,20461,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"le.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferSQL2(); destroy sql buffer. TSQLStructure* SqlWriteAny(const void* obj, const TClass* cl, Long64_t objid); Convert object of any class to sql structures; Return pointer on created TSQLStructure; TSQLStructure object will be owned by TBufferSQL2. void* SqlReadAny(Long64_t keyid, Long64_t objid, TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t objid, TString& clname, Version_t& version); Returns object info like classname and version; Should be taken from buffer, which is produced in the begginnig. TSQLObjectData* SqlObjectData(Long64_t objid, TSQLClassInfo* sqlinfo); creates TSQLObjectData for specifed object id and specified class; Object data for each class can be stored in two different tables.; First table contains data in column-wise form for simple types like integer,; strings and so on when second table contains any other data which cannot; be converted into column-wise representation.; TSQLObjectData will contain results of the requests to both such tables for; concrete object id. void WriteObject(const TObject* obj); Convert object into sql structures.; !!! Should be used only by TBufferSQL2 itself.; Use SqlWrite() functions to convert your object to sql; Redefined here to avoid gcc 3.x warning. Int_t SqlWriteObject(const void* obj, const TClass* objClass, TMemberStreamer* streamer = 0, Int_t streamer_index = 0); Write object to buffer; If object was written before, only pointer will be stored; Return id of saved object. void* SqlReadObject(void* obj, TClass** cl = 0, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object from the buffer. void* SqlReadObjectDirect(void* obj, TClass** cl, Long64_t objid, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object data.; Class name a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferSQL2.html:23684,simpl,simple,23684,root/html530/TBufferSQL2.html,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html,5,['simpl'],['simple']
Usability,"le.C Illustrates the advantages of a TH1K histogram ;  hlabels1.C 1-D histograms with alphanumeric labels ;  hlabels2.C 2-D histograms with alphanumeric labels ;  hlHisto1.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hlHisto2.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hlHisto3.CThis tutorial demonstrates how the highlight mechanism can be used on a ntuple ;  hlHisto4.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hstack.C Example of stacked histograms: class THStack ;  hsum.C Histograms filled and drawn in a loop ;  hsumTimer.C Demo of Timers ;  legendautoplaced.C The legend can be placed automatically in the current pad in an empty space found at painting time ;  logscales.C Draw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot1.py Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot2.py Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot3.py Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot5.py Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:127618,simpl,simple,127618,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"le::RProvider::Browse(rootfold);; 116 if (elem_root); 117 comp->Add(std::make_shared<Browsable::RWrapper>(""root"", elem_root));; 118 ; 119 std::unique_ptr<Browsable::RHolder> rootfiles = std::make_unique<Browsable::TObjectHolder>(gROOT->GetListOfFiles(), kFALSE);; 120 auto elem_files = Browsable::RProvider::Browse(rootfiles);; 121 if (elem_files) {; 122 auto files = std::make_shared<Browsable::RWrapper>(""ROOT Files"", elem_files);; 123 files->SetExpandByDefault(true);; 124 comp->Add(files);; 125 // if there are any open files, make them visible by default; 126 if (elem_files->GetNumChilds() > 0); 127 seldir = {};; 128 }; 129 ; 130 SetTopElement(comp);; 131 ; 132 SetWorkingPath(seldir);; 133}; 134 ; 135/////////////////////////////////////////////////////////////////////; 136/// Reset all data correspondent to last request; 137 ; 138void RBrowserData::ResetLastRequestData(bool with_element); 139{; 140 fLastAllChilds = false;; 141 fLastSortedItems.clear();; 142 fLastSortMethod.clear();; 143 fLastItems.clear();; 144 if (with_element) {; 145 fLastPath.clear();; 146 fLastElement.reset();; 147 }; 148}; 149 ; 150/////////////////////////////////////////////////////////////////////////; 151/// Decompose path to elements; 152/// Returns array of names for each element in the path, first element either ""/"" or "".""; 153/// If returned array empty - it is error; 154 ; 155Browsable::RElementPath_t RBrowserData::DecomposePath(const std::string &strpath, bool relative_to_work_element); 156{; 157 Browsable::RElementPath_t arr;; 158 if (relative_to_work_element) arr = fWorkingPath;; 159 ; 160 if (strpath.empty()); 161 return arr;; 162 ; 163 auto arr2 = Browsable::RElement::ParsePath(strpath);; 164 arr.insert(arr.end(), arr2.begin(), arr2.end());; 165 return arr;; 166}; 167 ; 168/////////////////////////////////////////////////////////////////////////; 169/// Process browser request; 170 ; 171bool RBrowserData::ProcessBrowserRequest(const RBrowserRequest &request, RBrowserReply &reply); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:4572,clear,clear,4572,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['clear'],['clear']
Usability,"le; n: the size of the array. Output:; index: the shuffled indexes. This method is used for stochastic training ; Definition at line 2139 of file TMultiLayerPerceptron.cxx. ◆ SteepestDir(). void TMultiLayerPerceptron::SteepestDir ; (; Double_t * ; dir). protected . Sets the search direction to steepest descent. ; Definition at line 2253 of file TMultiLayerPerceptron.cxx. ◆ Streamer(). void TMultiLayerPerceptron::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMultiLayerPerceptron::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 151 of file TMultiLayerPerceptron.h. ◆ Train(). void TMultiLayerPerceptron::Train ; (; Int_t ; nEpoch, . Option_t * ; option = ""text"", . Double_t ; minE = 0 . ). Train the network. ; nEpoch is the number of iterations. option can contain:; ""text"" (simple text output); ""graph"" (evoluting graphical training curves); ""update=X"" (step for the text/graph output update); ""+"" will skip the randomisation and start from the previous values.; ""current"" (draw in the current canvas); ""minErrorTrain"" (stop when NN error on the training sample gets below minE; ""minErrorTest"" (stop when NN error on the test sample gets below minE All combinations are available. . Definition at line 788 of file TMultiLayerPerceptron.cxx. Friends And Related Symbol Documentation. ◆ TMLPAnalyzer. friend class TMLPAnalyzer. friend . Definition at line 27 of file TMultiLayerPerceptron.h. Member Data Documentation. ◆ fCurrentTree. Int_t TMultiLayerPerceptron::fCurrentTree. private . ! index of the current tree in a chain ; Definition at line 124 of file TMultiLayerPerceptron.h. ◆ fCurrentTreeWeight. Double_t TMultiLayerPerceptron::fCurrentTreeWeight. private . ! weight of the current tree in a chain ; Definition at line 125 of file TMultiLayerPerceptron.h. ◆ fData. TTree* TMultiLayerPerceptron::fData. private . ! pointer to the tree used as da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:49324,simpl,simple,49324,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,"le; static TTask*fgBeginTaskpointer to task initiator; static TTask*fgBreakPointpointer to current break point. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TTask. Function documentation; TTask(); Default constructor invoked when reading a TTask object from a file. TTask(const char* name, const char* title); Standard constructor. TTask& operator=(const TTask& tt); assignment operator (PLEASE DO NOT USE THIS IS WRONG). TTask(const TTask& task); Copy constructor. ~TTask(); Delete a task and its subtasks. void Abort(); Abort current tree of tasks.; After this call, the tree of tasks is ready to be executed again.; The application must take care of cleaning data structures created; by previous executions. void Browse(TBrowser* b); Browse the list of tasks.; It is recommended to add the top level task to the list of; ROOT browsables by:; gROOT->GetListOfBrowsables()->Add(myTopLevelTask). void CleanTasks(); Reset tasks state: breakpoints and execute flags; also invokes the Clear function of each task to clear all data; structures created by a previous execution of a task. void Clear(Option_t* option = """"); Recursively call the Clear function of this task and its subtasks.; The Clear function must be implemented for each derived class; to clear all data structures created by a previous execution of a task.; This function is automatically called by the CleanTasks function. void Continue(); Resume execution at the current break point. void Exec(Option_t* option); Dummy Execute.; This function must be redefined in the derived classes. void ExecuteTask(Option_t* option = ""0""); Execute main task and its subtasks.; When calling this function, the Exec function of the corresponding class; is invoked, then the list of its subtasks is executed calling recursively; all the subtasks, etc. The option parameter may be used to select different execution steps; within a task. This parameter is passed also to all the subtasks. void ExecuteTasks(Option_t* option); Execute all th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTask.html:10459,clear,clear,10459,root/html602/TTask.html,https://root.cern,https://root.cern/root/html602/TTask.html,2,['clear'],['clear']
Usability,"le;  . Private Member Functions; TGeoPhysicalNode * FindNextBoundaryBVH (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world. ;  ; TGeoPhysicalNode * FindNextBoundaryLoop (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world in a trivial loop version (for debugging) ;  ; TGeoPhysicalNode * FindNextBoundaryOrig (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world. ;  ; TGeoPhysicalNode * FindNodeBVH (Double_t point[3]);  Finds physical node containing the point. ;  ; TGeoPhysicalNode * FindNodeLoop (Double_t point[3]);  Finds physical node containing the point using simple algorithm (for debugging) ;  ; TGeoPhysicalNode * FindNodeOrig (Double_t point[3]);  Finds physical node containing the point (original version based on TGeoVoxelFinder) ;  ; std::pair< double, double > GetBVHSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; std::pair< double, double > GetLoopSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; void InitSafetyVoxel (TGeoVoxelGridIndex const &);  Method to initialize the safety voxel at a specific 3D voxel (grid) index. ;  ; Double_t SafetyBVH (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ;  ; Double_t SafetyLoop (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (trivial loop ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:15381,simpl,simple,15381,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['simpl'],['simple']
Usability,"leBorder|kSunkenFrame);  Create progress bar. ;  ;  ~TGProgressBar () override;  ; virtual void Format (const char *format=""%.2f"");  Set format for displaying a value. ;  ; Pixel_t GetBarColor () const;  ; EBarType GetBarType () const;  ; EFillType GetFillType () const;  ; FontStruct_t GetFontStruct () const;  ; TString GetFormat () const;  ; Float_t GetMax () const;  ; Float_t GetMin () const;  ; GContext_t GetNormGC () const;  ; Float_t GetPosition () const;  ; Bool_t GetShowPos () const;  ; const char * GetValueFormat () const;  ; void Increment (Float_t inc);  Increment progress position. ;  ; TClass * IsA () const override;  ; virtual void Percent (Bool_t on);  ; virtual void Reset ();  Reset progress bar (i.e. set pos to 0). ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save progress bar parameters as a C++ statement(s) on output stream out. ;  ; void SetBarColor (const char *color=""blue"");  Set progress bar color. ;  ; virtual void SetBarColor (Pixel_t color);  Set progress bar color. ;  ; void SetBarType (EBarType type);  Set bar type. ;  ; void SetFillType (EFillType type);  Set fill type. ;  ; void SetForegroundColor (Pixel_t pixel) override;  Change text color drawing. ;  ; void SetMax (Float_t max);  ; void SetMin (Float_t min);  ; void SetPosition (Float_t pos);  Set progress position between [min,max]. ;  ; void SetRange (Float_t min, Float_t max);  Set min and max of progress bar. ;  ; virtual void ShowPos (Bool_t on);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t UsePercent () const;  ;  Public Member Functions inherited from TGFrame;  TGFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=0, Pixel_t back=GetDefaultFrameBackground());  Create a TGFrame object. Options is an OR of the EFrameTypes. ;  ;  TGFrame (TGClient *c, Window_t id, const TGWindow *parent=nullptr);  Create a frame using an ext",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:2901,progress bar,progress bar,2901,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,2,['progress bar'],['progress bar']
Usability,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsAnaConvPdf.html:4315,clear,clearShapeDirty,4315,root/html602/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsAnaConvPdf.html,1,['clear'],['clearShapeDirty']
Usability,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedPdf.html:3420,clear,clearShapeDirty,3420,root/html534/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html,6,['clear'],['clearShapeDirty']
Usability,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDecay.html:2824,clear,clearShapeDirty,2824,root/html534/RooDecay.html,https://root.cern,https://root.cern/root/html534/RooDecay.html,3,['clear'],['clearShapeDirty']
Usability,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBCPEffDecay.html:3126,clear,clearShapeDirty,3126,root/html534/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html534/RooBCPEffDecay.html,12,['clear'],['clearShapeDirty']
Usability,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBDecay.html:3024,clear,clearShapeDirty,3024,root/html534/RooBDecay.html,https://root.cern,https://root.cern/root/html534/RooBDecay.html,3,['clear'],['clearShapeDirty']
Usability,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgusBG.html:2848,clear,clearShapeDirty,2848,root/html534/RooArgusBG.html,https://root.cern,https://root.cern/root/html534/RooArgusBG.html,133,['clear'],['clearShapeDirty']
Usability,"leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:20987,simpl,simple,20987,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,5,['simpl'],['simple']
Usability,lear();; 668 fDataErrorHighPtr = nullptr;; 669 ; 670 fDataErrorLow.clear();; 671 fDataErrorLowPtr = nullptr;; 672 ; 673 fDataError.clear();; 674 fDataErrorPtr = nullptr;; 675 ; 676 return;; 677 }; 678 ; 679 if ( kCoordError == fErrorType || kAsymError == fErrorType ); 680 {; 681 fCoordErrorsPtr.resize( fDim );; 682 fCoordErrors.resize( fDim );; 683 for( unsigned int i=0; i < fDim; i++ ); 684 {; 685 fCoordErrors[i].resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 686 ; 687 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 688 }; 689 ; 690 fpTmpCoordErrorVector = new double[fDim];; 691 }; 692 else; 693 {; 694 fCoordErrors.clear();; 695 fCoordErrorsPtr.clear();; 696 }; 697 ; 698 if ( kValueError == fErrorType || kCoordError == fErrorType ); 699 {; 700 fDataError.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 701 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 702 ; 703 fDataErrorHigh.clear();; 704 fDataErrorHighPtr = nullptr;; 705 fDataErrorLow.clear();; 706 fDataErrorLowPtr = nullptr;; 707 }; 708 else if ( fErrorType == kAsymError ); 709 {; 710 fDataErrorHigh.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 711 fDataErrorHighPtr = fDataErrorHigh.empty() ? nullptr : &fDataErrorHigh.front();; 712 ; 713 fDataErrorLow.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 714 fDataErrorLowPtr = fDataErrorLow.empty() ? nullptr : &fDataErrorLow.front();; 715 ; 716 fDataError.clear();; 717 fDataErrorPtr = nullptr;; 718 }; 719 else; 720 {; 721 assert(false);; 722 }; 723 }; 724 ; 725 void BinData::InitBinEdge(); 726 {; 727 fBinEdge.resize( fDim );; 728 ; 729 for( unsigned int i=0; i<fDim; i++ ); 730 {; 731 fBinEdge[i].reserve(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 732 }; 733 ; 734 if ( fpTmpBinEdgeVector ); 735 {; 736 delete[] fpTmpBinEdgeVector;; 737 fpTmpBinEdgeVector = nullptr;; 738 }; 739 ; 740 fpTmpBinEdgeVector = new double[ fDim ];; 741 }; 742 ; 743 void BinData::UnWrap( ),MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:21466,clear,clear,21466,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"lectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGDockableFrame.html:21286,undo,undocking,21286,root/html534/TGDockableFrame.html,https://root.cern,https://root.cern/root/html534/TGDockableFrame.html,1,['undo'],['undocking']
Usability,"lectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGDockableFrame.html:21186,undo,undocking,21186,root/html528/TGDockableFrame.html,https://root.cern,https://root.cern/root/html528/TGDockableFrame.html,3,['undo'],['undocking']
Usability,"lection.; 1494 // i.e. they contains the exact same type.; 1495 ; 1496 TVirtualCollectionProxy *oldProxy = oldClass->GetCollectionProxy();; 1497 TVirtualCollectionProxy *newProxy = newClass->GetCollectionProxy();; 1498 ; 1499 if (oldProxy->GetValueClass() == 0 && newProxy->GetValueClass() == 0; 1500 && (oldProxy->GetType() == kULong_t || oldProxy->GetType() == kULong64_t); 1501 && (newProxy->GetType() == kULong_t || newProxy->GetType() == kULong64_t )) {; 1502 // We have compatibles collections (they have the same content)!; 1503 return (oldClass->GetCollectionType() == newClass->GetCollectionType());; 1504 }; 1505 return kFALSE;; 1506 }; 1507 ; 1508 TClass *FindAlternate(TClass *context, const std::string &i_name, std::string& newName); 1509 {; 1510 // Return a class whose has the name as oldClass and can be found; 1511 // within the scope of the class 'context'.; 1512 ; 1513 // First strip any 'const ' prefix or trailing '*'.; 1514 std::string name(i_name);; 1515 newName.clear();; 1516 if (name.compare(0,6,""const "")==0) {; 1517 newName = ""const "";; 1518 name.erase(0,6);; 1519 }; 1520 std::string suffix;; 1521 UInt_t nstars = 0;; 1522 while(name[name.length()-nstars-1]=='*') {; 1523 ++nstars;; 1524 suffix.append(""*"");; 1525 }; 1526 if (nstars) {; 1527 name.erase(name.length()-nstars,nstars);; 1528 }; 1529 ; 1530 std::string alternate(context->GetName());; 1531 alternate.append(""::"");; 1532 alternate.append(name);; 1533 ; 1534 TClass *altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1535 if (altcl) {; 1536 newName.append(altcl->GetName());; 1537 newName.append(suffix);; 1538 return altcl;; 1539 }; 1540 ; 1541 size_t ctxt_cursor = strlen(context->GetName());; 1542 for (size_t level = 0; ctxt_cursor != 0; --ctxt_cursor) {; 1543 switch (context->GetName()[ctxt_cursor]) {; 1544 case '<': --level; break;; 1545 case '>': ++level; break;; 1546 case ':': if (level == 0) {; 1547 // we encountered a scope not within a template; 1548 // parameter.; 1549 alter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:58440,clear,clear,58440,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['clear'],['clear']
Usability,"lection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TQCommand*fCurrentthe latest executed command; TObjLink*fCursorcurrent position in history stack; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; UInt_tfLimitmaximum number of commands can be located in stack; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*fLogBooklisting of all actions during execution; Bool_tfLoggingkTRUE if logging is ON; Int_tTQCommand::fNRargsnumber of redo arguments; Int_tTQCommand::fNUargsnumber of undo arguments; TStringTQCommand::fNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tTQCommand::fNewDeletekTRUE if Redo/Undo methods are new/delete; void*TQCommand::fObjectobject to which undo/redo actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:18337,undo,undo,18337,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,2,['undo'],['undo']
Usability,lectionPtrIterators* TBranchElement::fPtrIterators. protected . ! holds the iterators when the branch is of fType==4 and it is a split collection of pointers. ; Definition at line 103 of file TBranchElement.h. ◆ fReadActionSequence. TStreamerInfoActions::TActionSequence* TBranchElement::fReadActionSequence. protected . ! Set of actions to be executed to extract the data from the basket. ; Definition at line 99 of file TBranchElement.h. ◆ fSTLtype. Int_t TBranchElement::fSTLtype. protected . ! STL container type ; Definition at line 81 of file TBranchElement.h. ◆ fStreamerType. Int_t TBranchElement::fStreamerType. protected . branch streamer type ; Definition at line 79 of file TBranchElement.h. ◆ fTargetClass. TClassRef TBranchElement::fTargetClass. protected . ! Reference to the target in-memory class ; Definition at line 91 of file TBranchElement.h. ◆ fType. Int_t TBranchElement::fType. protected . Branch type. ; Note on fType values:; -1 unsplit object with custom streamer at time of writing; 0 unsplit object with default streamer at time of writing OR simple data member of split object (fID==-1 for the former); 1 base class of a split object.; 2 class typed data member of a split object; 3 branch count of a split TClonesArray; 31 data member of the content of a split TClonesArray; 4 branch count of a split STL Collection.; 41 data member of the content of a split STL collection . Definition at line 67 of file TBranchElement.h. ◆ fWriteIterators. TVirtualCollectionIterators* TBranchElement::fWriteIterators. protected . ! holds the read (non-staging) iterators when the branch is of fType==4 and associative containers. ; Definition at line 102 of file TBranchElement.h. Libraries for TBranchElement:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TBranchElement.h; tree/tree/src/TBranchElement.cxx. TBranchElement. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:18 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:83907,simpl,simple,83907,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['simpl'],['simple']
Usability,"led for the first time; 162(`TH1::Draw`), it creates a `THistPainter` object and saves a; 163pointer to this ""painter"" as a data member of the histogram. The; 164`THistPainter` class specializes in the drawing of histograms. It is; 165separated from the histogram so that one can have histograms without the; 166graphics overhead, for example in a batch program. Each histogram having its own; 167painter (rather than a central singleton painter painting all histograms), allows; 168two histograms to be drawn in two threads without overwriting the painter's; 169values.; 170 ; 171When a displayed histogram is filled again, there is no need to call the; 172`Draw()` method again; the image will be refreshed the next time the; 173pad will be updated.; 174 ; 175A pad is updated after one of these three actions:; 176 ; 1771. a carriage control on the ROOT command line,; 1782. a click inside the pad,; 1793. a call to `TPad::Update`.; 180 ; 181 ; 182By default a call to `TH1::Draw()` clears the pad of all objects; 183before drawing the new image of the histogram. One can use the `SAME`; 184option to leave the previous display intact and superimpose the new histogram.; 185The same histogram can be drawn with different graphics options in different; 186pads.; 187 ; 188When a displayed histogram is deleted, its image is automatically removed; 189from the pad.; 190 ; 191To create a copy of the histogram when drawing it, one can use; 192`TH1::DrawClone()`. This will clone the histogram and allow to change; 193and delete the original one without affecting the clone.; 194 ; 195 ; 196\anchor HP01; 197### Histograms' plotting options; 198 ; 199 ; 200Most options can be concatenated with or without spaces or commas, for example:; 201 ; 202 h->Draw(""E1 SAME"");; 203 ; 204The options are not case sensitive:; 205 ; 206 h->Draw(""e1 same"");; 207 ; 208 ; 209The default drawing option can be set with `TH1::SetOption` and retrieve; 210using `TH1::GetOption`:; 211 ; 212 root [0] h->Draw(); // Draw ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:7078,clear,clears,7078,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['clear'],['clears']
Usability,"led with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:4065,learn,learning,4065,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"ledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; 2855/// - kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; 2856/// - kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; 2857/// - kMatch (0) : perfect match; 2858/// - kMatchConversion (1) : match with (I/O) conversion; 2859/// - kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; 2860/// - kMakeClass (3) : MakeClass mode so we can not check.; 2861/// - kVoidPtr (4) : void* passed so no check was made.; 2862/// - kNoCheck (5) : Underlying TBranch not yet available so no check was made.; 2863/// In addition this can be multiplexed with the two bits:; 2864/// - kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; 2865/// - kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode.; 2866/// This bits can be masked out by using kDecomposedObjMask; 2867 ; 2868Int_t TTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, bool isptr); 2869{; 2870 if (GetMakeClass()) {; 2871 // If we are in MakeClass mode so we do not really use classes.; 2872 return kMakeClass;; 2873 }; 2874 ; 2875 // Let's determine what we need!; 2876 TClass* expectedClass = nullptr;; 2877 EDataType expectedType = kOther_t;; 2878 if (0 != branch->GetExpectedType(expectedClass,expectedType) ) {; 2879 // Something went wrong, the warning message has already been issued.; 2880 return kInternalError;; 2881 }; 2882 bool isBranchElement = branch->InheritsFrom( TBranchElement::Class() );; 2883 if (expectedClass && datatype == kOther_t && ptrClass == nullptr) {; 2884 if (isBranchElement) {; 2885 TBranchElement* bEl = (TBranchElement*)branch;; 2886 bEl->SetTargetClass( expectedClass->GetName() );; 288",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:113097,usab,usable,113097,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['usab'],['usable']
Usability,"legant replacement of two-dimensional histograms : the inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin J. 2; H(J) = sum Y E(J) = sum Y; l(J) = sum l L(J) = sum l; h(J) = H(J)/L(J) s(J) = sqrt(E(J)/L(J)- h(J)**2); e(J) = s(J)/sqrt(L(J)). In the special case where s(J) is zero (eg, case of 1 entry only in one bin); e(J) is computed from the average of the s(J) for all bins if the static function; TProfile::Approximate has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour. Example of a profile histogram with its graphics output; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }. /*. */. Function Members (Methods); public:. TProfile(); TProfile(const TProfile& profile); TProfile(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Option_t* option = """"); TProfile(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Option_t* option = """"); TProfile(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Option_t* option = """"); TProfile(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Double_t ylow, Double_t yup, Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile.html:1374,simpl,simple,1374,root/html528/TProfile.html,https://root.cern,https://root.cern/root/html528/TProfile.html,3,['simpl'],['simple']
Usability,"legant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; 48 instead of using global variables.; 49 ; 50 ; 51## Basic concepts of MINUIT; 52 ; 53The [MINUIT](https://root.cern/download/minuit.pdf); 54package acts on a multiparameter Fortran function to which one; 55must give the generic name <TT>FCN</TT>. In the ROOT implementation,; 56the function <TT>FCN</TT> is defined via the MINUIT SetFCN member function; 57when an Histogram.Fit command is invoked.; 58The value of <TT>FCN</TT> will in general depend on one; 59or more variable parameters.; 60 ; 61To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); 62the Fit function defines the Minuit fitting function as being H1FitChisquare; 63or H1FitLikelihood depending on the options selected.; 64H1FitChisquare; 65calculates the chisquare between the user fitting function (gaussian, polynomial,; 66user defined,etc) and the data for given values of the parameters.; 67It is the task of MINUIT to find those values of the parameters; 68which give the lowest value of chisquare.; 69 ; 70### Basic concepts - The transformation for parameters with limits.; 71 ; 72For variable parameters with limits, MINUIT uses the following; 73transformation:; 74 ; 75\f[; 76P_{\mathrm{int}} = \arcsin; 77 \left( 2\: \frac{P_{\mathrm{ext}}-a}{b-a} - 1 \right); 78P_{\mathrm{ext}} = a + \frac{b - a}{2} \left( \sin P_{\mathrm{int}} + 1 \right); 79\f]; 80 ; 81so that the internal value \f$P_{\mathrm{int}}\f$ can take on any value, while; 82the external value \f$P_{\mathrm{ext}}\f$ can take on values only between the lower; 83limit \f$a\f$ and the upper limit \f$b\f$.; 84Since the transformat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:2700,simpl,simple,2700,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['simpl'],['simple']
Usability,"legation object; 237 TString fSenderClass; //class name of delegation object; 238 ; 239 void *GetSender() override { return fSender; }; 240 const char *GetSenderClassName() const override { return fSenderClass.Data(); }; 241 ; 242private:; 243 TQObjSender(const TQObjSender&) = delete;; 244 TQObjSender& operator=(const TQObjSender&) = delete;; 245 ; 246public:; 247 TQObjSender() : TQObject(), fSender(nullptr), fSenderClass() { }; 248 virtual ~TQObjSender() { Disconnect(); }; 249 ; 250 virtual void SetSender(void *sender) { fSender = sender; }; 251 void SetSenderClassName(const char *sclass = """") { fSenderClass = sclass; }; 252 ; 253 ClassDefOverride(TQObjSender,0) //Used to ""delegate"" TQObject functionality; 254 //to interpreted classes, see also RQ_OBJECT.h; 255};; 256 ; 257 ; 258 ; 259// Global function which simplifies making connections in interpreted; 260// ROOT session; 261//; 262// ConnectCINT - connects to interpreter(CINT) command; 263 ; 264extern Bool_t ConnectCINT(TQObject *sender, const char *signal,; 265 const char *slot);; 266 ; 267#ifdef G__DICTIONARY; 268// This include makes it possible to have a single connection; 269// from all objects of the same class but is only needed in; 270// the dictionary.; 271#include ""TQClass.h""; 272#endif; 273 ; 274 ; 275//---- ClassImpQ macro ----------------------------------------------; 276//; 277// This macro used to correspond to the ClassImp macro and should be used; 278// for classes derived from TQObject instead of the ClassImp macro.; 279// This macro makes it possible to have a single connection from; 280// all objects of the same class.; 281// *** It is now obsolete ***; 282 ; 283#define ClassImpQ(name) \; 284 ClassImp(name); 285 ; 286#endif; R__EXTERN#define R__EXTERNDefinition DllImport.h:26; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; ClassDefOverride#define ClassDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8h_source.html:9271,simpl,simplifies,9271,doc/master/TQObject_8h_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8h_source.html,1,['simpl'],['simplifies']
Usability,"lementation(const char* methodname, const char* params, const char* proto, TClass* cl, const ClassInfo_t* cinfo); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* object, Long_t& retLong); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Long_t& retLong); Execute the method for the specified object and argument values. void Execute(void* object, Double_t& retDouble); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Double_t& retDouble); Execute the method for the specified object and argument values. void Execute(vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMethodCall.html:10321,usab,usable,10321,root/html528/TMethodCall.html,https://root.cern,https://root.cern/root/html528/TMethodCall.html,4,['usab'],['usable']
Usability,"length n.; 1739/// Note that this function returns the sigma(standard deviation) and; 1740/// not the root mean square of the array.; 1741 ; 1742template <typename T>; 1743Double_t TMVA::Tools::RMS(Long64_t n, const T *a, const Double_t *w); 1744{; 1745 ; 1746 if (w) {; 1747 return TMVA::Tools::RMS(a, a+n, w);; 1748 } else {; 1749 return TMath::RMS(a, a+n);; 1750 }; 1751}; 1752 ; 1753////////////////////////////////////////////////////////////////////////////////; 1754/// get the cumulative distribution of a histogram; 1755 ; 1756TH1* TMVA::Tools::GetCumulativeDist( TH1* h); 1757{; 1758 TH1* cumulativeDist= (TH1*) h->Clone(TString::Format(""%sCumul"",h->GetTitle()));; 1759 //cumulativeDist->Smooth(5); // with this, I get less beautiful ROC curves, hence out!; 1760 ; 1761 Float_t partialSum = 0;; 1762 Float_t inverseSum = 0.;; 1763 ; 1764 Float_t val;; 1765 for (Int_t ibinEnd=1, ibin=cumulativeDist->GetNbinsX(); ibin >=ibinEnd ; ibin--){; 1766 val = cumulativeDist->GetBinContent(ibin);; 1767 if (val>0) inverseSum += val;; 1768 }; 1769 inverseSum = 1/inverseSum; // as I learned multiplications are much faster than division, and later I need one per bin. Well, not that it would really matter here I guess :); 1770 ; 1771 for (Int_t ibinEnd=1, ibin=cumulativeDist->GetNbinsX(); ibin >=ibinEnd ; ibin--){; 1772 val = cumulativeDist->GetBinContent(ibin);; 1773 if (val>0) partialSum += val;; 1774 cumulativeDist->SetBinContent(ibin,partialSum*inverseSum);; 1775 }; 1776 return cumulativeDist;; 1777}; 1778 ; 1779void TMVA::Tools::ReadAttr(void *node, const char *attrname, float &value); 1780{; 1781 // read attribute from xml; 1782 const char *val = xmlengine().GetAttr(node, attrname);; 1783 if (val == nullptr) {; 1784 const char *nodename = xmlengine().GetNodeName(node);; 1785 Log() << kFATAL << ""Trying to read non-existing attribute '"" << attrname << ""' from xml node '"" << nodename << ""'""; 1786 << Endl;; 1787 } else; 1788 value = atof(val);; 1789}; 1790 ; 1791void TMVA::Tools::Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:62293,learn,learned,62293,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['learn'],['learned']
Usability,"lete [] integral;; 3570}; 3571 ; 3572////////////////////////////////////////////////////////////////////////////////; 3573/// Fill histogram following distribution in histogram h.; 3574///; 3575/// @param h : Histogram pointer used for sampling random number; 3576/// @param ntimes : number of times the histogram is filled; 3577/// @param rng : (optional) Random number generator used for sampling; 3578///; 3579/// The distribution contained in the histogram h (TH1) is integrated; 3580/// over the channel contents for the bin range of this histogram.; 3581/// It is normalized to 1.; 3582///; 3583/// Getting one random number implies:; 3584/// - Generating a random number between 0 and 1 (say r1); 3585/// - Look in which bin in the normalized integral r1 corresponds to; 3586/// - Fill histogram channel ntimes random numbers are generated; 3587///; 3588/// SPECIAL CASE when the target histogram has the same binning as the source.; 3589/// in this case we simply use a poisson distribution where; 3590/// the mean value per bin = bincontent/integral.; 3591 ; 3592void TH1::FillRandom(TH1 *h, Int_t ntimes, TRandom * rng); 3593{; 3594 if (!h) { Error(""FillRandom"", ""Null histogram""); return; }; 3595 if (fDimension != h->GetDimension()) {; 3596 Error(""FillRandom"", ""Histograms with different dimensions""); return;; 3597 }; 3598 if (std::isnan(h->ComputeIntegral(true))) {; 3599 Error(""FillRandom"", ""Histograms contains negative bins, does not represent probabilities"");; 3600 return;; 3601 }; 3602 ; 3603 //in case the target histogram has the same binning and ntimes much greater; 3604 //than the number of bins we can use a fast method; 3605 Int_t first = fXaxis.GetFirst();; 3606 Int_t last = fXaxis.GetLast();; 3607 Int_t nbins = last-first+1;; 3608 if (ntimes > 10*nbins) {; 3609 auto inconsistency = CheckConsistency(this,h);; 3610 if (inconsistency != kFullyConsistent) return; // do nothing; 3611 Double_t sumw = h->Integral(first,last);; 3612 if (sumw == 0) return;; 3613 Double_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:142960,simpl,simply,142960,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['simpl'],['simply']
Usability,"letteEditor ; (; ). overridevirtual . Start palette editor. ; Reimplemented from TAttImage.; Definition at line 2252 of file TASImage.cxx. ◆ Streamer(). void TASImage::Streamer ; (; TBuffer & ; b). overridevirtual . Streamer for ROOT I/O. ; Reimplemented from TObject.; Definition at line 6175 of file TASImage.cxx. ◆ StreamerNVirtual(). void TASImage::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 211 of file TASImage.h. ◆ Tile(). void TASImage::Tile ; (; UInt_t ; width, . UInt_t ; height . ). overridevirtual . Tile the original image. ; Reimplemented from TImage.; Definition at line 1987 of file TASImage.cxx. ◆ TypeFromMagicNumber(). const char * TASImage::TypeFromMagicNumber ; (; const char * ; file). private . Guess the file type from the first byte of file. ; Definition at line 402 of file TASImage.cxx. ◆ UnZoom(). void TASImage::UnZoom ; (; ). overridevirtual . Un-zoom the image to original size. ; UnZoom() - performs undo for Zoom,Crop,Scale actions ; Reimplemented from TImage.; Definition at line 2049 of file TASImage.cxx. ◆ Vectorize(). Double_t * TASImage::Vectorize ; (; UInt_t ; max_colors = 256, . UInt_t ; dither = 4, . Int_t ; opaque_threshold = 1 . ). overridevirtual . Reduce color-depth of an image and fills vector of ""scientific data"" [0...1]. ; Colors are reduced by allocating color cells to most used colors first, and then approximating other colors with those allocated.; Parameters. [in]max_colors- maximum size of the colormap. ; [in]dither- number of bits to strip off the color data ( 0...7 ) ; [in]opaque_threshold- alpha channel threshold at which pixel should be treated as opaque . Reimplemented from TImage.; Definition at line 2832 of file TASImage.cxx. ◆ WriteImage(). void TASImage::WriteImage ; (; const char * ; file, . EImageFileTypes ; type = TImage::kUnknown . ). overridevirtual . Write image to specified file. ; If there is no file extension or if the file extension is unknown, the type argument",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:77895,undo,undo,77895,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['undo'],['undo']
Usability,"liases can be used in composing others;; input/output event lists easy to handle;; menu with histogram drawing options;; user commands may be executed within the viewer and the current command can be echoed;; current 'Draw' event loop is reflected by a progress bar and may be interrupted by the user;; all widgets have self-explaining tool tips and/or context menus;; expressions/leaves can be dragged to a 'scan box' and scanned by double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. a menu bar with entries : File, Edit, Run, Options and Help;; a toolbar in the upper part where you can issue user commands, change the drawing option and the histogram name, three check buttons Hist, Rec and Scan.HIST toggles histogram drawing mode, REC enables recording of the last command issued and SCAN enables redirecting of TTree::Scan command in an ASCII file (see -Scanning expressions-);; a button bar in the lower part with : buttons DRAW/STOP that issue histogram drawing and stop the current command respectively, two text widgets where input and output event lists can be specified, a message box and a RESET button on the right that clear edited expression content (see Editing...); a tree-type list on the main left panel where you can select among trees or branches. The tree/branch will be detailed in the right panel. Mapped trees are provided with context menus, activated by right-clicking;; a view-type list on the right panel. The first column contain X, Y and Z expression items, an optional cut and ten optional editable expressions. Expressions and leaf-type items can be dragged or deleted. A right click on the list-box or item activates context menus. Opening a new tree and saving a session :; To open a new tree in the viewer use <File/Open tree file> menu The content of the file (keys) will be listed. Use <SetTreeName> function from the context menu of the right panel, entering a tree name among those listed.; To save",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeViewer.html:2299,clear,clear,2299,doc/master/classTTreeViewer.html,https://root.cern,https://root.cern/doc/master/classTTreeViewer.html,1,['clear'],['clear']
Usability,lic Member Functions |; Static Public Member Functions |; Private Member Functions |; Static Private Member Functions |; Private Attributes |; Static Private Attributes |; Friends |; List of all members ; TGuiBldDragManager Class ReferenceGUI » GUI Builder. ; Drag and drop manager used by the ROOT GUI Builder. ; Definition at line 58 of file TGuiBldDragManager.h. Public Member Functions;  TGuiBldDragManager ();  ;  ~TGuiBldDragManager () override;  Destructor. ;  ; void ChangeBackgroundColor (TGCanvas *);  Change background color via context menu. ;  ; void ChangeBackgroundColor (TGComboBox *);  Change background color for list box entries. ;  ; void ChangeBackgroundColor (TGCompositeFrame *);  Change background color via context menu for this frame and all subframes. ;  ; void ChangeBackgroundColor (TGFrame *);  Change background color via context menu. ;  ; void ChangeBackgroundColor (TGListBox *);  Set background color for list box entries. ;  ; void ChangeBarColor (TGProgressBar *);  Set progress bar color via TGColorDialog. ;  ; void ChangeImage (TGIcon *);  Invoke file dialog to assign a new image. ;  ; void ChangePicture (TGPictureButton *);  Invoke file dialog to assign a new picture. ;  ; void ChangeProperties (TGLabel *);  Edit properties via font selection dialog. ;  ; void ChangeProperties (TGTextButton *);  Edit properties via font selection dialog. ;  ; void ChangeTextColor (TGGroupFrame *);  Change text color via color selection dialog. ;  ; void ChangeTextColor (TGLabel *);  Change text color via color selection dialog. ;  ; void ChangeTextColor (TGProgressBar *);  Change text color which displays position. ;  ; void ChangeTextColor (TGTextButton *);  Change text color via color selection dialog. ;  ; void ChangeTextColor (TGTextEntry *);  Set text color. ;  ; void ChangeTextFont (TGGroupFrame *);  Change text font via font selection dialog. ;  ; void ChangeTextFont (TGTextEntry *);  Change text font via font selection dialog. ;  ; void DoClassMenu (I,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGuiBldDragManager.html:1158,progress bar,progress bar,1158,doc/master/classTGuiBldDragManager.html,https://root.cern,https://root.cern/doc/master/classTGuiBldDragManager.html,1,['progress bar'],['progress bar']
Usability,"lid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooResolutionModel.html:4627,clear,clearValueDirty,4627,root/html602/RooResolutionModel.html,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html,1,['clear'],['clearValueDirty']
Usability,"like this should appear:. Figure 2: Example of TBrowser at start-up time; On the left, in the ""ROOT Files"" folder, you can find the ROOT file you have opened and our EventTree. If you see EventTree;1 and EventTree: they are identical. The first one is the tree on disk, the second the one in memory. Click your way through the tree.; Draw the ""fPosZ"" values from the browser. You should obtain a result looking like this:. Figure 3: Distribution of ""fPosZ"" values; This graph is called a histogram: it counts occurrences, combining neighboring values into ""bins"". In this case we have 100 equally sized bins (the ""steps""), ranging from x=-74 to x=102. You can tell that there were about 500 particles with a fPosZ value around -11. Histograms are a very common way to visualize data, e.g. in high energy physics.; Now close the browser, quit and restart ROOT (to make sure everybody starts from the same point).; . ‹ Meet a TTree; up; Using TTree::Draw() to access a TTree ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/accessing-ttree-tbrowser.html:3639,guid,guidelines,3639,d/accessing-ttree-tbrowser.html,https://root.cern,https://root.cern/d/accessing-ttree-tbrowser.html,1,['guid'],['guidelines']
Usability,"limit the amount of data processed. ;  ;  df006_ranges.py;   Use Range to limit the amount of data processed. ;  ;  df007_snapshot.C;   Write ROOT data with RDataFrame. ;  ;  df007_snapshot.py;   Write ROOT data with RDataFrame. ;  ;  df008_createDataSetFromScratch.C;   Create data from scratch with RDataFrame. ;  ;  df008_createDataSetFromScratch.py;   Create data from scratch with RDataFrame. ;  ;  df009_FromScratchVSTTree.C;   Compare creation of a ROOT dataset with RDataFrame and TTree. ;  ;  df010_trivialDataSource.C;   Use the ""trivial data source"", an example data source implementation. ;  ;  df010_trivialDataSource.py;   Use the ""trivial data source"", an example data source implementation. ;  ;  df012_DefinesAndFiltersAsStrings.C;   Use just-in-time-compiled Filters and Defines for quick prototyping. ;  ;  df012_DefinesAndFiltersAsStrings.py;   Use just-in-time-compiled Filters and Defines for quick prototyping. ;  ;  df013_InspectAnalysis.C;   Use callbacks to update a plot and a progress bar during the event loop. ;  ;  df014_CSVDataSource.C;   Process a CSV file with RDataFrame and the CSV data source. ;  ;  df014_CSVDataSource.py;   Process a CSV file with RDataFrame and the CSV data source. ;  ;  df015_LazyDataSource.C;   Use the lazy RDataFrame data source to concatenate computation graphs. ;  ;  df016_vecOps.C;   Process collections in RDataFrame with the help of RVec. ;  ;  df016_vecOps.py;   Process collections in RDataFrame with the help of RVec. ;  ;  df017_vecOpsHEP.C;   Use RVecs to plot the transverse momentum of selected particles. ;  ;  df017_vecOpsHEP.py;   Use RVecs to plot the transverse momentum of selected particles. ;  ;  df018_customActions.C;   Implement a custom action to fill THns. ;  ;  df019_Cache.C;   Cache a processed RDataFrame in memory for further usage. ;  ;  df019_Cache.py;   Cache a processed RDataFrame in memory for further usage. ;  ;  df020_helpers.C;   Show usage of RDataFrame's helper tools, contained in ROOT/RDFHelper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:2067,progress bar,progress bar,2067,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,1,['progress bar'],['progress bar']
Usability,"line 1571 of file RooFactoryWSTool.cxx. ◆ autoClassNamePostFix(). const char * RooFactoryWSTool::autoClassNamePostFix ; (; ); const. inline . Definition at line 155 of file RooFactoryWSTool.h. ◆ checkIndex(). void RooFactoryWSTool::checkIndex ; (; UInt_t ; index). staticprotected . Definition at line 1516 of file RooFactoryWSTool.cxx. ◆ checkSyntax(). bool RooFactoryWSTool::checkSyntax ; (; const char * ; arg). protected . Perform basic syntax on given factory expression. ; If function returns true syntax errors are found. ; Definition at line 1481 of file RooFactoryWSTool.cxx. ◆ Class(). static TClass * RooFactoryWSTool::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooFactoryWSTool::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooFactoryWSTool::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 199 of file RooFactoryWSTool.h. ◆ clearError(). void RooFactoryWSTool::clearError ; (; ). inlineprotected . Associated workspace. ; Definition at line 192 of file RooFactoryWSTool.h. ◆ createArg(). RooAbsArg * RooFactoryWSTool::createArg ; (; const char * ; className, . const char * ; objName, . const char * ; varList . ). Low-level factory interface for creating a RooAbsPdf of a given class with a given list of input variables The variable list varList should be of the form ""a,b,c"" where the interpretation of the argument is dependent on the pdf. ; Set and List arguments can be passed by substituting a single argument with the form (a,b,c), i.e. one can set varList to ""x,(a0,a1,a2)"" to pass a RooAbsReal and a RooArgSet as arguments. ; Definition at line 280 of file RooFactoryWSTool.cxx. ◆ createCategory(). RooCategory * RooFactoryWSTool::createCategory ; (; const char * ; name, . const char * ; stateNameList = nullptr . ). Low-level factory interface for creating a RooCategory with a given list of state names. ; The State ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFactoryWSTool.html:30143,clear,clearError,30143,doc/master/classRooFactoryWSTool.html,https://root.cern,https://root.cern/doc/master/classRooFactoryWSTool.html,1,['clear'],['clearError']
Usability,"line 650 of file TUnfoldSys.cxx. ◆ DeclFileName(). static const char * TUnfoldSys::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 146 of file TUnfoldSys.h. ◆ DoBackgroundSubtraction(). void TUnfoldSys::DoBackgroundSubtraction ; (; void ; ). protected . perform background subtraction ; This prepares the data members for the base class TUnfold, such that the background is properly taken into account. ; Definition at line 377 of file TUnfoldSys.cxx. ◆ GetBackground(). void TUnfoldSys::GetBackground ; (; TH1 * ; bgrHist, . const char * ; bgrSource = nullptr, . const Int_t * ; binMap = nullptr, . Int_t ; includeError = 3, . Bool_t ; clearHist = kTRUE . ); const. get background into a histogram ; Parameters. [in,out]bgrHisttarget histogram, content and errors will be altered ; [in]bgrSource(default=nullptr) name of backgrond source or zero to add all sources of background ; [in]binMap(default=nullptr) remap histogram bins ; [in]includeError(default=3) include uncorrelated(1), correlated (2) or both (3) sources of uncertainty in the histogram errors ; [in]clearHist(default=true) reset histogram before adding up the specified background sources. the array binMap is explained with the method GetOutput(). The flag clearHist may be used to add background from several sources in successive calls to GetBackground(). ; Definition at line 565 of file TUnfoldSys.cxx. ◆ GetBgrSources(). TSortedList * TUnfoldSys::GetBgrSources ; (; void ; ); const. Get a new list of all background sources. ; The user is responsible for deleting the list get list of name of background sources ; Definition at line 1528 of file TUnfoldSys.cxx. ◆ GetChi2Sys(). Double_t TUnfoldSys::GetChi2Sys ; (; void ; ). calculate total chi**2 including all systematic errors ; Definition at line 1366 of file TUnfoldSys.cxx. ◆ GetDeltaSysBackgroundScale(). Bool_t TUnfoldSys::GetDeltaSysBackgroundScale ; (; TH1 * ; hist_delta, . const char * ; source, . c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:34290,clear,clearHist,34290,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearHist']
Usability,"line 926 of file RooTreeDataStore.cxx. ◆ reduce(). std::unique_ptr< RooAbsDataStore > RooTreeDataStore::reduce ; (; RooStringView ; name, . RooStringView ; title, . const RooArgSet & ; vars, . const RooFormulaVar * ; cutVar, . const char * ; cutRange, . std::size_t ; nStart, . std::size_t ; nStop . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 179 of file RooTreeDataStore.cxx. ◆ reset(). void RooTreeDataStore::reset ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 935 of file RooTreeDataStore.cxx. ◆ Reset(). void RooTreeDataStore::Reset ; (; Option_t * ; option = nullptr). Interface function to TTree::Reset. ; Definition at line 1104 of file RooTreeDataStore.cxx. ◆ resetBuffers(). void RooTreeDataStore::resetBuffers ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 1058 of file RooTreeDataStore.cxx. ◆ resetCache(). void RooTreeDataStore::resetCache ; (; ). overridevirtual . Remove tree with values of cached observables and clear list of cached observables. ; Implements RooAbsDataStore.; Definition at line 1018 of file RooTreeDataStore.cxx. ◆ restoreAlternateBuffers(). void RooTreeDataStore::restoreAlternateBuffers ; (; ). Definition at line 1069 of file RooTreeDataStore.cxx. ◆ row(). const RooArgSet & RooTreeDataStore::row ; (; ). inline . Definition at line 139 of file RooTreeDataStore.h. ◆ setArgStatus(). void RooTreeDataStore::setArgStatus ; (; const RooArgSet & ; set, . bool ; active . ). overridevirtual . Activate or deactivate the branch status of the TTree branch associated with the given set of dataset observables. ; Implements RooAbsDataStore.; Definition at line 999 of file RooTreeDataStore.cxx. ◆ setBranchBufferSize(). void RooTreeDataStore::setBranchBufferSize ; (; Int_t ; size). inlineprivate . Definition at line 152 of file RooTreeDataStore.h. ◆ setExternalWeightArray(). void RooTreeDataStore::setExternalWeightArray ; (; const double * ; arrayWgt, . const double * ; arrayWgtErrLo, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:36174,clear,clear,36174,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['clear'],['clear']
Usability,"lineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 63 of file RooPoisson.h. ◆ protectNegativeMean(). void RooPoisson::protectNegativeMean ; (; bool ; flag = true). inline . Switch on or off protection against negative means. ; Definition at line 40 of file RooPoisson.h. ◆ setNoRounding(). void RooPoisson::setNoRounding ; (; bool ; flag = true). inline . Switch off/on rounding of x to the nearest integer. ; Definition at line 36 of file RooPoisson.h. ◆ Streamer(). void RooPoisson::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooPoisson::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 63 of file RooPoisson.h. ◆ translate(). void RooPoisson::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 67 of file RooPoisson.cxx. Member Data Documentation. ◆ _noRounding. bool RooPoisson::_noRounding. protected . Definition at line 56 of file RooPoisson.h. ◆ _protectNegative. bool RooPoisson::_protectNegative {true}. protected . Definition at line 57 of file RooPoisson.h. ◆ mean. RooRealProxy RooPoisson::mean. protected . Definition at line 55 of file RooPoisson.h. ◆ x. RooRealProxy RooPoisson::x. protected . Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPoisson.html:79535,simpl,simple,79535,doc/master/classRooPoisson.html,https://root.cern,https://root.cern/doc/master/classRooPoisson.html,1,['simpl'],['simple']
Usability,"lineprivate . Definition at line 3151 of file RInterface.hxx. ◆ DefinePerSample() [1/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename RetType_t = typename TTraits::CallableTraits<F>::ret_type> . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::DefinePerSample ; (; std::string_view ; name, . F ; expression . ). inline . Define a new column that is updated when the input sample changes. ; Parameters. [in]nameThe name of the defined column. ; [in]expressionA C++ callable that computes the new value of the defined column. . Returnsthe first node of the computation graph for which the new quantity is defined.; The signature of the callable passed as second argument should be T(unsigned int slot, const ROOT::RDF::RSampleInfo &id) where:; T is the type of the defined column; slot is a number in the range [0, nThreads) that is different for each processing thread. This can simplify the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; id is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is being processed (see the class docs for more information). DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being processed or to inject a callback into the event loop that is only called when the processing of a new sample starts rather than at every entry.; The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often. Example usage:; ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; df.DefinePerSample(""weightbysample"",; [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; ROOT::RDF::RInterface::DefinePerSampleRInterface< Proxied, DS_t > DefinePerSample(std::string_view name, F expression)Define a new column that is updated when the input sample changes.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:54315,simpl,simplify,54315,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['simpl'],['simplify']
Usability,"ling::GetEnum"", ""DeclContext not found for %s .\n"", name);; 4854 }; 4855 }; 4856 } else {; 4857 // If it is a global enum.; 4858 // Could trigger deserialization of decls.; 4859 cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());; 4860 possibleEnum = cling::utils::Lookup::Tag(&fInterpreter->getSema(), name);; 4861 }; 4862 if (possibleEnum && (possibleEnum != (clang::Decl*)-1); 4863 && isa<clang::EnumDecl>(possibleEnum)) {; 4864 return possibleEnum;; 4865 }; 4866 return nullptr;; 4867}; 4868 ; 4869////////////////////////////////////////////////////////////////////////////////; 4870/// Return pointer to cling DeclId for a global value; 4871 ; 4872TInterpreter::DeclId_t TCling::GetDeclId( const llvm::GlobalValue *gv ) const; 4873{; 4874 if (!gv) return nullptr;; 4875 ; 4876 llvm::StringRef mangled_name = gv->getName();; 4877 ; 4878 int err = 0;; 4879 char* demangled_name_c = TClassEdit::DemangleName(mangled_name.str().c_str(), err);; 4880 if (err) {; 4881 if (err == -2) {; 4882 // It might simply be an unmangled global name.; 4883 DeclId_t d;; 4884 TClingClassInfo gcl(GetInterpreterImpl());; 4885 d = gcl.GetDataMember(mangled_name.str().c_str());; 4886 return d;; 4887 }; 4888 return nullptr;; 4889 }; 4890 ; 4891 std::string scopename(demangled_name_c);; 4892 free(demangled_name_c);; 4893 ; 4894 //; 4895 // Separate out the class or namespace part of the; 4896 // function name.; 4897 //; 4898 std::string dataname;; 4899 ; 4900 if (!strncmp(scopename.c_str(), ""typeinfo for "", sizeof(""typeinfo for "")-1)) {; 4901 scopename.erase(0, sizeof(""typeinfo for "")-1);; 4902 } else if (!strncmp(scopename.c_str(), ""vtable for "", sizeof(""vtable for "")-1)) {; 4903 scopename.erase(0, sizeof(""vtable for "")-1);; 4904 } else {; 4905 // See if it is a function; 4906 std::string::size_type pos = scopename.rfind('(');; 4907 if (pos != std::string::npos) {; 4908 return nullptr;; 4909 }; 4910 // Separate the scope and member name; 4911 pos = scopename.rfind(':');; 4912 if (pos ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:190138,simpl,simply,190138,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['simpl'],['simply']
Usability,list specific TList derivation; TProofPerfAnalysis Set of tools to analyse the performance tree; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static config; TProofServ PROOF Server Application Interface; TProofServLite PROOF-Lite Server Application Interface; TProofSuperMaster PROOF control class for making submasters; TProofVectorContainer<TProofDrawListOfGraphs::Point3D_t> Class describing a vector container; TProofVectorContainer<TProofDrawListOfPolyMarkers3D::Point4D_t> Class describing a vector container; TProtoClass Persistent TClass; TProtoClass::TProtoRealData Persistent version of TRealData; TPyArg Python morphing argument type; TPyDispatcher Python dispatcher class; TPyMultiGenFunction Python for Math::IMultiGenFunction equivalent; TPyMultiGradFunction Python for Math::IMultiGradFunction equivalent; TPyReturn Python morphing return object; TPySelector Python equivalent base class for PROOF; TPythia8 Interface class of Pythia8; TPythia8Decayer Particle Decayer using Pythia8; TPython Access to the python interpreter; TQApplication creates ROOT environment with the Qt windowing system; TQCanvasImp ABC describing Qt GUI independent main window; TQCanvasMenu interface to Qt based context sensitive popup menus; TQClass Class with connections; TQCommand encapsulates the information for undo/redo a single action.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:118649,undo,undo,118649,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['undo'],['undo']
Usability,"lit; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; if splitlevel=0, the object is serialized in the branch buffer. ==> Case C. TBranch *branch = tree->Branch(branchname,clonesarray, bufsize, splitlevel); clonesarray is the address of a pointer to a TClonesArray.; The TClonesArray is a direct access list of objects of the same class.; For example, if the TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with only one branch). /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:4350,simpl,simple,4350,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['simpl'],['simple']
Usability,"litlevel = 1 . ). virtual . Create a new TTree BranchObject. ; Build a TBranchObject for an object of class classname. addobj is the address of a pointer to an object of class classname. IMPORTANT: classname must derive from TObject. The class dictionary must be available (ClassDef in class header).; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object. See the next Branch constructor for a more efficient storage in case the entry consists of arrays of identical objects.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode. ; Reimplemented in TTreeSQL.; Definition at line 2074 of file TTree.cxx. ◆ BranchRef(). TBranch * TTree::BranchRef ; (; ). virtual . Build the optional branch supporting the TRefTable. ; This branch wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:93532,simpl,simply,93532,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['simpl'],['simply']
Usability,"ll(), the current value of the type/object will be saved. ; [in]bufsizeThe buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc. The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes). A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 353 of file TTree.h. ◆ Branch() [11/13]. TBranch * TTree::Branch ; (; const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; bufsize = 32000 . ). virtual . Create a new TTree Branch. ; This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file. address is the address of the first item of a structure.; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type may be 0,1 or 2 characters. If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:83892,simpl,simple,83892,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['simpl'],['simple']
Usability,"ll.cxx;  draw.cxx;  draw_subpads.cxx;  draw_th1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxx;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demonstrates how THtml can document sources ;  MyTasks.cxxA set of classes deriving from TTask ;  regexp.CA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:165788,simpl,simple,165788,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['simpl'],['simple']
Usability,llTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected . ! save the fact that we processes the first entry ; Definition at line 60 of file TTreeCache.h. ◆ fgLearnEntries. Int_t TTreeCache::fgLearnEntries = 100. staticprotected . number of entries used for learning mode ; Definition at line 65 of file TTreeCache.h. ◆ fIsLearning. bool TTreeCache::fIsLearning {true}. protected . ! true if cache is in learning mode ; Definition at line 54 of file TTreeCache.h. ◆ fIsManual. bool TTreeCache::fIsManual {false}. protected . ! true if cache is StopLearningPhase was used ; Definition at line 55 of file TTreeCache.h. ◆ fLastMiss. Long64_t TTreeCache::fLastMiss {-1}. protected . ! set to the event # of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCach,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:54227,learn,learning,54227,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"llptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Types; typedef std::map< TEveElement *, Set_t >::iterator SelMap_i;  ; typedef std::map< TEveElement *, Set_t > SelMap_t;  ;  Protected Types inherited from TEveElement; enum  ECompoundSelectionColorBits { ;   kCSCBImplySelectAllChildren = (1ULL << ( 0 )); , kCSCBTakeAnyParentAsMaster = (1ULL << ( 1 )); , kCSCBApplyMainColorToAllChildren = (1ULL << ( 2 )); , kCSCBApplyMainColorToMatchingChildren = (1ULL << ( 3 )); , ;   kCSCBApplyMainTransparencyToAllChildren = (1ULL << ( 4 )); , kCSCBApplyMainTransparencyToMatchingChildren = (1ULL << ( 5 )). };  ; enum  EDestruct { kNone; , kStandard; , kAnnihilate; };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; void DoElementSelect (SelMap_i entry);  Select element indicated by the entry and fill its implied-selected set. ;  ; void DoElementUnselect (SelMap_i entry);  Deselect element indicated by the entry and clear its implied-selected set. ;  ; void RecheckImpliedSet (SelMap_i smi);  Recalculate implied-selected state for given selection entry. ;  ;  Protected Member Functions inherited from TEveElement; virtual void AnnihilateRecursively ();  Protected member function called from TEveElement::Annihilate(). ;  ; virtual void PreDeleteElement ();  Externally assigned and controlled user data. ;  ; virtual void RemoveElementsInternal ();  Remove all elements. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Protected Attributes; Bool_t fActive;  ; ImplySelect_foo fDecImpSelElement;  ; SelMap_t fImpliedSelected;  ; ImplySelect_foo fIncImpSelElement;  ; Bool_t fIsM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveSelection.html:35936,clear,clear,35936,doc/master/classTEveSelection.html,https://root.cern,https://root.cern/doc/master/classTEveSelection.html,1,['clear'],['clear']
Usability,load . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome ROOT 6 Analysis Workshop. Abstract; This tutorial will guide you through an example analysis with ROOT 6. It shows the recommended practices for analyzing data stored in ROOT TTrees - the most common format for High Energy Physics data.; It requires ROOT 6 as it uses several of its features.; . 0. Setting up ROOT ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/root-6-analysis-workshop-1.html:1914,guid,guide,1914,d/root-6-analysis-workshop-1.html,https://root.cern,https://root.cern/d/root-6-analysis-workshop-1.html,2,['guid'],['guide']
Usability,"lockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. Bool_tfReturnFeedback; TArrayIfSlaveActW; TArrayL64fSlaveBytesRead; TArrayFfSlaveEffS; TArrayFfSlaveEvtRti; TArrayFfSlaveInitTime; TArrayFfSlaveMBRti; TArrayFfSlaveProcTime; TArrayL64fSlaveProgress; TArrayIfSlaveTotS; TArrayL64fSlaveTotals; TListfSlaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF. Runs on super master.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void Progress(TSlave* sl, Long64_t total, Long64_t processed); Report progress. void Progress(TSlave* sl, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress. void Progress(TSlave* sl, TProofProgressInfo* pi); Progress signal. Bool_t HandleTimer(TTimer* timer); Send progress and feedback to client. void SetupFeedback(); Setup reporting of feedback objects and progress messages. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* sl, Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProofPlayerSuperMaster(TProof* proof = 0); { }. virtual ~TProofPlayerSuperMaster(); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 36592 2010-11-11 10:43:17Z ganis $ » Last generated: 2010-12-08 16:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerSuperMaster.html:17172,feedback,feedback,17172,root/html528/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html528/TProofPlayerSuperMaster.html,2,['feedback'],['feedback']
Usability,"lockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. Bool_tfReturnFeedback; TArrayIfSlaveActW; TArrayL64fSlaveBytesRead; TArrayFfSlaveEffS; TArrayFfSlaveEvtRti; TArrayFfSlaveInitTime; TArrayFfSlaveMBRti; TArrayFfSlaveProcTime; TArrayL64fSlaveProgress; TArrayIfSlaveTotS; TArrayL64fSlaveTotals; TListfSlaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF. Runs on super master.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void Progress(TSlave* sl, Long64_t total, Long64_t processed); Report progress. void Progress(TSlave* sl, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress. void Progress(TSlave* sl, TProofProgressInfo* pi); Progress signal. Bool_t HandleTimer(TTimer* timer); Send progress and feedback to client. void SetupFeedback(); Setup reporting of feedback objects and progress messages. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* sl, Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProofPlayerSuperMaster(TProof* proof = 0); { }. virtual ~TProofPlayerSuperMaster(); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 39442 2011-05-27 09:13:25Z ganis $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayerSuperMaster.html:17440,feedback,feedback,17440,root/html530/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html530/TProofPlayerSuperMaster.html,2,['feedback'],['feedback']
Usability,"lockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. Bool_tfReturnFeedback; TArrayIfSlaveActW; TArrayL64fSlaveBytesRead; TArrayFfSlaveEffS; TArrayFfSlaveEvtRti; TArrayFfSlaveInitTime; TArrayFfSlaveMBRti; TArrayFfSlaveProcTime; TArrayL64fSlaveProgress; TArrayIfSlaveTotS; TArrayL64fSlaveTotals; TListfSlaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF. Runs on super master.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void Progress(TSlave* sl, Long64_t total, Long64_t processed); Report progress. void Progress(TSlave* sl, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress. void Progress(TSlave* sl, TProofProgressInfo* pi); Progress signal. Bool_t HandleTimer(TTimer* timer); Send progress and feedback to client. void SetupFeedback(); Setup reporting of feedback objects and progress messages. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* sl, Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProofPlayerSuperMaster(TProof* proof = 0); { }. virtual ~TProofPlayerSuperMaster(); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 40186 2011-07-11 12:00:50Z ganis $ » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerSuperMaster.html:17456,feedback,feedback,17456,root/html532/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html532/TProofPlayerSuperMaster.html,2,['feedback'],['feedback']
Usability,"lon () const;  ; Scalar_t GetMomentum () const;  Getters. ;  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasGradients ();  ; std::vector< Matrix_t > & GetPastSquaredBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ; Scalar_t GetRho () const;  ; std::vector< std::vector< Matrix_t > > & GetWeightUpdates ();  ; std::vector< Matrix_t > & GetWeightUpdatesAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; std::vector< std::vector< Matrix_t > > fBiasUpdates;  The accumulation of the past Biases for performing updates. ;  ; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; Scalar_t fMomentum;  The momentum used for training. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The sum of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The sum of the square of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html:2432,learn,learningRate,2432,doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,1,['learn'],['learningRate']
Usability,"look like this:; ... // open the file; TFile *f = TFile::Open(""http://root.cern/files/introtutorials/eventdata.root"");; if (f == 0) {; // if we cannot open the file, print an error message and return immediatly; printf(""Error: cannot open http://root.cern/files/introtutorials/eventdata.root!\n"");; return;; }. // Create tyhe tree reader and its data containers; TTreeReader myReader(""EventTree"", f);. ... Getting the data out of the TTree; Fine, we have access to our tree. But now we need to get a handle on the data it stores, as shown below:; ... TTreeReaderValue<Int_t> eventSize(myReader, ""fEventSize"");. ... Loading TTree's Data; For the analysis example we need to access the events' size, which is accessible through the TTreeReaderValue eventSize. But the TTreeReader first needs to get told about which TTree entry to access. For that call TTreeReader::Next() in a loop. It will return false once it has reached the end of the TTree.; In the same loop, compute the total size of all events (simply add the current event size to the total size); ... // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Get the data from the current TTree entry by getting; // the value from the connected reader (eventSize):; totalSize += *eventSize;; }. Accessing the Analysis Result; At the end of the loop, print the sum of all event sizes. This sum shows you the real power of a TTree: even though you can analyze large amounts of data (our example tree with 22MB is tiny!) ROOT needs just a few MB of your RAM, no matter how many events you analyze. Imagine what it would be like if you had to load all data into memory, e.g. using a simple vector!; ... Int_t sizeInMB = totalSize/1024/1024;; printf(""Total size of all events: %d MB\n"", sizeInMB);; }. Running the Macro; To run this macro, simply type .x AnalyzeTree.C and ROOT will execute it. If it finds an error it might be wise to quit ROOT (.q) and try again!; If, for any reason, you don't manage to get it working, yo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:4466,simpl,simply,4466,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,1,['simpl'],['simply']
Usability,"lot a PDF in disjunct ranges, and get normalisation right. ;  ; file  rf212_plottingInRanges_blinding.py;   Plot a PDF in disjunct ranges, and get normalisation right. ;  ; file  rf301_composition.C;   Multidimensional models: multi-dimensional pdfs through composition e.g. ;  ; file  rf301_composition.py;   Multidimensional models: multi-dimensional pdfs through composition, e.g. ;  ; file  rf302_utilfuncs.C;   Multidimensional models: utility functions classes available for use in tailoring of composite (multidimensional) pdfs ;  ; file  rf302_utilfuncs.py;   Multidimensional models: utility functions classes available for use in tailoring of composite (multidimensional) pdfs ;  ; file  rf303_conditional.C;   Multidimensional models: use of tailored pdf as conditional pdfs.s ;  ; file  rf303_conditional.py;   'MULTIDIMENSIONAL MODELS' RooFit tutorial macro #303 Use of tailored p.d.f as conditional p.d.fs.s ;  ; file  rf304_uncorrprod.C;   Multidimensional models: simple uncorrelated multi-dimensional pdfs ;  ; file  rf304_uncorrprod.py;   Multidimensional models: simple uncorrelated multi-dimensional pdfs ;  ; file  rf305_condcorrprod.C;   Multidimensional models: multi-dimensional pdfs with conditional pdfs in product ;  ; file  rf305_condcorrprod.py;   Multidimensional models: multi-dimensional pdfs with conditional pdfs in product ;  ; file  rf306_condpereventerrors.C;   Multidimensional models: conditional pdf with per-event errors ;  ; file  rf306_condpereventerrors.py;   Multidimensional models: complete example with use of conditional pdf with per-event errors ;  ; file  rf307_fullpereventerrors.C;   Multidimensional models: full pdf with per-event errors ;  ; file  rf307_fullpereventerrors.py;   Multidimensional models: usage of full pdf with per-event errors ;  ; file  rf308_normintegration2d.C;   Multidimensional models: normalization and integration of pdfs, construction of cumulative distribution functions from pdfs in two dimensions ;  ; file  rf308_no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:6969,simpl,simple,6969,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['simpl'],['simple']
Usability,"lper-cols). |; 106| Filter() | Filter rows based on user-defined conditions. |; 107| FilterAvailable() | Specialized Filter. If the value of the input column is available, keep the entry, otherwise discard it. |; 108| FilterMissing() | Specialized Filter. If the value of the input column is missing, keep the entry, otherwise discard it. |; 109| Range() | Filter rows based on entry number (single-thread only). |; 110| Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; 111| RedefineSlot() | Overwrite the value and/or type of an existing column. See DefineSlot() for more information. |; 112| RedefineSlotEntry() | Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. |; 113| Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |; 114 ; 115 ; 116### Actions; 117Actions aggregate data into a result. Each one is described in more detail in the reference guide.; 118 ; 119In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters.; 120 ; 121Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; 122produce many different results in one event loop. Instant actions trigger the event loop instantly.; 123 ; 124 ; 125| **Lazy action** | **Description** |; 126|------------------|-----------------|; 127| Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; 128| Book() | Book execution of a custom action using a user-defined helper object. |; 129| Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; 130| Count() | Return the number of events processed. Useful e.g. to get a quick count of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:7142,guid,guide,7142,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['guid'],['guide']
Usability,"lrecord->AddText(""fSeekKey: Pointer to object on file"");; lrecord->AddText(""fSeekPdir: Pointer to directory on file"");; lrecord->AddText(""fClassName: class name of the object"");; lrecord->AddText(""fName: name of the object"");; lrecord->AddText(""fTitle: title of the object"");; ; c1->Update();; c1->Print(""file.png"");; }; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextAnglevirtual void SetTextAngle(Float_t tangle=0)Set the text angle.Definition TAttText.h:43; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveLabel::Drawvoid Draw(Option_t *option="""") overrideDraw this pavelabel with its current attributes.Definition TPaveLabel.cxx:88; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::AddLinevirtual TLine * AddLine(Double_t x1=0, Double_t y1=0, Double_t x2=0, Double_t y2=0)Add a new graphics line to this pavetext.Definition TPaveText.cxx:177; TPaveText::Drawvoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/file_8C.html:5260,simpl,simple,5260,doc/master/file_8C.html,https://root.cern,https://root.cern/doc/master/file_8C.html,1,['simpl'],['simple']
Usability,"ls. Detailed Description; Write and read STL vectors in a tree. . ; #include <vector>; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TCanvas.h""; #include ""TFrame.h""; #include ""TH1F.h""; #include ""TBenchmark.h""; #include ""TRandom.h""; #include ""TSystem.h""; ; void write(); {; ; TFile *f = TFile::Open(""hvector.root"",""RECREATE"");; ; if (!f) { return; }; ; // Create one histograms; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; hpx->SetFillColor(48);; ; std::vector<float> vpx;; std::vector<float> vpy;; std::vector<float> vpz;; std::vector<float> vrand;; ; // Create a TTree; TTree *t = new TTree(""tvec"",""Tree with vectors"");; t->Branch(""vpx"",&vpx);; t->Branch(""vpy"",&vpy);; t->Branch(""vpz"",&vpz);; t->Branch(""vrand"",&vrand);; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; ; gRandom->SetSeed();; const Int_t kUPDATE = 1000;; for (Int_t i = 0; i < 25000; i++) {; Int_t npx = (Int_t)(gRandom->Rndm(1)*15);; ; vpx.clear();; vpy.clear();; vpz.clear();; vrand.clear();; ; for (Int_t j = 0; j < npx; ++j) {; ; Float_t px,py,pz;; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ; hpx->Fill(px);; ; vpx.emplace_back(px);; vpy.emplace_back(py);; vpz.emplace_back(pz);; vrand.emplace_back(random);; ; }; if (i && (i%kUPDATE) == 0) {; if (i == kUPDATE) hpx->Draw();; c1->Modified();; c1->Update();; if (gSystem->ProcessEvents()); break;; }; t->Fill();; }; f->Write();; ; delete f;; }; ; ; void read(); {; ; TFile *f = TFile::Open(""hvector.root"",""READ"");; ; if (!f) { return; }; ; TTree *t; f->GetObject(""tvec"",t);; ; std::vector<float> *vpx = nullptr;; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; ; const Int_t kUPDATE = 1000;; ; TBranch *bvpx = nullptr;; t->SetBranchAddress(""vpx"",&vpx,&bvpx);; ; ; // Create one histograms; TH1F *h = new TH1F(""h"",""This is the px distribution"",100,-4,4);; h->SetFillColor(48);; ; for (Int_t i = 0; i < ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hvector_8C.html:1171,clear,clear,1171,doc/master/hvector_8C.html,https://root.cern,https://root.cern/doc/master/hvector_8C.html,1,['clear'],['clear']
Usability,"ls. Returns the previous block status. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; void SetupFeedback () override;  Setup feedback. ;  ; void StopFeedback () override;  Stop feedback. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if requested. ;  ; virtual Int_t DrawCanvas (TObject *obj);  Draw the object if it is a canvas. ;  ; void * GetSender () override;  ; void MapOutputListToDataMembers () const;  ; void MergeOutput (Bool_t savememvalues=kFALSE) override;  Merge output (may not be used in this class). ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSlave.html:18903,feedback,feedback,18903,doc/master/classTProofPlayerSlave.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSlave.html,1,['feedback'],['feedback']
Usability,"ls::TNormalizedCtxt &normCtxt); 8742{; 8743 const clang::TypeDecl* td = llvm::dyn_cast<clang::TypeDecl>(decl->getDeclContext());; 8744 if (!td) return;; 8745 ; 8746 clang::QualType qualType(td->getTypeForDecl(),0);; 8747 ROOT::TMetaUtils::GetNormalizedName(name, qualType, interp, normCtxt);; 8748 unsigned int level = 0;; 8749 for(size_t cursor = name.length()-1; cursor != 0; --cursor) {; 8750 if (name[cursor] == '>') ++level;; 8751 else if (name[cursor] == '<' && level) --level;; 8752 else if (level == 0 && name[cursor] == ':') {; 8753 name.erase(0,cursor+1);; 8754 break;; 8755 }; 8756 }; 8757}; 8758 ; 8759////////////////////////////////////////////////////////////////////////////////; 8760 ; 8761void TCling::GetFunctionName(const clang::Decl *decl, std::string &output) const; 8762{; 8763 output.clear();; 8764 ; 8765 const auto *FD = llvm::dyn_cast<clang::FunctionDecl>(decl);; 8766 if (const auto *USD = llvm::dyn_cast<clang::UsingShadowDecl>(decl)) {; 8767 FD = llvm::dyn_cast<clang::FunctionDecl>(USD->getTargetDecl());; 8768 }; 8769 if (!FD) {; 8770 Error(""GetFunctionName"", ""NULL Decl!"");; 8771 return;; 8772 }; 8773 ; 8774 // For using-decls, show ""Derived"", not ""Base"", i.e. use the; 8775 // name of the decl context of the UsingShadowDecl (aka `decl`); 8776 // not the name of FD's decl context.; 8777 if (llvm::isa<clang::CXXConstructorDecl>(FD)); 8778 {; 8779 ConstructorName(output, decl, *fInterpreter, *fNormalizedCtxt);; 8780 ; 8781 } else if (llvm::isa<clang::CXXDestructorDecl>(decl)); 8782 {; 8783 ConstructorName(output, decl, *fInterpreter, *fNormalizedCtxt);; 8784 output.insert(output.begin(), '~');; 8785 } else {; 8786 llvm::raw_string_ostream stream(output);; 8787 auto printPolicy = decl->getASTContext().getPrintingPolicy();; 8788 // Don't trigger fopen of the source file to count lines:; 8789 printPolicy.AnonymousTagLocations = false;; 8790 FD->getNameForDiagnostic(stream, printPolicy, /*Qualified=*/false);; 8791 }; 8792}; 8793 ; 8794//////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:341066,clear,clear,341066,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['clear'],['clear']
Usability,"lso minimizer type; 121 // algorithm is after "" / ""; 122 const std::string & minname = result.MinimizerType();; 123 size_t pos = minname.find("" / "");; 124 if (pos != std::string::npos) {; 125 std::string minimType = minname.substr(0,pos);; 126 std::string algoType = minname.substr(pos+3,minname.length() );; 127 SetMinimizer(minimType.c_str(), algoType.c_str() );; 128 }; 129 else {; 130 SetMinimizer(minname.c_str());; 131 }; 132}; 133 ; 134 ; 135void FitConfig::SetParamsSettings(unsigned int npar, const double *params, const double * vstep ) {; 136 // initialize FitConfig from given parameter values and step sizes; 137 // if npar different than existing one - clear old one and create new ones; 138 if (params == nullptr) {; 139 fSettings = std::vector<ParameterSettings>(npar);; 140 return;; 141 }; 142 // if a vector of parameters is given and parameters are not existing or are of different size; 143 bool createNew = false;; 144 if (npar != fSettings.size() ) {; 145 fSettings.clear();; 146 fSettings.reserve(npar);; 147 createNew = true;; 148 }; 149 unsigned int i = 0;; 150 const double * end = params+npar;; 151 for (const double * ipar = params; ipar != end; ++ipar) {; 152 double val = *ipar;; 153 double step = 0;; 154 if (vstep == nullptr) {; 155 step = 0.3*std::fabs(val); // step size is 30% of par value; 156 //double step = 2.0*std::fabs(val); // step size is 30% of par value; 157 if (val == 0) step = 0.3;; 158 }; 159 else; 160 step = vstep[i];; 161 ; 162 if (createNew); 163 fSettings.push_back( ParameterSettings(""Par_"" + ROOT::Math::Util::ToString(i), val, step ) );; 164 else {; 165 fSettings[i].SetValue(val);; 166 fSettings[i].SetStepSize(step);; 167 }; 168 ; 169 i++;; 170 }; 171}; 172 ; 173ROOT::Math::Minimizer * FitConfig::CreateMinimizer() {; 174 // create minimizer according to the chosen configuration using the; 175 // plug-in manager; 176 ; 177 // in case of empty string usesd default values; 178 if (fMinimizerOpts.MinimizerType().empty()); 179 fMinimizerOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8cxx_source.html:4544,clear,clear,4544,doc/master/FitConfig_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html,1,['clear'],['clear']
Usability,"lso possible with indexed friend trees (see below).; To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame with the main tree:; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");; ; RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above, or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree).; NoteA common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original one: rows will be mismatched.; Indexed friend trees provide a way to perform simple joins of multiple trees over a common column. When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the ""index"" columns have a value identical to the one in the main one. For example, in Python:; main_tree = ...; aux_tree = ...; ; # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""); ; mainTree.AddFriend(aux_tree); ; df = ROOT.RDataFrame(mainTree); RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats.; RDataFrame calls into concrete RDataSource implementations to retrieve information abou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:71327,simpl,simple,71327,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simple']
Usability,"lt and Minuit2Minimizer::Hesse for the hesseResult.; If other minimizers are used see their specific documentation for the status code returned.; For example in the case of Fumili, for the status returned see TFumili::Minimize. Excluding points. Use TF1::RejectPoint inside your fitting function to exclude points; within a certain range from the fit. Example:; Double_t fline(Double_t *x, Double_t *par); {; if (x[0] > 2.5 && x[0] < 3.5) {; TF1::RejectPoint();; return 0;; }; return par[0] + par[1]*x[0];; }. void exclude() {; TF1 *f1 = new TF1(""f1"", ""[0] +[1]*x +gaus(2)"", 0, 5);; f1->SetParameters(6, -1,5, 3, 0.2);; TH1F *h = new TH1F(""h"", ""background + signal"", 100, 0, 5);; h->FillRandom(""f1"", 2000);; TF1 *fline = new TF1(""fline"", fline, 0, 5, 2);; fline->SetParameters(2, -1);; h->Fit(""fline"", ""l"");; }. Warning when using the option ""0"". When selecting the option ""0"", the fitted function is added to; the list of functions of the histogram, but it is not drawn.; You can undo what you disabled in the following way:; h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; h.Draw(); function is not drawn; const Int_t kNotDraw = 1<<9;; h.GetFunction(""myFunction"")->ResetBit(kNotDraw);; h.Draw(); // function is visible again. Access to the Minimizer information during fitting. This function calls, the ROOT::Fit::FitObject function implemented in HFitImpl.cxx; which uses the ROOT::Fit::Fitter class. The Fitter class creates the objective fuction; (e.g. chi2 or likelihood) and uses an implementation of the Minimizer interface for minimizing; the function.; The default minimizer is Minuit (class TMinuitMinimizer which calls TMinuit).; The default can be set in the resource file in etc/system.rootrc. For example; Root.Fitter: Minuit2; A different fitter can also be set via ROOT::Math::MinimizerOptions::SetDefaultMinimizer; (or TVirtualFitter::SetDefaultFitter).; For example ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");; will set the usdage of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:80299,undo,undo,80299,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['undo'],['undo']
Usability,"lt; At the end of the loop, print the sum of all event sizes. This sum shows you the real power of a TTree: even though you can analyze large amounts of data (our example tree with 22MB is tiny!) ROOT needs just a few MB of your RAM, no matter how many events you analyze. Imagine what it would be like if you had to load all data into memory, e.g. using a simple vector!; ... Int_t sizeInMB = totalSize/1024/1024;; printf(""Total size of all events: %d MB\n"", sizeInMB);; }. Running the Macro; To run this macro, simply type .x AnalyzeTree.C and ROOT will execute it. If it finds an error it might be wise to quit ROOT (.q) and try again!; If, for any reason, you don't manage to get it working, you can download a working macro file here: CountEvents.C; Here again, if you are using ROOT via ssh, you have to download the file with wget from your remote directory:; wget http://root-mirror.github.io/training/intro/CountEvents.C; . ‹ TTree and Its Data; up; Histogramming ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:6319,guid,guidelines,6319,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,1,['guid'],['guidelines']
Usability,"ltSelectedBackground; static TList*TEveCompositeFrame::fgFrameList; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static const TStringTEveCompositeFrame::fgkEmptyFrameName; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveCompositeFrameInMainFrame(TGCompositeFrame* parent, TEveWindow* eve_parent, TGMainFrame* mf); Constructor. ~TEveCompositeFrameInMainFrame(); Destructor. void WindowNameChanged(const TString& name); Update widgets using window's name or title. void Destroy(); Virtual function called from eve side when the frame should be; destroyed. This means we expect that fEveWindow is null. We simply call CloseWindow() on the main-frame which will in; turn generate the ""CloseWindow()"" signal.; This is then handled in MainFrameClosed(). void SetOriginalSlotAndContainer(TEveWindow* slot, TEveWindow* container); Set the container where to return the contained window on destruction. void SomeWindowClosed(TEveWindow* w); Slot called when a window is closed ... we check that this was; not our original container. void MainFrameClosed(); Slot for main-frame's ""CloseWindow()"" signal.; If an eve window is still present, it will be put into:; - original-container, if it is set;; - into window-managers default-container. TEveCompositeFrame& operator=(const TEveCompositeFrameInMainFrame& ). TEveCompositeFrameInMainFrame(const TEveCompositeFrameInMainFrame& ). TEveWindow* GetOriginalSlot() const; { return fOriginalSlot; }. TEveWindow* GetOriginalContainer() const; { return fOriginalContainer; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCompositeFrameInMainFrame.html:21772,simpl,simply,21772,root/html602/TEveCompositeFrameInMainFrame.html,https://root.cern,https://root.cern/root/html602/TEveCompositeFrameInMainFrame.html,2,['simpl'],['simply']
Usability,"lude instead of ROOTINCDIR ROOT-7537. Interpreter. Fix redirection ROOT-7053; Take the language and target options from the PCH ROOT-7478 ROOT-6966; Properly recover from a template instantiation failure when looking up a class in the interpreter ROOT-7462; Do not clear pending instantiations upon unloading; fixes missing symbols due to missing function bodies ROOT-7586; Speed up significantly cling’s findType and remove its memory cost in most cases.; Make sure object declared on the interpreter stack are deleted at the end of the process ROOT-7673; Resolve issues with error recovery when the transaction includes template instantiation.; Fix handling of argument that negative integers in TClingCallFunc ROOT-7684. I/O. Fix memory leak in handling of I/O customization rules ROOT-7683; Set CheckSum of StreamerInfo of user classes that have a collection proxy. Tree. Fix ROOT-6885 which affects very large TChain with friend trees.; Fix ROOT-7423 which can stop the TTreeCache from stopping the learning phase when asynchronous prefetching is enabled. TTreeReader. Fix reading of data members of type BasicType[42]; Fix support for large file ROOT-7652. Geom. Fix missing OCC header file for the version ROOT-7536. Bugs. [ROOT-6419] - ROOT-6.00.01 fails to build with geocad support due to conficting function definition; [ROOT-6966] - MacOS 10.9 build cannot run on 10.10; [ROOT-7342] - Conflicting definitions of Printf function; [ROOT-7402] - Fix the inconsistency in ROOT_LINKER_LIBRARY() macro between 5 and 6 versions; [ROOT-7423] - Activating prefetching makes TTree iteration slower when reading through HTTP; [ROOT-7475] - TTreeReader is retrieving the containers properly, but when used in a for loop, the elements get somehow “overridden”; [ROOT-7478] - Generating PCH fails with CXX flags with spaces; [ROOT-7491] - TLatex display issues with root 6.04; [ROOT-7509] - Build Failure on FreeBSD 10.1; [ROOT-7515] - C++14 needs GCC 5.1; [ROOT-7536] - Missing include file; [ROOT-753",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:29960,learn,learning,29960,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['learn'],['learning']
Usability,"lue when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:134469,learn,learning,134469,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['learn'],['learning']
Usability,"lue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsAnaConvPdf.html:4296,clear,clearValueAndShapeDirty,4296,root/html532/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsAnaConvPdf.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"lue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:3396,clear,clearValueAndShapeDirty,3396,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"lue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:2997,clear,clearValueAndShapeDirty,2997,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,4,['clear'],['clearValueAndShapeDirty']
Usability,"lue);; f1->SetLineWidth(4);; f1->Draw(""same"");. const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeader(""The Legend Title"");; leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; leg->Draw();. return c1;; }. TLegend inherits from TAttText therefore changing any; text attributes (text alignmemt, font, color...) on a legend will changed the; text attributes on each line. In particular it can be interessting to change the text alignement that way. In; order to have a base-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLegend.html:2592,simpl,simply,2592,root/html534/TLegend.html,https://root.cern,https://root.cern/root/html534/TLegend.html,2,['simpl'],['simply']
Usability,"lue. void SetParameter(const char* par, Int_t value); Set an input list parameter. void SetParameter(const char* par, Long_t value); Set an input list parameter. void SetParameter(const char* par, Long64_t value); Set an input list parameter. void SetParameter(const char* par, Double_t value); Set an input list parameter. TObject * GetParameter(const char* par) const; Get specified parameter. A parameter set via SetParameter() is either; a TParameter or a TNamed or 0 in case par is not defined. void DeleteParameters(const char* wildcard); Delete the input list parameters specified by a wildcard (e.g. PROOF_*); or exact name (e.g. PROOF_MaxSlavesPerNode). void ShowParameters(const char* wildcard = ""PROOF_*"") const; Show the input list parameters specified by the wildcard.; Default is the special PROOF control parameters (PROOF_*). void AddFeedback(const char* name); Add object to feedback list. void RemoveFeedback(const char* name); Remove object from feedback list. void ClearFeedback(); Clear feedback list. void ShowFeedback() const; Show items in feedback list. TList * GetFeedbackList() const; Return feedback list. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TDrawFeedback * CreateDrawFeedback(); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. TList * GetOutputNames(); FIXME: to be written. void Browse(TBrowser* b); Build the PROOF's structure in the browser. void SetPlayer(TVirtualProofPlayer* player); Set a new PROOF player. TVirtualProofPlayer * MakePlayer(const char* player = 0, TSocket* s = 0); Construct a TProofPlayer object. The player string specifies which; player should be created: remote, slave, sm (supermaster) or base.; Default is remote. Socket is needed in case a slave player ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:74687,feedback,feedback,74687,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,['feedback'],['feedback']
Usability,"lue=true) const;  Add a subfield to the provided entry. ;  ; void EnsureNotBare () const;  Throws an RException if fDefaultEntry is nullptr. ;  ; void EnsureNotFrozen () const;  Throws an RException if fFrozen is true. ;  ; void EnsureValidFieldName (std::string_view fieldName);  Checks that user-provided field names are valid in the context of this NTuple model. ;  ; RFieldBase * FindField (std::string_view fieldName) const;  The field name can be a top-level field or a nested field. Returns nullptr if the field is not in the model. ;  . Private Attributes; std::unique_ptr< REntry > fDefaultEntry;  Contains field values corresponding to the created top-level fields, as well as registered subfields. ;  ; std::string fDescription;  Free text set by the user. ;  ; std::unordered_set< std::string > fFieldNames;  Keeps track of which field names are taken, including projected field names. ;  ; std::unique_ptr< RFieldZero > fFieldZero;  Hierarchy of fields consisting of simple types and collections (sub trees) ;  ; bool fIsFrozen = false;  Changed by Freeze() / Unfreeze() and by the RUpdater. ;  ; std::uint64_t fModelId = 0;  Every model has a unique ID to distinguish it from other models. ;  ; std::unique_ptr< Internal::RProjectedFields > fProjectedFields;  The set of projected top-level fields. ;  ; std::unordered_set< std::string > fRegisteredSubfields;  Keeps track of which subfields have been registered to be included in entries belonging to this model. ;  ; std::uint64_t fSchemaId = 0;  Models have a separate schema ID to remember that the clone of a frozen model still has the same schema. ;  . Friends; RFieldZero & Internal::GetFieldZeroOfModel (RNTupleModel &);  ; Internal::RProjectedFields & Internal::GetProjectedFieldsOfModel (RNTupleModel &);  . #include <ROOT/RNTupleModel.hxx>; Member Typedef Documentation. ◆ FieldMappingFunc_t. using ROOT::Experimental::RNTupleModel::FieldMappingFunc_t = std::function<std::string(const std::string &)>. User provided function ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html:5495,simpl,simple,5495,doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html,1,['simpl'],['simple']
Usability,"lues; and tolerance 'tolCor' on correlation coefficients. RooFitResult* lastMinuitFit(const RooArgList& varList = RooArgList()); Import the results of the last fit performed by gMinuit, interpreting; the fit parameters as the given varList of parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in his RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; is the Shur complement of V22, calculated as shown above. (Note that Vred is _not_ a simple sub-matrix of V). const TMatrixDSym& correlationMatrix() const; Return correlation matrix ;. RooAbsPdf* createHessePdf(const RooArgSet& params) const; Return a p.d.f that represents the fit result as a multi-variate probability densisty; function on the floating fit parameters, including correlations. void SetName(const char* name); Change name of RooFitResult object. void SetNameTitle(const char* name, const char* title); Change name and title of RooFitResult object. void printName(ostream& os) const; Print name of fit result. void printTitle(ostream& os) const; Print title of fit result. void printClassName(ostream& os) const; Print class name of fit result. void printArgs(ostream& os) const; Print arguments of fit result, i.e. the parameters of the fit. void printValue(ostream& os) const; Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. Int_t defaultPrintContents(Option_t* opt) const; Configure default contents to be print",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFitResult.html:14716,simpl,simple,14716,root/html526/RooFitResult.html,https://root.cern,https://root.cern/root/html526/RooFitResult.html,3,['simpl'],['simple']
Usability,"lume.cxx. ◆ ResetTransparency(). void TGeoVolume::ResetTransparency ; (; Char_t ; transparency = -1). inline . Definition at line 383 of file TGeoVolume.h. ◆ SaveAs(). void TGeoVolume::SaveAs ; (; const char * ; filename = """", . Option_t * ; option = """" . ); const. overridevirtual . Save geometry having this as top volume as a C++ macro. ; Reimplemented from TObject.; Definition at line 1447 of file TGeoVolume.cxx. ◆ SavePrimitive(). void TGeoVolume::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TObject.; Definition at line 1535 of file TGeoVolume.cxx. ◆ SelectVolume(). void TGeoVolume::SelectVolume ; (; Bool_t ; clear = kFALSE). Select this volume as matching an arbitrary criteria. ; The volume is added to a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need to be reset at the end by calling the method with CLEAR=true. This will also clear the list. ; Definition at line 2325 of file TGeoVolume.cxx. ◆ SetActiveDaughters(). void TGeoVolume::SetActiveDaughters ; (; Bool_t ; flag = kTRUE). inline . Definition at line 213 of file TGeoVolume.h. ◆ SetActivity(). void TGeoVolume::SetActivity ; (; Bool_t ; flag = kTRUE). inline . Definition at line 212 of file TGeoVolume.h. ◆ SetAdded(). void TGeoVolume::SetAdded ; (; ). inline . Definition at line 215 of file TGeoVolume.h. ◆ SetAsTopVolume(). void TGeoVolume::SetAsTopVolume ; (; ). Set this volume as the TOP one (the whole geometry starts from here) ; Definition at line 2051 of file TGeoVolume.cxx. ◆ SetAttVisibility(). void TGeoVolume::SetAttVisibility ; (; Bool_t ; vis). inline . Definition at line 233 of file TGeoVolume.h. ◆ SetCurrentPoint(). void TGeoVolume::SetCurrentPoint ; (; Double_t ; x, . Double_t ; y, . Double_t ; z . ). Set the current tracking point. ; Definition at line 2059 of file TGeoVolume.cxx. ◆ SetCylVoxels(). void TGeoVolume::SetCylVoxels ; (; Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:63595,clear,clear,63595,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['clear'],['clear']
Usability,"lumn_min_percent = 50, . int ; last_column_own_line_max_percent = 75 . ). Definition at line 2806 of file OptionParser.h. ◆ printUsage() [3/5]. template<typename Function , typename Stream > . void ROOT::option::printUsage ; (; Function * ; prn, . Stream * ; stream, . const Descriptor ; usage[], . int ; width = 80, . int ; last_column_min_percent = 50, . int ; last_column_own_line_max_percent = 75 . ). Definition at line 2830 of file OptionParser.h. ◆ printUsage() [4/5]. template<typename OStream > . void ROOT::option::printUsage ; (; OStream & ; prn, . const Descriptor ; usage[], . int ; width = 80, . int ; last_column_min_percent = 50, . int ; last_column_own_line_max_percent = 75 . ). Outputs a nicely formatted usage string with support for multi-column formatting and line-wrapping. ; printUsage() takes the help texts of a Descriptor[] array and formats them into a usage message, wrapping lines to achieve the desired output width.; Table formatting:; Aside from plain strings which are simply line-wrapped, the usage may contain tables. Tables are used to align elements in the output.; // Without a table. The explanatory texts are not aligned.; -c, --create |Creates something.; -k, --kill |Destroys something.; ; // With table formatting. The explanatory texts are aligned.; -c, --create |Creates something.; -k, --kill |Destroys something.; c#define c(i)Definition RSha256.hxx:101; Table formatting removes the need to pad help texts manually with spaces to achieve alignment. To create a table, simply insert \t (tab) characters to separate the cells within a row.; const option::Descriptor usage[] = {; {..., ""-c, --create \tCreates something."" },; {..., ""-k, --kill \tDestroys something."" }, ...; Note that you must include the minimum amount of space desired between cells yourself. Table formatting will insert further spaces as needed to achieve alignment.; You can insert line breaks within cells by using \v (vertical tab).; const option::Descriptor usage[] = {; {..., ""-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1option.html:6468,simpl,simply,6468,doc/master/namespaceROOT_1_1option.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1option.html,1,['simpl'],['simply']
Usability,"lumn_min_percent = 50, . int ; last_column_own_line_max_percent = 75 . ). Definition at line 2806 of file OptionParser.h. ◆ printUsage() [3/5]. template<typename Function , typename Stream > . void ROOT::option::printUsage ; (; Function * ; prn, . Stream * ; stream, . const Descriptor ; usage[], . int ; width = 80, . int ; last_column_min_percent = 50, . int ; last_column_own_line_max_percent = 75 . ). Definition at line 2830 of file OptionParser.h. ◆ printUsage() [4/5]. template<typename OStream > . void ROOT::option::printUsage ; (; OStream & ; prn, . const Descriptor ; usage[], . int ; width = 80, . int ; last_column_min_percent = 50, . int ; last_column_own_line_max_percent = 75 . ). Outputs a nicely formatted usage string with support for multi-column formatting and line-wrapping. ; printUsage() takes the help texts of a Descriptor[] array and formats them into a usage message, wrapping lines to achieve the desired output width.; Table formatting:; Aside from plain strings which are simply line-wrapped, the usage may contain tables. Tables are used to align elements in the output.; // Without a table. The explanatory texts are not aligned.; -c, --create |Creates something.; -k, --kill |Destroys something.; ; // With table formatting. The explanatory texts are aligned.; -c, --create |Creates something.; -k, --kill |Destroys something.; c#define c(i)Definition RSha256.hxx:101; createvirtual RooAbsTestStatistic * create(const char *name, const char *title, RooAbsReal &real, RooAbsData &data, const RooArgSet &projDeps, Configuration const &cfg)=0; Table formatting removes the need to pad help texts manually with spaces to achieve alignment. To create a table, simply insert \t (tab) characters to separate the cells within a row.; const option::Descriptor usage[] = {; {..., ""-c, --create \tCreates something."" },; {..., ""-k, --kill \tDestroys something."" }, ...; Note that you must include the minimum amount of space desired between cells yourself. Table formatting wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1option.html:6467,simpl,simply,6467,doc/v632/namespaceROOT_1_1option.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1option.html,1,['simpl'],['simply']
Usability,"lution operator PDF. convVar : convolution variable (on which both pdf and resmodel should depend); pdf : input 'physics' pdf; resmodel : input 'resultion' pdf. output is pdf(x) (X) resmodel(x) = Int [ pdf(x') resmodel (x-x') ] dx'. RooNumConvPdf(const RooNumConvPdf& other, const char* name = 0); Copy constructor. ~RooNumConvPdf(); Destructor. Double_t evaluate() const; Calculate and return value of p.d.f. void initialize() const; One-time initialization of object. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return appropriate generator context for this convolved p.d.f. If both pdf and resolution; model support internal generation return and optimization convolution generation context; that uses a smearing algorithm. Otherwise return a standard accept/reject sampling; context on the convoluted shape. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooNumConvPdf(*this,newname) ; }. RooNumIntConfig& convIntConfig(); Calls forwarded to RooNumConvolution. { return conv().convIntConfig() ; }. void clearConvolutionWindow(); { conv().clearConvolutionWindow() ; }. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); { conv().setConvolutionWindow(centerParam,widthParam,widthScaleFactor) ; }. void setCallWarning(Int_t threshold = 2000); { conv().setCallWarning(threshold) ; }. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); { conv().setCallProfiling(flag,nbinX,nbinCall,nCallHigh) ; }. const TH2* profileData() const; { return conv().profileData() ; }. RooRealVar& var() const; Access components. { return (RooRealVar&)(const_cast<RooAbsReal&>(_origVar.arg())) ; }. RooAbsReal& pdf() const; { return co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:43376,intuit,intuitively,43376,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,7,['intuit'],['intuitively']
Usability,"lution(); this function is called from ""init"" and controls the evolution of the; individuals.; the function can be overridden to change the parameters for mutation rate; sexual reproduction and so on. Double_t SpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); this function provides the ability to change the stepSize of a mutation according to; the success of the last generations. Parameters:; int ofSteps : = if OF the number of STEPS given in this variable (ofSteps); int successSteps : >sucessSteps Generations could improve the result; double factor : than multiply the stepSize ( spread ) by this factor; (if ofSteps == successSteps nothing is changed, if ofSteps < successSteps, the spread; is divided by the factor). using this function one can increase the stepSize of the mutation when we have; good success (to pass fast through the easy phase-space) and reduce the stepSize; if we are in a difficult ""territory"" of the phase-space. Bool_t HasConverged(Int_t steps = 10, Double_t ratio = 0.1); gives back true if the last ""steps"" steps have lead to an improvement of the; ""fitness"" of the ""individuals"" of at least ""improvement"". this gives a simple measure of if the fitness of the individuals is; converging and no major improvement is to be expected soon. GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0). GeneticPopulation& GetGeneticPopulation(); { return fPopulation; }. Double_t GetSpread() const; { return fSpread; }. void SetSpread(Double_t s); { fSpread = s; }. void SetMakeCopies(Bool_t s); { fMakeCopies = s; }. Bool_t GetMakeCopies(); { return fMakeCopies; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GeneticAlgorithm.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__GeneticAlgorithm.html:5154,simpl,simple,5154,root/html532/TMVA__GeneticAlgorithm.html,https://root.cern,https://root.cern/root/html532/TMVA__GeneticAlgorithm.html,1,['simpl'],['simple']
Usability,"lutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGaussModel.html:3302,clear,clearShapeDirty,3302,root/html532/RooGaussModel.html,https://root.cern,https://root.cern/root/html532/RooGaussModel.html,3,['clear'],['clearShapeDirty']
Usability,"lutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGaussModel.html:3302,clear,clearShapeDirty,3302,root/html528/RooGaussModel.html,https://root.cern,https://root.cern/root/html528/RooGaussModel.html,3,['clear'],['clearShapeDirty']
Usability,"lutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGaussModel.html:3302,clear,clearShapeDirty,3302,root/html530/RooGaussModel.html,https://root.cern,https://root.cern/root/html530/RooGaussModel.html,3,['clear'],['clearShapeDirty']
Usability,"lvirtual TLeaf * GetLeafImpl(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree::Showvirtual void Show(Long64_t entry=-1, Int_t lenmax=20)Print values of all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t GetMedianClusterSize()Estimate the median cluster size for the TTree.Definition TTree.cxx:8297; TTree::GetClusterIteratorvirtual TClusterIterator G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:437074,learn,learning,437074,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['learn'],['learning']
Usability,"lways visible, having a scroll bar when the displayed area is not enough to show all items. The choices may be mutually exclusive (a list box with single selection) or not mutually exclusive (a list box with multiple selection). The proper usage of the list boxes is for selecting values, or objects, or setting attributes. You have to create them to display 4 to 8 choices at one time (3 is a required minimum in case of lack of screen space). The list should contain not more than 40 items accessible by scrolling view (vertical scroll bar). If more are required, you should provide a method for using search criteria or scoping the options. The best list boxes use is for textual data or choices. They should be wide enough to display fully all items. When it is not possible, break the long items with ellipsis and provide tool tip that displays the full item text.; The list box widget is represented by TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry classes. Currently entries are simple text strings (TGTextLBEntry). A TGListBox looks a lot like a TGCanvas. It has a TGViewPort containing a TGLBContainer which contains the entries and it also has a vertical scrollbar which becomes visible if there are more items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service classes of the list box. Here is a sample code showing how to create a list box with ten entries:; // list box widget containing 10 entries; int fFirstEntry = 0, fLastEntry = 10;; char tmp[20];; TGListBox *fListBox = new TGListBox(parent, 90);; for (i = fFirstEntry; i < fLastEntry; i++) {; sprintf(tmp, ""Entry %i"", i+1);; fListBox->AddEntry(tmp, i);; }; fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; We create the list box widget passing the parent window pointer and giving an ID number. Next we add entries with specified string and ID to the list box. Before adding the list box to its parent ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1200044,simpl,simple,1200044,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"ly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValueDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; virtual value_type evaluate () const =0;  Evaluate the category state and return. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:36240,clear,clearTypes,36240,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['clear'],['clearTypes']
Usability,"ly a group of logically connected widgets: radio buttons, related check boxes, two or more functionally related controls. It is a composite frame with a border and a title. The title explains the purpose of the group and should be a noun or noun phrase. Here is an example taken from guitest.C:; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; The second line sets the title position on the left. You can change it to be centered or right aligned if you use TGGroupFrame::kCenter or TGGroupFrame::kRight as a parameter. Be conservative in the use of borders because of the potential for clutter. Do not place them around single entry fields, single combo boxes, list boxes and groups of command buttons. The design of these widgets provides them with a border. The picture above provides kind of borders to avoid.; 25.6 Layout Management; The layout process is an integral part of any GUI. When you create a simple message window, laying out its few buttons and text widgets is quite simple. However, this process becomes increasingly difficult if you have to implement large GUI’s with many widgets that should behave properly when the GUI is resized or uses a different font type or size. Layout management is the process of determining the size and position of every widget in a container.; A layout manager is an object that performs layout management for the widgets within a container. You already know that when adding a component (child widget) to a container (parent widget) you can provide alignment hints (or rely on the default ones). These hints are used by the layout manager to correctly position the widgets in the container. The TGLayoutManager is an abstract class providing the basic layout functionality. The layout classes hierarchy. The base “container” class is TGCmpositeFrame. You can easily change the layout manager using the SetLayoutManager(TGLayoutManager *l) method. Setting the proper layout manager for each",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1157535,simpl,simple,1157535,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"ly discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. Bool_t IgnoreSizeForOfInterest() const; Return true if size of this shape should be ignored when determining if; the object should be drawn. In this base-class we simply return state of; static flag fgIgnoreSizeForCameraInterest. Several sub-classes override this virtual function. Bool_t GetIgnoreSizeForCameraInterest(); Get state of static fgIgnoreSizeForCameraInterest flag.; When this is true all objects, also very small, will be drawn by GL. void SetIgnoreSizeForCameraInterest(Bool_t isfci); Set state of static fgIgnoreSizeForCameraInterest flag. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalShape* Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLLogicalShape.html:7805,simpl,simply,7805,root/html534/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html534/TGLLogicalShape.html,1,['simpl'],['simply']
Usability,"ly discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. Bool_t IgnoreSizeForOfInterest() const; Return true if size of this shape should be ignored when determining if; the object should be drawn. In this base-class we simply return state of; static flag fgIgnoreSizeForCameraInterest. Several sub-classes override this virtual function. Bool_t GetIgnoreSizeForCameraInterest(); Get state of static fgIgnoreSizeForCameraInterest flag.; When this is true all objects, also very small, will be drawn by GL. void SetIgnoreSizeForCameraInterest(Bool_t isfci); Set state of static fgIgnoreSizeForCameraInterest flag. TGLLogicalShape(const TGLLogicalShape& ). TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLLogicalShape.html:8256,simpl,simply,8256,root/html602/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html,2,['simpl'],['simply']
Usability,"ly discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalShape* GetFirstPhysical() const; { return fFirstPhysical; }. TObject* ID() const; { return fExternalObj; }. TObject* GetExternal() const; { return fExternalObj; }. TGLScene* GetScene() const; { return fScene; }. void UpdateBoundingBox(); {}. UInt_t DLOffset(Short_t ) const; { return 0; }. ELODAxes SupportedLODAxes() const; { return kLODAxesNone; }. void DirectDraw(TGLRnrCtx& rnrCtx) const. Bool_t IgnoreSizeForOfInterest() const; { return kFALSE; }. Bool_t KeepDuringSmartRefresh() const; Override in sub-classes that do direct object rendering (e.g. TGLObject).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLLogicalShape.html:7640,simpl,simply,7640,root/html528/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html,3,['simpl'],['simply']
Usability,"ly thread-safe and asynchronous interfaces. More robust interfaces; Compile-time type safety by default; Decomposition into layers: logical layer, primitives layer, storage layer; Separation of data model and live data; Self-contained I/O code to support creation of a standalone I/O library. Concepts; At the logical layer, the user defines a data model using the RNTupleModel class. The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree. The data model can contain (nested) collections, e.g., a type can be std::vector<std::vector<float>>.; Each serializable type is represented by a field, concretely by a templated version of RField, e.g. RField<double>. A field can generate or adopt an associated value, which represents a memory location storing a value of the given C++ type. These distinguished memory locations are the destinations and sources for the deserialization and serialization.; The (de-)serialization is a mapping from the C++ type to the more simple column type system. A column contains an arbitrary number of fixed-sized elements of a well-defined set of types: integers and floats of different bit sizes. A C++ type may be mapped to multiple columns. For instance, an std::vector<float> maps to two columns, an offset column indicating the size of the vector per entry, and a payload column with the float data.; Columns are partitioned into pages (roughly: TTree baskets) of a few kB – a few tens of kB each. The physical layer (only) needs to provide the means to store and retrieve pages. The physical layer is decoupled from the high-level C++ logic. The physical layer implements an abstract page storage interface, so that dedicated implementations for key-value stores and other storage systems are conceivable. At this point, the only provided backend stores the pages in ROOT files.; RNTuples are further grouped into clusters, which are, like TTree clusters, self-contained blocks of consecutive entries. Clus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html:2271,simpl,simple,2271,doc/master/md_tree_2ntuple_2v7_2doc_2README.html,https://root.cern,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html,1,['simpl'],['simple']
Usability,"ly, TProfile, TProfile2D, and TProfile3D.; Definition at line 2840 of file TH1.cxx. ◆ DoFillN(). void TH1::DoFillN ; (; Int_t ; ntimes, . const Double_t * ; x, . const Double_t * ; w, . Int_t ; stride = 1 . ). protectedvirtual . Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty. ; Definition at line 3473 of file TH1.cxx. ◆ DoIntegral(). Double_t TH1::DoIntegral ; (; Int_t ; ix1, . Int_t ; ix2, . Int_t ; iy1, . Int_t ; iy2, . Int_t ; iz1, . Int_t ; iz2, . Double_t & ; err, . Option_t * ; opt, . Bool_t ; doerr = kFALSE . ); const. protectedvirtual . Internal function compute integral and optionally the error between the limits specified by the bin number values working for all histograms (1D, 2D and 3D) ; Definition at line 7977 of file TH1.cxx. ◆ Draw(). void TH1::Draw ; (; Option_t * ; option = """"). overridevirtual . Draw this histogram with options. ; Histograms are drawn via the THistPainter class. Each histogram has a pointer to its own painter (to be usable in a multithreaded program). The same histogram can be drawn with different options in different pads. When a histogram drawn in a pad is deleted, the histogram is automatically removed from the pad or pads where it was drawn. If a histogram is drawn in a pad, then filled again, the new status of the histogram will be automatically shown in the pad next time the pad is updated. One does not need to redraw the histogram. To draw the current version of a histogram in a pad, one can use h->DrawCopy(); This makes a clone of the histogram. Once the clone is drawn, the original histogram may be modified or deleted without affecting the aspect of the clone. By default, TH1::Draw clears the current pad.; One can use TH1::SetMaximum and TH1::SetMinimum to force a particular value for the maximum or the minimum scale on the plot.; TH1::UseCurrentStyle can be used to change all histogram graphics attributes to correspond to the current selected style. This function must be called",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:108625,usab,usable,108625,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['usab'],['usable']
Usability,"l _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static RooArgSet _emptySet;  Supports named argument constructor. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions;  RooChi2Var (const char *name, const char *title, RooAbsReal &func, RooDataHist &data, const RooArgSet &projDeps, FuncMode funcMode, RooAbsTestStatistic::Configuration const &cfg, RooDataHist::ErrorType etype);  . Additional Inherited Members;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:66127,clear,clearEvalErrorLog,66127,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['clear'],['clearEvalErrorLog']
Usability,"m ""col"" is missing, the entire entry will be filtered out; df_available = df.FilterAvailable(""col""); df_available = df_available.Define(""twice"", ""col * 2""); ; # Conversely, if we want to select the entries for which the column has missing; # values, we do the following; df_missingcol = df.FilterMissing(""col""); # Following operations in the same branch of the computation graph clearly; # cannot access that same column, since there would be no value to read; df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); ROOT::RDataFrame df{dataset};; ; // Anytime an entry from ""col"" is missing, the entire entry will be filtered out; auto df_available = df.FilterAvailable(""col"");; auto df_twicecol = df_available.Define(""twice"", ""col * 2"");; ; // Conversely, if we want to select the entries for which the column has missing; // values, we do the following; auto df_missingcol = df.FilterMissing(""col"");; // Following operations in the same branch of the computation graph clearly; // cannot access that same column, since there would be no value to read; auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; DefaultValueFor; DefaultValueFor creates a node of the computation graph which just forwards the values of the columns necessary for other downstream nodes, when they are available. In case a value of the input column passed to this function is not available, the node will provide the default value passed to this function call instead. Example:; df = ROOT.RDataFrame(dataset); # Anytime an entry from ""col"" is missing, the value will be the default one; default_value = ... # Some sensible default value here; df = df.DefaultValueFor(""col"", default_value) ; df = df.Define(""twice"", ""col * 2""); ROOT::RDataFrame df{dataset};; // Anytime an entry from ""col"" is missing, the value will be the default one; constexpr auto default_value = ... // Some sensible default value here; auto df_default = df.DefaultValueFor(""col"", default_value);; auto df_col = df",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:83729,clear,clearly,83729,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['clear'],['clearly']
Usability,"m &other, const char *name=nullptr);  Copy constructor. ;  ; TObject * clone (const char *newname) const override;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; TClass * IsA () const override;  ; const RooArgList & list ();  ; bool setData (RooAbsData &data, bool cloneData=true) override;  Replace the variables in this RooConstraintSum with the global observables in the dataset if they match by name. ;  ; bool setData (RooAbsData const &data, bool cloneData=true);  Replace the variables in this RooConstraintSum with the global observables in the dataset if they match by name. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; virtual double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConstraintSum.html:2129,simpl,simple,2129,doc/master/classRooConstraintSum.html,https://root.cern,https://root.cern/doc/master/classRooConstraintSum.html,1,['simpl'],['simple']
Usability,m color to operations. ; Definition at line 178 of file TWebPainting.cxx. ◆ AddFillAttr(). void TWebPainting::AddFillAttr ; (; const TAttFill & ; attr). Store fill attributes If attributes were not changed - ignore operation. ; Definition at line 131 of file TWebPainting.cxx. ◆ AddLineAttr(). void TWebPainting::AddLineAttr ; (; const TAttLine & ; attr). Store line attributes If attributes were not changed - ignore operation. ; Definition at line 113 of file TWebPainting.cxx. ◆ AddMarkerAttr(). void TWebPainting::AddMarkerAttr ; (; const TAttMarker & ; attr). Store marker attributes If attributes were not changed - ignore operation. ; Definition at line 161 of file TWebPainting.cxx. ◆ AddOper(). void TWebPainting::AddOper ; (; const std::string & ; oper). Add next custom operator to painting Operations are separated by semicolons Following operations are supported: t - text h - text coded into simple hex r - rectangle b - rectangular fill region l - polyline f - poly fill region m - poly marker z - line attributes y - fill attributes x - marker attributes o - text attributes After operation code optional arguments can be append like length of operation or coded text Each operation may use data from binary float buffer. ; Definition at line 53 of file TWebPainting.cxx. ◆ AddTextAttr(). void TWebPainting::AddTextAttr ; (; const TAttText & ; attr). Store text attributes If attributes were not changed - ignore operation. ; Definition at line 147 of file TWebPainting.cxx. ◆ Class(). static TClass * TWebPainting::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TWebPainting::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TWebPainting::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 59 of file TWebPainting.h. ◆ DeclFileName(). static const char * TWebPainting::DeclFileName ; (; ). inlinestatic . ReturnsName of the file contain,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebPainting.html:13081,simpl,simple,13081,doc/master/classTWebPainting.html,https://root.cern,https://root.cern/doc/master/classTWebPainting.html,1,['simpl'],['simple']
Usability,"m fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:15890,learn,learning,15890,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['learn'],['learning']
Usability,"m for TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Matrix_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 47 of file Optimizer.h. ◆ Scalar_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 48 of file Optimizer.h. Constructor & Destructor Documentation. ◆ VOptimizer(). template<typename Architecture_t , typename Layer_t , typename DeepNet_t > . TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::VOptimizer ; (; Scalar_t ; learningRate, . DeepNet_t & ; deepNet . ). Constructor. ; Definition at line 94 of file Optimizer.h. ◆ ~VOptimizer(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . virtual TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::~VOptimizer ; (; ). virtualdefault . Virtual Destructor. . Member Function Documentation. ◆ GetGlobalStep(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . size_t TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::GetGlobalStep ; (; ); const. inline . Definition at line 81 of file Optimizer.h. ◆ GetLayerAt(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Layer_t * TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html:3121,learn,learningRate,3121,doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,1,['learn'],['learningRate']
Usability,"m specified with the TUnfold constructor). The indexes of binMap correspond to the truth bins (including underflow and overflow) of the response matrix. The element binMap[i] specifies the histogram number in output where the corresponding truth bin will be stored. It is possible to specify the same output bin number for multiple indexes, in which case these bins are added. Set binMap[i]=-1 to ignore an unfolded truth bin. The uncertainties are calculated from the corresponding parts of the covariance matrix, properly taking care of added truth bins. ; If the pointer binMap is zero, the bins are mapped one-to-one. Truth bin zero (underflow) is stored in the output underflow, truth bin 1 is stored in bin number 1, etc. ; Definition at line 3289 of file TUnfold.cxx. ◆ GetOutputBinName(). TString TUnfold::GetOutputBinName ; (; Int_t ; iBinX); const. protectedvirtual . Get bin name of an outpt bin. ; Parameters. [in]iBinXbin number. Return value: name of the bin ; For TUnfold and TUnfoldSys, this function simply returns the bin number as a string. This function really only makes sense in the context of TUnfoldDensity, where binnig schemes are implemented using the class TUnfoldBinning, and non-trivial bin names are returned. ; Reimplemented in TUnfoldDensity.; Definition at line 1667 of file TUnfold.cxx. ◆ GetProbabilityMatrix(). void TUnfold::GetProbabilityMatrix ; (; TH2 * ; A, . EHistMap ; histmap . ); const. get matrix of probabilities ; Parameters. [out]Atwo-dimensional histogram to store the probabilities (normalized response matrix). The bin contents are overwritten for those bins where A is nonzero ; [in]histmapspecify axis along which the truth bins are oriented . Definition at line 3010 of file TUnfold.cxx. ◆ GetRhoAvg(). Double_t TUnfold::GetRhoAvg ; (; void ; ); const. inline . get average global correlation determined in recent unfolding ; Definition at line 327 of file TUnfold.h. ◆ GetRhoI(). Double_t TUnfold::GetRhoI ; (; TH1 * ; rhoi, . const Int_t * ; bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:41950,simpl,simply,41950,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['simpl'],['simply']
Usability,"m with options.Definition TH1.cxx:3066; TLegend::TLegendTLegend()Default constructor.Definition TLegend.cxx:200; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; exDouble_t ex[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11. TLegend inherits from TAttText therefore changing any text attributes (text alignment, font, color...) on a legend will changed the text attributes on each line.; In particular it can be interesting to change the text alignement that way. In order to have a base-line vertical alignment instead of a centered one simply do: legend->SetTextAlign(13);; or legend->SetTextAlign(11);; The default value of some TLegend attributes can be changed using gStyle. The default settings are: SetLegendBorderSize(1);; SetLegendFillColor(0);; SetLegendFont(42);; SetLegendTextSize(0.);; The global attributes change the default values for the next created legends.; Text attributes can be also changed individually on each legend entry: TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TLegendEntryStorage class for one entry of a TLegend.Definition TLegendEntry.h:25; leglegDefinition legend1.C:34; Note that the TPad class has a method to build automatically a legend for all objects in the pad. It is called TPad::BuildLegend().; Each item in the legend is added using the AddEntry method. This method defines the object to be added (by reference or name), the label associated to this o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLegend.html:5114,simpl,simply,5114,doc/master/classTLegend.html,https://root.cern,https://root.cern/doc/master/classTLegend.html,1,['simpl'],['simply']
Usability,"m->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQCommand(const TQCommand& com); TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:3016,undo,undo,3016,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,4,['undo'],['undo']
Usability,"m->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQUndoManager(); virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::Appen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:3015,undo,undo,3015,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,4,['undo'],['undo']
Usability,"m->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:3040,undo,undo,3040,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,2,['undo'],['undo']
Usability,"m->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:3039,undo,undo,3039,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,2,['undo'],['undo']
Usability,"m_{\rm ES}}\) , \(\Delta E\) and \({\cal F}\). The variable which is not incorporated in \(y\) is used as the control variable \(x\) . The six distributions of the three variables are assumed to be the ones depicted in Fig. 1. Figure 1 ; Distributions of the three discriminating variables available to perform the Likelihood fit: \({m_{\rm ES}}\) , \(\Delta E\) , \({\cal F}\) . Among the three variables, two are used to perform the fit while one is kept out of the fit to serve the purpose of a control variable. The three distributions on the top (resp. bottom) of the figure correspond to the signal (resp. background). The unit of the vertical axis is chosen such that it indicates the number of entries per bin, if one slices the histograms in 25 bins.; A data sample being built through a Monte Carlo simulation based on the distributions shown in Fig. 1, one obtains the three distributions of Fig. 2. Whereas the distribution of \(\Delta E\) clearly indicates the presence of the signal, the distribution of \({m_{\rm ES}}\) and \({\cal F}\) are less obviously populated by signal. Figure 2 ; Distributions of the three discriminating variables for signal plus background. The three distributions are the ones obtained from a data sample obtained through a Monte Carlo simulation based on the distributions shown in Fig. 1. The data sample consists of 500 signal events and 5000 background events.; Choosing \(\Delta E\) and \({\cal F}\) as discriminating variables to determine \(N_1\) and \(N_2\) through a maximum Likelihood fit, one builds, for the control variable \({m_{\rm ES}}\) which is unknown to the fit, the two \(\hbox {$_s$}{\cal P}lots\) for signal and background shown in Fig. 3. One observes that the \(\hbox{$_s$}{\cal P}lot\) for signal reproduces correctly the PDF even where the latter vanishes, although the error bars remain sizeable. This results from the almost complete cancellation between positive and negative weights: the sum of weights is close to zero while t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSPlot.html:8050,clear,clearly,8050,doc/master/classTSPlot.html,https://root.cern,https://root.cern/doc/master/classTSPlot.html,1,['clear'],['clearly']
Usability,"maining time (per file being processed). It is recorded and printed in the terminal every m events and every ; 1521n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. ; 1522 ; 1523ProgressBar is added after creating the dataframe object (df):; 1524~~~{.cpp}; 1525ROOT::RDataFrame df(""tree"", ""file.root"");; 1526ROOT::RDF::Experimental::AddProgressBar(df);; 1527~~~; 1528 ; 1529Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility ; 1530For example, it can be called at any computational node, such as Filter or Define, not only the head node,; 1531with no change to the ProgressBar function itself (please see the [Efficient analysis in Python](#python) ; 1532section for appropriate usage in Python): ; 1533~~~{.cpp}; 1534ROOT::RDataFrame df(""tree"", ""file.root"");; 1535auto df_1 = ROOT::RDF::RNode(df.Filter(""x>1""));; 1536ROOT::RDF::Experimental::AddProgressBar(df_1);; 1537~~~; 1538Examples of implemented progress bars can be seen by running [Higgs to Four Lepton tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html) and [Dimuon tutorial](https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html). ; 1539 ; 1540*/; 1541// clang-format on; 1542 ; 1543namespace ROOT {; 1544 ; 1545using ROOT::RDF::ColumnNames_t;; 1546using ColumnNamesPtr_t = std::shared_ptr<const ColumnNames_t>;; 1547 ; 1548////////////////////////////////////////////////////////////////////////////; 1549/// \brief Build the dataframe.; 1550/// \param[in] treeName Name of the tree contained in the directory; 1551/// \param[in] dirPtr TDirectory where the tree is stored, e.g. a TFile.; 1552/// \param[in] defaultColumns Collection of default columns.; 1553///; 1554/// The default columns are looked at in case no column is specified in the; 1555/// booking of actions or transformations.; 1556/// \see ROOT::RDF::RInterface for the documentation of the methods available.; 1557RDataF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:86840,progress bar,progress bars,86840,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['progress bar'],['progress bars']
Usability,"maining time (per file being processed). It is recorded and printed in the terminal every m events and every ; 1561n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. ; 1562 ; 1563ProgressBar is added after creating the dataframe object (df):; 1564~~~{.cpp}; 1565ROOT::RDataFrame df(""tree"", ""file.root"");; 1566ROOT::RDF::Experimental::AddProgressBar(df);; 1567~~~; 1568 ; 1569Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility ; 1570For example, it can be called at any computational node, such as Filter or Define, not only the head node,; 1571with no change to the ProgressBar function itself (please see the [Efficient analysis in Python](#python) ; 1572section for appropriate usage in Python): ; 1573~~~{.cpp}; 1574ROOT::RDataFrame df(""tree"", ""file.root"");; 1575auto df_1 = ROOT::RDF::RNode(df.Filter(""x>1""));; 1576ROOT::RDF::Experimental::AddProgressBar(df_1);; 1577~~~; 1578Examples of implemented progress bars can be seen by running [Higgs to Four Lepton tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html) and [Dimuon tutorial](https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html). ; 1579 ; 1580\anchor missing-values; 1581### Working with missing values in the dataset; 1582 ; 1583In certain situations a dataset might be missing one or more values at one or; 1584more of its entries. For example:; 1585 ; 1586- If the dataset is composed of multiple files and one or more files is; 1587 missing one or more columns required by the analysis.; 1588- When joining different datasets horizontally according to some index value; 1589 (e.g. the event number), if the index does not find a match in one or more; 1590 other datasets for a certain entry.; 1591 ; 1592For example, suppose that column ""y"" does not have a value for entry 42:; 1593 ; 1594\code{.unparsed}; 1595+-------+---+---+; 1596| Entry | x | y |; 1597+-------+---+---+; 1598| 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:88520,progress bar,progress bars,88520,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['progress bar'],['progress bars']
Usability,"malized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. One can also call TF1::GetRandom to get a random variate from a function. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*-*-*Fill histogram following distribution in histogram h*-*-*-*. The distribution contained in the histogram h (TH1) is integrated; over the channel contents for the bin range of this histogram.; It is normalized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. SPECIAL CASE when the target histogram has the same binning as the source.; in this case we simply use a poisson distribution where; the mean value per bin = bincontent/integral. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*. Int_t FindBin(Double_t x, Double_t y = 0, Double_t z = 0); Return Global bin number corresponding to x,y,z. 2-D and 3-D histograms are represented with a one dimensional; structure. This function tries to rebin the axis if the given point; belongs to an under-/overflow bin.; This has the advantage that all existing functions, such as; GetBinContent, GetBinError, GetBinFunction work for all dimensions.; See also TH1::GetBin, TAxis::FindBin and TAxis::FindFixBin; -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Int_t FindFixBin(Double_t x, Double_t y = 0, Double_t z = 0) const; Return Global bin number corresponding to x,y,z. 2-D and 3-D histograms are represented with a one dimensional; structure. This function DOES not try to rebin the axis if the given; point belongs to an under-/overflow bin.; This has the advantage that all existing fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:68908,simpl,simply,68908,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['simpl'],['simply']
Usability,"mand * ; c). virtual . Compress command. ; Compression is analogous to arithmetic ""addition operation"".; Note:; The compressed command will be deleted.; Execution Compress method invokes Redo action with new redo arguments inherited from compressed command. More complicated commands might want to override this function. ; Definition at line 402 of file TQCommand.cxx. ◆ DeclFileName(). static const char * TQCommand::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 98 of file TQCommand.h. ◆ Delete(). void TQCommand::Delete ; (; Option_t * ; opt = """"). overridevirtual . If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ; If ""opt"" is zero - delete all merged commands. ; Reimplemented from TList.; Definition at line 285 of file TQCommand.cxx. ◆ GetCommand(). TQCommand * TQCommand::GetCommand ; (; ). static . Return a command which is doing redo/undo action. ; This static method allows to set undo parameters dynamically, i.e. during execution of Redo function.; Example: For redo actions like TGTextEdit::DelChar() it is not possible to know ahead what character will be deleted. To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)), one needs to call TQCommand::SetUndoArgs(1, character) from inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);; TQCommand::GetCommandstatic TQCommand * GetCommand()Return a command which is doing redo/undo action.Definition TQCommand.cxx:276. Definition at line 276 of file TQCommand.cxx. ◆ GetName(). const char * TQCommand::GetName ; (; ); const. overridevirtual . Returns the command name. ; Default name is ""ClassName::RedoName(args)"" If list of merged commands is not empty the name is ""ClassName::RedoName(args):cname1:cname2 ..."" ; Reimplemented from TCollection.; Definition at line 670 of file TQCommand.cxx. ◆ GetNRargs(). Int_t TQCommand::GetNRargs ; (; ); const. Returns a number of re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:36650,undo,undo,36650,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"mand. ; Definition at line 736 of file TQCommand.cxx. ◆ GetStatus(). Int_t TQCommand::GetStatus ; (; ); const. Returns a number of sequential undo or redo operations. ; Definition at line 792 of file TQCommand.cxx. ◆ GetTitle(). const char * TQCommand::GetTitle ; (; ); const. overridevirtual . Returns command description. ; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"" ; Reimplemented from TObject.; Definition at line 713 of file TQCommand.cxx. ◆ GetUndo(). TQConnection * TQCommand::GetUndo ; (; ); const. inline . Definition at line 76 of file TQCommand.h. ◆ GetUndoArgs(). Long_t * TQCommand::GetUndoArgs ; (; ); const. Returns a pointer to array of undo arguments. ; Definition at line 760 of file TQCommand.cxx. ◆ GetUndoName(). const char * TQCommand::GetUndoName ; (; ); const. Returns the name of undo command. ; Definition at line 744 of file TQCommand.cxx. ◆ Init(). void TQCommand::Init ; (; const char * ; cl, . void * ; object, . const char * ; redo, . const char * ; undo . ). protectedvirtual . Common protected method used in several constructors. ; Definition at line 120 of file TQCommand.cxx. ◆ IsA(). TClass * TQCommand::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TList.; Reimplemented in TQUndoManager.; Definition at line 98 of file TQCommand.h. ◆ IsEqual(). Bool_t TQCommand::IsEqual ; (; const TObject * ; obj); const. overridevirtual . Equal comparison. ; The commands are equal if they are applied to the same object and have the same Redo/Undo actions; More complicated commands might want to override this function. ; Reimplemented from TObject.; Definition at line 418 of file TQCommand.cxx. ◆ IsExecuting(). Bool_t TQCommand::IsExecuting ; (; ); const. Returns kTRUE if command execution is in progress. ; Definition at line 824 of file TQCommand.cxx. ◆ IsMacro(). Bool_t TQCommand::IsMacro ; (; ); const. Returns kTRUE if neither redo nor undo action specified. ; Definition at line 8",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:39389,undo,undo,39389,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"mation for undo/redo a single action.; TQConnection Internal class used in the object communication mechanism; TQMimeTypes Pool of mime type objects; TQObjSender Used to ""delegate"" TQObject functionality; TQObject Base class for object communication mechanism; TQRootApplication creates Qt environment interface with the ROOT windowing system; TQRootCanvas interface to Qt eventloop to handle user input; TQRootDialog prompt for the arguments of an object's member function; TQRootGuiFactory Qt ROOT Gui factory; TQUndoManager recorder of operations for undo and redo; TQpDataBase Qp Base Data class; TQpDataDens Qp Data class for Dens formulation; TQpDataSparse Qp Data class for Sparse formulation; TQpLinSolverBase Qp linear solver base class; TQpLinSolverDens Qp linear solver class for Dens formulation; TQpLinSolverSparse Qp linear solver class for Sparse formulation; TQpProbBase Qp problem formulation base class; TQpProbDens Qp dens problem formulation class; TQpProbSparse Qp sparse problem formulation class; TQpResidual Qp Residual class; TQpSolverBase Qp Solver class; TQpVar Qp Variables class; TQtApplication Instantiate the Qt system within ROOT environment; TQtBrush create QBrush object based on the ROOT ""fill"" attributes; TQtClientFilter Map Qt and ROOT event; TQtClientWidget QFrame implementation backing ROOT TGWindow objects; TQtMarker Convert ROOT TMarker objects on to QPointArray; TQtPadFont < Create Qt QFont object based on ROOT TAttText attributes; TQtRootGuiFactory Factory for Qt-based ROOT GUI components; TQtRootSlot ; TQtTimer QTimer to awake the ROOT event loop from Qt event loop; TQtWidget QWidget to back ROOT TCanvas (Can be used with Qt designer); TQuaternion a quaternion class; TQueryDescription Query description; TQueryResult Class describing a query; TQueryResultManager PROOF query result manager; TROOT Top level (or root) structure for all classes; TRWLock Reader/writer lock; TRadialGradient Radial gradient fill.; TRandom Simple Random number genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:119192,undo,undo,119192,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['undo'],['undo']
Usability,"mation in these files can be edited via a normal editor. The main motivation for this new format is to facilitate the communication with other non ROOT applications. Currently writing and reading XML files is limited to ROOT applications. It is our intention to develop a simple reader independent of the ROOT libraries that could be used as an example for real applications.; The XML format should be used only for small data volumes, typically histogram files, pictures, geometries, calibrations. The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism exploiting the ROOT/Cling dictionary. Any class having a dictionary can be saved in XML format. This first implementation does not support subdirectories or trees.; The shared library libRXML.so may be loaded dynamically via gSystem->Load(""libRXML""). This library is also automatically loaded by the plug-in manager as soon a XML file is created. To create an XTM file, simply specify a filename with an .xml extension when calling TFile::Open. TFile::Open will recognize that you are trying to open an XML file and return a TXMLFile object. When a XML file is open in write mode, one can use the normal TObject::Write to write an object in the file.; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; The canvas can be saved as a XML file format via File menu / Save or Save As menu entries. One can do also:; canvas->Print(""Example.xml"");; 12 Trees; 12.1 Why Should You Use a Tree?; In the “Input/Output” chapter, we saw how objects can be saved in ROOT files. In case you want to store large quantities of same-class objects, ROOT has designed the TTree and TNtuple classes specifica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:518616,simpl,simply,518616,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simply']
Usability,"max] for the first and [ymin,ymax] for the second coordinate; 167 */; 168 void AddRange(double xmin, double xmax, double ymin, double ymax ) { AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); }; 169 /**; 170 add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; 171 [zmin,zmax] for the third coordinate; 172 */; 173 void AddRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax ) {; 174 AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); AddRange(2,zmin,zmax); }; 175 ; 176 /**; 177 set a range [xmin,xmax] for the new coordinate icoord; 178 If more range exists for other coordinates, delete the existing one and use it the new one; 179 Use Add range if want to keep the union of the existing ranges; 180 */; 181 void SetRange(unsigned int icoord , double xmin, double xmax );; 182 ; 183 /**; 184 set a range [xmin,xmax] for the first coordinate icoord; 185 */; 186 void SetRange(double xmin, double xmax ) { SetRange(0,xmin,xmax); }; 187 /**; 188 set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate; 189 */; 190 void SetRange(double xmin, double xmax, double ymin, double ymax ) { SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); }; 191 /**; 192 set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; 193 [zmin,zmax] for the third coordinate; 194 */; 195 void SetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax ) {; 196 SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); SetRange(2,zmin,zmax); }; 197 ; 198 /**; 199 clear all ranges in one coordinate (is now -inf, +inf); 200 */; 201 void Clear (unsigned int icoord = 0 );; 202 ; 203 /**; 204 check if a point is inside the range for the given coordinate; 205 */; 206 bool IsInside(double x, unsigned int icoord = 0) const;; 207 ; 208 /**; 209 check if a multi-dimpoint is inside the range; 210 */; 211 bool IsInside(const double *x) const {; 212 bool ret = true;; 213 for (unsigned int idim = 0; idim < fRanges.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataRange_8h_source.html:6994,clear,clear,6994,doc/master/DataRange_8h_source.html,https://root.cern,https://root.cern/doc/master/DataRange_8h_source.html,1,['clear'],['clear']
Usability,"maxdiff=0 (default), the first cell with content=c is returned. Double_t GetCorrelationFactor(Int_t axis1 = 1, Int_t axis2 = 2) const; -*-*-*Return correlation factor between axis1 and axis2; *-* ====================================================. Double_t GetCovariance(Int_t axis1 = 1, Int_t axis2 = 2) const; -*-*-*Return covariance between axis1 and axis2; *-* ====================================================. void GetRandom2(Double_t& x, Double_t& y); return 2 random numbers along axis x and y distributed according; the cellcontents of a 2-dim histogram; return a NaN if the histogram has a bin with negative content. void GetStats(Double_t* stats) const; fill the array stats from the contents of this histogram; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2; stats[4] = sumwy; stats[5] = sumwy2; stats[6] = sumwxy. If no axis-subranges are specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If sub-ranges are specified, the function recomputes these quantities; from the bin contents in the current axis ranges. Note that the mean value/RMS is computed using the bins in the currently; defined ranges (see TAxis::SetRange). By default the ranges include; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram. Double_t Integral(Option_t* option = """") const; Return integral of bin contents. Only bins in the bins range are considered.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t Integral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Option_t* option = """") const; Return integral",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2.html:40034,simpl,simply,40034,root/html534/TH2.html,https://root.cern,https://root.cern/root/html534/TH2.html,1,['simpl'],['simply']
Usability,"mber Functions |; List of all members ; TProofPlayerLite Class ReferencePROOF » PROOF kernel Libraries. ; Version of TProofPlayerRemote merges the functionality needed by clients and masters. ; It is used in optmized local sessions. ; Definition at line 28 of file TProofPlayerLite.h. Public Member Functions;  TProofPlayerLite (TProof *proof=0);  ;  ~TProofPlayerLite () override;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize a query. ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; TClass * IsA () const override;  ; Long64_t Process (TDSet *set, const char *selector, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Process specified TDSet on PROOF. ;  ; Long64_t Process (TDSet *set, TSelector *selector, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Process specified TDSet on PROOF. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayerRemote;  TProofPlayerRemote (TProof *proof=0);  ;  ~TProofPlayerRemote () override;  Destructor. ;  ; void AddOutput (TList *out) override;  Incorporate the content of the received output list 'out' into the final output list fOutput. ;  ; Int_t AddOutputObject (TObject *obj) override;  Incorporate the received object 'obj' into the output list fOutput. ;  ; Long64_t DrawSelect (TDSet *set, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (support for TChain::Draw()). ;  ; void Feedback (TList *objs) override;  Feedback signal. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:1234,feedback,feedback,1234,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,1,['feedback'],['feedback']
Usability,"mber function virtual void Myclass::Func0() which then can be overridden in a derived class of Myclass. (See example TMhs3).; Class Myclass may also provide a method to stop the running thread:; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; Example TMhs3: Class TThreadframe (TThreadframe.h, TThreadframe.cxx) is a simple example of a framework class managing up to four threaded methods. Class TMhs3 (TMhs3.h, TMhs3.cxx) inherits from this base class, showing the mhs3 example 8.1 (mhs3.h, mhs3.cxx)within a class. The Makefile of this example builds the shared libraries libTThreadframe.so and libTMhs3.so. These are either loaded or executed by the ROOT script TMhs3demo.C, or are linked against an executable: TMhs3run.cxx.; 23.3.1 Known Problems; Parts of the ROOT framework, like the interpreter, are not yet thread-safe. Therefore, you should use this package with caution. If you restrict your threads to distinct and `simple’ duties, you will able to benefit from their use. The TThread class is available on all platforms, which provide a POSIX compliant thread implementation. On Linux, Xavier Leroy’s Linux Threads implementation is widely used, but the TThread implementation should be usable on all platforms that provide pthread.; Linux Xlib on SMP machines is not yet thread-safe. This may cause crashes during threaded graphics operations; this problem is independent of ROOT.; Object instantiation: there is no implicit locking mechanism for memory allocation and global ROOT lists. The user has to explicitly protect their code when using them.; 23.4 The Signals of ROOT; The list of default signals handled by ROOT is:; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; The signals kSigFloatingException, kSigSegmentationViolation, kSigIllegalInstruction, and kSigBus cause the printing of the *** Break *** messag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1117115,simpl,simple,1117115,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"mber to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:25920,learn,learning,25920,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['learn'],['learning']
Usability,"mber to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:26544,learn,learning,26544,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,2,['learn'],['learning']
Usability,"mber_of_params, params). Example:; move_command->SetUndoArgs(2, 200, 200);. Bool_t CanRedo() const; Returns kTRUE if Redo action is possible, kFALSE if it's not.; By default, only single sequential redo action is possible. Bool_t CanUndo() const; Returns kTRUE if Undo action is possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:23260,undo,undo,23260,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,6,['undo'],['undo']
Usability,"mbers ; TPadPainter Class ReferenceGraphics » 2D Graphics » Graphics pad. ; Implement TVirtualPadPainter which abstracts painting operations. ; Definition at line 26 of file TPadPainter.h. Public Member Functions;  TPadPainter ();  Empty ctor. We need it only because of explicit copy ctor. ;  ; void ClearDrawable () override;  Clear the current gVirtualX window. ;  ; void CopyDrawable (Int_t device, Int_t px, Int_t py) override;  Copy a gVirtualX pixmap. ;  ; Int_t CreateDrawable (UInt_t w, UInt_t h) override;  Create a gVirtualX Pixmap. ;  ; void DestroyDrawable (Int_t device) override;  Close the current gVirtualX pixmap. ;  ; void DrawBox (Double_t x1, Double_t y1, Double_t x2, Double_t y2, EBoxMode mode) override;  Paint a simple box. ;  ; void DrawFillArea (Int_t n, const Double_t *x, const Double_t *y) override;  Paint filled area. ;  ; void DrawFillArea (Int_t n, const Float_t *x, const Float_t *y) override;  Paint filled area. ;  ; void DrawLine (Double_t x1, Double_t y1, Double_t x2, Double_t y2) override;  Paint a simple line. ;  ; void DrawLineNDC (Double_t u1, Double_t v1, Double_t u2, Double_t v2) override;  Paint a simple line in normalized coordinates. ;  ; void DrawPixels (const unsigned char *pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending) override;  Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. ;  ; void DrawPolyLine (Int_t n, const Double_t *x, const Double_t *y) override;  Paint Polyline. ;  ; void DrawPolyLine (Int_t n, const Float_t *x, const Float_t *y) override;  Paint polyline. ;  ; void DrawPolyLineNDC (Int_t n, const Double_t *u, const Double_t *v) override;  Paint polyline in normalized coordinates. ;  ; void DrawPolyMarker (Int_t n, const Double_t *x, const Double_t *y) override;  Paint polymarker. ;  ; void DrawPolyMarker (Int_t n, const Float_t *x, const Float_t *y) override;  Paint polymarker. ;  ; void DrawText (Double_t x, Double_t y, const char *text, ETextMode mode) override; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPadPainter.html:1284,simpl,simple,1284,doc/master/classTPadPainter.html,https://root.cern,https://root.cern/doc/master/classTPadPainter.html,1,['simpl'],['simple']
Usability,"mdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); const RooNumIntConfig&convIntConfig() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvolution.html:5646,clear,clearValueDirty,5646,root/html530/RooNumConvolution.html,https://root.cern,https://root.cern/root/html530/RooNumConvolution.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t binnedL = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:4325,clear,clearValueDirty,4325,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,3,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidconstOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:4280,clear,clearValueDirty,4280,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,3,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:4352,clear,clearValueDirty,4352,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,15,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:4261,clear,clearValueDirty,4261,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidconstOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsTestStatistic.html:4216,clear,clearValueDirty,4216,root/html532/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsTestStatistic.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsHiddenReal.html:3720,clear,clearValueDirty,3720,root/html532/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html532/RooAbsHiddenReal.html,3,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedReal.html:4288,clear,clearValueDirty,4288,root/html532/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedReal.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefficients(); virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStepFunction.html:3986,clear,clearValueDirty,3986,root/html532/RooStepFunction.html,https://root.cern,https://root.cern/root/html532/RooStepFunction.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefficients(); virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStepFunction.html:4145,clear,clearValueDirty,4145,root/html534/RooStepFunction.html,https://root.cern,https://root.cern/root/html534/RooStepFunction.html,3,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitRange = kFALSE, Bool_t binnedL = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNLLVar.html:4934,clear,clearValueDirty,4934,root/html534/RooNLLVar.html,https://root.cern,https://root.cern/root/html534/RooNLLVar.html,3,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet&, const char*, const char*, Int_t, RooFit::MPSplit, Bool_t, Bool_t, Bool_t); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::create",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooXYChi2Var.html:4540,clear,clearValueDirty,4540,root/html534/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html534/RooXYChi2Var.html,3,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& dhist, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, Bool_t = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:5466,clear,clearValueDirty,5466,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,3,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& adata, const RooArgSet& projDeps, const char* = 0, const char* = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t = kFALSE, Bool_t = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataWeightedAverage.html:4307,clear,clearValueDirty,4307,root/html534/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html534/RooDataWeightedAverage.html,3,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNLLVar.html:4761,clear,clearValueDirty,4761,root/html532/RooNLLVar.html,https://root.cern,https://root.cern/root/html532/RooNLLVar.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet&, const char*, const char*, Int_t, Bool_t, Bool_t, Bool_t); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooXYChi2Var.html:4381,clear,clearValueDirty,4381,root/html532/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html532/RooXYChi2Var.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& dhist, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooChi2Var.html:5259,clear,clearValueDirty,5259,root/html532/RooChi2Var.html,https://root.cern,https://root.cern/root/html532/RooChi2Var.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& adata, const RooArgSet& projDeps, const char* = 0, const char* = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataWeightedAverage.html:4124,clear,clearValueDirty,4124,root/html532/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html532/RooDataWeightedAverage.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; RooArgListcomponents(); virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProduct.html:3645,clear,clearValueDirty,3645,root/html534/RooProduct.html,https://root.cern,https://root.cern/root/html534/RooProduct.html,3,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; RooArgSetcomponents(); virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProduct.html:3591,clear,clearValueDirty,3591,root/html532/RooProduct.html,https://root.cern,https://root.cern/root/html532/RooProduct.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo1DMomentMorphFunction.html:3618,clear,clearValueDirty,3618,root/html532/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html532/Roo1DMomentMorphFunction.html,46,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:3738,clear,clearValueDirty,3738,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,177,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ParamHistFunc.html:3667,clear,clearValueDirty,3667,root/html532/ParamHistFunc.html,https://root.cern,https://root.cern/root/html532/ParamHistFunc.html,8,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; voidcopyCacheFast(const RooRealVar& other, Bool_t setValDirty = kTRUE); static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealVar.html:4007,clear,clearValueDirty,4007,root/html534/RooRealVar.html,https://root.cern,https://root.cern/root/html534/RooRealVar.html,3,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; voidcopyCacheFast(const RooRealVar& other, Bool_t setValDirty = kTRUE); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealVar.html:3943,clear,clearValueDirty,3943,root/html532/RooRealVar.html,https://root.cern,https://root.cern/root/html532/RooRealVar.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealMPFE.html:4599,clear,clearValueDirty,4599,root/html534/RooRealMPFE.html,https://root.cern,https://root.cern/root/html534/RooRealMPFE.html,3,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealMPFE.html:4495,clear,clearValueDirty,4495,root/html532/RooRealMPFE.html,https://root.cern,https://root.cern/root/html532/RooRealMPFE.html,1,['clear'],['clearValueDirty']
Usability,"me (Int_t hour, Int_t min, Int_t sec, Bool_t emit=kTRUE);  Set the numeric value (time format). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void TextChanged (const char *text=nullptr) override;  Text has changed message. ;  ;  Public Member Functions inherited from TGTextEntry;  TGTextEntry (const TGWindow *p, TGTextBuffer *text, Int_t id=-1, GContext_t norm=GetDefaultGC()(), FontStruct_t font=GetDefaultFontStruct(), UInt_t option=kSunkenFrame|kDoubleBorder, Pixel_t back=GetWhitePixel());  Create a text entry widget. ;  ;  TGTextEntry (const TGWindow *parent=nullptr, const char *text=nullptr, Int_t id=-1);  Simple text entry constructor. ;  ;  TGTextEntry (const TString &contents, const TGWindow *parent, Int_t id=-1);  Simple test entry constructor. ;  ;  ~TGTextEntry () override;  Delete a text entry widget. ;  ; virtual void AppendText (const char *text);  Appends text to the end of text entry, clears the selection and moves the cursor to the end of the line. ;  ; void Backspace ();  Deletes the character on the left side of the text cursor and moves the cursor one position to the left. ;  ; void Clear (Option_t *option="""") override;  Clears up the text entry. ;  ; void CursorLeft (Bool_t mark=kFALSE, Int_t steps=1);  Moves the cursor leftwards one or more characters. ;  ; virtual void CursorOutDown ();  This signal is emitted when cursor is going out of bottom side. ;  ; virtual void CursorOutLeft ();  This signal is emitted when cursor is going out of left side. ;  ; virtual void CursorOutRight ();  This signal is emitted when cursor is going out of right side. ;  ; virtual void CursorOutUp ();  This signal is emitted when cursor is going out of upper side. ;  ; void CursorRight (Bool_t mark=kFALSE, Int_t steps=1);  Moves the cursor rightwards one or more characters. ;  ; void CursorWordBackward (Bool_t mark=kFALSE);  Moves the cursor one word to the left. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGNumberEntryField.html:4403,clear,clears,4403,doc/master/classTGNumberEntryField.html,https://root.cern,https://root.cern/doc/master/classTGNumberEntryField.html,1,['clear'],['clears']
Usability,"me (TGFrame *f, TGLayoutHints *hints) override;  Add frame to dockable frame container. Frame and hints are NOT adopted. ;  ; void DockContainer (Int_t del=kTRUE);  Dock container back to TGDockableFrame. ;  ; virtual void Docked ();  ; Bool_t EnableHide () const;  ; void EnableHide (Bool_t onoff);  Enable hiding. ;  ; Bool_t EnableUndock () const;  ; void EnableUndock (Bool_t onoff);  Enable undocking. ;  ; TGCompositeFrame * GetContainer () const;  ; TGUndockedFrame * GetUndocked () const;  ; void HideContainer ();  Hide dock container. ;  ; TClass * IsA () const override;  ; Bool_t IsFixedSize () const;  ; Bool_t IsHidden () const;  ; Bool_t IsUndocked () const;  ; Bool_t ProcessMessage (Longptr_t, Longptr_t, Longptr_t) override;  Process dockable frame messages. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a dockable frame widget as a C++ statement(s) on output stream out. ;  ; void SetFixedSize (Bool_t fixed);  ; void SetWindowName (const char *name) override;  Set window name so it appear as title of the undock window. ;  ; void ShowContainer ();  Show dock container. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UndockContainer ();  Undock container. ;  ; virtual void Undocked ();  ;  Public Member Functions inherited from TGCompositeFrame;  TGCompositeFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=0, Pixel_t back=GetDefaultFrameBackground());  Create a composite frame. ;  ;  TGCompositeFrame (TGClient *c, Window_t id, const TGWindow *parent=nullptr);  Create a frame using an externally created window. ;  ;  ~TGCompositeFrame () override;  Delete a composite frame. ;  ; void ChangeOptions (UInt_t options) override;  Change composite frame options. Options is an OR of the EFrameTypes. ;  ; virtual void ChangeSubframesBackground (Pixel_t back);  Change background color for this frame and all subfr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDockableFrame.html:2067,undo,undock,2067,doc/master/classTGDockableFrame.html,https://root.cern,https://root.cern/doc/master/classTGDockableFrame.html,1,['undo'],['undock']
Usability,"me + _total"" and ""name + _passed"" respectively. ; Reimplemented from TNamed.; Definition at line 3547 of file TEfficiency.cxx. ◆ SetPassedEvents(). Bool_t TEfficiency::SetPassedEvents ; (; Int_t ; bin, . Int_t ; events . ). Sets the number of passed events in the given global bin. ; returns ""true"" if the number of passed events has been updated otherwise ""false"" ist returned; Note: - requires: 0 <= events <= fTotalHistogram->GetBinContent(bin) ; Definition at line 3566 of file TEfficiency.cxx. ◆ SetPassedHistogram(). Bool_t TEfficiency::SetPassedHistogram ; (; const TH1 & ; rPassed, . Option_t * ; opt . ). Sets the histogram containing the passed events. ; The given histogram is cloned and stored internally as histogram containing the passed events. The given histogram has to be consistent with the current fTotalHistogram (see CheckConsistency(const TH1&,const TH1&)). The method returns whether the fPassedHistogram has been replaced (true) or not (false).; Note: The list of associated functions fFunctions is cleared.; Option:; ""f"": force the replacement without checking the consistency This can lead to inconsistent histograms and useless results or unexpected behaviour. But sometimes it might be the only way to change the histograms. If you use this option, you should ensure that the fTotalHistogram is replaced by a consistent one (with respect to rPassed) as well. . Definition at line 3597 of file TEfficiency.cxx. ◆ SetPosteriorAverage(). void TEfficiency::SetPosteriorAverage ; (; Bool_t ; on = true). inline . Definition at line 143 of file TEfficiency.h. ◆ SetPosteriorMode(). void TEfficiency::SetPosteriorMode ; (; Bool_t ; on = true). inline . Definition at line 142 of file TEfficiency.h. ◆ SetShortestInterval(). void TEfficiency::SetShortestInterval ; (; Bool_t ; on = true). inline . Definition at line 144 of file TEfficiency.h. ◆ SetStatisticOption(). void TEfficiency::SetStatisticOption ; (; EStatOption ; option). Sets the statistic option which affects the cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEfficiency.html:109022,clear,cleared,109022,doc/master/classTEfficiency.html,https://root.cern,https://root.cern/doc/master/classTEfficiency.html,1,['clear'],['cleared']
Usability,"me y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd2Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrd2Editor.html:21251,undo,undoing,21251,root/html528/TGeoTrd2Editor.html,https://root.cern,https://root.cern/root/html528/TGeoTrd2Editor.html,1,['undo'],['undoing']
Usability,"me y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd2Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTrd2Editor.html:21351,undo,undoing,21351,root/html530/TGeoTrd2Editor.html,https://root.cern,https://root.cern/root/html530/TGeoTrd2Editor.html,1,['undo'],['undoing']
Usability,"me y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd2Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTrd2Editor.html:21351,undo,undoing,21351,root/html532/TGeoTrd2Editor.html,https://root.cern,https://root.cern/root/html532/TGeoTrd2Editor.html,1,['undo'],['undoing']
Usability,"me) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGaussModel.html:3266,clear,clearEvalErrorLog,3266,root/html532/RooGaussModel.html,https://root.cern,https://root.cern/root/html532/RooGaussModel.html,3,['clear'],['clearEvalErrorLog']
Usability,"me) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGaussModel.html:3266,clear,clearEvalErrorLog,3266,root/html528/RooGaussModel.html,https://root.cern,https://root.cern/root/html528/RooGaussModel.html,3,['clear'],['clearEvalErrorLog']
Usability,"me) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGaussModel.html:3266,clear,clearEvalErrorLog,3266,root/html530/RooGaussModel.html,https://root.cern,https://root.cern/root/html530/RooGaussModel.html,3,['clear'],['clearEvalErrorLog']
Usability,"me) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd ).c_str(),kTRUE);; 2675 }; 2676 void SetComment(const char *title) {; 2677 const char *left = strstr(title,""["");; 2678 if (left) {; 2679 const char *right = strstr(left,""]"");; 2680 if (right) {; 2681 ++left;; 2682 fComment.Append(left,right-left);; 2683 }; 2684 }; 2685 }; 2686 void Clear() {; 2687 fName.Clear();; 2688 fClassName.Clear();; 2689 fComment.Clear();; 2690 }; 2691 /* Hide this not yet used implementation to suppress warnings message; 2692 from icc 11; 2693 Bool_t operator==(const TMemberInfo &other) {; 2694 return fName==other.fName; 2695 && fClassName == other.fClassName; 2696 && fComment == other.fComment;; 2697 }; 2698 */; 2699 Bool_t operator!=(const TMemberInfo &other) {; 2700 if (fName != other.fName) return kTRUE;; 2701 if (fDataType < TStreamerInfo::kObject) {; 2702 // For simple type, let compare the data type; 2703 if (fDataType != other.fDataType) {; 2704 if ( (fDataType == 4 && other.fDataType == 16); 2705 || (fDataType == 16 && other.fDataType == 4) ) {; 2706 // long and 'long long' have the same file format; 2707 } else if ( (fDataType == 14 && other.fDataType == 17); 2708 || (fDataType == 17 && other.fDataType == 14) ) {; 2709 // unsigned long and 'unsigned long long' have the same file format; 2710 } else if ( (fDataType == 3 && other.fDataType == 6); 2711 ||(fDataType == 6 && other.fDataType == 3) ){; 2712 // Int_t and kCounter. As the switch from Int_t (3) to; 2713 // kCounter (6) might be triggered by a derived class using; 2714 // the field as an array size, the class itself has no; 2715 // control on what the field type really use.; 2716 } else {; 2717 return kTRUE;; 2718 }; 2719 }; 2720 } else if (fClassName != other.fClassName) {; 2721 if ( (fClassName == ""long"" && (other.fClassName == ""long long"" || other.fClassName == ""Long64_t""))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:107395,simpl,simple,107395,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['simpl'],['simple']
Usability,"me); virtual voidTObject::RecursiveRemove(TObject* obj); voidTGeoVolume::RegisterYourself(Option_t* option = """"); voidTGeoVolume::Release(); voidTGeoVolume::RemoveNode(TGeoNode* node); TGeoNode*TGeoVolume::ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidTGeoVolume::ReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTGeoVolume::SaveAs(const char* filename, Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTGeoVolume::SavePrimitive(ostream& out, Option_t* option = """"); voidTGeoVolume::SelectVolume(Bool_t clear = kFALSE); voidTGeoVolume::SetActiveDaughters(Bool_t flag = kTRUE); voidTGeoVolume::SetActivity(Bool_t flag = kTRUE); voidTGeoVolume::SetAdded(); voidTGeoVolume::SetAsTopVolume()TOGGLE GETTER ; voidTGeoAtt::SetAttBit(UInt_t f); voidTGeoAtt::SetAttBit(UInt_t f, Bool_t set); voidTGeoVolume::SetAttVisibility(Bool_t vis); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCurrentNodeIndex(Int_t index); voidTGeoVolume::SetCurrentPoint(Double_t x, Double_t y, Double_t z); voidTGeoVolume::SetCylVoxels(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoVolume::SetField(TObject* field); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidTGeoVolume::SetFinder(TGeoPatternFinder* finder); voidTGeoVolume::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeAssembly.html:27507,clear,clear,27507,root/html534/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeAssembly.html,3,['clear'],['clear']
Usability,"me); virtual voidTObject::RecursiveRemove(TObject* obj); voidTGeoVolume::RegisterYourself(Option_t* option = """"); voidTGeoVolume::Release(); voidTGeoVolume::RemoveNode(TGeoNode* node); TGeoNode*TGeoVolume::ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidTGeoVolume::ReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTGeoVolume::SaveAs(const char* filename, Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTGeoVolume::SavePrimitive(ostream& out, Option_t* option = """"); voidTGeoVolume::SelectVolume(Bool_t clear = kFALSE); voidTGeoVolume::SetActiveDaughters(Bool_t flag = kTRUE); voidTGeoVolume::SetActivity(Bool_t flag = kTRUE); voidTGeoVolume::SetAdded(); voidTGeoVolume::SetAsTopVolume()TOGGLE GETTER ; voidTGeoAtt::SetAttBit(UInt_t f); voidTGeoAtt::SetAttBit(UInt_t f, Bool_t set); voidTGeoVolume::SetAttVisibility(Bool_t vis); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoVolume::SetCurrentPoint(Double_t x, Double_t y, Double_t z); voidTGeoVolume::SetCylVoxels(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoVolume::SetField(TObject* field); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidTGeoVolume::SetFinder(TGeoPatternFinder* finder); voidTGeoVolume::SetFWExtension(TGeoExtension* ext); vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeMulti.html:27556,clear,clear,27556,root/html534/TGeoVolumeMulti.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeMulti.html,3,['clear'],['clear']
Usability,"me, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooThresholdCategory.html:1995,clear,clearValueAndShapeDirty,1995,root/html602/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html602/RooThresholdCategory.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"me.; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments:; if either clname or obj is NULL that means that redo/undo is function; to specify default arguments for redo/undo method/function '=' must precede to argument value. Example: TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case undo parameter can be omitted.; Example: TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. Definition at line 168 of file TQCommand.cxx. ◆ TQCommand() [2/3]. TQCommand::TQCommand ; (; TObject * ; obj, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments: to specify default arguments for redo/undo method/function '=' must precede to argument value.; Example: TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case ""undo"" can parameter be omitted.; Example: TQCommand(gPad, ""SetFillStyle(Style_t)"");. Definition at line 199 of file TQCommand.cxx. ◆ TQCommand() [3/3]. TQCommand::TQCommand ; (; const TQCommand & ; com). Copy constructor. ; Definition at line 209 of file TQCommand.cxx. ◆ ~TQCommand(). TQCommand::~TQCommand ; (; ). virtual . dtor. ; Definition at line 249 of file TQCommand.cxx. Member Function Documentation. ◆ Add() [1/2]. void TQCommand::Add ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TList.; Reimplemented in TQUndoManager.; Definition at line 91 of file TQCommand.h. ◆ Add() [2/2]. void TQCommand::Add ; (; TObject * ; obj, . Option_t * ; opt . ). overridevirtual . Add command to the list of merged commands. ; Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command . Reimplemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:33051,undo,undo,33051,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"me.c_str());; 5793 i->SetClass(nullptr);; 5794 i->GetElements()->Delete();; 5795 TStreamerElement *fel = R__CreateEmulatedElement(""first"", firstname, 0, silent);; 5796 Int_t size = 0;; 5797 if (fel) {; 5798 i->GetElements()->Add( fel );; 5799 ; 5800 size = fel->GetSize();; 5801 Int_t sp = sizeof(void *);; 5802 //align the non-basic data types (required on alpha and IRIX!!); 5803 if (size%sp != 0) size = size - size%sp + sp;; 5804 } else {; 5805 delete i;; 5806 return 0;; 5807 }; 5808 if (hint_pair_offset); 5809 size = hint_pair_offset;; 5810 TStreamerElement *second = R__CreateEmulatedElement(""second"", secondname, size, silent);; 5811 if (second) {; 5812 i->GetElements()->Add( second );; 5813 } else {; 5814 delete i;; 5815 return 0;; 5816 }; 5817 Int_t oldlevel = gErrorIgnoreLevel;; 5818 // Hide the warning about the missing pair dictionary.; 5819 gErrorIgnoreLevel = kError;; 5820 i->BuildCheck(nullptr, kFALSE); // Skipping the loading part (it would leads to infinite recursion on this very routine); 5821 gErrorIgnoreLevel = oldlevel;; 5822 // In the state emulated, BuildOld would recalculate the offset and undo the offset update.; 5823 // Note: we should consider adding a new state just for this (the hints indicates that we are mapping a compiled class but; 5824 // then we would have to investigate all use of the state with <= and >= condition to make sure they are still appropriate).; 5825 if (hint_pair_size) {; 5826 i->GetClass()->SetClassSize(hint_pair_size);; 5827 i->GetClass()->fIsSyntheticPair = kTRUE;; 5828 }; 5829 ; 5830 i->BuildOld();; 5831 ; 5832 if (hint_pair_size); 5833 i->GetClass()->SetClassSize(hint_pair_size);; 5834 return i;; 5835}; 5836 ; 5837TVirtualStreamerInfo *TStreamerInfo::GenerateInfoForPair(const std::string &pairclassname, bool silent, size_t hint_pair_offset, size_t hint_pair_size); 5838{; 5839 const static int pairlen = strlen(""pair<"");; 5840 if (pairclassname.compare(0, pairlen, ""pair<"") != 0) {; 5841 if (!silent); 5842 Error(""GenerateI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:233532,undo,undo,233532,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['undo'],['undo']
Usability,"me::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGUndockedFrame(const TGWindow* p = 0, TGDockableFrame* dockable = 0); Create the undocked (transient) frame. ~TGUndockedFrame(); Delete undocked frame. Puts back dockable frame in its original container. void FixSize(); Fix the size of the undocked frame so it cannot be changed via the WM. void CloseWindow(); Close undocked frame (called via WM close button). TGUndockedFrame(const TGUndockedFrame& ). TGUndockedFrame& operator=(const TGUndockedFrame& ). » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-04-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGUndockedFrame.html:22334,undo,undocked,22334,root/html534/TGUndockedFrame.html,https://root.cern,https://root.cern/root/html534/TGUndockedFrame.html,4,['undo'],['undocked']
Usability,"me::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. private:. TGLVEntry*fEntryTmpused to transfer to feedback; TGLVContainer*fLVContaineroutput list view; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TSessionOutputFrame. Function documentation; TSessionOutputFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionOutputFrame(); Destructor. void Build(TSessionViewer* gui); Build query output information frame. void OnElementClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks on list view items. void OnElementDblClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle double-clicks on list view items. void AddObject(TObject* obj); Add object to output list view. TSessionOutputFrame(TGWindow* parent, Int_t w, Int_t h). TGLVContainer * GetLVContainer(); { return fLVContainer; }. void RemoveAll(); { fLVContainer->RemoveAll(); }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionOutputFrame.html:19805,feedback,feedback,19805,root/html602/TSessionOutputFrame.html,https://root.cern,https://root.cern/root/html602/TSessionOutputFrame.html,2,['feedback'],['feedback']
Usability,"mechanism can be used on an histogram. ;  ;  hlHisto3.C;  This tutorial demonstrates how the highlight mechanism can be used on a ntuple. ;  ;  hlHisto4.C;  This tutorial demonstrates how the highlight mechanism can be used on an histogram. ;  ;  hstack.C;   Example of stacked histograms: class THStack. ;  ;  hstackpads.C;   Drawing stack histograms on subpads. ;  ;  hsum.C;   Histograms filled and drawn in a loop. ;  ;  hsumTimer.C;   Demo of Timers. ;  ;  legendautoplaced.C;   The legend can be placed automatically in the current pad in an empty space found at painting time. ;  ;  logscales.C;   Draw parametric functions with log scales. ;  ;  movepalette.C;   When an histogram is drawn with the option COLZ, a palette is automatically drawn vertically on the right side of the plot. ;  ;  multicolor.C;   Use a THStack to show a 2-D hist with cells with different colors. ;  ;  NormalizeHistogram.C;   Normalizing a Histogram ;  ;  ratioplot1.C;   Example creating a simple ratio plot of two histograms using the pois division option. ;  ;  ratioplot1.py;   Example creating a simple ratio plot of two histograms using the pois division option. ;  ;  ratioplot2.C;   Example of a fit residual plot. ;  ;  ratioplot2.py;   Example of a fit residual plot. ;  ;  ratioplot3.C;   Example which shows how you can get the graph of the lower plot and set the y axis range for it. ;  ;  ratioplot3.py;   Example which shows how you can get the graph of the lower plot and set the y axis range for it. ;  ;  ratioplot4.C;   Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ;  ;  ratioplot4.py;   Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ;  ;  ratioplot5.C;   Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ;  ;  ratioplot5.py;   Example that shows how you can set the colors of the confidence interval bands by us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:3512,simpl,simple,3512,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,1,['simpl'],['simple']
Usability,"members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::MultiBuildConfig. class RooSimWSTool::MultiBuildConfig: public RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimWSTool__MultiBuildConfig.html:1139,simpl,simple,1139,root/html534/RooSimWSTool__MultiBuildConfig.html,https://root.cern,https://root.cern/root/html534/RooSimWSTool__MultiBuildConfig.html,3,['simpl'],['simple']
Usability,"memory costly logical shapes, and retaining/discarding the physical placements as required. The viewer may decide to force the client to rebuild (republish) the scene (via a TPad repaint at present), and thus collect these objects if the internal viewer state changes. It does this presently by forcing a repaint on the attached TPad object - hence the reason for putting all publishing to the viewer in the attached pad objects Paint() method. We will likely remove this requirement in the future, indicating the rebuild request via a normal ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); TBuffer3DGeneric 3D primitive description class.Definition TBuffer3D.h:18; bool; unsigned int; If you use the first (simple) case a viewer using logical/physical pairs SetSectionsValid(TBuffer3D::kBoundingBox); will generate IDs for each physical object internally. In the second you can specify a unique identifier from the client, which allows the viewer to be more efficient. It can now cache both logical and physical objects, and only discard physical objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of descendents. Both AddObject() methods have an addChildren parameter. The viewer will complete this (if passed) indicating if children (contained within the one just sent) are worth adding. Recycling TBuffer3D; Once add AddObject() has been called, the contents are copied to the viewer internally. You are free to destroy this object, or recycle it for the next object if suitable. ; Definition at line 17 of file TBuffer3D.h. Public",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer3D.html:8443,simpl,simple,8443,doc/master/classTBuffer3D.html,https://root.cern,https://root.cern/doc/master/classTBuffer3D.html,1,['simpl'],['simple']
Usability,"ment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: assembly.C.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; namechar name[80]Definition TGX11.cxx:110; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; Note that components cannot be declared as ""overlapping"" and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in **TGeo** has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:53130,simpl,simple,53130,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"ment. ;  ; Bool_t GetDestroyOnZeroRefCnt () const;  Returns state of flag determining if the element will be destroyed when reference count reaches zero. ;  ; virtual TObject * GetEditorObject (const TEveException &eh) const;  ; virtual TString GetHighlightTooltip ();  ; virtual const TGPicture * GetListTreeCheckBoxIcon ();  Returns list-tree-item check-box picture appropriate for given rendering state. ;  ; virtual const TGPicture * GetListTreeIcon (Bool_t open=kFALSE);  Returns pointer to first listtreeicon. ;  ; virtual Color_t GetMainColor () const;  ; Color_t * GetMainColorPtr () const;  ; TEveElement * GetMaster ();  Returns the master element - that is: ;  ; virtual Int_t GetNItems () const;  ; Int_t GetParentIgnoreCnt () const;  Get number of parents that should be ignored in doing reference-counting. ;  ; virtual TObject * GetRenderObject (const TEveException &eh) const;  ; virtual Bool_t GetRnrAnything () const;  ; virtual Bool_t GetRnrChildren () const;  ; virtual Bool_t GetRnrSelf () const;  ; virtual Bool_t GetRnrState () const;  ; virtual UChar_t GetSelectedLevel () const;  Get selection level, needed for rendering selection and highlight feedback. ;  ; TRef & GetSource ();  ; TObject * GetSourceObject () const;  ; void * GetUserData () const;  ; TEveElement * GetVizModel () const;  ; const TString & GetVizTag () const;  ; virtual Bool_t HandleElementPaste (TEveElement *el);  React to element being pasted or dnd-ed. ;  ; Bool_t HasChild (TEveElement *el);  Check if element el is a child of this element. ;  ; Bool_t HasChildren () const;  ; virtual Bool_t HasMainColor () const;  ; virtual Bool_t HasMainTrans () const;  ; Bool_t HasParents () const;  ; virtual void HighlightElement (Bool_t state);  Set element's highlight state. Stamp appropriately. ;  ; void IncDenyDestroy ();  Increases the deny-destroy count of the element. ;  ; virtual void IncImpliedHighlighted ();  Increase element's implied-highlight count. Stamp appropriately. ;  ; virtual void I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveGeoNode.html:10507,feedback,feedback,10507,doc/master/classTEveGeoNode.html,https://root.cern,https://root.cern/doc/master/classTEveGeoNode.html,2,['feedback'],['feedback']
Usability,"mented from TGFrame.; Reimplemented in TGVProgressBar.; Definition at line 90 of file TGProgressBar.h. ◆ Percent(). virtual void TGProgressBar::Percent ; (; Bool_t ; on). inlinevirtual . Reimplemented in TGVProgressBar.; Definition at line 78 of file TGProgressBar.h. ◆ Reset(). void TGProgressBar::Reset ; (; ). virtual . Reset progress bar (i.e. set pos to 0). ; Definition at line 126 of file TGProgressBar.cxx. ◆ SavePrimitive(). void TGProgressBar::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save progress bar parameters as a C++ statement(s) on output stream out. ; Reimplemented from TGFrame.; Reimplemented in TGVProgressBar.; Definition at line 396 of file TGProgressBar.cxx. ◆ SetBarColor() [1/2]. void TGProgressBar::SetBarColor ; (; const char * ; color = ""blue""). Set progress bar color. ; Definition at line 166 of file TGProgressBar.cxx. ◆ SetBarColor() [2/2]. void TGProgressBar::SetBarColor ; (; Pixel_t ; color). virtual . Set progress bar color. ; Definition at line 156 of file TGProgressBar.cxx. ◆ SetBarType(). void TGProgressBar::SetBarType ; (; EBarType ; type). Set bar type. ; Definition at line 146 of file TGProgressBar.cxx. ◆ SetFillType(). void TGProgressBar::SetFillType ; (; EFillType ; type). Set fill type. ; Definition at line 136 of file TGProgressBar.cxx. ◆ SetForegroundColor(). void TGProgressBar::SetForegroundColor ; (; Pixel_t ; pixel). overridevirtual . Change text color drawing. ; Reimplemented from TGFrame.; Definition at line 207 of file TGProgressBar.cxx. ◆ SetMax(). void TGProgressBar::SetMax ; (; Float_t ; max). inline . Definition at line 82 of file TGProgressBar.h. ◆ SetMin(). void TGProgressBar::SetMin ; (; Float_t ; min). inline . Definition at line 81 of file TGProgressBar.h. ◆ SetPosition(). void TGProgressBar::SetPosition ; (; Float_t ; pos). Set progress position between [min,max]. ; Definition at line 92 of file TGProgressBar.cxx. ◆ SetRange(). void TGProgressBar::SetRange ; (; Float",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGProgressBar.html:35210,progress bar,progress bar,35210,doc/master/classTGProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGProgressBar.html,1,['progress bar'],['progress bar']
Usability,"mented in TGVProgressBar.; Definition at line 79 of file TGProgressBar.h. ◆ Streamer(). void TGProgressBar::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGFrame.; Reimplemented in TGVProgressBar. ◆ StreamerNVirtual(). void TGProgressBar::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 90 of file TGProgressBar.h. ◆ UsePercent(). Bool_t TGProgressBar::UsePercent ; (; ); const. inline . Definition at line 68 of file TGProgressBar.h. Member Data Documentation. ◆ fBarColorGC. TGGC TGProgressBar::fBarColorGC. protected . progress bar drawing context ; Definition at line 39 of file TGProgressBar.h. ◆ fBarType. EBarType TGProgressBar::fBarType. protected . OPTION={GetMethod=""GetBarType"";SetMethod=""SetBarType"";Items=(kStandard=""Standard"",kFancy=""Fancy"")} ; Definition at line 34 of file TGProgressBar.h. ◆ fBarWidth. Int_t TGProgressBar::fBarWidth. protected . progress bar width ; Definition at line 32 of file TGProgressBar.h. ◆ fDrawBar. Bool_t TGProgressBar::fDrawBar. protected . if true draw only bar in DoRedraw() ; Definition at line 38 of file TGProgressBar.h. ◆ fFillType. EFillType TGProgressBar::fFillType. protected . OPTION={GetMethod=""GetFillType"";SetMethod=""SetFillType"";Items=(kSolidFill=Solid"",kBlockFill=""Block"")} ; Definition at line 33 of file TGProgressBar.h. ◆ fFontStruct. FontStruct_t TGProgressBar::fFontStruct. protected . font used to draw position text ; Definition at line 41 of file TGProgressBar.h. ◆ fFormat. TString TGProgressBar::fFormat. protected . format used to show position not in percent ; Definition at line 35 of file TGProgressBar.h. ◆ fgDefaultFont. const TGFont * TGProgressBar::fgDefaultFont = nullptr. staticprotected . Definition at line 45 of file TGProgressBar.h. ◆ fgDefaultGC. TGGC * TGProgressBar::fgDefaultGC = nullptr. staticprotected . Definition at line 46 of file TGProgressBar.h. ◆ fMax. Float_t TGProgressBar::fMax. protected . log",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGProgressBar.html:37391,progress bar,progress bar,37391,doc/master/classTGProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGProgressBar.html,1,['progress bar'],['progress bar']
Usability,"ments the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines the analytical integral translation for the class. ;  ; TObject * clone (const char *newname) const override;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; TClass * IsA () const override;  ; void selectNormalizationRange (const char *rangeName=nullptr, bool force=false) override;  Interface function to force use of a given normalization range to interpret function value. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual RooAbsGenContext * binnedGenContext (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChebychev.html:2105,simpl,simple,2105,doc/master/classRooChebychev.html,https://root.cern,https://root.cern/doc/master/classRooChebychev.html,1,['simpl'],['simple']
Usability,"mepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualViewer3D. class TVirtualViewer3D: public TObject. TVirtualViewer3D. Abstract 3D shapes viewer. The concrete implementations are:. TViewerX3D : X3d viewer; TGLViewer : OpenGL viewer. ; 3D Viewer Infrastructure Overview; The 3D Viewer infrastructure consists of:. TVirtualViewer3D interface: An abstract handle to the viewer, allowing; client to test preferences, add objects, control the viewer via scripting; (to be added) etc.; TBuffer3D class hierarchy: Used to describe 3D objects; (""shapes""); - filled /added by negotiation with viewer via TVirtualViewer3D. Together these allow clients to publish objects to any one of the 3D viewers; (currently OpenGL/x3d,TPad), free of viewer specific drawing code. They allow; our simple x3d viewer, and considerably more sophisticated OpenGL one to both; work with both geometry libraries (g3d and geom) efficiently.; Publishing to a viewer consists of the following steps:. Create / obtain viewer handle; Begin scene on viewer; Fill mandatory parts of TBuffer3D describing object; Add to viewer; Fill optional parts of TBuffer3D if requested by viewer, and add again; ... repeat 3/4/5; as required; End scene on viewer. Creating / Obtaining Viewer; Create/obtain the viewer handle via local/global pad - the viewer is always; bound to a TPad object at present [This may be removed as a restriction in; the future] . You should perform the publishing to the viewer described below; in the Paint() method of the object you attach to the pad (via Draw()); TVirtualViewer3D * v = gPad->GetViewer3D(""xxxx"");; "" xxxx"" is viewer type: OpenGL ""ogl"", X3D ""x3d"" or; Pad ""pad"" (default). The viewer is created via the plugin manager,; attached to pad, and the interface returned.; Begin / End Scene; Objects must be added to viewer between BeginScene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:982,simpl,simple,982,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,4,['simpl'],['simple']
Usability,"meters(const Double_t *params)Definition TF1.h:677; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPaveStatsThe histogram statistics painter class.Definition TPaveStats.h:18; TPaveStats::SetOptStatvoid SetOptStat(Int_t stat=1)Set the stat option.Definition TPaveStats.cxx:30",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisProxy_8C.html:13563,simpl,simple,13563,doc/master/h1analysisProxy_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisProxy_8C.html,1,['simpl'],['simple']
Usability,"method returns the shifts of the unfolding result induced by varying the identified systematic source by one sigma. ; the array binMap is explained with the method GetOutput(). ; Definition at line 1027 of file TUnfoldSys.cxx. ◆ GetDeltaSysTau(). Bool_t TUnfoldSys::GetDeltaSysTau ; (; TH1 * ; hist_delta, . const Int_t * ; binMap = nullptr . ). correlated one-sigma shifts from shifting tau ; Parameters. [out]hist_deltahistogram to store shifts ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins. returns true if the background source was found. ; This method returns the shifts of the unfolding result induced by varying the normalisation of the identified background by one sigma. ; the array binMap is explained with the method GetOutput(). ; Definition at line 1086 of file TUnfoldSys.cxx. ◆ GetEmatrixFromVyy(). void TUnfoldSys::GetEmatrixFromVyy ; (; const TMatrixDSparse * ; vyy, . TH2 * ; ematrix, . const Int_t * ; binMap, . Bool_t ; clearEmat . ). protected . propagate an error matrix on the input vector to the unfolding result ; Parameters. [in]vyyinput error matrix ; [in,out]ematrixhistogram to be updated ; [in]binMapmapping of histogram bins ; [in]clearEmatif set, clear histogram before adding this covariance contribution . Definition at line 1250 of file TUnfoldSys.cxx. ◆ GetEmatrixInput(). void TUnfoldSys::GetEmatrixInput ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from input measurement uncertainties ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the uncertainties or covariance of the input data. In many cases, these are the ""statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:37159,clear,clearEmat,37159,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,"method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of integers with the same; size as the number of entries in the prototype dataset and must contain; integer values in the range [0,Nevt-1]. void resampleData(Double_t& ratio); Rescale existing output buffer with given ratio. Int_t defaultPrintContents(Option_t* opt) const; Define default contents when printing. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Define default print style. RooAbsGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). Bool_t isValid() const; If true generator context is in a valid state. void setVerbose(Bool_t verbose = kTRUE); Set/clear verbose messaging. Bool_t isVerbose() const; If true verbose messaging is active. void Print(Option_t* options = 0) const; Print context information on stdout. void setExpectedData(Bool_t ); {}. void generateEvent(RooArgSet& theEvent, Int_t remaining). » Last changed: Sat Sep 5 17:28:33 2015 » Last generated: 2015-09-05 17:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsGenContext.html:12108,clear,clear,12108,root/html604/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html604/RooAbsGenContext.html,1,['clear'],['clear']
Usability,"mi-interactive work with large amounts of data. They ended up re-implementing a full Totem analysis in a declarative fashion using RDataFrame and distributing their calculations over a big Spark cluster with PyRDF.; Check it out on CDS! . 30-01-2019 ; More tests, more benchmarks! ; ROOT relies on testing, including performance testing - and we need to improve both.; . 30-01-2019 ; Better argument parsing ; Use a C++ command line argument library for defining and parsing ROOT's options.; . 30-01-2019 ; Transform GNU-makefile tests to CMake ; ROOT's test suite has several crucial tests that still try on GNU-Makefile. We need to integrate them with CMake.; . 11-07-2018 ; RDataFrame session at CHEP 2018 ; Join the CHEP 2018 BOF to discuss bout the Future of ROOT Based Analysis: sign up here and visit the indico agenda.; Too much data? Too many cores? TTree analysis is tedious? Come and enjoy an intro plus discussion of RDataFrame, ROOT's current-generation way of writing super-efficient analyses! It moves all the intricacies into ROOT's responsibility, leaving you simply with a declarative formulation of the filters and computations that make up your analysis.; . 17-01-2018 ; ROOT Users' Workshop 2018 ; The ROOT team would like to invite you to the 11th ROOT Users' Workshop. This time we meet in Sarajevo, the capital of Bosnia and Herzegovina -; a buzzing melting pot of cultures since centuries.; The workshop features four days of presentations and discussions on everything ROOT:; what works for you, what doesn't and how ROOT evolves to address future challenges.; ROOT is changing; this is your chance to influence what happens and to interact with all its developers!; Our way of saying ""thank you for participating"" is to make sure that you have a great time in a unique location! . 03-08-2017 ; The ROOT Docker container (alpha version) ; Do you like Docker? Would you like to use ROOT? We provide an alpha version of the ROOT Docker container!; . 08-03-2017 ; Development r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/news.html:3254,simpl,simply,3254,d/news.html,https://root.cern,https://root.cern/d/news.html,1,['simpl'],['simply']
Usability,"min = gPad->GetUxmin();; 432 xmax = gPad->GetUxmax();; 433 ymin = gPad->GetUymin();; 434 ymax = gPad->GetUymax();; 435 dx = xmax-xmin;; 436 dy = ymax-ymin;; 437 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 438 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 439 ; 440 // Range() could change the size of the pad pixmap and therefore should; 441 // be called before the other paint routines; 442 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 443 ymin - dyr*gPad->GetBottomMargin(),; 444 xmax + dxr*gPad->GetRightMargin(),; 445 ymax + dyr*gPad->GetTopMargin());; 446 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 447 ; 448 if (!x.empty() && !y.empty()) {; 449 if (middle) {; 450 for(i=0;i<np;i++) {; 451 fX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 452 fY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 453 }; 454 } else {; 455 fX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 456 fY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 457 }; 458 x.clear();; 459 y.clear();; 460 }; 461 gPad->Modified(kTRUE);; 462 gVirtualX->SetLineColor(-1);; 463 }; 464}; 465 ; 466////////////////////////////////////////////////////////////////////////////////; 467/// List this polyline with its attributes.; 468/// The option string is ignored.; 469 ; 470void TPolyLine::ls(Option_t *) const; 471{; 472 TROOT::IndentLevel();; 473 printf(""TPolyLine N=%d\n"",fN);; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// Merge polylines in the collection in this polyline; 478 ; 479Int_t TPolyLine::Merge(TCollection *li); 480{; 481 if (!li) return 0;; 482 TIter next(li);; 483 ; 484 //first loop to count the number of entries; 485 TPolyLine *pl;; 486 Int_t npoints = 0;; 487 while ((pl = (TPolyLine*)next())) {; 488 if (!pl->InheritsFrom(TPolyLine::Class())) {; 489 Error(""Add"",""Attempt to add object of class: %s to a %s"",pl->ClassName(),this->ClassName());; 490 return -1;; 491 }; 492 npoints += pl->Size();; 493 }; 494 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPolyLine_8cxx_source.html:14924,clear,clear,14924,doc/master/TPolyLine_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html,1,['clear'],['clear']
Usability,"min, double xmax, double ymin, double ymax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); }. void AddRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void SetRange(unsigned int icoord, double xmin, double xmax). set a range [xmin,xmax] for the new coordinate icoord; If more range exists for other coordinates, delete the existing one and use it the new one; Use Add range if want to keep the union of the existing ranges. void SetRange(double xmin, double xmax). set a range [xmin,xmax] for the first coordinate icoord. { SetRange(0,xmin,xmax); }. void SetRange(double xmin, double xmax, double ymin, double ymax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); }. void SetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void Clear(unsigned int icoord = 0). clear all ranges in one coordinate (is now -inf, +inf). bool IsInside(double x, unsigned int icoord = 0) const. check if a point is inside the range for the given coordinate. void CleanRangeSet(unsigned int icoord, double xmin, double xmax). internal function to remove all the existing ranges between xmin and xmax; called when a new range is inserted. void GetInfRange(double& x1, double& x2); get the full range (-inf, +inf). » Author: L. Moneta Wed Aug 30 11:05:02 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Fit__DataRange.html:6080,clear,clear,6080,root/html602/ROOT__Fit__DataRange.html,https://root.cern,https://root.cern/root/html602/ROOT__Fit__DataRange.html,1,['clear'],['clear']
Usability,"min, double xmax, double ymin, double ymax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); }. void AddRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void SetRange(unsigned int icoord, double xmin, double xmax). set a range [xmin,xmax] for the new coordinate icoord; If more range exists for other coordinates, delete the existing one and use it the new one; Use Add range if want to keep the union of the existing ranges. void SetRange(double xmin, double xmax). set a range [xmin,xmax] for the first coordinate icoord. { SetRange(0,xmin,xmax); }. void SetRange(double xmin, double xmax, double ymin, double ymax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); }. void SetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void Clear(unsigned int icoord = 0). clear all ranges in one coordinate (is now -inf, +inf). bool IsInside(double x, unsigned int icoord = 0) const. check if a point is inside the range for the given coordinate. void CleanRangeSet(unsigned int icoord, double xmin, double xmax). internal function to remove all the existing ranges between xmin and xmax; called when a new range is inserted. void GetInfRange(double& x1, double& x2); get the full range (-inf, +inf). » Author: L. Moneta Wed Aug 30 11:05:02 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Fit__DataRange.html:6080,clear,clear,6080,root/html534/ROOT__Fit__DataRange.html,https://root.cern,https://root.cern/root/html534/ROOT__Fit__DataRange.html,1,['clear'],['clear']
Usability,"min, double xmax, double ymin, double ymax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); }. void AddRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void SetRange(unsigned int icoord, double xmin, double xmax). set a range [xmin,xmax] for the new coordinate icoord; If more range exists for other coordinates, delete the existing one and use it the new one; Use Add range if want to keep the union of the existing ranges. void SetRange(double xmin, double xmax). set a range [xmin,xmax] for the first coordinate icoord. { SetRange(0,xmin,xmax); }. void SetRange(double xmin, double xmax, double ymin, double ymax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); }. void SetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void Clear(unsigned int icoord = 0). clear all ranges in one coordinate (is now -inf, +inf). bool IsInside(double x, unsigned int icoord = 0) const. check if a point is inside the range for the given coordinate. void CleanRangeSet(unsigned int icoord, double xmin, double xmax). internal function to remove all the existing ranges between xmin and xmax; called when a new range is inserted. void GetInfRange(double& x1, double& x2); get the full range (-inf, +inf). » Author: L. Moneta Wed Aug 30 11:05:02 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__DataRange.html:6080,clear,clear,6080,root/html604/ROOT__Fit__DataRange.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__DataRange.html,1,['clear'],['clear']
Usability,"mitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),; TQUndoManager::Redo() methods only invokes the top level command as a whole. Merge method is analogous to logical join operation. Note: Merge method invokes redo action. Long64_t Merge(TCollection* , TFileMerg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TQCommand.html:19634,undo,undo,19634,root/html530/TQCommand.html,https://root.cern,https://root.cern/root/html530/TQCommand.html,5,['undo'],['undo']
Usability,"mitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),; TQUndoManager::Redo() methods only invokes the top level command as a whole. Merge method is analogous to logical join operation. Note: Merge method invokes redo action. void Add(TObject* obj, Option_t* opt); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:19461,undo,undo,19461,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,1,['undo'],['undo']
Usability,"mizer result are not consistent"");; 174 std::cout << ""Number of free parameters from FitConfig = "" << nfree << std::endl;; 175 std::cout << ""Number of free parameters from Minimizer = "" << fNFree << std::endl;; 176 }; 177 ; 178 // if flag is binned compute a chi2 when a chi2 function is given; 179 if (fitType == 1) {; 180 if (chi2func == nullptr); 181 fChi2 = fVal;; 182 else {; 183 // compute chi2 equivalent for likelihood fits; 184 // NB: empty bins are considered; 185 fChi2 = (*chi2func)(&fParams[0]);; 186 }; 187 }; 188 else if (fitType == 3) {; 189 // case of binned likelihood fits (use Baker-Cousins chi2); 190 fChi2 = 2 * fVal;; 191 }; 192 ; 193 // fill error matrix; 194 // if minimizer provides error provides also error matrix; 195 // clear in case of re-filling an existing result; 196 if (!fCovMatrix.empty()) fCovMatrix.clear();; 197 if (!fGlobalCC.empty()) fGlobalCC.clear();; 198 ; 199 if (min->Errors() != nullptr) {; 200 ; 201 fErrors = std::vector<double>(min->Errors(), min->Errors() + npar ) ;; 202 ; 203 if (fCovStatus != 0) {; 204 unsigned int r = npar * ( npar + 1 )/2;; 205 fCovMatrix.reserve(r);; 206 for (unsigned int i = 0; i < npar; ++i); 207 for (unsigned int j = 0; j <= i; ++j); 208 fCovMatrix.push_back(min->CovMatrix(i,j) );; 209 }; 210 // minos errors are set separately when calling Fitter::CalculateMinosErrors(); 211 ; 212 // globalCC; 213 fGlobalCC.reserve(npar);; 214 for (unsigned int i = 0; i < npar; ++i) {; 215 double globcc = min->GlobalCC(i);; 216 if (globcc < 0) break; // it is not supported by that minimizer; 217 fGlobalCC.push_back(globcc);; 218 }; 219 ; 220 }; 221 ; 222}; 223 ; 224bool FitResult::Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls) {; 225 // update fit result with new status from minimizer; 226 // ncalls if it is not zero is used instead of value from minimizer; 227 ; 228 fMinimizer = min;; 229 ; 230 // in case minimizer changes; 231 fMinimTy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:6924,clear,clear,6924,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,1,['clear'],['clear']
Usability,"mizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. unsigned intfDim; intfErrorCode; vector<double>fErrors; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; ROOT::Minuit2::FunctionMinimum*fMinimum; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; boolfUseFumili; vector<double>fValues. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Minuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad). Default constructor. Minuit2Minimizer(const char * type). Constructor with a char (used by PM). virtual ~Minuit2Minimizer(). Destructor (no operations). Minuit2Minimizer(const Minuit2Minimizer &); usually copying is non trivial, so we make this unaccessible. Copy constructor. void Clear(); clear resources (parameters) for consecutives minimizations. void SetFunction(const ROOT::Math::IMultiGenFunction & func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction & func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableVal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__Minuit2Minimizer.html:5489,clear,clear,5489,root/html526/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__Minuit2Minimizer.html,1,['clear'],['clear']
Usability,"mmand.h. ◆ Compress(). void TQCommand::Compress ; (; TQCommand * ; c). virtual . Compress command. ; Compression is analogous to arithmetic ""addition operation"".; Note:; The compressed command will be deleted.; Execution Compress method invokes Redo action with new redo arguments inherited from compressed command. More complicated commands might want to override this function. ; Definition at line 402 of file TQCommand.cxx. ◆ DeclFileName(). static const char * TQCommand::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 98 of file TQCommand.h. ◆ Delete(). void TQCommand::Delete ; (; Option_t * ; opt = """"). overridevirtual . If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ; If ""opt"" is zero - delete all merged commands. ; Reimplemented from TList.; Definition at line 285 of file TQCommand.cxx. ◆ GetCommand(). TQCommand * TQCommand::GetCommand ; (; ). static . Return a command which is doing redo/undo action. ; This static method allows to set undo parameters dynamically, i.e. during execution of Redo function.; Example: For redo actions like TGTextEdit::DelChar() it is not possible to know ahead what character will be deleted. To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)), one needs to call TQCommand::SetUndoArgs(1, character) from inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);; TQCommand::GetCommandstatic TQCommand * GetCommand()Return a command which is doing redo/undo action.Definition TQCommand.cxx:276. Definition at line 276 of file TQCommand.cxx. ◆ GetName(). const char * TQCommand::GetName ; (; ); const. overridevirtual . Returns the command name. ; Default name is ""ClassName::RedoName(args)"" If list of merged commands is not empty the name is ""ClassName::RedoName(args):cname1:cname2 ..."" ; Reimplemented from TCollection.; Definition at line 670 of file TQCommand.cxx. ◆ GetNRargs(). Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:36602,undo,undo,36602,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"mmands can be merged if they can be composed into a single command (Macro command). ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo arguments. ;  ; Int_t GetNUargs () const;  Returns a number of undo arguments. ;  ; void * GetObject () const;  Returns an object for which undo redo actions are applied. ;  ; TQConnection * GetRedo () const;  ; Long_t * GetRedoArgs () const;  Returns a pointer to array of redo arguments. ;  ; const char * GetRedoName () const;  Returns the name of redo command. ;  ; Int_t GetStatus () const;  Returns a number of sequential undo or redo operations. ;  ; const char * GetTitle () const override;  Returns command description. ;  ; TQConnection * GetUndo () const;  ; Long_t * GetUndoArgs () const;  Returns a pointer to array of undo arguments. ;  ; const char * GetUndoName () const;  Returns the name of undo command. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Undo function and is the setter action. ;  ; Bool_t IsUndoing () const;  Undo action is in progress. ;  ; virtual Long64_t Merge (TCollection *, TFileMergeInfo *);  Merge a collection of TQCommand. ;  ; virtual void Merge (TQCommand *c);  Add command to the list of merged commands. ;  ; virtual void SetArgs (Int_t nargs,...);  Set do/redo and undo parameters. ;  ; virtual void SetName (const char *name);  Sets name of the command. ;  ; virtual void SetRedoArgs (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:3495,undo,undo,3495,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"mn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBuf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooTreeDataStore.html:17033,clear,clear,17033,root/html528/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html528/RooTreeDataStore.html,2,['clear'],['clear']
Usability,"mn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree(); { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). void setBranchBufferSize(Int_t size); TTree Branch buffer size contro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:16959,clear,clear,16959,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,1,['clear'],['clear']
Usability,"modified/protected for the case; when a TProfile is projected (ProjectionX). The previous algorithm; generated a N^2 problem when projecting a TProfile with a large number of; bins (eg 100000).; - in version 3.05/06, a new static function TProfile::Approximate; is introduced to enable or disable (default) the approximation. Ideas for improvements of this algorithm are welcome. No suggestions; received since our call for advice to roottalk in Jul 2002.; see for instance: http://root.cern.ch/root/roottalk/roottalk02/2916.html. Option_t * GetErrorOption() const; -*Return option to compute profile errors; *-* =======================================. void GetStats(Double_t* stats) const; fill the array stats from the contents of this profile; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2; stats[4] = sumwy; stats[5] = sumwy2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. void LabelsDeflate(Option_t* axis = ""X""); Reduce the number of bins for this axis to the number of bins having a label. void LabelsInflate(Option_t* axis = ""X""); Double the number of bins for axis.; Refill histogram; This function is called by TAxis::FindBin(const char *label). void LabelsOption(Option_t* option = ""h"", Option_t* axis = ""X""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (start of label left adjusted). Long64_t Merge(TCollection* list); Merge all histograms in the collection in this histogram.; This function computes the min/max for the x axis,; compu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProfile.html:39627,simpl,simply,39627,root/html602/TProfile.html,https://root.cern,https://root.cern/root/html602/TProfile.html,2,['simpl'],['simply']
Usability,"modulo color component, cmy smooth alorithm,; cmy modulo color component, cie smooth alorithm,; cie modulo color component, yiq smooth alorithm,; yiq modulo color component, hsv smooth alorithm,; hsv modulo color component, it does not apply for simple display modes; algorithm group. void SetColorIncrements(Double_t r, Double_t g, Double_t b); Sets color increments between two color levels for r, g, b components:; -r, g, b - color increments between two color levels. void SetLightPosition(Int_t x, Int_t y, Int_t z); Sets position of fictive light source in 3D space:; -x, y, z. void SetShading(Int_t shading, Int_t shadow); Sets on/off shading and shadow switches:; -shading - determines whether the picture will shaded, smoothed (no shading, shading), for rainbowed display modes only; -shadow - determines whether shadow will be drawn, for rainbowed display modes with shading according to light. void SetBezier(Int_t bezier); Sets on/off Bezier smoothing:; -bezier - determines Bezier interpolation (applies only for simple; display modes group for grid, x_lines, y_lines display modes). void SetContourWidth(Int_t width); Sets width between horizontal slices:; -width - width between contours, applies only for contours display mode. void SetLightHeightWeight(Double_t weight); Sets weight between shading according to fictive light source and according to channels counts:; -weight - weight between shading according to fictive light source and according to channels counts, applies only for kPicture2ModeGroupLightHeight modes group. void SetChanMarks(Int_t enable, Int_t color, Int_t width, Int_t height, Int_t style); Sets enables/disables drawing of channel marks and sets their attributes:; -enable - decides whether the channel marks are shown or not; -color - color of channel marks; -width - width of channel marks in pixels; -height - height of channel marks in pixels; -style - style of channel marks (dot, cross, star, rectangle, X, diamond, triangle). void SetChanGrid(Int_t en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Painter.html:30348,simpl,simple,30348,root/html528/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Painter.html,6,['simpl'],['simple']
Usability,"more than one adequate generator. If you use Visual Studio, “NMake Makefiles” is a generator you can use for building with NMake. By default, CMake chooses the most specific generator supported by your development environment. If you want an alternative generator, you must tell this to CMake with the -G option.; Options and variables; Variables customize how the build will be generated. Options are boolean variables, with possible values ON/OFF. Options and variables are defined on the CMake command line like this:; $ cmake -DVARIABLE=value path/to/source. You can set a variable after the initial CMake invocation to change its value. You can also undefine a variable:; $ cmake -UVARIABLE path/to/source. Variables are stored in the CMake cache. This is a file named CMakeCache.txt stored at the root of your build directory that is generated by cmake. Editing it yourself is not recommended.; Variables are listed in the CMake cache with the variable name and type separated by a colon. You can also specify the variable and type on the CMake command line:; $ cmake -DVARIABLE:TYPE=value path/to/source. Variables in the CMake cache are 'remembered', so you do not need to type them if you execute cmake command again. It is recommended to delete the file CMakeCache.txt to start from a clean configuration. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:23827,guid,guidelines,23827,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['guid'],['guidelines']
Usability,"moryPlot::DoPlot ; (; ). Draw the plot from the logs. ; Definition at line 192 of file TProofProgressMemoryPlot.cxx. ◆ DoWorkerPlot(). TGraph * TProofProgressMemoryPlot::DoWorkerPlot ; (; TProofLogElem * ; ple). protected . Make a memory consumption graph for a worker. ; Definition at line 553 of file TProofProgressMemoryPlot.cxx. ◆ ParseLine(). Int_t TProofProgressMemoryPlot::ParseLine ; (; TString ; l, . Long64_t & ; v, . Long64_t & ; r, . Long64_t & ; e . ). protected . Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the number of events 'e'. ; The line is assumed to be in the form ""... Memory 130868 virtual 31540 ... event 5550"" The fields are only filled if >= 0 . Return 0 on success, -1 if any of the values could not be filled (the output fields are not touched in such a case). ; Definition at line 507 of file TProofProgressMemoryPlot.cxx. ◆ Select(). void TProofProgressMemoryPlot::Select ; (; Int_t ; id). actions of select all/clear all button ; Definition at line 644 of file TProofProgressMemoryPlot.cxx. Member Data Documentation. ◆ fAllWorkers. TGSplitButton* TProofProgressMemoryPlot::fAllWorkers. protected . Definition at line 34 of file TProofProgressMemoryPlot.h. ◆ fAPlot. TMultiGraph* TProofProgressMemoryPlot::fAPlot. protected . Definition at line 40 of file TProofProgressMemoryPlot.h. ◆ fDialog. TProofProgressDialog* TProofProgressMemoryPlot::fDialog. protected . Definition at line 31 of file TProofProgressMemoryPlot.h. ◆ fFullLogs. Bool_t TProofProgressMemoryPlot::fFullLogs. protected . Definition at line 41 of file TProofProgressMemoryPlot.h. ◆ fMasterPlot. TRootEmbeddedCanvas* TProofProgressMemoryPlot::fMasterPlot. protected . Definition at line 36 of file TProofProgressMemoryPlot.h. ◆ fMPlot. TMultiGraph* TProofProgressMemoryPlot::fMPlot. protected . Definition at line 39 of file TProofProgressMemoryPlot.h. ◆ fPlot. TGTextButton* TProofProgressMemoryPlot::fPlot. protected . Definition at line 33 of file TProofProgressMemo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressMemoryPlot.html:39684,clear,clear,39684,doc/master/classTProofProgressMemoryPlot.html,https://root.cern,https://root.cern/doc/master/classTProofProgressMemoryPlot.html,1,['clear'],['clear']
Usability,"mous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_t_debug; TFile*_refFile; list<pair<RooPlot*,string> >_regPlots; list<pair<RooFitResult*,string> >_regResults; list<pair<TH1*,string> >_regTH; list<pair<RooTable*,string> >_regTables; list<pair<Double_t,string> >_regValues; list<pair<RooWorkspace*,string> >_regWS; Int_t_verb; Bool_t_write; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static TDirectory*gMemDir. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooUnitTest(const char* name, TFile* refFile, Bool_t writeRef, Int_t verbose). ~RooUnitTest(). void regPlot(RooPlot* frame, const char* refName). void regResult(RooFitResult* r, const char* refName). void regValue(Double_t value, const char* refName). void regTable(RooTable* t, const char* refName). void regWS(RooWorkspace* ws, const char* refName). void regTH(TH1* h, const char* refName). RooWorkspace* getWS(const char* refName). Bool_t areTHidentical(TH1* htest, TH1* href). Bool_t runCompTests(). void setSilentMode(). void clearSilentMode(). Bool_t runTest(). void setMemDir(TDirectory* memDir); Set gMemDir to memDir. RooUnitTest(const char* name, TFile* refFile, Bool_t writeRef, Int_t verbose). void setDebug(Bool_t flag); { _debug = flag ; }. Bool_t isTestAvailable(); { return kTRUE ; }. Bool_t testCode(). Double_t htol(); { return 5e-4 ; }. Double_t ctol(); { return 2e-3 ; }. Double_t fptol(); { return 1e-3 ; }. Double_t fctol(); { return 1e-3 ; }. Double_t vtol(); { return 1e-3 ; }. » Last changed: Tue Jun 2 15:36:32 2015 » Last generated: 2015-06-02 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooUnitTest.html:8275,clear,clearSilentMode,8275,root/html604/RooUnitTest.html,https://root.cern,https://root.cern/root/html604/RooUnitTest.html,1,['clear'],['clearSilentMode']
Usability,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TBenchmark.html:7593,resume,resume,7593,root/html604/TBenchmark.html,https://root.cern,https://root.cern/root/html604/TBenchmark.html,1,['resume'],['resume']
Usability,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 14:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBenchmark.html:7593,resume,resume,7593,root/html602/TBenchmark.html,https://root.cern,https://root.cern/root/html602/TBenchmark.html,1,['resume'],['resume']
Usability,"mplate<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetWidth ; (; size_t ; width). inline . Definition at line 223 of file GeneralLayer.h. ◆ Update(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::Update ; (; const Scalar_t ; learningRate). Updates the weights and biases, given the learning rate. ; Definition at line 410 of file GeneralLayer.h. ◆ UpdateBiases(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiases ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the biases, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weights, given the gradients and the learning rate,. ; Definition at line 418 of file GeneralLayer.h. ◆ WriteMatrixToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteMatrixToXML ; (; void * ; node, . const char * ; name, . const Matrix_t & ; matrix . ). Definition at line 521 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:26007,learn,learning,26007,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learning']
Usability,"mple: TAxis_ver8 or TList_raw5 Second kind of tables appears, when some of class members can not be converted to normalized form or when class has custom streamer. For instance, for TH1 class two tables are required: TH1_ver4 and TH1_raw4 Most of members are stored in TH1_ver4 table column-wise, and only member: Double_t* fBuffer; //[fBufferSize] can not be represented as column while size of array is not fixed. Therefore, fBuffer will be written as list of values in TH1_raw4 table. All objects, stored in the DB, will be registered in table ""ObjectsTable"". In this there are following columns: . Name Description . ""key:id"" key identifier to which belong object . ""obj:id"" object identifier . ""Class"" object class name . ""Version"" object class version . Data in each ""ObjectsTable"" row uniquely identify, in which table and which column object is stored.; In normal situation all class data should be sorted column-wise. Up to now following member are supported:; Basic data types. Here is everything clear. Column SQL type will be as much as possible close to the original type of value.; Fixed array of basic data types. In this case n columns like fArr[0], fArr[1] and so on will be created. If there is multidimensional array, names will be fArr2[1][2][1] and so on; Parent class. In this case version of parent class is stored and data of parent class will be stored with the same obj:id in correspondent table. There is a special case, when parent store nothing (this is for instance TQObject). In that case just -1 is written to avoid any extra checks if table exist or not.; Object as data member. In that case object is saved in normal way to data base and column will contain id of this object.; Pointer on object. Same as before. In case if object was already stored, just its id will be placed in the column. For NULL pointer 0 is used.; TString. Now column with limited width like VARCAHR(255) in MySQL is used. Later this will be improved to support maximum possible strings; Anyt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:1716,clear,clear,1716,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['clear'],['clear']
Usability,"mplicated, especially if there are (cyclical) reference back to the owning object ; Definition at line 47 of file RooObjCacheManager.cxx. ◆ RooObjCacheManager() [2/2]. RooObjCacheManager::RooObjCacheManager ; (; const RooObjCacheManager & ; other, . RooAbsArg * ; owner = nullptr . ). Copy constructor. ; Definition at line 59 of file RooObjCacheManager.cxx. ◆ ~RooObjCacheManager(). RooObjCacheManager::~RooObjCacheManager ; (; ). override . Destructor. ; Definition at line 71 of file RooObjCacheManager.cxx. Member Function Documentation. ◆ Class(). static TClass * RooObjCacheManager::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooObjCacheManager::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooObjCacheManager::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 62 of file RooObjCacheManager.h. ◆ clearObsList(). static bool RooObjCacheManager::clearObsList ; (; ). inlinestatic . Definition at line 48 of file RooObjCacheManager.h. ◆ DeclFileName(). static const char * RooObjCacheManager::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 62 of file RooObjCacheManager.h. ◆ doClearObsList(). static void RooObjCacheManager::doClearObsList ; (; bool ; flag). inlinestatic . Definition at line 47 of file RooObjCacheManager.h. ◆ findConstantNodes(). void RooObjCacheManager::findConstantNodes ; (; const RooArgSet & ; obs, . RooArgSet & ; cacheList, . RooLinkedList & ; processedNodes . ). overridevirtual . If clearOnRedirect is false, forward constant term optimization calls to cache elements. ; Reimplemented from RooAbsCache.; Definition at line 209 of file RooObjCacheManager.cxx. ◆ insertObjectHook(). void RooObjCacheManager::insertObjectHook ; (; RooAbsCacheElement & ; obj). overridevirtual . Set owner link on all object inserted into cache. ; Also if cache mode o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:8445,clear,clearObsList,8445,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['clear'],['clearObsList']
Usability,"mponents,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will ignore; for the time being the positioning of components. The definition of a composite; shape takes an expression where the identifiers are shape names. The; expression is parsed and decomposed in 2 sub-expressions and the top-level; Boolean operator. 1. A+B+C; This represent the union of A, B and C. Both union operators are at the; same level. Since:; A+B+C = (A+B)+C = A+(B+C); the first (+) is taken as separator, hence the expression split:; A and B+C; A Boolean node of type TGeoUnion(""A"", ""B+C"") is created. This tries to replace; the 2 expressions by actual pointers to corresponding shapes.; The first expression (A) contains no operators therefore is interpreted as; representing a shape. The shape named ""A"" is searched into the list of shapes; handled by the manager class and stored as the ""left"" shape in the Boolean; union node. Since the second expression is not yet fully decomposed, the ""right""; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:2335,simpl,simple,2335,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,3,['simpl'],['simple']
Usability,"mponents,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will ignore; for the time being the positioning of components. The definition of a composite; shape takes an expression where the identifiers are shape names. The; expression is parsed and decomposed in 2 sub-expressions and the top-level; Boolean operator. 1. A+B+C; This represent the union of A, B and C. Both union operators are at the; same level. Since:; A+B+C = (A+B)+C = A+(B+C); the first (+) is taken as separator, hence the expression splitted:; A and B+C; A Boolean node of type TGeoUnion(""A"", ""B+C"") is created. This tries to replace; the 2 expressions by actual pointers to corresponding shapes.; The first expression (A) contains no operators therefore is interpreted as; representing a shape. The shape named ""A"" is searched into the list of shapes; handled by the manager class and stored as the ""left"" shape in the Boolean; union node. Since the second expression is not yet fully decomposed, the ""right",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCompositeShape.html:2335,simpl,simple,2335,root/html528/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html528/TGeoCompositeShape.html,3,['simpl'],['simple']
Usability,"mposing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCII file (see -Scanning expressions-);; - a button bar in the lower part with : buttons DRAW/STOP that issue histogram; drawing and stop the current command respectively, two text widgets where; input and output event lists can be specified, a message box and a RESET; button on the right that clear edited expression content (see Editing...); - a tree-type list on the main left panel where you can select among trees or; branches. The tree/branch will be detailed in the right panel.; Mapped trees are provided with context menus, activated by right-clicking;; - a view-type list on the right panel. The first column contain X, Y and; Z expression items, an optional cut and ten optional editable expressions.; Expressions and leaf-type items can be dragged or deleted. A right click on; the list-box or item activates context menus. Opening a new tree and saving a session :. To open a new tree in the viewer use <File/Open tree file> menu; The content of the file (keys) will be listed. Use <SetTreeName> function; from the context menu of the right panel, entering a tree name among those; l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeViewer.html:2353,clear,clear,2353,root/html530/TTreeViewer.html,https://root.cern,https://root.cern/root/html530/TTreeViewer.html,5,['clear'],['clear']
Usability,"mputation of the boundaries before iterating through all of the bins.; Parameters. pAxisthe axis to consider ; nPixelsthe number of pixels to render axis into ; isLogwhether the axis is log scale . Definition at line 5472 of file THistPainter.cxx. ◆ DeclFileName(). static const char * THistPainter::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 159 of file THistPainter.h. ◆ DefineColorLevels(). void THistPainter::DefineColorLevels ; (; Int_t ; ndivz). virtual . Define the color levels used to paint legos, surfaces etc.. ; Definition at line 9603 of file THistPainter.cxx. ◆ DistancetoPrimitive(). Int_t THistPainter::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute the distance from the point px,py to a line. ; Compute the closest distance of approach from point px,py to elements of an histogram. The distance is computed in pixels units.; Algorithm: Currently, this simple model computes the distance from the mouse to the histogram contour only. ; Implements TVirtualHistPainter.; Definition at line 3255 of file THistPainter.cxx. ◆ DrawPanel(). void THistPainter::DrawPanel ; (; ). overridevirtual . Display a panel with all histogram drawing options. ; Implements TVirtualHistPainter.; Definition at line 3444 of file THistPainter.cxx. ◆ ExecuteEvent(). void THistPainter::ExecuteEvent ; (; Int_t ; event, . Int_t ; px, . Int_t ; py . ). overridevirtual . Execute the actions corresponding to event. ; This function is called when a histogram is clicked with the locator at the pixel position px,py. ; Implements TVirtualHistPainter.; Definition at line 3464 of file THistPainter.cxx. ◆ GetBestFormat(). const char * THistPainter::GetBestFormat ; (; Double_t ; v, . Double_t ; e, . const char * ; f . ). static . This function returns the best format to print the error value (e) knowing the parameter value (v) and the format (f) used to print it. ; Definition at line 10714 of file THist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:153217,simpl,simple,153217,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['simpl'],['simple']
Usability,"ms in parallel and write them on file ;  mtbb101_fillNtuples.C Fill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.C Parallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallelMergeTest.C;  pclient.CClient program to test parallel sockets ;  pserv.CServer program to test parallel sockets ;  spy.CClient program which allows the snooping of objects from a spyserv process ;  spyserv.CServer program which allows clients, ""spies"", to connect and snoop objects ;  TestAuth.CMacro test authentication methods stand alone ;  testTUDPSocket.CAs test echo server use udpserver.c in the same directory ;  treeClient.CClient program which creates and fills 2 histograms and a TTree ;  TUriTest.CRudimentary TUri test macro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:136734,simpl,simple,136734,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['simpl'],['simple']
Usability,"multiple times. After the first call above to TTree::Draw, a TEntryListArray is created and filled with the entries and the indices of the arrays that satisfied the selection cut (x > 0). In the subsequent calls to TTree::Draw, only these entries / subentries are used to fill histograms. About the class; The class derives from TEntryList and can be used basically in the same way. This same class is used to keep entries and subentries, so there are two types of TEntryListArray's:. The ones that only hold subentries; fEntry is set to the entry# for which the subentries correspond; fSubLists must be 0. The ones that hold entries and eventually lists with subentries in fSubLists.; fEntry = -1 for those; If there are no sublists for a given entry, all the subentries will be used in the selection. Additions with respect to TEntryList. Data members:; fSubLists: a container to hold the sublists; fEntry: the entry number if the list is used to hold subentries; fLastSubListQueried and fSubListIter: a pointer to the last sublist queried and an iterator to resume the loop from the last sublist queried (to speed up selection and insertion in TTree::Draw). Public methods:; Contains, Enter and Remove with subentry as argument; GetSubListForEntry: to return the sublist corresponding to the given entry. Protected methods:; AddEntriesAndSubLists: called by Add when adding two TEntryList arrays with sublists; ConvertToTEntryListArray: convert TEntryList to TEntryListArray; RemoveSubList: to remove the given sublist; RemoveSubListForEntry: to remove the sublist corresponding to the given entry; SetEntry: to get / set a sublist for the given entry . Definition at line 26 of file TEntryListArray.h. Public Member Functions;  TEntryListArray ();  Default c-tor. ;  ;  TEntryListArray (const char *name, const char *title);  c-tor with name and title ;  ;  TEntryListArray (const char *name, const char *title, const char *treename, const char *filename);  c-tor with name and title, which also ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListArray.html:1999,resume,resume,1999,doc/master/classTEntryListArray.html,https://root.cern,https://root.cern/doc/master/classTEntryListArray.html,1,['resume'],['resume']
Usability,"multithreading turned on?; 816 ; 817 ; 818 void pads (int numPads) { if (fMonitoring) fMonitoring->pads (numPads); } ///< preparation for monitoring; 819 void create (std::string histoName, int bins, double min, double max) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max); } ///< for monitoring; 820 void create (std::string histoName, int bins, double min, double max, int bins2, double min2, double max2) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max, bins2, min2, max2); } ///< for monitoring; 821 void addPoint (std::string histoName, double x) { if (fMonitoring) fMonitoring->addPoint (histoName, x); } ///< for monitoring; 822 void addPoint (std::string histoName, double x, double y) {if (fMonitoring) fMonitoring->addPoint (histoName, x, y); } ///< for monitoring; 823 void plot (std::string histoName, std::string options, int pad, EColor color) { if (fMonitoring) fMonitoring->plot (histoName, options, pad, color); } ///< for monitoring; 824 void clear (std::string histoName) { if (fMonitoring) fMonitoring->clear (histoName); } ///< for monitoring; 825 bool exists (std::string histoName) { if (fMonitoring) return fMonitoring->exists (histoName); return false; } ///< for monitoring; 826 ; 827 size_t convergenceCount () const { return m_convergenceCount; } ///< returns the current convergence count; 828 size_t maxConvergenceCount () const { return m_maxConvergenceCount; } ///< returns the max convergence count so far; 829 size_t minError () const { return m_minError; } ///< returns the smallest error so far; 830 ; 831 public:; 832 Timer m_timer; ///< timer for monitoring; 833 double m_minProgress; ///< current limits for the progress bar; 834 double m_maxProgress; ///< current limits for the progress bar; 835 ; 836 ; 837 size_t m_convergenceSteps; ///< number of steps without improvement to consider the DNN to have converged; 838 size_t m_batchSize; ///< mini-batch size; 839 size_t m_testRepetitions;; 840 double m_factorWeightDecay;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:31375,clear,clear,31375,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['clear'],['clear']
Usability,"n .rootrc, as documented in the THtml class reference page http://root.cern.ch/root/html/THtml. The following will enumerate some of the highlights.; 27.4.1 Referencing Documentation for other Libraries; When THtml generates documentation for classes it recognizes all class names known to ROOT. If THtml does not have sources for a class it determines the class’s library name. This has to be set by means of rootmap files, see Library AutoLoading of this User’s Guide. Given the library name, THtml searches for an entry in its map of libraries to documentation URLs. If it finds it, it will create a link to the documentation at that URL for all occurrences of a given class name. One can set the URL ../mylib/ for a library name MyLib by setting Root.Html.MyLib: ../mylib/ or by calling THtml::SetLibURL(""MyLib"", ""../mylib/""). Occurrences of class MyClass of MyLib will now be referenced as ../mylib/MyClass.html.; 27.4.2 Search Engine; THtml can invoke external search engines. The ROOT reference guide sets Root.Html.Search to http://www.google.com/search?q=%s+site%3A%u. Calling THtml::SetSearchStemURL() will set the same. If this URL stem is set, THtml will create search fields in the index pages. It will send the words entered in these search fields as %s in the URL; %u will be replaced by the current document’s path, allowing a site- and directory-specific search.; 27.4.3 ViewCVS; Most code is managed in a version control system like CVS. ViewCVS is a WWW reader interface to the versioning control system that allows e.g. tracking a file’s changes. THtml will reference these pages automatically if the .rootrc variable Root.Html.ViewCVS is set to the URL stem of the ViewCVS. installation. Alternatively, one can call THtml::SetViewCVS().; 27.4.4 Wiki Pages; In some contexts it might be desirable to let users comment on classes, e.g. for suggestions of use or alternatives, details of behavior, and cross references to other relevant classes. A successful example of this is the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1249806,guid,guide,1249806,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['guid'],['guide']
Usability,"n = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. TQueryDescription*fActQuerycurrent (actual) query; TStringfAddressserver address; Bool_tfAttachedkTRUE if attached; Bool_tfAutoEnableenable packages at session startup time; TStringfConfigFileconfiguration file name; Bool_tfConnectedkTRUE if connected; Bool_tfLocalkTRUE if session is local; Int_tfLogLevellog (debug) level; TStringfNamesession name; Int_tfNbHistosnumber of feedback histos; TList*fPackageslist of packages; Int_tfPortcommunication port; TProof*fProofpointer on TProof used by this session; TProofMgr*fProofMgrProof sessions manager; TList*fQuerieslist of queries in this session; Bool_tfSynckTRUE if in sync mode; TStringfTagsession unique identifier; TStringfUserNameuser name (on server); static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance Chart:. TObject. ←; TSessionDescription. Function documentation; const char * GetName() const; { return fQueryName; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionDescription.html:5505,feedback,feedback,5505,root/html602/TSessionDescription.html,https://root.cern,https://root.cern/root/html602/TSessionDescription.html,2,['feedback'],['feedback']
Usability,"n SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoTrapEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoH1(); Slot for H1. void DoBl1(); Slot for Bl1. void DoTl1(); Slot for Tl1. void DoDz(); Slot for Z. void DoSc1(); Slot for H2. void DoSc2(); Slot for H2. void DoAlpha1(); Slot for alpha1. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTrapEditor.html:22847,undo,undoing,22847,root/html604/TGeoTrapEditor.html,https://root.cern,https://root.cern/root/html604/TGeoTrapEditor.html,1,['undo'],['undoing']
Usability,"n SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoTrapEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoH1(); Slot for H1. void DoBl1(); Slot for Bl1. void DoTl1(); Slot for Tl1. void DoDz(); Slot for Z. void DoSc1(); Slot for H2. void DoSc2(); Slot for H2. void DoAlpha1(); Slot for alpha1. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrapEditor.html:22847,undo,undoing,22847,root/html602/TGeoTrapEditor.html,https://root.cern,https://root.cern/root/html602/TGeoTrapEditor.html,1,['undo'],['undoing']
Usability,"n TColorWheel.h:36; TColorWheel::fRmaxDouble_t fRmaxMaximum radius for rectangles.Definition TColorWheel.h:27; TColorWheel::PaintGrayvoid PaintGray() constDraw the gray colors + white + black.Definition TColorWheel.cxx:389; TColorWheel::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideReturn the color number pointed by the mouse.Definition TColorWheel.cxx:155; TColorWheel::Paintvoid Paint(Option_t *option="""") overridePaint the color wheel.Definition TColorWheel.cxx:225; TColorWheel::PaintCirclesvoid PaintCircles(Int_t coffset, Double_t angle) constDraw all colors of type circle.Definition TColorWheel.cxx:279; TColorWheel::fDrDouble_t fDrCircles radius.Definition TColorWheel.h:29; TColorWheel::PaintRectanglesvoid PaintRectangles(Int_t coffset, Double_t angle) constDraw all colors of type rectangle.Definition TColorWheel.cxx:306; TColorWheel::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overridealways return the color wheelDefinition TColorWheel.cxx:106; TColorWheel::Rotatevoid Rotate(Double_t x, Double_t y, Double_t &u, Double_t &v, Double_t ang) constRotate point x,y with an angle=ang.Definition TColorWheel.cxx:428; TColorWheel::fGraphTGraph * fGraph! pointer to utility graphDefinition TColorWheel.h:37; TColorWheel::~TColorWheel~TColorWheel() overridedestructorDefinition TColorWheel.cxx:94; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TTextBase class for several text objects.Definition TText.h:22; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; v@ vDefinition rootcling_impl.cxx:3699; Drawth1 Draw(). graf2dgpadincTColorWheel.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:17 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColorWheel_8h_source.html:6777,simpl,simple,6777,doc/master/TColorWheel_8h_source.html,https://root.cern,https://root.cern/doc/master/TColorWheel_8h_source.html,1,['simpl'],['simple']
Usability,"n THbookFile.cxx:91; TLine.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TTree.h; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::BypassStreamervoid BypassStreamer(Bool_t bypass=kTRUE)When the kBypassStreamer bit is set, the automatically generated Streamer can call directly TClass::W...Definition TClonesArray.cxx:321; TClonesArray::Clearvoid Clear(Option_t *option="""") overrideClear the clones array.Definition TClonesArray.cxx:420; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::GetY1Double_t GetY1() constDefinition TLine.h:52; TLine::GetX2Double_t GetX2() constDefinition TLine.h:51; TLine::GetX1Double_t GetX1() constDefinition TLine.h:50; TLine::GetY2Double_t GetY2() constDefinition TLine.h:53; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tcl_8C.html:4298,simpl,simple,4298,doc/master/tcl_8C.html,https://root.cern,https://root.cern/doc/master/tcl_8C.html,1,['simpl'],['simple']
Usability,"n TQCommand.h:27. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");; For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color; ; com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);; Color_tshort Color_tDefinition RtypesCore.h:85; TQCommand::SetRedoArgsvirtual void SetRedoArgs(Int_t nargs,...)Set redo parameters.Definition TQCommand.cxx:508; TQCommand::SetUndoArgsvirtual void SetUndoArgs(Int_t nargs,...)Set undo parameters.Definition TQCommand.cxx:542; 1st argument - the number of undo, redo parameters the other arguments - undo, redo values Since the number of undo,redo parameters is the same one can use com->SetArgs(1, new_color, old_color);; TQCommand::SetArgsvirtual void SetArgs(Int_t nargs,...)Set do/redo and undo parameters.Definition TQCommand.cxx:465. Undo, redo method execution com->Redo(); // execute redo method; com->Undo(); // execute undo method; TQCommand::Undovirtual void Undo(Option_t *option="""")Un-execute all merged commands and the command.Definition TQCommand.cxx:626; TQCommand::Redovirtual void Redo(Option_t *option="""")Execute command and then merge commands.Definition TQCommand.cxx:588. Merged commands It possible to group several commands together so an end user can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; gPad#define gPadDefinition TVirtualPad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:2255,undo,undo,2255,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,3,['undo'],['undo']
Usability,"n `pythonizor_of_myclass` provides and injects a new; # implementation for `__str__`, the mechanism that Python provides to define; # how to represent objects as strings. This new implementation; # always returns the string ""This is a MyClass object"".; @pythonization('MyClass'); def pythonizor_of_myclass(klass):; klass.__str__ = lambda o : 'This is a MyClass object'; ; # Once we have defined our pythonizor function, let's see it in action.; # We will now use the `MyClass` class for the first time from Python: we will; # create a new instance of that class. At this moment, the pythonizor will; # execute and modify the class - pythonizors are always lazily run when a given; # class is used for the first time from a Python script.; my_object = ROOT.MyClass(); ; # Since the pythonizor already executed, we should now see the new behaviour.; # For that purpose, let's print `my_object` (should show ""This is a MyClass; # object"").; print(my_object); ; # The previous example is just a simple one, but there are many ways in which a; # class can be pythonized. Typical examples are the redefinition of dunder; # methods (e.g. `__iter__` and `__next__` to make your objects iterable from; # Python). If you need some inspiration, many ROOT classes are pythonized in; # the way we just saw; their pythonizations can be seen at:; # https://github.com/root-project/root/tree/master/bindings/pyroot/pythonizations/python/ROOT/pythonization; ; # The @pythonization decorator offers a few more options when it comes to; # matching classes that you want to pythonize. We saw that we can match a; # single class, but we can also specify a list of classes to pythonize.; #; # The following code defines a couple of new classes:; ROOT.gInterpreter.Declare('''; namespace NS {; class Class1 {};; class Class2 {};; }; '''); ; # Note that these classes belong to the `NS` namespace. As mentioned above, the; # @pythonization decorator accepts a parameter with the namespace of the class; # or classes to be pyt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html:3239,simpl,simple,3239,doc/master/pyroot002__pythonizationDecorator_8py.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html,1,['simpl'],['simple']
Usability,"n a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  ;  Static Public Member Functions inherited from RooAbsLValue; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; virtual value_type evaluate () const =0;  Evaluate the category state and return. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; virtual void recomputeShape ()=0;  If a category depends on the shape of others, i.e. its state numbers or names depend o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategoryLValue.html:37421,clear,clearTypes,37421,doc/master/classRooAbsCategoryLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategoryLValue.html,1,['clear'],['clearTypes']
Usability,"n actions.; 18.5 Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that.; 18.5.1 TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:971313,simpl,simple,971313,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"n adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes TMinuitMinimizer implemented using TMinuit, TFumiliMinimizer implemented using TFumili for least squa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:713074,guid,guide,713074,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['guid'],['guide']
Usability,"n and stored, these are then bound and converted to type TGeoBBox and stored in fsolmap map using the name as its key. ; Definition at line 2707 of file TGDMLParse.cxx. ◆ EleProcess(). XMLNodePointer_t TGDMLParse::EleProcess ; (; TXMLEngine * ; gdml, . XMLNodePointer_t ; node, . XMLNodePointer_t ; parentn, . Bool_t ; hasIsotopes, . Bool_t ; hasIsotopesExtended . ). private . When the element keyword is found, this function is called, and the name and values of the element are converted into type TGeoElement and stored in felemap map using the name as its key. ; Definition at line 1086 of file TGDMLParse.cxx. ◆ Ellipsoid(). XMLNodePointer_t TGDMLParse::Ellipsoid ; (; TXMLEngine * ; gdml, . XMLNodePointer_t ; node, . XMLAttrPointer_t ; attr . ). private . In the solids section of the GDML file, an ellipsoid may be declared. ; Unfortunately, the ellipsoid is not supported under ROOT so, when the ellipsoid keyword is found, this function is called to convert it to a simple box with similar dimensions, and the dimensions required are taken and stored, these are then bound and converted to type TGeoBBox and stored in fsolmap map using the name as its key. ; Definition at line 2619 of file TGDMLParse.cxx. ◆ ElTube(). XMLNodePointer_t TGDMLParse::ElTube ; (; TXMLEngine * ; gdml, . XMLNodePointer_t ; node, . XMLAttrPointer_t ; attr . ). private . In the solids section of the GDML file, a ElTube may be declared. ; when the eltube keyword is found, this function is called, and the dimensions required are taken and stored, these are then bound and converted to type TGeoEltu and stored in fsolmap map using the name as its key. ; Definition at line 4024 of file TGDMLParse.cxx. ◆ Evaluate(). double TGDMLParse::Evaluate ; (; const char * ; evalline). private . Takes a string containing a mathematical expression and returns the value of the expression. ; Definition at line 411 of file TGDMLParse.cxx. ◆ GDMLReadFile(). TGeoVolume * TGDMLParse::GDMLReadFile ; (; const char * ; filenam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDMLParse.html:31550,simpl,simple,31550,doc/master/classTGDMLParse.html,https://root.cern,https://root.cern/doc/master/classTGDMLParse.html,1,['simpl'],['simple']
Usability,"n at line 1670 of file TGenCollectionProxy.cxx. ◆ GetIncrement(). ULong_t TGenCollectionProxy::GetIncrement ; (; ); const. overridevirtual . Return the offset between two consecutive value_types (memory layout). ; Implements TVirtualCollectionProxy.; Definition at line 1004 of file TGenCollectionProxy.cxx. ◆ GetOnFileClass(). virtual TClass * TGenCollectionProxy::GetOnFileClass ; (; ); const. inlinevirtual . Definition at line 428 of file TGenCollectionProxy.h. ◆ GetReadMemberWiseActions(). TStreamerInfoActions::TActionSequence * TGenCollectionProxy::GetReadMemberWiseActions ; (; Int_t ; version). overridevirtual . Return the set of action necessary to stream in this collection member-wise coming from the old value class layout refered to by 'version'. ; Implements TVirtualCollectionProxy.; Definition at line 1798 of file TGenCollectionProxy.cxx. ◆ GetType(). EDataType TGenCollectionProxy::GetType ; (; ); const. overridevirtual . If the content is a simple numerical value, return its type (see TDataType) ; Implements TVirtualCollectionProxy.; Definition at line 1051 of file TGenCollectionProxy.cxx. ◆ GetValueClass(). TClass * TGenCollectionProxy::GetValueClass ; (; ); const. overridevirtual . Return a pointer to the TClass representing the content. ; Implements TVirtualCollectionProxy.; Definition at line 1038 of file TGenCollectionProxy.cxx. ◆ GetWriteMemberWiseActions(). TStreamerInfoActions::TActionSequence * TGenCollectionProxy::GetWriteMemberWiseActions ; (; ). overridevirtual . Return the set of action necessary to stream out this collection member-wise. ; Implements TVirtualCollectionProxy.; Definition at line 1820 of file TGenCollectionProxy.cxx. ◆ HasPointers(). Bool_t TGenCollectionProxy::HasPointers ; (; ); const. overridevirtual . Return true if the content is of type 'pointer to'. ; Implements TVirtualCollectionProxy.; Definition at line 1022 of file TGenCollectionProxy.cxx. ◆ Initialize(). TGenCollectionProxy * TGenCollectionProxy::Initialize ; (; Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:22167,simpl,simple,22167,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['simpl'],['simple']
Usability,"n at line 242 of file TGeoMatrix.h. ◆ Determinant(). Double_t TGeoRotation::Determinant ; (; ); const. computes determinant of the rotation matrix ; Definition at line 1364 of file TGeoMatrix.cxx. ◆ FastRotZ(). void TGeoRotation::FastRotZ ; (; const Double_t * ; sincos). Perform a rotation about Z having the sine/cosine of the rotation angle. ; Definition at line 1039 of file TGeoMatrix.cxx. ◆ GetAngles() [1/2]. void TGeoRotation::GetAngles ; (; Double_t & ; phi, . Double_t & ; theta, . Double_t & ; psi . ); const. Retrieve Euler angles. ; Definition at line 1340 of file TGeoMatrix.cxx. ◆ GetAngles() [2/2]. void TGeoRotation::GetAngles ; (; Double_t & ; theta1, . Double_t & ; phi1, . Double_t & ; theta2, . Double_t & ; phi2, . Double_t & ; theta3, . Double_t & ; phi3 . ); const. Retrieve rotation angles. ; Definition at line 1310 of file TGeoMatrix.cxx. ◆ GetInverse(). void TGeoRotation::GetInverse ; (; Double_t * ; invmat); const. Get the inverse rotation matrix (which is simply the transpose) ; Definition at line 1393 of file TGeoMatrix.cxx. ◆ GetPhiRotation(). Double_t TGeoRotation::GetPhiRotation ; (; Bool_t ; fixX = kFALSE); const. Returns rotation angle about Z axis in degrees. ; If the rotation is a pure rotation about Z, fixX parameter does not matter, otherwise its meaning is:; fixX = true : result is the phi angle of the projection of the rotated X axis in the un-rotated XY; fixX = false : result is the phi angle of the projection of the rotated Y axis - 90 degrees . Definition at line 1054 of file TGeoMatrix.cxx. ◆ GetRotationMatrix(). const Double_t * TGeoRotation::GetRotationMatrix ; (; ); const. inlineoverridevirtual . Implements TGeoMatrix.; Definition at line 239 of file TGeoMatrix.h. ◆ GetScale(). const Double_t * TGeoRotation::GetScale ; (; ); const. inlineoverridevirtual . Implements TGeoMatrix.; Definition at line 240 of file TGeoMatrix.h. ◆ GetTranslation(). const Double_t * TGeoRotation::GetTranslation ; (; ); const. inlineoverridevirtual . Imp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoRotation.html:22071,simpl,simply,22071,doc/master/classTGeoRotation.html,https://root.cern,https://root.cern/doc/master/classTGeoRotation.html,1,['simpl'],['simply']
Usability,"n at line 529 of file DecisionTreeNode.cxx. ◆ AddToSumTarget(). void TMVA::DecisionTreeNode::AddToSumTarget ; (; Float_t ; t). inline . add to sum target, if traininfo defined ; Definition at line 335 of file DecisionTreeNode.h. ◆ AddToSumTarget2(). void TMVA::DecisionTreeNode::AddToSumTarget2 ; (; Float_t ; t2). inline . add to sum target 2, if traininfo defined ; Definition at line 337 of file DecisionTreeNode.h. ◆ Class(). static TClass * TMVA::DecisionTreeNode::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::DecisionTreeNode::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::DecisionTreeNode::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 397 of file DecisionTreeNode.h. ◆ ClearNodeAndAllDaughters(). void TMVA::DecisionTreeNode::ClearNodeAndAllDaughters ; (; ). clear the nodes (their S/N, Nevents etc), just keep the structure of the tree ; Definition at line 346 of file DecisionTreeNode.cxx. ◆ CreateNode(). virtual Node * TMVA::DecisionTreeNode::CreateNode ; (; ); const. inlinevirtual . Implements TMVA::Node.; Definition at line 132 of file DecisionTreeNode.h. ◆ DeclFileName(). static const char * TMVA::DecisionTreeNode::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 397 of file DecisionTreeNode.h. ◆ GetAlpha(). Double_t TMVA::DecisionTreeNode::GetAlpha ; (; ); const. inline . return the critical point alpha, or -1 if traininfo undefined ; Definition at line 308 of file DecisionTreeNode.h. ◆ GetAlphaMinSubtree(). Double_t TMVA::DecisionTreeNode::GetAlphaMinSubtree ; (; ); const. inline . return the minimum alpha in the tree rooted at this node, or -1 if traininfo undefined ; Definition at line 313 of file DecisionTreeNode.h. ◆ GetCC(). Double_t TMVA::DecisionTreeNode::GetCC ; (; ); const. inline . return CC, or -1 if traininfo undefined ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html:16868,clear,clear,16868,doc/master/classTMVA_1_1DecisionTreeNode.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html,1,['clear'],['clear']
Usability,"n at line 971 of file RooProdPdf.cxx. ◆ makeRGPPName(). std::string RooProdPdf::makeRGPPName ; (; const char * ; pfx, . const RooArgSet & ; term, . const RooArgSet & ; iset, . const RooArgSet & ; nset, . const char * ; isetRangeName . ); const. private . Make an appropriate automatic name for a RooGenProdProj object in getPartIntList() ; Definition at line 1555 of file RooProdPdf.cxx. ◆ pdfList(). const RooArgList & RooProdPdf::pdfList ; (; ); const. inline . Definition at line 67 of file RooProdPdf.h. ◆ plotSamplingHint(). std::list< double > * RooProdPdf::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Forward the plot sampling hint from the p.d.f. that defines the observable obs. ; Reimplemented from RooAbsReal.; Definition at line 2106 of file RooProdPdf.cxx. ◆ printMetaArgs(). void RooProdPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 2189 of file RooProdPdf.cxx. ◆ processProductTerm(). std::vector< RooAbsReal * > RooProdPdf::processProductTerm ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset, . const char * ; isetRangeName, . const RooArgSet * ; term, . const RooArgSet & ; termNSet, . const RooArgSet & ; termISet, . bool & ; isOwned, . bool ; forceWrap = false . ); const. private . Calculate integrals of factorized product terms over observables iset while normalized to observables in nset. ; Definition at line 1382 of file RooProdPdf.cxx. ◆ rearrangeProduct(). void RooProdPdf::rearrangeProduct ; (; RooProdPdf::CacheElem & ; cache); const. private . Definition at line 989 of file RooProdPdf.cxx. ◆ redirectServersHook(). bool RooProdPdf::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overridevirtual . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:98170,intuit,intuitively,98170,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['intuit'],['intuitively']
Usability,"n be the case where the class definition is lost, or unavailable.; The current version of a shared library and an old file with old class versions (backward compatibility). This is often the case when reading old data.; Reading a file with a shared library built with MakeProject. This is the case when someone has already read the data without a shared library and has used ROOT MakeProject feature to reconstruct the class definitions and shared library (MakeProject is explained in detail later on). In case of a mismatch between the in-memory version and the persistent version of a class, ROOT maps the persistent one to the one in memory. This allows you to change the class definition at will, for example:. Change the order of data members in the class.; Add new data members. By default, the value of the missing member will be 0 or in case of an object it will be set to null.; Remove data members.; Move a data member to a base class or vice-versa.; Change the type of a member if it is a simple type or a pointer to a simple type. If a loss of precision occurs, a warning is given.; Add or remove a base class. The schema evolution for objects written on disk and in memory. ROOT supports schema evolution by keeping a class description of each version of the class that was ever written to disk, with the class. When it writes an object to file, it also writes the description of the current class version along with it. This description is implemented in the StreamerInfoclass.; 11.5.1 The TStreamerInfo Class; Each class has a list of StreamerInfo objects, one for each version of the class if that version was written to disk at least once. When reading an object from a file, the system uses the StreamerInfo list to decode an object into the current version. The StreamerInfo is made up of TStreamerElements . Each describes one persistent data member of the class. By default, all data members of a class are persistent. To exclude a data member (i.e. make it not persistent), add a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:491516,simpl,simple,491516,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"n case one label does not exist yet. When the filling is terminated, it is possible to trim the number of bins to match the number of active labels by calling:; TH1::LabelsDeflate(axis);; Here axis may be X, Y, or Z. This operation is automatic when using TTree::Draw . Once bin labels have been created, they become persistent if the histogram is written to a file or when generating the C++ code via SavePrimitive .; 3.15 Histogram Stacks; A THStack is a collection of TH1 (or derived) objects. Use THStack::Add( TH1 *h) to add a histogram to the stack. The THStack does not own the objects in the list. Stacked histograms. By default, THStack::Draw draws the histograms stacked as shown in the left pad in the picture above. If the option ""nostack"" is used, the histograms are superimposed as if they were drawn one at a time using the ""same"" draw option . The right pad in this picture illustrates the THStack drawn with the ""nostack"" option.; hs->Draw(""nostack"");; Next is a simple example, for a more complex one see $ROOTSYS/tutorials/hist/hstack.C.; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; 3.16 TH2Poly; TH2Poly is a 2D Histogram class allowing to define polygonal bins of arbitrary shape.; Each bin in the TH2Poly histogram is a TH2PolyBin object. TH2PolyBin is a very simple class containing the vertices and contents of the polygonal bin as well as several related functions.; Bins are defined using one of the AddBin() methods. The bin definition should be done before filling.; The followin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:124169,simpl,simple,124169,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"n d P D F; //-----------------------------------------------; // angle theta and the weight to account for the acceptance effect; RooRealVar costheta(""costheta"", ""costheta"", -1.0, 1.0);; RooRealVar weight(""weight"", ""weight"", 0.0, 1000.0);; ; // initialise parameters to fit; RooRealVar c0(""c0"", ""0th-order coefficient"", c0gen, -1.0, 1.0);; RooRealVar c1(""c1"", ""1st-order coefficient"", c1gen, -1.0, 1.0);; c0.setError(0.01);; c1.setError(0.01);; // create simple second-order polynomial as probability density function; RooPolynomial pol(""pol"", ""pol"", costheta, {c0, c1}, 1);; ; double ngen = nstats;; if (acceptancemodel == 1); ngen *= 2.0 / (23.0 / 15.0);; else; ngen *= 2.0 / (16.0 / 15.0);; RooRealVar ntot(""ntot"", ""ntot"", ngen, 0.0, 2.0 * ngen);; RooExtendPdf extended(""extended"", ""extended pdf"", pol, ntot);; int npoisson = rnd->Poisson(nstats);; ; // G e n e r a t e d a t a s e t f o r p s e u d o e x p e r i m e n t i; //-------------------------------------------------------------------------------; RooDataSet data(""data"", ""data"", {costheta, weight}, WeightVar(""weight""));; // generate nstats events; for (std::size_t j = 0; j < npoisson; j++) {; bool finished = false;; // use simple accept/reject for generation; while (!finished) {; costheta = 2.0 * rnd->Rndm() - 1.0;; // efficiency for the specific value of cos(theta); double eff = 1.0;; if (acceptancemodel == 1); eff = 1.0 - 0.7 * costheta.getVal() * costheta.getVal();; else; eff = 0.3 + 0.7 * costheta.getVal() * costheta.getVal();; // use 1/eff as weight to account for acceptance; weight = 1.0 / eff;; // accept/reject; if (10.0 * rnd->Rndm() < eff * pol.getVal()); finished = true;; }; haccepted->Fill(costheta.getVal());; hweighted->Fill(costheta.getVal(), weight.getVal());; data.add({costheta, weight}, weight.getVal());; }; ; auto fillPulls = [&](std::size_t i) {; hc0pull[i]->Fill((c0.getVal() - c0gen) / c0.getError());; hc1pull[i]->Fill((c1.getVal() - c1gen) / c1.getError());; hntotpull[i]->Fill((ntot.getVal() - ngen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf611__weightedfits_8C.html:7231,simpl,simple,7231,doc/master/rf611__weightedfits_8C.html,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html,1,['simpl'],['simple']
Usability,"n event using the algorithm corresponding to the specified code. ;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ;  ; RooAbsReal const & getMean () const;  Get the mean parameter. ;  ; RooAbsReal const & getSigma () const;  Get the sigma parameter. ;  ; RooAbsReal const & getX () const;  Get the x variable. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual RooAbsGenContext * binnedGenContext (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGaussian.html:2373,simpl,simple,2373,doc/master/classRooGaussian.html,https://root.cern,https://root.cern/doc/master/classRooGaussian.html,1,['simpl'],['simple']
Usability,"n example of a very simple use of the genetic algorithm of TMVA ;  TMVAMinimalClassification.C Minimal self-contained example for setting up TMVA with binary classification ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionApplication.C This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  ► tree;  basic.C Read data from an ascii file and create a root file with an histogram and an ntuple ;  basic2.C Create can ntuple reading data from an ascii file ;  bill.C Benchmark comparing row-wise and column-wise storage performance ;  cernbuild.C Read data (CERN staff) from an ascii file and create a root file with a Tree ;  cernstaff.C Playing with a Tree containing variables of type character ;  circular.C Example of a circular Tree ;  clonesA_Event.CExample to write & read a Tree built with a complex class inheritance tree ;  clonesA_Event.cxx;  clonesA_Event.h;  copytree.C Copy a subset of a Tree to a new Tree ;  copytree2.C Copy a subset of a Tree to a new Tree, one branch in a separate file ;  copytree3.C Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries ;  drawsparse.C Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord ;  h1an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:160355,simpl,simple,160355,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,2,['simpl'],['simple']
Usability,"n file; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); # And the created histogram is automatically attached to the file; print(""Histogram '{}' is attached to: '{}'.\n"".format(histo_2.GetName(), histo_2.GetDirectory().GetName())); # Before exiting the context, objects can be written to the file; f.WriteObject(histo_2, ""my_histogram""); ; # When the TFile.Close method is called, the current directory is automatically; # set again to ROOT.gROOT. Objects that were attached to the file inside the; # context are automatically deleted and made 'None' when the file is closed.; print(""Status after the first TFile context manager:""); print("" Current directory: '{}'."".format(ROOT.gDirectory.GetName())); print("" Accessing 'histo_2' gives: '{}'.\n"".format(histo_2)); ; # Also reading data from a TFile can be done in a context manager. Information; # stored in the objects of the file can be queried and used inside the context.; # After the context, the objects are not usable anymore because the file is; # automatically closed. This means you should use this pattern as a quick way; # to get information or modify objects from a certain file, without needing to; # keep the histograms alive afterwards.; with TFile.Open(""pyroot005_file_1.root"", ""read"") as f:; # Retrieve histogram using the name given to f.WriteObject in the previous; # with statement; histo_2_fromfile = f[""my_histogram""]; print(""Retrieved '{}' histogram from file '{}'.\n"".format(histo_2_fromfile.GetName(), f.GetName())); ; # Cleanup the file created for this tutorial; os.remove(""pyroot005_file_1.root""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot005__tfile__context__manager_8py.html:2654,usab,usable,2654,doc/master/pyroot005__tfile__context__manager_8py.html,https://root.cern,https://root.cern/doc/master/pyroot005__tfile__context__manager_8py.html,1,['usab'],['usable']
Usability,"n how closely the output matched the desired output ; Definition at line 1286 of file MethodMLP.cxx. ◆ UpdatePriors(). void TMVA::MethodMLP::UpdatePriors ; (; ). private . zjh ; Definition at line 1454 of file MethodMLP.cxx. ◆ UpdateRegulators(). void TMVA::MethodMLP::UpdateRegulators ; (; ). private . zjh ; Definition at line 1468 of file MethodMLP.cxx. ◆ UpdateSynapses(). void TMVA::MethodMLP::UpdateSynapses ; (; ). private . update synapse error fields and adjust the weights (if in sequential mode) ; Definition at line 1412 of file MethodMLP.cxx. Member Data Documentation. ◆ fBatchSize. Int_t TMVA::MethodMLP::fBatchSize. private . batch size, only matters if in batch learning mode ; Definition at line 192 of file MethodMLP.h. ◆ fBPMode. EBPTrainingMode TMVA::MethodMLP::fBPMode. private . backprop learning mode (sequential or batch) ; Definition at line 190 of file MethodMLP.h. ◆ fBpModeS. TString TMVA::MethodMLP::fBpModeS. private . backprop learning mode option string (sequential or batch) ; Definition at line 191 of file MethodMLP.h. ◆ fCalculateErrors. bool TMVA::MethodMLP::fCalculateErrors. private . compute inverse hessian matrix at the end of the training ; Definition at line 165 of file MethodMLP.h. ◆ fDecayRate. Double_t TMVA::MethodMLP::fDecayRate. private . decay rate for above learning rate ; Definition at line 189 of file MethodMLP.h. ◆ fDeviationsFromTargets. std::vector<std::pair<Float_t,Float_t> >* TMVA::MethodMLP::fDeviationsFromTargets. private . deviation from the targets, event weight ; Definition at line 204 of file MethodMLP.h. ◆ fEpochMon. Bool_t TMVA::MethodMLP::fEpochMon. private . create and fill epoch-wise monitoring histograms (makes outputfile big!) ; Definition at line 194 of file MethodMLP.h. ◆ fGA_nsteps. Int_t TMVA::MethodMLP::fGA_nsteps. private . GA settings: number of steps. ; Definition at line 197 of file MethodMLP.h. ◆ fGA_preCalc. Int_t TMVA::MethodMLP::fGA_preCalc. private . GA settings: number of pre-calc steps. ; Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:50109,learn,learning,50109,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['learn'],['learning']
Usability,"n in the global frame. It can be retrieved with:; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; TGeoManager::GetCurrentDirectionconst Double_t * GetCurrentDirection() constDefinition TGeoManager.h:502; The direction can be initialized in a similar manner as the current point:; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; TGeoManager::SetCurrentDirectionvoid SetCurrentDirection(Double_t *dir)Definition TGeoManager.h:518. Initializing the State; Setting the initial point and direction is not enough for initializing tracking. The modeller needs to find out where the initial point is located in the geometrical hierarchy. Due to the containment based architecture of the model, this is the deepest positioned object containing the point. For illustrating this, imagine that we have a simple structure with a top volume A and another one Bpositioned inside. Since Ais a top volume, its associated node A_1 will define MARS and our simple hierarchy of nodes (positioned volumes) will be: /A_1/B_1. Suppose now that the initial point is contained by B_1. This implies by default that the point is also contained by A_1, since B_1 have to be fully contained by this. After searching the point location, the modeller will consider that the point is located inside B_1, which will be considered as the representative object (node) for the current state. This is stored as: TGeoNode *TGeoNavigator::fCurrentNode and can be asked from the manager class only after the ‘'Where am I?’` was completed:; TGeoNode *current = gGeoManager->GetCurrentNode();; TGeoManager::GetCurrentNodeTGeoNode * GetCurrentNode() constDefinition TGeoManager.h:499; In order to find the location of the current point inside the hierarchy of nodes, after setting this point it is mandatory to call the ‘‘Where am I?’` method:; gGeoManager->FindNode();; TGeoManager::FindNodeTGeoNode * FindNode(Bool_t safe_start=kTRUE)Returns deepest node containing current p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:70834,simpl,simple,70834,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"n is cancel safe, they could call:; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; To cancel a thread TThread* th call:; th->Kill();; To cancel by thread name:; TThread::Kill(name);; To cancel a thread by ID:; TThread::Kill(tid);; To cancel a thread and delete th when cancel finished:; th->Delete();; Deleting of the thread instance by the operator delete is dangerous. Use th->Delete() instead. C++ delete is safe only if thread is not running. Often during the canceling, some clean up actions must be taken. To define clean up functions use:; void UserCleanUp(void *arg) {; // here the user cleanup is done; ...; }; TThread::CleanUpPush(&UserCleanUp,arg);; // push user function into cleanup stack""last in, first out""; TThread::CleanUpPop(1); // pop user function out of stack and; // execute it, thread resumes after this call; TThread::CleanUpPop(0); // pop user function out of stack; // _without_ executing it; Note: CleanUpPush and CleanUpPop should be used as corresponding pairs like brackets; unlike pthreads cleanup stack (which is not implemented here), TThread does not force this usage.; 23.2.4.7 Finishing thread; When a thread returns from a user function the thread is finished. It also can be finished by TThread::Exit(). Then, in case of thread-detached mode, the thread vanishes completely. By default, on finishing TThread executes the most recent cleanup function (CleanUpPop(1) is called automatically once).; 23.3 Advanced TThread: Launching a Method in a Thread; Consider a class Myclass with a member function that shall be launched as a thread.; void* Myclass::Thread0((void* arg); To start Thread0 as a TThread, class Myclass may provide a method:; Int_t Myclass::Threadstart(){; if(!mTh){; mTh= new TThread(""memberfunction"",; (void(*)(void *))&Thread0,(void*) this);; mTh->Run();; return 0;; }; return 1;; }; Here mTh is a TThre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1113208,resume,resumes,1113208,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['resume'],['resumes']
Usability,"n issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooFunctorBinding.h>. Inheritance diagram for RooFunctorBinding:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooFunctorBinding() [1/3]. RooFunctorBinding::RooFunctorBinding ; (; ). default . ◆ RooFunctorBinding() [2/3]. RooFunctorBinding::RooFunctorBinding ; (; const char * ; name, . const char * ; title, . const ROOT::Math::IBaseFunctionMultiDim & ; ftor, . const RooArgList & ; v . ). Create a RooFit function that makes ftor usable in RooFit. ; Parameters. nameName of the object. ; titleTitle (e.g. for plotting) ; ftorFunctor instance to be evaluated. ; vRooFit variables to be passed to the function. . Definition at line 56 of file RooFunctorBinding.cxx. ◆ RooFunctorBinding() [3/3]. RooFunctorBinding::RooFunctorBinding ; (; const RooFunctorBinding & ; other, . const char * ; name = nullptr . ). Definition at line 72 of file RooFunctorBinding.cxx. ◆ ~RooFunctorBinding(). RooFunctorBinding::~RooFunctorBinding ; (; ). inlineoverride . Definition at line 37 of file RooFunctorBinding.h. Member Function Documentation. ◆ Class(). static TClass * RooFunctorBinding::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooFunctorBinding::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooFunctorBinding::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 51 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFunctorBinding.html:60808,usab,usable,60808,doc/master/classRooFunctorBinding.html,https://root.cern,https://root.cern/doc/master/classRooFunctorBinding.html,1,['usab'],['usable']
Usability,"n maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooAbsReal.; Definition at line 62 of file RooFFTConvPdf.h. ◆ pdfObservable(). RooAbsArg & RooFFTConvPdf::pdfObservable ; (; RooAbsArg & ; histObservable); const. overrideprotectedvirtual . Return p.d.f. ; observable (which can be a function) to substitute given p.d.f. observable. Substitutes x by xprime if xprime is set. ; Reimplemented from RooAbsCachedPdf.; Definition at line 847 of file RooFFTConvPdf.cxx. ◆ prepareFFTBinning(). void RooFFTConvPdf::prepareFFTBinning ; (; RooRealVar & ; convVar); const. private . Try to improve the binning and inform user if possible. ; With a 10% buffer fraction, 930 raw bins yield 1024 FFT bins, a sweet spot for the speed of FFTW. ; Definition at line 302 of file RooFFTConvPdf.cxx. ◆ printMetaArgs(). void RooFFTConvPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 947 of file RooFFTConvPdf.cxx. ◆ scanPdf(). std::vector< double > RooFFTConvPdf::scanPdf ; (; RooRealVar & ; obs, . RooAbsPdf & ; pdf, . const RooDataHist & ; hist, . const RooArgSet & ; slicePos, . Int_t & ; N, . Int_t & ; N2, . Int_t & ; zeroBin, . double ; shift . ); const. protected . Scan the values of 'pdf' in observable 'obs' using the bin values stored in 'hist' at slice position 'slicePos' N is filled with the number of bins defined in hist, N2 is filled with N plus the number of buffer bins The return value is an array of doubles of length N2 with the sampled values. ; The caller takes ownership of the array ; Definition at line 665 of file RooFFTConvPdf.cxx. ◆ setBufferFraction(). void RooFFTConvPdf::setBufferFraction ; (; double ; frac). Change the size of the buffer on either side of the observable range to frac times the size of the range of the convolutio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:93939,intuit,intuitively,93939,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['intuit'],['intuitively']
Usability,"n of a RooCacheManager<RooAbsCacheElement> that specializes in the storage of cache elements that contain RooAbsArg objects. ; Caches with RooAbsArg derived payload require special care as server redirects cache operation mode changes and constant term optimization calls may need to be forwarded to such cache payload. This cache manager takes care of all these operations by forwarding these calls to the RooAbsCacheElement interface functions, which have a sensible default implementation. ; Definition at line 29 of file RooObjCacheManager.h. Public Member Functions;  RooObjCacheManager (const RooObjCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooObjCacheManager (RooAbsArg *owner=nullptr, Int_t maxSize=2, bool clearCacheOnServerRedirect=true, bool allowOptimize=false);  Constructor of object cache manager for given owner. ;  ;  ~RooObjCacheManager () override;  Destructor. ;  ; void findConstantNodes (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  If clearOnRedirect is false, forward constant term optimization calls to cache elements. ;  ; void insertObjectHook (RooAbsCacheElement &) override;  Set owner link on all object inserted into cache. ;  ; TClass * IsA () const override;  ; void operModeHook () override;  Intercept changes to cache operation mode and forward to cache elements. ;  ; void optimizeCacheMode (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  Intercept calls to perform automatic optimization of cache mode operation. ;  ; void printCompactTreeHook (std::ostream &, const char *) override;  Add details on cache contents when printing in tree mode. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Intercept server redirect calls. ;  ; void setClearOnRedirect (bool flag);  ; void sterilize () override;  Clear the cache payload but retain slot mapping w.r.t to normalization and integration sets. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:1361,clear,clearOnRedirect,1361,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['clear'],['clearOnRedirect']
Usability,"n of h1 by h2.; 1253///; 1254/// `this = (c1*h1)*(c2*h2)`; 1255 ; 1256Bool_t TProfile::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1257{; 1258 Error(""Multiply"",""Multiplication of profile histograms not implemented"");; 1259 return kFALSE;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Project this profile into a 1-D histogram along X; 1264///; 1265/// The projection is always of the type TH1D.; 1266///; 1267/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1268/// to be equal to the errors of the profile.; 1269/// Option ""E"" is defined as the default one in the header file.; 1270/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1271/// - if option ""B"" is specified, the content of bin of the returned histogram; 1272/// will be equal to the GetBinEntries(bin) of the profile,; 1273/// otherwise (default) it will be equal to GetBinContent(bin); 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH1D using the 2-nd value as a weight.; 1280/// This makes sense only for profile filled with weights =1. If not, the error of the; 1281/// projected histogram obtained with this option will not be correct.; 1282 ; 1283TH1D *TProfile::ProjectionX(const char *name, Option_t *option) const; 1284{; 1285 ; 1286 TString opt = option;; 1287 opt.ToLower();; 1288 Int_t nx = fXaxis.GetNbins();; 1289 ; 1290 // Create the projection histogram; 1291 TString pname = name;; 1292 if (pname == ""_px"") {; 1293 pname = GetName();; 1294 pname.Append(""_px"");; 1295 }; 1296 TH1D *h1;; 1297 const TArrayD ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:46319,simpl,simply,46319,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['simpl'],['simply']
Usability,"n range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooProduct with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProduct(*this, newname); }. RooArgList components(); { RooArgList tmp(_compRSet) ; tmp.add(_compCSet) ; return tmp ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. ProdMap* groupProductTerms(const RooArgSet& ) const. » Last changed: Sat Jun 20 16:42:32 2015 » Last generated: 2015-06-20 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProduct.html:37959,intuit,intuitively,37959,root/html534/RooProduct.html,https://root.cern,https://root.cern/root/html534/RooProduct.html,1,['intuit'],['intuitively']
Usability,"n range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooProduct with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProduct(*this, newname); }. RooArgList components(); { RooArgList tmp(_compRSet) ; tmp.add(_compCSet) ; return tmp ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. ProdMap* groupProductTerms(const RooArgSet& ) const. » Last changed: Sat Jun 20 17:30:24 2015 » Last generated: 2015-06-20 17:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooProduct.html:39457,intuit,intuitively,39457,root/html604/RooProduct.html,https://root.cern,https://root.cern/root/html604/RooProduct.html,1,['intuit'],['intuitively']
Usability,"n range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooProduct with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProduct(*this, newname); }. RooArgList components(); { RooArgList tmp(_compRSet) ; tmp.add(_compCSet) ; return tmp ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. ProdMap* groupProductTerms(const RooArgSet& ) const. » Last changed: Tue Jun 30 14:35:02 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProduct.html:39457,intuit,intuitively,39457,root/html602/RooProduct.html,https://root.cern,https://root.cern/root/html602/RooProduct.html,1,['intuit'],['intuitively']
Usability,"n request. TList * GetListOfPackages(); Get from the master the list of names of the packages available. TList * GetListOfEnabledPackages(); Get from the master the list of names of the packages enabled. void PrintProgress(Long64_t total, Long64_t processed, Float_t procTime = -1., Long64_t bytesread = -1); Print a progress bar on stderr. Used in batch mode. void Progress(Long64_t total, Long64_t processed); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Get query progress information. Connect a slot to this signal; to track progress. void Feedback(TList* objs); Get list of feedback objects. Connect a slot to this signal; to monitor the feedback object. void CloseProgressDialog(); Close progress dialog. void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset progress dialog. void StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total); Send startup message. void DataSetStatus(const char* msg, Bool_t status, Int_t done, Int_t total); Send dataset preparation status. void SendDataSetStatus(const char* msg, UInt_t n, UInt_t tot, Bool_t st); Send or notify data set status. void QueryResultReady(const char* ref); Notify availability of a query result. void ValidateDSet(TDSet* dset); Validate a TDSet. void AddInputData(TObject* obj, Bool_t push = kFALSE); Add data objects that might be needed during the processing of; the selector (see Process()). This object can be very large, so they; are distributed in an optimized way using a dedicated file.; If push is TRUE the input data are sent over even if no a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:70479,feedback,feedback,70479,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,['feedback'],['feedback']
Usability,"n sessions/queries hierarchy list tree; TGListTreeItem*fSessionItembase (main) session list tree item; TGPopupMenu*fSessionMenusession menu entry; TList*fSessionslist of sessions; time_tfStart; TGStatusBar*fStatusBarbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionViewer(const char* title = ""ROOT Session Viewer"", UInt_t w = 550, UInt_t h = 320); Main Session viewer constructor. TSessionViewer(const char* title, Int_t x, Int_t y, UInt_t w, UInt_t h); Main Session viewer constructor. void ReadConfiguration(const char* filename = 0); Read configuration file and populate list of sessions; list of queries and list of packages.; Read and set also global options as feedback histos. void UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionViewer.html:25780,feedback,feedback,25780,root/html528/TSessionViewer.html,https://root.cern,https://root.cern/root/html528/TSessionViewer.html,4,['feedback'],['feedback']
Usability,"n that extends from 0 to maxLength. *length is filled with the; x-coordinate of the right edge of the last character that did fit. source -- Characters to be displayed. Need not be '\0' terminated.; numChars -- Maximum number of characters to consider from source string.; maxLength -- If > 0, maxLength specifies the longest permissible line; length; don't consider any character that would cross this; x-position. If <= 0, then line length is unbounded and the; flags argument is ignored.; flags -- Various flag bits OR-ed together:; TEXT_PARTIAL_OK means include the last char which only; partially fit on this line.; TEXT_WHOLE_WORDS means stop on a word boundary, if possible.; TEXT_AT_LEAST_ONE means return at least one character even; if no characters fit.; *length -- Filled with x-location just after the terminating character. Int_t TextWidth(const char* string, Int_t numChars = -1) const; A wrapper function for the more complicated interface of MeasureChars.; Computes how much space the given simple string needs. The return value is the width (in pixels) of the given string. string -- String whose width will be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen(). Int_t XTextWidth(const char* string, Int_t numChars = -1) const; Return text widht in pixels. void UnderlineChars(Drawable_t dst, GContext_t gc, const char* string, Int_t x, Int_t y, Int_t firstChar, Int_t lastChar) const; This procedure draws an underline for a given range of characters in a; given string. It doesn't draw the characters (which are assumed to have; been displayed previously); it just draws the underline. This procedure; would mainly be used to quickly underline a few characters without having; to construct an underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which to draw.; gc -- Graphics context for actually drawing line.; string -- String containing charact",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGFont.html:10137,simpl,simple,10137,root/html528/TGFont.html,https://root.cern,https://root.cern/root/html528/TGFont.html,6,['simpl'],['simple']
Usability,"n the Draw() method means:. The axis should be drawn (option A),; The graph should be drawn as a simple line (option L).; By default a graph is drawn in the current pad in the current coordinate system. To define a suitable coordinate system and draw the axis the option A must be specified. TGraphPainter offers many options to paint the various kind of graphs.; It is separated from the graph classes so that one can have graphs without the graphics overhead, for example in a batch program.; When a displayed graph is modified, there is no need to call Draw() again; the image will be refreshed the next time the pad will be updated. A pad is updated after one of these three actions:. a carriage return on the ROOT command line,; a click inside the pad,; a call to TPad::Update. Graphs' plotting options; Graphs can be drawn with the following options:. Option Description . ""A"" Produce a new plot with Axis around the graph . ""I"" Combine with option 'A' it draws invisible axis . ""L"" A simple polyline is drawn . ""F"" A fill area is drawn ('CF' draw a smoothed fill area) . ""C"" A smooth Curve is drawn . ""*"" A Star is plotted at each point . ""P"" The current marker is plotted at each point . ""B"" A Bar chart is drawn . ""1"" When a graph is drawn as a bar chart, this option makes the bars start from the bottom of the pad. By default they start at 0. . ""X+"" The X-axis is drawn on the top side of the plot. . ""Y+"" The Y-axis is drawn on the right side of the plot. . ""PFC"" Palette Fill Color: graph's fill color is taken in the current palette. . ""PLC"" Palette Line Color: graph's line color is taken in the current palette. . ""PMC"" Palette Marker Color: graph's marker color is taken in the current palette. . ""RX"" Reverse the X axis. . ""RY"" Reverse the Y axis. . Drawing options can be combined. In the following example the graph is drawn as a smooth curve (option ""C"") with markers (option ""P"") and with axes (option ""A"").; {; auto c1 = new TCanvas(""c1"",""c1"",200,10,600,400);; ; c1->SetFillColo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPainter.html:2032,simpl,simple,2032,doc/master/classTGraphPainter.html,https://root.cern,https://root.cern/doc/master/classTGraphPainter.html,1,['simpl'],['simple']
Usability,"n the callback.; 14352 *; 14353 * TODO: What would be the best reaction here?; 14354 * (Note: The reaction may change, if there is a better; 14355 * idea.); 14356 */; 14357 ; 14358 /* For the moment, use option c: We look for a proper file,; 14359 * but since a file request is not always a script resource,; 14360 * the authorization check might be different. */; 14361 interpret_uri(conn,; 14362 path,; 14363 sizeof(path),; 14364 &file.stat,; 14365 &is_found,; 14366 &is_script_resource,; 14367 &is_websocket_request,; 14368 &is_put_or_delete_request,; 14369 &is_template_text_file);; 14370 callback_handler = NULL;; 14371 ; 14372 /* Here we are at a dead end:; 14373 * According to URI matching, a callback should be; 14374 * responsible for handling the request,; 14375 * we called it, but the callback declared itself; 14376 * not responsible.; 14377 * We use a goto here, to get out of this dead end,; 14378 * and continue with the default handling.; 14379 * A goto here is simpler and better to understand; 14380 * than some curious loop. */; 14381 goto no_callback_resource;; 14382 }; 14383 } else {; 14384#if defined(USE_WEBSOCKET); 14385 handle_websocket_request(conn,; 14386 path,; 14387 is_callback_resource,; 14388 subprotocols,; 14389 ws_connect_handler,; 14390 ws_ready_handler,; 14391 ws_data_handler,; 14392 ws_close_handler,; 14393 callback_data);; 14394#endif; 14395 }; 14396 return;; 14397 }; 14398 ; 14399 /* 8. handle websocket requests */; 14400#if defined(USE_WEBSOCKET); 14401 if (is_websocket_request) {; 14402 HTTP1_only;; 14403 if (is_script_resource) {; 14404 ; 14405 if (is_in_script_path(conn, path)) {; 14406 /* Websocket Lua script */; 14407 handle_websocket_request(conn,; 14408 path,; 14409 0 /* Lua Script */,; 14410 NULL,; 14411 NULL,; 14412 NULL,; 14413 NULL,; 14414 NULL,; 14415 conn->phys_ctx->user_data);; 14416 } else {; 14417 /* Script was in an illegal path */; 14418 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14419 }; 14420 } else {; 14421 mg_sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:423419,simpl,simpler,423419,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['simpl'],['simpler']
Usability,"n the callback.; 14353 *; 14354 * TODO: What would be the best reaction here?; 14355 * (Note: The reaction may change, if there is a better; 14356 * idea.); 14357 */; 14358 ; 14359 /* For the moment, use option c: We look for a proper file,; 14360 * but since a file request is not always a script resource,; 14361 * the authorization check might be different. */; 14362 interpret_uri(conn,; 14363 path,; 14364 sizeof(path),; 14365 &file.stat,; 14366 &is_found,; 14367 &is_script_resource,; 14368 &is_websocket_request,; 14369 &is_put_or_delete_request,; 14370 &is_template_text_file);; 14371 callback_handler = NULL;; 14372 ; 14373 /* Here we are at a dead end:; 14374 * According to URI matching, a callback should be; 14375 * responsible for handling the request,; 14376 * we called it, but the callback declared itself; 14377 * not responsible.; 14378 * We use a goto here, to get out of this dead end,; 14379 * and continue with the default handling.; 14380 * A goto here is simpler and better to understand; 14381 * than some curious loop. */; 14382 goto no_callback_resource;; 14383 }; 14384 } else {; 14385#if defined(USE_WEBSOCKET); 14386 handle_websocket_request(conn,; 14387 path,; 14388 is_callback_resource,; 14389 subprotocols,; 14390 ws_connect_handler,; 14391 ws_ready_handler,; 14392 ws_data_handler,; 14393 ws_close_handler,; 14394 callback_data);; 14395#endif; 14396 }; 14397 return;; 14398 }; 14399 ; 14400 /* 8. handle websocket requests */; 14401#if defined(USE_WEBSOCKET); 14402 if (is_websocket_request) {; 14403 HTTP1_only;; 14404 if (is_script_resource) {; 14405 ; 14406 if (is_in_script_path(conn, path)) {; 14407 /* Websocket Lua script */; 14408 handle_websocket_request(conn,; 14409 path,; 14410 0 /* Lua Script */,; 14411 NULL,; 14412 NULL,; 14413 NULL,; 14414 NULL,; 14415 NULL,; 14416 conn->phys_ctx->user_data);; 14417 } else {; 14418 /* Script was in an illegal path */; 14419 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14420 }; 14421 } else {; 14422 mg_sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:423452,simpl,simpler,423452,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['simpl'],['simpler']
Usability,"n the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials Using a Macro to Read a TTree. Why using a macro?; As real analyses don't fit into simple TTree::Draw() invocations, and as it is quite cumbersome to type the same lines again and again in the Root prompt, simply create macros for commonly used code. A macro is a file that is interpreted by ROOT.; Creating and Editing the Macro; Create a macro (e.g. AnalyzeTree.C) using your favorite text editor, e.g. with vi, emacs, wordpad, Eclipse, Visual Studio,... The macro should start with the proper #include statements and should contain the function declaration with the same name than the macro itself. As we know we're going to use TFile and TTree (at least), we can already include their headers TFile.h and TTree.h. Then come the function implementation.; Function Implementation; Lets start with something simple: calculate the sum of all event sizes. For this we need a new variable of type int. Create (declare) it at the beginning of the function, and don't forget to initialize it to 0. At the end, the code in AnalyzeTree.C should look like this:; #include ""TFile.h""; #include ""TTree.h"". void AnalyzeTree(); {; // Variables used to store the data; Int_t totalSize = 0; // Sum of data size (in bytes) of all events. ... Opening the File and Getting the Tree; The first thing to do is to open the file containing the tree, by calling TFile::Open(), passing the file name, and then, if the file is open (i.e. if the pointer to it is not NULL), create a TTreeReader using the tree name and the file. At the end, the code in AnalyzeTree.C should look like this:; ... // open the file; TFile *f = TFile::Open(""http://root.cern/files/introtutorials/eventdata.root"");; if (f == 0) {; // if we cannot open the file, print an error message and return immediatly; printf(""Error: cannot open http://root.cern/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:2724,simpl,simple,2724,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,1,['simpl'],['simple']
Usability,"n this canvas as a C++ macro file.Definition TCanvas.cxx:1822; TCanvas::HandleInputvirtual void HandleInput(EEventType button, Int_t x, Int_t y)Handle Input Events.Definition TCanvas.cxx:1234; TCanvas::UpdateAsyncvoid UpdateAsync() overrideAsynchronous pad update.Definition TCanvas.cxx:2545; TCanvas::GetSelectedTObject * GetSelected() const overrideDefinition TCanvas.h:141; TCanvas::GetEventXInt_t GetEventX() const overrideDefinition TCanvas.h:136; TCanvas::SetCanvasSizevoid SetCanvasSize(UInt_t ww, UInt_t wh) overrideSet Width and Height of canvas to ww and wh respectively.Definition TCanvas.cxx:1975; TCanvas::GetSelectedPadTVirtualPad * GetSelectedPad() const overrideDefinition TCanvas.h:146; TCanvas::SetCursorvoid SetCursor(ECursor cursor) overrideSet cursor.Definition TCanvas.cxx:1989; TCanvas::GetCanvasIDInt_t GetCanvasID() const overrideDefinition TCanvas.h:157; TCanvas::GetWindowWidthUInt_t GetWindowWidth() constDefinition TCanvas.h:161; TCanvas::FeedbackModevoid FeedbackMode(Bool_t set)Turn rubberband feedback mode on or off.Definition TCanvas.cxx:1128; TCanvas::SetClickSelectedvoid SetClickSelected(TObject *obj)Definition TCanvas.h:209; TCanvas::GetPadSaveTVirtualPad * GetPadSave() const overrideDefinition TCanvas.h:139; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TCanvas::Clearedvirtual void Cleared(TVirtualPad *pad)Emit pad Cleared signal.Definition TCanvas.cxx:770; TCanvas::GetWwUInt_t GetWw() const overrideDefinition TCanvas.h:163; TCanvas::OpaqueMovingBool_t OpaqueMoving() const overrideDefinition TCanvas.h:180; TCanvas::GetWhUInt_t GetWh() const overrideDefinition TCanvas.h:164; TCanvas::Classstatic TClass * Class(); TCanvas::SetSelectedvoid SetSelected(TObject *obj) overrideSet selected canvas.Definition TCanvas.cxx:2146; TCanvas::GetEventInt_t GetEvent() const overrideDefinition TCanvas.h:135; TCanvas::IsWebBool_t IsWeb() const overrideIs web canvas.Definition TCanvas.cxx:1496; TCanvas::SetBatchvoid Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:272886,feedback,feedback,272886,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['feedback'],['feedback']
Usability,"n this list one can still access the list to search for; 466/// other not yet deleted objects).; 467 ; 468void TList::Delete(Option_t *option); 469{; 470 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 471 R__COLLECTION_WRITE_GUARD();; 472 ; 473 Bool_t slow = option ? (!strcmp(option, ""slow"") ? kTRUE : kFALSE) : kFALSE;; 474 ; 475 TList removeDirectory; // need to deregister these from their directory; 476 ; 477 if (slow) {; 478 ; 479 // In some case, for example TParallelCoord, a list (the pad's list of; 480 // primitives) will contain both the container and the containees; 481 // (the TParallelCoorVar) but if the Clear is being called from; 482 // the destructor of the container of this list, one of the first; 483 // thing done will be the remove the container (the pad) for the; 484 // list (of Primitives of the canvas) that was connecting it; 485 // (indirectly) to the list of cleanups.; 486 ; 487 // To preserve this connection (without introducing one when there was none),; 488 // we re-use fCache to inform RecursiveRemove of the node currently; 489 // being cleared/deleted.; 490 while (fFirst) {; 491 auto tlk = fFirst;; 492 fFirst = fFirst->fNext;; 493 fSize--;; 494 ; 495 // Make node available to RecursiveRemove; 496 tlk->fNext.reset();; 497 tlk->fPrev.reset();; 498 fCache = tlk;; 499 ; 500 // delete only heap objects; 501 auto obj = tlk->GetObject();; 502 if (obj && ROOT::Detail::HasBeenDeleted(obj)); 503 Error(""Delete"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 504 obj, GetName());; 505 else if (obj && obj->IsOnHeap()); 506 TCollection::GarbageCollect(obj);; 507 else if (obj && obj->IsA()->GetDirectoryAutoAdd()); 508 removeDirectory.Add(obj);; 509 ; 510 // delete tlk;; 511 }; 512 ; 513 fFirst.reset();; 514 fLast.reset();; 515 fCache.reset();; 516 fSize = 0;; 517 ; 518 } else {; 519 ; 520 auto first = fFirst; //pointer to first entry in linked list; 521 fFirst.reset();; 522 fLast.reset();; 523 fCache.reset();; 524 fSize = 0;; 52",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:15340,clear,cleared,15340,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['clear'],['cleared']
Usability,"n to TProof::fLogFileW. ;  ; void SetInitTime () override;  Set init time. ;  ; void SetMerging (Bool_t on=kTRUE) override;  Switch on/off merge timer. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:4539,feedback,feedback,4539,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,1,['feedback'],['feedback']
Usability,"n underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which to draw.; gc -- Graphics context for actually drawing line.; string -- String containing characters to be underlined or overstruck.; x, y -- Coordinates at which first character of string is drawn.; firstChar -- Index of first character.; lastChar -- Index of one after the last character. TGTextLayout * ComputeTextLayout(const char* string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t* width, UInt_t* height) const; Computes the amount of screen space needed to display a multi-line,; justified string of text. Records all the measurements that were done; to determine to size and positioning of the individual lines of text;; this information can be used by the TGTextLayout::DrawText() procedure; to display the text quickly (without remeasuring it). This procedure is useful for simple widgets that want to display; single-font, multi-line text and want TGFont to handle the details. The return value is a TGTextLayout token that holds the measurement; information for the given string. The token is only valid for the given; string. If the string is freed, the token is no longer valid and must; also be deleted. The dimensions of the screen area needed to display the text are stored; in *width and *height. string -- String whose dimensions are to be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen().; wrapLength -- Longest permissible line length, in pixels. <= 0 means no; automatic wrapping: just let lines get as long as needed.; justify -- How to justify lines.; flags -- Flag bits OR-ed together. kTextIgnoreTabs means that tab; characters should not be expanded. kTextIgnoreNewlines; means that newline characters should not cause a line break.; width -- Filled with width of string.; height -- Filled with height of string. LayoutChunk_t * NewChunk(TGTextLayout* l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGFont.html:11842,simpl,simple,11842,root/html528/TGFont.html,https://root.cern,https://root.cern/root/html528/TGFont.html,6,['simpl'],['simple']
Usability,"n versions with bug fixes. We release about two production versions per year. The old version is the previous production version that people might need for some time before switching to the new version.; Release candidate; A Release Candidate is a preview of the next production release. It allows users to make their code ready for the new production release, and to provide early feedback.; Development release; Use this to get access to the latest and greatest, but as a side effect there might be some instabilities. However, by trying out the development version you can help us converge much more quickly to a stable version that can then become the new production version.; Nightlies; You can download nightly snapshots of ROOT. That's useful to check whether a bug fix actually fixes an issue you reported, or to see the newest feature you heard about. It helps us tremendously to get feedback from you on nightlies: please try them out and report back to us!; Using binaries; After unpacking / installing the binary, and before using ROOT you should use a special script distributed with ROOT:; source <pathname>/root/bin/thisroot.sh (there are versions for [t]csh and fish, too.); where <pathname> is the location where you unpacked the ROOT distribution.; Typically add these lines to your .profile or .login files. Docker (Experimental); We also provide ROOT in Docker containers, for more information see Docker Hub.; The following recent versions are available for download:. Latest ROOT Releases. ; Pro ; Release 6.20/04 - 2020-04-01 ; . Old ; Release 6.18/04 - 2019-09-11 ; ; ; . Version 6 ; ; Release 6.20/06 - 2020-06-10. Release 6.20/04 - 2020-04-01. Release 6.20/02 - 2020-03-15. Release 6.20/00 - 2020-02-26. Release 6.19/02 - 2020-01-10. Release 6.18/04 - 2019-09-11. Release 6.18/02 - 2019-08-23. . . Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publicati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/downloading-root.html:3218,feedback,feedback,3218,d/downloading-root.html,https://root.cern,https://root.cern/d/downloading-root.html,1,['feedback'],['feedback']
Usability,"n'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static bool getFloorGlobal ();  ; static void setFloorGlobal (bool flag);  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:59802,clear,clearEvalErrorLog,59802,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"n'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static bool getFloorGlobal ();  ; static void setFloorGlobal (bool flag);  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumPdf.html:58572,clear,clearEvalErrorLog,58572,doc/master/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/master/classRooRealSumPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"n't the covariance; 37# matrix. Normalising the covariance matrix is a good idea if your; 38# variables have different orders of magnitude.; 39principal = TPrincipal(n, ""ND""); 40 ; 41# Use a pseudo-random number generator; 42randomNum = gRandom; 43 ; 44# Make the m data-points; 45# Make a variable to hold our data; 46# Allocate memory for the data point; 47data = vector('double')(); 48for i in range(m):; 49 # First we create the un-correlated, random variables, according; 50 # to one of three distributions; 51 for j in range(n - c):; 52 if j % 3 == 0:; 53 data.push_back(randomNum.Gaus(5, 1)); 54 elif j % 3 == 1:; 55 data.push_back(randomNum.Poisson(8)); 56 else:; 57 data.push_back(randomNum.Exp(2)); 58 ; 59 # Then we create the correlated variables; 60 for j in range(c):; 61 data.push_back(0); 62 for k in range(n - c - j):; 63 data[n - c + j] += data[k]; 64 ; 65 # Finally we're ready to add this datapoint to the PCA; 66 principal.AddRow(data.data()); 67 data.clear(); 68 ; 69# Do the actual analysis; 70principal.MakePrincipals(); 71 ; 72# Print out the result on; 73principal.Print(); 74 ; 75# Test the PCA; 76principal.Test(); 77 ; 78# Make some histograms of the original, principal, residue, etc data; 79principal.MakeHistograms(); 80 ; 81# Make two functions to map between feature and pattern space; 82# Start a browser, so that we may browse the histograms generated; 83# above; 84principal.MakeCode(); 85b = TBrowser(""principalBrowser"", principal); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/principal_8py_source.html:2177,clear,clear,2177,doc/master/principal_8py_source.html,https://root.cern,https://root.cern/doc/master/principal_8py_source.html,1,['clear'],['clear']
Usability,"n() [4/4]. const_iterator RooAbsCollection::begin ; (; ); const. inline . Definition at line 276 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCollection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 455 of file RooAbsCollection.h. ◆ clear(). void RooAbsCollection::clear ; (; ). inline . Clear contents. If the collection is owning, it will also delete the contents. ; Definition at line 305 of file RooAbsCollection.h. ◆ clearStructureTags(). void RooAbsCollection::clearStructureTags ; (; ). inlineprotected . Definition at line 415 of file RooAbsCollection.h. ◆ clone(). virtual TObject * RooAbsCollection::clone ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ Clone(). TObject * RooAbsCollection::Clone ; (; const char * ; newname = nullptr); const. inlineoverridevirtual . Make a clone of an object using the Streamer facility. ; If the object derives from TNamed, this function is called by TNamed::Clone. TNamed::Clone uses the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the current ROOT directory. ; Reimplemented from TObject.; Definition at line 76 of file RooAbsCollection.h. ◆ contains(). bool RooAbsCollection::contains ; (; const RooAbsArg & ; var); const. inlin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:36905,clear,clearStructureTags,36905,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['clear'],['clearStructureTags']
Usability,"n(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeDataStore.html:17316,clear,cleared,17316,root/html532/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html,1,['clear'],['cleared']
Usability,"n(). bool RooRealSumFunc::isBinnedDistribution ; (; const RooArgSet & ; ); const. overridevirtual . Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ; Reimplemented from RooAbsReal.; Definition at line 148 of file RooRealSumFunc.cxx. ◆ plotSamplingHint(). std::list< double > * RooRealSumFunc::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ; Parameters. [in]obsObservable to retrieve sampling hint for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented from RooAbsReal.; Definition at line 154 of file RooRealSumFunc.cxx. ◆ printMetaArgs(). void RooRealSumFunc::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooRealSumFunc to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 168 of file RooRealSumFunc.cxx. ◆ setCacheAndTrackHints(). void RooRealSumFunc::setCacheAndTrackHints ; (; RooArgSet & ; trackNodes). overridevirtual . Reimplemented from RooAbsArg.; Definition at line 160 of file RooRealSumFunc.cxx. ◆ setFloor(). void RooRealSumFunc::setFloor ; (; bool ; flag). inline . Definition at line 53 of file RooRealSumFunc.h. ◆ setFloorGlobal(). static void RooRealSumFunc::setFloorGlobal ; (; bool ; flag). inlinestatic . Definition at line 55 of file RooRealSumFunc.h. ◆ Streamer(). void RooRealSumFunc::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooRealSumFunc::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 78 of file RooRealSumFunc.h. ◆ translate(). void RooRealSumFunc::translate ; (; RooFit::Detai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:68204,intuit,intuitively,68204,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,2,['intuit'],['intuitively']
Usability,"n(pvalue);; 25.8.10 Progress Bars; A progress bar is a widget that shows that an operation is in progress and how much time is left. It is a long rectangular bar, initially empty, that fills with a color as a process is being performed. The filled-in area indicates the percentage of the process that has been completed. You should use this widget for waits exceeding one minute. For a very time consuming operation it is better to break the operation into subtasks and provide a progress bar for each of them. A progress bar may be oriented horizontally or vertically. The horizontally oriented progress bar fills with a color from left to right; the vertically oriented - from bottom to top. A percent complete message provides an indication of the completed part of the process. It is a good practice to include some descriptive text of the process to keep users informed and entertained while they are waiting for process completion.; The picture below shows the progress bars you can create using the classes TGProgressBar, TGHProgressBar, and TGHProgressBar.; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg3->SetFillType(TGProgressBar::kBlockFill);. vframe->AddFrame(fHProg1,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg2,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg3,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->Resize(200, 200);; 25.8.11 Static Widgets; The classes TGLabel and TGIcon show some information - text or graphics. The ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1208619,progress bar,progress bars,1208619,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['progress bar'],['progress bars']
Usability,"n(tree);\n"",scriptfunc.Data());; 1961 fprintf(hf,""\n"");; 1962 fprintf(hf,""}\n"");; 1963 fprintf(hf,""\n"");; 1964 ; 1965 // generate code for class member function Process; 1966 fprintf(hf,""inline bool %s::Process(Long64_t entry)\n"",classname.Data());; 1967 fprintf(hf,""{\n"");; 1968 ; 1969 fprintf(hf,"" // The Process() function is called for each entry in the tree (or possibly\n""; 1970 "" // keyed object in the case of PROOF) to be processed. The entry argument\n""; 1971 "" // specifies which entry in the currently loaded tree is to be processed.\n""; 1972 "" // It can be passed to either TTree::GetEntry() or TBranch::GetEntry()\n""; 1973 "" // to read either all or the required parts of the data. When processing\n""; 1974 "" // keyed objects with PROOF, the object is already loaded and is available\n""; 1975 "" // via the fObject pointer.\n""; 1976 "" //\n""; 1977 "" // This function should contain the \""body\"" of the analysis. It can contain\n""; 1978 "" // simple or elaborate selection criteria, run algorithms on the data\n""; 1979 "" // of the event and typically fill histograms.\n\n"");; 1980 fprintf(hf,"" // WARNING when a selector is used with a TChain, you must use\n"");; 1981 fprintf(hf,"" // the pointer to the current TTree to call GetEntry(entry).\n"");; 1982 fprintf(hf,"" // The entry is always the local entry number in the current tree.\n"");; 1983 fprintf(hf,"" // Assuming that fChain is the pointer to the TChain being processed,\n"");; 1984 fprintf(hf,"" // use fChain->GetTree()->GetEntry(entry).\n"");; 1985 fprintf(hf,""\n"");; 1986 fprintf(hf,""\n"");; 1987 fprintf(hf,"" fDirector.SetReadEntry(entry);\n"");; 1988 if (fOptions & kNoHist) {; 1989 if (cutfilename) {; 1990 fprintf(hf,"" if (%s()) %s();\n"",cutscriptfunc.Data(),scriptfunc.Data());; 1991 } else {; 1992 fprintf(hf,"" %s();\n"",scriptfunc.Data());; 1993 }; 1994 } else {; 1995 if (cutfilename) {; 1996 fprintf(hf,"" if (%s()) htemp->Fill(%s());\n"",cutscriptfunc.Data(),scriptfunc.Data());; 1997 } else {; 1998 fprintf(hf,"" htemp->Fill(%s(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:75521,simpl,simple,75521,doc/master/TTreeProxyGenerator_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html,1,['simpl'],['simple']
Usability,"n); Set the version string - returns kFALSE if the format is incorrect. const char * GetVersion() const; Get the version string. Bool_t TestVersion(Int_t version) const; Check if given version number is defined in this rule. Bool_t SetChecksum(const TString& checksum); Set the checksum string - returns kFALSE if the format is incorrect. Bool_t TestChecksum(UInt_t checksum) const; Check if given checksum is defined in this rule. void SetSourceClass(const TString& classname); Set the source class of this rule (i.e. the onfile class). const char * GetSourceClass() const; Get the source class of this rule (i.e. the onfile class). void SetTargetClass(const TString& classname); Set the target class of this rule (i.e. the in memory class). const char * GetTargetClass() const; Get the targte class of this rule (i.e. the in memory class). void SetTarget(const TString& target); Set the target member of this rule (i.e. the in memory data member). const char * GetTargetString() const; Get the target data members of this rule as a simple string (i.e. the in memory data member). const TObjArray* GetTarget() const; Get the target data members of this rule (i.e. the in memory data member). void SetSource(const TString& source); Set the list of source members. This should be in the form of a declaration:; Int_t fOldMember; TNamed fName;. const TObjArray* GetSource() const; Get the list of source members as a TObjArray of TNamed object,; with the name being the member name and the title being its type. void SetInclude(const TString& include); Set the comma separated list of header files to include to be able; to compile this rule. const TObjArray* GetInclude() const; Return the list of header files to include to be able to; compile this rule as a TObjArray of TObjString. void SetEmbed(Bool_t embed); Set whether this rule should be save in the ROOT file (if true). Bool_t GetEmbed() const; Return true if this rule should be saved in the ROOT File. Bool_t IsValid() const; Return kTRUE i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__TSchemaRule.html:9871,simpl,simple,9871,root/html528/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html528/ROOT__TSchemaRule.html,4,['simpl'],['simple']
Usability,"n, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, const RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:76137,clear,clearEvalError,76137,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['clear'],['clearEvalError']
Usability,"n. ; . Function Members (Methods); public:. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); virtual~RooObjCacheManager(); Int_tRooCacheManager<RooAbsCacheElement>::cacheSize() const; static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tRooCacheManager<RooAbsCacheElement>::lastIndex() const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet1ByIndex(Int_t index) const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet2ByIndex(Int_t index) const; RooObjCacheManager&operator=(const RooObjCacheManager&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooCacheManager<RooAbsCacheElement>::reset(); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp, char* parent); voidRooCacheManager<RooAbsCacheElement>::sterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Bool_t_clearOnRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooObjCacheManager.html:1058,clear,clearCacheOnServerRedirect,1058,root/html526/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html526/RooObjCacheManager.html,1,['clear'],['clearCacheOnServerRedirect']
Usability,"n. It is advisable however to define these properties just after the first creation of a volume namespace, since in case of volume families any new member created by the modeler inherits these properties.; In order to provide navigation features, volumes have to be able to find the proper container of any point defined in the local reference frame. This can be the volume itself, one of its positioned daughter volumes or none if the point is actually outside. On the other hand, volumes have to provide also other navigation methods such as finding the distances to its shape boundaries or which daughter will be crossed first. The implementation of these features is done at shape level, but the local mother-daughters management is handled by volumes that builds additional optimisation structures upon geometry closure. In order to have navigation features properly working one has to follow the general rules for building a valid geometry (see TGeoManager class).; Now let's make a simple volume representing a copper wire. We suppose that a medium is already created (see TGeoMedium class on how to create media). We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm and a half-length dZ=1cm :; TGeoTube *tube = new TGeoTube(""wire_tube"", 0, 0.01, 1);; TGeoTubeDefinition TGeoTube.h:17; One may omit the name for the shape if no retrieving by name is further needed during geometry building. The same shape can be shared by different volumes having different names and materials. Now let's make the volume for our wire. The prototype for volumes constructor looks like :; TGeoVolume::TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med); Since TGeoTube derives from the base shape class, we can provide it to the volume constructor :; TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::TGeoVolumeTGeoVolume()dummy constructorDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:2757,simpl,simple,2757,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['simpl'],['simple']
Usability,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:125097,simpl,simple,125097,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['simpl'],['simple']
Usability,"n.; 3337 ; 3338 cl = GetIdMap()->Find(typeinfo.name());; 3339 ; 3340 if (cl) {; 3341 if (cl->IsLoaded()) return cl;; 3342 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3343 load = kTRUE;; 3344 } else {; 3345 // Note we might need support for typedefs and simple types!; 3346 ; 3347 // TDataType *objType = GetType(name, load);; 3348 //if (objType) {; 3349 // const char *typdfName = objType->GetTypeName();; 3350 // if (typdfName && strcmp(typdfName, name)) {; 3351 // cl = GetClass(typdfName, load);; 3352 // return cl;; 3353 // }; 3354 // }; 3355 }; 3356 ; 3357 if (!load) return nullptr;; 3358 ; 3359 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3360 if (dict) {; 3361 cl = (dict)();; 3362 if (cl) cl->PostLoadCheck();; 3363 return cl;; 3364 }; 3365 if (cl) return cl;; 3366 ; 3367 TIter next(gROOT->GetListOfClassGenerators());; 3368 TClassGenerator *gen;; 3369 while( (gen = (TClassGenerator*) next()) ) {; 3370 cl = gen->GetClass(typeinfo,load);; 3371 if (cl) {; 3372 cl->PostLoadCheck();; 3373 return cl;; 3374 }; 3375 }; 3376 ; 3377 // try AutoLoading the typeinfo; 3378 int autoload_old = gCling->SetClassAutoLoading(1);; 3379 if (!autoload_old) {; 3380 // Re-disable, we just meant to test; 3381 gCling->SetClassAutoLoading(0);; 3382 }; 3383 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3384 // Disable autoload to avoid potential infinite recursion; 3385 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3386 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3387 if (cl) {; 3388 return cl;; 3389 }; 3390 }; 3391 ; 3392 if (hint_pair_offset) {; 3393 int err = 0;; 3394 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3395 if (!err) {; 3396 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3397 free(demangled_name);; 3398 if (cl); 3399 return cl;; 3400 }; 3401 }; 3402 ; 3403 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:127848,simpl,simple,127848,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['simpl'],['simple']
Usability,"n::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the outpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:24433,learn,learning,24433,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,6,['learn'],['learning']
Usability,"n; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQUndoManager.html:19656,undo,undo,19656,root/html534/TQUndoManager.html,https://root.cern,https://root.cern/root/html534/TQUndoManager.html,1,['undo'],['undo']
Usability,"n; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-04-23 20:07; This page has been automatically generated. For comments or suggestions regarding t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGDockableFrame.html:21426,undo,undock,21426,root/html534/TGDockableFrame.html,https://root.cern,https://root.cern/root/html534/TGDockableFrame.html,1,['undo'],['undock']
Usability,"n; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $ » Last generated: 2010-09-23 20:05; This page has been automati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGDockableFrame.html:21326,undo,undock,21326,root/html528/TGDockableFrame.html,https://root.cern,https://root.cern/root/html528/TGDockableFrame.html,1,['undo'],['undock']
Usability,"n; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $ » Last generated: 2011-07-04 15:28; This page has been automati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGDockableFrame.html:21426,undo,undock,21426,root/html530/TGDockableFrame.html,https://root.cern,https://root.cern/root/html530/TGDockableFrame.html,1,['undo'],['undock']
Usability,"n; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $ » Last generated: 2011-11-03 20:13; This page has been automati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGDockableFrame.html:21426,undo,undock,21426,root/html532/TGDockableFrame.html,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html,1,['undo'],['undock']
Usability,"n@ kGreenDefinition Rtypes.h:66; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; qfloat * qDefinition THbookFile.cxx:89; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttText::SetTextAnglevirtual void SetTextAngle(Float_t tangle=0)Set the text angle.Definition TAttText.h:43; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2I2-D histogram with an int per channel (see TH1 documentation)Definition TH2.h:225; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TTextBase class for several text objects.Definition TText.h:22; TText::DrawTextvirtual TText * DrawText(Double_t x, Double_t y, const char *text)Draw this text with new coordinates.Definition TText.cxx:176; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; AuthorGeorg Troska ; Definition in file candleplotwhiskers.C. tutorialshistcandleplotwhiskers.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/candleplotwhiskers_8C.html:4881,simpl,simple,4881,doc/master/candleplotwhiskers_8C.html,https://root.cern,https://root.cern/doc/master/candleplotwhiskers_8C.html,1,['simpl'],['simple']
Usability,"nBase class of the Configurations ;  CTConfiguredAction;  CTIDNode;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  CTNestedIDs;  ►Nvecgeom;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CBalancerInfo;  Cbasic_string_view;  CBasicRNNLayerGeneric implementation ;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  Cclient_cert;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_cert;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_header;  Cmg_option;  Cmg_request_info;  Cmg_response_info;  Cmg_server_ports;  Cmg_websocket_subprotocols;  CMultiDistFree functions adapter needed by UNURAN for multidimensional cont distribution ;  CMYSQL_BIND;  CMYSQL_STMT;  CNuMuToNuE_Oscillation;  ►",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:91842,simpl,simple,91842,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['simpl'],['simple']
Usability,"nBase> fActionPtr;; 179 ; 180 /// Triggers the event loop in the RLoopManager; 181 void TriggerRun();; 182 ; 183 /// Get the pointer to the encapsulated result.; 184 /// Ownership is not transferred to the caller.; 185 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 186 T *Get(); 187 {; 188 if (fActionPtr != nullptr && !fActionPtr->HasRun()); 189 TriggerRun();; 190 return fObjPtr.get();; 191 }; 192 ; 193 void ThrowIfNull(); 194 {; 195 if (fObjPtr == nullptr); 196 throw std::runtime_error(""Trying to access the contents of a null RResultPtr."");; 197 }; 198 ; 199 RResultPtr(std::shared_ptr<T> objPtr, RDFDetail::RLoopManager *lm,; 200 std::shared_ptr<RDFInternal::RActionBase> actionPtr); 201 : fLoopManager(lm), fObjPtr(std::move(objPtr)), fActionPtr(std::move(actionPtr)); 202 {; 203 }; 204 ; 205public:; 206 using Value_t = T; ///< Convenience alias to simplify access to proxied type; 207 static constexpr ULong64_t kOnce = 0ull; ///< Convenience definition to express a callback must be executed once; 208 ; 209 RResultPtr() = default;; 210 RResultPtr(const RResultPtr &) = default;; 211 RResultPtr(RResultPtr &&) = default;; 212 RResultPtr &operator=(const RResultPtr &) = default;; 213 RResultPtr &operator=(RResultPtr &&) = default;; 214 explicit operator bool() const { return bool(fObjPtr); }; 215 ; 216 /// Convert a RResultPtr<T2> to a RResultPtr<T>.; 217 ///; 218 /// Useful e.g. to store a number of RResultPtr<TH1D> and RResultPtr<TH2D> in a std::vector<RResultPtr<TH1>>.; 219 /// The requirements on T2 and T are the same as for conversion between std::shared_ptr<T2> and std::shared_ptr<T>.; 220 template <typename T2,; 221 std::enable_if_t<std::is_constructible<std::shared_ptr<T>, std::shared_ptr<T2>>::value, int> = 0>; 222 RResultPtr(const RResultPtr<T2> &r) : fLoopManager(r.fLoopManager), fObjPtr(r.fObjPtr), fActionPtr(r.fActionPtr); 223 {; 224 }; 225 ; 226 /// Get a const reference to the encapsulated object.; 227 /// Trigger",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:8284,simpl,simplify,8284,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['simpl'],['simplify']
Usability,"nBinsnumber of bins to scan, if = -1 no scan is done (default); RooArgSetfNuisanceParameters; RooArgSetfPOI; RooAbsPdf*fPdf; ROOT::Math::IBaseFunctionOneDim*fPosteriorFunctionfunction representing the posterior; RooAbsPdf*fPosteriorPdfnormalized (on the poi) posterior pdf ; RooAbsPdf*fPriorPOI; RooAbsPdf*fProductPdfinternal pointer to model * prior; doublefSizesize used for getting the interval; Double_tfUpperupper interval bound; Bool_tfValidInterval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BayesianCalculator(); default constructor. BayesianCalculator( /* const char* name, const char* title, */ RooAbsData& data, RooAbsPdf& pdf,						 const RooArgSet& POI,						 RooAbsPdf& priorPOI,						 const RooArgSet* nuisanceParameters ); TNamed( TString(name), TString(title) ),; constructor. BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); constructor from Model Config. ~BayesianCalculator(); destructor. void ClearAll() const; clear cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model. RooAbsReal* GetPosteriorFunction() const; build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters. RooAbsPdf* GetPosteriorPdf() const; build and return the posterior pdf (i.e posterior function normalized to all range of poi; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region. void SetIntegrationType(const char* type). SimpleInterval* GetInterval(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__BayesianCalculator.html:8355,clear,clear,8355,root/html528/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__BayesianCalculator.html,1,['clear'],['clear']
Usability,"nInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = false) {; 801 std::unique_ptr<TMethodCall>; 802 Method = std::make_unique<TMethodCall>();; 803 ; 804 TString prototypeArguments = """";; 805 if (HasVariables || HasParameters) {; 806 if (IsVectorized); 807 prototypeArguments.Append(""ROOT::Double_v*"");; 808 else; 809 prototypeArguments.Append(""Double_t*"");; 810 }; 811 auto AddDoublePtrParam = [&prototypeArguments]() {; 812 prototypeArguments.Append("","");; 813 prototypeArguments.Append(""Double_t*"");; 814 };; 815 if (HasParameters); 816 AddDoublePtrParam();; 817 ; 818 // We need an extra Double_t* for the gradient return result.; 819 if (AddCladArrayRef) {; 820 prototypeArguments.Append("","");; 821 prototypeArguments.Append(""Double_t*"");; 822 }; 823 ; 824 // Initialize the method call using real function name (cling name) defined; 825 // by Process",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:28816,clear,clear,28816,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['clear'],['clear']
Usability,"nProxy::Initialize(Bool_t silent) const; virtual TGenCollectionProxy*TEmulatedCollectionProxy::InitializeEx(Bool_t silent); voidTEmulatedCollectionProxy::ReadItems(int nElements, TBuffer& b); voidReadMap(int nElements, TBuffer& b); voidTEmulatedCollectionProxy::Shrink(UInt_t nCurr, UInt_t left, Bool_t force); voidTEmulatedCollectionProxy::WriteItems(int nElements, TBuffer& b); voidWriteMap(int nElements, TBuffer& b). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodTGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextCont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEmulatedMapProxy.html:4600,clear,clear,4600,root/html532/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html532/TEmulatedMapProxy.html,1,['clear'],['clear']
Usability,"n_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TH2::FitSlicesXvirtual void FitSlicesX(TF1 *f1=nullptr, Int_t firstybin=0, Int_t lastybin=-1, Int_t cut=0, Option_t *option=""QNR"", TObjArray *arr=nullptr)Project slices along X in case of a 2-D histogram, then fit each slice with function f1 and make a hi...Definition TH2.cxx:1016; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:99",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisTreeReader_8C.html:11122,simpl,simple,11122,doc/master/h1analysisTreeReader_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisTreeReader_8C.html,1,['simpl'],['simple']
Usability,"n_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TH2::FitSlicesXvirtual void FitSlicesX(TF1 *f1=nullptr, Int_t firstybin=0, Int_t lastybin=-1, Int_t cut=0, Option_t *option=""QNR"", TObjArray *arr=nullptr)Project slices along X in case of a 2-D histogram, then fit each slice with function f1 and make a hi...Definition TH2.cxx:1016; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysis_8C.html:16257,simpl,simple,16257,doc/master/h1analysis_8C.html,https://root.cern,https://root.cern/doc/master/h1analysis_8C.html,1,['simpl'],['simple']
Usability,"nal function? There is no abstract base class? No templates? It implies that you plan to keep the pointless T in front of all the names of ROOT, even though you will have access to namespaces (finally) and thus can move past the 1970's C practice of avoiding name collisions by a sort of weird Hungarian notation. It implies that you plan to maintain the outdated interfaces which make no use of templates. Templates are one of the most powerful features of C++, are more relevant to performance critical tasks than inheritance, and help ensure the type-safety of code (thereby ensuring the accuracy of data by helping to prevent accidental narrowing etc). It implies that you intend to continue to encourage the use of bare new and delete operators, instead of relying on the more efficient, reliable, and safe method of using RAII. Why? This begs the obvious question: why bother migrating at all? You wish to migrate to the modern and superior C++11 in order to not take advantage of its features? Why not just simply maintain ROOT5 and CINT, and just refuse to upgrade? ROOT is not a particularly good framework that is written in a language that isn't quite C++. If you are going to break away and make/use/write cling, then fix the poor design decisions: cling will probably break compatibility anyways despite your best efforts, so you might as well take the time and effort to refactor and clean up the code base. A simple example, taken from this website: """""" TFFTComplex One of the interface classes to the FFTW package, can be used directly or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes complex input/output discrete Fourier transforms (DFT) in one or more dimensions. For the detailed information on the computed transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it: 1) Create an instance of TFFTComplex - this will allocate input and output arrays (unless an in-place transform is specified) 2) Run the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:10317,simpl,simply,10317,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['simpl'],['simply']
Usability,"nal_name, Int_t, const T &... params);  Emit a signal with a varying number of arguments. ;  ; TList * GetListOfClassSignals () const;  Returns pointer to list of signals of this class. ;  ; TList * GetListOfConnections () const;  ; TList * GetListOfSignals () const;  ; virtual Bool_t HasConnection (const char *signal_name) const;  Return true if there is any object connected to this signal. ;  ; virtual void HighPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void LowPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void Message (const char *msg);  ; virtual Int_t NumberOfConnections () const;  Return number of connections for this object. ;  ; virtual Int_t NumberOfSignals () const;  Return number of signals for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TQCommand * GetCommand ();  Return a command which is doing redo/undo action. ;  ;  Static Public Member Functions inherited from TList; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSeqCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:23067,undo,undo,23067,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"nals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoRotationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for rotation editor. ~TGeoRotationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected rotation. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoRotationEditor.html:22027,undo,undoing,22027,root/html534/TGeoRotationEditor.html,https://root.cern,https://root.cern/root/html534/TGeoRotationEditor.html,1,['undo'],['undoing']
Usability,"nalyzer;  CTModuleDocInfo;  CTMonaLisaText;  CTMonaLisaValue;  CTMonaLisaWriter;  CTMonitor;  CTMPClientBase class for multiprocess applications' clients ;  CTMPWorkerThis class works in conjuction with TMPClient, reacting to messages received from it as specified by the Notify and HandleInput methods ;  CTMultiDimFitMultidimensional Fits in ROOT ;  CTMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects ;  CTMultiLayerPerceptron;  CTMutex;  CTMutexImp;  CTMySQLResult;  CTMySQLRow;  CTMySQLServer;  ►CTMySQLStatement;  CTParamData;  CTNamedBase class for all named ROOT classes ;  CTNDArray;  CTNDArrayRef;  CTNDArrayT;  CTNetFile;  CTNetFileStager;  CTNetSystem;  CTNetXNGFile;  CTNetXNGFileStager;  CTNetXNGSystem;  CTNeuron;  CTNewChainDlg;  CTNewQueryDlg;  CTNodeTNode description ;  CTNodeDivDescription of parameters to divide a 3-D geometry object ;  CTNonCopyable;  CTNonSplitBrowsableAllows a TBrowser to browse non-split branches as if they were split ;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStep;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CTOrdCollectionIterIterator of ordered collection ;  CTOutputListSelectorDataMap;  CTPackageDescription;  CTPacketizer;  CTPacketizerAdapti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:144306,simpl,simple,144306,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['simpl'],['simple']
Usability,"name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringfNameIdentfier for this object; TProof*fProofhandle to PROOF session; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatsFeedback(TProof* proof = 0); Constructor. ~TStatsFeedback(); Destructor. void Feedback(TList* objs); Display feedback. const char * GetName() const; { return fName.Data(); }. ULong_t Hash() const; { return fName.Hash(); }. » Author: G. Ganis May 2012 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStatsFeedback.html:9027,feedback,feedback,9027,root/html534/TStatsFeedback.html,https://root.cern,https://root.cern/root/html534/TStatsFeedback.html,1,['feedback'],['feedback']
Usability,"name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background normalisation uncertainty ; Parameters. [in,out]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram prior to adding the covariance matrix contribution. this method returns the uncertainties on the unfolding result arising from the background source source and its normalisation uncertainty. See method SubtractBackground() how to set the normalisation uncertainty ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1144 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundUncorr(). void TUnfoldSys::GetEmatrixSysBackgroundUncorr ; (; TH2 * ; ematrix, . const char * ; source, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background uncorrelated uncertainty ; Parameters. [in]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result arising from the background source source and the uncorrelated (background histogram uncertainties). Also see method SubtractBackground() ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1229 of file TUnfoldSys.cxx. ◆ GetEmatrixSysSource(). void TUnfoldSys::GetEmatrixSysSource ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from a systematic variation of the response matrix ; Parameters. [in,out]ematrixcovariance mat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:39390,clear,clearEmat,39390,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,name. Multiple streams can write to same file. . OutputStream(ostream&) Send output to given C++ stream. Multiple message streams can write to same c++ stream . The return value is the unique ID of the defined stream. PyROOT; The RooMsgService::addStream() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArg of the function. . Definition at line 177 of file RooMsgService.cxx. ◆ anyDebug(). bool RooMsgService::anyDebug ; (; ). static . Returns true if any debug level stream is active. ; Definition at line 138 of file RooMsgService.cxx. ◆ Class(). static TClass * RooMsgService::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooMsgService::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooMsgService::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 246 of file RooMsgService.h. ◆ clearErrorCount(). void RooMsgService::clearErrorCount ; (; ). inline . Definition at line 200 of file RooMsgService.h. ◆ debugCode(). Int_t & RooMsgService::debugCode ; (; ). inline . Definition at line 207 of file RooMsgService.h. ◆ debugWorkspace(). RooWorkspace * RooMsgService::debugWorkspace ; (; ). Definition at line 147 of file RooMsgService.cxx. ◆ DeclFileName(). static const char * RooMsgService::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 246 of file RooMsgService.h. ◆ deleteStream(). void RooMsgService::deleteStream ; (; Int_t ; id). Delete stream with given unique ID code. ; Definition at line 293 of file RooMsgService.cxx. ◆ errorCount(). Int_t RooMsgService::errorCount ; (; ); const. inline . Definition at line 199 of file RooMsgService.h. ◆ getStream(). StreamConfig & RooMsgService::getStream ; (; Int_t ; id). inline . Definition at line 161 of file RooMsgService.h. ◆ getStreamStatus(). bool RooMsgService::get,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMsgService.html:17967,clear,clearErrorCount,17967,doc/master/classRooMsgService.html,https://root.cern,https://root.cern/doc/master/classRooMsgService.html,1,['clear'],['clearErrorCount']
Usability,"napsesarray of pointers to synapses, no structural data; boolTMVA::MethodANNBase::fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodMLP.html:20071,learn,learning,20071,root/html528/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html,5,"['clear', 'learn']","['clear', 'learning']"
Usability,"nc (passThrough, myweights, gradients);; 313 // return value;; 314 // }; 315 // };; 316 ; 317 ; 318 ; 319 ///< list all the minimizer types; 320 enum MinimizerType; 321 {; 322 fSteepest ///< SGD; 323 };; 324 ; 325 ; 326 ; 327 ; 328 ; 329 /*! \brief Steepest Gradient Descent algorithm (SGD); 330 *; 331 * Implements a steepest gradient descent minimization algorithm; 332 */; 333 class Steepest; 334 {; 335 public:; 336 ; 337 size_t m_repetitions;; 338 ; 339 ; 340 /*! \brief c'tor; 341 *; 342 * C'tor; 343 *; 344 * \param learningRate denotes the learning rate for the SGD algorithm; 345 * \param momentum fraction of the velocity which is taken over from the last step; 346 * \param repetitions re-compute the gradients each ""repetitions"" steps; 347 */; 348 Steepest (double learningRate = 1e-4,; 349 double momentum = 0.5,; 350 size_t repetitions = 10); 351 : m_repetitions (repetitions); 352 , m_alpha (learningRate); 353 , m_beta (momentum); 354 {}; 355 ; 356 /*! \brief operator to call the steepest gradient descent algorithm; 357 *; 358 * entry point to start the minimization procedure; 359 *; 360 * \param fitnessFunction (templated) function which has to be provided. This function is minimized; 361 * \param weights (templated) a reference to a container of weights. The result of the minimization procedure; 362 * is returned via this reference (needs to support std::begin and std::end; 363 * \param passThrough (templated) object which can hold any data which the fitness function needs. This object; 364 * is not touched by the minimizer; This object is provided to the fitness function when; 365 * called; 366 */; 367 template <typename Function, typename Weights, typename PassThrough>; 368 double operator() (Function& fitnessFunction, Weights& weights, PassThrough& passThrough);; 369 ; 370 ; 371 double m_alpha; ///< internal parameter (learningRate); 372 double m_beta; ///< internal parameter (momentum); 373 std::vector<double> m_prevGradients; ///< vector remembers the gradie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:9202,learn,learningRate,9202,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['learn'],['learningRate']
Usability,"nce Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t > Class Template Reference. ; template<typename Architecture_t, typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>>; class TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >RMSProp Optimizer class. ; This class represents the RMSProp Optimizer with options for applying momentum. ; Definition at line 45 of file RMSProp.h. Public Types; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  ;  Public Types inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  . Public Member Functions;  TRMSProp (DeepNet_t &deepNet, Scalar_t learningRate=0.001, Scalar_t momentum=0.0, Scalar_t rho=0.9, Scalar_t epsilon=1e-7);  Constructor. ;  ;  ~TRMSProp ()=default;  Destructor. ;  ; std::vector< std::vector< Matrix_t > > & GetBiasUpdates ();  ; std::vector< Matrix_t > & GetBiasUpdatesAt (size_t i);  ; Scalar_t GetEpsilon () const;  ; Scalar_t GetMomentum () const;  Getters. ;  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasGradients ();  ; std::vector< Matrix_t > & GetPastSquaredBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ; Scalar_t GetRho () const;  ; std::vector< std::vector< Matrix_t > > & GetWeightUpdates ();  ; std::vector< Matrix_t > & GetWeightUpdatesAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html:1144,learn,learningRate,1144,doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,1,['learn'],['learningRate']
Usability,"nce. Namespaces; namespace  BitPacking;  . Classes; struct  AxisConfigToType;  Converts a RAxisConfig of whatever kind to the corresponding RAxisBase-derived object. More...;  ; struct  AxisConfigToType< RAxisConfig::kEquidistant >;  ; struct  AxisConfigToType< RAxisConfig::kGrow >;  ; struct  AxisConfigToType< RAxisConfig::kIrregular >;  ; struct  AxisConfigToType< RAxisConfig::kLabels >;  ; class  RArraySizeField;  An artificial field that provides the size of a fixed-size array. More...;  ; class  RCluster;  An in-memory subset of the packed and compressed pages of a cluster. More...;  ; class  RClusterDescriptorBuilder;  A helper class for piece-wise construction of an RClusterDescriptor. More...;  ; class  RClusterGroupDescriptorBuilder;  A helper class for piece-wise construction of an RClusterGroupDescriptor. More...;  ; class  RClusterPool;  Managed a set of clusters containing compressed and packed pages. More...;  ; class  RColumn;  A column is a storage-backed array of a simple, fixed-size type, from which pages can be mapped into memory. More...;  ; class  RColumnDescriptorBuilder;  A helper class for piece-wise construction of an RColumnDescriptor. More...;  ; class  RColumnElementBase;  A column element encapsulates the translation between basic C++ types and their column representation. More...;  ; struct  RColumnInfo;  ; struct  RComputeGlobalBin;  Recursively gets the total number of regular bins before the current dimension, when computing a global bin that is in under- or overflow in at least one dimension. More...;  ; struct  RComputeGlobalBin<-1, NDIMS, BINS, AXES >;  ; struct  RComputeGlobalBinRaw;  Recursively computes a zero-based global bin index, given... More...;  ; struct  RComputeGlobalBinRaw<-1, NDIMS, BINS, AXES, BINTYPE >;  ; struct  RComputeLocalBins;  Recursively computes the number of regular bins before the current dimension, as well as the number of under- and overflow bins left to account for, after the current dimension. More..",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html:1259,simpl,simple,1259,doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,1,['simpl'],['simple']
Usability,"nch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; WARNING: Currently only ONE TTree object can be 'cached' per TFile object.; This call disable the cache for the other TTree objects read from the same; TFile object as this TTree (The SetCacheSize called __last__ wins).; To cache multiple TTree objects in the same ROOT file, you must create; one TFile object per TTree object. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:120396,learn,learning,120396,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['learn'],['learning']
Usability,"nchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual voidCanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidCreatePackets(); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TChain.html:3703,undo,undo,3703,root/html528/TChain.html,https://root.cern,https://root.cern/root/html528/TChain.html,6,['undo'],['undo']
Usability,"nction = DNN::EOutputFunction::kSigmoid;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////////; 111/// MLP can handle classification with 2 classes and regression with; 112/// one regression-target; 113 ; 114Bool_t TMVA::MethodDNN::HasAnalysisType(Types::EAnalysisType type,; 115 UInt_t numberClasses,; 116 UInt_t /*numberTargets*/ ); 117{; 118 if (type == Types::kClassification && numberClasses == 2 ) return kTRUE;; 119 if (type == Types::kMulticlass ) return kTRUE;; 120 if (type == Types::kRegression ) return kTRUE;; 121 ; 122 return kFALSE;; 123}; 124 ; 125////////////////////////////////////////////////////////////////////////////////; 126/// default initializations; 127 ; 128void TMVA::MethodDNN::Init() {; 129 Log() << kWARNING; 130 << ""MethodDNN is deprecated and it will be removed in future ROOT version. ""; 131 ""Please use MethodDL ( TMVA::kDL)""; 132 << Endl;; 133 ; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// Options to be set in the option string:; 138///; 139/// - LearningRate <float> DNN learning rate parameter.; 140/// - DecayRate <float> Decay rate for learning parameter.; 141/// - TestRate <int> Period of validation set error computation.; 142/// - BatchSize <int> Number of event per batch.; 143///; 144/// - ValidationSize <string> How many events to use for validation. ""0.2""; 145/// or ""20%"" indicates that a fifth of the; 146/// training data should be used. ""100""; 147/// indicates that 100 events should be used.; 148 ; 149void TMVA::MethodDNN::DeclareOptions(); 150{; 151 ; 152 DeclareOptionRef(fLayoutString=""SOFTSIGN|(N+100)*2,LINEAR"",; 153 ""Layout"",; 154 ""Layout of the network."");; 155 ; 156 DeclareOptionRef(fValidationSize = ""20%"", ""ValidationSize"",; 157 ""Part of the training data to use for ""; 158 ""validation. Specify as 0.2 or 20% to use a ""; 159 ""fifth of the data set as validation set. ""; 160 ""Specify as 100 to use exactly 100 events. ""; 161 ""(Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:4718,learn,learning,4718,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['learn'],['learning']
Usability,"nction"" which; has been overridden by the user. void Evolution(); this function is called from ""init"" and controls the evolution of the; individuals.; the function can be overridden to change the parameters for mutation rate; sexual reproduction and so on. Double_t SpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); this function provides the ability to change the stepSize of a mutation according to; the success of the last generations. Parameters:; int ofSteps : = if OF the number of STEPS given in this variable (ofSteps); int successSteps : >sucessSteps Generations could improve the result; double factor : than multiply the stepSize ( spread ) by this factor; (if ofSteps == successSteps nothing is changed, if ofSteps < successSteps, the spread; is divided by the factor). using this function one can increase the stepSize of the mutation when we have; good success (to pass fast through the easy phase-space) and reduce the stepSize; if we are in a difficult ""territory"" of the phase-space. Bool_t HasConverged(Int_t steps = 10, Double_t ratio = 0.1); gives back true if the last ""steps"" steps have lead to an improvement of the; ""fitness"" of the ""individuals"" of at least ""improvement"". this gives a simple measure of if the fitness of the individuals is; converging and no major improvement is to be expected soon. GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0). GeneticPopulation& GetGeneticPopulation(); { return fPopulation; }. Double_t GetSpread() const; { return fSpread; }. void SetSpread(Double_t s); { fSpread = s; }. void SetMakeCopies(Bool_t s); { fMakeCopies = s; }. Bool_t GetMakeCopies(); { return fMakeCopies; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__GeneticAlgorithm.html:5178,simpl,simple,5178,root/html534/TMVA__GeneticAlgorithm.html,https://root.cern,https://root.cern/root/html534/TMVA__GeneticAlgorithm.html,1,['simpl'],['simple']
Usability,"nctionDefinition NeuralNet.h:697; TMVA::DNN::Layer::LayerLayer(size_t numNodes, EnumFunction activationFunction, ModeOutputValues eModeOutputValues=ModeOutputValues::DIRECT)c'tor for defining a LayerDefinition NeuralNet.cxx:166; TMVA::DNN::Net::m_layersstd::vector< Layer > m_layerslayer-structure-dataDefinition NeuralNet.h:1272; TMVA::DNN::Net::inputSizesize_t inputSize() constinput size of the DNNDefinition NeuralNet.h:1098; TMVA::DNN::Net::numNodessize_t numNodes(size_t trainingStartLayer=0) constreturns the number of nodes in this netDefinition NeuralNet.cxx:556; TMVA::DNN::Net::fillDropContainervoid fillDropContainer(DropContainer &dropContainer, double dropFraction, size_t numNodes) constprepare the drop-out-container (select the nodes which are to be dropped out)Definition NeuralNet.cxx:572; TMVA::DNN::Net::numWeightssize_t numWeights(size_t trainingStartLayer=0) constreturns the number of weights in this netDefinition NeuralNet.cxx:540; TMVA::DNN::Settings::clearvoid clear(std::string histoName)for monitoringDefinition NeuralNet.h:824; TMVA::DNN::Settings::hasConvergedvirtual bool hasConverged(double testError)has this training converged already?Definition NeuralNet.cxx:485; TMVA::DNN::Settings::SettingsSettings(TString name, size_t _convergenceSteps=15, size_t _batchSize=10, size_t _testRepetitions=7, double _factorWeightDecay=1e-5, TMVA::DNN::EnumRegularization _regularization=TMVA::DNN::EnumRegularization::NONE, MinimizerType _eMinimizerType=MinimizerType::fSteepest, double _learningRate=1e-5, double _momentum=0.3, int _repetitions=3, bool _multithreading=true)c'torDefinition NeuralNet.cxx:232; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::~Settingsvirtual ~Settings()d'torDefinition NeuralNet.cxx:261; TMVA::DNN::Settings::m_convergenceCountsize_t m_convergenceCountDefinition NeuralNet.h:857; TMVA::DNN::Settings::m_minErrordouble m_minErrorDefinition NeuralNet.h:859; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:26810,clear,clearvoid,26810,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,2,['clear'],"['clear', 'clearvoid']"
Usability,"nctions inherited from RooAbsLValue; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; value_type evaluate () const override;  Evaluate the category state and return. ;  ; void recomputeShape () override;  Ask server category to recompute shape, and copy its information. ;  ;  Protected Member Functions inherited from RooAbsCategoryLValue; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_type index) const;  Return the legacy RooCatType corresponding to index. If it doesn't exist, create one. ;  ; void setCachedValue (double value, bool notifyClients=tru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSuperCategory.html:39373,clear,clearTypes,39373,doc/master/classRooSuperCategory.html,https://root.cern,https://root.cern/doc/master/classRooSuperCategory.html,1,['clear'],['clearTypes']
Usability,"nctions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; ROOT::Experimental::RCanvas Class ReferenceGraphics » ROOT7 Graphics » ROOT7 Pad related classes. ; A window's topmost RPad. ; AuthorAxel Naumann axel@.nosp@m.cern.nosp@m..ch ; Date2015-07-08 ; WarningThis is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome! ; Definition at line 47 of file RCanvas.hxx. Public Member Functions;  RCanvas ();  Create a temporary RCanvas; for long-lived ones please use Create(). ;  ;  ~RCanvas () override=default;  ; template<class PANEL > ; bool AddPanel (std::shared_ptr< PANEL > &panel);  Insert panel into the canvas, canvas should be shown at this moment. ;  ; void ClearOnClose (const std::shared_ptr< void > &handle);  Set handle which will be cleared when connection is closed. ;  ; void ClearShown ();  clear IsShown() flag ;  ; void ClearUpdated ();  clear IsUpdated() flag ;  ; std::string CreateJSON ();  Provide JSON which can be used for offline display. ;  ; const RCanvas * GetCanvas () const override;  Access to the top-most canvas, if any (const version). ;  ; RCanvas * GetCanvas () override;  Access to the top-most canvas, if any (non-const version). ;  ; int GetHeight () const;  Get canvas height. ;  ; uint64_t GetModified () const;  Get modify counter. ;  ; const std::string & GetTitle () const;  Get the canvas's title. ;  ; std::string GetUID () const;  Return unique identifier for the canvas Used in iPython display. ;  ; int GetWidth () const;  Get canvas width. ;  ; std::string GetWindowAddr () const;  Returns window name used to display canvas. ;  ; std::string GetWindowUrl (bool remote);  Returns window URL which can be used for connection. ;  ; void Hide ();  Hide all canvas displays. ;  ; bool IsModified () const;  Returns true is canvas was modified since last painting. ;  ; bool IsShown () const;  returns true if Show() method was",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html:1109,clear,clear,1109,doc/master/classROOT_1_1Experimental_1_1RCanvas.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html,2,['clear'],['clear']
Usability,"nction ; function). inline . add a preprocess function object ; Definition at line 74 of file Measurement.h. ◆ AddPOI(). void RooStats::HistFactory::Measurement::AddPOI ; (; const std::string & ; POI). inline . append parameter to vector of PoIs ; Definition at line 49 of file Measurement.h. ◆ AddPreprocessFunction(). void RooStats::HistFactory::Measurement::AddPreprocessFunction ; (; std::string ; name, . std::string ; expression, . std::string ; dependencies . ). Add a preprocessed function by giving the function a name, a functional expression, and a string with a bracketed list of dependencies (eg ""SigXsecOverSM[0,3]"") ; Definition at line 112 of file Measurement.cxx. ◆ ClearConstantParams(). void RooStats::HistFactory::Measurement::ClearConstantParams ; (; ). inline . empty vector of constant parameters ; Definition at line 60 of file Measurement.h. ◆ ClearParamValues(). void RooStats::HistFactory::Measurement::ClearParamValues ; (; ). inline . clear map of parameter values ; Definition at line 70 of file Measurement.h. ◆ GetAsimovDatasets(). std::vector< RooStats::HistFactory::Asimov > & RooStats::HistFactory::Measurement::GetAsimovDatasets ; (; ). inline . get vector of defined Asimov Datasets ; Definition at line 82 of file Measurement.h. ◆ GetBinHigh(). int RooStats::HistFactory::Measurement::GetBinHigh ; (; ). inline . Definition at line 98 of file Measurement.h. ◆ GetBinLow(). int RooStats::HistFactory::Measurement::GetBinLow ; (; ). inline . Definition at line 97 of file Measurement.h. ◆ GetConstantParams(). std::vector< std::string > & RooStats::HistFactory::Measurement::GetConstantParams ; (; ). inline . get vector of all constant parameters ; Definition at line 62 of file Measurement.h. ◆ GetFunctionObjects() [1/2]. std::vector< RooStats::HistFactory::PreprocessFunction > & RooStats::HistFactory::Measurement::GetFunctionObjects ; (; ). inline . get vector of defined function objects ; Definition at line 77 of file Measurement.h. ◆ GetFunctionObjects() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1Measurement.html:16357,clear,clear,16357,doc/master/classRooStats_1_1HistFactory_1_1Measurement.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1Measurement.html,1,['clear'],['clear']
Usability,"nd ();  dtor. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo arguments. ;  ; Int_t GetNUargs () const;  Returns a number of undo arguments. ;  ; void * GetObject () const;  Returns an object for which undo redo actions are applied. ;  ; TQConnection * GetRedo () const;  ; Long_t * GetRedoArgs () const;  Returns a pointer to array of redo arguments. ;  ; const char * GetRedoName () const;  Returns the name of redo command. ;  ; Int_t GetStatus () const;  Returns a number of sequential undo or redo operations. ;  ; const char * GetTitle () const override;  Returns command description. ;  ; TQConnection * GetUndo () const;  ; Long_t * GetUndoArgs () const;  Returns a pointer to array of undo arguments. ;  ; const char * GetUndoName () const;  Returns the name of undo command. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Undo function and is the setter action. ;  ; Bool_t IsUndoing () const;  Undo action is in progress. ;  ; virtual Long64_t Merge (TCollection *, TFileMergeInfo *);  Merge a collection of TQCommand. ;  ; virtual void Merge (TQCommand *c);  Add command to the list of merged commands. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:3291,undo,undo,3291,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"nd = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgSet.html:12980,clear,clearStructureTags,12980,root/html534/RooArgSet.html,https://root.cern,https://root.cern/root/html534/RooArgSet.html,1,['clear'],['clearStructureTags']
Usability,"nd = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. static RooPrintable::ContentsOptionRooPrintable::kAddress; static RooPrintable::ContentsOptionRooPrintable::kArgs; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static RooPrintable::ContentsOptionRooPrintable::kClassName; static RooPrintable::ContentsOptionRooPrintable::kCollectionHeader; static RooPrintable::ContentsOptionRooPrintable::kExtras; static TObject::EStatusBitsTObject::kHasUUID; static RooPrintable::StyleOptionRooPrintable::kInline; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgSet.html:13014,clear,clearStructureTags,13014,root/html602/RooArgSet.html,https://root.cern,https://root.cern/root/html602/RooArgSet.html,2,['clear'],['clearStructureTags']
Usability,"nd namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far. void ClearGlobals(); Forget all global variables seen so far. void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char* path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. const TSeqCollection * GetListOfGlobals(); Return the list of globals. const TSeqCollection * GetListOfGlobalFunctions(); Return the list of global functions. const TSeqCollection * GetListOfPragmas(); Return the list of pragmas. const TSeqCollection * GetListOfSysIncFiles(); Return the list of system include files. const TSeqCollection * GetListOfUsers(); reads from ""/etc/passwd"". Char_t AllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); [static utility function]. if all the strings in ""*pList"" have the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTabCom.html:7931,clear,clears,7931,root/html528/TTabCom.html,https://root.cern,https://root.cern/root/html528/TTabCom.html,4,['clear'],['clears']
Usability,"nd older jquery-ui; support custom requests to remote objects, demonstrated in httptextlog.C tutorial; rewrite draw.htm (page for individual object drawing) to support all custom features as main gui does; See also the JSRoot 3.9 examples page and the JSRoot 3.9 release notes. Class Reference Guide; The ROOT reference guide is moving to the Doxygen system. Doxygen is the de-facto standard for code documentation. It offers many nice features we are now exploring and trying to get the best of them. Having MathJax rendered math formula is one of them. The documentation can be structured in a more logical way using groups. Still there is a lot to do but big progresses have been done. We developed also a Doxygen filter allowing to execute macros given as examples in the documentation and show the resulting picture directly in the documentation.; Tutorials; The tutorials in $ROOTSYS/tutorials are also presented on the web thanks to Doxygen. They are now part of the reference guide allowing nice cross-referencing with the classes documentation. Here also a filter has been developed to generate the resulting picture.; Build, Configuration and Testing Infrastructure; ROOT uses the CMake cross-platform build-generator tool as a primary build system. CMake does not build the project, it generates the files needed by your build tool (GNU make, Ninja, Visual Studio, etc) for building ROOT. The classic build with configure/make is is still available but it will not be evolving with the new features of ROOT.; We added full support for C++14.; Minor changes in the build system:. Renamed build option POSTGRESQL_LIBRARIES to POSTGRESQL_LIBRARY; Added build option builtin_openssl to build OpenSSL internally. This is specially needed for the latest Mac OSX (El Capitan). Patch Releases; Release 6.06/02; Core. Make TListOfFunctions::Get thread-safe; Make TPluginManager thread-safe ROOT-7927; Properly handle the case of an executable with a space in its full pathname when search for linked",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:23448,guid,guide,23448,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['guid'],['guide']
Usability,"nd optimization convolution generation context that uses a smearing algorithm. Otherwise return a standard accept/reject sampling context on the convoluted shape. ; Reimplemented from RooAbsPdf.; Definition at line 168 of file RooNumConvPdf.cxx. ◆ initialize(). void RooNumConvPdf::initialize ; (; ); const. protected . One-time initialization of object. ; Definition at line 148 of file RooNumConvPdf.cxx. ◆ IsA(). TClass * RooNumConvPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 78 of file RooNumConvPdf.h. ◆ model(). RooAbsReal & RooNumConvPdf::model ; (; ); const. inline . Definition at line 54 of file RooNumConvPdf.h. ◆ pdf(). RooAbsReal & RooNumConvPdf::pdf ; (; ); const. inline . Definition at line 53 of file RooNumConvPdf.h. ◆ printMetaArgs(). void RooNumConvPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 201 of file RooNumConvPdf.cxx. ◆ profileData(). const TH2 * RooNumConvPdf::profileData ; (; ); const. inline . Definition at line 49 of file RooNumConvPdf.h. ◆ setCallProfiling(). void RooNumConvPdf::setCallProfiling ; (; bool ; flag, . Int_t ; nbinX = 40, . Int_t ; nbinCall = 40, . Int_t ; nCallHigh = 1000 . ). inline . Definition at line 47 of file RooNumConvPdf.h. ◆ setCallWarning(). void RooNumConvPdf::setCallWarning ; (; Int_t ; threshold = 2000). inline . Definition at line 46 of file RooNumConvPdf.h. ◆ setConvolutionWindow(). void RooNumConvPdf::setConvolutionWindow ; (; RooAbsReal & ; centerParam, . RooAbsReal & ; widthParam, . double ; widthScaleFactor = 1 . ). inline . Definition at line 44 of file RooNumConvPdf.h. ◆ Streamer(). void RooNumConvPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvPdf.html:79991,intuit,intuitively,79991,doc/master/classRooNumConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooNumConvPdf.html,1,['intuit'],['intuitively']
Usability,"nd subtraction ; This prepares the data members for the base class TUnfold, such that the background is properly taken into account. ; Definition at line 377 of file TUnfoldSys.cxx. ◆ GetBackground(). void TUnfoldSys::GetBackground ; (; TH1 * ; bgrHist, . const char * ; bgrSource = nullptr, . const Int_t * ; binMap = nullptr, . Int_t ; includeError = 3, . Bool_t ; clearHist = kTRUE . ); const. get background into a histogram ; Parameters. [in,out]bgrHisttarget histogram, content and errors will be altered ; [in]bgrSource(default=nullptr) name of backgrond source or zero to add all sources of background ; [in]binMap(default=nullptr) remap histogram bins ; [in]includeError(default=3) include uncorrelated(1), correlated (2) or both (3) sources of uncertainty in the histogram errors ; [in]clearHist(default=true) reset histogram before adding up the specified background sources. the array binMap is explained with the method GetOutput(). The flag clearHist may be used to add background from several sources in successive calls to GetBackground(). ; Definition at line 565 of file TUnfoldSys.cxx. ◆ GetBgrSources(). TSortedList * TUnfoldSys::GetBgrSources ; (; void ; ); const. Get a new list of all background sources. ; The user is responsible for deleting the list get list of name of background sources ; Definition at line 1528 of file TUnfoldSys.cxx. ◆ GetChi2Sys(). Double_t TUnfoldSys::GetChi2Sys ; (; void ; ). calculate total chi**2 including all systematic errors ; Definition at line 1366 of file TUnfoldSys.cxx. ◆ GetDeltaSysBackgroundScale(). Bool_t TUnfoldSys::GetDeltaSysBackgroundScale ; (; TH1 * ; hist_delta, . const char * ; source, . const Int_t * ; binMap = nullptr . ). correlated one-sigma shifts from background normalisation uncertainty ; Parameters. [out]hist_deltahistogram to store shifts ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins. returns true if the background source was found. ; This method retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:34449,clear,clearHist,34449,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearHist']
Usability,"nd vAxis are the default directions for forward; (inverted) and upwards. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void SetStereo(Bool_t stereo, Bool_t quad_buf = kTRUE); Enable stereo rendering.; If quad_buf is true rendering is done into separate left and right GL; buffers. This requires hardware support. Otherwise left and right images; get rendered into left and right half of the window.; Note that mouse highlighting and selection will not work exactly right; as image for each eye gets slightly shifted and there are two different; directions through the mouse pointer, one for each eye. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void ReMouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void UnMouseOver(TObject* obj, UInt_t state); Emit UnMouseOver signal. void Clicked(TObject* obj); Emit Clicked signal. void Clicked(TObject* obj, UInt_t button, UInt_t state); Emit Clicked signal with button id and modifier state. void ReClicked(TObject* obj, UInt_t button, UInt_t state); Emit ReClicked signal with button id and modifier state. void UnClicked(TObject* obj, UInt_t button, UInt_t state); Emit UnClicked signal with button id and modifier state. void MouseIdle(TGLPhysical",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLViewer.html:35796,guid,guides,35796,root/html604/TGLViewer.html,https://root.cern,https://root.cern/root/html604/TGLViewer.html,1,['guid'],['guides']
Usability,"nd(""my macro"");; macro->Add(com1);; macro->Add(com2);; ...; During Redo operation commands composing macro command are executed sequentially in direct order (first in first out). During Undo, they are executed in reverse order (last in first out).; Undo manager. TQUndoManager is recorder of undo and redo operations. This is command history list which can be traversed backwards and upwards performing undo and redo operations. To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);; TQCommand::TQUndoManagerfriend class TQUndoManagerDefinition TQCommand.h:29; TQUndoManagerRecorder of operations for undo and redo.Definition TQCommand.h:103; TQUndoManager::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the stack of commands.Definition TQCommand.cxx:959; TQUndoManager::Add automatically invokes execution of command's Redo method. Use TQUndoManager::Undo to undo commands in history list. Redo is Undo for undo action. Use TQUndoManager::Redo method for that ; Definition at line 27 of file TQCommand.h. Public Member Functions;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; void Add (TObject *obj) override;  ; void Add (TObject *obj, Option_t *opt) override;  Add command to the list of merged commands. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual Bool_t CanRedo () const;  Returns kTRUE if Redo action is possible, kFALSE if it's not. ;  ; virtual Bool_t CanUndo () const;  Returns kTRUE if Undo action is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:4583,undo,undo,4583,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"nd() and range-based for loops; RooAbsCollection::iterator(): same; RooAbsCollection::fwdIterator(): same; RooWorkspace::componentIterator(): use RooWorkspace::components() with range-based loop. Deprecation of legacy test statistics classes in public interface; Instantiating the following classes and even including their header files is deprecated, and the headers will be removed in ROOT 6.34:. RooAbsTestStatistic; RooAbsOptTestStatistic; RooNLLVar; RooChi2Var; RooXYChi2Var. Please use the higher-level functions RooAbsPdf::createNLL() and RooAbsPdf::createChi2() if you want to create objects that represent test statistics.; Change of RooParamHistFunc; The RooParamHistFunc didn’t take any observable RooRealVar as constructor argument. It assumes as observable the internal variables in the passed RooDataHist. This means it was in most contexts unusable, because the input can’t be changed, other than loading a different bin in the dataset.; Furthermore, there was actually a constructor that took a RooAbsArg x, but it was simply ignored.; To fix all these problems, the existing constructors were replaced by a new one that takes the observable explicitly.; Since the old constructors resulted in wrong computation graphs that caused trouble with the new CPU evaluation backend, they had to be removed without deprecation. Please adapt your code if necessary.; Renaming of some RooFit classes; The RooPower was renamed to RooPowerSum, and RooExpPoly was renamed to RooLegacyExpPoly.; This was a necessary change, because the names of these classes introduced in ROOT 6.28 collided with some classes in CMS combine, which were around already long before. Therefore, the classes had to be renamed to not cause any problems for CMS.; In the unlikeliy case where you should have used these new classes for analysis already, please adapt your code to the new names and re-create your workspaces.; RDataFrame. The RDataFrame constructors that take in input one or more file names (or globs ther",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:14020,simpl,simply,14020,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['simpl'],['simply']
Usability,"ndEntry.; 335 Long64_t fEndEntry = -1LL;; 336 Long64_t fBeginEntry = 0LL; ///< This allows us to propagate the range to the TTreeCache; 337 bool fProxiesSet = false; ///< True if the proxies have been set, false otherwise; 338 bool fSetEntryBaseCallingLoadTree = false; ///< True if during the LoadTree execution triggered by SetEntryBase.; 339 ; 340 // Flag to activate or deactivate warnings in case the friend trees have; 341 // more entries than the main one. In some cases we may want to deactivate; 342 // this behaviour, notably in multithreaded runs where we have to partition; 343 // the main tree but keep the entire friend trees in every thread to ensure; 344 // alignment.; 345 bool fWarnAboutLongerFriends{true};; 346 void WarnIfFriendsHaveMoreEntries();; 347 ; 348 // List of branches for which we want to suppress the printed error about; 349 // missing branch when switching to a new tree; 350 std::vector<std::string> fSuppressErrorsForMissingBranches{};; 351 std::vector<std::string> fMissingProxies{};; 352 ; 353 friend class ROOT::Internal::TTreeReaderValueBase;; 354 friend class ROOT::Internal::TTreeReaderArrayBase;; 355 ; 356 ClassDefOverride(TTreeReader, 0); // A simple interface to read trees; 357};; 358 ; 359#endif // defined TTreeReader; Long64_tlong long Long64_tDefinition RtypesCore.h:69; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TNotifyLink.h; TTreeReaderUtils.h; TTree.h; ROOT::Internal::TFriendProxyDefinition TFriendProxy.h:22; ROOT::Internal::TNamedBranchProxyDefinition TTreeReaderUtils.h:43; ROOT::Internal::TTreeReaderArrayBaseBase class of TTreeReaderArray.Definition TTreeReaderArray.h:29; ROOT::Internal::TTreeReaderValueBaseBase class of TTreeReaderValue.Definition TTreeReaderValue.h:45; TBranchProxyDirectorThis class is used to 'drive' and hold a serie of TBranchProxy objects which represen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:14798,simpl,simple,14798,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,1,['simpl'],['simple']
Usability,"ndPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; Bool_tdefineType(const char* lab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCategory.html:2107,clear,clearValueDirty,2107,root/html602/RooCategory.html,https://root.cern,https://root.cern/root/html602/RooCategory.html,2,['clear'],['clearValueDirty']
Usability,"ndim). static . Global switch to cache all integral values that integrate at least ndim dimensions numerically. ; Definition at line 1165 of file RooRealIntegral.cxx. ◆ setCacheNumeric(). void RooRealIntegral::setCacheNumeric ; (; bool ; flag). inline . Definition at line 55 of file RooRealIntegral.h. ◆ Streamer(). void RooRealIntegral::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooRealIntegral::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 150 of file RooRealIntegral.h. ◆ sum(). double RooRealIntegral::sum ; (; ); const. protectedvirtual . Perform summation of list of category dependents to be integrated. ; Definition at line 939 of file RooRealIntegral.cxx. ◆ translate(). void RooRealIntegral::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 1035 of file RooRealIntegral.cxx. Member Data Documentation. ◆ _anaList. RooSetProxy RooRealIntegral::_anaList. protected . Set of observables over which is integrated/summed analytically. ; Definition at line 119 of file RooRealIntegral.h. ◆ _cacheAllNDim. Int_t RooRealIntegral::_cacheAllNDim. staticprotected . ! Cache all integrals with given numeric dimension ; Definition at line 145 of file RooRealIntegral.h. ◆ _cacheNum. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:74847,simpl,simple,74847,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['simpl'],['simple']
Usability,"nding on the context, using TTask might still be a valid solution. ; TTask is a base class that can be used to build a complex tree of Tasks. Each TTask derived class may contain other TTasks that can be executed recursively, such that a complex program can be dynamically built and executed by invoking the services of the top level Task or one of its subtasks.; Use the TTask::Add function to add a subtask to an existing TTask. To execute a TTask, one calls the ExecuteTask function. ExecuteTask will call recursively:. the TTask::Exec function of the derived class; TTask::ExecuteTasks to execute for each task the list of its subtasks. If the top level task (see example below) is added to the list of Root browsable objects, the tree of tasks can be visualized by the Root browser. The browser can be used to start a task, set break points at the beginning of a task or when the task has completed. At a breakpoint, data structures generated by the execution up this point may be inspected asynchronously and then the execution can be resumed by selecting the ""Continue"" function of a task.; A Task may be active or inactive (controlled by TTask::SetActive). When a task is not active, its sub tasks are not executed.; A TTask tree may be made persistent, saving the status of all the tasks.; The Root browser's picture below has been generated by executing the following script: {; TTask *aliroot = new TTask(""aliroot"",""ALICE reconstruction main task"");; TTask *geominit = new TTask(""geomInit"",""Initialize ALICE geometry"");; TTask *matinit = new TTask(""matInit"",""Initialize ALICE materials"");; TTask *physinit = new TTask(""physInit"",""Initialize Physics processes"");; TTask *tracker = new TTask(""tracker"",""Track reconstruction manager"");; TTask *tpcrec = new TTask(""tpcrec"",""TPC reconstruction"");; TTask *itsrec = new TTask(""itsrec"",""ITS reconstruction"");; TTask *muonrec = new TTask(""muonRec"",""Muon Reconstruction"");; TTask *phosrec = new TTask(""phosRec"",""Phos Reconstruction"");; TTask *richre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTask.html:1551,resume,resumed,1551,doc/master/classTTask.html,https://root.cern,https://root.cern/doc/master/classTTask.html,1,['resume'],['resumed']
Usability,"ndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←; TQUndoManager. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. TQCommand & operator=(const TQUndoManager& ). void Add(TObject* obj, Option_t* opt). TQUndoManager(). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:31",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQUndoManager.html:20161,undo,undo,20161,root/html604/TQUndoManager.html,https://root.cern,https://root.cern/root/html604/TQUndoManager.html,1,['undo'],['undo']
Usability,"ndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←; TQUndoManager. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. TQCommand & operator=(const TQUndoManager& ). void Add(TObject* obj, Option_t* opt). TQUndoManager(). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:29",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:20161,undo,undo,20161,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,1,['undo'],['undo']
Usability,"ne 152 of file RInterfaceBase.cxx. ◆ GetColumnType(). std::string ROOT::RDF::RInterfaceBase::GetColumnType ; (; std::string_view ; column). Return the type of a given column as a string. ; Returnsthe type of the required column.; This is not an action nor a transformation, just a query to the RDataFrame object. Example usage:; auto colType = d.GetColumnType(""columnName"");; // Print column type; std::cout << ""Column "" << colType << "" has type "" << colType << std::endl;. Definition at line 197 of file RInterfaceBase.cxx. ◆ GetColumnTypeNamesList(). ROOT::RDF::ColumnNames_t ROOT::RDF::RInterfaceBase::GetColumnTypeNamesList ; (; const ColumnNames_t & ; columnList). protected . Definition at line 407 of file RInterfaceBase.cxx. ◆ GetDefinedColumnNames(). ROOT::RDF::ColumnNames_t ROOT::RDF::RInterfaceBase::GetDefinedColumnNames ; (; ). Returns the names of the defined columns. ; Returnsthe container of the defined column names.; This is not an action nor a transformation, just a simple utility to get the columns names that have been defined up to the node. If no column has been defined, e.g. on a root node, it returns an empty collection. Example usage:; auto defColNames = d.GetDefinedColumnNames();; // Print defined columns' names; for (auto &&defColName : defColNames) std::cout << defColName << std::endl;. Definition at line 309 of file RInterfaceBase.cxx. ◆ GetLoopManager(). RDFDetail::RLoopManager * ROOT::RDF::RInterfaceBase::GetLoopManager ; (; ); const. inlineprotected . Definition at line 128 of file RInterfaceBase.hxx. ◆ GetNFiles(). unsigned int ROOT::RDF::RInterfaceBase::GetNFiles ; (; ). Definition at line 27 of file RInterfaceBase.cxx. ◆ GetNRuns(). unsigned int ROOT::RDF::RInterfaceBase::GetNRuns ; (; ); const. Gets the number of event loops run. ; ReturnsThe number of event loops run by this RDataFrame instance; This method returns the number of events loops run so far by this RDataFrame instance.; Example usage: ROOT::RDataFrame df(1);; std::cout << df.GetNR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html:10005,simpl,simple,10005,doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html,1,['simpl'],['simple']
Usability,"ne 57 of file TEveProjectionManager.h. ◆ GetImportEmpty(). Bool_t TEveProjectionManager::GetImportEmpty ; (; ); const. inline . Definition at line 60 of file TEveProjectionManager.h. ◆ GetProjection(). TEveProjection * TEveProjectionManager::GetProjection ; (; ). inline . Definition at line 49 of file TEveProjectionManager.h. ◆ HandleElementPaste(). Bool_t TEveProjectionManager::HandleElementPaste ; (; TEveElement * ; el). overridevirtual . React to element being pasted or dnd-ed. ; Return true if redraw is needed (virtual method). ; Reimplemented from TEveElement.; Definition at line 172 of file TEveProjectionManager.cxx. ◆ ImportElements(). TEveElement * TEveProjectionManager::ImportElements ; (; TEveElement * ; el, . TEveElement * ; ext_list = nullptr . ). virtual . Recursively import elements and apply projection to the newly imported objects. ; If ext_list is not 0 the new element is also added to the list. This simplifies construction of complex views where projected elements are distributed into several scenes for optimization of updates and rendering.; Returns the projected replica of el. Can be 0, if el and none of its children are projectable. ; Definition at line 279 of file TEveProjectionManager.cxx. ◆ ImportElementsRecurse(). TEveElement * TEveProjectionManager::ImportElementsRecurse ; (; TEveElement * ; el, . TEveElement * ; parent . ). virtual . If el is TEveProjectable add projected instance else add plain TEveElementList to parent. ; Call the same function on el's children.; Returns the projected replica of el. Can be 0, if el and none of its children are projectable. ; Definition at line 225 of file TEveProjectionManager.cxx. ◆ IsA(). TClass * TEveProjectionManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TEveElementList.; Definition at line 77 of file TEveProjectionManager.h. ◆ operator=(). TEveProjectionManager & TEveProjectionManager::operator= ; (; const TEveProjectionManager & ; )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveProjectionManager.html:40047,simpl,simplifies,40047,doc/master/classTEveProjectionManager.html,https://root.cern,https://root.cern/doc/master/classTEveProjectionManager.html,1,['simpl'],['simplifies']
Usability,"ne Brun; *-* comments extracted from the MINUIT documentation file.; -; *. void mnhess(); Calculates the full second-derivative matrix of FCN*-*-; *-* ===================================================; *-* by taking finite differences. When calculating diagonal; *-* elements, it may iterate so that step size is nearly that; *-* which gives function change= UP/10. The first derivatives; *-* of course come as a free side effect, but with a smaller; *-* step size in order to obtain a known accuracy.; *. void mnhes1(); Calculate first derivatives (GRD) and uncertainties (DGRD)*-*-; *-* ==========================================================; *-* and appropriate step sizes GSTEP; *-* Called from MNHESS and MNGRAD; *. void mnimpr(); Attempts to improve on a good local minimum*-*-*-; *-* ===========================================; *-* Attempts to improve on a good local minimum by finding a; *-* better one. The quadratic part of FCN is removed by MNCALF; *-* and this transformed function is minimized using the simplex; *-* method from several random starting points.; *-* ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); *. void mninex(Double_t* pint); -*Transforms from internal coordinates (PINT) to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =======================================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:44781,simpl,simplex,44781,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,6,['simpl'],['simplex']
Usability,"ne containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(; numerator, denominator);; Int_t status = f->Fit(eff, ""I"");; if (status",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBinomialEfficiencyFitter.html:1473,simpl,simply,1473,root/html526/TBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/root/html526/TBinomialEfficiencyFitter.html,7,['simpl'],['simply']
Usability,"ne tries; minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary function.; Approximate value is:; $${\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; Z_{ik}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over; the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; $$; \theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\eqno(7); $$; They form parallelepiped $P$ ($P_0$ may be deformed by $P$).; Very similar step formulae are used in FUMILI for negative logarithm; of the likelihood function with the same idea - linearization of; function argument. Function Members (Methods); public:. TFumili(Int_t maxpar = 25); TFumili(const TFumili&); virtual~TFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildArrays(); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumili.html:3193,simpl,simple,3193,root/html528/TFumili.html,https://root.cern,https://root.cern/root/html528/TFumili.html,4,['simpl'],['simple']
Usability,"ne tries; minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary function.; Approximate value is:; $${\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; Z_{ik}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over; the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; $$; \theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\eqno(7); $$; They form parallelepiped $P$ ($P_0$ may be deformed by $P$).; Very similar step formulae are used in FUMILI for negative logarithm; of the likelihood function with the same idea - linearization of; function argument. Function Members (Methods); public:. virtual~TFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildArrays(); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFumili.html:3193,simpl,simple,3193,root/html602/TFumili.html,https://root.cern,https://root.cern/root/html602/TFumili.html,2,['simpl'],['simple']
Usability,"ne(0.66,0.24,0.66,0.26);; 282 line->Draw();; 283 line = new TLine(0.76,0.24,0.76,0.26);; 284 line->Draw();; 285 line = new TLine(0.86,0.24,0.86,0.26);; 286 line->Draw();; 287 line = new TLine(0.96,0.24,0.96,0.26);; 288 line->Draw();; 289}; c#define c(i)Definition RSha256.hxx:101; kWhite@ kWhiteDefinition Rtypes.h:65; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextAnglevirtual void SetTextAngle(Float_t tangle=0)Set the text angle.Definition TAttText.h:43; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavetext with its current attributes.Definition TPaveText.cxx:242; TPave::SetBorderSizevirtual void SetBorderSize(Int_t bordersize=4)Sets the border size of the TPave box and shadow.Definition TPave.h:77; TTextBase class for several text objects.Definition TText.h:22; lineTLine * lineDefinition entrylistblock_figure1.C:235; ptTPaveText * ptDefinition entrylistblock_figure1.C:7; textTText * textDefinition entrylistblock_figure1.C:9; arrowDefinition RArrowDS.hxx:17. treetreedocmacrosentrylistblock_f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/entrylistblock__figure1_8C_source.html:9889,simpl,simple,9889,doc/master/entrylistblock__figure1_8C_source.html,https://root.cern,https://root.cern/doc/master/entrylistblock__figure1_8C_source.html,1,['simpl'],['simple']
Usability,"ne3D(temp1, temp2);; 6736 temp1[0] = x;; 6737 temp1[1] = y1;; 6738 temp1[2] = z;; 6739 temp2[0] = x;; 6740 temp2[1] = y2;; 6741 temp2[2] = z;; 6742 gPad->PaintLine3D(temp1, temp2);; 6743 temp1[0] = x;; 6744 temp1[1] = y;; 6745 temp1[2] = z1;; 6746 temp2[0] = x;; 6747 temp2[1] = y;; 6748 temp2[2] = z2;; 6749 gPad->PaintLine3D(temp1, temp2);; 6750 temp1[0] = x;; 6751 temp1[1] = y;; 6752 temp1[2] = z;; 6753 view->WCtoNDC(temp1, &temp2[0]);; 6754 gPad->PaintPolyMarker(1, &temp2[0], &temp2[1]);; 6755 }; 6756 }; 6757 ; 6758 // Paint the Front Box if needed; 6759 if (Hoption.FrontBox) {; 6760 fLego->InitMoveScreen(-1.1,1.1);; 6761 fLego->SetDrawFace(&TPainter3dAlgorithms::DrawFaceMove2);; 6762 fLego->FrontBox(90);; 6763 }; 6764 ; 6765 // Paint the Axis if needed; 6766 if (!Hoption.Axis && !Hoption.Same && !Hoption.Lego && !Hoption.Surf) {; 6767 TGaxis axis;; 6768 PaintLegoAxis(&axis, 90);; 6769 }; 6770 ; 6771 fLego.reset();; 6772}; 6773 ; 6774////////////////////////////////////////////////////////////////////////////////; 6775/// Calculate range and clear pad (canvas).; 6776 ; 6777void THistPainter::PaintFrame(); 6778{; 6779 ; 6780 if (Hoption.Same) return;; 6781 ; 6782 RecalculateRange();; 6783 ; 6784 if (Hoption.Lego || Hoption.Surf || Hoption.Tri ||; 6785 Hoption.Contour == 14 || Hoption.Error >= 100) {; 6786 TObject *frame = gPad->FindObject(""TFrame"");; 6787 if (frame) gPad->Remove(frame);; 6788 return;; 6789 }; 6790 ; 6791 //The next statement is always executed on non-iOS platform,; 6792 //on iOS depends on pad mode.; 6793 if (!gPad->PadInSelectionMode() && !gPad->PadInHighlightMode()); 6794 gPad->PaintPadFrame(Hparam.xmin,Hparam.ymin,Hparam.xmax,Hparam.ymax);; 6795}; 6796 ; 6797////////////////////////////////////////////////////////////////////////////////; 6798/// [Paint functions associated to an histogram.](\ref HP28""); 6799 ; 6800void THistPainter::PaintFunction(Option_t *); 6801{; 6802 auto lnk = fFunctions->FirstLink();; 6803 ; 6804 while (lnk) {; 6805 auto o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:247390,clear,clear,247390,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"neC);; 2314 fTabSize.clear();; 2315 fX = xsave;; 2316 fY = ysave;; 2317 if (fError) return 0;; 2318 return 1;; 2319}; 2320 ; 2321////////////////////////////////////////////////////////////////////////////////; 2322/// Check if the Latex syntax is correct; 2323 ; 2324Int_t TLatex::CheckLatexSyntax(TString &text); 2325{; 2326 const Char_t *kWord1[] = {""{}^{"",""{}_{"",""^{"",""_{"",""#scale{"",""#color{"",""#font{"",""#sqrt{"",""#[]{"",""#{}{"",""#||{"",; 2327 ""#bar{"",""#vec{"",""#dot{"",""#hat{"",""#ddot{"",""#acute{"",""#grave{"",""#check{"",""#tilde{"",""#slash{"",""#bf{"",""#it{"",""#mbox{"",; 2328 ""\\scale{"",""\\color{"",""\\font{"",""\\sqrt{"",""\\[]{"",""\\{}{"",""\\||{"",""#(){"",""\\(){"",; 2329 ""\\bar{"",""\\vec{"",""\\dot{"",""\\hat{"",""\\ddot{"",""\\acute{"",""\\grave{"",""\\check{"",""\\bf{"",""\\it{"",""\\mbox{""}; // check for }; 2330 const Char_t *kWord2[] = {""#scale["",""#color["",""#font["",""#sqrt["",""#kern["",""#lower["",""\\scale["",""\\color["",""\\font["",""\\sqrt["",""\\kern["",""\\lower[""}; // check for ]{ + }; 2331 const Char_t *kWord3[] = {""#frac{"",""\\frac{"",""#splitline{"",""\\splitline{""}; // check for }{ then }; 2332 const Char_t *kLeft1[] = {""#left["",""\\left["",""#left{"",""\\left{"",""#left|"",""\\left|"",""#left("",""\\left(""};; 2333 const Char_t *kLeft2[] = {""#[]{"",""#[]{"",""#{}{"",""#{}{"",""#||{"",""#||{"",""#(){"",""#(){""};; 2334 const Char_t *kRight[] = {""#right]"",""\\right]"",""#right}"",""\\right}"",""#right|"",""\\right|"",""#right)"",""\\right)""};; 2335 const Int_t lkWord1[] = {4,4,2,2,7,7,6,6,4,4,4,5,5,5,5,6,7,7,7,7,7,4,4,6,7,7,6,6,4,4,4,4,4,5,5,5,5,6,7,7,7,4,4,6};; 2336 const Int_t lkWord2[] = {7,7,6,6,6,7,7,7,6,6,6,7} ;; 2337 const Int_t lkWord3[] = {6,6,11,11} ;; 2338 Int_t nkWord1 = 44, nkWord2 = 12, nkWord3 = 4;; 2339 Int_t i,k ;; 2340 Int_t nLeft1 , nRight , nOfLeft, nOfRight;; 2341 Int_t lLeft1 = 6 ;; 2342 Int_t lLeft2 = 4 ;; 2343 Int_t lRight = 7 ;; 2344 nLeft1 = nRight = 8 ;; 2345 nOfLeft = nOfRight = 0 ;; 2346 ; 2347 Char_t buf[11] ; for (i=0;i<11;i++) buf[i]=0;; 2348 Bool_t opFound ;; 2349 Int_t opFrac = 0;; 2350 Int_t length = text.Length() ;; 2351 ; 23",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLatex_8cxx_source.html:83321,clear,clear,83321,doc/master/TLatex_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html,1,['clear'],['clear']
Usability,"ned extended likelihood fits (Binned(),Extended()) on data generated; // with a Poisson fluctuation on Nobs (Extended()); RooMCStudy *mcs = new RooMCStudy(model, mjjj, Binned(), Silence(), Extended(true),; FitOptions(Extended(true), PrintEvalErrors(-1)));; ; // C u s t o m i z e m a n a g e r; // ---------------------------------; ; // Add module that randomizes the summed value of nsig+nbkg; // sampling from a uniform distribution between 0 and 1000; //; // In general one can randomize a single parameter, or a; // sum of N parameters, using either a uniform or a Gaussian; // distribution. Multiple randomization can be executed; // by a single randomizer module; ; RooRandomizeParamMCSModule randModule;; randModule.sampleSumUniform(RooArgSet(nsig, nbkg), 50, 500);; mcs->addModule(randModule);; ; // Add profile likelihood calculation of significance. Redo each; // fit while keeping parameter nsig fixed to zero. For each toy,; // the difference in -log(L) of both fits is stored, as well; // a simple significance interpretation of the delta(-logL); // using Dnll = 0.5 sigma^2; ; RooDLLSignificanceMCSModule sigModule(nsig, 0);; mcs->addModule(sigModule);; ; // R u n m a n a g e r , m a k e p l o t s; // ---------------------------------------------; ; // Run 1000 experiments. This configuration will generate a fair number; // of (harmless) MINUIT warnings due to the instability of the Chebychev polynomial fit; // at low statistics.; mcs->generateAndFit(500);; ; // Make some plots; TH1 *dll_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,dll_nullhypo_nsig"", AutoBinning(40), AutoBinning(40));; TH1 *z_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,significance_nullhypo_nsig"", AutoBinning(40), AutoBinning(40));; TH1 *errnsig_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,nsigerr"", AutoBinning(40), AutoBinning(40));; TH1 *errnsig_vs_nsig = mcs->fitParDataSet().createHistogram(""nsig,nsigerr"", AutoBinning(40), AutoBinning(40));; ; // Draw plots on canvas; TCanva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html:2817,simpl,simple,2817,doc/master/rf803__mcstudy__addons2_8C.html,https://root.cern,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html,1,['simpl'],['simple']
Usability,"neralLayer< Architecture_t >::SetInputWidth ; (; size_t ; inputWidth). inline . Definition at line 220 of file GeneralLayer.h. ◆ SetIsTraining(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetIsTraining ; (; bool ; isTraining). inline . Definition at line 224 of file GeneralLayer.h. ◆ SetWidth(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetWidth ; (; size_t ; width). inline . Definition at line 223 of file GeneralLayer.h. ◆ Update(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::Update ; (; const Scalar_t ; learningRate). Updates the weights and biases, given the learning rate. ; Definition at line 410 of file GeneralLayer.h. ◆ UpdateBiases(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiases ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the biases, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:25655,learn,learning,25655,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learning']
Usability,"neralized as follows:. Opening of the connection to the system; Definition of main frame (top level window); Creation of widgets as children of the top-level frame; assign them desired properties following the steps:; Create a new widget passing its parent in the constructor; Connect widget’s signals with desired slots to ensure desired functionality; Define widget’s layout and add it to the parent list of children; Set main window attributes; Map all sub windows; Initialize the layout algorithm via Resize(GetDefaultSize()) method; Map the main frame; Execution of the even-processing loop. 25.4.1 A Standalone Version; As usual a standalone program in C++ has to contain a main() function - the starting point for the application execution. In this case it is better to separate the program code creating a program header file example2a.h with the MyMainFrame class declaration and example2a.cxx- with the class methods implementation. To run our simple example as a standalone application we need to create in addition an object of class TApplication. It will make a correct initialization of the dictionaries if it is not yet done. It will be responsible for holding everything together and to handle all events in the application. Its environment provides an interface to the ROOT graphics system and by calling the Run() method the event loop starts and the application program is waiting for the user action. The application exits only if the top level window is not closed. Two header files are used in addition: TApplication.h - for the class TApplication and TGClient.h that is used to make initial connection to the graphics system. The class TApplication must be instantiated only once in any given application. The original list of argument options can be retrieved via the Argc() and Argv() methods.; Note: to have signals/slots working we need to create a dictionary for the class MyMainFrame, i.e. we create the file ex2aLinkDef.h containing the line:; #pragma link C++ class MyMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1142152,simpl,simple,1142152,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"nes that we have already created.; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; The 2 nodes that we have created inside chamber will both point to a wire_co object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeller is smarter than that and creates for each volume some optimization structures called voxels to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway lose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation: instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.; Volume Families; A volume family is represented by the class TGeoVolumeMulti. It rep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:41866,simpl,simple,41866,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"nestatic . ReturnsName of the file containing the class declaration ; Definition at line 58 of file TMLPAnalyzer.h. ◆ DrawDInput(). void TMLPAnalyzer::DrawDInput ; (; Int_t ; i). Draws the distribution (on the test sample) of the impact on the network output of a small variation of the ith input. ; Definition at line 284 of file TMLPAnalyzer.cxx. ◆ DrawDInputs(). void TMLPAnalyzer::DrawDInputs ; (; ). Draws the distribution (on the test sample) of the impact on the network output of a small variation of each input. ; DrawDInputs() draws something that approximates the distribution of the derivative of the NN w.r.t. each input. That quantity is recognized as one of the measures to determine key quantities in the network.; What is done is to vary one input around its nominal value and to see how the NN changes. This is done for each entry in the sample and produces a distribution.; What you can learn from that is:; is variable a really useful, or is my network insensitive to it ?; is there any risk of big systematic ? Is the network extremely sensitive to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve as input for an ""educated guess"" when optimizing the network. ; Definition at line 311 of file TMLPAnalyzer.cxx. ◆ DrawNetwork(). void TMLPAnalyzer::DrawNetwork ; (; Int_t ; neuron, . const char * ; signal, . const char * ; bg . ). Draws the distribution of the neural network (using ith neuron). ; Two distributions are drawn, for events passing respectively the ""signal"" and ""background"" cuts. Only the test sample is used. ; Definition at line 337 of file TMLPAnalyzer.cxx. ◆ DrawTruthDeviation(). TProfile * TMLPAnalyzer::DrawTruthDeviation ; (; Int_t ; outnode = 0, . Option_t * ; option = """" . ). Create a profile of the difference of the MLP output minus the true value for a given output node outnode, vs the true value for outnode, for all test data events. ; This method is mainly useful when doing regress",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMLPAnalyzer.html:14457,learn,learn,14457,doc/master/classTMLPAnalyzer.html,https://root.cern,https://root.cern/doc/master/classTMLPAnalyzer.html,1,['learn'],['learn']
Usability,"nestaticconstexpr . ReturnsVersion of this class ; Definition at line 146 of file TUnfoldSys.h. ◆ ClearResults(). void TUnfoldSys::ClearResults ; (; void ; ). overrideprotectedvirtual . Clear all data members which depend on the unfolding results. ; Reimplemented from TUnfold.; Definition at line 650 of file TUnfoldSys.cxx. ◆ DeclFileName(). static const char * TUnfoldSys::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 146 of file TUnfoldSys.h. ◆ DoBackgroundSubtraction(). void TUnfoldSys::DoBackgroundSubtraction ; (; void ; ). protected . perform background subtraction ; This prepares the data members for the base class TUnfold, such that the background is properly taken into account. ; Definition at line 377 of file TUnfoldSys.cxx. ◆ GetBackground(). void TUnfoldSys::GetBackground ; (; TH1 * ; bgrHist, . const char * ; bgrSource = nullptr, . const Int_t * ; binMap = nullptr, . Int_t ; includeError = 3, . Bool_t ; clearHist = kTRUE . ); const. get background into a histogram ; Parameters. [in,out]bgrHisttarget histogram, content and errors will be altered ; [in]bgrSource(default=nullptr) name of backgrond source or zero to add all sources of background ; [in]binMap(default=nullptr) remap histogram bins ; [in]includeError(default=3) include uncorrelated(1), correlated (2) or both (3) sources of uncertainty in the histogram errors ; [in]clearHist(default=true) reset histogram before adding up the specified background sources. the array binMap is explained with the method GetOutput(). The flag clearHist may be used to add background from several sources in successive calls to GetBackground(). ; Definition at line 565 of file TUnfoldSys.cxx. ◆ GetBgrSources(). TSortedList * TUnfoldSys::GetBgrSources ; (; void ; ); const. Get a new list of all background sources. ; The user is responsible for deleting the list get list of name of background sources ; Definition at line 1528 of file TUnfoldSys.cxx. ◆ GetCh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:33861,clear,clearHist,33861,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearHist']
Usability,"net. ;  ; Scalar_t fRho;  The Rho constant used by the optimizer. ;  ; std::vector< std::vector< Matrix_t > > fWeightUpdates;  The accumulation of the past Weights for performing updates. ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor1;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor2;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor1;  working tensor used to keep a temporary copy of weights or weight gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor2;  working tensor used to keep a temporary copy of weights or weight gradients ;  ;  Protected Attributes inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scalar_t fLearningRate;  The learning rate used for training. ;  . #include <TMVA/DNN/RMSProp.h>. Inheritance diagram for TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Matrix_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 47 of file RMSProp.h. ◆ Scalar_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 48 of file RMSProp.h. Constructor & Destructor Documentation. ◆ TRMSProp(). template<typename Architecture_t , typename Layer_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html:4479,learn,learning,4479,doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,1,['learn'],['learning']
Usability,"new TGDoubleVSlider(p,100,kDoubleScaleNo,dsliderID);; vDslider->SetRange(-10,10);; 25.8.9 Triple Slider; The new TGTripleHSlider and TGTripleVSlider classes inherit from the double slider widgets and allow easy selection of a range and a pointer value. The pointer position can be constrained into the selected range or can be relative to it. To change the slider range value press the left mouse button near to the left/right (top/bottom) edges of the slider. To change both values simultaneously press the mouse button near to the slider center. To change pointer value press the mouse on the pointer and drag it to the desired position.; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; 25.8.10 Progress Bars; A progress bar is a widget that shows that an operation is in progress and how much time is left. It is a long rectangular bar, initially empty, that fills with a color as a process is being performed. The filled-in area indicates the percentage of the process that has been completed. You should use this widget for waits exceeding one minute. For a very time consuming operation it is better to break the operation into subtasks and provide a progress bar for each of them. A progress bar may be oriented horizontally or vertically. The horizontally oriented progress bar fills with a color from left to right; the vertically oriented - from bottom to top. A percent complete message provides an indication of the completed part of the process. It is a good practice to include some descriptive text of the process to keep users informed and entertained while they are waiting for process completion.; The picture below shows the progress bars you can create using the classes TGProgressBar, TGHProgressBar, and TGHProgressBar.; // vertic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1207689,progress bar,progress bar,1207689,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['progress bar'],['progress bar']
Usability,"new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");. return cst1;; }; Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the; ""Front Box"" and ""Back Box"" around the plot. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THistPainter.html:69621,simpl,simply,69621,root/html532/THistPainter.html,https://root.cern,https://root.cern/root/html532/THistPainter.html,4,['simpl'],['simply']
Usability,"nextel->GetType() == TStreamerInfo::kCacheDelete ) {; 2439 continue;; 2440 }; 2441 // NOTE: We should verify that the rule's source are 'before'; 2442 // or 'at' this branch.; 2443 // fprintf(stderr,""%s/%d[%zu] pushd %zu %s\n"",GetName(),fID,fIDs.size(),i,nextel->GetName());; 2444 fNewIDs.push_back(i);; 2445 fNewIDs.back().fElement = nextel;; 2446 fNewIDs.back().fInfo = fInfo;; 2447 }; 2448 } else if (elt && offset==TStreamerInfo::kMissing) {; 2449 // Still re-assign fID properly.; 2450 fNewIDs.clear();; 2451 size_t ndata = fInfo->GetNelement();; 2452 for (size_t i = 0; i < ndata; ++i) {; 2453 if (fInfo->GetElement(i) == elt) {; 2454 fID = i;; 2455 break;; 2456 }; 2457 }; 2458 } else {; 2459 // We have not even found the element .. this is strange :(; 2460 // fNewIDs.clear();; 2461 // fID = -3;; 2462 // SetBit(kDoNotProcess);; 2463 }; 2464 if (fOnfileObject==nullptr && (fType==31 || fType==41 || (0 <= fType && fType <=2) ) && fInfo->GetNelement(); 2465 && fInfo->GetElement(0)->GetType() == TStreamerInfo::kCacheNew); 2466 {; 2467 SetOnfileObject(fInfo);; 2468 }; 2469 }; 2470 if (fType == 3 || fType == 4 || (fType == 0 && fID == -2) || fType == 2) {; 2471 // Need to add the rule targeting transient members.; 2472 TStreamerInfo *localInfo = fInfo;; 2473 if (fType == 3 || fType == 4) {; 2474 // Don't we have real version information?; 2475 // Not unless there is a subbranch with a non-split element of the class.; 2476 // Search for the correct version.; 2477 localInfo = FindOnfileInfo(fClonesClass, fBranches);; 2478 }; 2479 ; 2480 TString prefix(GetFullName());; 2481 if (fType == 2 && fID >= 0) {; 2482 auto start = prefix.Length();; 2483 if (prefix[start - 1] == '.'); 2484 --start;; 2485 std::string_view view(prefix.Data(), start);; 2486 auto cutoff = view.find_last_of('.');; 2487 if (cutoff != std::string::npos) {; 2488 prefix.Remove(cutoff + 1);; 2489 }; 2490 }; 2491 if (prefix[prefix.Length()-1] != '.') {; 2492 if (fType == 3 || fType == 4 || prefix.Index('.') != TStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:88001,clear,clear,88001,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['clear'],['clear']
Usability,"nfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::Fitter::EvalFCNbool EvalFCN()Perform a simple FCN evaluation.Definition Fitter.cxx:288; ROOT::Fit::Fitter::fExtObjFunctionconst ROOT::Math::IMultiGenFunction * fExtObjFunction! pointer to an external FCNDefinition Fitter.h:576; ROOT::Fit::Fitter::FitFCNbool FitFCN()Perform a fit with the previously set FCN function.Definition Fitter.cxx:269; ROOT::Fit::Fitter::DoUpdateFitConfigvoid DoUpdateFitConfig()Definition Fitter.cxx:860; ROOT::Fit::Fitter::DoMinimizationbool DoMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)do minimizationDefinition Fitter.cxx:836; ROOT::Fit::Fitter::DoSetFCNbool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize, int fitType)Set Objective function.Definition Fitter.cxx:137; ROOT::Fit::Fitter::fDataSizeint fDataSizesize of data sets (need for Fumili or LM fitters)Definition Fitter.h:560; ROOT::Fit::Fitter::DoUnbinnedLikelihoodFitbool DoUnbinnedLikelihoodFit(bool extended=false",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:43833,simpl,simple,43833,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['simpl'],['simple']
Usability,"nfo : [dataset] : Added class ""Background""; : Add Tree bkg_tree of type Background with 10000 events; ; ; ; **/; ; /****; # Booking Methods; ; Here we book the TMVA methods. We book a Boosted Decision Tree method (BDT); ; **/; ; // Boosted Decision Trees; if (useTMVABDT) {; factory.BookMethod(&loader, TMVA::Types::kBDT, ""BDT"",; ""!V:NTrees=200:MinNodeSize=2.5%:MaxDepth=2:BoostType=AdaBoost:AdaBoostBeta=0.5:""; ""UseBaggedBoost:BaggedSampleFraction=0.5:SeparationType=GiniIndex:nCuts=20"");; }; /**; ; #### Booking Deep Neural Network; ; Here we book the DNN of TMVA. See the example TMVA_Higgs_Classification.C for a detailed description of the; options; ; **/; ; if (useTMVADNN) {; ; TString layoutString(; ""Layout=DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR"");; ; // Training strategies; // one can catenate several training strings with different parameters (e.g. learning rates or regularizations; // parameters) The training string must be concatenates with the `|` delimiter; TString trainingString1(""LearningRate=1e-3,Momentum=0.9,Repetitions=1,""; ""ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,""; ""MaxEpochs=10,WeightDecay=1e-4,Regularization=None,""; ""Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0."");; ; TString trainingStrategyString(""TrainingStrategy="");; trainingStrategyString += trainingString1; // + ""|"" + trainingString2 + ....; ; // Build now the full DNN Option string; ; TString dnnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:""; ""WeightInitialization=XAVIER"");; dnnOptions.Append("":"");; dnnOptions.Append(layoutString);; dnnOptions.Append("":"");; dnnOptions.Append(trainingStrategyString);; ; TString dnnMethodName = ""TMVA_DNN_CPU"";; // use GPU if available; #ifdef R__HAS_TMVAGPU; dnnOptions += "":Architecture=GPU"";; dnnMethodName = ""TMVA_DNN_GPU"";; #elif defined(R__HAS_TMVACPU); dnnOptions += "":Architecture=CPU"";; #endif; ; factory.BookMethod(&loader, TMVA::Types::kDL, dnnMethodName, dnnOptions);; }; ; /***; ### B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:54390,learn,learning,54390,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['learn'],['learning']
Usability,"nfo; Int_tfSVNRev; TGLabel*fSelector; TStringfSessionUrl; TGCheckButton*fSmoothSpeedouse smooth speedometer update; TGSpeedo*fSpeedospeedometer; Bool_tfSpeedoEnabledwhether to enable the speedometer; TTimefStartTime; TProofProgressDialog::EQueryStatusfStatus; TGTextButton*fStop; TGTextBuffer*fTextQuery; TGLabel*fTimeLab; TGLabel*fTitleLab; TGraph*fTotSGraph; TGLabel*fTotal; TGTextButton*fUpdtSpeedo; static Bool_tfgKeepDefault; static Bool_tfgLogQueryDefault; static TStringfgTextQueryDefault. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); Create PROOF processing progress dialog. void ToggleOdometerInfos(); Toggle information displayed in Analog Meter. void ToggleThreshold(). void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle but",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressDialog.html:3651,progress bar,progress bar,3651,root/html528/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html528/TProofProgressDialog.html,4,['progress bar'],['progress bar']
Usability,"nformation and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; 1086for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis.; 1087 ; 1088\anchor rnode; 1089### RDataFrame objects as function arguments and return values; 1090RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); 1091functions and to return them from functions. However, in general each dataframe node will have a different C++ type,; 1092which includes all available compile-time information about what that node does. One way to cope with this complication; 1093is to use template functions and/or C++14 auto return types:; 1094~~~{.cpp}; 1095template <typename RDF>; 1096auto ApplySomeFilters(RDF df); 1097{; 1098 return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; 1099}; 1100~~~; 1101 ; 1102A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; 1103converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; 1104~~~{.cpp}; 1105// a function that conditionally adds a Range to an RDataFrame node.; 1106RNode MaybeAddRange(RNode df, bool mustAddRange); 1107{; 1108 return mustAddRange ? df.Range(1) : df;; 1109}; 1110// use as :; 1111ROOT::RDataFrame df(10);; 1112auto maybeRangedDF = MaybeAddRange(df, true);; 1113~~~; 1114 ; 1115The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; 1116loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`.; 1117 ; 1118\anchor RDFCollections; 1119### Storing RDataFrame objects in collections; 1120 ; 1121ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:; 1122 ; 1123~~~{.cp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:64650,simpl,simpler,64650,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simpler']
Usability,"nformation and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; 1126for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis.; 1127 ; 1128\anchor rnode; 1129### RDataFrame objects as function arguments and return values; 1130RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); 1131functions and to return them from functions. However, in general each dataframe node will have a different C++ type,; 1132which includes all available compile-time information about what that node does. One way to cope with this complication; 1133is to use template functions and/or C++14 auto return types:; 1134~~~{.cpp}; 1135template <typename RDF>; 1136auto ApplySomeFilters(RDF df); 1137{; 1138 return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; 1139}; 1140~~~; 1141 ; 1142A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; 1143converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; 1144~~~{.cpp}; 1145// a function that conditionally adds a Range to an RDataFrame node.; 1146RNode MaybeAddRange(RNode df, bool mustAddRange); 1147{; 1148 return mustAddRange ? df.Range(1) : df;; 1149}; 1150// use as :; 1151ROOT::RDataFrame df(10);; 1152auto maybeRangedDF = MaybeAddRange(df, true);; 1153~~~; 1154 ; 1155The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; 1156loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`.; 1157 ; 1158\anchor RDFCollections; 1159### Storing RDataFrame objects in collections; 1160 ; 1161ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:; 1162 ; 1163~~~{.cp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:66330,simpl,simpler,66330,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['simpl'],['simpler']
Usability,"ng SHOw XXXX command."");; 3912 Printf("" In addition, the SHOw commands listed starting here have no"");; 3913 Printf("" corresponding SET command for obvious reasons."");; 3914 ; 3915 Printf("" "");; 3916 Printf("" SHOw CORrelations"");; 3917 Printf("" Calculates and prints the parameter correlations from the"");; 3918 Printf("" error matrix."");; 3919 ; 3920 Printf("" "");; 3921 Printf("" SHOw COVariance"");; 3922 Printf("" Prints the (external) covariance (error) matrix."");; 3923 ; 3924 Printf("" "");; 3925 Printf("" SHOw EIGenvalues"");; 3926 Printf("" Calculates and prints the eigenvalues of the covariance"");; 3927 Printf("" matrix."");; 3928 ; 3929 Printf("" "");; 3930 Printf("" SHOw FCNvalue"");; 3931 Printf("" Prints the current value of FCN."");; 3932 goto L99;; 3933 }; 3934//______________________________________________________________________________; 3935//; 3936// Command SIMPLEX; 3937//; 3938 if( !strncmp(comd.Data(),""SIM"",3) ) {; 3939 Printf("" ***>SIMplex [maxcalls] [tolerance]"");; 3940 Printf("" Performs a function minimization using the simplex method of"");; 3941 Printf("" Nelder and Mead. Minimization terminates either when the"");; 3942 Printf("" function has been called (approximately) [maxcalls] times,"");; 3943 Printf("" or when the estimated vertical distance to minimum (EDM) is"");; 3944 Printf("" less than [tolerance]."");; 3945 Printf("" The default value of [tolerance] is 0.1*UP(see SET ERRordef)."");; 3946 goto L99;; 3947 }; 3948//______________________________________________________________________________; 3949//; 3950// Command STANDARD; 3951//; 3952 if( !strncmp(comd.Data(),""STA"",3) ) {; 3953 Printf("" ***>STAndard"");; 3954 goto L99;; 3955 }; 3956//______________________________________________________________________________; 3957//; 3958// Command STOP; 3959//; 3960 if( !strncmp(comd.Data(),""STO"",3) ) {; 3961 Printf("" ***>STOP"");; 3962 Printf("" Same as EXIT."");; 3963 goto L99;; 3964 }; 3965//______________________________________________________________________________; 39",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:132489,simpl,simplex,132489,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['simpl'],['simplex']
Usability,"ng a class description of each version of the class that was ever written to disk, with the class. When it writes an object to file, it also writes the description of the current class version along with it. This description is implemented in the StreamerInfoclass.; 11.5.1 The TStreamerInfo Class; Each class has a list of StreamerInfo objects, one for each version of the class if that version was written to disk at least once. When reading an object from a file, the system uses the StreamerInfo list to decode an object into the current version. The StreamerInfo is made up of TStreamerElements . Each describes one persistent data member of the class. By default, all data members of a class are persistent. To exclude a data member (i.e. make it not persistent), add a “!” after the comment marks. For example the pointer *fPainter of a TH1 is not persistent:; TVirtualHistPainter* fPainter //!pointer to histogram painter; 11.5.2 The TStreamerElement Class; A TStreamerElement describes a data member of a simple type, object, array, pointer, or container. The offset in the TStreamerElement is the starting address of the data for that data member.; BASE TNamed offset= 0 type=67 The basis for a named object; BASE TAttLine offset= 28 type= 0 Line attributes; In this example, the TNamed data starts at byte 0, and TAttLine starts at byte 28. The offset is machine and compiler dependent and is computed when the StreamerInfo is analyzed. The types are defined in the file TStreamerInfo.h and listed here:; enum EReadWrite {; kBase=0, kChar=1,kShort=2,kInt=3,kLong=4,; kFloat=5, kCounter=6,kCharStar=7, kDouble=8,kUChar=11,; kUShort=12, kUInt=13,kULong=14,kBits=15,kOffsetL=20,; kOffsetP=40, kObject=61,kAny=62,kObjectp=63,kObjectP=64,; kTString=65, kTObject=66,kTNamed=67,kSkip=100,kSkipL=120,; kSkipP=140, kConv=200, kConvL=220,kConvP=240,kStreamer=500,; kStreamLoop=501, kMissing=99999; };; The method TClass::GetStreamerInfo analyzes the StreamerInfo the same way it would be analyzed by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:492756,simpl,simple,492756,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"ng and draw on top of it the; 428option `SAME` should be use. The histogram drawn with the option; 429`SAME` uses the coordinates system available in the current pad.; 430 ; 431This option can be used alone or combined with any valid drawing option but; 432some combinations must be use with care.; 433 ; 434\anchor HP060a; 435#### Limitations; 436 ; 437- It does not work when combined with the `LEGO` and `SURF` options unless the; 438 histogram plotted with the option `SAME` has exactly the same; 439 ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; 440 lego plots [histograms' stacks](\ref HP26) should be used.; 441 ; 442 ; 443\anchor HP061; 444### Colors automatically picked in palette; 445 ; 446\since **ROOT version 6.09/01**; 447 ; 448When several histograms are painted in the same canvas thanks to the option ""SAME""; 449or via a `THStack` it might be useful to have an easy and automatic way to choose; 450their color. The simplest way is to pick colors in the current active color; 451palette. Palette coloring for histogram is activated thanks to the options `PFC`; 452(Palette Fill Color), `PLC` (Palette Line Color) and `PMC` (Palette Marker Color).; 453When one of these options is given to `TH1::Draw` the histogram get its color; 454from the current color palette defined by `gStyle->SetPalette(...)`. The color; 455is determined according to the number of objects having palette coloring in; 456the current pad.; 457 ; 458Begin_Macro(source); 459../../../tutorials/hist/histpalettecolor.C; 460End_Macro; 461 ; 462Begin_Macro(source); 463../../../tutorials/hist/thstackpalettecolor.C; 464End_Macro; 465 ; 466Begin_Macro(source); 467../../../tutorials/hist/thstack2palettecolor.C; 468End_Macro; 469 ; 470\anchor HP06; 471### Superimposing two histograms with different scales in the same pad; 472 ; 473 ; 474The following example creates two histograms, the second histogram is the bins; 475integral of the first one. It shows a procedure to draw the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:22177,simpl,simplest,22177,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['simpl'],['simplest']
Usability,"ng and pressing Enter at the end.; Another way is from the right panel context menu : ExecuteCommand. All commands can be interrupted at any time by pressing the STOP button from the bottom-left You can toggle recording of the current command in the history file by checking the Rec button from the top-right. Context menus; You can activate context menus by right-clicking on items or inside the right panel.; Context menus for mapped items from the left tree-type list : The items from the left that are provided with context menus are tree and branch items. You can directly activate the MENU marked methods of TTree from this menu.; Context menu for the right panel:; A general context menu is activated if the user right-clicks the right panel.; Commands are :; EmptyAll : clears the content of all expressions;; ExecuteCommand : execute a ROOT command;; MakeSelector : equivalent of TTree::MakeSelector();; NewExpression : add an expression item in the right panel;; Process : equivalent of TTree::Process();; SaveSource : save the current session as a C++ macro;; SetScanFileName : define a name for the file where TTree::Scan command is redirected when the <Scan> button is checked;; SetTreeName : open a new tree with this name in the viewer;. A specific context menu is activated if expressions/leaves are right-clicked.; Commands are :; Draw : draw a histogram for this item;; EditExpression : pops-up the expression editor;; Empty : empty the name and alias of this item;; RemoveItem : removes clicked item from the list;; Scan : scan this expression;; SetExpression : edit name and alias for this item by hand;. Starting the viewer. From the TBrowser: Select a tree in the TBrowser, then call the StartViewer() method from its context menu (right-click on the tree).; From the command line: Start a ROOT session in the directory where you have your tree. You will need first to load the library for TTreeViewer and optionally other libraries for user defined classes (you can do this late",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeViewer.html:5980,clear,clears,5980,doc/master/classTTreeViewer.html,https://root.cern,https://root.cern/doc/master/classTTreeViewer.html,1,['clear'],['clears']
Usability,ng how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlcreatedb.py Create a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlfilldb.py Fill run catalog with nfiles entries ;  SQLiteIPLocation.C ;  SQLitePlatformDistribution.C ;  SQLiteTimeVersionOfRoot.C ;  SQLiteVersionsOfRoot.C ;  sqlselect.CQuery example to MySQL test database ;  sqlselect.py Query example to MySQL test database ;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVACrossValidationApplication.C This macro provides an example of how to use TMVA for k-folds cros,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:164475,simpl,simple,164475,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"ng loss. ;  . #include <TMVA/DNN/DLMinimizers.h>; Member Typedef Documentation. ◆ DeepNet_t. template<typename Architecture_t > . using TMVA::DNN::TDLGradientDescent< Architecture_t >::DeepNet_t = TDeepNet<Architecture_t>. Definition at line 67 of file DLMinimizers.h. ◆ Matrix_t. template<typename Architecture_t > . using TMVA::DNN::TDLGradientDescent< Architecture_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 69 of file DLMinimizers.h. ◆ Scalar_t. template<typename Architecture_t > . using TMVA::DNN::TDLGradientDescent< Architecture_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 68 of file DLMinimizers.h. Constructor & Destructor Documentation. ◆ TDLGradientDescent() [1/2]. template<typename Architecture_t > . TMVA::DNN::TDLGradientDescent< Architecture_t >::TDLGradientDescent. Definition at line 163 of file DLMinimizers.h. ◆ TDLGradientDescent() [2/2]. template<typename Architecture_t > . TMVA::DNN::TDLGradientDescent< Architecture_t >::TDLGradientDescent ; (; Scalar_t ; learningRate, . size_t ; convergenceSteps, . size_t ; testInterval . ). Definition at line 172 of file DLMinimizers.h. Member Function Documentation. ◆ GetConvergenceCount(). template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetConvergenceCount ; (; ); const. inline . Getters. ; Definition at line 146 of file DLMinimizers.h. ◆ GetConvergenceSteps(). template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetConvergenceSteps ; (; ); const. inline . Definition at line 147 of file DLMinimizers.h. ◆ GetTestError(). template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetTestError ; (; ); const. inline . Definition at line 149 of file DLMinimizers.h. ◆ GetTestInterval(). template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetTestInterval ; (; ); const. inline . Definition at line 150 of file DLMi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:4832,learn,learningRate,4832,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,1,['learn'],['learningRate']
Usability,"ng result induced by varying the normalisation of the identified background by one sigma. ; the array binMap is explained with the method GetOutput(). ; Definition at line 1086 of file TUnfoldSys.cxx. ◆ GetEmatrixFromVyy(). void TUnfoldSys::GetEmatrixFromVyy ; (; const TMatrixDSparse * ; vyy, . TH2 * ; ematrix, . const Int_t * ; binMap, . Bool_t ; clearEmat . ). protected . propagate an error matrix on the input vector to the unfolding result ; Parameters. [in]vyyinput error matrix ; [in,out]ematrixhistogram to be updated ; [in]binMapmapping of histogram bins ; [in]clearEmatif set, clear histogram before adding this covariance contribution . Definition at line 1250 of file TUnfoldSys.cxx. ◆ GetEmatrixInput(). void TUnfoldSys::GetEmatrixInput ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from input measurement uncertainties ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the uncertainties or covariance of the input data. In many cases, these are the ""statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1207 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundScale(). void TUnfoldSys::GetEmatrixSysBackgroundScale ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background normalisation uncertainty ; Parameters. [in,out]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram prior to adding the covariance matrix contribution. this metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:37831,clear,clearEmat,37831,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,2,['clear'],"['clear', 'clearEmat']"
Usability,"ng verbose and debug flag appropriately ; Definition at line 510 of file MethodANNBase.cxx. ◆ PrintNetwork(). void TMVA::MethodANNBase::PrintNetwork ; (; ); const. virtual . print network representation, for debugging ; Definition at line 533 of file MethodANNBase.cxx. ◆ PrintNeuron(). void TMVA::MethodANNBase::PrintNeuron ; (; TNeuron * ; neuron); const. private . print a neuron, for debugging ; Definition at line 573 of file MethodANNBase.cxx. ◆ ProcessOptions(). void TMVA::MethodANNBase::ProcessOptions ; (; ). virtual . do nothing specific at this moment ; Implements TMVA::MethodBase.; Reimplemented in TMVA::MethodMLP.; Definition at line 157 of file MethodANNBase.cxx. ◆ ReadWeightsFromStream() [1/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; std::istream & ; ). virtual . Implements TMVA::MethodBase. ◆ ReadWeightsFromStream() [2/3]. void TMVA::MethodANNBase::ReadWeightsFromStream ; (; std::istream & ; istr). virtual . destroy/clear the network then read it back in from the weights file ; Implements TMVA::MethodBase.; Definition at line 889 of file MethodANNBase.cxx. ◆ ReadWeightsFromStream() [3/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; TFile & ; ). inlinevirtual . Reimplemented from TMVA::MethodBase.; Definition at line 266 of file MethodBase.h. ◆ ReadWeightsFromXML(). void TMVA::MethodANNBase::ReadWeightsFromXML ; (; void * ; wghtnode). virtual . read MLP from xml weight file ; Implements TMVA::MethodBase.; Definition at line 767 of file MethodANNBase.cxx. ◆ SetActivation(). void TMVA::MethodANNBase::SetActivation ; (; TActivation * ; activation). inline . Definition at line 83 of file MethodANNBase.h. ◆ SetNeuronInputCalculator(). void TMVA::MethodANNBase::SetNeuronInputCalculator ; (; TNeuronInput * ; inputCalculator). inline . Definition at line 87 of file MethodANNBase.h. ◆ Streamer(). virtual void TMVA::MethodANNBase::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::MethodBase.; Reimplemented in TMVA::Metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html:41547,clear,clear,41547,doc/master/classTMVA_1_1MethodANNBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html,1,['clear'],['clear']
Usability,"ng(), methodTitle);; 2570 importances[ny] += SROC - SSROC;; 2571 // std::cout << ""SubSeed: "" << y << "" y:"" << ybitset << "" x-y "" << x - y << "" "" << std::bitset<32>(x - y) <<; 2572 // "" ny "" << ny << "" SROC "" << SROC << "" SSROC "" << SSROC << "" Importance = "" << importances[ny] <<; 2573 // std::endl; cleaning information; 2574 TMVA::MethodBase *ssmethod =; 2575 dynamic_cast<TMVA::MethodBase *>(fMethodsMap[ybitset.to_string().c_str()][0][0]);; 2576 TMVA::ResultsClassification *ssresults = (TMVA::ResultsClassification *)ssmethod->Data()->GetResults(; 2577 ssmethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2578 delete ssresults;; 2579 delete subseedloader;; 2580 this->DeleteAllMethods();; 2581 fMethodsMap.clear();; 2582 }; 2583 }; 2584 }; 2585 std::cout << ""--- Variable Importance Results (Random)"" << std::endl;; 2586 return GetImportance(nbits, importances, varNames);; 2587}; 2588 ; 2589////////////////////////////////////////////////////////////////////////////////; 2590 ; 2591TH1F *TMVA::Factory::GetImportance(const int nbits, std::vector<Double_t> importances, std::vector<TString> varNames); 2592{; 2593 TH1F *vih1 = new TH1F(""vih1"", """", nbits, 0, nbits);; 2594 ; 2595 gStyle->SetOptStat(000000);; 2596 ; 2597 Float_t normalization = 0.0;; 2598 for (int i = 0; i < nbits; i++) {; 2599 normalization = normalization + importances[i];; 2600 }; 2601 ; 2602 Float_t roc = 0.0;; 2603 ; 2604 gStyle->SetTitleXOffset(0.4);; 2605 gStyle->SetTitleXOffset(1.2);; 2606 ; 2607 std::vector<Double_t> x_ie(nbits), y_ie(nbits);; 2608 for (Int_t i = 1; i < nbits + 1; i++) {; 2609 x_ie[i - 1] = (i - 1) * 1.;; 2610 roc = 100.0 * importances[i - 1] / normalization;; 2611 y_ie[i - 1] = roc;; 2612 std::cout << ""--- "" << varNames[i - 1] << "" = "" << roc << "" %"" << std::endl;; 2613 vih1->GetXaxis()->SetBinLabel(i, varNames[i - 1].Data());; 2614 vih1->SetBinContent(i, roc);; 2615 }; 2616 TGraph *g_ie = new TGraph(nbits + 2, &x_ie[0], &y_ie[0]);; 2617 g_ie->SetTitle("""");; 2618 ; 261",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:106931,clear,clear,106931,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['clear'],['clear']
Usability,"ng...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; TTabCom Class Reference. . Definition at line 52 of file TTabCom.h. Public Types; enum  { kDebug = 17; };  ; enum  EContext_t { ;   kUNKNOWN_CONTEXT =-1; , kSYS_UserName; , kSYS_EnvVar; , kCINT_stdout; , ;   kCINT_stderr; , kCINT_stdin; , kCINT_Edit; , kCINT_Load; , ;   kCINT_Exec; , kCINT_EXec; , kCINT_pragma; , kCINT_includeSYS; , ;   kCINT_includePWD; , kCINT_cpp; , kROOT_Load; , kSYS_FileName; , ;   kCXX_NewProto; , kCXX_ConstructorProto; , kCXX_ScopeProto; , kCXX_DirectProto; , ;   kCXX_IndirectProto; , kCXX_ScopeMember; , kCXX_DirectMember; , kCXX_IndirectMember; , ;   kCXX_Global; , kCXX_GlobalProto; , kNUM_PAT. };  ; typedef TList TContainer;  ; typedef TListIter TContIter;  . Public Member Functions;  TTabCom ();  Default constructor. ;  ; virtual ~TTabCom ();  ; void ClearAll ();  clears all lists except for user names and system include files. ;  ; void ClearClasses ();  Clear classes and namespace collections. ;  ; void ClearCppDirectives ();  Forget all Cpp directives seen so far. ;  ; void ClearEnvVars ();  Forget all environment variables seen so far. ;  ; void ClearFiles ();  Close all files. ;  ; void ClearGlobalFunctions ();  Forget all global functions seen so far. ;  ; void ClearGlobals ();  Forget all global variables seen so far. ;  ; void ClearPragmas ();  Forget all pragmas seen so far. ;  ; void ClearSysIncFiles ();  Close system files. ;  ; void ClearUsers ();  Forget all user seen so far. ;  ; const TSeqCollection * GetListOfClasses ();  Return the list of classes. ;  ; const TSeqCollection * GetListOfCppDirectives ();  Return the list of CPP directives. ;  ; const TSeqCollection * GetListOfEnvVars ();  Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. ;  ; const TSeqCollection * GetListOfFilesInPath (const char path[]);  ""path""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTabCom.html:1088,clear,clears,1088,doc/master/classTTabCom.html,https://root.cern,https://root.cern/doc/master/classTTabCom.html,1,['clear'],['clears']
Usability,"ng...; Searching...; No Matches. Boost.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: M. Fischler 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class Boost, a 4x4 symmetric matrix representation of; 12// an axial Lorentz transformation; 13//; 14// Created by: Mark Fischler Mon Nov 1 2005; 15//; 16#include ""Math/GenVector/Boost.h""; 17#include ""Math/GenVector/LorentzVector.h""; 18#include ""Math/GenVector/PxPyPzE4D.h""; 19#include ""Math/GenVector/DisplacementVector3D.h""; 20#include ""Math/GenVector/Cartesian3D.h""; 21#include ""Math/GenVector/GenVector_exception.h""; 22 ; 23#include <cmath>; 24#include <algorithm>; 25 ; 26//#ifdef TEX; 27/**; 28 ; 29 A variable names bgamma appears in several places in this file. A few; 30 words of elaboration are needed to make its meaning clear. On page 69; 31 of Misner, Thorne and Wheeler, (Exercise 2.7) the elements of the matrix; 32 for a general Lorentz boost are given as; 33 ; 34 \f[ \Lambda^{j'}_k = \Lambda^{k'}_j; 35 = (\gamma - 1) n^j n^k + \delta^{jk} \f]; 36 ; 37 where the n^i are unit vectors in the direction of the three spatial; 38 axes. Using the definitions, \f$ n^i = \beta_i/\beta \f$ , then, for example,; 39 ; 40 \f[ \Lambda_{xy} = (\gamma - 1) n_x n_y; 41 = (\gamma - 1) \beta_x \beta_y/\beta^2 \f]; 42 ; 43 By definition, \f[ \gamma^2 = 1/(1 - \beta^2) \f]; 44 ; 45 so that \f[ \gamma^2 \beta^2 = \gamma^2 - 1 \f]; 46 ; 47 or \f[ \beta^2 = (\gamma^2 - 1)/\gamma^2 \f]; 48 ; 49 If we insert this into the expression for \f$ \Lambda_{xy} \f$, we get; 50 ; 51 \f[ \Lambda_{xy} = (\gamma - 1) \gamma^2/(\gamma^2 - 1) \beta_x \beta_y \f]; 52 ; 53 or, finally; 54 ; 55 \f[ \Lambda_{xy} = \gamma^2/(\gamma+1) \beta_x \beta_y \f]; 56 ; 57 The expression \f$ \gamma^2/(\gamma+1) \f$ is what we",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Boost_8cxx_source.html:1127,clear,clear,1127,doc/master/Boost_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Boost_8cxx_source.html,1,['clear'],['clear']
Usability,"ng64_t processed) override;  ; void Progress (TSlave *, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti) override;  ; void Progress (TSlave *, TProofProgressInfo *pi) override;  ; Int_t ReinitSelector (TQueryResult *qr) override;  Reinitialize fSelector using the selector files in the query result. ;  ; void RemoveQueryResult (const char *ref) override;  Remove all query result instances referenced 'ref' from the list of results. ;  ; void RestorePreviousQuery () override;  ; Int_t SavePartialResults (Bool_t queryend=kFALSE, Bool_t force=kFALSE) override;  Save the partial results of this query to a dedicated file under the user data directory. ;  ; void SetCurrentQuery (TQueryResult *q) override;  Set current query and save previous value. ;  ; void SetDispatchTimer (Bool_t on=kTRUE) override;  Enable/disable the timer to dispatch pening events while processing. ;  ; void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt) override;  Set draw feedback option. ;  ; void SetExitStatus (EExitStatus st) override;  ; void SetInitTime () override;  ; void SetMaxDrawQueries (Int_t max) override;  ; void SetMerging (Bool_t=kTRUE) override;  ; void SetOutputFilePath (const char *fp) override;  ; void SetProcessing (Bool_t on=kTRUE);  Set processing bit according to 'on'. ;  ; void SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0) override;  Enable/disable the timer to stop/abort processing. ;  ; virtual void StopFeedback ();  Stop feedback (may not be used in this class). ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop the process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback list (may not be used in this class). ;  ; void StoreOutput (TList *out) override;  Store output list (may not be used in this class). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:7000,feedback,feedback,7000,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"ng64_t processed) override;  ; void Progress (TSlave *, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti) override;  ; void Progress (TSlave *, TProofProgressInfo *pi) override;  ; Int_t ReinitSelector (TQueryResult *qr) override;  Reinitialize fSelector using the selector files in the query result. ;  ; void RemoveQueryResult (const char *ref) override;  Remove all query result instances referenced 'ref' from the list of results. ;  ; void RestorePreviousQuery () override;  ; Int_t SavePartialResults (Bool_t queryend=kFALSE, Bool_t force=kFALSE) override;  Save the partial results of this query to a dedicated file under the user data directory. ;  ; void SetCurrentQuery (TQueryResult *q) override;  Set current query and save previous value. ;  ; void SetDispatchTimer (Bool_t on=kTRUE) override;  Enable/disable the timer to dispatch pening events while processing. ;  ; void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt) override;  Set draw feedback option. ;  ; void SetExitStatus (EExitStatus st) override;  ; void SetInitTime () override;  ; void SetMaxDrawQueries (Int_t max) override;  ; void SetMerging (Bool_t=kTRUE) override;  ; void SetOutputFilePath (const char *fp) override;  ; void SetProcessing (Bool_t on=kTRUE);  Set processing bit according to 'on'. ;  ; void SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0) override;  Enable/disable the timer to stop/abort processing. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop the process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback list (may not be used in this class). ;  ; void StoreOutput (TList *out) override;  Store output list (may not be used in this class). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateAutoBin (const char *name, Double_t &xmin, Double_t &xmax, Double_t &ymin, Double_t &ymax, Double_t &z",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLocal.html:5852,feedback,feedback,5852,doc/master/classTProofPlayerLocal.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLocal.html,2,['feedback'],['feedback']
Usability,"ngMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj, Bool_t& merged); Low statistic histograms need a special treatment when using autobin. Bool_t HistoSameAxis(TH1* h0, TH1* h1); Return kTRUE is the histograms 'h0' and 'h1' have the same binning and ranges; on the axis (i.e. if they can be just Add-ed for merging). void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of feedback objects. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet for specified slave. Bool_t IsClient() const; Is the player running on the client?. Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (support for TChain::Draw()).; Returns -1 in case of error or number of selected events in case of success. void SetInitTime(); Set init time. TVirtualPacketizer * GetPacketizer() const; { return 0; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerRemote.html:19210,feedback,feedback,19210,root/html532/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html532/TProofPlayerRemote.html,4,['feedback'],['feedback']
Usability,"ngTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. void FillLeaves(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeaves(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. Int_t SetParent(const TObject* obj, const Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when reading or writing; branches that may contain referenced objects. TRefTable * GetRefTable() const; {return fRefTable;}. void SetReadEntry(Long64_t entry); {fReadEntry = entry;}. » Author: Rene Brun 19/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchRef.h 22689 2008-03-17 16:21:23Z rdm $ » Last generated: 2009-12-07 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchRef.html:13527,clear,cleared,13527,root/html526/TBranchRef.html,https://root.cern,https://root.cern/root/html526/TBranchRef.html,1,['clear'],['cleared']
Usability,"ng_impl.cxx:3690; v4@ v4Definition rootcling_impl.cxx:3692; v3@ v3Definition rootcling_impl.cxx:3691; v1@ v1Definition rootcling_impl.cxx:3689; The supported operators are; +, -, *, /; +=, -=, *=, /=; <, >, ==, !=, <=, >=, &&, ||; ~, !; &, |, ^; &=, |=, ^=; <<=, >>=. The most common mathematical functions are supported. It is possible to invoke them passing RVecs as arguments.; abs, fdim, fmod, remainder; floor, ceil, trunc, round, lround, llround; exp, exp2, expm1; log, log10, log2, log1p; pow; sqrt, cbrt; sin, cos, tan, asin, acos, atan, atan2, hypot; sinh, cosh, tanh, asinh, acosh; erf, erfc; lgamma, tgamma. If the VDT library is available, the following functions can be invoked. Internally the calculations are vectorized:; fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan. Owning and adopting memory; RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case, it can be constructed with the address of the memory associated to it and its length. For example: std::vector<int> myStlVec {1,2,3};; RVec<int> myRVec(myStlVec.data(), myStlVec.size());; In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"". If any method which implies a re-allocation is called, e.g. emplace_back or resize, the adopted memory is released and new one is allocated. The previous content is copied in the new memory and preserved. Sorting and manipulation of indices. Sorting; RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms can be used, for example sorting: RVec<double> v{6., 4., 5.};; std::sort(v.begin(), v.end());; v@ vDefinition rootcling_impl.cxx:3687; For convenience, helpers are provided too: auto sorted_v = Sort(v);; auto reversed_v = Reverse(v);; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html:4695,simpl,simply,4695,doc/v632/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html,1,['simpl'],['simply']
Usability,"ng_impl.cxx:3702; v4@ v4Definition rootcling_impl.cxx:3704; v3@ v3Definition rootcling_impl.cxx:3703; v1@ v1Definition rootcling_impl.cxx:3701; The supported operators are; +, -, *, /; +=, -=, *=, /=; <, >, ==, !=, <=, >=, &&, ||; ~, !; &, |, ^; &=, |=, ^=; <<=, >>=. The most common mathematical functions are supported. It is possible to invoke them passing RVecs as arguments.; abs, fdim, fmod, remainder; floor, ceil, trunc, round, lround, llround; exp, exp2, expm1; log, log10, log2, log1p; pow; sqrt, cbrt; sin, cos, tan, asin, acos, atan, atan2, hypot; sinh, cosh, tanh, asinh, acosh; erf, erfc; lgamma, tgamma. If the VDT library is available, the following functions can be invoked. Internally the calculations are vectorized:; fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan. Owning and adopting memory; RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case, it can be constructed with the address of the memory associated to it and its length. For example: std::vector<int> myStlVec {1,2,3};; RVec<int> myRVec(myStlVec.data(), myStlVec.size());; In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"". If any method which implies a re-allocation is called, e.g. emplace_back or resize, the adopted memory is released and new one is allocated. The previous content is copied in the new memory and preserved. Sorting and manipulation of indices. Sorting; RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms can be used, for example sorting: RVec<double> v{6., 4., 5.};; std::sort(v.begin(), v.end());; v@ vDefinition rootcling_impl.cxx:3699; For convenience, helpers are provided too: auto sorted_v = Sort(v);; auto reversed_v = Reverse(v);; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html:4696,simpl,simply,4696,doc/master/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html,1,['simpl'],['simply']
Usability,"nge current fill area attributes if necessary.Definition TAttFill.cxx:216; TAttFill::SaveFillAttributesvirtual void SaveFillAttributes(std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001)Save fill attributes as C++ statement(s) on output stream out.Definition TAttFill.cxx:239; TAttLine::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::Modifyvirtual void Modify()Change current line attributes if necessary.Definition TAttLine.cxx:247; TAttLine::Copyvoid Copy(TAttLine &attline) constCopy this line attributes to a new TAttLine.Definition TAttLine.cxx:177; TAttLine::SaveLineAttributesvirtual void SaveLineAttributes(std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1)Save line attributes as C++ statement(s) on output stream out.Definition TAttLine.cxx:275; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::fY1Double_t fY1Y of 1st point.Definition TLine.h:26; TLine::fX1Double_t fX1X of 1st point.Definition TLine.h:25; TLine::kLineNDC@ kLineNDCUse NDC coordinates.Definition TLine.h:33; TLine::Copyvoid Copy(TObject &line) const overrideCopy this line to line.Definition TLine.cxx:76; TLine::fX2Double_t fX2X of 2nd point.Definition TLine.h:27; TLine::fY2Double_t fY2Y of 2nd point.Definition TLine.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TArrow_8cxx_source.html:20033,simpl,simple,20033,doc/master/TArrow_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TArrow_8cxx_source.html,1,['simpl'],['simple']
Usability,"nge(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:53381,simpl,simplex,53381,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,5,['simpl'],['simplex']
Usability,"nge+9);; firstaxis->AddRange(new TParallelCoordRange(firstaxis,-1.263024,-0.755292));; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kOrange@ kOrangeDefinition Rtypes.h:67; kViolet@ kVioletDefinition Rtypes.h:67; TCanvas.h; TFile.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TNtuple.h; TParallelCoordRange.h; TParallelCoordVar.h; TParallelCoord.h; TRandom.h; TStyle.h; gPad#define gPadDefinition TVirtualPad.h:308; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TParallelCoordRangeA TParallelCoordRange is a range used for parallel coordinates plots.Definition TParallelCoordRange.h:25; TParallelCoordVarTParallelCoord axes.Definition TParallelCoordVar.h:24; TParallelCoordVar::AddRangevoid AddRange(TParallelCoordRange *range)Add a range to the current selection on the axis.Definition TParallelCoordVar.cxx:102; TParallelCoordParallel Coordinates class.Definition TParallelCoord.h:28; TParallelCoord::AddSelectionvoid AddSelection(const char *title)Add a selection.Definition TParallelCoord.cxx:242; TParallelCoord::GetCurrentSelectionTParallelCoordSelect * GetCurrentSelection()Return the selection currently being edited.Definition TParallelCoord.cxx:438",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/parallelcoord_8C.html:3215,simpl,simple,3215,doc/master/parallelcoord_8C.html,https://root.cern,https://root.cern/doc/master/parallelcoord_8C.html,1,['simpl'],['simple']
Usability,"nge. . ReturnsThe caller owns the returned std::list. ; Reimplemented from RooAbsReal.; Definition at line 329 of file RooAddition.cxx. ◆ printMetaArgs(). void RooAddition::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Reimplemented from RooAbsArg.; Definition at line 253 of file RooAddition.cxx. ◆ setData(). bool RooAddition::setData ; (; RooAbsData & ; data, . bool ; cloneData = true . ). overridevirtual . Reimplemented from RooAbsReal.; Definition at line 241 of file RooAddition.cxx. ◆ Streamer(). void RooAddition::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooAddition::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 76 of file RooAddition.h. ◆ translate(). void RooAddition::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 160 of file RooAddition.cxx. Member Data Documentation. ◆ _cacheMgr. RooObjCacheManager RooAddition::_cacheMgr. mutableprotected . ! The cache manager ; Definition at line 72 of file RooAddition.h. ◆ _ownedList. RooArgList RooAddition::_ownedList. protected . List of owned components. ; Definition at line 63 of file RooAddition.h. ◆ _set. RooListProxy RooAddition::_set. protected . set of terms to be summed ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:67179,simpl,simple,67179,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,1,['simpl'],['simple']
Usability,"nges.py;   Use Range to limit the amount of data processed. ;  ; file  df007_snapshot.C;   Write ROOT data with RDataFrame. ;  ; file  df007_snapshot.py;   Write ROOT data with RDataFrame. ;  ; file  df008_createDataSetFromScratch.C;   Create data from scratch with RDataFrame. ;  ; file  df008_createDataSetFromScratch.py;   Create data from scratch with RDataFrame. ;  ; file  df009_FromScratchVSTTree.C;   Compare creation of a ROOT dataset with RDataFrame and TTree. ;  ; file  df010_trivialDataSource.C;   Use the ""trivial data source"", an example data source implementation. ;  ; file  df010_trivialDataSource.py;   Use the ""trivial data source"", an example data source implementation. ;  ; file  df012_DefinesAndFiltersAsStrings.C;   Use just-in-time-compiled Filters and Defines for quick prototyping. ;  ; file  df012_DefinesAndFiltersAsStrings.py;   Use just-in-time-compiled Filters and Defines for quick prototyping. ;  ; file  df013_InspectAnalysis.C;   Use callbacks to update a plot and a progress bar during the event loop. ;  ; file  df014_CSVDataSource.C;   Process a CSV file with RDataFrame and the CSV data source. ;  ; file  df014_CSVDataSource.py;   Process a CSV file with RDataFrame and the CSV data source. ;  ; file  df015_LazyDataSource.C;   Use the lazy RDataFrame data source to concatenate computation graphs. ;  ; file  df016_vecOps.C;   Process collections in RDataFrame with the help of RVec. ;  ; file  df016_vecOps.py;   Process collections in RDataFrame with the help of RVec. ;  ; file  df017_vecOpsHEP.C;   Use RVecs to plot the transverse momentum of selected particles. ;  ; file  df017_vecOpsHEP.py;   Use RVecs to plot the transverse momentum of selected particles. ;  ; file  df018_customActions.C;   Implement a custom action to fill THns. ;  ; file  df019_Cache.C;   Cache a processed RDataFrame in memory for further usage. ;  ; file  df019_Cache.py;   Cache a processed RDataFrame in memory for further usage. ;  ; file  df020_helpers.C;   Show usage of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__dataframe.html:3458,progress bar,progress bar,3458,doc/master/group__tutorial__dataframe.html,https://root.cern,https://root.cern/doc/master/group__tutorial__dataframe.html,1,['progress bar'],['progress bar']
Usability,"nificance"", 100, 0, 1, 100, 0, 3);; 287 create (""OutputSig"", 100, 0, 1);; 288 create (""OutputBkg"", 100, 0, 1);; 289 fMonitoring->ProcessEvents ();; 290 }; 291 }; 292 ; 293 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 294 *; 295 */; 296 void ClassificationSettings::endTrainCycle (double /*error*/) ; 297 {; 298 if (fMonitoring) fMonitoring->ProcessEvents ();; 299 }; 300 ; 301 /** \brief action to be done after the computation of a test sample (e.g. update some monitoring output); 302 *; 303 */; 304 void ClassificationSettings::testSample (double /*error*/, double output, double target, double weight); 305 {; 306 ; 307 m_output.push_back (output);; 308 m_targets.push_back (target);; 309 m_weights.push_back (weight);; 310 }; 311 ; 312 ; 313 /** \brief action to be done when the test cycle is started (e.g. update some monitoring output); 314 *; 315 */; 316 void ClassificationSettings::startTestCycle () ; 317 {; 318 m_output.clear ();; 319 m_targets.clear ();; 320 m_weights.clear ();; 321 }; 322 ; 323 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 324 *; 325 */; 326 void ClassificationSettings::endTestCycle () ; 327 {; 328 if (m_output.empty ()); 329 return;; 330 double minVal = *std::min_element (begin (m_output), end (m_output));; 331 double maxVal = *std::max_element (begin (m_output), end (m_output));; 332 const size_t numBinsROC = 1000;; 333 const size_t numBinsData = 100;; 334 ; 335 std::vector<double> truePositives (numBinsROC+1, 0);; 336 std::vector<double> falsePositives (numBinsROC+1, 0);; 337 std::vector<double> trueNegatives (numBinsROC+1, 0);; 338 std::vector<double> falseNegatives (numBinsROC+1, 0);; 339 ; 340 std::vector<double> x (numBinsData, 0);; 341 std::vector<double> datSig (numBinsData+1, 0);; 342 std::vector<double> datBkg (numBinsData+1, 0);; 343 ; 344 double binSizeROC = (maxVal - minVal)/(double)numBinsROC;; 345 double binSizeData = (maxVal ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:12115,clear,clear,12115,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,1,['clear'],['clear']
Usability,"nimum is found, the search area is shifted to be centered at the best value. Random points are chosen uniformly over a hypercube determined by current step sizes. The Metropolis algorithm accepts a worse point with probability exp(-d/UP), where d is the degradation. Improved points are of course always accepted. Actual steps are random multiples of the nominal steps (DIRIN). ; Definition at line 6818 of file TMinuit.cxx. ◆ mnset(). void TMinuit::mnset ; (; ). virtual . Interprets the commands that start with SET and SHOW. ; Called from MNEXCM file characteristics for SET INPUT 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED ' explanation of print level numbers -1:3 and strategies 0:2 identification of debug options things that can be set or shown options not intended for normal users ; Definition at line 6913 of file TMinuit.cxx. ◆ mnsimp(). void TMinuit::mnsimp ; (; ). virtual . Minimization using the simplex method of Nelder and Mead. ; Performs a minimization using the simplex method of Nelder and Mead (ref. – Comp. J. 7,308 (1965)). ; Definition at line 7431 of file TMinuit.cxx. ◆ mnstat(). void TMinuit::mnstat ; (; Double_t & ; fmin, . Double_t & ; fedm, . Double_t & ; errdef, . Int_t & ; npari, . Int_t & ; nparx, . Int_t & ; istat . ). virtual . Returns concerning the current status of the minimization. ; User-called Namely, it returns:; FMIN: the best function value found so far; FEDM: the estimated vertical distance remaining to minimum; ERRDEF: the value of UP defining parameter uncertainties; NPARI: the number of currently variable parameters; NPARX: the highest (external) parameter number defined by user; ISTAT: a status integer indicating how good is the covariance matrix:; 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix . Definition at line 7638 of file TMinuit.cxx. ◆ mntiny(). void TMinuit::mntiny ; (; Double_t ; epsp1, . Double_t & ; epsbak . ).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:64484,simpl,simplex,64484,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['simpl'],['simplex']
Usability,"ning of the dataset list of this dataset. void Browse(TBrowser* b); Browse this dataset (called by TBrowser). TObject * Clone(const char* newname = """") const; the custom implementation fo the TObject::Clone. void Delete(Option_t* opt = """"). Delete - deletes the list of the TDataSet objects and all ""Structural Members""; as well; This method doesn't affect the ""Associated Members"". TDataSet * FindByPath(const char* path) const; Aliase for TDataSet::Find(const Char_t *path) method. TDataSet * Find(const char* path) const. Full description see: TDataSetIter::Find. Note. This method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * FindByName(const char* name, const char* path = """", Option_t* opt = """") const. Full description see: TDataSetIter::Find. Note. This is method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const. Full description see: TDataSetIter::Find. Note. This method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * First() const; Return the first object in the list. Returns 0 when list is empty. void AddMain(TDataSet* set); add data set to main data set. TDataSet * GetMainSet(); return pointer to the main dataset. TObject * GetObject() const; The depricated method (left here for the sake of the backward compatibility). TDataSet * Last() const; Return the last object in the list. Returns 0 when list is empty. TDataSet * Next() const; Return the object next to this one in the parent structure; This co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSet.html:14373,simpl,simplify,14373,root/html528/TDataSet.html,https://root.cern,https://root.cern/root/html528/TDataSet.html,6,['simpl'],['simplify']
Usability,"ning rate. ; Definition at line 410 of file GeneralLayer.h. ◆ UpdateBiases(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiases ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the biases, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weights, given the gradients and the learning rate,. ; Definition at line 418 of file GeneralLayer.h. ◆ WriteMatrixToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteMatrixToXML ; (; void * ; node, . const char * ; name, . const Matrix_t & ; matrix . ). Definition at line 521 of file GeneralLayer.h. ◆ WriteTensorToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteTensorToXML ; (; void * ; node, . const char * ; name, . const std::vector< Matrix_t > & ; tensor . ). helper functions for XML ; Definition at line 496 of file GeneralLayer.h. Member Data Documentation. ◆ fActivationGradi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:26367,learn,learning,26367,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learning']
Usability,"nit(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:18701,undo,undo,18701,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,12,['undo'],['undo']
Usability,"nitialization) {; 820 case EInitialization::kGauss:; 821 net.initializeWeights(WeightInitializationStrategy::XAVIER,; 822 std::back_inserter(weights));; 823 break;; 824 case EInitialization::kUniform:; 825 net.initializeWeights(WeightInitializationStrategy::XAVIERUNIFORM,; 826 std::back_inserter(weights));; 827 break;; 828 default:; 829 net.initializeWeights(WeightInitializationStrategy::XAVIER,; 830 std::back_inserter(weights));; 831 break;; 832 }; 833 ; 834 int idxSetting = 0;; 835 for (auto s : fTrainingSettings) {; 836 ; 837 EnumRegularization r = EnumRegularization::NONE;; 838 switch(s.regularization) {; 839 case ERegularization::kNone: r = EnumRegularization::NONE; break;; 840 case ERegularization::kL1: r = EnumRegularization::L1; break;; 841 case ERegularization::kL2: r = EnumRegularization::L2; break;; 842 }; 843 ; 844 Settings * settings = new Settings(TString(), s.convergenceSteps, s.batchSize,; 845 s.testInterval, s.weightDecay, r,; 846 MinimizerType::fSteepest, s.learningRate,; 847 s.momentum, 1, s.multithreading);; 848 std::shared_ptr<Settings> ptrSettings(settings);; 849 ptrSettings->setMonitoring (0);; 850 Log() << kINFO; 851 << ""Training with learning rate = "" << ptrSettings->learningRate (); 852 << "", momentum = "" << ptrSettings->momentum (); 853 << "", repetitions = "" << ptrSettings->repetitions (); 854 << Endl;; 855 ; 856 ptrSettings->setProgressLimits ((idxSetting)*100.0/(fSettings.size ()),; 857 (idxSetting+1)*100.0/(fSettings.size ()));; 858 ; 859 const std::vector<double>& dropConfig = ptrSettings->dropFractions ();; 860 if (!dropConfig.empty ()) {; 861 Log () << kINFO << ""Drop configuration"" << Endl; 862 << "" drop repetitions = "" << ptrSettings->dropRepetitions(); 863 << Endl;; 864 }; 865 ; 866 int idx = 0;; 867 for (auto f : dropConfig) {; 868 Log () << kINFO << "" Layer "" << idx << "" = "" << f << Endl;; 869 ++idx;; 870 }; 871 Log () << kINFO << Endl;; 872 ; 873 DNN::Steepest minimizer(ptrSettings->learningRate(),; 874 ptrSettings->momentum(),; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:30289,learn,learningRate,30289,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['learn'],['learningRate']
Usability,"nition at line 224 of file GeneralLayer.h. ◆ SetWidth(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetWidth ; (; size_t ; width). inline . Definition at line 223 of file GeneralLayer.h. ◆ Update(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::Update ; (; const Scalar_t ; learningRate). Updates the weights and biases, given the learning rate. ; Definition at line 410 of file GeneralLayer.h. ◆ UpdateBiases(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiases ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the biases, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weights, given the gradients and the learning rate,. ; Definition at line 418 of file GeneralLayer.h. ◆ WriteMatrixToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteMatrixToXML ; (; void * ; node, . const char * ; na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:25923,learn,learningRate,25923,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learningRate']
Usability,"nition at line 328 of file TTreeProcessorMT.cxx. ◆ GetTasksPerWorkerHint(). unsigned int TTreeProcessorMT::GetTasksPerWorkerHint ; (; ). static . Retrieve the current value for the desired number of tasks per worker. ; ReturnsThe desired number of tasks to be created per worker. TTreeProcessorMT uses this value as an hint. ; Definition at line 528 of file TTreeProcessorMT.cxx. ◆ Process(). void TTreeProcessorMT::Process ; (; std::function< void(TTreeReader &)> ; func). Process the entries of a TTree in parallel. ; The user-provided function receives a TTreeReader which can be used to iterate on a subrange of entries TTreeProcessorMT::Process([](TTreeReader& readerSubRange) {; // Select branches to read; while (readerSubRange.Next()) {; // Use content of current entry; }; });; ROOT::TTreeProcessorMT::Processvoid Process(std::function< void(TTreeReader &)> func)Process the entries of a TTree in parallel.Definition TTreeProcessorMT.cxx:454; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:44; TTreeReader::Nextbool Next()Move to the next entry (or index of the TEntryList if that is set).Definition TTreeReader.h:209; The user needs to be aware that each of the subranges can potentially be processed in parallel. This means that the code of the user function should be thread safe.; Parameters. [in]funcUser-defined function that processes a subrange of entries . Definition at line 454 of file TTreeProcessorMT.cxx. ◆ SetTasksPerWorkerHint(). void TTreeProcessorMT::SetTasksPerWorkerHint ; (; unsigned int ; tasksPerWorkerHint). static . Set the hint for the desired number of tasks created per worker. ; Parameters. [in]tasksPerWorkerHintDesired number of tasks per worker. This allows to create a reasonable number of tasks even if any of the processed files features a bad clustering, for example with a lot of entries and just a few entries per cluster, or to limit the number of tasks spawned when ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMT.html:6208,simpl,simple,6208,doc/v632/classROOT_1_1TTreeProcessorMT.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMT.html,1,['simpl'],['simple']
Usability,"nition at line 330 of file TTreeProcessorMT.cxx. ◆ GetTasksPerWorkerHint(). unsigned int TTreeProcessorMT::GetTasksPerWorkerHint ; (; ). static . Retrieve the current value for the desired number of tasks per worker. ; ReturnsThe desired number of tasks to be created per worker. TTreeProcessorMT uses this value as an hint. ; Definition at line 535 of file TTreeProcessorMT.cxx. ◆ Process(). void TTreeProcessorMT::Process ; (; std::function< void(TTreeReader &)> ; func). Process the entries of a TTree in parallel. ; The user-provided function receives a TTreeReader which can be used to iterate on a subrange of entries TTreeProcessorMT::Process([](TTreeReader& readerSubRange) {; // Select branches to read; while (readerSubRange.Next()) {; // Use content of current entry; }; });; ROOT::TTreeProcessorMT::Processvoid Process(std::function< void(TTreeReader &)> func)Process the entries of a TTree in parallel.Definition TTreeProcessorMT.cxx:460; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; TTreeReader::Nextbool Next()Move to the next entry (or index of the TEntryList if that is set).Definition TTreeReader.h:216; The user needs to be aware that each of the subranges can potentially be processed in parallel. This means that the code of the user function should be thread safe.; Parameters. [in]funcUser-defined function that processes a subrange of entries . Definition at line 460 of file TTreeProcessorMT.cxx. ◆ SetTasksPerWorkerHint(). void TTreeProcessorMT::SetTasksPerWorkerHint ; (; unsigned int ; tasksPerWorkerHint). static . Set the hint for the desired number of tasks created per worker. ; Parameters. [in]tasksPerWorkerHintDesired number of tasks per worker. This allows to create a reasonable number of tasks even if any of the processed files features a bad clustering, for example with a lot of entries and just a few entries per cluster, or to limit the number of tasks spawned when ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TTreeProcessorMT.html:6575,simpl,simple,6575,doc/master/classROOT_1_1TTreeProcessorMT.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TTreeProcessorMT.html,1,['simpl'],['simple']
Usability,"nition at line 460 of file RGeomData.cxx. ◆ BuildDescription(). void RGeomDescription::BuildDescription ; (; TGeoNode * ; topnode, . TGeoVolume * ; topvolume . ). private . Build geometry description. ; Definition at line 494 of file RGeomData.cxx. ◆ ChangeConfiguration(). bool RGeomDescription::ChangeConfiguration ; (; const std::string & ; json). Change configuration by client Returns true if any parameter was really changed. ; Definition at line 2105 of file RGeomData.cxx. ◆ ChangeNodeVisibility(). bool RGeomDescription::ChangeNodeVisibility ; (; const std::vector< std::string > & ; path, . bool ; on . ). Change visibility for specified element Returns true if changes was performed. ; Definition at line 1850 of file RGeomData.cxx. ◆ ClearAllPhysVisibility(). bool RGeomDescription::ClearAllPhysVisibility ; (; ). Reset all custom visibility settings. ; Definition at line 2089 of file RGeomData.cxx. ◆ ClearCache(). void RGeomDescription::ClearCache ; (; ). Clear cached data, need to be clear when connection broken. ; Definition at line 1381 of file RGeomData.cxx. ◆ ClearDescription(). void RGeomDescription::ClearDescription ; (; ). private . Clear geometry description. ; Definition at line 478 of file RGeomData.cxx. ◆ ClearDrawData(). void RGeomDescription::ClearDrawData ; (; ). Clear raw data. Will be rebuild when next connection will be established. ; Definition at line 1370 of file RGeomData.cxx. ◆ ClearPhysNodeVisibility(). bool RGeomDescription::ClearPhysNodeVisibility ; (; const std::vector< std::string > & ; path). Reset custom visibility of physical node by path. ; Definition at line 2065 of file RGeomData.cxx. ◆ CollectNodes(). void RGeomDescription::CollectNodes ; (; RGeomDrawing & ; drawing, . bool ; all_nodes = false . ). private . Collect nodes which are used in visibles. ; Definition at line 721 of file RGeomData.cxx. ◆ CopyMaterialProperties(). void RGeomDescription::CopyMaterialProperties ; (; TGeoVolume * ; vol, . RGeomNode & ; node . ). private . C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:12786,clear,clear,12786,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,2,['clear'],['clear']
Usability,"nition at line 552 of file TGTextEntry.cxx. ◆ SetInsertMode(). void TGTextEntry::SetInsertMode ; (; EInsertMode ; mode = kInsert). virtual . Sets the mode how characters are entered to the text entry. ; Definition at line 596 of file TGTextEntry.cxx. ◆ SetMaxLength(). void TGTextEntry::SetMaxLength ; (; Int_t ; maxlen). virtual . Set the maximum length of the text in the editor. ; If the text is currently too long, it is chopped off at the limit. Any marked text will be unmarked. The cursor position is set to 0 and the first part of the string is shown. See also GetMaxLength(). ; Definition at line 636 of file TGTextEntry.cxx. ◆ SetState(). void TGTextEntry::SetState ; (; Bool_t ; state). virtual . Set state of widget. If kTRUE=enabled, kFALSE=disabled. ; Reimplemented in TGNumberEntryField.; Definition at line 498 of file TGTextEntry.cxx. ◆ SetText(). void TGTextEntry::SetText ; (; const char * ; text, . Bool_t ; emit = kTRUE . ). virtual . Sets text entry to text, clears the selection and moves the cursor to the end of the line. ; If necessary the text is truncated to fit MaxLength(). See also GetText(). ; Reimplemented in TGNumberEntryField.; Definition at line 611 of file TGTextEntry.cxx. ◆ SetTextColor() [1/2]. void TGTextEntry::SetTextColor ; (; Pixel_t ; color, . Bool_t ; local = kTRUE . ). virtual . Changes text color. ; If local is true color is changed locally. ; Definition at line 1761 of file TGTextEntry.cxx. ◆ SetTextColor() [2/2]. void TGTextEntry::SetTextColor ; (; TColor * ; color, . Bool_t ; local = kTRUE . ). virtual . Changes text color. ; If local is true color is changed locally. ; Definition at line 1777 of file TGTextEntry.cxx. ◆ SetTitle(). virtual void TGTextEntry::SetTitle ; (; const char * ; label). inlinevirtual . Definition at line 155 of file TGTextEntry.h. ◆ SetToolTipText(). void TGTextEntry::SetToolTipText ; (; const char * ; text, . Long_t ; delayms = 500 . ). virtual . Set tool tip text associated with this text entry. ; The delay i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEntry.html:65187,clear,clears,65187,doc/master/classTGTextEntry.html,https://root.cern,https://root.cern/doc/master/classTGTextEntry.html,1,['clear'],['clears']
Usability,"nition at line 61 of file RooUniform.cxx. ◆ getGenerator(). Int_t RooUniform::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Advertise internal generator. ; Reimplemented from RooAbsPdf.; Definition at line 107 of file RooUniform.cxx. ◆ IsA(). TClass * RooUniform::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 50 of file RooUniform.h. ◆ Streamer(). void RooUniform::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooUniform::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 50 of file RooUniform.h. ◆ translate(). void RooUniform::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 53 of file RooUniform.cxx. Member Data Documentation. ◆ x. RooListProxy RooUniform::x. protected . Definition at line 43 of file RooUniform.h. Libraries for RooUniform:. [legend]; The documentation for this class was generated from the following files:; roofit/roofit/inc/RooUniform.h; roofit/roofit/src/RooUniform.cxx. RooUniform. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:11 (GVA Time) using Doxygen 1.9.8 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooUniform.html:76775,simpl,simple,76775,doc/master/classRooUniform.html,https://root.cern,https://root.cern/doc/master/classRooUniform.html,1,['simpl'],['simple']
Usability,"niz Gunceler, Danilo Piparo; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#include ""TH2Poly.h""; 14#include ""TMultiGraph.h""; 15#include ""TGraph.h""; 16#include ""TInterpreter.h""; 17#include ""Riostream.h""; 18#include ""TList.h""; 19#include ""TMath.h""; 20#include <cassert>; 21 ; 22ClassImp(TH2Poly);; 23 ; 24/** \class TH2Poly; 25 \ingroup Histograms; 262D Histogram with Polygonal Bins; 27 ; 28## Overview; 29`TH2Poly` is a 2D Histogram class (TH2) allowing to define polygonal; 30bins of arbitrary shape.; 31 ; 32Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; 33`TH2PolyBin` is a very simple class containing the vertices (stored; 34as `TGraph`s or `TMultiGraph`s ) and contents of the polygonal; 35bin as well as several related functions.; 36 ; 37Essentially, a `TH2Poly` is a TList of `TH2PolyBin` objects; 38with methods to manipulate them.; 39 ; 40Bins are defined using one of the `AddBin()` methods. The bin definition; 41should be done before filling.; 42 ; 43The histogram can be filled with `Fill(Double_t x, Double_t y, Double_t w); 44`. `w` is the weight.; 45If no weight is specified, it is assumed to be 1.; 46 ; 47Not all histogram's area need to be binned. Filling an area without bins,; 48will falls into the overflows. Adding a bin is not retroactive; it doesn't; 49affect previous fillings. A `Fill()` call, that; 50was previously ignored due to the lack of a bin at the specified location, is; 51not reconsidered when that location is binned later.; 52 ; 53If there are two overlapping bins, the first one in the list will be incremented; 54by `Fill()`.; 55 ; 56The histogram may automatically extends its limits if a bin outside",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:1186,simpl,simple,1186,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['simpl'],['simple']
Usability,"nkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* =============================================; *-* If IOPT=1,; *-* If IOPT=0, sets only MINOS errors to undefined; *-* Called from MNCLER and whenever problem changes, for example; *-* after SET LIMITS, SET PARAM, CALL FCN 6; *. void mnsave(); -*Writes current parameter values and step sizes onto file ISYSSA; *-* ===============================================================; *-* in format which can be reread by Minuit for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:51859,simpl,simplex,51859,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,6,['simpl'],['simplex']
Usability,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAllowDirectiveswhether directives are to be interpreted; Bool_tfCheckForMethodwhether to check the current line for a method; TStringfClassDescrTagtag for finding the class description; enum TDocParser::fClassDocStatewhether we found the class description; TStringfCommentcurrent comment; Bool_tfCommentAtBOLat the beginning of the current line, fParseContext contained kComment; TClass*fCurrentClasscurrent class context of sources being parsed; TStringfCurrentFilecurrent source / header file name; TStringfCurrentMethodTagname_idx of the currently parsed method; TStringfCurrentModulecurrent module context of sources being parsed; TListfDataMembers[6]data members (by access, plus enums); Int_tfDirectiveCountindex of directive for current method; TListfDirectiveHandlershandler for doc directives (TDocDirective objects); TDocParser::EDocContextfDocContextcurrent context of parsed sources for documenting; TDocOutput*fDocOutputTDocOutput invoking us; set<UInt_t>fExtraLinesWithAnchorlines that need an additional anchor; TStringfFirstClassDocfirst class-doc found - per file, taken if fLastClassDoc is empty; THtml*fHtmlTHtml object using us; TStringfLastClassDoclast class-doc found - becomes class doc at ClassImp or first method; TStringfLineCommentcurrent line with links and directives for doc; UInt_tfLineNocurrent line number; Long_tfLineNumbersource line number; TStringfLineRawcurrent line; TStringfLineSourcecurrent line with links; TStringfLineStrippedcurrent line without surrounding spaces; map<std::string,Int_t>fMethodCountsnumber of undocumented overloads; THashListfMethods[3]methods as TMethodWrapper objects (by access); list<UInt_t>fParseContextcurrent context of parsed sources; TClass*fRecentClassrecently seen class context of sources being parsed, e.g. for Convert(); TStringfSourceInfo[5]author, last changed, ...; TStringfSourceInfoTags[5]tags for source",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDocParser.html:10254,undo,undocumented,10254,root/html528/TDocParser.html,https://root.cern,https://root.cern/root/html528/TDocParser.html,3,['undo'],['undocumented']
Usability,"nning ;  fillrandom.C Fill a 1-D histogram from a parametric function ;  fillrandom.py Fill a 1-D histogram from a parametric function ;  FirstContour.C Make a contour plot and get the first contour in a TPolyMarker ;  h1draw.C 1-D histogram drawing options ;  h2proj.C;  hbars.C Example of bar charts with 1-d histograms ;  histpalettecolor.C Palette coloring for histogram is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  hksimple.C Illustrates the advantages of a TH1K histogram ;  hlabels1.C 1-D histograms with alphanumeric labels ;  hlabels2.C 2-D histograms with alphanumeric labels ;  hstack.C Example of stacked histograms: class THStack ;  hsum.C Histograms filled and drawn in a loop ;  hsumTimer.C Demo of Timers ;  logscales.C Draw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot1.py Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot2.py Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot3.py Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot5.py Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:123162,simpl,simple,123162,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,"nning the hypothesis test results of a HypoTestCalculator for various values of the parameter of interest. More...;  ; class  HypoTestInverterPlot;  Class to plot a HypoTestInverterResult, the output of the HypoTestInverter calculator. More...;  ; class  HypoTestInverterResult;  HypoTestInverterResult class holds the array of hypothesis test results and compute a confidence interval. More...;  ; class  HypoTestPlot;  This class provides the plots for the result of a study performed with any of the HypoTestCalculatorGeneric (e.g. More...;  ; class  HypoTestResult;  HypoTestResult is a base class for results from hypothesis tests. More...;  ; class  IntervalCalculator;  IntervalCalculator is an interface class for a tools which produce RooStats ConfIntervals. More...;  ; struct  LikelihoodFunction;  ; class  LikelihoodInterval;  LikelihoodInterval is a concrete implementation of the RooStats::ConfInterval interface. More...;  ; class  LikelihoodIntervalPlot;  This class provides simple and straightforward utilities to plot a LikelihoodInterval object. More...;  ; class  MarkovChain;  Stores the steps in a Markov Chain of points. More...;  ; class  MaxLikelihoodEstimateTestStat;  MaxLikelihoodEstimateTestStat: TestStatistic that returns maximum likelihood estimate of a specified parameter. More...;  ; class  MCMCCalculator;  Bayesian Calculator estimating an interval or a credible region using the Markov-Chain Monte Carlo method to integrate the likelihood function with the prior to obtain the posterior function. More...;  ; class  MCMCInterval;  MCMCInterval is a concrete implementation of the RooStats::ConfInterval interface. More...;  ; class  MCMCIntervalPlot;  This class provides simple and straightforward utilities to plot a MCMCInterval object. More...;  ; class  MetropolisHastings;  This class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo. More...;  ; class  MinNLLTestStat;  MinNLLTestStat is an implementati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:3744,simpl,simple,3744,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['simpl'],['simple']
Usability,"nnotation via picking. ;  ; void DoASavImageGUIBaseName (const char *t);  Update base-name. ;  ; void DoASavImageGUIOutMode (Int_t m);  Update output mode. ;  ; void DoASavImageStart ();  Start auto-rotator image auto-save. ;  ; void DoASavImageStop ();  Stop auto-rotator image auto-save. ;  ; void DoCameraCenterExt ();  Set external camera center. ;  ; void DoCameraHome ();  CameraHome was clicked. ;  ; void DoCameraOverlay ();  Update viewer with GUI state. ;  ; void DoCaptureCenter ();  Capture camera-center via picking. ;  ; void DoClearColor (Pixel_t color);  Clear-color was changed. ;  ; void DoDrawCameraCenter ();  Draw camera center. ;  ; void DoIgnoreSizesOnUpdate ();  ResetCamerasOnUpdate was toggled. ;  ; void DoResetCamerasOnUpdate ();  ResetCamerasOnUpdate was toggled. ;  ; void DoRotatorStart ();  Start auto-rotator. ;  ; void DoRotatorStop ();  Stop auto-rotator. ;  ; void DoUpdateScene ();  UpdateScene was clicked. ;  ; TClass * IsA () const override;  ; void SetGuides ();  Configuration of guides GUI called from SetModel(). ;  ; void SetModel (TObject *obj) override;  Sets model or disables/hides viewer. ;  ; void SetRotatorMode ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateCameraCenter ();  Update current camera with GUI state. ;  ; void UpdateMaxDrawTimes ();  Slot for fMaxSceneDrawTimeHQ and fMaxSceneDrawTimeLQ. ;  ; void UpdatePointLineStuff ();  Slot for point-sizes and line-widths. ;  ; void UpdateRotator ();  Update rotator related variables. ;  ; void UpdateStereo ();  Update stereo related variables. ;  ; void UpdateViewerAxes (Int_t id);  Update viewer with GUI state. ;  ; void UpdateViewerReference ();  Update viewer with GUI state. ;  ; virtual void ViewerRedraw ();  Initiate redraw of the viewer. ;  ;  Public Member Functions inherited from TGedFrame;  TGedFrame (const TGWindow *p=nullptr, Int_t width=140, Int_t height=30, U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewerEditor.html:1722,guid,guides,1722,doc/master/classTGLViewerEditor.html,https://root.cern,https://root.cern/doc/master/classTGLViewerEditor.html,1,['guid'],['guides']
Usability,"node, const char *name, Matrix_t &matrix);  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetDropoutProbability (Scalar_t);  Set Dropout probability. ;  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Static Protected Member Functions; static size_t CalculateNormDim (int axis, size_t c, size_t h, size_t w);  . Private Attributes; Tensor_t fDerivatives;  First fDerivatives of the activations of this layer. ;  ; TDescriptors * fDescriptors = nullptr;  ; Scalar_t fEpsilon;  ; Matrix_t fIVar;  ; Scalar_t fMomentum;  The weight decay. ;  ; Matrix_t fMu;  ; Matrix_t fMu_Training;  ; int fNormAxis;  Normalization axis. For each element of this axis we will compute mean and stddev. ;  ; Tensor_t fReshapedData;  ; int fTrai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html:7819,learn,learningRate,7819,doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); Create progress bar. void SetRange(Float_t min, Float_t max); Set min and max of progress bar. void SetPosition(Float_t pos); Set progress position between [min,max]. void Increment(Float_t inc); Increment progress position. void Reset(); Reset progress bar (i.e. set pos to 0). void SetFillType(TGProgressBar::EFillType type); Set fill type. void SetBarType(TGProgressBar::EBarType type); Set bar type. void SetBarColor(ULong_t color); Set progress bar color. void SetBarColor(const char* color = ""blue""); Set progress bar color. void Format(const char* format = ""%.2f""); Set format for displaying a value. FontStruct_t GetDefaultFontStruct(); Return default font structure in use. const TGGC & GetDefaultGC(); Return default graphics context in use. void SetForegroundColor(Pixel_t pixel); Change text color drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save progress bar parameters as a C++ statement(s) on output stream out. Bool_t fDrawBar; // if true draw only bar in DoRedraw(). TGProgressBar(const TGWindow* p, UInt_t w, UInt_t h, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); { }. Float_t GetMin() const; { return fMin; }. Float_t GetMax() const; { return fMax; }. Float_t GetPosition() const; { return fPos; }. EFillType GetFillType() const; { return fFillType; }. EBarType GetBarType() const; { return fBarType; }. Bool_t GetShowPos() const; { return fShowPos; }. TString GetFormat() const; { return fFormat; }. const char* GetValueFormat() const; { return fFormat.Data(); }. Bool_t UsePercent() const; { return fPercent; }. Pixel_t GetBarColor() const; { return fBarColorGC.GetForeground(); }. GContext_t GetNormGC() const; { return fNormGC; }. FontStruct_t GetFontStruct() const; { ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGProgressBar.html:21643,progress bar,progress bar,21643,root/html602/TGProgressBar.html,https://root.cern,https://root.cern/root/html602/TGProgressBar.html,2,['progress bar'],['progress bar']
Usability,"ns in C++;; -- Return results to python for processing, ploting, etc;; -- Run entire plot making code in python for stacking, labeling, etc.; Granted, this is probably a more complex approach than most of us in physics are willing to tolerate. I suspect that you do not have much choice since the user community wants CINT-like functionality from ROOT (and one feature of the ROOT project that makes it great is a full consideration of what experiments and users need for data taking and analysis).; Thanks for the interesting discussion! I have learned quite a bit about ROOT plans and it all seems very promising. Cheers!. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:52 Permalink . Dependency on Python . In my experience, getting python scripts to work is a very unreliable affair. They almost always have dependencies on external packages and if you don't have EXACTLY the same version of python you only have about a 50% chance that anything you use will work. The language is simply not stable. C++ is bad enough. Scripting languages are much, much worse. The maintainers think the language is their playtoy and they take no responsibility to maintain backward compatibility from release to release. Python is just a Bad Idea(tm). Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:52 Permalink . CINT need to be communitized, that's the whole problem . Indeed, for decade, Cint never made it to open-source because of ROOT dependencies and backward compatiblities. Now that I am seeing this arguement is no more, and we are going to dig up some old grave.. I don't see why Cint shouldn't be taking over by open source or boost. I don't see how we are going to leverage on Clang/Cling at all... all I am seeing is regression session will be made at a far higher degree. I ""plussoie"" Renee's point, mixing technologies is a very , veRY, VERY bad idea. Mostly because Python isn't an ISO standard like many others langage. We should stick to C++ ISO and that's all we ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:19015,simpl,simply,19015,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['simpl'],['simply']
Usability,"ns that the axis; syetem should be define (option ""A"") and that the graph should; be drawn as a simple line (option ""L""). By default a graph is drawn; in the current pad in the current coordinates system. To define a suitable; coordinates system and drawn the axis the option ""A"" must be; specified. TGraphPainter offers many options to paint the various kind of graphs. The TGraphPainter class specializes in the drawing of graphs. It is; separated from the graph so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is not need to call the; Draw() method again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage control on the ROOT command line,; a click inside the pad,; a call to TPad::Update. Graphs' plotting options; Graphs can be drawn with the following options:. ""A""; Axis are drawn around the graph. ""L""; A simple polyline between every points is drawn. ""F""; A fill area is drawn ('CF' draw a smooth fill area). ""C""; A smooth Curve is drawn. ""*""; A Star is plotted at each point. ""P""; Idem with the current marker. ""B""; A Bar chart is drawn at each point. ""1""; ylow=rwymin. ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Several drawing options can be combined. In the following example the graph; is drawn as a smooth curve (option ""C"") and with markers (option ""P""). The; option ""A"" request the definition of the axis. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",200,10,600,400);. c1->SetFillColor(42);; c1->SetGrid();. const Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; gr = new TGraph(n,x,y);; gr->SetLineColor(2);; gr->SetLineWidth(4);; gr->SetMarkerColor(4);; gr->SetMarkerSize(1.5);; gr->SetMarkerStyle(21);; gr->SetTitle(""Option ACP example"");; gr->GetXaxis()->SetTitle(""X title",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphPainter.html:1802,simpl,simple,1802,root/html528/TGraphPainter.html,https://root.cern,https://root.cern/root/html528/TGraphPainter.html,2,['simpl'],['simple']
Usability,"ns |; Private Types |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::Internal::TExecutor Class Reference. ; This class implements the interface to execute the same task multiple times, sequentially or in parallel depending on the execution policy passed as a first parameter on construction, and possibly with different arguments every time. . ROOT::Internal::TExecutor::Map; The two possible usages of the Map method are:. Map(F func, unsigned nTimes): func is executed nTimes with no arguments; Map(F func, T& args): func is executed on each element of the collection of arguments args. For either signature, func is executed as many times as needed by a pool of n workers; where n tipically defaults to the number of cores.; A collection containing the result of each execution is returned.; Note: the user is responsible for the deletion of any object that might be created upon execution of func, returned objects included. ROOT::::Internal::TExecutor never deletes what it returns, it simply forgets it.; Parameters. funca callable object, such as a lambda expression, an std::function, a functor object or a function that takes zero arguments (for the first signature) or one (for the second signature). ; argsa standard vector, a ROOT::TSeq of integer type or an initializer list for the second signature. An integer only for the first. Note: in cases where the function to be executed takes more than zero/one argument but all are fixed except zero/one, the function can be wrapped in a lambda or via std::bind to give it the right signature.; Return value:; An std::vector. The elements in the container will be the objects returned by func. ROOT::Internal::TExecutor::MapReduce; This set of methods behaves exactly like Map, but takes an additional function as a third argument. This function is applied to the set of objects returned by the corresponding Map execution to ""squash"" them into a single object. The signature of the reduce function should be (c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1Internal_1_1TExecutor.html:1209,simpl,simply,1209,doc/v632/classROOT_1_1Internal_1_1TExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1Internal_1_1TExecutor.html,2,['simpl'],['simply']
Usability,"ns: double sized border, white background and a bit wider to allow for text to be printed in the bar. ; Definition at line 238 of file TGProgressBar.cxx. ◆ ~TGHProgressBar(). TGHProgressBar::~TGHProgressBar ; (; ). inlineoverride . Definition at line 108 of file TGProgressBar.h. Member Function Documentation. ◆ Class(). static TClass * TGHProgressBar::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGHProgressBar::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGHProgressBar::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 118 of file TGProgressBar.h. ◆ DeclFileName(). static const char * TGHProgressBar::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 118 of file TGProgressBar.h. ◆ DoRedraw(). void TGHProgressBar::DoRedraw ; (; ). overrideprotectedvirtual . Draw horizontal progress bar. ; Implements TGProgressBar.; Definition at line 265 of file TGProgressBar.cxx. ◆ GetDefaultSize(). TGDimension TGHProgressBar::GetDefaultSize ; (; ); const. inlineoverridevirtual . std::cout << fWidth << ""x"" << fHeight << std::endl; ; Reimplemented from TGFrame.; Definition at line 110 of file TGProgressBar.h. ◆ IsA(). TClass * TGHProgressBar::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGFrame.; Definition at line 118 of file TGProgressBar.h. ◆ SavePrimitive(). void TGHProgressBar::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a horizontal progress bar as a C++ statement(s) on output stream out. ; Reimplemented from TGFrame.; Definition at line 464 of file TGProgressBar.cxx. ◆ ShowPosition(). void TGHProgressBar::ShowPosition ; (; Bool_t ; set = kTRUE, . Bool_t ; percent = kTRUE, . const char * ; format = ""%.2f"" . ). Show postion text, either in percent or form",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:33104,progress bar,progress bar,33104,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,1,['progress bar'],['progress bar']
Usability,"ns;  CrossValidation (TString jobName, TMVA::DataLoader *dataloader, TFile *outputFile, TString options);  ;  CrossValidation (TString jobName, TMVA::DataLoader *dataloader, TString options);  ;  ~CrossValidation ();  ; void Evaluate ();  Does training, test set evaluation and performance evaluation of using cross-evalution. ;  ; Factory & GetFactory ();  ; UInt_t GetNumFolds ();  ; const std::vector< CrossValidationResult > & GetResults () const;  ; TString GetSplitExpr ();  ; void InitOptions ();  ; virtual TClass * IsA () const;  ; void ParseOptions ();  Method to parse the internal option string. ;  ; void SetNumFolds (UInt_t i);  ; void SetSplitExpr (TString splitExpr);  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::Envelope;  ~Envelope ();  Default destructor. ;  ; virtual void BookMethod (TString methodname, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; virtual void BookMethod (Types::EMVA method, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; DataLoader * GetDataLoader ();  Method to get the pointer to TMVA::DataLoader object. ;  ; TFile * GetFile ();  Method to get the pointer to TFile object. ;  ; std::vector< OptionMap > & GetMethods ();  Method get the Booked methods in a option map object. ;  ; Bool_t HasMethod (TString methodname, TString methodtitle);  function to check methods booked ;  ; Bool_t IsModelPersistence ();  Method to see if the algorithm model is saved in xml or serialized files. ;  ; Bool_t IsSilentFile ();  Method to see if a file is available to save results. ;  ; Bool_t IsVerbose ();  Method to see if the algorithm should print extra information. ;  ; void SetDataLoader (DataLoader *dalaloader);  Method to set the pointer to TMVA::DataLoader object. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CrossValidation.html:2199,learn,learning,2199,doc/master/classTMVA_1_1CrossValidation.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CrossValidation.html,1,['learn'],['learning']
Usability,"nset = 0, Bool_t clipInvalid = kFALSE) const; static voidblockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); const TMatrixDSym&covarianceMatrix() const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMultiVarGaussian.html:3087,clear,clearValueDirty,3087,root/html526/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html526/RooMultiVarGaussian.html,1,['clear'],['clearValueDirty']
Usability,"nset, . const char * ; rangeName, . int & ; code . ); const. protected . Retrieve object representing projection integral of input p.d.f over observables iset, while normalizing over observables nset. ; The code argument returned by reference is the unique code defining this particular projection configuration ; Definition at line 109 of file RooProjectedPdf.cxx. ◆ initGenerator(). void RooProjectedPdf::initGenerator ; (; Int_t ; code). inlineoverridevirtual . Interface for one-time initialization to setup the generator for the specified code. ; Reimplemented from RooAbsPdf.; Definition at line 34 of file RooProjectedPdf.h. ◆ IsA(). TClass * RooProjectedPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 73 of file RooProjectedPdf.h. ◆ printMetaArgs(). void RooProjectedPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the integration operation. ; Reimplemented from RooAbsArg.; Definition at line 254 of file RooProjectedPdf.cxx. ◆ redirectServersHook(). bool RooProjectedPdf::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overrideprotectedvirtual . Intercept a server redirection all and update list of dependents if necessary Specifically update the set proxy 'deps' which introduces the dependency on server value dirty flags of ourselves. ; Reimplemented from RooAbsPdf.; Definition at line 211 of file RooProjectedPdf.cxx. ◆ selfNormalized(). bool RooProjectedPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 36 of file RooProjectedPdf.h. ◆ Streamer(). void Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProjectedPdf.html:80025,intuit,intuitively,80025,doc/master/classRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classRooProjectedPdf.html,1,['intuit'],['intuitively']
Usability,"nsion] Array of pointers to variables formula; Bool_t*fVarMultiple![fDimension] true if fVar[i] has a variable index; Double_t*fVmax![fDimension] Maxima of varexp columns; Double_t*fVmin![fDimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight); static TSelectorDraw::(anonymous)kWarn. Class Charts. Inheritance Chart:. TObject. ←; TSelector. ←; TSelectorDraw. ←. TEvePointSelector. TEveSelectorToEventList. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Return the last values corresponding to the i-th component; of the formula being processed (where the component are ':' separated).; The actual number of entries is:; GetSelectedRows() % tree->GetEstimate(); Note GetSelectedRows currently returns the actual number of values plotted; and thus if the formula contains arrays, this number might be greater than; the number of entries in the trees.; By default TTree::Draw creates the arrays obtained; with all GetVal and GetW with a length corresponding to the; parameter fEstimate. By default fEstimate=10000 and can be modified; via TTree::SetEstim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelectorDraw.html:10506,simpl,simplest,10506,root/html602/TSelectorDraw.html,https://root.cern,https://root.cern/root/html602/TSelectorDraw.html,2,['simpl'],['simplest']
Usability,"nsional array; TNDArrayT<float> N-dimensional array; TNDArrayT<int> N-dimensional array; TNDArrayT<long> N-dimensional array; TNDArrayT<short> N-dimensional array; TNDArrayT<unsigned int> N-dimensional array; TNDArrayT<unsigned long> N-dimensional array; TNDArrayT<unsigned short> N-dimensional array; TNamed The basis for a named object (name, title); TNetFile A ROOT file that reads/writes via a rootd server; TNetFileStager Implementation for a 'rootd' backend; TNetSystem Directory handler for NetSystem; TNetXNGFile ROOT class definition; TNetXNGFileStager ! Interface to a 'XRD' staging; TNetXNGSystem ROOT class definition; TNeuron Neuron for MultiLayerPerceptrons; TNewChainDlg New chain dialog; TNewQueryDlg New query dialog; TNode Description of parameters to position a 3-D geometry object; TNodeDiv Description of parameters to divide a 3-D geometry object; TNonSplitBrowsable Helper object to browse unsplit objects; TNtuple A simple tree with branches of floats.; TNtupleD A simple tree with branches of floats.; TObjArray An array of objects; TObjArrayIter Object array iterator; TObjString Collectable string class; TObject Basic ROOT object; TObjectRefSpy Spy object reference for deletion; TObjectSet TDataSet wrapper for TObject class objects; TObjectSpy Spy object pointer for deletion; TObjectTable Table of active objects; TOptionListItem Element in the list of options.; TOrdCollection An ordered collection; TOrdCollectionIter Ordered collection iterator; TOutputListSelectorDataMap Converter from output list to TSelector data members; TPARA PARA shape; TPBHandleDSType Streamable PBHandleDSType; TPBHistType Streamable PBHistType; TPBReadType Streamable PBReadType; TPCON PCON shape; TPDF PDF driver; TPGON PGON shape; TPMERegexp Wrapper for Perl-like regular expression matching.; TPRegexp Perl Compatible Regular Expression Class; TPServerSocket Parallel server socket; TPSocket Parallel client socket; TPackageDescription Package description; TPacketizer Generate work pac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:110894,simpl,simple,110894,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['simpl'],['simple']
Usability,"nsional array; TNDArrayT<float> N-dimensional array; TNDArrayT<int> N-dimensional array; TNDArrayT<long> N-dimensional array; TNDArrayT<short> N-dimensional array; TNDArrayT<unsigned int> N-dimensional array; TNDArrayT<unsigned long> N-dimensional array; TNDArrayT<unsigned short> N-dimensional array; TNamed The basis for a named object (name, title); TNetFile A ROOT file that reads/writes via a rootd server; TNetFileStager Implementation for a 'rootd' backend; TNetSystem Directory handler for NetSystem; TNetXNGFile ROOT class definition; TNetXNGFileStager ! Interface to a 'XRD' staging; TNetXNGSystem ROOT class definition; TNeuron Neuron for MultiLayerPerceptrons; TNewChainDlg New chain dialog; TNewQueryDlg New query dialog; TNode Description of parameters to position a 3-D geometry object; TNodeDiv Description of parameters to divide a 3-D geometry object; TNonSplitBrowsable Helper object to browse unsplit objects; TNtuple A simple tree with branches of floats.; TNtupleD A simple tree with branches of floats.; TObjArray An array of objects; TObjArrayIter Object array iterator; TObjString Collectable string class; TObject Basic ROOT object; TObjectRefSpy Spy object reference for deletion; TObjectSet TDataSet wrapper for TObject class objects; TObjectSpy Spy object pointer for deletion; TObjectTable Table of active objects; TOrdCollection An ordered collection; TOrdCollectionIter Ordered collection iterator; TOutputListSelectorDataMap Converter from output list to TSelector data members; TPARA PARA shape; TPBHandleDSType Streamable PBHandleDSType; TPBHistType Streamable PBHistType; TPBReadType Streamable PBReadType; TPCON PCON shape; TPDF PDF driver; TPGON PGON shape; TPMERegexp Wrapper for Perl-like regular expression matching.; TPRegexp Perl Compatible Regular Expression Class; TPServerSocket Parallel server socket; TPSocket Parallel client socket; TPackageDescription Package description; TPacketizer Generate work packets for parallel processing; TPacketizerAdaptive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:117089,simpl,simple,117089,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['simpl'],['simple']
Usability,"nsional general purpose Monte Carlo event generator (integrator) with hyper-cubical ""foam of cells"". Certain features of full version of FOAM are omitted. mFOAM is intended as an easy to use tool for MC simulation/integration in few dimensions. It relies heavily on ROOT package, borrowing persistency of classes from ROOT. mFOAM can be easily used from the ROOT shell. For more difficult problems the full FOAM may be better. How to run application programs ?; The application program can be run in two modes: it can be simply interpreted by CLING or compiled. The first method is simpler but results in slower execution. The second method employs ACLiC - The Automatic Compiler of Libraries, which automatizes the process of compilation and linking.; In /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials there are 3 demonstration programs:; foam_kanwa.C; is a simple example how to run FOAM in interactive mode. To run this macro issue the following simple command from the Linux shell:; root foam_kanwa.C; or from CLING:; root [0] .x foam_kanwa.C; Simulation will start and graphical canvas with plot of the distribution function appear. In this example we defined the distribution function simply as a global function function Camel2.; foam_demo.C; shows usage of FOAM in compiled mode, which is the preferred method. The integrand function is defined now as a Density method from class TFDISTR inheriting from abstract class TFoamIntegrand. User can modify interface to integrand function according to their needs but they should always remember to define Density method which provides the density distribution. Enter CLING interpreter and type:; root [0] gSystem->Load(""libFoam.so""); root [1] .x foam_demo.C+; to load FOAM library, compile and execute macro foam_demo.C. A shared object foam_demo_C.so is created in the current directory. At the end of exploration phase FOAM object including distribution function will be written to disk.; foam_demopers",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__FOAM.html:1225,simpl,simple,1225,doc/master/group__tutorial__FOAM.html,https://root.cern,https://root.cern/doc/master/group__tutorial__FOAM.html,1,['simpl'],['simple']
Usability,"nsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFractionFitter.html:17553,simpl,simply,17553,root/html534/TFractionFitter.html,https://root.cern,https://root.cern/root/html534/TFractionFitter.html,1,['simpl'],['simply']
Usability,"nsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFractionFitter.html:16381,simpl,simply,16381,root/html528/TFractionFitter.html,https://root.cern,https://root.cern/root/html528/TFractionFitter.html,3,['simpl'],['simply']
Usability,"nsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. unsigned intfDimdimension of the function to be minimized ; vector<double>fErrors; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; ROOT::Minuit2::FunctionMinimum*fMinimum; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; boolfUseFumili; vector<double>fValues. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Minuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad). Default constructor. Minuit2Minimizer(const char* type). Constructor with a char (used by PM). virtual ~Minuit2Minimizer(). Destructor (no operations). Minuit2Minimizer(const ROOT::Minuit2::Minuit2Minimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. void Clear(); clear resources (parameters) for consecutives minimizations. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__Minuit2Minimizer.html:6293,clear,clear,6293,root/html534/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__Minuit2Minimizer.html,1,['clear'],['clear']
Usability,"nspector;  Utility class to plot conditional MLE of nuisance parameters vs. More...;  ; class  ProfileLikelihoodCalculator;  The ProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for tools which can produce both a RooStats HypoTestResult and ConfInterval). More...;  ; class  ProfileLikelihoodTestStat;  ProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset. More...;  ; class  ProofConfig;  Holds configuration options for proof and proof-lite. More...;  ; class  ProposalFunction;  ProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm. More...;  ; class  ProposalHelper;  ; class  RatioOfProfiledLikelihoodsTestStat;  TestStatistic that returns the ratio of profiled likelihoods. More...;  ; struct  RooStatsConfig;  ; class  SamplingDistPlot;  This class provides simple and straightforward utilities to plot SamplingDistribution objects. More...;  ; class  SamplingDistribution;  This class simply holds a sampling distribution of some test statistic. More...;  ; class  SamplingSummary;  ; class  SamplingSummaryLookup;  ; class  SequentialProposal;  Class implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step. More...;  ; class  SimpleInterval;  SimpleInterval is a concrete implementation of the ConfInterval interface. More...;  ; class  SimpleLikelihoodRatioTestStat;  TestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood. More...;  ; class  SPlot;  A class to calculate ""sWeights"" used to create an ""sPlot"". More...;  ; class  TestStatistic;  TestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class. More...;  ; class  TestStatSampler;  TestStatSampler is an interface",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:7051,simpl,simple,7051,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['simpl'],['simple']
Usability,"nst RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:6691,clear,clearValueAndShapeDirty,6691,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,3,['clear'],['clearValueAndShapeDirty']
Usability,"nst RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooAbsReal*RooAbsPdf::createChi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo2DKeysPdf.html:2809,clear,clearValueDirty,2809,root/html532/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html532/Roo2DKeysPdf.html,1,['clear'],['clearValueDirty']
Usability,"nst TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBBoxEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBBoxEditor.html:21326,undo,undoing,21326,root/html528/TGeoBBoxEditor.html,https://root.cern,https://root.cern/root/html528/TGeoBBoxEditor.html,1,['undo'],['undoing']
Usability,"nst TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBBoxEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoBBoxEditor.html:21426,undo,undoing,21426,root/html530/TGeoBBoxEditor.html,https://root.cern,https://root.cern/root/html530/TGeoBBoxEditor.html,1,['undo'],['undoing']
Usability,"nst TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBBoxEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoBBoxEditor.html:21426,undo,undoing,21426,root/html532/TGeoBBoxEditor.html,https://root.cern,https://root.cern/root/html532/TGeoBBoxEditor.html,1,['undo'],['undoing']
Usability,"nst TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); the standard constructor for just an ordinar ""decision trees"". MethodDT(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from Reader. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodDT.html:22179,simpl,simply,22179,root/html534/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodDT.html,1,['simpl'],['simply']
Usability,"nst TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); the standard constructor for just an ordinar ""decision trees"". MethodDT(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from Reader. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Bool_t MonitorBoost(TMVA::MethodBoost* booster). Double_t PruneTree(const Int_t methodIndex). Double_t TestTreeQuality(TMVA::DecisionTree* dt). void AddWeightsXMLTo(void* parent) const. void ReadWeightsFro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodDT.html:21179,simpl,simply,21179,root/html528/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html,3,['simpl'],['simply']
Usability,"nst char *cmd, const char *ord, Bool_t logtomacro=kFALSE);  Send command to be executed on node of ordinal 'ord' (use ""0"" for master). ;  ; void Feedback (TList *objs);  Get list of feedback objects. ;  ; Long64_t Finalize (const char *queryref, Bool_t force=kFALSE);  Finalize query with reference ref. ;  ; Long64_t Finalize (Int_t query=-1, Bool_t force=kFALSE);  Finalize the qry-th query in fQueries. ;  ; TList * FindDataSets (const char *searchString, const char *optStr="""");  Find datasets, returns in a TList all found datasets. ;  ; Long64_t GetBytesRead () const;  ; Int_t GetClientProtocol () const;  ; const char * GetConfDir () const;  ; const char * GetConfFile () const;  ; Float_t GetCpuTime () const;  ; const char * GetDataPoolUrl () const;  ; TMap * GetDataSetQuota (const char *optStr="""");  returns a map of the quotas of all groups ;  ; TString Getenv (const char *env, const char *ord=""0"");  Get value of environment variable 'env' on node 'ord'. ;  ; TList * GetFeedbackList () const;  Return feedback list. ;  ; const char * GetGroup () const;  ; const char * GetImage () const;  ; TList * GetInputList ();  Get input list. ;  ; TMacro * GetLastLog ();  Fill a TMacro with the log lines since the last reading (fLogFileR) Return (TMacro *)0 if no line was logged. ;  ; TList * GetListOfEnabledPackages ();  Get from the master the list of names of the packages enabled. ;  ; TList * GetListOfPackages ();  Get from the master the list of names of the packages available. ;  ; TList * GetListOfSlaveInfos ();  Returns list of TSlaveInfo's. In case of error return 0. ;  ; TList * GetLoadedMacros () const;  ; void GetLog (Int_t start=-1, Int_t end=-1);  Ask for remote logs in the range [start, end]. ;  ; Int_t GetLogLevel () const;  ; TMacro * GetMacroLog ();  ; TProofMgr * GetManager ();  ; const char * GetMaster () const;  ; void GetMaxQueries ();  Get max number of queries whose full results are kept in the remote sandbox. ;  ; TFileCollection * GetMissingFiles (TQue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:10897,feedback,feedback,10897,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['feedback'],['feedback']
Usability,"nst char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; void HandleCheckFile (TMessage *mess);  Handle file checking request. ;  ;  Protected Member Functions inherited from TApplication;  TApplication ();  Default ctor. Can be used by classes deriving from TApplication. ;  ; virtual void Forum (const char *line);  The function ("".forum <type>"") submits a new post on the ROOT forum via web browser. ;  ; virtual void GitHub (const char *line);  The function ("".gh <type>"") submits a new issue on GitHub via web browser. ;  ; virtual void Help (const char *line);  The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ;  ; virtual void LoadGraphicsLibs ();  Load shared libs necessary for graphics. ;  ; virtual void MakeBatch ();  Switch to batch mode. ;  ; virtual Longptr_t ProcessRemote (const char *line, Int_t *error=nullptr);  Process the content of a line starting with "".R"" (already stripped-off) The format is. ;  ; void SetSignalHandler (TSignalHandler *sh);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Static Protected Member Functions; static void ErrorHandler (Int_t level, Bool_t abort, const char *location, const char *msg);  The error handler function. ;  ;  Static Protected Member Functions inherited from TApplicati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:18375,guid,guide,18375,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['guid'],['guide']
Usability,"nst char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooThresholdCategory.html:2225,clear,clearValueDirty,2225,root/html532/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html,1,['clear'],['clearValueDirty']
Usability,"nst debug (non-debug) ROOT? . Microsoft's STL classes (std::string, std::vector,...) are different for debug and optimized mode. When calling a ROOT function that expects a STL object as an argument, the caller (e.g. your code) and ROOT must agree on what the object looks like. Thus if you link against ROOT libraries built as debug (non-debug) you must also compile your code as debug (non-debug). ACLiC does that automatically for you. ; . Changing the Displayed Title in Canvas. . Disable the title and add yourself your own title with a TPaveLabel: ; gStyle->SetOptTitle(0);; TPaveLabel *title = new TPaveLabel(.11,.95,.35,.99,""new title"",""brndc"");; title->Draw(); ; Changing the Displayed Title in Canvas. ; . Segmentation violation in TASImage::InitVisual () on Mac . The configure command should specify explicitly where ROOT should find all X11-related libs. ./configure --with-x11-libdir=/opt/local/lib/ ; --with-xpm-libdir=/opt/local/lib/ ; --with-xft-libdir=/opt/local/lib/ ; --with-xext-libdir=/opt/local/lib/; A simple Draw(0 or a Browser opening might cause a Segmentation violation in TASImage::InitVisual () on Mac. ; . How do I start PROOF? . Type at the ROOT prompt:. root [0] TProof::Open(""""); How do I start PROOF? ; . How to render graphics in a file, without displaying the image on the screen ? . Run in batch mode:. root -b -q myscript.C. or in your program add:. gROOT->SetBatch();; ; . Prerequisites for building ROOT from source. . To successfully build ROOT a number of prerequisite packages must be installed. Check the prerequisites page for the list of packages needed for your platform.; ; . How to use ROOT libraries in Xcode on Mac OS X? . The easiest way is to use cmake and let it create the Xcode project, this has the advantage that the dictionaries are created automatically. The CMakeLists.txt file will define the libraries and executables to be added to the Xcode project. An example from the ROOT Event example (found in root/test) can be downloaded here. J",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/faq-page.html:6275,simpl,simple,6275,d/faq-page.html,https://root.cern,https://root.cern/d/faq-page.html,1,['simpl'],['simple']
Usability,"nst. inline . Definition at line 122 of file TGTextEntry.h. ◆ HasOwnFont(). Bool_t TGTextEntry::HasOwnFont ; (; ); const. inline . Definition at line 158 of file TGTextEntry.h. ◆ Home(). void TGTextEntry::Home ; (; Bool_t ; mark = kFALSE). Moves the text cursor to the left end of the line. ; If mark is kTRUE text will be marked towards the first position, if not any marked text will be unmarked if the cursor is moved. See also End(). ; Definition at line 983 of file TGTextEntry.cxx. ◆ Init(). void TGTextEntry::Init ; (; ). protectedvirtual . Do default initialization. ; Definition at line 315 of file TGTextEntry.cxx. ◆ Insert(). void TGTextEntry::Insert ; (; const char * ; newText). virtual . Removes any currently selected text, inserts newText, sets it as the new contents of the text entry. ; Definition at line 779 of file TGTextEntry.cxx. ◆ InsertText(). void TGTextEntry::InsertText ; (; const char * ; text, . Int_t ; pos . ). virtual . Inserts text at position pos, clears the selection and moves the cursor to the end of the line. ; If necessary the text is truncated to fit MaxLength(). See also GetText(), SetText(), AppendText(), RemoveText(). ; Definition at line 1675 of file TGTextEntry.cxx. ◆ IsA(). TClass * TGTextEntry::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGFrame.; Definition at line 184 of file TGTextEntry.h. ◆ IsCursorOutOfFrame(). Bool_t TGTextEntry::IsCursorOutOfFrame ; (; ). protectedvirtual . Returns kTRUE if cursor is out of frame. ; Definition at line 1568 of file TGTextEntry.cxx. ◆ IsEdited(). Bool_t TGTextEntry::IsEdited ; (; ); const. inline . Definition at line 129 of file TGTextEntry.h. ◆ IsFrameDrawn(). Bool_t TGTextEntry::IsFrameDrawn ; (; ); const. inline . Definition at line 128 of file TGTextEntry.h. ◆ Layout(). void TGTextEntry::Layout ; (; ). inlineoverridevirtual . Reimplemented from TGFrame.; Definition at line 130 of file TGTextEntry.h. ◆ MarkWord(). void TGTextEntry::M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEntry.html:57866,clear,clears,57866,doc/master/classTGTextEntry.html,https://root.cern,https://root.cern/doc/master/classTGTextEntry.html,1,['clear'],['clears']
Usability,"nst; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:3974,clear,clearShapeDirty,3974,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,2,['clear'],['clearShapeDirty']
Usability,"nst; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:4420,clear,clearShapeDirty,4420,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,1,['clear'],['clearShapeDirty']
Usability,"nst; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:4420,clear,clearShapeDirty,4420,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,3,['clear'],['clearShapeDirty']
Usability,"nst;  ; TSessionOutputFrame * GetOutputFrame () const;  ; TGPopupMenu * GetPopupQry () const;  ; TGPopupMenu * GetPopupSrv () const;  ; const TGPicture * GetProofConPict () const;  ; const TGPicture * GetProofDisconPict () const;  ; const TGPicture * GetQueryConPict () const;  ; const TGPicture * GetQueryDisconPict () const;  ; TSessionQueryFrame * GetQueryFrame () const;  ; TSessionServerFrame * GetServerFrame () const;  ; TSessionFrame * GetSessionFrame () const;  ; TGListTree * GetSessionHierarchy () const;  ; TGListTreeItem * GetSessionItem () const;  ; TList * GetSessions () const;  ; TGStatusBar * GetStatusBar () const;  ; Bool_t HandleTimer (TTimer *) override;  Handle animation timer. ;  ; TClass * IsA () const override;  ; Bool_t IsAutoSave () const;  ; Bool_t IsBusy () const;  ; void LogMessage (const char *msg, Bool_t all);  Load/append a log msg in the log frame. ;  ; void MyHandleMenu (Int_t);  Handle session viewer custom popup menus. ;  ; void OnCascadeMenu ();  Handle feedback histograms configuration menu. ;  ; void OnListTreeClicked (TGListTreeItem *entry, Int_t btn, Int_t x, Int_t y);  Handle mouse clicks in list tree. ;  ; void OnListTreeDoubleClicked (TGListTreeItem *entry, Int_t btn);  Handle mouse double clicks in list tree (connect to server). ;  ; Bool_t ProcessMessage (Longptr_t msg, Longptr_t parm1, Longptr_t) override;  Handle messages send to the TSessionViewer object. ;  ; void QueryResultReady (char *query);  Handle signal ""query result ready"" coming from Proof session. ;  ; void ReadConfiguration (const char *filename=nullptr);  Read configuration file and populate list of sessions list of queries and list of packages. ;  ; void ResetSession ();  Reset Proof session. ;  ; void SetBusy (Bool_t busy=kTRUE);  ; void SetChangePic (Bool_t change);  ; void SetLogWindow (TSessionLogView *log);  ; void ShowEnabledPackages ();  Query list of enabled packages from proof and display it into a new text window. ;  ; void ShowInfo (const char *txt)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionViewer.html:2683,feedback,feedback,2683,doc/master/classTSessionViewer.html,https://root.cern,https://root.cern/doc/master/classTSessionViewer.html,1,['feedback'],['feedback']
Usability,"nstance when changing from; 289/// signal to background tree, or using TChains as input) The; 290/// TTreeFormulas, that hold the input expressions need to be; 291/// re-associated with the new tree, which is done here; 292 ; 293void TMVA::DataSetFactory::ChangeToNewTree( TreeInfo& tinfo, const DataSetInfo & dsi ); 294{; 295 TTree *tr = tinfo.GetTree()->GetTree();; 296 ; 297 //tr->SetBranchStatus(""*"",1); // nor needed when using TTReeFormula; 298 tr->ResetBranchAddresses();; 299 ; 300 Bool_t hasDollar = kTRUE; // Set to false if wants to enable only some branch in the tree; 301 ; 302 // 1) the input variable formulas; 303 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << "" create input formulas for tree "" << tr->GetName() << Endl;; 304 std::vector<TTreeFormula*>::const_iterator formIt, formItEnd;; 305 for (formIt = fInputFormulas.begin(), formItEnd=fInputFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 306 fInputFormulas.clear();; 307 TTreeFormula* ttf = 0;; 308 fInputTableFormulas.clear(); // this contains shallow pointer copies; 309 ; 310 bool firstArrayVar = kTRUE;; 311 int firstArrayVarIndex = -1;; 312 int arraySize = -1;; 313 for (UInt_t i = 0; i < dsi.GetNVariables(); i++) {; 314 ; 315 // create TTreeformula; 316 if (! dsi.IsVariableFromArray(i) ) {; 317 ttf = new TTreeFormula(Form(""Formula%s"", dsi.GetVariableInfo(i).GetInternalName().Data()),; 318 dsi.GetVariableInfo(i).GetExpression().Data(), tr);; 319 CheckTTreeFormula(ttf, dsi.GetVariableInfo(i).GetExpression(), hasDollar);; 320 fInputFormulas.emplace_back(ttf);; 321 fInputTableFormulas.emplace_back(std::make_pair(ttf, (Int_t) 0));; 322 } else {; 323 // it is a variable from an array; 324 if (firstArrayVar) {; 325 ; 326 // create a new TFormula; 327 ttf = new TTreeFormula(Form(""Formula%s"", dsi.GetVariableInfo(i).GetInternalName().Data()),; 328 dsi.GetVariableInfo(i).GetExpression().Data(), tr);; 329 CheckTTreeFormula(ttf, dsi.GetVariableInfo(i).GetExpression(), hasDollar);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:12145,clear,clear,12145,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['clear'],['clear']
Usability,"nstructor ; Definition at line 2256 of file TGeoMatrix.cxx. ◆ TGeoGenTrans() [4/4]. TGeoGenTrans::TGeoGenTrans ; (; const char * ; name, . Double_t ; dx, . Double_t ; dy, . Double_t ; dz, . Double_t ; sx, . Double_t ; sy, . Double_t ; sz, . TGeoRotation * ; rot . ). constructor ; Definition at line 2269 of file TGeoMatrix.cxx. ◆ ~TGeoGenTrans(). TGeoGenTrans::~TGeoGenTrans ; (; ). override . destructor ; Definition at line 2282 of file TGeoMatrix.cxx. Member Function Documentation. ◆ Class(). static TClass * TGeoGenTrans::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoGenTrans::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoGenTrans::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 395 of file TGeoMatrix.h. ◆ Clear(). void TGeoGenTrans::Clear ; (; Option_t * ; option = """"). overridevirtual . clear the fields of this transformation ; Reimplemented from TGeoCombiTrans.; Definition at line 2287 of file TGeoMatrix.cxx. ◆ DeclFileName(). static const char * TGeoGenTrans::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 395 of file TGeoMatrix.h. ◆ GetScale(). const Double_t * TGeoGenTrans::GetScale ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoCombiTrans.; Definition at line 393 of file TGeoMatrix.h. ◆ Inverse(). TGeoHMatrix TGeoGenTrans::Inverse ; (; ); const. overridevirtual . Return a temporary inverse of this. ; Reimplemented from TGeoCombiTrans.; Definition at line 2312 of file TGeoMatrix.cxx. ◆ IsA(). TClass * TGeoGenTrans::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoCombiTrans.; Definition at line 395 of file TGeoMatrix.h. ◆ MakeClone(). TGeoMatrix * TGeoGenTrans::MakeClone ; (; ); const. inlineoverridevirtual . Make a clone of this matrix. ; Reimplemented from TGeoC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoGenTrans.html:20108,clear,clear,20108,doc/master/classTGeoGenTrans.html,https://root.cern,https://root.cern/doc/master/classTGeoGenTrans.html,1,['clear'],['clear']
Usability,"nstructor from TEveUtil Monte Carlo track. TEveTrack(TEveRecTrackD* t, TEveTrackPropagator* prop = 0); Constructor from TEveRecTrack<double> reconstructed track. TEveTrack(TEveRecTrack* t, TEveTrackPropagator* prop = 0); Constructor from TEveRecTrack<float> reconstructed track.; It is recomended to use constructor with TEveRecTrack<double> since; TEveTrackPropagator operates with double type. TEveTrack(const TEveTrack& t); Copy constructor. Track paremeters are copied but the; extrapolation is not perfermed so you should still call; MakeTrack() to do that.; If points of 't' are locked, they are cloned. ~TEveTrack(); Destructor. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Returns list-tree icon for TEveTrack. void ComputeBBox(); Compute the bounding box of the track. void SetStdTitle(); Set standard track title based on most data-member values. void SetTrackParams(const TEveTrack& t); Copy track parameters from t. Track-propagator is set, too.; PathMarks are cleared - you can copy them via SetPathMarks(t).; If track 't' is locked, you should probably clone its points; over - use TEvePointSet::ClonePoints(t);. void SetPathMarks(const TEveTrack& t); Copy path-marks from t. void SetPropagator(TEveTrackPropagator* prop); Set track's render style.; Reference counts of old and new propagator are updated. void SetAttLineAttMarker(TEveTrackList* tl); Set line and marker attributes from TEveTrackList. void MakeTrack(Bool_t recurse = kTRUE); Calculate track representation based on track data and current; settings of the propagator.; If recurse is true, descend into children. void CopyVizParams(const TEveElement* el); Copy visualization parameters from element el. void WriteVizParams(ostream& out, const TString& var); Write visualization parameters. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, return TEveTrackProjected class. void SortPathMarksByTime(); Sort registerd pat-marks by time. void PrintPathMarks(); Print registered ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveTrack.html:31330,clear,cleared,31330,root/html530/TEveTrack.html,https://root.cern,https://root.cern/root/html530/TEveTrack.html,2,['clear'],['cleared']
Usability,"nstructor from TEveUtil Monte Carlo track. TEveTrack(TEveRecTrackD* t, TEveTrackPropagator* prop = 0); Constructor from TEveRecTrack<double> reconstructed track. TEveTrack(TEveRecTrack* t, TEveTrackPropagator* prop = 0); Constructor from TEveRecTrack<float> reconstructed track.; It is recomended to use constructor with TEveRecTrack<double> since; TEveTrackPropagator operates with double type. TEveTrack(const TEveTrack& t); Copy constructor. Track paremeters are copied but the; extrapolation is not perfermed so you should still call; MakeTrack() to do that.; If points of 't' are locked, they are cloned. ~TEveTrack(); Destructor. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Returns list-tree icon for TEveTrack. void ComputeBBox(); Compute the bounding box of the track. void SetStdTitle(); Set standard track title based on most data-member values. void SetTrackParams(const TEveTrack& t); Copy track parameters from t. Track-propagator is set, too.; PathMarks are cleared - you can copy them via SetPathMarks(t).; If track 't' is locked, you should probably clone its points; over - use TEvePointSet::ClonePoints(t);. void SetPathMarks(const TEveTrack& t); Copy path-marks from t. void SetPropagator(TEveTrackPropagator* prop); Set track's render style.; Reference counts of old and new propagator are updated. void SetAttLineAttMarker(TEveTrackList* tl); Set line and marker attributes from TEveTrackList. void MakeTrack(Bool_t recurse = kTRUE); Calculate track representation based on track data and current; settings of the propagator.; If recurse is true, descend into children. void CopyVizParams(const TEveElement* el); Copy visualization parameters from element el. void WriteVizParams(ostream& out, const TString& var); Write visualization parameters. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, return TEveTrackProjected class. void SortPathMarksByTime(); Sort registered pat-marks by time. void PrintPathMarks(); Print registered",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrack.html:31862,clear,cleared,31862,root/html534/TEveTrack.html,https://root.cern,https://root.cern/root/html534/TEveTrack.html,3,['clear'],['cleared']
Usability,"nstructor. ~RooNumConvPdf(); Destructor. Double_t evaluate() const; Calculate and return value of p.d.f. void initialize() const; One-time initialization of object. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return appropriate generator context for this convolved p.d.f. If both pdf and resolution; model support internal generation return and optimization convolution generation context; that uses a smearing algorithm. Otherwise return a standard accept/reject sampling; context on the convoluted shape. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooNumConvPdf(*this,newname) ; }. RooNumIntConfig& convIntConfig(); Calls forwarded to RooNumConvolution. { return conv().convIntConfig() ; }. void clearConvolutionWindow(); { conv().clearConvolutionWindow() ; }. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); { conv().setConvolutionWindow(centerParam,widthParam,widthScaleFactor) ; }. void setCallWarning(Int_t threshold = 2000); { conv().setCallWarning(threshold) ; }. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); { conv().setCallProfiling(flag,nbinX,nbinCall,nCallHigh) ; }. const TH2* profileData() const; { return conv().profileData() ; }. RooRealVar& var() const; Access components. { return (RooRealVar&)(const_cast<RooAbsReal&>(_origVar.arg())) ; }. RooAbsReal& pdf() const; { return const_cast<RooAbsReal&>(_origPdf.arg()) ; }. RooAbsReal& model() const; { return const_cast<RooAbsReal&>(_origModel.arg()) ; }. RooNumConvolution& conv() const; WVE Store all properties of RooNumConvolution here so that can be take; along in the copy ctor. { if (!_init) initialize() ; return *_conv ; }. » ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:43652,clear,clearConvolutionWindow,43652,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,7,['clear'],['clearConvolutionWindow']
Usability,"nt . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Support Guidelines for submitting a bug. Introduction; The RootTalk mailing list and forum can be used to pass information of general interest to the ROOT user community or to submit problems that you cannot solve with the information provided in the Documentation. Several thousands users read the list and forum and my provide you with solutions to your problem.; Only if you are convinced that your problem is a real bug of the ROOT software then follow the instructions on how to report a bug with JIRA.; When you submit a bug, please follow these guidelines:. If you submit a problem, always indicate your ROOT version number (e.g. 6.02.00, 5.34.22) and the platform you are running on (e.g. Ubuntu 14 gcc49, SLC6 clang35).; The bug title subject line should clearly identify the problem.; If you use a non recent version of ROOT, try to test your problem with newer version. If this is too difficult, consult the release and development notes to check if your problem has not already been solved.; Try to quickly search the internet and look in the forum if your problem has been already solved.; Try to share the maximum amount of information. A bug report which only says ""My macro crashes when running on kubuntu but on windows works"" is much less likely to be solved quickly than a complete message with a gdb stacktrace and a reproducer (see next item).; Send a minimal program or macro reproducing the problem. Make sure that your script can be executed directly. If it uses a data file, send the smallest possible data file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/guidelines-submitting-bug.html:2420,guid,guidelines,2420,d/guidelines-submitting-bug.html,https://root.cern,https://root.cern/d/guidelines-submitting-bug.html,1,['guid'],['guidelines']
Usability,"nt algorithm (SGD) ; Implements a steepest gradient descent minimization algorithm ; Definition at line 333 of file NeuralNet.h. Public Member Functions;  Steepest (double learningRate=1e-4, double momentum=0.5, size_t repetitions=10);  c'tor ;  ; template<typename Function , typename Weights , typename PassThrough > ; double operator() (Function &fitnessFunction, Weights &weights, PassThrough &passThrough);  operator to call the steepest gradient descent algorithm ;  . Public Attributes; double m_alpha;  internal parameter (learningRate) ;  ; double m_beta;  internal parameter (momentum) ;  ; std::vector< double > m_localGradients;  local gradients for reuse in thread. ;  ; std::vector< double > m_localWeights;  local weights for reuse in thread. ;  ; std::vector< double > m_prevGradients;  vector remembers the gradients of the previous step ;  ; size_t m_repetitions;  . #include <TMVA/NeuralNet.h>; Constructor & Destructor Documentation. ◆ Steepest(). TMVA::DNN::Steepest::Steepest ; (; double ; learningRate = 1e-4, . double ; momentum = 0.5, . size_t ; repetitions = 10 . ). inline . c'tor ; C'tor; Parameters. learningRatedenotes the learning rate for the SGD algorithm ; momentumfraction of the velocity which is taken over from the last step ; repetitionsre-compute the gradients each ""repetitions"" steps . Definition at line 348 of file NeuralNet.h. Member Function Documentation. ◆ operator()(). template<typename Function , typename Weights , typename PassThrough > . double TMVA::DNN::Steepest::operator() ; (; Function & ; fitnessFunction, . Weights & ; weights, . PassThrough & ; passThrough . ). operator to call the steepest gradient descent algorithm ; implementation of the steepest gradient descent algorithm; entry point to start the minimization procedure; Parameters. fitnessFunction(templated) function which has to be provided. This function is minimized ; weights(templated) a reference to a container of weights. The result of the minimization procedure is retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Steepest.html:1293,learn,learningRate,1293,doc/master/classTMVA_1_1DNN_1_1Steepest.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Steepest.html,1,['learn'],['learningRate']
Usability,"nt and save a capture in a png file. ;  ; file  games.C;  This macro runs three ""games"" that each nicely illustrate the graphics capabilities of ROOT. ;  ; file  gtreeTableTest.C;  This TableTest class is a simple example of how to use a TGTreeTable. ;  ; file  guilabels.C;  This macro gives an example of how to create different kind of labels and the possibility to enable/disable them. ;  ; file  guitest.C;  Test program for ROOT native GUI classes Exactly like $ROOTSYS/test/guitest.cxx but using the new signal and slots communication mechanism. ;  ; file  guitest_playback.C;  This macro plays a recorded ROOT session showing how to perform various interactive GUI operations with the guitest.C macro While replaying the session, several temporary macros (guitest0xx.C) macros will be saved. ;  ; file  guiWithCLING.C;  A simple example of entering CLING commands and having the CLING output in a ROOT GUI application window. ;  ; file  iconAsXPMData.C;  A simple example of creating icon image from XPM data, included into the code. ;  ; file  listBox.C;  This macro gives an example of how to create a list box and how to set and use its multiple selection feature. ;  ; file  mditest.C;  GUI MDI features. ;  ; file  ntupleTableTest.C;  This TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface. ;  ; file  numberEntry.C;  This macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry. ;  ; file  simpleTableTest.C;  This TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface. ;  ; file  Slider3Demo.C;  Simple macro showing capabilities of triple slider. ;  ; file  splitbuttonTest.C;  A simple example that shows the usage of a TGSplitButton. ;  ; file  splitterHorizontal.C;  This macro gives an example of how to create a horizontal splitter. ;  ; file  splitterVertical.C;  This macro gives an example of how",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__gui.html:2295,simpl,simple,2295,doc/master/group__tutorial__gui.html,https://root.cern,https://root.cern/doc/master/group__tutorial__gui.html,1,['simpl'],['simple']
Usability,"nt ipos); check if the character at position i is part of a scientific notation. Bool_t IsHexadecimal(const TString& formula, int ipos); check if the character at position i is part of a scientific notation. TFormula(). ~TFormula(). TFormula(const char* name, const char* formula = """", bool addToGlobList = true); -; *-* Constructor; *-* When TF1 is constructed using C++ function, TF1 need space to keep parameters values.; -. TFormula(const char* name, const char* formula = """", bool addToGlobList = true). TFormula& operator=(const TFormula& rhs); -; *-* = Operator; -. Int_t Compile(const char* expression = """"); Compile the given expression with Cling; backward compatibility method to be used in combination with the empty constructor; if no expression is given , the current stored formula (retrieved with GetExpFormula()) or the title is used.; return 0 if the formula compilation is successfull. void Copy(TObject& f1) const. void Clear(Option_t* option = """"); clear the formula setting expression to empty and reset the variables and parameters containers. bool PrepareEvalMethod(); -; *-* Sets TMethodCall to function inside Cling environment; *-* TFormula uses it to execute function.; *-* After call, TFormula should be ready to evaluate formula.; -. void InputFormulaIntoCling(); -; *-* Inputs formula, transfered to C++ code into Cling; -. void FillDefaults(); -; *-* Fill structures with default variables, constants and function shortcuts; -; #ifdef ROOT_CPLUSPLUS11. void HandlePolN(TString& formula); -; *-* Handling polN; *-* If before 'pol' exist any name, this name will be treated as variable used in polynomial; *-* eg.; *-* varpol2(5) will be replaced with: [5] + [6]*var + [7]*var^2; *-* Empty name is treated like variable x.; -. void HandleParametrizedFunctions(TString& formula); -; *-* Handling parametrized functions; *-* Function can be normalized, and have different variable then x.; *-* Variables should be placed in brackets after function name.; *-* No brackets a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFormula.html:11172,clear,clear,11172,root/html604/TFormula.html,https://root.cern,https://root.cern/root/html604/TFormula.html,1,['clear'],['clear']
Usability,"nt number otherwise. TAxis * GetXaxis() const; Get x axis of the graph. TAxis * GetYaxis() const; Get y axis of the graph. void InitGaus(Double_t xmin = 0, Double_t xmax = 0); Compute Initial values of parameters for a gaussian. void InitExpo(Double_t xmin = 0, Double_t xmax = 0); Compute Initial values of parameters for an exponential. void InitPolynom(Double_t xmin = 0, Double_t xmax = 0); Compute Initial values of parameters for a polynom. Int_t InsertPoint(); Insert a new point at the mouse position. Double_t Integral(Int_t first = 0, Int_t last = -1) const; Integrate the TGraph data within a given (index) range; Note that this function computes the area of the polygon enclosed by the points of the TGraph.; The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; with the first one. It is clear that the order of the point is essential in defining the polygon.; Also note that the segments should not intersect. NB: if last=-1 (default) last is set to the last point.; if (first <0) the first point (0) is taken. Method:; There are many ways to calculate the surface of a polygon. It all depends on what kind of data; you have to deal with. The most evident solution would be to divide the polygon in triangles and; calculate the surface of them. But this can quickly become complicated as you will have to test; every segments of every triangles and check if they are intersecting with a current polygon's; segment or if it goes outside the polygon. Many calculations that would lead to many problems...; The solution (implemented by R.Brun); Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; segments don't intersect.; It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; vertex. Then it subtracts from it the result of the y coordina",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraph.html:35786,clear,clear,35786,root/html534/TGraph.html,https://root.cern,https://root.cern/root/html534/TGraph.html,3,['clear'],['clear']
Usability,"nt size sum.; Creating the Histogram; You then create the object with new TH1F(""hPosX"", ""Position in X"", 20, -5, 5);; Associate error bars with this histogram (see TH1F::Sumw2()); Filling the Histogram; The goal is to fill the histogram with the value of fPosX from the tree for all particles with a momentum > 40. You will need access to the particles' total momentum and their X position. Each TTree entry has several particles; it's thus easiest to use one TTreeReaderArray each for these Double_t values, for instance TTreeReaderArray particlesMomentum(myReader, ""fParticles.fMomentum"");. The TTreeReaderArray works just like the TTreeReaderValue we have used before, but gives you access to the number of particles using particlesMomentum.GetSize() and the n-th particle using the particlesMomentum[n] operator.; The analysis happens in loops. The outer loop is iterating through the TTree entries, using the TTreeReader::Next() loop - just as before. For each TTree entry, loop over all particles of the TTree entry with a simple for loop. For each particle, check that its momentum is > 40; if it is, fill the histogram (see TH1F::Fill()) with the fPosX value of that particle.; This step involves writing some code (similar to the code you have for the event size). If you get lost (SPOILER ALERT!): the solution is at the end of this page.; Fitting and Drawing the Histogram; Once the histogram is filled, fit it with a pol2 using TH1::Fit(""pol2""). Here ""pol2"" is ROOT's short name for ""polynomial of 2nd degree"", i.e. [0] + [1]x + [2]x*x, aka ""parabola"".; ""Fitting"" means using a function (in this case the pol2) with one or more free parameters ([0]..[2] in this case) and looking for those values of the parameters that result in the function passing as closely as possible through the data points, where ""close"" takes the points' uncertainties into account. You should first fit and then draw, to see the fit together with the histogram.; At the end, you should get something like this:. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/histogramming.html:3372,simpl,simple,3372,d/histogramming.html,https://root.cern,https://root.cern/d/histogramming.html,1,['simpl'],['simple']
Usability,"nt to the current cursor position in stack. ;  ; UInt_t GetLimit () const;  Returns a maximum number of commands which could be located in stack. ;  ; TClass * IsA () const override;  ; Bool_t IsLogging () const;  Returns kTRUE if logging is ON. ;  ; void ls (Option_t *option="""") const override;  Lists all commands in stack. ;  ; void Redo (Option_t *option="""") override;  Performs redo action. Move cursor position forward in history stack. ;  ; virtual void SetLimit (UInt_t limit);  Returns a maximum number of commands which could be located in stack. ;  ; virtual void SetLogging (Bool_t on=kTRUE);  Start logging. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Undo (Option_t *option="""") override;  Performs undo action. Move cursor position backward in history stack. ;  ;  Public Member Functions inherited from TQCommand;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo arguments. ;  ; Int_t GetNUargs () const;  Returns a number of undo arguments. ;  ; void * GetObject () const;  Returns an object for which",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:2064,undo,undo,2064,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"nt to this object. Note that this method can be called; 2942 /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; 2943 /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; 2944 /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; 2945 /// or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; 2946 /// * `void InitTask(TTreeReader *, unsigned int slot)`: each working thread shall call this method during the event; 2947 /// loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader; 2948 /// that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations; 2949 /// it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; 2950 /// * `void Exec(unsigned int slot, ColumnTypes...columnValues)`: each working thread shall call this method; 2951 /// during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value:; 2952 /// this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of; 2953 /// the requested columns for the particular entry being processed.; 2954 /// * `void Finalize()`: this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; 2955 /// * `std::string GetActionName()`: it returns a string identifier for this type of action that RDataFrame will use in; 2956 /// diagnostics, SaveGraph(), etc.; 2957 ///; 2958 /// ### Optional methods; 2959 ///; 2960 /// If these methods are implemented they enable extra functionality as per the description below.; 2961 ///; 2962 /// * `Result_t &PartialUpdate(unsigned int slot)`: if present, it must r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:166875,simpl,simple,166875,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['simpl'],['simple']
Usability,"nt using the algorithm corresponding to the specified code. ;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ;  ; RooAbsReal const & getMedian () const;  Get the median parameter. ;  ; RooAbsReal const & getShapeK () const;  Get the shape parameter. ;  ; RooAbsReal const & getX () const;  Get the x variable. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ; bool useStandardParametrization () const;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLognormal.html:2744,simpl,simple,2744,doc/master/classRooLognormal.html,https://root.cern,https://root.cern/doc/master/classRooLognormal.html,1,['simpl'],['simple']
Usability,"nt variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCommittee(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption, TDirectory* theTargetDir = 0); constructor. MethodCommittee(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = 0); constructor for calculating Committee-MVA using previously generatad decision trees; the result of the previous training (the decision trees) are read in via the; weightfile. Make sure the ""theVariables"" correspond to the ones used in; creating the ""weight""-file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; NMembers <string> number of members in the committee; UseMemberDecision <bool> use signal information from event (otherwise assume signal); UseWeightedMembers <bool> use weighted trees or simple average in classification from the forest. BoostType <string> boosting type; available values are: AdaBoost <default>; Bagging. void ProcessOptions(); process user options. void Init( void ); common initialisation with defaults for the Committee-Method. ~MethodCommittee( void ); destructor. void WriteStateToFile() const; Function to write options and weights to file. void Train( void ); training. Double_t Boost(TMVA::MethodBase* , UInt_t imember); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in the constructor. The return value is the boosting weight. Double_t AdaBoost(TMVA::MethodBase* ); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCommittee.html:18292,simpl,simple,18292,root/html528/TMVA__MethodCommittee.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCommittee.html,3,['simpl'],['simple']
Usability,"nt(bin); 3565 ; 3566Bool_t TEfficiency::SetPassedEvents(Int_t bin,Int_t events); 3567{; 3568 if(events <= fTotalHistogram->GetBinContent(bin)) {; 3569 fPassedHistogram->SetBinContent(bin,events);; 3570 return true;; 3571 }; 3572 else {; 3573 Error(""SetPassedEvents(Int_t,Int_t)"",""total number of events (%.1lf) in bin %i is less than given number of passed events %i"",fTotalHistogram->GetBinContent(bin),bin,events);; 3574 return false;; 3575 }; 3576}; 3577 ; 3578////////////////////////////////////////////////////////////////////////////////; 3579/// Sets the histogram containing the passed events; 3580///; 3581/// The given histogram is cloned and stored internally as histogram containing; 3582/// the passed events. The given histogram has to be consistent with the current; 3583/// fTotalHistogram (see CheckConsistency(const TH1&,const TH1&)).; 3584/// The method returns whether the fPassedHistogram has been replaced (true) or; 3585/// not (false).; 3586///; 3587/// Note: The list of associated functions fFunctions is cleared.; 3588///; 3589/// Option:; 3590/// - ""f"": force the replacement without checking the consistency; 3591/// This can lead to inconsistent histograms and useless results; 3592/// or unexpected behaviour. But sometimes it might be the only; 3593/// way to change the histograms. If you use this option, you; 3594/// should ensure that the fTotalHistogram is replaced by a; 3595/// consistent one (with respect to rPassed) as well.; 3596 ; 3597Bool_t TEfficiency::SetPassedHistogram(const TH1& rPassed,Option_t* opt); 3598{; 3599 TString option = opt;; 3600 option.ToLower();; 3601 ; 3602 Bool_t bReplace = option.Contains(""f"");; 3603 ; 3604 if(!bReplace); 3605 bReplace = CheckConsistency(rPassed,*fTotalHistogram);; 3606 ; 3607 if(bReplace) {; 3608 delete fPassedHistogram;; 3609 // do not add cloned histogram to gDirectory; 3610 {; 3611 TDirectory::TContext ctx(nullptr);; 3612 fPassedHistogram = (TH1*)(rPassed.Clone());; 3613 fPassedHistogram->SetNormFactor(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8cxx_source.html:142206,clear,cleared,142206,doc/master/TEfficiency_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html,1,['clear'],['cleared']
Usability,"nt. ;  ; Float_t fTextAngle;  Text angle. ;  ; Color_t fTextColor;  Text color. ;  ; Font_t fTextFont;  Text font. ;  ; Float_t fTextSize;  Text size. ;  ;  Protected Attributes inherited from TAttMarker; Color_t fMarkerColor;  Marker color. ;  ; Size_t fMarkerSize;  Marker size. ;  ; Style_t fMarkerStyle;  Marker style. ;  . Private Member Functions; void ClearPixmap (Drawable *pix);  Clear the pixmap pix. ;  ; void CloseWindow1 ();  Delete current window. ;  ; void CollectImageColors (ULong_t pixel, ULong_t *&orgcolors, Int_t &ncolors, Int_t &maxcolors);  Collect in orgcolors all different original image colors. ;  ; void CopyWindowtoPixmap (Drawable *pix, Int_t xpos, Int_t ypos);  Copy area of current window in the pixmap pix. ;  ; void FindBestVisual ();  Find best visual, i.e. ;  ; Int_t FindColor (ULong_t pixel, ULong_t *orgcolors, Int_t ncolors);  Returns index in orgcolors (and fNewColors) for pixel. ;  ; void FindUsableVisual (RXVisualInfo *vlist, Int_t nitems);  Check if visual is usable, if so set fVisual, fDepth, fColormap, fBlackPixel and fWhitePixel. ;  ; void ImgPickPalette (RXImage *image, Int_t &ncol, Int_t *&R, Int_t *&G, Int_t *&B);  Returns in R G B the ncol colors of the palette used by the image. ;  ; void MakeOpaqueColors (Int_t percent, ULong_t *orgcolors, Int_t ncolors);  Get RGB values for orgcolors, add percent neutral to the RGB and allocate fNewColors. ;  ; void MapColorStruct (ColorStruct_t *color, RXColor &xcolor);  Map a ColorStruct_t to a XColor structure. ;  ; void MapCursor (ECursor cursor, Int_t &xcursor);  ; void MapEvent (Event_t &ev, void *xev, Bool_t tox=kTRUE);  Map Event_t structure to XEvent structure. ;  ; void MapEventMask (UInt_t &emask, UInt_t &xemask, Bool_t tox=kTRUE);  Map event mask to or from X. ;  ; void MapGCValues (GCValues_t &gval, ULong_t &xmask, RXGCValues &xgval, Bool_t tox=kTRUE);  Map a GCValues_t to a XCGValues structure if tox is true. ;  ; void MapKeySym (UInt_t &keysym, UInt_t &xkeysym, Bool_t tox=kTRUE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:49548,usab,usable,49548,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['usab'],['usable']
Usability,"nt. protected . current cursor position ; Definition at line 43 of file TGTextEdit.h. ◆ fCursor0GC. GContext_t TGTextEdit::fCursor0GC. protected . graphics context for erasing cursor ; Definition at line 37 of file TGTextEdit.h. ◆ fCursor1GC. GContext_t TGTextEdit::fCursor1GC. protected . graphics context for drawing cursor ; Definition at line 38 of file TGTextEdit.h. ◆ fCursorState. Int_t TGTextEdit::fCursorState. protected . cursor state (1=drawn, 2=erased) ; Definition at line 39 of file TGTextEdit.h. ◆ fEnableCursorWithoutFocus. Bool_t TGTextEdit::fEnableCursorWithoutFocus. protected . enable cursor visibility when focus went out from text editor window (default is kTRUE) ; Definition at line 47 of file TGTextEdit.h. ◆ fEnableMenu. Bool_t TGTextEdit::fEnableMenu. protected . enable context menu with editor actions ; Definition at line 45 of file TGTextEdit.h. ◆ fgCursor0GC. TGGC * TGTextEdit::fgCursor0GC = nullptr. staticprotected . Definition at line 50 of file TGTextEdit.h. ◆ fgCursor1GC. TGGC * TGTextEdit::fgCursor1GC = nullptr. staticprotected . Definition at line 51 of file TGTextEdit.h. ◆ fHistory. TGTextEditHist* TGTextEdit::fHistory. protected . undo manager ; Definition at line 46 of file TGTextEdit.h. ◆ fInsertMode. EInsertMode TGTextEdit::fInsertMode. protected . OPTION={GetMethod=""GetInsertMode"";SetMethod=""SetInsertMode"";Items=(kInsert=""&Insert"",kReplace=""&Replace"")} ; Definition at line 44 of file TGTextEdit.h. ◆ fMenu. TGPopupMenu* TGTextEdit::fMenu. protected . popup menu with editor actions ; Definition at line 41 of file TGTextEdit.h. ◆ fSearch. TGSearchType* TGTextEdit::fSearch. protected . structure used by search dialog ; Definition at line 42 of file TGTextEdit.h. Libraries for TGTextEdit:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGTextEdit.h; gui/gui/src/TGTextEdit.cxx. TGTextEdit. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:37 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEdit.html:61512,undo,undo,61512,doc/master/classTGTextEdit.html,https://root.cern,https://root.cern/doc/master/classTGTextEdit.html,1,['undo'],['undo']
Usability,"nt;  variable that holds the option of how to treat negative event weights in training ;  ; UInt_t fNNodesMax;  max # of nodes ;  ; Double_t fNodePurityLimit;  purity limit for sig/bkg nodes ;  ; Bool_t fNoNegWeightsInTraining;  ignore negative event weights in the training ;  ; Int_t fNTrees;  number of decision trees requested ;  ; Bool_t fPairNegWeightsGlobal;  pair ev. with neg. and pos. weights in training sample and ""annihilate"" them ;  ; DecisionTree::EPruneMethod fPruneMethod;  method used for pruning ;  ; TString fPruneMethodS;  prune method option String ;  ; Double_t fPruneStrength;  a parameter to set the ""amount"" of pruning..needs to be adjusted ;  ; Bool_t fRandomisedTrees;  choose a random subset of possible cut variables at each node during training ;  ; LossFunctionBDT * fRegressionLossFunctionBDTG;  ; TString fRegressionLossFunctionBDTGS;  the option string determining the loss function for BDT regression ;  ; std::map< const TMVA::Event *, std::vector< double > > fResiduals;  individual event residuals for gradient boost ;  ; SeparationBase * fSepType;  the separation used in node splitting ;  ; TString fSepTypeS;  the separation (option string) used in node splitting ;  ; Double_t fShrinkage;  learning rate for gradient boost; ;  ; Double_t fSigToBkgFraction;  Signal to Background fraction assumed during training. ;  ; Bool_t fSkipNormalization;  true for skipping normalization at initialization of trees ;  ; std::vector< const TMVA::Event * > fSubSample;  subsample for bagged grad boost ;  ; std::vector< const TMVA::Event * > * fTrainSample;  pointer to sample actually used in training (fEventSample or fSubSample) for example ;  ; Bool_t fTrainWithNegWeights;  yes there are negative event weights and we don't ignore them ;  ; Bool_t fUseExclusiveVars;  individual variables already used in fisher criterium are not anymore analysed individually for node splitting ;  ; Bool_t fUseFisherCuts;  use multivariate splits using the Fisher criterium ;  ; U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:37837,learn,learning,37837,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['learn'],['learning']
Usability,"ntLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finaly, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exactly matching:. mlpfit hybrid learning method is not implemented; output neurons can be normalized, this is not the case for mlpfit; the neural net is exported in C++, FORTRAN or PYTHON; the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron. Function Members (Methods); public:. TMultiLayerPerceptr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:8054,simpl,simple,8054,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,"ntLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finaly, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exactly matching:. mlpfit hybrid learning method is not implemented; output neurons can be normalized, this is not the case for mlpfit; the neural net is exported in C++, FORTRAN or PYTHON; the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron. Function Members (Methods); public:. virtual~TMultiLayer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMultiLayerPerceptron.html:8054,simpl,simple,8054,root/html602/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html602/TMultiLayerPerceptron.html,2,['simpl'],['simple']
Usability,"nt_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooThresholdCategory.html:2241,clear,clearValueAndShapeDirty,2241,root/html534/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"nt_t fNEntriesSinceSorting; ///<! Number of entries processed since the last re-sorting of branches; 144 std::vector<std::pair<Long64_t,TBranch*>> fSortedBranches; ///<! Branches to be processed in parallel when IMT is on, sorted by average task time; 145 std::vector<TBranch*> fSeqBranches; ///<! Branches to be processed sequentially when IMT is on; 146 Float_t fTargetMemoryRatio{1.1f}; ///<! Ratio for memory usage in uncompressed buffers versus actual occupancy. 1.0; 147 /// indicates basket should be resized to exact memory usage, but causes significant; 148/// memory churn.; 149#ifdef R__TRACK_BASKET_ALLOC_TIME; 150 mutable std::atomic<ULong64_t> fAllocationTime{0}; ///<! Time spent reallocating basket memory buffers, in microseconds.; 151#endif; 152 mutable std::atomic<UInt_t> fAllocationCount{0}; ///<! Number of reallocations basket memory buffers.; 153 ; 154 static Int_t fgBranchStyle; ///< Old/New branch style; 155 static Long64_t fgMaxTreeSize; ///< Maximum size of a file containing a Tree; 156 ; 157private:; 158 // For simplicity, although fIMTFlush is always disabled in non-IMT builds, we don't #ifdef it out.; 159 mutable bool fIMTFlush{false}; ///<! True if we are doing a multithreaded flush.; 160 mutable std::atomic<Long64_t> fIMTTotBytes; ///<! Total bytes for the IMT flush baskets; 161 mutable std::atomic<Long64_t> fIMTZipBytes; ///<! Zip bytes for the IMT flush baskets.; 162 ; 163 void InitializeBranchLists(bool checkLeafCount);; 164 void SortBranchesByTime();; 165 Int_t FlushBasketsImpl() const;; 166 void MarkEventCluster();; 167 Long64_t GetMedianClusterSize();; 168 ; 169protected:; 170 virtual void KeepCircular();; 171 virtual TBranch *BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel);; 172 virtual TBranch *BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel);; 173 virtual TBranch *BranchImpRef(const char* branchname, const char* cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:7876,simpl,simplicity,7876,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['simpl'],['simplicity']
Usability,"nt_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. » Last changed: Mon Dec 7 13:48:35 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooObjCacheManager.html:5287,clear,clearOnRedirect,5287,root/html526/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html526/RooObjCacheManager.html,1,['clear'],['clearOnRedirect']
Usability,nt_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:19051,learn,learning,19051,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['learn'],['learning']
Usability,"nt_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTubeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTubeEditor.html:21244,undo,undoing,21244,root/html528/TGeoTubeEditor.html,https://root.cern,https://root.cern/root/html528/TGeoTubeEditor.html,1,['undo'],['undoing']
Usability,"nt_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTubeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTubeEditor.html:21344,undo,undoing,21344,root/html530/TGeoTubeEditor.html,https://root.cern,https://root.cern/root/html530/TGeoTubeEditor.html,1,['undo'],['undoing']
Usability,"nt_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTubeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTubeEditor.html:21344,undo,undoing,21344,root/html532/TGeoTubeEditor.html,https://root.cern,https://root.cern/root/html532/TGeoTubeEditor.html,1,['undo'],['undoing']
Usability,"nt_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube segment editor. ~TGeoTubeSegEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTubeSegEditor.html:22808,undo,undoing,22808,root/html604/TGeoTubeSegEditor.html,https://root.cern,https://root.cern/root/html604/TGeoTubeSegEditor.html,1,['undo'],['undoing']
Usability,"nt_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube segment editor. ~TGeoTubeSegEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTubeSegEditor.html:22808,undo,undoing,22808,root/html602/TGeoTubeSegEditor.html,https://root.cern,https://root.cern/root/html602/TGeoTubeSegEditor.html,1,['undo'],['undoing']
Usability,"nt_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetRange(Float_t min, Float_t max); Set min and max of progress bar. void SetPosition(Float_t pos); Set progress position between [min,max]. void Increment(Float_t inc); Increment progress position. void Reset(); Reset progress bar (i.e. set pos to 0). void SetFillType(TGProgressBar::EFillType type); Set fill type. void SetBarType(TGProgressBar::EBarType type); Set bar type. void SetBarColor(ULong_t color); Set progress bar color. void SetBarColor(const char* color = ""blue""); Set progress bar color. void Format(const char* format = ""%.2f""); Set format for displaying a value. FontStruct_t GetDefaultFontStruct(); Return default font structure in use. const TGGC & GetDefaultGC(); Return default graphics context in use. void SetForegroundColor(Pixel_t pixel); Change text color drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save progress bar parameters as a C++ statement(s) on output stream out. Bool_t fDrawBar; // if true draw only bar in DoRedraw(). virtual ~TGProgressBar(); { }. Float_t GetMin() const; { return fMin; }. Float_t GetMax() const; { return fMax; }. Float_t GetPosition() const; { return fPos; }. EFillType GetFillType() const; { return fFillType; }. EBarType GetBarType() const; { return fBarType; }. Bool_t GetShowPos() const; { return fShowPos; }. TString GetFormat() const; { return fFormat; }. const char* GetValueFormat() const; { return fFormat.Data(); }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGProgressBar.html:19478,progress bar,progress bar,19478,root/html528/TGProgressBar.html,https://root.cern,https://root.cern/root/html528/TGProgressBar.html,4,['progress bar'],['progress bar']
Usability,"ntainer_type::iterator TMVA::DNN::Net::iterator_type. Definition at line 1066 of file NeuralNet.h. Constructor & Destructor Documentation. ◆ Net() [1/2]. TMVA::DNN::Net::Net ; (; ). inline . c'tor ; Definition at line 1074 of file NeuralNet.h. ◆ Net() [2/2]. TMVA::DNN::Net::Net ; (; const Net & ; other). inline . d'tor ; Definition at line 1085 of file NeuralNet.h. Member Function Documentation. ◆ addLayer() [1/2]. void TMVA::DNN::Net::addLayer ; (; Layer && ; layer). inline . Definition at line 1095 of file NeuralNet.h. ◆ addLayer() [2/2]. void TMVA::DNN::Net::addLayer ; (; Layer & ; layer). inline . add a layer (layout) ; Definition at line 1094 of file NeuralNet.h. ◆ backPropagate(). template<typename Settings > . void TMVA::DNN::Net::backPropagate ; (; std::vector< std::vector< LayerData > > & ; layerPatternData, . const Settings & ; settings, . size_t ; trainFromLayer, . size_t ; totalNumWeights . ); const. Definition at line 1355 of file NeuralNet.icc. ◆ clear(). void TMVA::DNN::Net::clear ; (; ). inline . Definition at line 1251 of file NeuralNet.h. ◆ compute(). template<typename Weights > . std::vector< double > TMVA::DNN::Net::compute ; (; const std::vector< double > & ; input, . const Weights & ; weights . ); const. compute the net with the given input and the given weights ; compute the neural net; Parameters. inputthe input data ; weightsthe weight data . Definition at line 1037 of file NeuralNet.icc. ◆ computeError(). template<typename ItWeight > . std::tuple< double, double > TMVA::DNN::Net::computeError ; (; const Settings & ; settings, . std::vector< LayerData > & ; lastLayerData, . Batch & ; batch, . ItWeight ; itWeightBegin, . ItWeight ; itWeightEnd . ); const. Definition at line 1321 of file NeuralNet.icc. ◆ dE(). void TMVA::DNN::Net::dE ; (; ). ◆ dropOutWeightFactor(). template<typename WeightsType , typename DropProbabilities > . void TMVA::DNN::Net::dropOutWeightFactor ; (; WeightsType & ; weights, . const DropProbabilities & ; drops, . bool ; i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html:8277,clear,clear,8277,doc/master/classTMVA_1_1DNN_1_1Net.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html,1,['clear'],['clear']
Usability,"ntainment. This is accomplished by positioning some volumes inside others. Any volume is an un-positioned object in the sense that it defines only a local frame (matching the one of its shape). In order to fully define the mother-daughter relationship between two volumes one has to specify how the daughter will be positioned inside. This is accomplished by defining a local geometrical transformation of the daughter with respect to the mother coordinate system. These transformations will be subsequently used in the example.; Q: “I see the lines defining the top level volume as in the previous example, but what about the other volumes named REPLICA and ROOT?”; A: You will also notice that several other volumes are created by using lines like:; TGeoVolume *someVolume = gGeoManager->MakeXXX(""someName"",; ptrMedium, /* parameters coresponding to XXX ...*/); In the method above XXX represent some shape name (Box, Tube, etc.). This is just a simple way of creating a volume having a given shape in one-step (see also section: “Creating and Positioning Volumes”). As for REPLICA and ROOT volumes, they are just some virtual volumes used for grouping and positioning together other real volumes. See “Positioned Volumes (Nodes)”. The same structure represented by (a real or) a virtual volume can be replicated several times in the geometry.; Q: “Fine, so probably the real volumes are the ones composing the letters R, O and T. Why one have to define so many volumes to make an R?”; A: Well, in real life some objects have much more complex shapes that an R. The modeller cannot just know all of them; the idea is to make a complex object by using elementary building blocks that have known shapes (called primitive shapes). Gluing these together in the appropriate way is the user responsibility.; Q: “I am getting the global picture but not making much out of it… There are also a lot of calls to TGeoVolume::AddNode() that I do not understand.”; A: A volume is positioned inside another one b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:880886,simpl,simple,880886,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"ntains 'built', reset this StreamerInfo as if Build or BuildOld; 2614/// was never called on it (useful to force their re-running).; 2615 ; 2616void TStreamerInfo::Clear(Option_t *option); 2617{; 2618 TString opt = option;; 2619 opt.ToLower();; 2620 ; 2621 if (opt.Contains(""build"")) {; 2622 R__LOCKGUARD(gInterpreterMutex);; 2623 ; 2624 delete [] fComp; fComp = 0;; 2625 delete [] fCompFull; fCompFull= 0;; 2626 delete [] fCompOpt; fCompOpt = 0;; 2627 ; 2628 fNdata = 0;; 2629 fNfulldata = 0;; 2630 fNslots= 0;; 2631 fSize = 0;; 2632 ; 2633 ResetIsCompiled();; 2634 ResetBit(kBuildOldUsed);; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd ).c_str(),kTRUE);; 2675 }; 2676 void SetComment",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105607,clear,clear,105607,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['clear'],['clear']
Usability,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * If the objects are added using the placement new then the Clear must; deallocate the memory.; * If the objects are added using TClonesArray::ConstructedAt then the; heap-based memory can stay allocated and reused as the constructor is; not called for already constructed/added object.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClonesArray.html:3946,clear,clearing,3946,root/html604/TClonesArray.html,https://root.cern,https://root.cern/root/html604/TClonesArray.html,1,['clear'],['clearing']
Usability,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:3946,clear,clearing,3946,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,2,['clear'],['clearing']
Usability,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClonesArray.html:3946,clear,clearing,3946,root/html602/TClonesArray.html,https://root.cern,https://root.cern/root/html602/TClonesArray.html,1,['clear'],['clearing']
Usability,"ntation. ◆ Class(). static TClass * TGFont::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGFont::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGFont::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 209 of file TGFont.h. ◆ ComputeTextLayout(). TGTextLayout * TGFont::ComputeTextLayout ; (; const char * ; string, . Int_t ; numChars, . Int_t ; wrapLength, . Int_t ; justify, . Int_t ; flags, . UInt_t * ; width, . UInt_t * ; height . ); const. Computes the amount of screen space needed to display a multi-line, justified string of text. ; Records all the measurements that were done to determine to size and positioning of the individual lines of text; this information can be used by the TGTextLayout::DrawText() procedure to display the text quickly (without remeasuring it).; This procedure is useful for simple widgets that want to display single-font, multi-line text and want TGFont to handle the details.; The return value is a TGTextLayout token that holds the measurement information for the given string. The token is only valid for the given string. If the string is freed, the token is no longer valid and must also be deleted.; The dimensions of the screen area needed to display the text are stored in *width and *height.; string – String whose dimensions are to be computed. numChars – Number of characters to consider from string, or < 0 for strlen(). wrapLength – Longest permissible line length, in pixels. <= 0 means no automatic wrapping: just let lines get as long as needed. justify – How to justify lines. flags – Flag bits OR-ed together. kTextIgnoreTabs means that tab characters should not be expanded. kTextIgnoreNewlines means that newline characters should not cause a line break. width – Filled with width of string. height – Filled with height of string. ; Definition at line 661 of file TGFont.cxx. ◆ DeclFileNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFont.html:16174,simpl,simple,16174,doc/master/classTGFont.html,https://root.cern,https://root.cern/doc/master/classTGFont.html,1,['simpl'],['simple']
Usability,"ntents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 502 of file RooProduct.cxx. ◆ realComponents(). const RooArgList & RooProduct::realComponents ; (; ); const. inline . Definition at line 50 of file RooProduct.h. ◆ setCacheAndTrackHints(). void RooProduct::setCacheAndTrackHints ; (; RooArgSet & ; trackNodes). overridevirtual . Label OK'ed components of a RooProduct with cache-and-track. ; Reimplemented from RooAbsArg.; Definition at line 479 of file RooProduct.cxx. ◆ Streamer(). void RooProduct::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooProduct::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 93 of file RooProduct.h. ◆ translate(). void RooProduct::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 493 of file RooProduct.cxx. Member Data Documentation. ◆ _cacheMgr. RooObjCacheManager RooProduct::_cacheMgr. mutableprotected . Definition at line 82 of file RooProduct.h. ◆ _compCSet. RooListProxy RooProduct::_compCSet. protected . Definition at line 72 of file RooProduct.h. ◆ _compRSet. RooListProxy RooProduct::_compRSet. protected . Definition at line 71 of file RooProduct.h. Libraries for RooProduct:. [legend]; The docume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProduct.html:68857,simpl,simple,68857,doc/master/classRooProduct.html,https://root.cern,https://root.cern/doc/master/classRooProduct.html,1,['simpl'],['simple']
Usability,"nternal::VecOps::RVecInlineStorageSize< T >::value >inline; at(size_type pos) constROOT::VecOps::RVecN< T, Internal::VecOps::RVecInlineStorageSize< T >::value >inline; at(size_type pos, value_type fallback)ROOT::VecOps::RVecN< T, Internal::VecOps::RVecInlineStorageSize< T >::value >inline; at(size_type pos, value_type fallback) constROOT::VecOps::RVecN< T, Internal::VecOps::RVecInlineStorageSize< T >::value >inline; back()ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; back() constROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; Base typedefROOT::Internal::VecOps::SmallVectorTemplateCommon< T >private; begin() noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; begin() const noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; capacity() const noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; capacity_in_bytes() constROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; cbegin() const noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; cend() const noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; clear()ROOT::Detail::VecOps::RVecImpl< T >inline; const_iterator typedefROOT::Detail::VecOps::RVecImpl< T >; const_pointer typedefROOT::Internal::VecOps::SmallVectorTemplateCommon< T >; const_reference typedefROOT::VecOps::RVec< T >; const_reverse_iterator typedefROOT::Internal::VecOps::SmallVectorTemplateCommon< T >; crbegin() const noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; crend() const noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; data() noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; data() const noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; destroy_range(T *S, T *E)ROOT::Internal::VecOps::SmallVectorTemplateBase< T, bool >inlineprotectedstatic; difference_type typedefROOT::Internal::VecOps::SmallVectorTemplateCommon< T >; emplace_back(ArgTypes &&.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec-members.html:1913,clear,clear,1913,doc/master/classROOT_1_1VecOps_1_1RVec-members.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec-members.html,1,['clear'],['clear']
Usability,"ntext &ctx) const override;  This function defines the analytical integral translation for the class. ;  ; TObject * clone (const char *newname) const override;  ; void generateEvent (Int_t code) override;  algorithm adapted from code example in: Marsaglia, G. ;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual RooAbsGenContext * binnedGenContext (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGamma.html:2889,simpl,simple,2889,doc/master/classRooGamma.html,https://root.cern,https://root.cern/doc/master/classRooGamma.html,1,['simpl'],['simple']
Usability,"ntribution from input measurement uncertainties ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the uncertainties or covariance of the input data. In many cases, these are the ""statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1207 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundScale(). void TUnfoldSys::GetEmatrixSysBackgroundScale ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background normalisation uncertainty ; Parameters. [in,out]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram prior to adding the covariance matrix contribution. this method returns the uncertainties on the unfolding result arising from the background source source and its normalisation uncertainty. See method SubtractBackground() how to set the normalisation uncertainty ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1144 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundUncorr(). void TUnfoldSys::GetEmatrixSysBackgroundUncorr ; (; TH2 * ; ematrix, . const char * ; source, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background uncorrelated uncertainty ; Parameters. [in]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:38694,clear,clearEmat,38694,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,2,['clear'],"['clear', 'clearEmat']"
Usability,"ntry, Int_t btn, Int_t x, Int_t y);  Emit Clicked() signal. ;  ; virtual void Clicked (TGListTreeItem *entry, Int_t btn, UInt_t mask, Int_t x, Int_t y);  Emit Clicked() signal. ;  ; void CloseItem (TGListTreeItem *item);  Close item in list tree (i.e. hide child items). ;  ; virtual void DataDropped (TGListTreeItem *item, TDNDData *data);  Emit DataDropped() signal. ;  ; Int_t DeleteChildren (TGListTreeItem *item);  Delete children of item from list. ;  ; Int_t DeleteItem (TGListTreeItem *item);  Delete item from list tree. ;  ; Int_t DeleteSelected ();  ; void DisableOpen (Bool_t disable=kTRUE);  ; virtual void DoubleClicked (TGListTreeItem *entry, Int_t btn);  Emit DoubleClicked() signal. ;  ; virtual void DoubleClicked (TGListTreeItem *entry, Int_t btn, Int_t x, Int_t y);  Emit DoubleClicked() signal. ;  ; virtual void DrawActive (Handle_t id, TGListTreeItem *item);  Draw active item with its active color. ;  ; virtual void DrawOutline (Handle_t id, TGListTreeItem *item, Pixel_t col=0xbbbbbb, Bool_t clear=kFALSE);  Draw a outline of color 'col' around an item. ;  ; void DrawRegion (Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Redraw list tree. ;  ; void End (Bool_t select=kFALSE) override;  Move content to the bottom. ;  ; TGListTreeItem * FindChildByData (TGListTreeItem *item, void *userData);  Find child of item by userData. ;  ; TGListTreeItem * FindChildByName (TGListTreeItem *item, const char *name);  Find child of item by name. ;  ; TGListTreeItem * FindItemByObj (TGListTreeItem *item, void *ptr);  Find item with fUserData == ptr. ;  ; TGListTreeItem * FindItemByPathname (const char *path);  Find item by pathname. ;  ; TGListTreeItem * FindSiblingByData (TGListTreeItem *item, void *userData);  Find sibling of item by userData. ;  ; TGListTreeItem * FindSiblingByName (TGListTreeItem *item, const char *name);  Find sibling of item by name. ;  ; Int_t FontAscent ();  Returns ascent of currently used font. ;  ; Int_t FontHeight ();  Returns height of current",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGListTree.html:4955,clear,clear,4955,doc/master/classTGListTree.html,https://root.cern,https://root.cern/doc/master/classTGListTree.html,1,['clear'],['clear']
Usability,"nts of the TGraph, do not need to form a closed polygon, since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point with the first one. It is clear that the order of the point is essential in defining the polygon. Also note that the segments should not intersect.; NB:; if last=-1 (default) last is set to the last point.; if (first <0) the first point (0) is taken. Method:; There are many ways to calculate the surface of a polygon. It all depends on what kind of data you have to deal with. The most evident solution would be to divide the polygon in triangles and calculate the surface of them. But this can quickly become complicated as you will have to test every segments of every triangles and check if they are intersecting with a current polygon's segment or if it goes outside the polygon. Many calculations that would lead to many problems... The solution (implemented by R.Brun); Fortunately for us, there is a simple way to solve this problem, as long as the polygon's segments don't intersect. It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area. Sources. http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon . Definition at line 1808 of file TGraph.cxx. ◆ IsA(). TClass * TGraph::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TGraphPolar, TGraphQQ, TGraphAsymmErrors, TGraphBentErrors, TGraphErrors, and TGraphMultiErrors.; Definition at line 203 of file TGraph.h. ◆ IsEditable(). virtual Bool_t TGraph::IsEditable ; (; ); const. inlinevirtual . Definition at line 166 of file TGraph.h. ◆ IsHighlight().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:62132,simpl,simple,62132,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['simpl'],['simple']
Usability,"nts the info about the layer. ;  ; void ReadMatrixXML (void *node, const char *name, Matrix_t &matrix);  ; virtual void ReadWeightsFromXML (void *parent)=0;  Read the information and the weights about the layer from XML node. ;  ; virtual void ResetTraining ();  Reset some training flags after a loop on all batches Some layer (e.g. ;  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetDropoutProbability (Scalar_t);  Set Dropout probability. ;  ; virtual void SetExtraLayerParameters (const std::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Protected Attributes; Tensor_t fActivationGradients;  Gradients w.r.t. the activations of this layer. ;  ; size_t fBatchSize;  Batch size used for trainin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:5303,learn,learningRate,5303,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"nts-kModeGroupHeight, modes of combination of shading according to light and to channels counts-kModeGroupLightHeight); Double_tfMxx; Double_tfMxy; Double_tfMyx; Double_tfMyy; TStringTNamed::fNameobject identifier; TColor*fNewColor!; Int_tfNewColorIndex; Int_tfNodesxnumber of nodes in x dimension of grid; Int_tfNodesynumber of nodes in y dimension of grid; Double_tfNuSli; Int_tfPenColorcolor of spectrum; Int_tfPenDashstyle of pen; Int_tfPenWidthwidth of line; Double_tfRainbow1Stepdetermines the first component step for neighbouring color levels, applies only for rainbowed display modes, it does not apply for simple display modes algorithm group; Double_tfRainbow2Stepdetermines the second component step for neighbouring color levels, applies only for rainbowed display modes, it does not apply for simple display modes algorithm group; Double_tfRainbow3Stepdetermines the third component step for neighbouring color levels, applies only for rainbowed display modes, it does not apply for simple display modes algorithm group; Int_tfShadingdetermines whether the picture will shaded, smoothed (no shading, shading), for rainbowed display modes only; Int_tfShadowdetermines whether shadow will be drawn (no shadow, shadow), for rainbowed display modes with shading according to light; TStringTNamed::fTitleobject title; Double_tfTxx; Double_tfTxy; Double_tfTyx; Double_tfTyy; Double_tfTyz; Int_tfViewAnglerotation angle of the view, it can be 0, 90, 180, 270 degrees; Double_tfVx; Double_tfVy; Int_tfXe; Int_tfXlightx position of fictive light source, applies only for rainbowed display modes with shading according to light; Int_tfXmaxx-end channel of spectrum; Int_tfXminx-starting channel of spectrum; Int_tfXs; Int_tfXt; Int_tfYe; Int_tfYlighty position of fictive light source, applies only for rainbowed display modes with shading according to light; Int_tfYmaxy-end channel of spectrum; Int_tfYminy-starting channel of spectrum; Int_tfYs; Int_tfYt; Double_tfZ; Double_tfZPresetValue; Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Painter.html:12342,simpl,simple,12342,root/html528/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Painter.html,6,['simpl'],['simple']
Usability,"nu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TMultiLayerPerceptron ();  Default constructor. ;  ;  TMultiLayerPerceptron (const char *layout, const char *weight, TTree *data, TEventList *training, TEventList *test, TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, const char *weight, TTree *data=nullptr, const char *training=""Entry$%2==0"", const char *test="""", TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, TTree *data, TEventList *training, TEventList *test, TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, TTree *data=nullptr, const char *training=""Entry$%2==0"", const char *test="""", TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  ~TMultiLayerPerceptron () override;  Destructor. ;  ; void ComputeDEDw () const;  Compute the DEDw = sum on all training events of dedw for each weight normalized by the number of events. ;  ; void Draw (Option_t *option="""") override;  Draws the network structure. ;  ; void DrawResult (Int_t index=0, Option_t *option=""test"") const;  Draws the neural net output It produces an histogram with the output for the two datasets. ;  ; Bool_t DumpWeights (Option_t *filename=""-"") const;  Dumps t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:10982,simpl,simple,10982,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,"nual for a detailed description.; Obtaining Tig; Tig is available as package from many Linux distributions. On Debian/Ubuntu it is available with the package name tig from the default repositories.; On RHEL-based systems it is available from the additional repository RepoForge.; On OS X it is easily installed via Homebrew:; brew install tig. Tig pager mode; Many git commands can be piped into tig. When tig is invoked this way, it is in pager mode: output will be colored according to the input format, and colored.; For instance it is possible to pipe the differences of one file like this:; git diff path/to/file.cxx | tig. or see the changes of one revision like this:; git show b204d4c87 | tig. The most important interactive tig commands are:. 'h': opens the help screen; 'q': closes current window; 'Q': closes all windows and exits. Log view; Tig invoked without any argument spawns a full log view with one line per commit including author, date and log message. Heads of the different branches are clearly indicated. To see a graph view indicating branching graphically (just like git log --oneline --graph), do:; tig --all. A log can be selected with Enter to see the revision changes.; An example of useful application of the log view is interactive cherry-picking: just press 'C' to cherry-pick currently selected commit into your current branch.; Blame view; Blame view is extremely useful to see which lines were committed by whom. It is an improved version of the standard git blame command with a much clearer and interactive output.; Each line can be selected to display the associated full commit log and diff. Usage:; tig blame path/to/file.cxx. Interactive staging and current status; tig status opens an interactive display to quickly select files to be staged. Move over the file and press 'u' to (un)stage it. The .gitconfig file; This file contains global (~/.gitconfig) or repository-local configuration settings. You can (eg):. Set user and email information to label comm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:17285,clear,clearly,17285,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['clear'],['clearly']
Usability,"null pointer. void Clear(Option_t* o = 0); Remove all elements from collection. void Delete(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. RooAbsArg* findArg(const RooAbsArg* ) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg) const; Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name) const; Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. RooLinkedListIter iterator(Bool_t dir = kTRUE) const. RooFIter fwdIterator() const. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE); Sort elements of this list according to their; TObject::Compare() ranking via a simple; bubble sort algorithm. void swapWithNext(RooLinkedListElem* elem); Swap given to elements in the linked list. Auxiliary function for Sort(). void Streamer(TBuffer& b); Custom streaming handling schema evolution w.r.t past implementations. TObject* Clone(const char* = 0) const. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. » Last changed: Fri Dec 2 14:26:52 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLinkedList.html:9437,simpl,simple,9437,root/html532/RooLinkedList.html,https://root.cern,https://root.cern/root/html532/RooLinkedList.html,1,['simpl'],['simple']
Usability,"nullptr;; 3821 while (lnk) {; 3822 auto obj = lnk->GetObject();; 3823 if (obj->InheritsFrom(TPad::Class())); 3824 ((TPad*)obj)->PaintModified();; 3825 lnk = lnk->Next();; 3826 }; 3827 return;; 3828 }; 3829 ; 3830 if (fCanvas) TColor::SetGrayscale(fCanvas->IsGrayscale());; 3831 ; 3832 TVirtualPS *saveps = gVirtualPS;; 3833 if (gVirtualPS) {; 3834 if (gVirtualPS->TestBit(kPrintingPS)); 3835 gVirtualPS = nullptr;; 3836 }; 3837 ; 3838 Bool_t began3DScene = kFALSE;; 3839 fPadPaint = 1;; 3840 {; 3841 TContext ctxt(this, kTRUE);; 3842 if (IsModified() || IsTransparent()) {; 3843 if ((fFillStyle < 3026) && (fFillStyle > 3000)) {; 3844 if (!gPad->IsBatch() && GetPainter()) GetPainter()->ClearDrawable();; 3845 }; 3846 PaintBorder(GetFillColor(), kTRUE);; 3847 }; 3848 ; 3849 PaintDate();; 3850 ; 3851 TList *pList = GetListOfPrimitives();; 3852 auto lnk = pList ? pList->FirstLink() : nullptr;; 3853 ; 3854 while (lnk) {; 3855 TObject *obj = lnk->GetObject();; 3856 if (obj->InheritsFrom(TPad::Class())) {; 3857 ((TPad*)obj)->PaintModified();; 3858 } else if (IsModified() || IsTransparent()) {; 3859 ; 3860 // Create a pad 3D viewer if none exists and we encounter a; 3861 // 3D shape; 3862 if (!fViewer3D && obj->InheritsFrom(TAtt3D::Class())) {; 3863 GetViewer3D(""pad"");; 3864 }; 3865 ; 3866 // Open a 3D scene if required; 3867 if (fViewer3D && !fViewer3D->BuildingScene()) {; 3868 fViewer3D->BeginScene();; 3869 began3DScene = kTRUE;; 3870 }; 3871 ; 3872 obj->Paint(lnk->GetOption());; 3873 }; 3874 lnk = lnk->Next();; 3875 }; 3876 }; 3877 ; 3878 fPadPaint = 0;; 3879 Modified(kFALSE);; 3880 ; 3881 // This must be done after modified flag is cleared, as some; 3882 // viewers will invoke another paint by marking pad modified again; 3883 if (began3DScene) {; 3884 if (fViewer3D) fViewer3D->EndScene();; 3885 }; 3886 ; 3887 gVirtualPS = saveps;; 3888}; 3889 ; 3890////////////////////////////////////////////////////////////////////////////////; 3891/// Paint box in CurrentPad World coordinates.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:123016,clear,cleared,123016,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['clear'],['cleared']
Usability,"nup request for the session specified by tag. ;  ; virtual void ClearCache (const char *file=0);  Remove file from all file caches. ;  ; void ClearData (UInt_t what=kUnregistered, const char *dsname=0);  Remove files for the data directory. ;  ; virtual void ClearDataSetCache (const char *dataset=0);  Clear the content of the dataset cache, if any (matching 'dataset', if defined). ;  ; void ClearFeedback ();  Clear feedback list. ;  ; void ClearInput ();  Clear input object list. ;  ; void ClearInputData (const char *name);  Remove obj 'name' form the input data list;. ;  ; void ClearInputData (TObject *obj=0);  Remove obj form the input data list; if obj is null (default), clear the input data info. ;  ; Int_t ClearPackage (const char *package);  Remove a specific package. ;  ; Int_t ClearPackages ();  Remove all packages. ;  ; void Close (Option_t *option="""");  Close all open slave servers. ;  ; void CloseProgressDialog ();  Close progress dialog. ;  ; TDrawFeedback * CreateDrawFeedback ();  Draw feedback creation proxy. ;  ; void DataSetStatus (const char *msg, Bool_t status, Int_t done, Int_t total);  Send dataset preparation status. ;  ; Int_t DeactivateWorker (const char *ord, Bool_t save=kTRUE);  Remove the worker identified by the ordinal number 'ord' from the the active list. ;  ; void DeleteDrawFeedback (TDrawFeedback *f);  Delete draw feedback object. ;  ; void DeleteParameters (const char *wildcard);  Delete the input list parameters specified by a wildcard (e.g. ;  ; void Detach (Option_t *opt="""");  Detach this instance to its proofserv. ;  ; void DisableGoAsyn ();  Signal to disable related switches. ;  ; Int_t DownloadPackage (const char *par, const char *dstdir=0);  Download a PROOF archive (PAR file) from the master package repository. ;  ; Long64_t DrawSelect (const char *dsetname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0, TObject *enl=0);  Execute the specified drawing action on ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:5178,feedback,feedback,5178,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['feedback'],['feedback']
Usability,"nvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooResolutionModel.html:4425,clear,clearValueDirty,4425,root/html528/RooResolutionModel.html,https://root.cern,https://root.cern/root/html528/RooResolutionModel.html,1,['clear'],['clearValueDirty']
Usability,"nvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooResolutionModel.html:4425,clear,clearValueDirty,4425,root/html530/RooResolutionModel.html,https://root.cern,https://root.cern/root/html530/RooResolutionModel.html,1,['clear'],['clearValueDirty']
Usability,"nvas (RCanvas) and draw ROOT 7 boxes in it (RBox) ;  concurrentfill.cxx;  draw.cxx;  draw_mt.cxxThis macro demonstrate usage of ROOT7 graphics from many threads Three different canvases in three different threads are started and regularly updated ;  draw_rh1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_subpads.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 lines in it (RLine) ;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  vo004_SortAndSelect.C In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo004_SortAndSelect.py In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo005_Combinations.C In this tutorial we learn how combinations of RVecs can be build ;  vo005_Combinations.py In this tutorial we learn how combinations of RVecs can be build ;  vo006_IndexManipulation.C In this tutorial we demonstrate RVec helpers for index manipulation ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:172342,learn,learn,172342,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['learn'],['learn']
Usability,"nvas area, near the edges, with the right mouse button; and select the Print item. You can select the name of the Postscript; file. If the file name is xxx.ps, you will generate a Postscript file named; xxx.ps. If the file name is xxx.eps, you generate an encapsulated Postscript; file instead. In your program (or macro), you can type:. c1->Print(""xxx.ps"") or c1->Print(""xxx.eps""). This will generate a file corresponding to the picture in the canvas; pointed by c1.; pad1->Print(""xxx.ps""); prints only the picture in the pad pointed by pad1. The size; of the Postscript picture, by default, is computed to keep the aspect ratio; of the picture on the screen, where the size along x is always 20cm. You; can set the size of the PostScript picture before generating the picture; with a command such as:. TPostScript myps(""myfile.ps"",111); myps.Range(xsize,ysize);; object->Draw();; myps.Close();. You can set the default paper size with:. gStyle->SetPaperSize(xsize,ysize);. You can resume writing again in this file with myps.Open();.; Note that you may have several Postscript files opened simultaneously. Output type; The output type allows to define how the PostScript output will looks like.; It allows to define the page format (A4, Legal etc..), the orientation; (Portrait, Landscape) and the number of images (zones) per page.; The output type has the following form:. [Format][Nx][Ny][Type]. Where:. Format : Is an integer between 0 and 99 defining the page format.; Example:; Format = 3 the paper is in the standard A3 format.; Format = n (1 Format = 4 and Format=0 are the same and define an A4 page.; The A0 format is selected by Format=99.; The US format Letter is selected by Format = 100.; The US format Legal is selected by Format = 200.; The US format Ledger is selected by Format = 300.; Nx, Ny : Specify respectively the number of zones on the x and y axis.; Nx and Ny are integers between 1 and 9.; Type : Can be equal to:; ; 1 : Portrait mode with a small margin at the bottom of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPostScript.html:1747,resume,resume,1747,root/html528/TPostScript.html,https://root.cern,https://root.cern/root/html528/TPostScript.html,3,['resume'],['resume']
Usability,"nvas(); root[] myCanvas->Divide(2,2); We activate the first pad with the TCanvas::cd statement:; root[] myCanvas->cd(1); We then draw the variable Cost:; root[] MyTree->Draw(""C; As you can see, the last call TTree::Draw has only one parameter. It is a string containing the leaf name. A histogram is automatically created as a result of a TTree::Draw. The style of the histogram is inherited from the TTree attributes and the current style (gStyle) is ignored. The TTree gets its attributes from the current TStyle at the time it was created. You can call the method TTree::UseCurrentStyle to change to the current style rather than the TTree style. (See gStyle; see also “Graphics and the Graphical User Interface” ); In the next segment, we activate the second pad and draw a scatter plot variables:; root[] myCanvas->cd(2); root[] MyTree->Draw(""Cost:Age""); This signature still only has one parameter, but it now has two dimensions separated by a colon (""x:y""). The item to be plotted can be an expression not just a simple variable. In general, this parameter is a string that contains up to three expressions, one for each dimension, separated by a colon (“e1:e2:e3”). A list of examples follows this introduction.; 12.20.1 Using Selection with TTree:Draw; Change the active pad to 3, and add a selection to the list of parameters of the draw command.; root[] myCanvas->cd(3); root[] MyTree->Draw(""Cost:Age"",""Nation == ""FR""""); This will draw the Costvs. Age for the entries where the nation is equal to “FR”. You can use any C++ operator, and some functions defined in TFormula, in the selection parameter. The value of the selection is used as a weight when filling the histogram. If the expression includes only Boolean operations as in the example above, the result is 0 or 1. If the result is 0, the histogram is not filled. In general, the expression is:; Selection = ""weight *(boolean expression)""; If the Boolean expression evaluates to true, the histogram is filled with a weight. If the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:586930,simpl,simple,586930,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"o : [dataset] : Added class ""Background""; # : Add Tree bkg_tree of type Background with 10000 events; ; # signalTree.Print();; ; # Booking Methods; ; # Here we book the TMVA methods. We book a Boosted Decision Tree method (BDT); ; ; # Boosted Decision Trees; if useTMVABDT:; factory.BookMethod(; loader,; TMVA.Types.kBDT,; ""BDT"",; V=False,; NTrees=400,; MinNodeSize=""2.5%"",; MaxDepth=2,; BoostType=""AdaBoost"",; AdaBoostBeta=0.5,; UseBaggedBoost=True,; BaggedSampleFraction=0.5,; SeparationType=""GiniIndex"",; nCuts=20,; ); ; ; #### Booking Deep Neural Network; ; # Here we book the DNN of TMVA. See the example TMVA_Higgs_Classification.C for a detailed description of the; # options; ; if useTMVADNN:; layoutString = ROOT.TString(; ""DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR""; ); ; # Training strategies; # one can catenate several training strings with different parameters (e.g. learning rates or regularizations; # parameters) The training string must be concatenated with the `|` delimiter; trainingString1 = ROOT.TString(; ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,""; ""ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,""; ""WeightDecay=1e-4,Regularization=None,""; ""Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.""; ) # + ""|"" + trainingString2 + ...; trainingString1 += "",MaxEpochs="" + str(max_epochs); ; # Build now the full DNN Option string; dnnMethodName = ""TMVA_DNN_CPU""; ; # use GPU if available; dnnOptions = ""CPU""; if hasGPU :; dnnOptions = ""GPU""; dnnMethodName = ""TMVA_DNN_GPU""; ; factory.BookMethod(; loader,; TMVA.Types.kDL,; dnnMethodName,; H=False,; V=True,; ErrorStrategy=""CROSSENTROPY"",; VarTransform=None,; WeightInitialization=""XAVIER"",; Layout=layoutString,; TrainingStrategy=trainingString1,; Architecture=dnnOptions; ); ; ; ### Book Convolutional Neural Network in TMVA; ; # For building a CNN one needs to define; ; # - Input Layout : number of channels (in this case = 1) | image height | image width; # - Batch Layout : batch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:10079,learn,learning,10079,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['learn'],['learning']
Usability,"o <= x <= xup; // what we want :; //; // maximize c^T x - k ( 1/2 ) x^T Q x; // subject to sum_x x_i = 1; // 0 <= x_i; ; // We have nrStocks weights to determine,; // 1 equality- and 0 inequality- equations (the simple square boundary; // condition (xlo <= x <= xup) does not count); ; const Int_t nrVar = nrStocks;; const Int_t nrEqual = 1;; const Int_t nrInEqual = 0;; ; // flip the sign of the objective function because we want to maximize; TVectorD c = -1.*r;; TMatrixDSym Q = riskFactor*Covar;; ; // equality equation; TMatrixD A(nrEqual,nrVar); A = 1;; TVectorD b(nrEqual); b = 1;; ; // inequality equation; //; // - although not applicable in the current situation since nrInEqual = 0, one; // has to specify not only clo and cup but also an index vector iclo and icup,; // whose values are either 0 or 1 . If iclo[j] = 1, the lower boundary condition; // is active on x[j], etc. ...; ; TMatrixD C (nrInEqual,nrVar);; TVectorD clo (nrInEqual);; TVectorD cup (nrInEqual);; TVectorD iclo(nrInEqual);; TVectorD icup(nrInEqual);; ; // simple square boundary condition : 0 <= x_i, so only xlo is relevant .; // Like for clo and cup above, we have to define an index vector ixlo and ixup .; // Since each variable has the lower boundary, we can set the whole vector; // ixlo = 1; ; TVectorD xlo (nrVar); xlo = 0;; TVectorD xup (nrVar); xup = 0;; TVectorD ixlo(nrVar); ixlo = 1;; TVectorD ixup(nrVar); ixup = 0;; ; // setup the quadratic programming problem . Since a small number of variables are; // involved and ""Q"" has everywhere entries, we chose the dense version ""TQpProbDens"" .; // In case of a sparse formulation, simply replace all ""Dens"" by ""Sparse"" below and; // use TMatrixDSparse instead of TMatrixDSym and TMatrixD; ; TQpProbDens *qp = new TQpProbDens(nrVar,nrEqual,nrInEqual);; ; // stuff all the matrices/vectors defined above in the proper places; ; TQpDataDens *prob = (TQpDataDens *)qp->MakeData(c,Q,xlo,ixlo,xup,ixup,A,b,C,clo,iclo,cup,icup);; ; // setup the nrStock variables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:8889,simpl,simple,8889,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['simpl'],['simple']
Usability,"o ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; 1116loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`.; 1117 ; 1118\anchor RDFCollections; 1119### Storing RDataFrame objects in collections; 1120 ; 1121ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:; 1122 ; 1123~~~{.cpp}; 1124std::vector<ROOT::RDF::RNode> dfs;; 1125dfs.emplace_back(ROOT::RDataFrame(10));; 1126dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; 1127~~~; 1128 ; 1129\anchor callbacks; 1130### Executing callbacks every N events; 1131It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; 1132Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; 1133drawing a partially-filled histogram every time a certain number of new entries is processed, or; 1134displaying a progress bar while the event loop runs.; 1135 ; 1136For example one can draw an up-to-date version of a result histogram every 100 entries like this:; 1137~~~{.cpp}; 1138auto h = df.Histo1D(""x"");; 1139TCanvas c(""c"",""x hist"");; 1140h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; 1141// event loop runs here, this final `Draw` is executed after the event loop is finished; 1142h->Draw();; 1143~~~; 1144 ; 1145Callbacks are registered to a ROOT::RDF::RResultPtr and must be callables that takes a reference to the result type as argument; 1146and return nothing. RDataFrame will invoke registered callbacks passing partial action results as arguments to them; 1147(e.g. a histogram filled with a part of the selected events).; 1148 ; 1149Read more on ROOT::RDF::RResultPtr::OnPartialResult() and ROOT::RDF::RResultPtr::OnPartialResultSlot().; 1150 ; 1151\anchor default-branches; 1152### Default",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:66258,progress bar,progress bar,66258,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"o ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; 1156loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`.; 1157 ; 1158\anchor RDFCollections; 1159### Storing RDataFrame objects in collections; 1160 ; 1161ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:; 1162 ; 1163~~~{.cpp}; 1164std::vector<ROOT::RDF::RNode> dfs;; 1165dfs.emplace_back(ROOT::RDataFrame(10));; 1166dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; 1167~~~; 1168 ; 1169\anchor callbacks; 1170### Executing callbacks every N events; 1171It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; 1172Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; 1173drawing a partially-filled histogram every time a certain number of new entries is processed, or; 1174displaying a progress bar while the event loop runs.; 1175 ; 1176For example one can draw an up-to-date version of a result histogram every 100 entries like this:; 1177~~~{.cpp}; 1178auto h = df.Histo1D(""x"");; 1179TCanvas c(""c"",""x hist"");; 1180h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; 1181// event loop runs here, this final `Draw` is executed after the event loop is finished; 1182h->Draw();; 1183~~~; 1184 ; 1185Callbacks are registered to a ROOT::RDF::RResultPtr and must be callables that takes a reference to the result type as argument; 1186and return nothing. RDataFrame will invoke registered callbacks passing partial action results as arguments to them; 1187(e.g. a histogram filled with a part of the selected events).; 1188 ; 1189Read more on ROOT::RDF::RResultPtr::OnPartialResult() and ROOT::RDF::RResultPtr::OnPartialResultSlot().; 1190 ; 1191\anchor default-branches; 1192### Default",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:67938,progress bar,progress bar,67938,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"o action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQComman",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:18071,undo,undo,18071,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,8,['undo'],['undo']
Usability,"o be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure).; 12.8 Branches; The organization of branches allows the designer to optimize the data for the anticipated use. The class for a branch is called TBranch. If two variables are independent, and the designer knows the variables will not be used together, they should be placed on separate branches. If, however, the variables are related, such as the coordinates of a point, it is most efficient to create one branch with both coordinates on it. A variable on a TBranch is called a leaf (yes - TLeaf). Another point to keep in mind when designing trees is that branches of the same TTree can be written to separate files. To add a TBranch to a TTree we call the method TTree::Branch(). Note that we DO NOT use the TBranch constructor.; The TTree::Branch method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a TList, or an array of objects. Let’s see some examples. To follow along you will need the shared library libEvent.so. First, check if it is in $ROOTSYS/test. If it is, copy it to your own area. If it is not there, you have to build it by typing make in $ROOTSYS/test.; 12.9 Adding a Branch to Hold a List of Variables; As in the very first example (cernstaff.root.root) the data we want to save is a list of simple variables, such as integers or floats. In this case, we use the following TTree::Branch signature:; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; The first parameter is the branch name.; The second parameter is the address from which the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with sam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:537240,simpl,simple,537240,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"o be overridden by all derived classes. ;  ; bool forceAnalyticalInt (const RooAbsArg &arg) const override;  ; const RooArgList & funcList () const;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &numVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ;  ; bool getFloor () const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooRealSumFunc to more intuitively reflect the contents of the product operator construction. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  ; void setFloor (bool flag);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:2719,intuit,intuitively,2719,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,2,['intuit'],['intuitively']
Usability,"o discriminating variables collectively denoted  which are chosen within three possible variables denoted , and .; The variable which is not incorporated in  is used as the control variable . The six distributions of the three variables are assumed to be the ones depicted in Fig. 1. Figure 1:; Distributions of the three discriminating variables available to perform the Likelihood fit: ; , , .; Among the three variables, two are used to perform the fit while one is; kept out of the fit to serve the purpose of a control variable. The; three distributions on the top (resp. bottom) of the figure correspond; to the signal (resp. background). The unit of the vertical axis is; chosen such that it indicates the number of entries per bin, if one; slices the histograms in 25 bins. A data sample being built through a Monte Carlo simulation based on the distributions shown in Fig. 1, one obtains the three distributions of Fig. 2. Whereas the distribution of  clearly indicates the presence of the signal, the distribution of and are less obviously populated by signal. Figure 2:; Distributions of the three discriminating variables for signal plus; background. The three distributions are the ones obtained from a data; sample obtained through a Monte Carlo simulation based on the; distributions shown in Fig. 1. The data sample consists of 500 signal events and 5000 background events. Chosing and as discriminating variables to determine and through a maximum Likelihood fit, one builds, for the control variable which is unknown to the fit, the two ; for signal and background shown in Fig. 3. One observes that the . for signal reproduces correctly the PDF even where the latter vanishes,; although the error bars remain sizeable. This results from the almost; complete cancellation between positive and negative weights: the sum of; weights is close to zero while the sum of weights squared is not. The; occurence of negative weights occurs through the appearance of the; covariance matrix, an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSPlot.html:6231,clear,clearly,6231,root/html528/TSPlot.html,https://root.cern,https://root.cern/root/html528/TSPlot.html,4,['clear'],['clearly']
Usability,"o draw a graph ""graph"" it's enough to do:. graph->Draw(""AL"");. The option ""AL"" in the Draw() method means:. The axis should be drawn (option ""A""),; The graph should be drawn as a simple line (option ""L""). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; ""A"" must be specified. TGraphPainter offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call; Draw() again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage return on the ROOT command line,; a click inside the pad,; a call to TPad::Update. Graphs' plotting options; Graphs can be drawn with the following options:. ""A""; Axis are drawn around the graph. ""L""; A simple polyline is drawn. ""F""; A fill area is drawn ('CF' draw a smoothed fill area). ""C""; A smooth Curve is drawn. ""*""; A Star is plotted at each point. ""P""; The current marker is plotted at each point. ""B""; A Bar chart is drawn. ""1""; When a graph is drawn as a bar chart, this option makes the bars start from; the bottom of the pad. By default they start at 0. ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Drawing options can be combined. In the following example the graph; is drawn as a smooth curve (option ""C"") with markers (option ""P"") and; with axes (option ""A""). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",200,10,600,400);. c1->SetFillColor(42);; c1->SetGrid();. const Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; gr = new TGraph(n,x,y);; gr->SetLineColor(2);; gr->SetLineWidth(4);; gr->SetMarkerColor(4);; gr->SetMarkerSize(1.5);; gr->SetMarkerStyle(21);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphPainter.html:1709,simpl,simple,1709,root/html532/TGraphPainter.html,https://root.cern,https://root.cern/root/html532/TGraphPainter.html,4,['simpl'],['simple']
Usability,"o generate the corresponding header file using SOFIE. ;  ;  TMVA_SOFIE_RDataFrame.py;   Example of inference with SOFIE and RDataFrame, of a model trained with Keras. ;  ;  TMVA_SOFIE_RDataFrame_JIT.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ;  ;  TMVA_SOFIE_RSofieReader.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE with the RSofieReader class This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model ;  ;  TMVAClassification.C;   This macro provides examples for the training and testing of the TMVA classifiers. ;  ;  TMVAClassificationApplication.C;   This macro provides a simple example on how to use the trained classifiers within an analysis module ;  ;  TMVAClassificationCategory.C;   This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. ;  ;  TMVAClassificationCategoryApplication.C;   This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  ;  TMVACrossValidation.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ;  TMVACrossValidationApplication.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ;  ;  TMVACrossValidationRegression.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ;  TMVAGAexample.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA ;  ;  TMVAGAexample2.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA. ;  ;  TMVAMinimalClassification.C;   Minimal self-contain",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:5132,simpl,simple,5132,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,1,['simpl'],['simple']
Usability,"o generates two views of the NA49 detector. ;  ;  na49visible.py;  Set visibility attributes for the NA49 geometry Set Shape attributes. ;  ;  ntuple1.py;   Ntuple drawing example. ;  ;  numberEntry.py;  Example frame with one box where the user can increase or decrease a number and the shown value will be updated accordingly. ;  ;  parse_CSV_file_with_TTree_ReadStream.py;  This function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream. ;  ;  pyroot001_arrayInterface.py;   This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data. ;  ;  pyroot002_pythonizationDecorator.py;   This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ;  ;  pyroot003_prettyPrinting.py;   This tutorial illustrates the pretty printing feature of PyROOT, which reveals the content of the object if a string representation is requested, e.g., by Python's print statement. ;  ;  pyroot004_NumbaDeclare.py;   This tutorial illustrates how PyROOT supports declaring C++ callables from Python callables making them, for example, usable with RDataFrame. ;  ;  pyroot005_tfile_context_manager.py;   This tutorial demonstrates the usage of the TFile class as a Python context manager. ;  ;  pyroot006_tcontext_context_manager.py;   This tutorial demonstrates the usage of the TContext class as a Python context manager. ;  ;  ratioplot.py;   Display two histograms and their ratio. ;  ;  shapes.py;   Draw the geometry using the x3d viewver. ;  ;  staff.py;   example of macro to read data from an ascii file and create a root file with a Tree. ;  ;  surfaces.py;   Surfaces example ;  ;  tornado.py;  Tornado example. ;  ;  zdemo.py;   This macro is an example of graphs in log scales with annotations. ;  . tutorialspyroot. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html:2274,usab,usable,2274,doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,https://root.cern,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,1,['usab'],['usable']
Usability,"o implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std::vector<Matrix_t> &otherBiases);; 143 ; 144 /*! Copy all trainable weight and biases from another equivalent layer but with different architecture; 145 The function can copy also extra parameters in addition to weights and biases if they are return; 146 by the function GetExtraLayerParameters */; 147 template <typename Arch>; 148 void CopyParameters(const VGeneralLayer<Arch> &layer);; 149 ; 150 /*! Prints the info about the layer. */; 151 virtual void Print() const = 0;; 152 ; 153 /*! Writes the information and the weights about the layer in an XML node. */; 154 virtual void AddWeightsXMLTo(void *parent) = 0;; 155 ; 156 /*! Read the information and the weights about the layer from XML node. */; 157 virtual void ReadWeightsFromXML(void *parent) = 0;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:5908,learn,learningRate,5908,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,1,['learn'],['learningRate']
Usability,"o left and right half of the window. Note that mouse highlighting and selection will not work exactly right as image for each eye gets slightly shifted and there are two different directions through the mouse pointer, one for each eye. ; Definition at line 2034 of file TGLViewer.cxx. ◆ SetStereoEyeOffsetFac(). void TGLViewer::SetStereoEyeOffsetFac ; (; Float_t ; f). inline . Definition at line 295 of file TGLViewer.h. ◆ SetStereoFrustumAsymFac(). void TGLViewer::SetStereoFrustumAsymFac ; (; Float_t ; f). inline . Definition at line 296 of file TGLViewer.h. ◆ SetStereoZeroParallax(). void TGLViewer::SetStereoZeroParallax ; (; Float_t ; f). inline . Definition at line 294 of file TGLViewer.h. ◆ SetupCameras(). void TGLViewer::SetupCameras ; (; Bool_t ; reset). protected . Setup cameras for current bounding box. ; Definition at line 367 of file TGLViewer.cxx. ◆ SetupClipObject(). void TGLViewer::SetupClipObject ; (; ). overrideprotectedvirtual . allow simple guide axes labels to be scaled relative to scene units ; Setup clip-object. Protected virtual method. ; Reimplemented from TGLViewerBase.; Definition at line 468 of file TGLViewer.cxx. ◆ SetViewport() [1/2]. void TGLViewer::SetViewport ; (; const TGLRect & ; vp). protected . Definition at line 1750 of file TGLViewer.cxx. ◆ SetViewport() [2/2]. void TGLViewer::SetViewport ; (; Int_t ; x, . Int_t ; y, . Int_t ; width, . Int_t ; height . ). protected . Set viewer viewport (window area) with bottom/left at (x,y), with dimensions 'width'/'height'. ; Definition at line 1732 of file TGLViewer.cxx. ◆ Streamer(). void TGLViewer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGLViewer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 395 of file TGLViewer.h. ◆ SwapBuffers(). void TGLViewer::SwapBuffers ; (; ); const. protected . Swap GL buffers. ; Definition at line 1288 of file TGLViewer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewer.html:69082,simpl,simple,69082,doc/master/classTGLViewer.html,https://root.cern,https://root.cern/doc/master/classTGLViewer.html,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"o nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Undo function and is the setter action. ;  ; Bool_t IsUndoing () const;  Undo action is in progress. ;  ; void ls (Option_t *option="""") const override;  ls this command and merged commands ;  ; virtual Long64_t Merge (TCollection *, TFileMergeInfo *);  Merge a collection of TQCommand. ;  ; virtual void Merge (TQCommand *c);  Add command to the list of merged commands. ;  ; virtual void Redo (Option_t *option="""");  Execute command and then merge commands. ;  ; virtual void SetArgs (Int_t nargs,...);  Set do/redo and undo parameters. ;  ; virtual void SetName (const char *name);  Sets name of the command. ;  ; virtual void SetRedoArgs (Int_t nargs,...);  Set redo parameters. ;  ; virtual void SetTitle (const char *title);  Sets description of the command. ;  ; virtual void SetUndoArgs (Int_t nargs,...);  Set undo parameters. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Undo (Option_t *option="""");  Un-execute all merged commands and the command. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void AddAfter (const TObject *after, TObject *obj) override;  Insert object after object after in the list. ;  ; virtual void AddAfter (TObjLink *after, TObject *obj);  Insert object after the specified ObjLink object. ;  ; void AddAt (TObject *obj, Int_t idx) override;  Insert object at position idx in the list. ;  ; void AddBefore (const TObject *before, TObject *obj) override;  Insert object before object before in the list. ;  ; virtual void AddBefore (TObjLink *before, TObject *obj);  Insert obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:7914,undo,undo,7914,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"o not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:34084,clear,clearCacheObject,34084,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,3,['clear'],['clearCacheObject']
Usability,"o obejct with given name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj) const; Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove all elements from collection. void Delete(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg) const; Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name) const; Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. RooLinkedListIter iterator(Bool_t dir = kTRUE) const. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE); Sort elements of this list according to their; TObject::Compare() ranking via a simple; bubble sort algorithm. void swapWithNext(RooLinkedListElem* elem); Swap given to elements in the linked list. Auxiliary function for Sort(). void Streamer(TBuffer& b); Custom streaming handling schema evolution w.r.t past implementations. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. » Last changed: Mon Jul 4 15:23:14 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooLinkedList.html:8920,simpl,simple,8920,root/html530/RooLinkedList.html,https://root.cern,https://root.cern/root/html530/RooLinkedList.html,1,['simpl'],['simple']
Usability,"o run Minos; 107 if (result.HasMinosError(i) ) {; 108 if (fMinosParams.empty()) {; 109 fMinosErrors = true;; 110 fMinosParams.reserve(npar-i);; 111 }; 112 fMinosParams.push_back(i);; 113 }; 114 }; 115 }; 116 ; 117 // set information about errors; 118 SetNormErrors( result.NormalizedErrors() );; 119 ; 120 // set also minimizer type; 121 // algorithm is after "" / ""; 122 const std::string & minname = result.MinimizerType();; 123 size_t pos = minname.find("" / "");; 124 if (pos != std::string::npos) {; 125 std::string minimType = minname.substr(0,pos);; 126 std::string algoType = minname.substr(pos+3,minname.length() );; 127 SetMinimizer(minimType.c_str(), algoType.c_str() );; 128 }; 129 else {; 130 SetMinimizer(minname.c_str());; 131 }; 132}; 133 ; 134 ; 135void FitConfig::SetParamsSettings(unsigned int npar, const double *params, const double * vstep ) {; 136 // initialize FitConfig from given parameter values and step sizes; 137 // if npar different than existing one - clear old one and create new ones; 138 if (params == nullptr) {; 139 fSettings = std::vector<ParameterSettings>(npar);; 140 return;; 141 }; 142 // if a vector of parameters is given and parameters are not existing or are of different size; 143 bool createNew = false;; 144 if (npar != fSettings.size() ) {; 145 fSettings.clear();; 146 fSettings.reserve(npar);; 147 createNew = true;; 148 }; 149 unsigned int i = 0;; 150 const double * end = params+npar;; 151 for (const double * ipar = params; ipar != end; ++ipar) {; 152 double val = *ipar;; 153 double step = 0;; 154 if (vstep == nullptr) {; 155 step = 0.3*std::fabs(val); // step size is 30% of par value; 156 //double step = 2.0*std::fabs(val); // step size is 30% of par value; 157 if (val == 0) step = 0.3;; 158 }; 159 else; 160 step = vstep[i];; 161 ; 162 if (createNew); 163 fSettings.push_back( ParameterSettings(""Par_"" + ROOT::Math::Util::ToString(i), val, step ) );; 164 else {; 165 fSettings[i].SetValue(val);; 166 fSettings[i].SetStepSize(step);; 167 }; 16",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8cxx_source.html:4223,clear,clear,4223,doc/master/FitConfig_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html,1,['clear'],['clear']
Usability,"o study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and read a tree with several simple (integers and floating-point) variables.; 12.14.1 Writing the Tree; Below is the function that writes the tree (tree1w). First, the variables are defined (px, py, pz, random and ev). Then we add a branch for each of the variables to the tree, by calling the TTree::Branch method for each variable.; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; 12.14.1.1 Creating Branches with A single Variable; This is the signature of TTree::Branch to create a branch with a list of variables:; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); The first parameter is the branch name. The second parameter is the address from which to read the value. The third parameter is the leaf list with the name and type of each leaf. In this example, each branch has only one leaf. In the box below, the branch is named px and has one floating point type leaf also call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:552944,simpl,simple,552944,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"o the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:6484,learn,learning,6484,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['learn'],['learning']
Usability,"o the result of this action (of type Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called before Initialize(), because the RResultPtr is constructed before the event loop is started.; void Initialize(): this method is called once before starting the event-loop. Useful for setup operations. It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper, or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; void InitTask(TTreeReader *, unsigned int slot): each working thread shall call this method during the event loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; void Exec(unsigned int slot, ColumnTypes...columnValues): each working thread shall call this method during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value: this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of the requested columns for the particular entry being processed.; void Finalize(): this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; std::string GetActionName(): it returns a string identifier for this type of action that RDataFrame will use in diagnostics, SaveGraph(), etc. Optional methods; If these methods are implemented they enable extra functionality as per the description below. Result_t &PartialUpdate(unsigned int slot): if present, it must return the value of the partial result of this action for the given 'slot'. Different threads might call this method concurrently, but will do so w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:39511,simpl,simple,39511,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['simpl'],['simple']
Usability,"o this dataset, even if it is not the first one added to the frame. By default only the 1st dataset added to a frame will update the normalization information . RooFit::Rescale(double f) Rescale drawn histogram by given factor. . RooFit::Cut(const char*) Only plot entries that pass the given cut. Apart from cutting in continuous variables Cut(""x>5""), this can also be used to plot a specific category state. Use something like Cut(""myCategory == myCategory::stateA""), where myCategory resolves to the state number for a given entry and myCategory::stateA resolves to the state number of the state named ""stateA"". RooFit::CutRange(const char*) Only plot data from given range. Separate multiple ranges with "","". NoteThis often requires passing the normalisation when plotting the PDF because RooFit does not save how many events were being plotted (it will only work for cutting slices out of uniformly distributed variables). data->plotOn(frame01, CutRange(""SB1""));; const double nData = data->sumEntries("""", ""SB1"");; // Make clear that the target normalisation is nData. The enumerator NumEvent; // is needed to switch between relative and absolute scaling.; model.plotOn(frame01, Normalization(nData, RooAbsReal::NumEvent),; ProjectionRange(""SB1""));; RooAbsReal::NumEvent@ NumEventDefinition RooAbsReal.h:276. Histogram drawing options . RooFit::DrawOption(const char* opt) Select ROOT draw option for resulting TGraph object . RooFit::LineStyle(Style_t style) Select line style by ROOT line style code, default is solid . RooFit::LineColor(Color_t color) Select line color by ROOT color code, default is black . RooFit::LineWidth(Width_t width) Select line with in pixels, default is 3 . RooFit::MarkerStyle(Style_t style) Select the ROOT marker style, default is 21 . RooFit::MarkerColor(Color_t color) Select the ROOT marker color, default is black . RooFit::MarkerSize(Size_t size) Select the ROOT marker size . RooFit::FillStyle(Style_t style) Select fill style, default is filled. . RooFit:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:58042,clear,clear,58042,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['clear'],['clear']
Usability,"o this dataset, even if it is not the first one added to the frame. By default only the 1st dataset added to a frame will update the normalization information . RooFit::Rescale(double f) Rescale drawn histogram by given factor. . RooFit::Cut(const char*) Only plot entries that pass the given cut. Apart from cutting in continuous variables Cut(""x>5""), this can also be used to plot a specific category state. Use something like Cut(""myCategory == myCategory::stateA""), where myCategory resolves to the state number for a given entry and myCategory::stateA resolves to the state number of the state named ""stateA"". RooFit::CutRange(const char*) Only plot data from given range. Separate multiple ranges with "","". NoteThis often requires passing the normalisation when plotting the PDF because RooFit does not save how many events were being plotted (it will only work for cutting slices out of uniformly distributed variables). data->plotOn(frame01, CutRange(""SB1""));; const double nData = data->sumEntries("""", ""SB1"");; // Make clear that the target normalisation is nData. The enumerator NumEvent; // is needed to switch between relative and absolute scaling.; model.plotOn(frame01, Normalization(nData, RooAbsReal::NumEvent),; ProjectionRange(""SB1""));; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooAbsReal::NumEvent@ NumEventDefinition RooAbsReal.h:276. Histogram drawing options . RooFit::DrawOption(const char* opt) Select ROOT draw option for resulting TGraph object . RooFit::LineStyle(Style_t style) Select line style by ROOT line style code, default is solid . RooFit::LineColor(Color_t color) Select line color by ROOT color code, default is black . RooFit::LineWidth(Width_t width) Select line with in pixels, default is 3 . RooFit::MarkerStyle(Style_t style) Select the ROOT marker style, default is 21 . RooFit::MarkerColor(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:69840,clear,clear,69840,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['clear'],['clear']
Usability,"o to be executed).Definition TRootBrowser.h:36; TBrowserPlugin::~TBrowserPlugin~TBrowserPlugin() overrideDefinition TRootBrowser.h:45; TBrowserPlugin::SetCommandvoid SetCommand(const char *cmd)Definition TRootBrowser.h:49; TBrowserPlugin::fCommandTString fCommandCommand to be executed.Definition TRootBrowser.h:40; TBrowserPlugin::fSubTabInt_t fSubTabTab element number.Definition TRootBrowser.h:39; TBrowserPlugin::fTabInt_t fTabTab number.Definition TRootBrowser.h:38; TBrowserPlugin::SetSubTabvoid SetSubTab(Int_t sub)Definition TRootBrowser.h:48; TBrowserPlugin::TBrowserPluginTBrowserPlugin(const char *name, const char *cmd="""", Int_t tab=1, Int_t sub=-1)Definition TRootBrowser.h:42; TBrowserPlugin::SetTabvoid SetTab(Int_t tab)Definition TRootBrowser.h:47; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TGCompositeFrameThe base class for composite widgets (menu bars, list boxes, etc.).Definition TGFrame.h:287; TGFrameA subclasses of TGWindow, and is used as base class for some simple widgets (buttons,...Definition TGFrame.h:80; TGFrame::MapRaisedvoid MapRaised() overridemap raisedDefinition TGFrame.h:205; TGHSplitterDefinition TGSplitter.h:90; TGHorizontalFrameA composite frame that layout their children in horizontal way.Definition TGFrame.h:385; TGLayoutHintsThis class describes layout hints used by the layout classes.Definition TGLayout.h:50; TGMainFrameDefines top level windows that interact with the system Window Manager.Definition TGFrame.h:397; TGMenuBarThe TGMenu.h header contains all different menu classes.Definition TGMenu.h:282; TGPictureThe TGPicture class implements pictures and icons used in the different GUI elements and widgets.Definition TGPicture.h:25; TGPopupMenuThis class creates a popup menu object.Definition TGMenu.h:110; TGStatusBarProvides a StatusBar widget.Definition TGStatusBar.h:21; TGTabA tab widget contains a set of composite frames each with a little tab with a name (like a set of fol...Definition TGTab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRootBrowser_8h_source.html:9723,simpl,simple,9723,doc/master/TRootBrowser_8h_source.html,https://root.cern,https://root.cern/doc/master/TRootBrowser_8h_source.html,1,['simpl'],['simple']
Usability,"o vol = mgr->GetVolume(volname.c_str());; 450 RGeomBrowserIter iter(*this);; 451 if (vol && (vol != topnode->GetVolume()) && iter.Navigate(vol)); 452 fSelectedStack = MakeStackByIds(iter.CurrentIds());; 453 }; 454}; 455 ; 456/////////////////////////////////////////////////////////////////////; 457/// Collect information about geometry from single volume; 458/// like it done in JSROOT ClonedNodes.createClones; 459 ; 460void RGeomDescription::Build(TGeoVolume *vol); 461{; 462 ClearDescription();; 463 if (!vol); 464 return;; 465 ; 466 TLockGuard lock(fMutex);; 467 ; 468 fDrawVolume = vol;; 469 ; 470 fSelectedStack.clear();; 471 ; 472 BuildDescription(nullptr, fDrawVolume);; 473}; 474 ; 475/////////////////////////////////////////////////////////////////////; 476/// Clear geometry description; 477 ; 478void RGeomDescription::ClearDescription(); 479{; 480 TLockGuard lock(fMutex);; 481 ; 482 fDesc.clear();; 483 fNodes.clear();; 484 fSortMap.clear();; 485 ClearDrawData();; 486 fDrawIdCut = 0;; 487 fDrawVolume = nullptr;; 488 fSelectedStack.clear();; 489}; 490 ; 491/////////////////////////////////////////////////////////////////////; 492/// Build geometry description; 493 ; 494void RGeomDescription::BuildDescription(TGeoNode *topnode, TGeoVolume *topvolume); 495{; 496 // vector to remember numbers; 497 std::vector<int> numbers;; 498 int offset = 1000000000;; 499 ; 500 // try to build flat list of all nodes; 501 TGeoNode *snode = topnode;; 502 TGeoIterator iter(topvolume);; 503 do {; 504 if (!snode) {; 505 numbers.emplace_back(offset);; 506 fNodes.emplace_back(nullptr);; 507 } else if (snode->GetNumber() >= offset) {; 508 // artificial offset already applied, used as identifier; 509 iter.Skip(); // no need to look inside; 510 } else {; 511 numbers.emplace_back(snode->GetNumber());; 512 snode->SetNumber(offset + fNodes.size()); // use id with shift 1e9; 513 fNodes.emplace_back(snode);; 514 }; 515 } while ((snode = iter()) != nullptr);; 516 ; 517 fDesc.reserve(fNodes.size())",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:12542,clear,clear,12542,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"o your local repository on the master branch, and you realize (perhaps because your project is turning out to be a bit more involved than you thought, or because a slew of changes have just appeared upstream) that you might have been better using NoSY. It's actually quite easy to swap to using NoSY without any disruption to your already-committed changes. Starting from your current position on the master branch:; Stash your current changes if appropriate:; git stash. Create (but do not switch to) a branch which will contain all your local commits up to this point:; git branch <local-branch>. Download the latest metadata from the remote:; git fetch origin. Now, reset your local master branch directly to the current state of origin/master:; git reset --hard origin/master. Note that you have not lost your local commits: they are on your local branch already.; Switch to your local branch:; git checkout <local-branch>. Do an initial sync between your local branch and the remote, resolving conflicts if necessary:; git rebase origin/master. Apply your stash, again, resolving conflicts if necessary:; git stash pop. Pick up at step 2 of the NoSY workflow above.; Reproduced with permission from the following page: https://cdcvs.fnal.gov/redmine/projects/cet-is-public/wiki/GitTipsAndTricks by Chris Green. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-how-tos.html:5131,guid,guidelines,5131,d/git-how-tos.html,https://root.cern,https://root.cern/d/git-how-tos.html,1,['guid'],['guidelines']
Usability,"o, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the include path:; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); You can also overwrite the existing include path:; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); The $ROOTSYS/include directory is automatically appended to the include path, so you do not have to worry about including it. To add library that should be used during linking of the shared library use something like:; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; This is especially useful for static libraries. For shared ones you can also simply load them before trying to compile the script:; gSystem->Load(""mydir/mylib"");; ACLiC uses the directive fMakeSharedLibs to create the shared library. If loading the shared library fails, it tries to output a list of missing symbols by creating an executable (on some platforms like OSF, this does not HAVE to be an executable) containing the script. It uses the directive fMakeExe to do so. For both directives, before passing them to TSystem::Exec(), it expands the variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs, $ExeNameand$ObjectFiles. See SetMakeSharedLib() for more information on those variables. When the file being passed to ACLiC is on a read only file system, ACLiC warns the user and creates the library in a temporary directory:; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; To select the temporary directory ACLiC lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:272300,simpl,simply,272300,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simply']
Usability,"o; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. void Progress(Long64_t total, Long64_t processed). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » La",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionQueryFrame.html:21824,progress bar,progress bar,21824,root/html534/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html534/TSessionQueryFrame.html,1,['progress bar'],['progress bar']
Usability,"oAbsArg &) const override;  ; void generateEvent (Int_t code) override;  This function should never be called as RooAddModel implements a custom generator context. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &numVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Return pseud-code that indicates if all components can do internal generation (1) or not (0) ;  ; TClass * IsA () const override;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Direct generation is safe if all components say so. ;  ; const RooArgList & pdfList () const;  Return list of component p.d.fs. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the product operator construction. ;  ; void resetErrorCounters (Int_t resetValue=10) override;  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; bool selfNormalized () const override;  Model is self normalized when used as p.d.f. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooResolutionModel;  RooResolutionModel ()=default;  ;  RooResolutionModel (const char *name, const char *title, RooAbsRealLValue &x);  Constructor with convolution variable 'x'. ;  ;  RooResolutionModel (const RooResolutionModel &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooResolutionModel () override;  Destructor. ;  ; const RooFormulaVar & basis () const;  ; const RooRealVar & basisConvVar () const;  Return the convolution variabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:4462,intuit,intuitively,4462,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['intuit'],['intuitively']
Usability,"oAbsArg & ; server, . bool ; valueProp, . bool ; shapeProp . ). Change dirty flag propagation mask for specified server. ; Definition at line 438 of file RooAbsArg.cxx. ◆ checkObservables(). bool RooAbsArg::checkObservables ; (; const RooArgSet * ; nset); const. virtual . Overloadable function in which derived classes can implement consistency checks of the variables. ; If this function returns true, indicating an error, the fitter or generator will abort. ; Reimplemented in RooLagrangianMorphFunc, RooAddModel, RooAddPdf, RooRealSumFunc, and RooRealSumPdf.; Definition at line 817 of file RooAbsArg.cxx. ◆ cleanBranchName(). TString RooAbsArg::cleanBranchName ; (; ); const. protected . Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ; Definition at line 2075 of file RooAbsArg.cxx. ◆ clearShapeDirty(). void RooAbsArg::clearShapeDirty ; (; ); const. inlineprotected . Definition at line 579 of file RooAbsArg.h. ◆ clearValueAndShapeDirty(). void RooAbsArg::clearValueAndShapeDirty ; (; ); const. inlineprotected . Definition at line 571 of file RooAbsArg.h. ◆ clearValueDirty(). void RooAbsArg::clearValueDirty ; (; ); const. inlineprotected . Definition at line 576 of file RooAbsArg.h. ◆ clients(). const RefCountList_t & RooAbsArg::clients ; (; ); const. inline . List of all clients of this object. ; Definition at line 166 of file RooAbsArg.h. ◆ clone(). virtual TObject * RooAbsArg::clone ; (; const char * ; newname = nullptr); const. pure virtual . Implemented in RooStats::HistFactory::FlexibleInterpVar, RooStats::HistFactory::LinInterpVar, ParamHistFunc, PiecewiseInterpolation, RooStats::HistFactory::RooBarlowBeestonLL, Roo2DKeysPdf, RooArgusBG, RooBCPEffDecay, RooBCPGenDecay, RooBDecay, RooBernstein, RooBifurGauss, RooBMixDecay, RooBreitWigner, RooBukinPdf, RooCBShape, RooCFunction1Binding< VO, VI >, RooCFunction1PdfBinding< VO, VI >, RooCFunction2Binding< VO, VI1, VI2 >, RooCFunction2PdfBinding< VO, VI1, V",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:50653,clear,clearValueAndShapeDirty,50653,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"oAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChangeTracker(); Deault constructor. RooChangeTracker(const char* name, const char* title, const RooArgSet& trackSet, Bool_t checkValues = kFALSE); Constructor. The set trackSet contains the observables to be; tracked for changes. If checkValues is true an additional; validation step is activated where the numeric values of the; tracked arguments are compared with reference values ensuring; that values have actually changed. RooChangeTracker(const RooChangeTracker& other, const char* name = 0); Copy constructor. Bool_t hasChanged(Bool_t clearState); Returns true if state has changes since last call with clearState=kTRUE; If clearState is true, changeState flag will be cleared. ~RooChangeTracker(); Destructor. RooArgSet parameters() const. TObject* clone(const char* newname) const; { return new RooChangeTracker(*this, newname); }. Double_t evaluate() const; { return 1 ; }. » Last changed: Mon Dec 7 13:47:06 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChangeTracker.html:33717,clear,clearState,33717,root/html526/RooChangeTracker.html,https://root.cern,https://root.cern/root/html526/RooChangeTracker.html,4,['clear'],"['clearState', 'cleared']"
Usability,"oAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooIntegralMorph.html:6377,clear,clearShapeDirty,6377,root/html526/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html526/RooIntegralMorph.html,1,['clear'],['clearShapeDirty']
Usability,"oAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:2946,clear,clearEvalErrorLog,2946,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"oAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:6651,clear,clearShapeDirty,6651,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,3,['clear'],['clearShapeDirty']
Usability,"oAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo2DKeysPdf.html:2761,clear,clearValueAndShapeDirty,2761,root/html532/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html532/Roo2DKeysPdf.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"oAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:4014,clear,clearValueAndShapeDirty,4014,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"oAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:4460,clear,clearValueAndShapeDirty,4460,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"oAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:4460,clear,clearValueAndShapeDirty,4460,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,3,['clear'],['clearValueAndShapeDirty']
Usability,"oArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:3699,clear,clearEvalError,3699,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,2,['clear'],['clearEvalError']
Usability,"oArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdPdf.html:4145,clear,clearEvalError,4145,root/html526/RooProdPdf.html,https://root.cern,https://root.cern/root/html526/RooProdPdf.html,1,['clear'],['clearEvalError']
Usability,"oArgSet& paramsOfInterest, Double_t size = 0.05, const RooArgSet* nullParams = 0); constructor from the data, a model pdf and the parameter of Interest.; If nuisance parameters are present they should be specified as part of the model; i.e. the model pdf is a combined pdf for the poi and the nuisance; The default test size used is 0.05 ( for a 95% interval); A set for the null parameters (it must be a copied set) can be specified which will be used for; performing the hypothesis test. ProfileLikelihoodCalculator(RooAbsData& data, RooStats::ModelConfig& model, Double_t size = 0.05); construct from the data and a model configuration (ModelConfig class); If the model configuration contains a Prior pdf it will be included in the full model; used by the profile likelihood calculator.; The default test size used is 0.05 ( for a 95% interval). ~ProfileLikelihoodCalculator(); destructor (delete the contained result of the fit). void DoReset() const; private method to reset and clear fit results; to be called when a new model or data are set in the calculator. void DoGlobalFit() const; private method to perform a global fit of the likelihood letting with all parameter of interest and; nuisance parameters; keep the list of fitted parameters. LikelihoodInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a profile likelihood ratio and uses that to construct a RooStats::LikelihoodInterval. HypoTestResult* GetHypoTest() const; Main interface to get a HypoTestResult.; It does two fits:; the first lets the null parameters float, so it's a maximum likelihood estimate; the second is to the null (fixing null parameters to their specified values): eg. a conditional maximum likelihood; the ratio of the likelihood at the conditional MLE to the MLE is the profile likelihood ratio.; Wilks' theorem is used to get p-values. A RooArgSet contained a copied of the null parameters must be previously specified; (either in the constructor or by using SetNu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__ProfileLikelihoodCalculator.html:11261,clear,clear,11261,root/html526/RooStats__ProfileLikelihoodCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__ProfileLikelihoodCalculator.html,1,['clear'],['clear']
Usability,"oFitResult*chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:3766,clear,clearValueAndShapeDirty,3766,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,3,['clear'],['clearValueAndShapeDirty']
Usability,"oFitResult*chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:3702,clear,clearValueAndShapeDirty,3702,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"oPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:69727,clear,clearShapeDirty,69727,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,9,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,"oVolume.h:43; The default units are in centimeters. Now we want to make this volume our world. We have to do this operation before closing the geometry.; root[] gGeoManager->SetTopVolume(top);; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; This should be enough, but it is not since always after defining some geometry hierarchy, TGeo needs to build some optimization structures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.; root[] gGeoManager->CloseGeometry();; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; Now we are really done with geometry building stage, but we would like to see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; kMagenta@ kMagentaDefinition Rtypes.h:66; TGeoManager::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE)make top volume visible on screenDefinition TGeoManager.cxx:2396. Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at rootgeom.C. You will notice that this is a bit more complex that just creating the ""world"" since several other volumes are created and put together in a hierarchy. The purpose here is just to learn how to interact with a geometry that is already built, but just few hints on the building steps in this example might be useful. The geometry here represents the word ROOT that is replicated in some symmetric manner. You might for instance ask some",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:7056,simpl,simple,7056,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"object (if one); Long64_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Long64_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafL(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafL(TBranch* parent, const char* name, const char* type); Create a LeafL*-*-; *-* ==============; -. ~TLeafL(); Default destructor for a LeafL*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. LongDouble_t GetValueLongDouble(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a long integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ======",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLeafL.html:8679,simpl,simple,8679,root/html534/TLeafL.html,https://root.cern,https://root.cern/root/html534/TLeafL.html,1,['simpl'],['simple']
Usability,"object (if one); Long64_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Long64_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafL(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafL(TBranch* parent, const char* name, const char* type); Create a LeafL*-*-; *-* ==============; -. ~TLeafL(); Default destructor for a LeafL*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. LongDouble_t GetValueLongDouble(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a long integer from std::istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLeafL.html:9171,simpl,simple,9171,root/html602/TLeafL.html,https://root.cern,https://root.cern/root/html602/TLeafL.html,2,['simpl'],['simple']
Usability,"object (if one); Long64_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Long64_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafL(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafL(TBranch* parent, const char* name, const char* type); Create a LeafL*-*-; *-* ==============; -. ~TLeafL(); Default destructor for a LeafL*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s); read a long integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. TLeafL(). Int_t GetMaximum() const; {return (Int_t)fMaximum;}. Int_t GetMinimum() const; {return (Int_t)fMinimum;}. void * GetValuePointer() const; {return fValue;}. void SetMaximum(Long64_t m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLeafL.html:8461,simpl,simple,8461,root/html528/TLeafL.html,https://root.cern,https://root.cern/root/html528/TLeafL.html,3,['simpl'],['simple']
Usability,"object is of CPPInstance derived type.; 169 if (!Initialize()); 170 return false;; 171 ; 172// detailed walk through inheritance hierarchy; 173 return CPPInstance_Check(pyobject);; 174}; 175 ; 176//-----------------------------------------------------------------------------; 177bool CPyCppyy::Instance_CheckExact(PyObject* pyobject); 178{; 179// Test if the given pyobject is of CPPInstance type.; 180 if (!Initialize()); 181 return false;; 182 ; 183// direct pointer comparison of type member; 184 return CPPInstance_CheckExact(pyobject);; 185}; 186 ; 187//-----------------------------------------------------------------------------; 188bool CPyCppyy::Sequence_Check(PyObject* pyobject); 189{; 190// Extends on PySequence_Check() to determine whether an object can be iterated; 191// over (technically, all objects can b/c of C++ pointer arithmetic, hence this; 192// check isn't 100% accurate, but neither is PySequence_Check()).; 193 ; 194// Note: simply having the iterator protocol does not constitute a sequence, bc; 195// PySequence_GetItem() would fail.; 196 ; 197// default to PySequence_Check() if called with a non-C++ object; 198 if (!CPPInstance_Check(pyobject)); 199 return (bool)PySequence_Check(pyobject);; 200 ; 201// all C++ objects should have sq_item defined, but a user-derived class may; 202// have deleted it, in which case this is not a sequence; 203 PyTypeObject* t = Py_TYPE(pyobject);; 204 if (!t->tp_as_sequence || !t->tp_as_sequence->sq_item); 205 return false;; 206 ; 207// if this is the default getitem, it is only a sequence if it's an array type; 208 if (t->tp_as_sequence->sq_item == CPPInstance_Type.tp_as_sequence->sq_item) {; 209 if (((CPPInstance*)pyobject)->fFlags & CPPInstance::kIsArray); 210 return true;; 211 return false;; 212 }; 213 ; 214// TODO: could additionally verify whether __len__ is supported and/or whether; 215// operator()[] takes an int argument type; 216 ; 217 return true;; 218}; 219 ; 220//--------------------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/API_8cxx_source.html:6523,simpl,simply,6523,doc/master/API_8cxx_source.html,https://root.cern,https://root.cern/doc/master/API_8cxx_source.html,1,['simpl'],['simply']
Usability,"object of class classname.; 2039/// IMPORTANT: classname must derive from TObject.; 2040/// The class dictionary must be available (ClassDef in class header).; 2041///; 2042/// This option requires access to the library where the corresponding class; 2043/// is defined. Accessing one single data member in the object implies; 2044/// reading the full object.; 2045/// See the next Branch constructor for a more efficient storage; 2046/// in case the entry consists of arrays of identical objects.; 2047///; 2048/// By default the branch buffers are stored in the same file as the Tree.; 2049/// use TBranch::SetFile to specify a different file; 2050///; 2051/// IMPORTANT NOTE about branch names:; 2052///; 2053/// And in general, in case two or more master branches contain subbranches; 2054/// with identical names, one must add a ""."" (dot) character at the end; 2055/// of the master branch name. This will force the name of the subbranches; 2056/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2057/// This situation happens when the top level object; 2058/// has two or more members referencing the same class.; 2059/// For example, if a Tree has two branches B1 and B2 corresponding; 2060/// to objects of the same class MyClass, one can do:; 2061/// ~~~ {.cpp}; 2062/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2063/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 2064/// ~~~; 2065/// if MyClass has 3 members a,b,c, the two instructions above will generate; 2066/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; 2067///; 2068/// bufsize is the buffer size in bytes for this branch; 2069/// The default value is 32000 bytes and should be ok for most cases.; 2070/// You can specify a larger value (e.g. 256000) if your Tree is not split; 2071/// and each entry is large (Megabytes); 2072/// A small value for bufsize is optimum if you intend to access; 2073/// the entries in the Tree randomly and your Tree is in split mode.; 2074 ; 2075TBranch* TTree::BranchOl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:81846,simpl,simply,81846,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['simpl'],['simply']
Usability,"object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TQCommand.h>. Inheritance diagram for TQCommand:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TQCommand() [1/3]. TQCommand::TQCommand ; (; const char * ; clname = nullptr, . void * ; obj = nullptr, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; clname - class name.; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments:; if either clname or obj is NULL that means that redo/undo is function; to specify default arguments for redo/undo method/function '=' must precede to argument value. Example: TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case undo parameter can be omitted.; Example: TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. Definition at line 168 of file TQCommand.cxx. ◆ TQCommand() [2/3]. TQCommand::TQCommand ; (; TObject * ; obj, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments: to specify default arguments for redo/undo method/function '=' must precede to argument value.; Example: TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case ""undo"" can parameter be omitted.; Example: TQCommand(gPad, ""SetFillStyle(Style_t)"");. Definition at line 199 of file TQCommand.cxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:32210,undo,undo,32210,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,2,['undo'],['undo']
Usability,"objects with no lights (but lighting still enabled); are partially visible. void DrawSphere(const TGLVertex3& position, Double_t radius, const UChar_t* rgba); Draw sphere, centered on vertex 'position', with radius 'radius',; color 'rgba'. void DrawLine(const TGLLine3& line, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t* rgba); Draw thick line (tube) defined by 'line', with head at end shape; 'head' - box/arrow/none, (head) size 'size', color 'rgba'. void DrawLine(const TGLVertex3& start, const TGLVector3& vector, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t* rgba); Draw thick line (tube) running from 'start', length 'vector',; with head at end of shape 'head' - box/arrow/none,; (head) size 'size', color 'rgba'. void DrawRing(const TGLVertex3& center, const TGLVector3& normal, Double_t radius, const UChar_t* rgba); Draw ring, centered on 'center', lying on plane defined by 'center' & 'normal'; of outer radius 'radius', color 'rgba'. void DrawReferenceMarker(const TGLCamera& camera, const TGLVertex3& pos, Float_t radius = 3, const UChar_t* rgba = 0); Draw a sphere- marker on world-coordinate 'pos' with pixel; radius 'radius'. Color argument is optional. void DrawSimpleAxes(const TGLCamera& camera, const TGLBoundingBox& bbox, Int_t axesType); Draw simple xyz-axes for given bounding-box. void DrawNumber(const TString& num, const TGLVertex3& pos, Bool_t center = kFALSE); Draw number in string 'num' via internal 8x8-pixel bitmap on; vertex 'pos'. If 'center' is true, the number is centered on 'pos'.; Only numbers, '.', '-' and ' ' are supported. TGLColor& operator=(const TGLUtil& ). TGLUtil(const TGLUtil& ). virtual ~TGLUtil(); {}. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-03-13 19:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLUtil.html:12399,simpl,simple,12399,root/html534/TGLUtil.html,https://root.cern,https://root.cern/root/html534/TGLUtil.html,1,['simpl'],['simple']
Usability,"objects,; this function will create one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not poss",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:7099,simpl,simple,7099,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['simpl'],['simple']
Usability,"objects,; this function will create one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode. Ie. if it contains objects of; any types deriving from TTrack this function will sort the objects; basing on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not poss",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:6710,simpl,simple,6710,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['simpl'],['simple']
Usability,"ocal machine. Then after making the commit, we pushed the change to origin. Optionally, we can pull down the last changes from upstream and rebase our branch onto the current master and force-push this to origin. After this, we create a pull request on GitHub from origin. It is important to note that it is not necessary to fork and clone for each contribution.; Merging a pull request locally; If the pull request does not have any conflicts with the master branch, it is possible to apply the changes locally by downloading a patch and piping it to git am with; wget -qO- https://github.com/root-project/root/pull/<PR#>.patch | git am; If you have conflicts, the preferred method is to rebase your branch onto master:; git remote update && git checkout master && git pull && git rebase master <your branch>; When a conflict exists with a commit, git will interrupt the rebase and let you resolve them by editing your files. Once the conflict is resolved, use; git add <conflicting files> && git rebase --continue; to continue the rebasing process. After all conflicts have been resolved, you can check that your changes are really what you want with git log -p master..<your branch> then push the result (without using --force).; Resources. Git How Tos; Git Tips and Tricks; GitHub and Git Foundations (YouTube). Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/creating-pull-request.html:6035,guid,guidelines,6035,d/creating-pull-request.html,https://root.cern,https://root.cern/d/creating-pull-request.html,1,['guid'],['guidelines']
Usability,"ocess (Bool_t abort, Int_t timeout=-1) override;  Stop process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:5436,feedback,feedback,5436,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,2,['feedback'],['feedback']
Usability,"ocess the specified TSelector object 'nentries' times. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddOutput (TList *out) override;  Incorporate output list (may not be used in this class). ;  ; Int_t AddOutputObject (TObject *obj) override;  Incorporate output object (may not be used in this class). ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; Long64_t DrawSelect (TDSet *set, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLocal.html:2261,feedback,feedback,2261,doc/master/classTProofPlayerLocal.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLocal.html,1,['feedback'],['feedback']
Usability,"ock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too many UUIDs within a single; system clock tick, the UUID generator will stall until the; system clock catches up. Function Members (Methods); public:. TUUID(); TUUID(const char* uuid_str); TUUID(const TUUID&); virtual~TUUID(); const char*AsString() const; static TClass*Class(); Int_tCompare(const TUUID& u) const; voidFillBuffer(char*& buffer); TInetAddressGetHostAddress() const; TDatimeGetTime() const; voidGetUUID(UChar_t* uuid) const; UInt_tGetUUIDNumber() const; UShort_tHash() const; virtual TClass*IsA() const; TUUID&operator=(const TUUID&); voidPrint() const; voidReadBuffer(cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUUID.html:2937,clear,cleared,2937,root/html528/TUUID.html,https://root.cern,https://root.cern/root/html528/TUUID.html,4,['clear'],['cleared']
Usability,"ock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too many UUIDs within a single; system clock tick, the UUID generator will stall until the; system clock catches up. Function Members (Methods); public:. virtual~TUUID(); const char*AsString() const; static TClass*Class(); Int_tCompare(const TUUID& u) const; voidFillBuffer(char*& buffer); TInetAddressGetHostAddress() const; TDatimeGetTime() const; voidGetUUID(UChar_t[16] uuid) const; UInt_tGetUUIDNumber() const; UShort_tHash() const; virtual TClass*IsA() const; TUUID&operator=(const TUUID&); voidPrint() const; voidReadBuffer(char*& buffer); voidSetUUID(const char* uuid_str); voidSetU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUUID.html:2961,clear,cleared,2961,root/html602/TUUID.html,https://root.cern,https://root.cern/root/html602/TUUID.html,2,['clear'],['cleared']
Usability,"ocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the branches in the cache. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). const TObjArray * GetCachedBranches() const; { return fBranches; }. Bool_t IsLearning() const; {return fIsLearning;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:23218,learn,learning,23218,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['learn'],['learning']
Usability,"ocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ fReadDirectionSet. bool TTreeCache::fReadDirectionSet {false}. protected . ! read direction established ; Definition at line 62 of file TTreeCache.h. ◆ fReverseRead. bool TTreeCache::fReverseRead {false}. protected . ! reading in reverse mode ; Definition at line 58 of file TTreeCache.h. ◆ fTree. TTree* TTreeCache::fTree {nullptr}. protected . ! pointer to the current Tree ; Definition at line 53 of file TTreeCache.h. Libraries for TTreeCache:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TTreeCache.h; tree/tree/src/TTreeCache.cxx. TTreeCache. ROOT master - Ref",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:56378,learn,learning,56378,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['learn'],['learning']
Usability,"ocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ fReadDirectionSet. bool TTreeCache::fReadDirectionSet {false}. protected . ! read direction established ; Definition at line 62 of file TTreeCache.h. ◆ fReverseRead. bool TTreeCache::fReverseRead {false}. protected . ! reading in reverse mode ; Definition at line 58 of file TTreeCache.h. ◆ fTree. TTree* TTreeCache::fTree {nullptr}. protected . ! pointer to the current Tree ; Definition at line 53 of file TTreeCache.h. Libraries for TTreeCache:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TTreeCache.h; tree/tree/src/TTreeCache.cxx. TTreeCache. ROOT v6-32 - Refe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:56308,learn,learning,56308,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['learn'],['learning']
Usability,"od GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1207 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundScale(). void TUnfoldSys::GetEmatrixSysBackgroundScale ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background normalisation uncertainty ; Parameters. [in,out]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram prior to adding the covariance matrix contribution. this method returns the uncertainties on the unfolding result arising from the background source source and its normalisation uncertainty. See method SubtractBackground() how to set the normalisation uncertainty ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1144 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundUncorr(). void TUnfoldSys::GetEmatrixSysBackgroundUncorr ; (; TH2 * ; ematrix, . const char * ; source, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background uncorrelated uncertainty ; Parameters. [in]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result arising from the background source source and the uncorrelated (background histogram uncertainties). Also see method SubtractBackground() ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1229 of file TUnfoldSys.cxx. ◆ GetEmatrixSysSo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:39081,clear,clearEmat,39081,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,"ode->GetVolume());; 447 ; 448 if (!volname.empty()) {; 449 auto vol = mgr->GetVolume(volname.c_str());; 450 RGeomBrowserIter iter(*this);; 451 if (vol && (vol != topnode->GetVolume()) && iter.Navigate(vol)); 452 fSelectedStack = MakeStackByIds(iter.CurrentIds());; 453 }; 454}; 455 ; 456/////////////////////////////////////////////////////////////////////; 457/// Collect information about geometry from single volume; 458/// like it done in JSROOT ClonedNodes.createClones; 459 ; 460void RGeomDescription::Build(TGeoVolume *vol); 461{; 462 ClearDescription();; 463 if (!vol); 464 return;; 465 ; 466 TLockGuard lock(fMutex);; 467 ; 468 fDrawVolume = vol;; 469 ; 470 fSelectedStack.clear();; 471 ; 472 BuildDescription(nullptr, fDrawVolume);; 473}; 474 ; 475/////////////////////////////////////////////////////////////////////; 476/// Clear geometry description; 477 ; 478void RGeomDescription::ClearDescription(); 479{; 480 TLockGuard lock(fMutex);; 481 ; 482 fDesc.clear();; 483 fNodes.clear();; 484 fSortMap.clear();; 485 ClearDrawData();; 486 fDrawIdCut = 0;; 487 fDrawVolume = nullptr;; 488 fSelectedStack.clear();; 489}; 490 ; 491/////////////////////////////////////////////////////////////////////; 492/// Build geometry description; 493 ; 494void RGeomDescription::BuildDescription(TGeoNode *topnode, TGeoVolume *topvolume); 495{; 496 // vector to remember numbers; 497 std::vector<int> numbers;; 498 int offset = 1000000000;; 499 ; 500 // try to build flat list of all nodes; 501 TGeoNode *snode = topnode;; 502 TGeoIterator iter(topvolume);; 503 do {; 504 if (!snode) {; 505 numbers.emplace_back(offset);; 506 fNodes.emplace_back(nullptr);; 507 } else if (snode->GetNumber() >= offset) {; 508 // artificial offset already applied, used as identifier; 509 iter.Skip(); // no need to look inside; 510 } else {; 511 numbers.emplace_back(snode->GetNumber());; 512 snode->SetNumber(offset + fNodes.size()); // use id with shift 1e9; 513 fNodes.emplace_back(snode);; 514 }; 515 } while ((snode =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:12519,clear,clear,12519,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"ode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:73214,simpl,simple,73214,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,1,['simpl'],['simple']
Usability,"odeorig->MakeCopyNode();; 2298 if (!newnode) {; 2299 Fatal(""ReplaceNode"", ""Cannot make copy node for %s"", nodeorig->GetName());; 2300 return nullptr;; 2301 }; 2302 // Change the volume for the new node; 2303 newnode->SetVolume(vol);; 2304 // Replace the matrix; 2305 if (newpos && !nodeorig->IsOffset()) {; 2306 TGeoNodeMatrix *nodemat = (TGeoNodeMatrix *)newnode;; 2307 nodemat->SetMatrix(newpos);; 2308 }; 2309 // Replace nodeorig with new one; 2310 fNodes->RemoveAt(ind);; 2311 fNodes->AddAt(newnode, ind);; 2312 if (fVoxels); 2313 fVoxels->SetNeedRebuild();; 2314 if (IsAssembly()); 2315 fShape->ComputeBBox();; 2316 return newnode;; 2317}; 2318 ; 2319////////////////////////////////////////////////////////////////////////////////; 2320/// Select this volume as matching an arbitrary criteria. The volume is added to; 2321/// a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need; 2322/// to be reset at the end by calling the method with CLEAR=true. This will also clear; 2323/// the list.; 2324 ; 2325void TGeoVolume::SelectVolume(Bool_t clear); 2326{; 2327 static TObjArray array(256);; 2328 static Int_t len = 0;; 2329 Int_t i;; 2330 TObject *vol;; 2331 if (clear) {; 2332 for (i = 0; i < len; i++) {; 2333 vol = array.At(i);; 2334 vol->ResetBit(TGeoVolume::kVolumeSelected);; 2335 }; 2336 array.Clear();; 2337 len = 0;; 2338 return;; 2339 }; 2340 SetBit(TGeoVolume::kVolumeSelected);; 2341 array.AddAtAndExpand(this, len++);; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// set visibility of this volume; 2346 ; 2347void TGeoVolume::SetVisibility(Bool_t vis); 2348{; 2349 TGeoAtt::SetVisibility(vis);; 2350 if (fGeoManager->IsClosed()); 2351 SetVisTouched(kTRUE);; 2352 fGeoManager->SetVisOption(4);; 2353 TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 2354 TIter next(brlist);; 2355 TBrowser *browser = nullptr;; 2356 while ((browser = (TBrowser *)next())) {; 2357 browser->CheckObjectItem(this, v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:86270,clear,clear,86270,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['clear'],['clear']
Usability,"odes. ~DecisionTree(); destructor. void SetParentTreeInNodes(TMVA::Node* n = NULL); descend a tree to find all its leaf nodes, fill max depth reached in the; tree at the same time. TMVA::DecisionTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); re-create a new tree (decision tree or search tree) from XML. UInt_t BuildTree(const TMVA::DecisionTree::EventList& eventSample, TMVA::DecisionTreeNode* node = NULL); building the decision tree by recursively calling the splitting of; one (root-) node into two daughter nodes (returns the number of nodes). void FillTree(TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = NULL); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(TMVA::DecisionTree::EventList* validationSample = NULL); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__DecisionTree.html:10136,clear,clear,10136,root/html528/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html,3,['clear'],['clear']
Usability,"of * GetProof () const;  ; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ; void StopFeedback () override;  Stop reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if requested. ;  ; virtual Int_t DrawCanvas (TObject *obj);  Draw the object if it is a canvas. ;  ; void * GetSender () override;  ; void MapOutputListToDataMembers () const;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  . Additional Inherited Members;  Public Types inherited from TProofPlayer; enum  EStat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:22052,feedback,feedback,22052,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,1,['feedback'],['feedback']
Usability,"of * GetProof () const;  ; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ; void StopFeedback () override;  Stop reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if requested. ;  ; virtual Int_t DrawCanvas (TObject *obj);  Draw the object if it is a canvas. ;  ; void * GetSender () override;  ; void MapOutputListToDataMembers () const;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  . Protected Attributes; TDSet * fDSet;  ; ErrorHandlerFunc_t fErrorHandler;  tdset for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:20345,feedback,feedback,20345,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallelMergeTest.C;  pclient.CClient program to test parallel sockets ;  pserv.CServer program to test parallel sockets ;  spy.CClient program which allows the snooping of objects from a spyserv process ;  spyserv.CServer program which allows clients, ""spies"", to connect and snoop objects ;  TestAuth.CMacro test authentication methods stand alone ;  testTUDPSocket.CAs test echo server use udpserver.c in the same directory ;  treeClient.CClient program which creates and fills 2 histograms and a TTree ;  TUriTest.CRudimentary TUri test macro ;  udpserver.c;  ► physics;  PhaseSpace.C Example of use of TGenPhaseSpace ;  ► proof;  EmptyInclude.hEmpty file to test TProof::Load in run",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:134476,simpl,simple,134476,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['simpl'],['simple']
Usability,"of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the branches in the cache. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). Bool_t IsLearning() const; {return fIsLearning;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TTreeCache.h 34935 2010-08-23 09:13:37Z brun $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:20516,learn,learning,20516,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,2,['learn'],['learning']
Usability,"of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:50403,simpl,simply,50403,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['simpl'],['simply']
Usability,"of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2145 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2160 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2170 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2187 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:50473,simpl,simply,50473,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['simpl'],['simply']
Usability,"of file MethodDT.cxx. ◆ DeclareCompatibilityOptions(). void TMVA::MethodDT::DeclareCompatibilityOptions ; (; ). virtual . options that are used ONLY for the READER to ensure backward compatibility ; Reimplemented from TMVA::MethodBase.; Definition at line 245 of file MethodDT.cxx. ◆ DeclareOptions(). void TMVA::MethodDT::DeclareOptions ; (; ). virtual . Define the options (their key words) that can be set in the option string. . UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting. known:; GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB. nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine misclassification error rate); PruneMethod The Pruning method: known:; NoPruning // switch off pruning completely; ExpectedError; CostComplexity. PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided""); . Implements TMVA::MethodBase.; Definition at line 212 of file MethodDT.cxx. ◆ DeclFileName(). static const char * TMVA::MethodDT::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 139 of file MethodDT.h. ◆ GetHelpMessage(). void TMVA::MethodDT::GetHelpMessage ; (; ); const. virtual . Implements TMVA::IMethod.; Definition at line 561 of file MethodDT.cxx. ◆ GetMvaValue(). Double_t TMVA::MethodDT::GetMvaValue ; (; Double_t * ; err = nullptr, . Double_t * ; errUpper = nullptr . ). virtual . returns MVA value ; Impleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDT.html:35219,simpl,simply,35219,doc/master/classTMVA_1_1MethodDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDT.html,1,['simpl'],['simply']
Usability,"of file RooVectorDataStore.cxx. ◆ forceCacheUpdate(). void RooVectorDataStore::forceCacheUpdate ; (; ). overrideprotectedvirtual . Reimplemented from RooAbsDataStore.; Definition at line 915 of file RooVectorDataStore.cxx. ◆ get() [1/3]. virtual const RooArgSet * RooAbsDataStore::get ; (; ); const. inlinevirtual . Reimplemented from RooAbsDataStore.; Definition at line 60 of file RooAbsDataStore.h. ◆ get() [2/3]. const RooArgSet * RooVectorDataStore::get ; (; Int_t ; index); const. overridevirtual . Load the n-th data point (n='index') into the variables of this dataset, and return a pointer to the RooArgSet that holds them. ; Implements RooAbsDataStore.; Definition at line 352 of file RooVectorDataStore.cxx. ◆ get() [3/3]. virtual const RooArgSet * RooAbsDataStore::get ; (; Int_t ; index); const. virtual . Implements RooAbsDataStore. ◆ getArrays(). RooVectorDataStore::ArraysStruct RooVectorDataStore::getArrays ; (; ); const. Exports all arrays in this RooVectorDataStore into a simple datastructure to be used by RooFit internal export functions. ; Definition at line 1366 of file RooVectorDataStore.cxx. ◆ getBatches(). RooAbsData::RealSpans RooVectorDataStore::getBatches ; (; std::size_t ; first, . std::size_t ; len . ); const. overridevirtual . Return batches of the data columns for the requested events. ; Parameters. [in]firstFirst event in the batches. ; [in]lenNumber of events in batches. . ReturnsSpans with the associated data. ; Implements RooAbsDataStore.; Definition at line 1137 of file RooVectorDataStore.cxx. ◆ getCategoryBatches(). RooAbsData::CategorySpans RooVectorDataStore::getCategoryBatches ; (; std::size_t ; first, . std::size_t ; len . ); const. overridevirtual . Reimplemented from RooAbsDataStore.; Definition at line 1176 of file RooVectorDataStore.cxx. ◆ getWeightBatch(). std::span< const double > RooVectorDataStore::getWeightBatch ; (; std::size_t ; first, . std::size_t ; len . ); const. overridevirtual . Return the weights of all events in the ra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:30588,simpl,simple,30588,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['simpl'],['simple']
Usability,"of file TProof.cxx. ◆ Collect() [4/4]. Int_t TProof::Collect ; (; TMonitor * ; mon, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect responses from the slave servers. ; Returns the number of messages received. Can be 0 if there are no active slaves. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. Collect also stops its execution from time to time to check for new workers in Dynamic Startup mode. ; Definition at line 2756 of file TProof.cxx. ◆ CollectInputFrom(). Int_t TProof::CollectInputFrom ; (; TSocket * ; s, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect and analyze available input from socket s. ; Returns 0 on success, -1 if any failure occurs. ; Definition at line 3060 of file TProof.cxx. ◆ CreateDrawFeedback(). TDrawFeedback * TProof::CreateDrawFeedback ; (; ). Draw feedback creation proxy. ; When accessed via TProof avoids link dependency on libProofPlayer. ; Definition at line 10094 of file TProof.cxx. ◆ CreateMerger(). Bool_t TProof::CreateMerger ; (; TSlave * ; sl, . Int_t ; port . ). private . Create a new merger. ; Definition at line 4454 of file TProof.cxx. ◆ CreateSlave(). TSlave * TProof::CreateSlave ; (; const char * ; url, . const char * ; ord, . Int_t ; perf, . const char * ; image, . const char * ; workdir . ). protected . Create a new TSlave of type TSlave::kSlave. ; Note: creation of TSlave is private with TProof as a friend. Derived classes must use this function to create slaves. ; Definition at line 1853 of file TProof.cxx. ◆ CreateSubmaster(). TSlave * TProof::CreateSubmaster ; (; const char * ; url, . const char * ; ord, . const char * ; image, . const char * ; msd, . Int_t ; nwk = 1 . ). protected . Create a new TSlave of type TSlave::kMaster. ; Note: creation of TSlave is private with TProof as a friend. Derived classes must use this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:79282,feedback,feedback,79282,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['feedback'],['feedback']
Usability,"of file TRobustEstimator.cxx. ◆ CreateOrtSubset(). void TRobustEstimator::CreateOrtSubset ; (; TMatrixD & ; dat, . Int_t * ; index, . Int_t ; hmerged, . Int_t ; nmerged, . TMatrixD & ; sscp, . Double_t * ; ndist . ). protected . creates a subset of hmerged vectors with smallest orthogonal distances to the hyperplane hyp[1]*(x1-mean[1])+...+hyp[nvar]*(xnvar-mean[nvar])=0 This function is called in case when less than fH samples lie on a hyperplane. ; Definition at line 968 of file TRobustEstimator.cxx. ◆ CreateSubset(). void TRobustEstimator::CreateSubset ; (; Int_t ; ntotal, . Int_t ; htotal, . Int_t ; p, . Int_t * ; index, . TMatrixD & ; data, . TMatrixD & ; sscp, . Double_t * ; ndist . ). protected . creates a subset of htotal elements from ntotal elements first, p+1 elements are drawn randomly(without repetitions) if their covariance matrix is singular, more elements are added one by one, until their covariance matrix becomes regular or it becomes clear that htotal observations lie on a hyperplane If covariance matrix determinant!=0, distances of all ntotal elements are calculated, using formula d_i=Sqrt((x_i-M)*S_inv*(x_i-M)), where M is mean and S_inv is the inverse of the covariance matrix htotal points with smallest distances are included in the returned subset. ; Definition at line 878 of file TRobustEstimator.cxx. ◆ CStep(). Double_t TRobustEstimator::CStep ; (; Int_t ; ntotal, . Int_t ; htotal, . Int_t * ; index, . TMatrixD & ; data, . TMatrixD & ; sscp, . Double_t * ; ndist . ). protected . from the input htotal-subset constructs another htotal subset with lower determinant ; As proven by Peter J.Rousseeuw and Katrien Van Driessen, if distances for all elements are calculated, using the formula:d_i=Sqrt((x_i-M)*S_inv*(x_i-M)), where M is the mean of the input htotal-subset, and S_inv - the inverse of its covariance matrix, then htotal elements with smallest distances will have covariance matrix with determinant less or equal to the determinant of the inpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRobustEstimator.html:22631,clear,clear,22631,doc/master/classTRobustEstimator.html,https://root.cern,https://root.cern/doc/master/classTRobustEstimator.html,1,['clear'],['clear']
Usability,"of file TUnfold.cxx. ◆ DoUnfold() [2/3]. Double_t TUnfold::DoUnfold ; (; Double_t ; tau_reg, . const TH1 * ; input, . Double_t ; scaleBias = 0.0 . ). perform the unfolding for a given input and regularisation ; Parameters. [in]tau_regregularisation parameter ; [in]inputinput distribution with uncertainties ; [in]scaleBias(default=0.0) scale factor applied to the bias. This is a shortcut for { SetInput(input,scaleBias); DoUnfold(tau); } ; Definition at line 2235 of file TUnfold.cxx. ◆ DoUnfold() [3/3]. Double_t TUnfold::DoUnfold ; (; void ; ). protectedvirtual . core unfolding algorithm ; Definition at line 246 of file TUnfold.cxx. ◆ ErrorMatrixToHist(). void TUnfold::ErrorMatrixToHist ; (; TH2 * ; ematrix, . const TMatrixDSparse * ; emat, . const Int_t * ; binMap, . Bool_t ; doClear . ); const. protected . add up an error matrix, also respecting the bin mapping ; Parameters. [in,out]ematrixerror matrix histogram ; [in]ematerror matrix stored with internal mapping (member fXToHist) ; [in]binMapmapping of histogram bins ; [in]doClearif true, ematrix is cleared prior to adding elements of emat to it. the array binMap is explained with the method GetOutput(). The matrix emat must have dimension NxN where N=fXToHist.size() The flag doClear may be used to add covariance matrices from several uncertainty sources. ; Definition at line 3379 of file TUnfold.cxx. ◆ GetAx(). const TMatrixDSparse * TUnfold::GetAx ; (; void ; ); const. inlineprotected . vector of folded-back result ; Definition at line 248 of file TUnfold.h. ◆ GetBias(). void TUnfold::GetBias ; (; TH1 * ; out, . const Int_t * ; binMap = nullptr . ); const. get bias vector including bias scale ; Parameters. [out]outhistogram to store the scaled bias vector. The bin contents are overwritten ; [in]binMap(default=nullptr) array for mapping truth bins to histogram bins. This method returns the bias vector times scaling factor, f*x0; The use of binMap is explained with the documentation of the GetOutput() method ; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:31556,clear,cleared,31556,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['clear'],['cleared']
Usability,"of parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in his RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix (Note that Vred _is_ a simple sub-matrix of V,; row/columns are ordered to matched the convention given in input argument 'params'. TMatrixDSym conditionalCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; is the Shur complement of V22, calculated as shown above. (Note that Vred is _not_ a simple sub-matrix of V). const TMatrixDSym& correlationMatrix() const; Return correlation matrix ;. RooAbsPdf* createHessePdf(const RooArgSet& params) const; Return a p.d.f that represents the fit result as a multi-variate probability densisty; function on the floating fit parameters, including correlations. void SetName(const char* name); Change name of RooFitResult object. void SetNameTitle(const char* name, const char* title); Change name and title of RooFitResult object. void printName(ostream& os) const; Print name of fit result. void printTitle(ostream& os) const; Print title of fit result. void printClassName(ostream& os) const; Print class name of fit result. void printArgs(ostream& os) const; Print arguments of fit result, i.e. the parameters of the fit. void printValue(ostream& os) const; Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. Int_t defaultPrintContents(Option_t* opt) const; Configure default contents to be print",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFitResult.html:15476,simpl,simple,15476,root/html532/RooFitResult.html,https://root.cern,https://root.cern/root/html532/RooFitResult.html,2,['simpl'],['simple']
Usability,"of point and max number of points (to pre-allocate vector)Definition UnBinData.h:54; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int n, unsigned int dim, Iterator dataItr, bool isWeighted=false)constructor for multi-dim external data (data are not copied inside) Uses as argument an iterator of ...Definition UnBinData.h:127; ROOT::Fit::UnBinData::Addvoid Add(const double *x)add multi-dim coordinate dataDefinition UnBinData.h:230; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints, const double *dataX, const double *dataY, const double *dataZ, const DataRange &range, bool isWeighted=false)constructor for 3D data and a range (data are copied inside according to the given range) or a 2D dat...Definition UnBinData.h:161; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints, const double *dataX, const double *dataY, const DataRange &range, bool isWeighted=false)constructor for 2D data and a range (data are copied inside according to the given range) or 1 1D dat...Definition UnBinData.h:150; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int n, const double *dataX, const double *dataY, bool isWeighted=false)constructor for 2D external data (data are not copied inside) or 1D data with a weight (if isWeighted...Definition UnBinData.h:101; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28. mathmathcoreincFitUnBinData.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/UnBinData_8h_source.html:14751,simpl,simple,14751,doc/master/UnBinData_8h_source.html,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html,1,['simpl'],['simple']
Usability,"of the analysis: select relevant; // tree entries, run algorithms on the tree entry and typically fill histograms.;  ; // *** 1. *** Tell the reader to load the data for this entry:; fReader.SetEntry(entry);;  ; // *** 2. *** Do the actual analysis; int tagMuon = gRandom->Integer(fRaPt.GetSize());;  ; if (fRaTriggered[tagMuon]) {; for (int iMuon = 0, nMuons = fRaPt.GetSize(); iMuon < nMuons; ++iMuon) {; // All but the tag muon can be probe muons; if (iMuon != tagMuon) {; 	 // Fill the efficiency object with; 	 // - whether this muon has triggered; 	 // - the pT of this muon.; 	 fEff->Fill(fRaTriggered[iMuon], fRaPt[iMuon]);; }; }; };  ; return kTRUE;; };  ; void TutorialSelector::Terminate(); {; // The Terminate() function is the last function to be called during the; // analysis of a tree with a selector. It always runs on the client, it can; // be used to present the results graphically or save the results to file.;  ; fEff->Print();; }.  . . ‹ 10. Go Parallel!; up; 11. Done! ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/tutorialselectorc.html:6370,guid,guidelines,6370,d/tutorialselectorc.html,https://root.cern,https://root.cern/d/tutorialselectorc.html,1,['guid'],['guidelines']
Usability,"of the class that was first created. To retrieve a later instance you can use GetListOfPrimitives(), which returns a list of all the objects on the pad. From the list you can select the object you need.; 9.3.1.2 Hiding an Object; Hiding an object in a pad can be made by removing it from the list of objects owned by that pad. This list is accessible by the GetListOfPrimitives() method of TPad. This method returns a pointer to a TList. Suppose we get the pointer to the object, we want to hide, call it obj (see paragraph above). We get the pointer to the list:; root[] li = gPad->GetListOfPrimitives(); Then remove the object from this list:; root[] li->Remove(obj); The object will disappear from the pad as soon as the pad is updated (try to resize it for example). If one wants to make the object reappear:; root[] obj->Draw(); Caution, this will not work with composed objects, for example many histograms drawn on the same plot (with the option “same”). There are other ways! Try to use the method described here for simple objects.; 9.3.2 The Coordinate Systems of a Pad; There are coordinate systems in a TPad: user coordinates, normalized coordinates (NDC), and pixel coordinates. Pad coordinate systems. 9.3.2.1 The User Coordinate System; The most common is the user coordinate system. Most methods of TPad use the user coordinates, and all graphic primitives have their parameters defined in terms of user coordinates. By default, when an empty pad is drawn, the user coordinates are set to a range from 0 to 1 starting at the lower left corner. At this point they are equivalent of the NDC coordinates (see below). If you draw a high level graphical object, such as a histogram or a function, the user coordinates are set to the coordinates of the histogram. Therefore, when you set a point it will be in the histogram coordinates.; For a newly created blank pad, one may use TPad::Range to set the user coordinate system. This function is defined as:; void Range(float x1,float y1,floa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:307442,simpl,simple,307442,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"of the distribution D (Max). A box plot describes a distribution with only five numbers. In ROOT Box Plots (Candle Plots) can be produced from a TTree using the “candle” option in TTree::Draw().; tree->Draw(“px:cos(py):sin(pz)”,””,”candle”);; 12.20.9 Using TTree::Scan. TTree::Scan can be used to print the content of the tree’s entries optional passing a selection.; root[] MyTree->Scan();; will print the first 8 variables of the tree.; root[] MyTree->Scan(""*"");; will print all the variable of the tree.; Specific variables of the tree can be explicit selected by list them in column separated list:; root[] MyTree->Scan(""var1:var2:var3"");; will print the values of var1, var2 and var3. A selection can be applied in the second argument:; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; will print the values of var1, var2 and var3 for the entries where var1 is exactly 0.; TTree::Scan returns the number of entries passing the selection. By default 50 rows are shown before TTree::Scan pauses and ask you to press the Enter key to see the next 50 rows. You can change the default number of rows to be shown before <CR> via mytree->SetScanfield(maxrows) where maxrows is 50 by default. If maxrows is set to 0 all rows of the Tree are shown. This option is interesting when dumping the contents of a Tree to an ascii file, eg from the command line:; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; will create a file tree.log.; Arrays (within an entry) are printed in their linear forms. If several arrays with multiple dimensions are printed together, they will NOT be synchronized. For example, with a tree containing arr1[4][2]and arr2[2][3],; root[] MyTree(""arr1:arr2"");; will results in a printing similar to:; ************************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:619345,pause,pauses,619345,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['pause'],['pauses']
Usability,"of these entries that pass the selection, and when you have a parametrization available for the efficiency as a function of the variable(s) under consideration.; A very common problem when estimating efficiencies is that of error estimation: when no other information is available than the total number of events N and the selected number n, the best estimate for the selection efficiency p is n/N. Standard binomial statistics dictates that the uncertainty (this presupposes sufficiently high statistics that an approximation by a normal distribution is reasonable) on p, given N, is ; \[; \sqrt{\frac{p(1-p)}{N}}; \]. However, when p is estimated as n/N, fluctuations from the true p to its estimate become important, especially for low numbers of events, and giving rise to biased results.; When fitting a parametrized efficiency, these problems can largely be overcome, as a hypothesized true efficiency is available by construction. Even so, simply using the corresponding uncertainty still presupposes that Gaussian errors yields a reasonable approximation. When using, instead of binned efficiency histograms, the original numerator and denominator histograms, a binned maximum likelihood can be constructed as the product of bin-by-bin binomial probabilities to select n out of N events. Assuming that a correct parametrization of the efficiency is provided, this construction in general yields less biased results (and is much less sensitive to binning details).; A generic use of this method is given below (note that the method works for 2D and 3D histograms as well):; {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(; numerator, denominator);; Int_t status = f->Fit(eff, ""I"");; if (status == 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html:1488,simpl,simply,1488,doc/master/classTBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html,1,['simpl'],['simply']
Usability,"ofServ::GetOptions(Int_t* argc, char** argv); const char*TProofServ::GetOrdinal() const; const char*TProofServ::GetPackageDir() const; const char*TProofServ::GetPrefix() const; TProof*TProofServ::GetProof() const; Int_tTProofServ::GetProtocol() const; Int_tTProofServ::GetQuerySeqNum() const; Float_tTProofServ::GetRealTime() const; static Long_tTProofServ::GetResMemMax(); const char*TProofServ::GetService() const; const char*TProofServ::GetSessionDir() const; const char*TProofServ::GetSessionTag() const; TSignalHandler*TApplication::GetSignalHandler() const; TSocket*TProofServ::GetSocket() const; virtual const char*TObject::GetTitle() const; const char*TProofServ::GetTopSessionTag() const; Int_tTProofServ::GetTotSessions() const; virtual UInt_tTObject::GetUniqueID() const; const char*TProofServ::GetUser() const; static Long_tTProofServ::GetVirtMemMax(); const char*TProofServ::GetWorkDir() const; virtual TProofServ::EQueryActionGetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); virtual Bool_tHandleError(const void* in = 0); virtual voidTProofServ::HandleException(Int_t sig); virtual voidTApplication::HandleIdleTimer()SIGNAL ; virtual Bool_tHandleInput(const void* in = 0); virtual voidHandleSigPipe(); virtual voidTProofServ::HandleSocketInput(); virtual Int_tTProofServ::HandleSocketInput(TMessage* mess, Bool_t all); virtual voidHandleTermination(); virtual Bool_tTApplication::HandleTermInput(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual voidHandleUrgentData(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTApplication::Hide(); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTApplication::Iconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofServ.html:7567,resume,resume,7567,root/html534/TXProofServ.html,https://root.cern,https://root.cern/root/html534/TXProofServ.html,3,['resume'],['resume']
Usability,"ogger &ml)Definition MsgLogger.h:148; Remark: in batch mode, the progress bar is quite ugly; you may want to use the text output then; Note that by default in TMVA::Config the drawing of the progress bar is switched off. To have the progress bar visible you need to enable it by calling TMVA::gConfig().SetDrawProgressBar(true) ; Definition at line 58 of file Timer.h. Public Member Functions;  Timer (const char *prefix="""", Bool_t colourfulOutput=kTRUE);  constructor ;  ;  Timer (Int_t ncounts, const char *prefix="""", Bool_t colourfulOutput=kTRUE);  standard constructor: ncounts gives the total number of counts that the loop will iterate through. ;  ; virtual ~Timer (void);  destructor ;  ; void DrawProgressBar (Int_t, const TString &comment="""");  draws progress bar in color or B&W caution: ;  ; void DrawProgressBar (TString);  draws a string in the progress bar ;  ; void DrawProgressBar (void);  draws the progressbar ;  ; Double_t ElapsedSeconds (void);  computes elapsed tim in seconds ;  ; TString GetElapsedTime (Bool_t Scientific=kTRUE);  returns pretty string with elapsed time ;  ; TString GetLeftTime (Int_t icounts);  returns pretty string with time left ;  ; void Init (Int_t ncounts);  ; virtual TClass * IsA () const;  ; void Reset (void);  resets timer ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TStopwatch;  TStopwatch ();  Create a stopwatch and start it. ;  ; void Continue ();  Resume a stopped stopwatch. ;  ; Int_t Counter () const;  ; Double_t CpuTime ();  Stop the stopwatch (if it is running) and return the cputime (in seconds) passed between the start and stop events. ;  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print the real and cpu time passed between the start and stop events. ;  ; Double_t RealTime ();  Stop the stopwatch (if it is running) and return the realtime (in s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Timer.html:1912,progress bar,progress bar,1912,doc/master/classTMVA_1_1Timer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Timer.html,2,['progress bar'],['progress bar']
Usability,"ogger.h:57; TMVA::PDFPDF wrapper for histograms; uses user-defined spline interpolation.Definition PDF.h:63; TMVA::PDF::GetXminDouble_t GetXmin() constDefinition PDF.h:104; TMVA::PDF::GetXmaxDouble_t GetXmax() constDefinition PDF.h:105; TMVA::PDF::GetValDouble_t GetVal(Double_t x) constreturns value PDF(x)Definition PDF.cxx:701; TMVA::ToolsGlobal auxiliary applications and data treatment routines.Definition Tools.h:76; TMVA::Tools::ComputeStatvoid ComputeStat(const std::vector< TMVA::Event * > &, std::vector< Float_t > *, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, Bool_t norm=kFALSE)sanity checkDefinition Tools.cxx:202; TMVA::Tools::GetParentvoid * GetParent(void *child)get parent nodeDefinition Tools.cxx:1140; TMVA::Tools::FormattedOutputvoid FormattedOutput(const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"")formatted output of simple tableDefinition Tools.cxx:887; TMVA::Tools::HistoHasEquidistantBinsBool_t HistoHasEquidistantBins(const TH1 &h)Definition Tools.cxx:1486; TMVA::Tools::ParseFormatLineTList * ParseFormatLine(TString theString, const char *sep="":"")Parse the string and cut into labels separated by "":"".Definition Tools.cxx:401; TMVA::Tools::NormVariableDouble_t NormVariable(Double_t x, Double_t xmin, Double_t xmax)normalise to output range: [-1, 1]Definition Tools.cxx:110; TMVA::Tools::WriteFloatArbitraryPrecisionvoid WriteFloatArbitraryPrecision(Float_t val, std::ostream &os)writes a float value with the available precision to a streamDefinition Tools.cxx:1058; TMVA::Tools::GetYTitleWithUnitTString GetYTitleWithUnit(const TH1 &h, const TString &unit, Bool_t normalised)histogramming utilityDefinition Tools.cxx:1048; TMVA::Tools::GetSeparationDouble_t GetSeparation(TH1 *S, TH1 *B) constcompute ""separation"" defined asDefinition Tools.cxx:121; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:72806,simpl,simple,72806,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['simpl'],['simple']
Usability,"ogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action with new redo arguments; inheritied from compressed command. More complicated commands might want to override this function. Bool_t IsEqual(const TObject* obj) const; Equal comparison. The commands are equal if they are; applied to the same object and have the same Redo/Undo actions. More complicated commands might want to override this function. Bool_t IsSetter() const; Returns kTRUE is command if Redo is the same as Undo function; and is the setter action. By default, all functions with names like ""SetXXX"" or ""setXXX""; considered as setters. Another type of setters are Move, Resize operations. More complicated commands might want to override this function. void SetArgs(Int_t narg, ...); Set do/redo and undo parameters. The format is; SetArgs(number_of_params, redo_params, undo_params). Example:; move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position. void SetRedoArgs(Int_t narg, ...); Set redo parameters. The format is; SetRedoArgs(number_of_params, params). Example:; move_command->SetRedoArgs(2, 100, 100);. void SetUndoArgs(Int_t narg, ...); Set undo parameters. The format is; SetUndoArgs(number_of_params, params). Example:; move_command->SetUndoArgs(2, 200, 200);. Bool_t CanRedo() const; Returns kTRUE if Redo action is possible, kFALSE if it's not.; By default, only single sequential redo action is possible. Bool_t CanUndo() const; Returns kTRUE if Undo action is possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:21978,undo,undo,21978,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,6,['undo'],['undo']
Usability,"ogram are only updated, when the Slider is released. This should be activated if the redrawing of the histogram is too time consuming. // ; Definition at line 33 of file TH1Editor.h. Public Member Functions;  TH1Editor (const TGWindow *p=nullptr, Int_t width=140, Int_t height=30, UInt_t options=kChildFrame, Pixel_t back=GetDefaultFrameBackground());  Constructor of histogram attribute GUI. ;  ;  ~TH1Editor () override;  Destructor of TH1 editor. ;  ; Bool_t AcceptModel (TObject *model) override;  Check if object is able to configure with this editor. ;  ; Int_t * Dividers (Int_t n);  Return an array of dividers of n (without the trivial divider n). ;  ; virtual void DoAddB (Bool_t);  Slot connected to the bar Add check box. ;  ; virtual void DoAddBar (Bool_t);  Slot connected to the bar Add check box. ;  ; virtual void DoAddMarker (Bool_t on);  Slot connected to the show markers check box. ;  ; virtual void DoAddSimple (Bool_t on);  Slot connected to fAddSimple check box for drawing a simple histogram without errors (== HIST draw option) in combination with some other draw options. ;  ; virtual void DoApply ();  Slot connected to the Apply button of the Binning tab. ;  ; virtual void DoAxisRange ();  Slot connected to the number entry fields containing the Max/Min value of the x-axis. ;  ; virtual void DoBarOffset ();  Slot connected to the Bar Offset of the Bar Charts. ;  ; virtual void DoBarWidth ();  Slot connected to the Bar Width of the Bar Charts. ;  ; virtual void DoBinLabel ();  Slot connected to the Bin number entry of the Rebinning tab. ;  ; virtual void DoBinLabel1 ();  Slot connected to the Bin number entry of the Rebinning tab. ;  ; virtual void DoBinMoved (Int_t number);  Slot connected to the rebin slider in case of a not ntuple histogram (does the Rebinning of the histogram). ;  ; virtual void DoBinMoved1 ();  Slot connected to the rebin slider in case of an ntuple histogram. ;  ; virtual void DoBinOffset ();  Slot connected to the OffSetNumberEntry ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1Editor.html:4769,simpl,simple,4769,doc/master/classTH1Editor.html,https://root.cern,https://root.cern/doc/master/classTH1Editor.html,1,['simpl'],['simple']
Usability,"ogram fitting option, WIDTH to fit directly density. The bin content in this case is scaled by the histogram bin width. TFormula. Fix several bugs in the new TFormula class.; Add as new pre-defined functions: crystalball, breitwigner and cheb0,cheb1,...cheb10 for the Chebyshev polynomials. Math Libraries; Random numbers. Move from MathMore to MathCore the class ROOT::Math::Random. Make it a new interface class for random number generation. Add interfaces for standard ROOT random engines, GSL random engines and random engines provided by the C++ standard library (std::random).; Add a new randomengine, MIXMAX based on matrix-recursive random number generator from Kostas and George Savvidy. See this paper. R Interface; Apply several improvements in the interface to R, allowing to use R functions within ROOT. See more at the ROOT-R User Guide.; TMVA; Add new TMVA plug-in based on R and Python (using Scikit-Learn) * See the RMVA Web page for a detailed description of the new TMVA method based on R * See the PyMVA Web page for detailed description of the machine learning methods added in TMVA and based on the Python Scikit-Learn package.; RooFit Libraries; 2D Graphics Libraries; THistPainter; Improve the algorithm to compute the lower limit of an axis in log scale when its real lower limit is 0. The problem was reported in ROOT-7414.; Using the COL option with histograms having some negative bins; the empty bins (containing 0) are drawn. In some cases one wants to not draw empty bins (containing 0) of histograms having a negative minimum. The option 1, used with the option COL, allows to do that.; Implement the Log option for CANDLE plots as requested here.; TTeXDump; From Dmitry Kalinkin (via github): Fix file corruption in TTeXDump::DrawPolyMarker The current implementation of TTeXDump uses TVirtualPS::PrintFast based methods to output TeX markup with automatic line-wraps. Yet these methods are optimized for PostScript format where there are a lot of space characters th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:14329,learn,learning,14329,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['learn'],['learning']
Usability,"ogram from a parametric function ;  FirstContour.C Make a contour plot and get the first contour in a TPolyMarker ;  h1draw.C 1-D histogram drawing options ;  h2proj.C;  hbars.C Example of bar charts with 1-d histograms ;  histpalettecolor.C Palette coloring for histogram is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  hksimple.C Illustrates the advantages of a TH1K histogram ;  hlabels1.C 1-D histograms with alphanumeric labels ;  hlabels2.C 2-D histograms with alphanumeric labels ;  hstack.C Example of stacked histograms: class THStack ;  hsum.C Histograms filled and drawn in a loop ;  hsumTimer.C Demo of Timers ;  logscales.C Draw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot1.py Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot2.py Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot3.py Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot5.py Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C Example showing a fit residual plot, where the separation margin has been set to 0 ;  ratioplot6.py Exa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:123265,simpl,simple,123265,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,"ogram->GetYaxis()->GetNdivisions();; 3634 ; 3635 delete fHistogram;; 3636 fHistogram = nullptr;; 3637 GetHistogram();; 3638 ; 3639 fHistogram->GetXaxis()->SetTitle(XAxisTitle.Data());; 3640 fHistogram->GetYaxis()->SetTitle(YAxisTitle.Data());; 3641 fHistogram->GetXaxis()->SetLabelColor(XLabCol);; 3642 fHistogram->GetYaxis()->SetLabelColor(YLabCol);; 3643 fHistogram->GetXaxis()->SetLabelFont(XLabFont);; 3644 fHistogram->GetYaxis()->SetLabelFont(YLabFont);; 3645 fHistogram->GetXaxis()->SetLabelOffset(XLabOffset);; 3646 fHistogram->GetYaxis()->SetLabelOffset(YLabOffset);; 3647 fHistogram->GetXaxis()->SetLabelSize(XLabSize);; 3648 fHistogram->GetYaxis()->SetLabelSize(YLabSize);; 3649 fHistogram->GetXaxis()->SetNdivisions(XNdiv);; 3650 fHistogram->GetYaxis()->SetNdivisions(YNdiv);; 3651 }; 3652 if (!fIntegral.empty()) {; 3653 fIntegral.clear();; 3654 fAlpha.clear();; 3655 fBeta.clear();; 3656 fGamma.clear();; 3657 }; 3658 if (fNormalized) {; 3659 // need to compute the integral of the not-normalized function; 3660 fNormalized = false;; 3661 fNormIntegral = Integral(fXmin, fXmax, 0.0);; 3662 fNormalized = true;; 3663 } else; 3664 fNormIntegral = 0;; 3665 ; 3666 // std::vector<double>x(fNdim);; 3667 // if ((fType == 1) && !fFunctor->Empty()) (*fFunctor)x.data(), (Double_t*)fParams);; 3668 if (fType == EFType::kCompositionFcn && fComposition) {; 3669 // double-check that the parameters are correct; 3670 fComposition->SetParameters(GetParameters());; 3671 ; 3672 fComposition->Update(); // should not be necessary, but just to be safe; 3673 }; 3674}; 3675 ; 3676////////////////////////////////////////////////////////////////////////////////; 3677/// Static function to set the global flag to reject points; 3678/// the fgRejectPoint global flag is tested by all fit functions; 3679/// if TRUE the point is not included in the fit.; 3680/// This flag can be set by a user in a fitting function.; 3681/// The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions.; 3682 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:139378,clear,clear,139378,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['clear'],['clear']
Usability,"ogzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==1) Hoption.Same += 1;; 4603 goto paintstat;; 4604 }; 4605 if (gridx || gridy) PaintAxis(kTRUE); // Draw the grid only; 4606 ; 4607 // test for options BAR or HBAR; 4608 if (Hoption.Bar >= 10) {; 4609 PaintBar(option);; 4610 }; 4611 ; 4612 // do not draw histogram if error bars required; 4613 if (!Hoption.Error) {; 4614 if (Hoption.Hist && Hoption.Bar<10) PaintHist(option);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:173619,clear,clear,173619,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"oid ); destructor. void CreateMLPOptions(TString ); translates options from option string into TMlpANN language. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; NCycles <integer> Number of training cycles (too many cycles could overtrain the network); HiddenLayers <string> Layout of the hidden layers (nodes per layer); * specifiactions for each hidden layer are separated by commata; * for each layer the number of nodes can be either absolut (simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodTMlpANN.html:17818,learn,learning,17818,root/html528/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodTMlpANN.html,6,['learn'],['learning']
Usability,"oid Copy(TAttLine &attline) constCopy this line attributes to a new TAttLine.Definition TAttLine.cxx:177; TAttLine::DistancetoLineInt_t DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2)Compute distance from point px,py to a line.Definition TAttLine.cxx:211; TAttLine::SaveLineAttributesvirtual void SaveLineAttributes(std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1)Save line attributes as C++ statement(s) on output stream out.Definition TAttLine.cxx:275; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::ReadVersionvirtual Version_t ReadVersion(UInt_t *start=nullptr, UInt_t *bcnt=nullptr, const TClass *cl=nullptr)=0; TBuffer::ReadClassBuffervirtual Int_t ReadClassBuffer(const TClass *cl, void *pointer, const TClass *onfile_class=nullptr)=0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::lsvoid ls(Option_t *option="""") const overrideList this line with its attributes.Definition TLine.cxx:380; TLine::SetY2virtual void SetY2(Double_t y2)Definition TLine.h:68; TLine::Classstatic TClass * Class(); TLine::fY1Double_t fY1Y of 1st point.Definition TLine.h:26; TLine::fX1Double_t fX1X of 1st point.Definition TLine.h:25; TLine::SetX2virtual void SetX2(Double_t x2)Definition TLine.h:66; TLine::kLineNDC@ kLineNDCUse NDC coordinates.Definition TLine.h:33; TLine::kHorizontal@ kHorizontalLine is horizontal.Definition TLine.h:35; TLine::kVertical@ kVerticalLine is vertical.Definition TLine.h:34; TLine::IsVerticalBool_t IsVertical()Check whether this line is to be drawn vertically.Definition TLine.cxx:459; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TLine::SetBBoxY1void SetBB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLine_8cxx_source.html:24776,simpl,simple,24776,doc/master/TLine_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html,1,['simpl'],['simple']
Usability,"oid GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0). Bool_t GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0). void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: Sun Mar 15 16:40:30 2015 » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:20466,clear,clearEmat,20466,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,4,['clear'],['clearEmat']
Usability,"oid SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetRotation(const TGeoMatrix& other); Copy rotation elements from other rotation matrix. void SetAngles(Double_t phi, Double_t theta, Double_t psi); Set matrix elements according to Euler angles. void SetAngles(Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Set matrix elements in the GEANT3 way. void GetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; Retreive rotation angles. void GetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; Retreive Euler angles. Double_t Determinant() const; computes determinant of the rotation matrix. void CheckMatrix(); performes an orthogonality check and finds if the matrix is a reflection; Warning(""CheckMatrix"", ""orthogonality check not performed yet"");. void GetInverse(Double_t* invmat) const; Get the inverse rotation matrix (which is simply the transpose). void MultiplyBy(TGeoRotation* rot, Bool_t after = kTRUE); Multiply this rotation with the one specified by ROT.; - after=TRUE (default): THIS*ROT; - after=FALSE : ROT*THIS. TGeoMatrix& operator=(const TGeoMatrix& matrix); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void LocalToMasterBomb(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void MasterToLocalBomb(const Double_t* master, Double_t* local) const. TGeoTranslation& operator=(const TGeoMatrix& matrix). virtual ~TGeoRotation(); {}. void SetMatrix(const Double_t* rot); {memcpy(&fRotationMatrix[0], rot, 9*sizeof(Double_t));CheckMatrix();}. » Author: Andrei Gheata 25/10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoRotation.html:18863,simpl,simply,18863,root/html528/TGeoRotation.html,https://root.cern,https://root.cern/root/html528/TGeoRotation.html,6,['simpl'],['simply']
Usability,"oid SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj); Low statistic histograms need a special treatment when using autobin. Bool_t HistoSameAxis(TH1* h0, TH1* h1); Return kTRUE is the histograms 'h0' and 'h1' have the same binning and ranges; on the axis (i.e. if they can be just Add-ed for merging). void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of feedback objects. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet for specified slave. Bool_t IsClient() const; Is the player running on the client?. Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (support for TChain::Draw()).; Returns -1 in case of error or number of selected events in case of success. void SetInitTime(); Set init time. TVirtualPacketizer * GetPacketizer() const; { return 0; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayerRemote.html:19178,feedback,feedback,19178,root/html530/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html530/TProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"oid TLeafG::FillBasket ; (; TBuffer & ; b). overridevirtual . Pack leaf elements in Basket output buffer. ; Reimplemented from TLeaf.; Definition at line 78 of file TLeafG.cxx. ◆ GetDeserializeType(). DeserializeType TLeafG::GetDeserializeType ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 42 of file TLeafG.h. ◆ GetMaximum(). Int_t TLeafG::GetMaximum ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 44 of file TLeafG.h. ◆ GetMinimum(). Int_t TLeafG::GetMinimum ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 45 of file TLeafG.h. ◆ GetTypeName(). const char * TLeafG::GetTypeName ; (; ); const. overridevirtual . Returns name of leaf type. ; Reimplemented from TLeaf.; Definition at line 96 of file TLeafG.cxx. ◆ GetValue(). Double_t TLeafG::GetValue ; (; Int_t ; i = 0); const. overridevirtual . Returns current value of leaf. . if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned . Reimplemented from TLeaf.; Definition at line 107 of file TLeafG.cxx. ◆ GetValueLong64(). Long64_t TLeafG::GetValueLong64 ; (; Int_t ; i = 0); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 66 of file TLeafG.h. ◆ GetValueLongDouble(). LongDouble_t TLeafG::GetValueLongDouble ; (; Int_t ; i = 0); const. overridevirtual . Returns current value of leaf. . if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned . Reimplemented from TLeaf.; Definition at line 118 of file TLeafG.cxx. ◆ GetValuePointer(). void * TLeafG::GetValuePointer ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 49 of file TLeafG.h. ◆ Import(). void TLeafG::Import ; (; TClonesArray * ; list, . Int_t ; n . ). overridevirtual . Import element from ClonesArray into local leaf buffer. ; Reimplemented from TLeaf.; Definition at line 143 of file TLeaf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafG.html:19243,simpl,simple,19243,doc/master/classTLeafG.html,https://root.cern,https://root.cern/doc/master/classTLeafG.html,1,['simpl'],['simple']
Usability,"oid TLeafI::FillBasket ; (; TBuffer & ; b). overridevirtual . Pack leaf elements in Basket output buffer. ; Reimplemented from TLeaf.; Definition at line 78 of file TLeafI.cxx. ◆ GetDeserializeType(). DeserializeType TLeafI::GetDeserializeType ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 42 of file TLeafI.h. ◆ GetMaximum(). Int_t TLeafI::GetMaximum ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 44 of file TLeafI.h. ◆ GetMinimum(). Int_t TLeafI::GetMinimum ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 45 of file TLeafI.h. ◆ GetTypeName(). const char * TLeafI::GetTypeName ; (; ); const. overridevirtual . Returns name of leaf type. ; Reimplemented from TLeaf.; Definition at line 96 of file TLeafI.cxx. ◆ GetValue(). Double_t TLeafI::GetValue ; (; Int_t ; i = 0); const. overridevirtual . Returns current value of leaf. . if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned . Reimplemented from TLeaf.; Definition at line 107 of file TLeafI.cxx. ◆ GetValuePointer(). void * TLeafI::GetValuePointer ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 47 of file TLeafI.h. ◆ Import(). void TLeafI::Import ; (; TClonesArray * ; list, . Int_t ; n . ). overridevirtual . Import element from ClonesArray into local leaf buffer. ; Reimplemented from TLeaf.; Definition at line 132 of file TLeafI.cxx. ◆ IncludeRange(). bool TLeafI::IncludeRange ; (; TLeaf * ; input). overridevirtual . Copy/set fMinimum and fMaximum to include/be wide than those of the parameter. ; Reimplemented from TLeaf.; Definition at line 116 of file TLeafI.cxx. ◆ IsA(). TClass * TLeafI::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TLeaf.; Definition at line 59 of file TLeafI.h. ◆ PrintValue(). void TLeafI::PrintValue ; (; Int_t ; i = 0); const. overridev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafI.html:19191,simpl,simple,19191,doc/master/classTLeafI.html,https://root.cern,https://root.cern/doc/master/classTLeafI.html,1,['simpl'],['simple']
Usability,"oid TLeafL::FillBasket ; (; TBuffer & ; b). overridevirtual . Pack leaf elements in Basket output buffer. ; Reimplemented from TLeaf.; Definition at line 78 of file TLeafL.cxx. ◆ GetDeserializeType(). DeserializeType TLeafL::GetDeserializeType ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 42 of file TLeafL.h. ◆ GetMaximum(). Int_t TLeafL::GetMaximum ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 44 of file TLeafL.h. ◆ GetMinimum(). Int_t TLeafL::GetMinimum ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 45 of file TLeafL.h. ◆ GetTypeName(). const char * TLeafL::GetTypeName ; (; ); const. overridevirtual . Returns name of leaf type. ; Reimplemented from TLeaf.; Definition at line 96 of file TLeafL.cxx. ◆ GetValue(). Double_t TLeafL::GetValue ; (; Int_t ; i = 0); const. overridevirtual . Returns current value of leaf. . if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned . Reimplemented from TLeaf.; Definition at line 107 of file TLeafL.cxx. ◆ GetValueLong64(). Long64_t TLeafL::GetValueLong64 ; (; Int_t ; i = 0); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 66 of file TLeafL.h. ◆ GetValueLongDouble(). LongDouble_t TLeafL::GetValueLongDouble ; (; Int_t ; i = 0); const. overridevirtual . Returns current value of leaf. . if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned . Reimplemented from TLeaf.; Definition at line 118 of file TLeafL.cxx. ◆ GetValuePointer(). void * TLeafL::GetValuePointer ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 49 of file TLeafL.h. ◆ Import(). void TLeafL::Import ; (; TClonesArray * ; list, . Int_t ; n . ). overridevirtual . Import element from ClonesArray into local leaf buffer. ; Reimplemented from TLeaf.; Definition at line 143 of file TLeaf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafL.html:19255,simpl,simple,19255,doc/master/classTLeafL.html,https://root.cern,https://root.cern/doc/master/classTLeafL.html,1,['simpl'],['simple']
Usability,"oid TLeafS::FillBasket ; (; TBuffer & ; b). overridevirtual . Pack leaf elements in Basket output buffer. ; Reimplemented from TLeaf.; Definition at line 74 of file TLeafS.cxx. ◆ GetDeserializeType(). DeserializeType TLeafS::GetDeserializeType ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 41 of file TLeafS.h. ◆ GetMaximum(). Int_t TLeafS::GetMaximum ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 42 of file TLeafS.h. ◆ GetMinimum(). Int_t TLeafS::GetMinimum ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 43 of file TLeafS.h. ◆ GetTypeName(). const char * TLeafS::GetTypeName ; (; ); const. overridevirtual . Returns name of leaf type. ; Reimplemented from TLeaf.; Definition at line 92 of file TLeafS.cxx. ◆ GetValue(). Double_t TLeafS::GetValue ; (; Int_t ; i = 0); const. overridevirtual . Returns current value of leaf. . if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned . Reimplemented from TLeaf.; Definition at line 103 of file TLeafS.cxx. ◆ GetValuePointer(). void * TLeafS::GetValuePointer ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 46 of file TLeafS.h. ◆ Import(). void TLeafS::Import ; (; TClonesArray * ; list, . Int_t ; n . ). overridevirtual . Import element from ClonesArray into local leaf buffer. ; Reimplemented from TLeaf.; Definition at line 128 of file TLeafS.cxx. ◆ IncludeRange(). bool TLeafS::IncludeRange ; (; TLeaf * ; input). overridevirtual . Copy/set fMinimum and fMaximum to include/be wide than those of the parameter. ; Reimplemented from TLeaf.; Definition at line 112 of file TLeafS.cxx. ◆ IsA(). TClass * TLeafS::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TLeaf.; Definition at line 58 of file TLeafS.h. ◆ PrintValue(). void TLeafS::PrintValue ; (; Int_t ; i = 0); const. overridev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafS.html:19216,simpl,simple,19216,doc/master/classTLeafS.html,https://root.cern,https://root.cern/doc/master/classTLeafS.html,1,['simpl'],['simple']
Usability,"oid* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofProgressStatus&operator+=(const TProofProgressStatus& st); TProofProgressStatusoperator-(TProofProgressStatus& st); TProofProgressStatus&operator-=(const TProofProgressStatus& st); TProofProgressStatus&operator=(const TProofProgressStatus&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBytesRead(Long64_t bytesRead); voidSetCPUTime(Double_t procTime); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEntries(Long64_t entries); voidSetLastEntries(Long64_t entries); voidSetLastProcTime(Double_t procTime); voidSetLastUpdate(Double_t updtTime = 0); voidSetLearnTime(Double_t learnTime); static voidTObject::SetObjectStat(Bool_t stat); voidSetProcTime(Double_t procTime); voidSetReadCalls(Long64_t readCalls); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressStatus.html:5067,learn,learnTime,5067,root/html528/TProofProgressStatus.html,https://root.cern,https://root.cern/root/html528/TProofProgressStatus.html,1,['learn'],['learnTime']
Usability,"oid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:21879,simpl,simple,21879,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,6,['simpl'],['simple']
Usability,"oidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Roo2DKeysPdf.html:2529,clear,clearEvalError,2529,root/html526/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html526/Roo2DKeysPdf.html,1,['clear'],['clearEvalError']
Usability,"oidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealSumPdf.html:3142,clear,clearEvalError,3142,root/html528/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html528/RooRealSumPdf.html,1,['clear'],['clearEvalError']
Usability,"oidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddPdf.html:3814,clear,clearEvalError,3814,root/html528/RooAddPdf.html,https://root.cern,https://root.cern/root/html528/RooAddPdf.html,3,['clear'],['clearEvalError']
Usability,"oidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:4260,clear,clearEvalError,4260,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,2,['clear'],['clearEvalError']
Usability,"oiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the TClonesArray has to be reused, the Clear() method is used. To provide its benefits, each TClonesArray must be allocated once per process and disposed of (deleted) only when not needed any more.; So a job should see only one deletion for each TClonesArray, which should be Clear()ed during the job several times. Deleting a TClonesArray is a double waste. Not only you do not avoid memory fragmentation, but you worsen it because the TClonesArray itself is a rather heavy structure, and there is quite some code in the destructor, so you have more memory fragmentation and slower code. NOTE 2; When investigating misuse of TClonesArray, please make sure of the following:. Use Clear() or Clear(""C"") instead of Delete(). This will improve program execution time.; TClonesArray object classes containing pointers allocate memory. To avoid causing memory leaks, special Clear(""C"") must be used for clearing TClonesArray. When option ""C"" is specified, ROOT automatically executes the Clear() method (by default it is empty contained in TObject). This method must be overridden in the relevant TClonesArray object class, implementing the reset procedure for pointer objects.; If the objects are added using the placement new then the Clear must deallocate the memory.; If the objects are added using TClonesArray::ConstructedAt then the heap-based memory can stay allocated and reused as the constructor is not called for already constructed/added object.; To reduce memory fragmentation, please make sure that the TClonesArrays are not destroyed and created on every event. They must only be constructed/destructed at the beginning/end of the run. . Definition at line 29 of file TClonesArray.h. Public Types; enum  EStatusBits { kBypassStreamer = (1ULL << ( 12 )); , kForgetBits = (1ULL << ( 15 )); };  Saved copies of pointers to objects. More...;  ;  Public Types inherited",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:4230,clear,clearing,4230,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['clear'],['clearing']
Usability,"oid Randomize () const;  Randomize the weights. ;  ; Double_t Result (Int_t event, Int_t index=0) const;  Computes the output for a given event. ;  ; void SetData (TTree *);  Set the data source. ;  ; void SetDelta (Double_t delta);  Sets Delta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEpsilon (Double_t eps);  Sets Epsilon - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEta (Double_t eta);  Sets Eta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEtaDecay (Double_t ed);  Sets EtaDecay - Eta *= EtaDecay at each epoch (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEventWeight (const char *);  Set the event weight. ;  ; void SetLearningMethod (TMultiLayerPerceptron::ELearningMethod method);  Sets the learning method. ;  ; void SetReset (Int_t reset);  Sets number of epochs between two resets of the search direction to the steepest descent. ;  ; void SetTau (Double_t tau);  Sets Tau - used in line search (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetTestDataSet (const char *test);  Sets the Test dataset. ;  ; void SetTestDataSet (TEventList *test);  Sets the Test dataset. ;  ; void SetTrainingDataSet (const char *train);  Sets the Training dataset. ;  ; void SetTrainingDataSet (TEventList *train);  Sets the Training dataset. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Train (Int_t nEpoch, Option_t *option=""text"", Double_t minE=0);  Train the network. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:14120,learn,learning,14120,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['learn'],['learning']
Usability,"oid SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool canComputeBatchWithCuda () const override;  ; void doEval (RooFit::EvalContext &) const override;  Evaluate in batch mode. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRatio.html:47949,simpl,simple,47949,doc/master/classRooRatio.html,https://root.cern,https://root.cern/doc/master/classRooRatio.html,1,['simpl'],['simple']
Usability,"oisson background/ Gauss Efficiency. ;  ; Double_t EvalLikeMod3 (Double_t mu, Int_t x, Double_t bm, Double_t em, Double_t sde, Double_t sdb, Int_t what);  Calculates the Profile Likelihood for MODEL 3: Gauss background/ Gauss Efficiency. ;  ; Double_t EvalLikeMod4 (Double_t mu, Int_t x, Int_t y, Double_t tau, Int_t what);  Calculates the Profile Likelihood for MODEL 4: Poiss background/Efficiency known. ;  ; Double_t EvalLikeMod5 (Double_t mu, Int_t x, Double_t bm, Double_t sdb, Int_t what);  Calculates the Profile Likelihood for MODEL 5: Gauss background/Efficiency known. ;  ; Double_t EvalLikeMod6 (Double_t mu, Int_t x, Int_t z, Double_t b, Int_t m, Int_t what);  Calculates the Profile Likelihood for MODEL 6: Background known/Efficiency binomial. ;  ; Double_t EvalLikeMod7 (Double_t mu, Int_t x, Double_t em, Double_t sde, Double_t b, Int_t what);  Calculates the Profile Likelihood for MODEL 7: background known/Efficiency Gauss. ;  ; Double_t GetBackground ();  Return a simple background value (estimate/truth) given the pre-specified model. ;  ; Double_t Interval (Int_t x, Int_t y, Int_t z, Double_t bm, Double_t em, Double_t e, Int_t mid, Double_t sde, Double_t sdb, Double_t tau, Double_t b, Int_t m);  Internal helper function 'Interval'. ;  ; Double_t LikeGradMod1 (Double_t e, Double_t mu, Int_t x, Int_t y, Int_t z, Double_t tau, Int_t m);  Gradient model likelihood. ;  ; Double_t Likelihood (Double_t mu, Int_t x, Int_t y, Int_t z, Double_t bm, Double_t em, Int_t mid, Double_t sde, Double_t sdb, Double_t tau, Double_t b, Int_t m, Int_t what);  Internal helper function Chooses between the different profile likelihood functions to use for the different models. ;  ; Double_t LikeMod1 (Double_t mu, Double_t b, Double_t e, Int_t x, Int_t y, Int_t z, Double_t tau, Int_t m);  Profile Likelihood function for MODEL 1: Poisson background/ Binomial Efficiency. ;  ; Double_t LikeMod2 (Double_t mu, Double_t b, Double_t e, Int_t x, Int_t y, Double_t em, Double_t tau, Double_t v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRolke.html:18514,simpl,simple,18514,doc/master/classTRolke.html,https://root.cern,https://root.cern/doc/master/classTRolke.html,1,['simpl'],['simple']
Usability,"ol_t IsEqual(const TObject* obj) const; Equal comparison. The commands are equal if they are; applied to the same object and have the same Redo/Undo actions. More complicated commands might want to override this function. Bool_t IsSetter() const; Returns kTRUE is command if Redo is the same as Undo function; and is the setter action. By default, all functions with names like ""SetXXX"" or ""setXXX""; considered as setters. Another type of setters are Move, Resize operations. More complicated commands might want to override this function. void SetArgs(Int_t narg, ...); Set do/redo and undo parameters. The format is; SetArgs(number_of_params, redo_params, undo_params). Example:; move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position. void SetRedoArgs(Int_t narg, ...); Set redo parameters. The format is; SetRedoArgs(number_of_params, params). Example:; move_command->SetRedoArgs(2, 100, 100);. void SetUndoArgs(Int_t narg, ...); Set undo parameters. The format is; SetUndoArgs(number_of_params, params). Example:; move_command->SetUndoArgs(2, 200, 200);. Bool_t CanRedo() const; Returns kTRUE if Redo action is possible, kFALSE if it's not.; By default, only single sequential redo action is possible. Bool_t CanUndo() const; Returns kTRUE if Undo action is possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:22193,undo,undo,22193,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,6,['undo'],['undo']
Usability,"ol_t clearHist = kTRUE) const; voidTUnfold::GetBias(TH1* bias, const Int_t* binMap = 0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; voidTUnfold::GetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; voidTUnfold::GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tTUnfold::GetNpar() const; Int_tTUnfold::GetNr() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:6277,clear,clearEmat,6277,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,3,['clear'],['clearEmat']
Usability,"ol_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFFTConvPdf.html:7364,clear,clearValueDirty,7364,root/html528/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html528/RooFFTConvPdf.html,1,['clear'],['clearValueDirty']
Usability,"ol_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFFTConvPdf.html:7364,clear,clearValueDirty,7364,root/html530/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html530/RooFFTConvPdf.html,1,['clear'],['clearValueDirty']
Usability,"ol_t nodel = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 406 ; 407 if (!nodel && IsOwner()) {; 408 Delete(option);; 409 return;; 410 }; 411 ; 412 // In some case, for example TParallelCoord, a list (the pad's list of; 413 // primitives) will contain both the container and the containees; 414 // (the TParallelCoordVar) but if the Clear is being called from; 415 // the destructor of the container of this list, one of the first; 416 // thing done will be the remove the container (the pad) for the; 417 // list (of Primitives of the canvas) that was connecting it; 418 // (indirectly) to the list of cleanups.; 419 // Note: The Code in TParallelCoordVar was changed (circa June 2017),; 420 // to no longer have this behavior and thus rely on this code (by moving; 421 // from using Draw to Paint) but the structure might still exist elsewhere; 422 // so we keep this comment here.; 423 ; 424 // To preserve this connection (without introducing one when there was none),; 425 // we re-use fCache to inform RecursiveRemove of the node currently; 426 // being cleared/deleted.; 427 while (fFirst) {; 428 auto tlk = fFirst;; 429 fFirst = fFirst->fNext;; 430 fSize--;; 431 ; 432 ; 433 // Make node available to RecursiveRemove; 434 tlk->fNext.reset();; 435 tlk->fPrev.reset();; 436 fCache = tlk;; 437 ; 438 // delete only heap objects marked OK to clear; 439 auto obj = tlk->GetObject();; 440 if (!nodel && obj) {; 441 if (ROOT::Detail::HasBeenDeleted(obj)) {; 442 Error(""Clear"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 443 obj, GetName());; 444 } else if (obj->IsOnHeap()) {; 445 if (obj->TestBit(kCanDelete)) {; 446 if (!ROOT::Detail::HasBeenDeleted(obj)) {; 447 TCollection::GarbageCollect(obj);; 448 }; 449 }; 450 }; 451 }; 452 // delete tlk;; 453 }; 454 fFirst.reset();; 455 fLast.reset();; 456 fCache.reset();; 457 fSize = 0;; 458 Changed();; 459}; 460 ; 461////////////////////////////////////////////////////////////////////////////////; 462/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:13094,clear,cleared,13094,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['clear'],['cleared']
Usability,"ol_t stat); virtual Int_tSetParent(const TObject* parent, Int_t branchID); static voidSetRefTable(TRefTable* table); virtual voidSetUID(UInt_t uid, TProcessID* context = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Int_tAddInternalIdxForPID(TProcessID* procid); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tExpandForIID(Int_t iid, Int_t newsize); voidExpandPIDs(Int_t numpids); Int_tFindPIDGUID(const char* guid) const; Int_tGetInternalIdxForPID(TProcessID* procid) const; Int_tGetInternalIdxForPID(Int_t pid) const; voidTObject::MakeZombie(). Data Members; public:. enum { kHaveWarnedReadingOld; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fAllocSize![fNumPIDs] allocated size of array fParentIDs for each ProcessID; Int_tfDefaultSize!default size for a new PID array; vector<Int_t>fMapPIDtoInternal! cache of pid to index in fProcessGUIDs; Int_t*fN![fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID; Int_tfNumPIDs!number of known ProcessIDs; TObject*fOwnerObject owning this TRefTable; Int_tfParentID!current parent ID in fParents (latest call to SetParent); Int_t**fParentIDs![fNumP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRefTable.html:6777,guid,guid,6777,root/html528/TRefTable.html,https://root.cern,https://root.cern/root/html528/TRefTable.html,3,['guid'],['guid']
Usability,"ol_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoConeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoConeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifing current parameters. void DoUndo(); Slot for undoing current operation. void DoRmin1(); Slot for Rmin1. void DoRmax1(); Slot for Rmax1. void DoRmin2(); Slot for Rmin2. void DoRmax2(); Slot for Rmax2. void DoDz(); Slot for Dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoConeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoConeEditor.html:21479,undo,undoing,21479,root/html528/TGeoConeEditor.html,https://root.cern,https://root.cern/root/html528/TGeoConeEditor.html,1,['undo'],['undoing']
Usability,"ol_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoConeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoConeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifing current parameters. void DoUndo(); Slot for undoing current operation. void DoRmin1(); Slot for Rmin1. void DoRmax1(); Slot for Rmax1. void DoRmin2(); Slot for Rmin2. void DoRmax2(); Slot for Rmax2. void DoDz(); Slot for Dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoConeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoConeEditor.html:21579,undo,undoing,21579,root/html530/TGeoConeEditor.html,https://root.cern,https://root.cern/root/html530/TGeoConeEditor.html,1,['undo'],['undoing']
Usability,"ol_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoConeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoConeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifing current parameters. void DoUndo(); Slot for undoing current operation. void DoRmin1(); Slot for Rmin1. void DoRmax1(); Slot for Rmax1. void DoRmin2(); Slot for Rmin2. void DoRmax2(); Slot for Rmax2. void DoDz(); Slot for Dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoConeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoConeEditor.html:21579,undo,undoing,21579,root/html532/TGeoConeEditor.html,https://root.cern,https://root.cern/root/html532/TGeoConeEditor.html,1,['undo'],['undoing']
Usability,"olationOrder(). void RooHistFunc::setInterpolationOrder ; (; Int_t ; order). inline . Set histogram interpolation order. ; Definition at line 63 of file RooHistFunc.h. ◆ Streamer(). void RooHistFunc::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class RooHistFunc. ; Reimplemented from RooAbsReal.; Definition at line 516 of file RooHistFunc.cxx. ◆ StreamerNVirtual(). void RooHistFunc::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 135 of file RooHistFunc.h. ◆ totVolume(). double RooHistFunc::totVolume ; (; ); const. Get total bin volume spanned by this hist function. ; Return the total volume spanned by the observables of the RooDataHist.; In 1-d, this is e.g. the range spanned on the x-axis. ; Definition at line 274 of file RooHistFunc.cxx. ◆ translate(). void RooHistFunc::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 193 of file RooHistFunc.cxx. ◆ variables(). RooArgSet const & RooHistFunc::variables ; (; ); const. inline . Definition at line 106 of file RooHistFunc.h. Friends And Related Symbol Documentation. ◆ RooAbsCachedReal. friend class RooAbsCachedReal. friend . Definition at line 115 of file RooHistFunc.h. Member Data Documentation. ◆ _cdfBoundaries. bool RooHistFunc::_cdfBoundaries = false. protected . Use boundary conditions for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:74017,simpl,simple,74017,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['simpl'],['simple']
Usability,"old5c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5d.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold6.C Test program for the class TUnfoldBinning ;  testUnfold7a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  histops.cxx;  histspeedtest.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demonstrates how THtml can document sources ;  MyTasks.cxxA set of classes deriving from TTask ;  regexp.CA regular expression, often called a pattern, is an expression that describes a set of strings ;  regexp_pme.CClass TPMERegexp - API similar to PME - PCRE Made Easy Tries to be as close as possible to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:161004,simpl,simple,161004,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['simpl'],['simple']
Usability,"old; Int_tfPx2old; Int_tfPy1old; Int_tfPy2old. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of histogram attribute GUI. void CreateBinTab(); Create binning tab. ~TH1Editor(); Destructor of TH1 editor. void ConnectSignals2Slots(); Connect signals to slots. Bool_t AcceptModel(TObject* model); Check if object is able to configure with this editor. void SetModel(TObject* obj); Pick up current values of histogram attributes. void DoTitle(const char* text); Slot connected to the histogram title setting. void DoAddMarker(Bool_t on); Slot connected to the show markers check box. void DoAddB(Bool_t ); Slot connected to the bar Add check box. void DoAddBar(Bool_t ); Slot connected to the bar Add check box. void DoAddSimple(Bool_t on); Slot connected to fAddSimple check box for drawing a simple histogram; without errors (== HIST draw option) in combination with some other; draw options. It draws an additional line on the top of the bins. void DoHistView(); Slot connected to the 'Plot' button group. void DoHistSimple(); Slot connected to the 2D radio button. void DoHistComplex(); Slot connected to the 3D radio button. void DoHistChanges(); Slot connected to the histogram type, the coordinate type, the error type; and the Add combo box. void DoBarWidth(); Slot connected to the Bar Width of the Bar Charts. void DoBarOffset(); Slot connected to the Bar Offset of the Bar Charts. void DoPercent(); Slot connected to the bar percentage settings. void DoHBar(Bool_t on); Slot connected to the Horizontal Bar check button. void DoSliderMoved(); Slot connected to the x-Slider for redrawing of the histogram; according to the new Slider range. void DoSliderPressed(); Slot connected to the x-axis Range slider for initialising the; values of the slider movement. void DoSliderReleased(); Slot co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1Editor.html:28702,simpl,simple,28702,root/html528/TH1Editor.html,https://root.cern,https://root.cern/root/html528/TH1Editor.html,6,['simpl'],['simple']
Usability,"oldSys::GetEmatrixSysBackgroundUncorr ; (; TH2 * ; ematrix, . const char * ; source, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background uncorrelated uncertainty ; Parameters. [in]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result arising from the background source source and the uncorrelated (background histogram uncertainties). Also see method SubtractBackground() ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1229 of file TUnfoldSys.cxx. ◆ GetEmatrixSysSource(). void TUnfoldSys::GetEmatrixSysSource ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from a systematic variation of the response matrix ; Parameters. [in,out]ematrixcovariance matrix histogram ; [in]nameidentifier of the systematic variation ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram prior to adding the covariance matrix contribution. Returns the covariance matrix contribution from shifting the given uncertainty source within one sigma ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1113 of file TUnfoldSys.cxx. ◆ GetEmatrixSysTau(). void TUnfoldSys::GetEmatrixSysTau ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from error on regularisation parameter ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:40254,clear,clearEmat,40254,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,"olding TClonesArray instances; It is recommended to use STL containers instead of TClonesArrays*.; // clonesarray is the address of a pointer to a TClonesArray.; auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel); The TClonesArray is a direct access list of objects of the same class. For example, if the TClonesArray is an array of TTrack objects, this function will create one subbranch for each data member of the object TTrack. Fill the Tree; A TTree instance is filled with the invocation of the TTree::Fill method: tree.Fill(); Upon its invocation, a loop on all defined branches takes place that for each branch invokes the TBranch::Fill method. Add a column to an already existing Tree; You may want to add a branch to an existing tree. For example, if one variable in the tree was computed with a certain algorithm, you may want to try another algorithm and compare the results. One solution is to add a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note the kOverwrite option in the Write method, it overwrites the existing tree. If it is not specified, two copies of the tree headers are saved. void tree3AddBranch() {; TFile f(""tree3.root"", ""update"");; ; Float_t new_v;; auto t3 = f->Get<TTree>(""t3"");; auto newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");; ; Long64_t nentries = t3->GetEntries(); // read the number of entries in the t3; ; for (Long64_t i = 0; i < nentries; i++) {; new_v = gRandom->Gaus(0, 1);; newBranch->Fill();; }; ; t3->Write("""", TObject::kOverwrite); // save only the new version of the tree; }; f#define f(i)Definition RSha256.hxx:104; Float_tfloat Float_tDefinition RtypesCore.h:57; Long64_tlong long Long64_tDefinition RtypesCore.h:69; nentriesint nentriesDefinition THbookFile.cxx:91; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TObject::kO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:9548,simpl,simple,9548,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['simpl'],['simple']
Usability,"olding TClonesArray instances; It is recommended to use STL containers instead of TClonesArrays*.; // clonesarray is the address of a pointer to a TClonesArray.; auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel); The TClonesArray is a direct access list of objects of the same class. For example, if the TClonesArray is an array of TTrack objects, this function will create one subbranch for each data member of the object TTrack. Fill the Tree; A TTree instance is filled with the invocation of the TTree::Fill method: tree.Fill(); Upon its invocation, a loop on all defined branches takes place that for each branch invokes the TBranch::Fill method. Add a column to an already existing Tree; You may want to add a branch to an existing tree. For example, if one variable in the tree was computed with a certain algorithm, you may want to try another algorithm and compare the results. One solution is to add a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note the kOverwrite option in the Write method, it overwrites the existing tree. If it is not specified, two copies of the tree headers are saved. void tree3AddBranch() {; TFile f(""tree3.root"", ""update"");; ; Float_t new_v;; auto t3 = f->Get<TTree>(""t3"");; auto newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");; ; Long64_t nentries = t3->GetEntries(); // read the number of entries in the t3; ; for (Long64_t i = 0; i < nentries; i++) {; new_v = gRandom->Gaus(0, 1);; newBranch->Fill();; }; ; t3->Write("""", TObject::kOverwrite); // save only the new version of the tree; }; f#define f(i)Definition RSha256.hxx:104; Float_tfloat Float_tDefinition RtypesCore.h:57; Long64_tlong long Long64_tDefinition RtypesCore.h:80; nentriesint nentriesDefinition THbookFile.cxx:91; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TObject::kO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:9547,simpl,simple,9547,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['simpl'],['simple']
Usability,"oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1011 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:31240,clear,clear,31240,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['clear'],['clear']
Usability,"ollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←. TQUndoManager. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQComman",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:19004,undo,undo,19004,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,4,['undo'],['undo']
Usability,"olons. In addition, input/output layer formulas can be preceded by '@' (e.g ""@out"") if one wants to also normalize the data from the TTree. Input and outputs are taken from the TTree given as second argument. Expressions are evaluated as for TTree::Draw(), arrays are expended in distinct neurons, one for each index. This can only be done for fixed-size arrays. If the formula ends with ""!"", softmax functions are used for the output layer. One defines the training and test datasets by TEventLists.; Example: TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; TMultiLayerPerceptron::TMultiLayerPerceptronTMultiLayerPerceptron()Default constructor.Definition TMultiLayerPerceptron.cxx:264; Both the TTree and the TEventLists can be defined in the constructor, or later with the suited setter method. The lists used for training and test can be defined either explicitly, or via a string containing the formula to be used to define them, exactly as for a TCut.; The learning method is defined using the TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :. TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS. A weight can be assigned to events, either in the constructor, either with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight is taken into account.; Finally, one starts the training with TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The first argument is the number of epochs while option is a string that can contain: ""text"" (simple text output) , ""graph"" (evoluting graphical training curves), ""update=X"" (step for the text/graph output update) or ""+"" (will skip the randomisation and start from the previous values). All combinations are available.; Example: net.Train(100,""text, graph, update=10"");; When the neural net is trained, it can be used directly ( TMultiLayer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:7429,learn,learning,7429,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['learn'],['learning']
Usability,"olor component, cie smooth alorithm, cie modulo color component, yiq smooth alorithm, yiq modulo color component, hsv smooth alorithm, hsv modulo color component, it does not apply for simple display modes algorithm group; Int_tfContWidthwidth between contours, applies only for contours display mode; Int_tfDisplayModespectrum display mode (points, grid, contours, bars, x_lines, y_lines, bars_x, bars_y, needles, surface, triangles); Double_tfDxspline; Double_tfDyspline; Short_t*fEnvelope!; Short_t*fEnvelopeContour!; Double_tfGbezx; Double_tfGbezy; TH2*fH2pointer to 2D histogram TH2; Double_tfKx; Double_tfKy; Double_tfLHweightweight between shading according to fictive light source and according to channels counts, applies only for kModeGroupLightHeight modes group; Int_tfLevels# of color levels for rainbowed display modes, it does not apply for simple display modes algorithm group; Int_tfLine; Int_tfMaximumXScreenResolution!buffers' size; Int_tfModeGroupdisplay mode algorithm group (simple modes-kModeGroupSimple, modes with shading according to light-kModeGroupLight, modes with shading according to channels counts-kModeGroupHeight, modes of combination of shading according to light and to channels counts-kModeGroupLightHeight); Double_tfMxx; Double_tfMxy; Double_tfMyx; Double_tfMyy; TStringTNamed::fNameobject identifier; TColor*fNewColor!; Int_tfNewColorIndex; Int_tfNodesxnumber of nodes in x dimension of grid; Int_tfNodesynumber of nodes in y dimension of grid; Double_tfNuSli; Int_tfPenColorcolor of spectrum; Int_tfPenDashstyle of pen; Int_tfPenWidthwidth of line; Double_tfRainbow1Stepdetermines the first component step for neighbouring color levels, applies only for rainbowed display modes, it does not apply for simple display modes algorithm group; Double_tfRainbow2Stepdetermines the second component step for neighbouring color levels, applies only for rainbowed display modes, it does not apply for simple display modes algorithm group; Double_tfRainbow3Stepdetermin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Painter.html:11215,simpl,simple,11215,root/html528/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Painter.html,6,['simpl'],['simple']
Usability,"olor(kBlue);; 8 lv.DrawLine(0.33,0.0,0.33,1.0);; 9 lv.DrawLine(0.6,0.165,1.,0.165);; 10 lv.DrawLine(0.6,0.493,1.,0.493);; 11 lv.DrawLine(0.6,0.823,1.,0.823);; 12 ; 13 // Horizontal alignment.; 14 auto *th1 = new TText(0.33,0.165,""Left adjusted"");; 15 th1->SetTextAlign(11); th1->SetTextSize(0.12);; 16 th1->Draw();; 17 ; 18 auto *th2 = new TText(0.33,0.493,""Center adjusted"");; 19 th2->SetTextAlign(21); th2->SetTextSize(0.12);; 20 th2->Draw();; 21 ; 22 auto *th3 = new TText(0.33,0.823,""Right adjusted"");; 23 th3->SetTextAlign(31); th3->SetTextSize(0.12);; 24 th3->Draw();; 25 ; 26 // Vertical alignment.; 27 auto *tv1 = new TText(0.66,0.165,""Bottom adjusted"");; 28 tv1->SetTextAlign(11); tv1->SetTextSize(0.12);; 29 tv1->Draw();; 30 ; 31 auto *tv2 = new TText(0.66,0.493,""Center adjusted"");; 32 tv2->SetTextAlign(12); tv2->SetTextSize(0.12);; 33 tv2->Draw();; 34 ; 35 auto *tv3 = new TText(0.66,0.823,""Top adjusted"");; 36 tv3->SetTextAlign(13); tv3->SetTextSize(0.12);; 37 tv3->Draw();; 38}; kBlue@ kBlueDefinition Rtypes.h:66; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TTextBase class for several text objects.Definition TText.h:22; th3auto * th3Definition textalign.C:22; lvTLine lvDefinition textalign.C:5; tv3auto * tv3Definition textalign.C:35; th2auto * th2Definition textalign.C:18; tv1auto * tv1Definition textalign.C:27; tv2auto * tv2Definition textalign.C:31; th1auto * th1Definition textalign.C:14. corebasedocmacrostextalign.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/textalign_8C_source.html:1654,simpl,simple,1654,doc/master/textalign_8C_source.html,https://root.cern,https://root.cern/doc/master/textalign_8C_source.html,1,['simpl'],['simple']
Usability,"olution(); this function is called from ""init"" and controls the evolution of the; individuals.; the function can be overridden to change the parameters for mutation rate; sexual reproduction and so on. Double_t SpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); this function provides the ability to change the stepSize of a mutation according to; the success of the last generations. Parameters:; int ofSteps : = if OF the number of STEPS given in this variable (ofSteps); int successSteps : >sucessSteps Generations could improve the result; double factor : than multiply the stepSize ( spread ) by this factor; (if ofSteps == successSteps nothing is changed, if ofSteps < successSteps, the spread; is divided by the factor). using this function one can increase the stepSize of the mutation when we have; good success (to pass fast through the easy phase-space) and reduce the stepSize; if we are in a difficult ""territory"" of the phase-space. Bool_t HasConverged(Int_t steps = 10, Double_t ratio = 0.1); gives back true if the last ""steps"" steps have lead to an improvement of the; ""fitness"" of the ""individuals"" of at least ""improvement"". this gives a simple measure of if the fitness of the individuals is; converging and no major improvement is to be expected soon. GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0). GeneticPopulation& GetGeneticPopulation(); { return fPopulation; }. Double_t GetSpread() const; { return fSpread; }. void SetSpread(Double_t s); { fSpread = s; }. void SetMakeCopies(Bool_t s); { fMakeCopies = s; }. Bool_t GetMakeCopies(); { return fMakeCopies; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GeneticAlgorithm.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__GeneticAlgorithm.html:5154,simpl,simple,5154,root/html530/TMVA__GeneticAlgorithm.html,https://root.cern,https://root.cern/root/html530/TMVA__GeneticAlgorithm.html,1,['simpl'],['simple']
Usability,"om this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see TFile::SetReadStreamerInfo) ; Definition at line 3605 of file TFile.cxx. ◆ Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2048 of file TFile.cxx. ◆ ReOpen(). Int_t TFile::ReOpen ; (; Option_t * ; mode). virtual . Reopen a file with a different access mode. ; For example, it is possible to change from READ to UPDATE ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:89391,usab,usable,89391,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['usab'],['usable']
Usability,"om->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" the error band is smoothed. Because of the; 715smoothing algorithm used some artefacts may appear at the end of the band; 716like in the following example. In such cases ""E3"" should be used instead; 717of ""E4"".; 718 ; 719Begin_Macro(source); 720{; 721 auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; 722 ce4->Divide(2,1);; 723 auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; 724 Int_t i;; 725 for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; 726 he4->SetFillColor(kRed);; 727 he4->GetXaxis()->SetRange(40,48);; 728 ce4->cd(1);; 729 he4->Draw(""E4"");; 730 ce4->cd(2);; 731 auto he3 = (TH1F*)he4->DrawClone(""E3"");; 732 he3->SetTitle(""Distribution drawn option E3"");; 733}; 734End_Macro; 735 ; 7362D histograms can be drawn with error bars as shown is the following example:; 737 ; 738Begin_Macro(source); 739{; 740 auto c2e = new TCanvas(""c2e"",""c2e"",600,400);; 741 auto h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; 742 float px, py;; 743 for (Int_t i = 0; i < 25000; i++) {; 744 gRandom->Rannor(px,py);; 745 h2e->Fill(px,5*py);; 746 }; 747 h2e->Draw(""E"");; 748}; 749End_Macro; 750 ; 751 ; 752\anchor HP100; 753### The bar chart option; 754 ; 755 ; 756The option ""B"" allows to draw simple vertical bar charts.; 757The bar width is controlled with `TH1::SetBarWidth()`,; 758and the bar offset within the bin, with `TH1::SetBarOffset()`.; 759These two settings are useful to draw several histograms on the; 760same plot as shown in the following example:; 761 ; 762Begin_Macro(source); 763{; 764 int i;; 765 const Int_t nx = 8;; 766 string os_X[nx] = {""8"",""32"",""128"",""512"",""2048"",""8192"",""32768"",""131072""};; 767 float d_35_0[nx] = {0.75, -3.30, -0.92, 0.10, 0.08, -1.69, -1.29, -2.37};; 76",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:32781,simpl,simple,32781,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['simpl'],['simple']
Usability,"ome classes where equality is already achieved if some or all of the data members are equal. By overriding the following TObject member functions, you can change the behavior of objects in collections:. IsEqual()is used by the FindObject()collection method. By default, IsEqual() compares the two object pointers.; Compare()returns -1, 0 or 1 depending if the object is smaller, equal or larger than the other object. By default, a TObject has not a valid Compare() method.; IsSortable()returns true if the class is sort able (i.e. if it has a valid Compare() method). By default, a TObject is not sort able.; Hash()returns a hash value. It needs to be implemented if an object has to be stored in a collection using a hashing technique, like THashTable, THashList and TMap. By default, Hash() returns the address of the object. It is essential to choose a good hash function. The example below shows how to use and override these member functions.; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; 16.5 The TIter Generic Iterator; As stated above, the TIterator class is abstract; it is not possible to create TIterator objects. However, it should be possible to write generic code to process all members of a collection so there is a need for a generic iterator object. A TIter object acts as generic iterator. It provides the same Next() and Reset() methods as TIterator although it has no idea how to support them! It works as fol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:848178,simpl,simple,848178,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"ommands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);; ...; During Redo operation commands composing macro command are executed sequentially in direct order (first in first out). During Undo, they are executed in reverse order (last in first out).; Undo manager. TQUndoManager is recorder of undo and redo operations. This is command history list which can be traversed backwards and upwards performing undo and redo operations. To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);; TQCommand::TQUndoManagerfriend class TQUndoManagerDefinition TQCommand.h:29; TQUndoManagerRecorder of operations for undo and redo.Definition TQCommand.h:103; TQUndoManager::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the stack of commands.Definition TQCommand.cxx:959; TQUndoManager::Add automatically invokes execution of command's Redo method. Use TQUndoManager::Undo to undo commands in history list. Redo is Undo for undo action. Use TQUndoManager::Redo method for that ; Definition at line 27 of file TQCommand.h. Public Member Functions;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; void Add (TObject *obj) override;  ; void Add (TObject *obj, Option_t *opt) override;  Add command to the list of merged commands. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual Bool_t CanRedo () const;  Returns kTRUE if Redo action is possible, kFALSE if it's not. ;  ; virtual Bool_t CanUndo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:4535,undo,undo,4535,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"ommands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQCommand & operator=(const TQCommand& ). TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:48; This page has been automatically generated. For comments or sugges",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQCommand.html:23963,undo,undo,23963,root/html534/TQCommand.html,https://root.cern,https://root.cern/root/html534/TQCommand.html,1,['undo'],['undo']
Usability,"ommands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQCommand & operator=(const TQCommand& ). TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:31; This page has been automatically generated. For comments or sugges",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQCommand.html:24703,undo,undo,24703,root/html604/TQCommand.html,https://root.cern,https://root.cern/root/html604/TQCommand.html,1,['undo'],['undo']
Usability,"ommands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQCommand & operator=(const TQCommand& ). TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:28; This page has been automatically generated. For comments or sugges",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:24703,undo,undo,24703,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,1,['undo'],['undo']
Usability,"ommands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 25128 2008-08-12 17:59:19Z pcanal $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:23688,undo,undo,23688,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,1,['undo'],['undo']
Usability,"ommands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 39365 2011-05-24 19:53:19Z pcanal $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TQCommand.html:23943,undo,undo,23943,root/html530/TQCommand.html,https://root.cern,https://root.cern/root/html530/TQCommand.html,1,['undo'],['undo']
Usability,"ommands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 39365 2011-05-24 19:53:19Z pcanal $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQCommand.html:23943,undo,undo,23943,root/html532/TQCommand.html,https://root.cern,https://root.cern/root/html532/TQCommand.html,1,['undo'],['undo']
Usability,"omposite frame, main frame, transient frame, group frame; Arranged by layout managers:; horizontal layout, vertical layout, row layout, list layout, tile layout, matrix layout. Using a combination of layout hints:. left, right, center x, center y, top, bottom, expand x, expand y, fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. in response to actions widgets send messages and emit signals; associated frames process these messages or the slot methods connected to the signals are executed. 25.3 TVirtualX; The GUI classes interface to the platform dependent low level graphics system via the semi-abstract graphics base class TVirtualX. Currently concrete implementations exist for X11 and Win32 (MacOS X is fully supported via Apple’s X11 implementation). Thanks to this single graphics interface, porting the ROOT GUI to a new platform requires only the implementation of TVirtualX. 25.4 A Simple Example; We will start with a simple example that builds a small application containing a canvas and two buttons: Draw and Exit. Its functionality will be very simple: every time you click on Draw button, the graphics of the function sin(x)/x will be drawn in randomly chosen interval in the canvas window, if you click on Exit - you close the application. This example shows the basic concepts for almost any GUI-application in ROOT and it is important to understand how it is constructed. The example program is written as a named script. See “Cling the C++ Interpreter”. Remember that the named script can be executed via; root[] .x example.C; only if the filename (without extension) and the function entry point are both the same. We need to say a few words about the parent-children relationship between the widgets before going through the real code. The widgets’ behaviors are based on this relationship. Every parent widget is responsible for where the children are and it ensures all properties and behavior for them. For example, if you want to hid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1129693,simpl,simple,1129693,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"ompound * GetCompound ();  ; Int_t GetDenyDestroy () const;  Returns the number of times deny-destroy has been requested on the element. ;  ; Bool_t GetDestroyOnZeroRefCnt () const;  Returns state of flag determining if the element will be destroyed when reference count reaches zero. ;  ; virtual TString GetHighlightTooltip ();  ; virtual const TGPicture * GetListTreeCheckBoxIcon ();  Returns list-tree-item check-box picture appropriate for given rendering state. ;  ; virtual Color_t GetMainColor () const;  ; Color_t * GetMainColorPtr () const;  ; virtual Char_t GetMainTransparency () const;  ; TEveElement * GetMaster ();  Returns the master element - that is: ;  ; virtual Int_t GetNItems () const;  ; Int_t GetParentIgnoreCnt () const;  Get number of parents that should be ignored in doing reference-counting. ;  ; virtual TObject * GetRenderObject (const TEveException &eh) const;  ; virtual Bool_t GetRnrAnything () const;  ; virtual Bool_t GetRnrChildren () const;  ; virtual Bool_t GetRnrSelf () const;  ; virtual Bool_t GetRnrState () const;  ; virtual UChar_t GetSelectedLevel () const;  Get selection level, needed for rendering selection and highlight feedback. ;  ; TRef & GetSource ();  ; TObject * GetSourceObject () const;  ; void * GetUserData () const;  ; TEveElement * GetVizModel () const;  ; const TString & GetVizTag () const;  ; Bool_t HasChild (TEveElement *el);  Check if element el is a child of this element. ;  ; Bool_t HasChildren () const;  ; virtual Bool_t HasMainColor () const;  ; virtual Bool_t HasMainTrans () const;  ; Bool_t HasParents () const;  ; virtual void HighlightElement (Bool_t state);  Set element's highlight state. Stamp appropriately. ;  ; void IncDenyDestroy ();  Increases the deny-destroy count of the element. ;  ; virtual void IncImpliedHighlighted ();  Increase element's implied-highlight count. Stamp appropriately. ;  ; virtual void IncImpliedSelected ();  Increase element's implied-selection count. Stamp appropriately. ;  ; void In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveViewer.html:14008,feedback,feedback,14008,doc/master/classTEveViewer.html,https://root.cern,https://root.cern/doc/master/classTEveViewer.html,1,['feedback'],['feedback']
Usability,on (class TSpectrum) ;  Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlcreatedb.py Create a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlfilldb.py Fill run catalog with nfiles entries ;  SQLiteIPLocation.C ;  SQLitePlatformDistribution.C ;  SQLiteTimeVersionOfRoot.C ;  SQLiteVersionsOfRoot.C ;  sqlselect.CQuery example to MySQL test database ;  sqlselect.py Query example to MySQL test database ;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:164355,simpl,simple,164355,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"on (either primary or cut buffer) into; text entry widget. Bool_t HandleTimer(TTimer* t); Handle cursor blink timer. Bool_t IsCursorOutOfFrame(); Returns kTRUE if cursor is out of frame. void ScrollByChar(); Shift position of cursor by one character. void UpdateOffset(); Updates start text offset according GetAlignment() mode,; if cursor is out of frame => scroll the text.; See also SetAlignment() and ScrollByChar(). void SetToolTipText(const char* text, Long_t delayms = 500); Set tool tip text associated with this text entry. The delay is in; milliseconds (minimum 250). To remove tool tip call method with; text = 0. void SetFocus(); Set focus to this text entry. void InsertText(const char* text, Int_t pos); Inserts text at position pos, clears the selection and moves; the cursor to the end of the line.; If necessary the text is truncated to fit MaxLength().; See also GetText(), SetText(), AppendText(), RemoveText(). void AppendText(const char* text); Appends text to the end of text entry, clears the selection; and moves the cursor to the end of the line.; If necessary the text is truncated to fit MaxLength().; See also GetText(), InsertText(), SetText(), RemoveText(). void RemoveText(Int_t start, Int_t end); Removes text at the range, clears the selection and moves; the cursor to the end of the line.; See also GetText(), InsertText(), SetText(), AppendText(). void SetFont(FontStruct_t font, Bool_t local = kTRUE); Changes text font.; If local is kTRUE font is changed locally. void SetFont(const char* fontName, Bool_t local = kTRUE); Changes text font specified by name.; If local is kTRUE font is changed locally. void SetFont(TGFont* font, Bool_t local = kTRUE); Changes text font specified by pointer to TGFont object.; If local is kTRUE font is changed locally. void SetTextColor(Pixel_t color, Bool_t local = kTRUE); Changes text color.; If local is true color is changed locally. void SetTextColor(TColor* color, Bool_t local = kTRUE); Changes text color.; If local is t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextEntry.html:37037,clear,clears,37037,root/html528/TGTextEntry.html,https://root.cern,https://root.cern/root/html528/TGTextEntry.html,6,['clear'],['clears']
Usability,"on Members (Methods); public:. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); virtual~RooObjCacheManager(); Int_tRooCacheManager<RooAbsCacheElement>::cacheSize() const; static TClass*Class(); static Bool_tclearObsList(); static voiddoClearObsList(Bool_t flag); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tRooCacheManager<RooAbsCacheElement>::lastIndex() const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet1ByIndex(Int_t index) const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet2ByIndex(Int_t index) const; RooObjCacheManager&operator=(const RooObjCacheManager&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooCacheManager<RooAbsCacheElement>::reset(); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); virtual voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooObjCacheManager.html:1058,clear,clearCacheOnServerRedirect,1058,root/html530/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html530/RooObjCacheManager.html,1,['clear'],['clearCacheOnServerRedirect']
Usability,"on RSha256.hxx:105; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kGreen@ kGreenDefinition Rtypes.h:66; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; kCanDelete@ kCanDeleteDefinition TObject.h:367; kCannotPick@ kCannotPickDefinition TObject.h:372; gROOT#define gROOTDefinition TROOT.h:406; gPad#define gPadDefinition TVirtualPad.h:308; TAttLine::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::HighlightConnectvirtual void HighlightConnect(const char *slot)This is ""simplification"" for function TCanvas::Connect with Highlighted signal for specific slot.Definition TCanvas.cxx:1631; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCanvas.cxx:719; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph.cxx:1566; TGraph::GetYaxisTAxis * GetYaxis() constGet y axis of the graph.Definition TGraph.cxx:1575; TGraph::Fin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hlHisto3_8C.html:5211,simpl,simplification,5211,doc/master/hlHisto3_8C.html,https://root.cern,https://root.cern/doc/master/hlHisto3_8C.html,1,['simpl'],['simplification']
Usability,"on a good local minimum.Definition TMinuit.cxx:4295; TMinuit::fPstarDouble_t * fPstarDefinition TMinuit.h:92; TMinuit::fObjectFitTObject * fObjectFitDefinition TMinuit.h:175; TMinuit::BuildArraysvirtual void BuildArrays(Int_t maxpar=15)Create internal Minuit arrays for the maxpar parameters.Definition TMinuit.cxx:512; TMinuit::mnwerrvirtual void mnwerr()Calculates the WERR, external parameter errors.Definition TMinuit.cxx:7861; TMinuit::kMAXWARN@ kMAXWARNDefinition TMinuit.h:35; TMinuit::fNfcnfrInt_t fNfcnfrDefinition TMinuit.h:148; TMinuit::mnrsetvirtual void mnrset(Int_t iopt)Resets function value and errors to UNDEFINED.Definition TMinuit.cxx:6661; TMinuit::fIMPRyDouble_t * fIMPRyDefinition TMinuit.h:106; TMinuit::fVlimhiDouble_t fVlimhiDefinition TMinuit.h:59; TMinuit::mneigvirtual void mneig(Double_t *a, Int_t ndima, Int_t n, Int_t mits, Double_t *work, Double_t precis, Int_t &ifault)Compute matrix eigen values.Definition TMinuit.cxx:2305; TMinuit::mnsimpvirtual void mnsimp()Minimization using the simplex method of Nelder and Mead.Definition TMinuit.cxx:7431; TMinuit::fLwarnBool_t fLwarnDefinition TMinuit.h:157; TMinuit::fXptDouble_t * fXptDefinition TMinuit.h:97; TMinuit::fGinDouble_t * fGinDefinition TMinuit.h:84; TMinuit::GetMethodCallTMethodCall * GetMethodCall() constDefinition TMinuit.h:193; TMinuit::fNfcnmxInt_t fNfcnmxDefinition TMinuit.h:146; TMinuit::fItaurInt_t fItaurDefinition TMinuit.h:149; TMinuit::TMinuitTMinuit()Minuit normal constructor.Definition TMinuit.cxx:347; TMinuit::fUndefiDouble_t fUndefiDefinition TMinuit.h:60; TMinuit::fKe2crInt_t fKe2crDefinition TMinuit.h:156; TMinuit::mnaminvirtual void mnamin()Initialize AMIN.Definition TMinuit.cxx:972; TMinuit::operator=TMinuit & operator=(const TMinuit &m); TMinuit::SetErrorDefvirtual Int_t SetErrorDef(Double_t up)To get the n-sigma contour the error def parameter ""up"" has to set to n^2.Definition TMinuit.cxx:908; TMinuit::fNuInt_t fNuDefinition TMinuit.h:130; TMinuit::GetStatusInt_t GetStatus() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8h_source.html:17301,simpl,simplex,17301,doc/master/TMinuit_8h_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html,1,['simpl'],['simplex']
Usability,"on activation function class; vector<TNeuron*>fOutputNeuronscache this for fast access; static const Bool_tfgDEBUGdebug flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeclareOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalised in put variables should be used; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers; NeuronType=sigmoid,tanh,radial,linar : the type of activation function; used at the neuronn. void ProcessOptions(); do nothing specific at this moment. vector<Int_t>* ParseLayoutString(TString layerSpec); parse layout specification string and return a vector, each entry; containing the number of neurons to go in each successive layer. void InitANNBase(); initialize ANNBase object. ~MethodANNBase(); destructor. void DeleteNetwork(); delete/clear network. void DeleteNetworkLayer(TObjArray*& layer); delete a network layer. void BuildNetwork(vector<Int_t>* layout, vector<Double_t>* weights = NULL, Bool_t fromFile = kFALSE); build network given a layout (number of neurons in each layer); and optional weights array. void BuildLayers(vector<Int_t>* layout, Bool_t from_file = false); build the network layers. void BuildLayer(Int_t numNeurons, TObjArray* curLayer, TObjArray* prevLayer, Int_t layerIndex, Int_t numLayers, Bool_t from_file = false); build a single layer with neurons and synapses connecting this; layer to the previous layer. void AddPreLinks(TMVA::TNeuron* neuron, TObjArray* prevLayer); add synapses connecting a neuron to its preceding layer. void InitWeights(); initialize the synapse weights randomly. void ForceWeights(vector<Double_t>* weights); force the synapse weights. void ForceNetworkInputs(const TMVA::Event* ev, Int_t ignoreIndex = -1); force the input values of the input neurons; force the value for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodANNBase.html:18852,clear,clear,18852,root/html528/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodANNBase.html,3,['clear'],['clear']
Usability,"on and the weights about the layer from XML node. ;  ; virtual void ResetTraining ();  Reset some training flags after a loop on all batches Some layer (e.g. ;  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetDropoutProbability (Scalar_t);  Set Dropout probability. ;  ; virtual void SetExtraLayerParameters (const std::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Protected Attributes; Tensor_t fActivationGradients;  Gradients w.r.t. the activations of this layer. ;  ; size_t fBatchSize;  Batch size used for training and evaluation. ;  ; std::vector< Matrix_t > fBiases;  The biases associated to the layer. ;  ; std::vector< Matrix_t > fBiasGradients;  Gradients w.r.t. the bias values of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:5474,learn,learningRate,5474,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"on at line 630 of file TXMLFile.cxx. ◆ ReadStreamerElement(). void TXMLFile::ReadStreamerElement ; (; XMLNodePointer_t ; node, . TStreamerInfo * ; info . ). protected . read and reconstruct single TStreamerElement from xml node ; Definition at line 825 of file TXMLFile.cxx. ◆ Recover(). Int_t TXMLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 86 of file TXMLFile.h. ◆ ReOpen(). Int_t TXMLFile::ReOpen ; (; Option_t * ; mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:67128,usab,usable,67128,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['usab'],['usable']
Usability,"on backend by default; The new vectorizing CPU evaluation backend is not the default for RooFit likelihoods. Likelihood minimization is now up to 10x faster on a single CPU core.; If you experience unexpected problems related to the likelihood evaluation, you can revert back to the old backend by passing RooFit::EvalBackend(""legacy"") to RooAbsPdf::fitTo() or RooAbsPdf::createNLL().; In case you observe any slowdowns with the new likelihood evaluation, please open a GitHub issue about this, as such a performance regression is considered a bug.; Asymptotically correct uncertainties for extended unbinned likelihood fits; Added correct treatment of extended term in asymptotically correct method for uncertainty determination in the presence of weights. This improvement will allow for extended unbinned maximum likelihood fits to use the asymptotically correct method when using the RooFit::AsymptoticError() command argument in RooAbsPdf::fitTo(). See also this writeup on extended weighted fits that is also linked from the reference guide. The pull request that introduced this feature might also be a good reference.; Compile your code with memory safe interfaces; If you define the ROOFIT_MEMORY_SAFE_INTERFACES preprocessor macro, the RooFit interface changes in a way such that memory leaks are avoided.; The most prominent effect of this change is that many functions that used to return an owning pointer (e.g., a pointer to an object that you need to manually delete) are then returning a std::unique_pt for automatic memory management.; For example this code would not compile anymore, because there is the risk that the caller forgets to delete params:; RooArgSet * params = pdf.getParameters(nullptr);; If you wrap such return values in a std::unique_ptr, then your code will compile both with and without memory safe interfaces:; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; Also some virtual RooFit functions like RooAbsReal::createIntegral() are returning a di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:9075,guid,guide,9075,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['guid'],['guide']
Usability,"on defines the analytical integral translation for the class. ;  ; TObject * clone (const char *newname) const override;  ; void generateEvent (Int_t code) override;  Interface for generation of an event using the algorithm corresponding to the specified code. ;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual RooAbsGenContext * binnedGenContext (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLandau.html:2191,simpl,simple,2191,doc/master/classRooLandau.html,https://root.cern,https://root.cern/doc/master/classRooLandau.html,1,['simpl'],['simple']
Usability,"on given a certain muon pT bin (pass) over how many muons are overall - triggered or not - in that pT bin (all).; But this won't work: we will never see those events that have not a single muon triggered - because in our data sample, only events with at least one muon trigger are saved! And so we would underestimate the all part. Our sample is ""biased"" against the muon trigger, because it requires events to be muon triggered.; The trick is to remove this ""bias"" from our data sample. The approach is called:; Tag and Probe; We take a random muon (the tag muon). If that has been seen by the trigger we know that the other muons have not been influenced by the trigger: we have satisfied the condition already with the tag muon. All other muons will now allow us to calculate the actual efficiency, but histogramming their pT in all and if it has fired the trigger also in pass.; TEfficiency; Instead of having to create two histograms for pass and all, and instead of having to search through ROOT how to build the ratio (and its uncertainty!) correctly (think of bins with 0 content) we can simply use TEfficiency. It behaves like a histogram; you fill it with the information whether it is part of the pass sample (or only part of the all sample) as first argument and with its pT value as second argument.; The script here shows how to do this - except for the TEfficiency::Fill() statement that you can probably do yourself!; // Save e.g. in effX.C. #include ""TEfficiency.h""; #include ""TF1.h"" // we'll need this later...; #include ""TFile.h""; #include ""TMath.h""; #include ""TRandom.h""; #include ""TTreeReader.h""; #include ""TTreeReaderArray.h"". void effX() {; TEfficiency* eff; = new TEfficiency(""eff"", ""Moun trigger efficiency"", 100, 0., 10.);. TFile* file; = TFile::Open(""http://root.cern.ch/root/files/tutorials/mockupx.root"");; TTreeReader reader(""MyTree"", file);. TTreeReaderArray<double> raPt(reader, ""muons.fPt"");; TTreeReaderArray<bool> raTriggered(reader, ""muons.fTriggered"");. while (re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/8-efficiency-calculation.html:3906,simpl,simply,3906,d/8-efficiency-calculation.html,https://root.cern,https://root.cern/d/8-efficiency-calculation.html,1,['simpl'],['simply']
Usability,"on matrix and the; global correlation coefficients from the MINUIT memory buffer and; fill the internal arrays. Bool_t isIdentical(const RooFitResult& other, Double_t tol = 5.0000000000000002E-5, Double_t tolCorr = 1.0E-4, Bool_t verbose = kTRUE) const; Return true if this fit result is identical to other within tolerance 'tol' on fitted values; and tolerance 'tolCor' on correlation coefficients. RooFitResult* lastMinuitFit(const RooArgList& varList = RooArgList()); Import the results of the last fit performed by gMinuit, interpreting; the fit parameters as the given varList of parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in this RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix (Note that Vred _is_ a simple sub-matrix of V,; row/columns are ordered to matched the convention given in input argument 'params'. TMatrixDSym conditionalCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; is the Shur complement of V22, calculated as shown above. (Note that Vred is _not_ a simple sub-matrix of V). const TMatrixDSym& correlationMatrix() const; Return correlation matrix ;. RooAbsPdf* createHessePdf(const RooArgSet& params) const; Return a p.d.f that represents the fit result as a multi-variate probability densisty; function on the floating fit parameters, including correlations. void SetName(const char* name); Change name of RooFitResult object. void SetNameTitle(const char* name, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFitResult.html:15965,simpl,simple,15965,root/html602/RooFitResult.html,https://root.cern,https://root.cern/root/html602/RooFitResult.html,2,['simpl'],['simple']
Usability,"on not in percent; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Float_tTGProgressBar::fMaxlogical maximum value (default 100); UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; Float_tTGProgressBar::fMinlogical minimum value (default 0); UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGProgressBar::fNormGCtext drawing graphics context; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTGProgressBar::fPercentshow position in percent (default true); Float_tTGProgressBar::fPoslogical position [fMin,fMax]; Int_tTGProgressBar::fPosPixposition of progress bar in pixel coordinates; Bool_tTGProgressBar::fShowPosshow position value (default false); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHProgressBar.html:18897,progress bar,progress bar,18897,root/html528/TGHProgressBar.html,https://root.cern,https://root.cern/root/html528/TGHProgressBar.html,12,['progress bar'],['progress bar']
Usability,"on of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCacheUnzip.html:16476,learn,learning,16476,root/html604/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html,1,['learn'],['learning']
Usability,"on of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCacheUnzip.html:16426,learn,learning,16426,root/html602/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html,1,['learn'],['learning']
Usability,"on of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCacheUnzip.html:13797,learn,learning,13797,root/html532/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html532/TTreeCacheUnzip.html,2,['learn'],['learning']
Usability,"on of three; measured quantities X, Y and Z can always be visualized by a three-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Z is an unknown (but single-valued); approximate function of X,Y this function is displayed by a profile2D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 2; H(I,J) = sum Z E(I,J) = sum Z; l(I,J) = sum l L(I,J) = sum l; h(I,J) = H(I,J)/L(I,J) s(I,J) = sqrt(E(I,J)/L(I,J)- h(I,J)**2); e(I,J) = s(I,J)/sqrt(L(I,J)). In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); the bin error e(I,J) is computed from the average of the s(I,J) for all cells; if the static function TProfile2D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note that this approximation is not the default behaviour. Example of a profile2D histogram; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof2d = new TProfile2D(""hprof2d"",""Profile of pz versus px and py"",40,-4,4,40,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof2d->Fill(px,py,pz,1);; }; hprof2d->Draw();; }. Function Members (Methods); public:. TProfile2D(); TProfile2D(const TProfile2D& profile); TProfile2D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Option_t* option = """"); TProfile2D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, Double_t ylow, Double_t yup, Option_t* option = """"); TProfile2D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t* ybins, Option_t* op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile2D.html:1456,simpl,simple,1456,root/html534/TProfile2D.html,https://root.cern,https://root.cern/root/html534/TProfile2D.html,1,['simpl'],['simple']
Usability,"on of three; measured quantities X, Y and Z can always be visualized by a three-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Z is an unknown (but single-valued); approximate function of X,Y this function is displayed by a profile2D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 2; H(I,J) = sum Z E(I,J) = sum Z; l(I,J) = sum l L(I,J) = sum l; h(I,J) = H(I,J)/L(I,J) s(I,J) = sqrt(E(I,J)/L(I,J)- h(I,J)**2); e(I,J) = s(I,J)/sqrt(L(I,J)). In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); the bin error e(I,J) is computed from the average of the s(I,J) for all cells; if the static function TProfile2D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note that this approximation is not the default behaviour. Example of a profile2D histogram; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof2d = new TProfile2D(""hprof2d"",""Profile of pz versus px and py"",40,-4,4,40,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof2d->Fill(px,py,pz,1);; }; hprof2d->Draw();; }. Function Members (Methods); public:. virtual~TProfile2D(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAdd(const TH1* h1, Double_t c1 = 1); virtual Bool_tAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual Bool_tAdd(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayD::AddAt(Double_t c, Int_t i); virtual voidTH2D::AddBinContent(Int_t bin); virtual voidTH2D::AddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProfile2D.html:1456,simpl,simple,1456,root/html602/TProfile2D.html,https://root.cern,https://root.cern/root/html602/TProfile2D.html,2,['simpl'],['simple']
Usability,on peak searching function (class TSpectrum) ;  SearchHR3.C Example to illustrate the influence of number of iterations in deconvolution in high resolution peak searching function (class TSpectrum) ;  Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlselect.C;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:155259,simpl,simple,155259,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,"on rootcling see the $ROOTSYS/test directory Makefile, Event.cxx, and Event.h for an example, or follow this link: http://root.cern.ch/root/RootCintMan.html; 15.6 genreflex: A Comfortable Interface to rootcling; Version 5 supported both Cint and Reflex dictionaries. The tool to create Reflex dictionaries was a Python script called genreflex and was very successful in the user community. Even if version 6 has only one type of dictionaries, cling dictionaries, a re-implementation of genreflex is provided. More precisely, in ROOT6, genreflex is nothing but a wrapper around rootcling, which offers an identical CLI and behaviour to the old Python tool. The input to genreflex is a C++ header file, a set of switches and a selection XML file. The output, as for rootcling, is a C++ dictionary source and a pcm files. An exhaustive documentation of the CLI switches of genreflex can be inspected with the genreflex --help command.; The entity corresponding to the LinkDef file for genreflex is the selection XML file, also called selection XML or simply selection file. A selection XML file allows to describe a list of classes for which the dictionaries are to be created. In addition, it allows to specify properties of classes or data members, without the need to add comments in the source code. This is of primary importance when dictionaries must be created for classes residing in code which cannot be modified. For a complete description of the structure of the selection XML files and the way in which attributes can be set, refer to the genreflex --help command.; It is important to observe that selection XML files can be used in presence of rootcling invocations instead of LinkDef files.; 15.6.1 The ROOT::Meta::Selection namespace; Not only LinkDef and selection files allow to select the classes for which the dictionaries must be created: a third method is available. This is represented by the ROOT::Meta::Selection namespace. The idea behind this technique is that all the classes w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:836946,simpl,simply,836946,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simply']
Usability,"on using graphics input will be made on the copy of the histogram, and not to the original object. By default a postfix ""_copy"" is added to the histogram name. Pass an empty postfix in case you want to draw a histogram with the same name; See Draw for the list of options ; Definition at line 3113 of file TH1.cxx. ◆ DrawNormalized(). TH1 * TH1::DrawNormalized ; (; Option_t * ; option = """", . Double_t ; norm = 1 . ); const. virtual . Draw a normalized copy of this histogram. ; A clone of this histogram is normalized to norm and drawn with option. A pointer to the normalized histogram is returned. The contents of the histogram copy are scaled such that the new sum of weights (excluding under and overflow) is equal to norm. Note that the returned normalized histogram is not added to the list of histograms in the current directory in memory. It is the user's responsibility to delete this histogram. The kCanDelete bit is set for the returned object. If a pad containing this copy is cleared, the histogram will be automatically deleted.; See Draw for the list of options ; Definition at line 3144 of file TH1.cxx. ◆ DrawPanel(). void TH1::DrawPanel ; (; ). virtual . Display a panel with all histogram drawing options. ; See class TDrawPanelHist for example ; Definition at line 3175 of file TH1.cxx. ◆ Eval(). void TH1::Eval ; (; TF1 * ; f1, . Option_t * ; option = """" . ). virtual . Evaluate function f1 at the center of bins of this histogram. . If option ""R"" is specified, the function is evaluated only for the bins included in the function range.; If option ""A"" is specified, the value of the function is added to the existing bin contents; If option ""S"" is specified, the value of the function is used to generate a value, distributed according to the Poisson distribution, with f1 as the mean. . Definition at line 3192 of file TH1.cxx. ◆ ExecuteEvent(). void TH1::ExecuteEvent ; (; Int_t ; event, . Int_t ; px, . Int_t ; py . ). overridevirtual . Execute action corresponding to one e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:111192,clear,cleared,111192,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['clear'],['cleared']
Usability,"on)Change search query and belongs to it json string Returns true if any parameter was really changed.Definition RGeomData.cxx:2130; ROOT::RGeomDescription::fVisibilitystd::vector< RGeomNodeVisibility > fVisibility! custom visibility flags for physical nodesDefinition RGeomData.hxx:244; ROOT::RGeomDescription::SelectTopbool SelectTop(const std::vector< std::string > &path)Select top node by path Used by the client to change active node Returns true if selected node was ch...Definition RGeomData.cxx:1946; ROOT::RGeomDescription::GetMaxVisNodesint GetMaxVisNodes() constReturns maximal visible number of nodes, ignored when non-positive.Definition RGeomData.hxx:319; ROOT::RGeomDescription::GetVisLevelint GetVisLevel() constReturns maximal visible level.Definition RGeomData.hxx:329; ROOT::RGeomDescription::GetMaxVisFacesint GetMaxVisFaces() constReturns maximal visible number of faces, ignored when non-positive.Definition RGeomData.hxx:324; ROOT::RGeomDescription::ClearCachevoid ClearCache()Clear cached data, need to be clear when connection broken.Definition RGeomData.cxx:1381; ROOT::RGeomDescription::ClearDescriptionvoid ClearDescription()Clear geometry description.Definition RGeomData.cxx:478; ROOT::RGeomDescription::MakeStackByIdsstd::vector< int > MakeStackByIds(const std::vector< int > &ids)Creates stack for given array of ids, first element always should be 0.Definition RGeomData.cxx:1621; ROOT::RGeomDescription::SetMaxVisFacesvoid SetMaxVisFaces(int cnt)Set maximal number of faces which should be selected for drawing.Definition RGeomData.hxx:322; ROOT::RGeomDescription::IsPreferredOfflinebool IsPreferredOffline() constIs offline operations preferred.Definition RGeomData.hxx:361; ROOT::RGeomDescription::fShapesstd::vector< ShapeDescr > fShapes! shapes with created descriptionsDefinition RGeomData.hxx:253; ROOT::RGeomDescription::fJsonCompint fJsonComp! default JSON compressionDefinition RGeomData.hxx:261; ROOT::RGeomDescription::ChangeNodeVisibilitybool ChangeNodeV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:77411,clear,clear,77411,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"on; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. private:. TGTextButton*fBtnAbortabort process button; TGTextButton*fBtnFinalizefinalize query button; TGTextButton*fBtnRetrieveretrieve query button; TGTextButton*fBtnSavesave query button; TGTextButton*fBtnShowLogshow log button; TGTextButton*fBtnStopstop process button; TGTextButton*fBtnSubmitsubmit query button; TQueryDescription*fDescquery description; TRootEmbeddedCanvas*fECanvasnode statistics embeded canvas; Long64_tfEntriesnumber of events/entries to process; TGCompositeFrame*fFAthree tabs element; TGCompositeFrame*fFBthree tabs element; TGCompositeFrame*fFCthree tabs element; TEditQueryFrame*fFDfourth tab element (edit query frame); Int_tfFilesnumber of files processed; Long64_tfFirstfirst event/entry to process; TGTextView*fInfoTextViewsummary on current query; TGLabel*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar; static TSessionQueryFrame::EQueryStatuskAborted; static TSessionQueryFrame::EQueryStatuskDone; static TSessionQueryFrame::EQueryStatuskRunning; static TSessionQueryFrame::EQueryStatuskStopped. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TSessionQueryFrame. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionQueryFrame.html:21417,progress bar,progress bar,21417,root/html602/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html602/TSessionQueryFrame.html,6,['progress bar'],['progress bar']
Usability,"on>; : ␛[1m================================================================␛[0m; : ; LD : Results for LD coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : myvar1: -0.309; : myvar2: -0.102; : var3: -0.142; : var4: +0.705; : (offset): -0.055; : -----------------------; : Elapsed time for training with 2000 events: 0.00103 sec ; LD : [dataset] : Evaluation of LD on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.000394 sec ; : <CreateMVAPdfs> Separation from histogram (PDF): 0.540 (0.000); : Dataset[dataset] : Evaluation of LD on training sample; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_LD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_LD.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: FDA_GA for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ FDA_GA ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The function discriminant analysis (FDA) is a classifier suitable ; : to solve linear or simple nonlinear discrimination problems.; : ; : The user provides the desired function with adjustable parameters; : via the configuration option string, and FDA fits the parameters to; : it, requiring the signal (background) function value to be as close; : as possible to 1 (0). Its advantage over the more involved and; : automatic nonlinear discriminators is the simplicity and transparency ; : of the discrimination expression. A shortcoming is that FDA will; : underperform for involved problems with complicated, phase space; : dependent nonlinear correlations.; : ; : Please consult the Users Guide for the format of the formula string; : and the allowed parameter ranges:; : documentation/tmva/UsersGuide/TMVAUsersGuide.pdf; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : The FDA performance depends on the complexity and fid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:38448,simpl,simple,38448,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['simpl'],['simple']
Usability,"onClear(Event_t* event); Handle selection clear event. Bool_t HandleSelectionRequest(Event_t* event); Handle request to send current clipboard contents to requestor window. void PastePrimary(Window_t wid, Atom_t property, Bool_t del); Paste text from selection (either primary or cut buffer) into; text entry widget. Bool_t HandleTimer(TTimer* t); Handle cursor blink timer. Bool_t IsCursorOutOfFrame(); Returns kTRUE if cursor is out of frame. void ScrollByChar(); Shift position of cursor by one character. void UpdateOffset(); Updates start text offset according GetAlignment() mode,; if cursor is out of frame => scroll the text.; See also SetAlignment() and ScrollByChar(). void SetToolTipText(const char* text, Long_t delayms = 500); Set tool tip text associated with this text entry. The delay is in; milliseconds (minimum 250). To remove tool tip call method with; text = 0. void SetFocus(); Set focus to this text entry. void InsertText(const char* text, Int_t pos); Inserts text at position pos, clears the selection and moves; the cursor to the end of the line.; If necessary the text is truncated to fit MaxLength().; See also GetText(), SetText(), AppendText(), RemoveText(). void AppendText(const char* text); Appends text to the end of text entry, clears the selection; and moves the cursor to the end of the line.; If necessary the text is truncated to fit MaxLength().; See also GetText(), InsertText(), SetText(), RemoveText(). void RemoveText(Int_t start, Int_t end); Removes text at the range, clears the selection and moves; the cursor to the end of the line.; See also GetText(), InsertText(), SetText(), AppendText(). void SetFont(FontStruct_t font, Bool_t local = kTRUE); Changes text font.; If local is kTRUE font is changed locally. void SetFont(const char* fontName, Bool_t local = kTRUE); Changes text font specified by name.; If local is kTRUE font is changed locally. void SetFont(TGFont* font, Bool_t local = kTRUE); Changes text font specified by pointer to TGFont obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextEntry.html:36780,clear,clears,36780,root/html528/TGTextEntry.html,https://root.cern,https://root.cern/root/html528/TGTextEntry.html,6,['clear'],['clears']
Usability,"onOrder ; (; Int_t ; order). inline . Definition at line 55 of file RooHistPdf.h. ◆ setUnitNorm(). void RooHistPdf::setUnitNorm ; (; bool ; flag). inline . Definition at line 78 of file RooHistPdf.h. ◆ Streamer(). void RooHistPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class RooHistPdf. ; Reimplemented from RooAbsPdf.; Definition at line 666 of file RooHistPdf.cxx. ◆ StreamerNVirtual(). void RooHistPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 162 of file RooHistPdf.h. ◆ totalVolume(). double RooHistPdf::totalVolume ; (; ); const. protected . ◆ totVolume(). double RooHistPdf::totVolume ; (; ); const. protected . Return the total volume spanned by the observables of the RooHistPdf. ; Definition at line 256 of file RooHistPdf.cxx. ◆ translate(). void RooHistPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 248 of file RooHistPdf.cxx. Friends And Related Symbol Documentation. ◆ RooAbsCachedPdf. friend class RooAbsCachedPdf. friend . Definition at line 109 of file RooHistPdf.h. ◆ RooHistFunc. friend class RooHistFunc. friend . Definition at line 124 of file RooHistPdf.h. Member Data Documentation. ◆ _cdfBoundaries. bool RooHistPdf::_cdfBoundaries = false. protected . Use boundary conditions for CDFs. ; Definition at line 118 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:88759,simpl,simple,88759,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['simpl'],['simple']
Usability,onRL_wide_boost.C Example to illustrate deconvolution function (class TSpectrum) ;  peaks.C Getting Contours From TH2D ;  peaks2.C Example to illustrate the 2-d peak finder (class TSpectrum2) ;  Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlselect.C;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorit,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:152612,simpl,simple,152612,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"on_t*TObject::GetOption() const; virtual voidTProofServ::GetOptions(Int_t* argc, char** argv); const char*TProofServ::GetOrdinal() const; const char*TProofServ::GetPackageDir() const; const char*TProofServ::GetPrefix() const; TProof*TProofServ::GetProof() const; Int_tTProofServ::GetProtocol() const; Int_tTProofServ::GetQuerySeqNum() const; Float_tTProofServ::GetRealTime() const; static Long_tTProofServ::GetResMemMax(); const char*TProofServ::GetService() const; const char*TProofServ::GetSessionDir() const; const char*TProofServ::GetSessionTag() const; TSignalHandler*TApplication::GetSignalHandler() const; TSocket*TProofServ::GetSocket() const; virtual const char*TObject::GetTitle() const; Int_tTProofServ::GetTotSessions() const; virtual UInt_tTObject::GetUniqueID() const; const char*TProofServ::GetUser() const; static Long_tTProofServ::GetVirtMemMax(); const char*TProofServ::GetWorkDir() const; virtual TProofServ::EQueryActionGetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); virtual Bool_tHandleError(const void* in = 0); virtual voidTProofServ::HandleException(Int_t sig); virtual voidTApplication::HandleIdleTimer()SIGNAL ; virtual Bool_tHandleInput(const void* in = 0); virtual voidHandleSigPipe(); virtual voidTProofServ::HandleSocketInput(); virtual Int_tTProofServ::HandleSocketInput(TMessage* mess, Bool_t all); virtual voidHandleTermination(); virtual Bool_tTApplication::HandleTermInput(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual voidHandleUrgentData(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTApplication::Hide(); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTApplication::Iconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXProofServ.html:7250,resume,resume,7250,root/html528/TXProofServ.html,https://root.cern,https://root.cern/root/html528/TXProofServ.html,3,['resume'],['resume']
Usability,"onality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTable.html:1481,simpl,simple,1481,root/html602/TGTable.html,https://root.cern,https://root.cern/root/html602/TGTable.html,4,['simpl'],['simple']
Usability,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCombiTrans.html:1723,simpl,simple,1723,root/html528/TGeoCombiTrans.html,https://root.cern,https://root.cern/root/html528/TGeoCombiTrans.html,48,['simpl'],['simple']
Usability,"ong64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:8463,simpl,simple,8463,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,6,['simpl'],['simple']
Usability,"onnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  ;  Static Public Member Functions inherited from TGWidget; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Attributes; TGCompositeFrame * fButtons;  container containing dock and hide buttons ;  ; TGCompositeFrame * fContainer;  container containing dockable frame ;  ; Bool_t fDeleted;  kTRUE if it is being deleted ;  ; TGDockButton * fDockButton;  dock button ;  ; TString fDockName;  name of frame ;  ; Bool_t fEnableHide;  if frame can be hidden ;  ; Bool_t fEnableUndock;  if frame can be undocked ;  ; Bool_t fFixedSize;  kTRUE if fixed size when undocked ;  ; TGUndockedFrame * fFrame;  undocked frame ;  ; Bool_t fHidden;  if frame is hidden ;  ; TGDockHideButton * fHideButton;  hide button ;  ; TGLayoutHints * fHints;  layout hints ;  ; TGLayoutHints * fLb;  ; TGLayoutHints * fLc;  layout hints ;  ;  Protected Attributes inherited from TGCompositeFrame; Bool_t fLayoutBroken;  no layout manager is used ;  ; TGLayoutManager * fLayoutManager;  layout manager ;  ; TList * fList;  container of frame elements ;  ; Bool_t fMapSubwindows;  kTRUE - map subwindows ;  ; Int_t fMustCleanup;  cleanup mode (see EFrameCleanup) ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDockableFrame.html:26665,undo,undocked,26665,doc/master/classTGDockableFrame.html,https://root.cern,https://root.cern/doc/master/classTGDockableFrame.html,3,['undo'],['undocked']
Usability,"ons Analyze, DefaultString, DefaultValue and DefaultVariable. ; Definition at line 2586 of file TFormula_v5.cxx. ◆ DefinedVariable(). Int_t TFormula::DefinedVariable ; (; TString & ; chaine, . Int_t & ; action . ). virtual . Check if expression is in the list of defined variables. ; This member function can be overloaded in derived classes; If you overload this member function, you also HAVE TO never call the constructor:; TFormula::TFormula(const char *name,const char *expression); and write your own constructor; MyClass::MyClass(const char *name,const char *expression) : TFormula(); which has to call the TFormula default constructor and whose implementation should be similar to the implementation of the normal TFormula constructor; This is necessary because the normal TFormula constructor call indirectly the virtual member functions Analyze, DefaultString, DefaultValue and DefaultVariable.; The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the action parameter. . Reimplemented in TTreeFormula.; Definition at line 2621 of file TFormula_v5.cxx. ◆ Eval(). Double_t TFormula::Eval ; (; Double_t ; x, . Double_t ; y = 0, . Double_t ; z = 0, . Double_t ; t = 0 . ); const. virtual . Evaluate this formula. ; The current value of variables x,y,z,t is passed through x, y, z and t. The parameters used will be the ones in the array params if params is given otherwise parameters will be taken from the stored data members fParams ; Definition at line 2668 of file TFormula_v5.cxx. ◆ EvalPar(). virtual Double_t ROOT::v5::TFormula::EvalPar ; (; const Double_t * ; x, . const Double_t * ; params = nullptr . ). inlinevirtual . Definition at line 235 of file TFormula.h. ◆ EvalParFast(). Double_t TFormula::EvalParFast ; (; const Double_t * ; x, . const Double_t * ; uparams . ). protected . Evaluate this formula. ; The current value of variables x,y,z,t is passed through ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html:36520,usab,usable,36520,doc/master/classROOT_1_1v5_1_1TFormula.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html,1,['usab'],['usable']
Usability,"ons to this object; TList*TQObject::fListOfSignals! list of signals from this object; TProofMgr*TProof::fManagermanager to which this session belongs (if any); Bool_tTProof::fMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Int_tTProof::fProtocolremote PROOF server protocol version number; TProof::EQueryModeTProof::fQueryModedefault query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TCondor*fCondorproxy for our Condor pool; TTimer*fTimertimer for delayed Condor COD suspend. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Start proof using condor. ~TProofCondor(); Clean up Condor PROOF environment. Bool_t StartSlaves(Bool_t ); Setup Condor workers using dynamic information. void SetActive(Bool_t active); Suspend or resume PROOF via Condor. TString GetJobAd(); Get job Ad. void SetActive(); { TProof::SetActive(); }. » Author: Fons Rademakers 13/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProofCondor.h 27171 2009-01-16 16:04:00Z ganis $ » Last generated: 2010-10-06 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofCondor.html:24467,resume,resume,24467,root/html528/TProofCondor.html,https://root.cern,https://root.cern/root/html528/TProofCondor.html,1,['resume'],['resume']
Usability,"ons to this object; TList*TQObject::fListOfSignals! list of signals from this object; TProofMgr*TProof::fManagermanager to which this session belongs (if any); Bool_tTProof::fMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Int_tTProof::fProtocolremote PROOF server protocol version number; TProof::EQueryModeTProof::fQueryModedefault query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TCondor*fCondorproxy for our Condor pool; TTimer*fTimertimer for delayed Condor COD suspend. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Start proof using condor. ~TProofCondor(); Clean up Condor PROOF environment. Bool_t StartSlaves(Bool_t ); Setup Condor workers using dynamic information. void SetActive(Bool_t active); Suspend or resume PROOF via Condor. TString GetJobAd(); Get job Ad. void SetActive(); { TProof::SetActive(); }. » Author: Fons Rademakers 13/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProofCondor.h 27171 2009-01-16 16:04:00Z ganis $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofCondor.html:24793,resume,resume,24793,root/html530/TProofCondor.html,https://root.cern,https://root.cern/root/html530/TProofCondor.html,1,['resume'],['resume']
Usability,"ons to this object; TList*TQObject::fListOfSignals! list of signals from this object; TProofMgr*TProof::fManagermanager to which this session belongs (if any); Bool_tTProof::fMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Int_tTProof::fProtocolremote PROOF server protocol version number; TProof::EQueryModeTProof::fQueryModedefault query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TCondor*fCondorproxy for our Condor pool; TTimer*fTimertimer for delayed Condor COD suspend. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Start proof using condor. ~TProofCondor(); Clean up Condor PROOF environment. Bool_t StartSlaves(Bool_t ); Setup Condor workers using dynamic information. void SetActive(Bool_t active); Suspend or resume PROOF via Condor. TString GetJobAd(); Get job Ad. void SetActive(); { TProof::SetActive(); }. » Author: Fons Rademakers 13/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProofCondor.h 27171 2009-01-16 16:04:00Z ganis $ » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofCondor.html:24793,resume,resume,24793,root/html532/TProofCondor.html,https://root.cern,https://root.cern/root/html532/TProofCondor.html,1,['resume'],['resume']
Usability,"ons.; Use TObject::Clone to make a full copy of an histogram. Note also that the histogram it will be created in gDirectory (if AddDirectoryStatus()=true); or will not be added to any directory if AddDirectoryStatus()=false; independently of the current directory stored in the original histogram. TObject* Clone(const char* newname = 0) const; Make a complete copy of the underlying object. If 'newname' is set,; the copy's name will be set to that name. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the histogram to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a line. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. Bool_t Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. The function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1); Divide this histogram by h1. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionally; compute binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TH1.html:63491,simpl,simple,63491,root/html604/TH1.html,https://root.cern,https://root.cern/root/html604/TH1.html,1,['simpl'],['simple']
Usability,ons;  CTActionSequence;  CTConfigurationBase class of the Configurations ;  CTConfiguredAction;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CApplicationWindowMain Qt&Root Application Window: ;  CBalancerInfo;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CClusterD;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CData;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CDUMMY;  CEditor;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  CFUMILI2;  Cfuncptr_and_voidptr_t;  CGaussFunction;  CGcCache_t;  CGCValues_t;  Cgroup;  CGSL_BFGS;  CGSL_BFGS2;  CGSL_FR;  CGSL_NLS;  CGSL_PR;  Ch1analysis;  Ch1analysisTreeReader;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CLINEAR;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_option;  ►Cmg_request_info;  Cmg_header;  Cmg_server_ports;  CMINUIT2;  CMultiDistFree functions adapter needed by UNURAN for multidimensional cont distribution ;  CMYSQL_BIND;  CMYSQL_STMT;  CNuMuToNuE_Oscillation;  ►CParamHis,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:81312,simpl,simple,81312,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['simpl'],['simple']
Usability,"ons;  ►CTActionSequence;  CSequencePtr;  CTConfigurationBase class of the Configurations ;  CTConfiguredAction;  CTIDNode;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  CTNestedIDs;  ►Nvecgeom;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CBalancerInfo;  Cbasic_string_view;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_option;  ►Cmg_request_info;  Cmg_header;  Cmg_server_ports;  CMultiDistFree functions adapter needed by UNURAN for multidimensional cont distribution ;  CMYSQL_BIND;  CMYSQL_STMT;  CNuMuToNuE_Oscillation;  ►CParamHistFunc;  CCacheElem;  CPassiveKeyGrab;  Cpasswd;  CPattern",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:88531,simpl,simple,88531,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['simpl'],['simple']
Usability,"ons=10);  c'tor ;  ; template<typename Function , typename Weights , typename PassThrough > ; double operator() (Function &fitnessFunction, Weights &weights, PassThrough &passThrough);  operator to call the steepest gradient descent algorithm ;  . Public Attributes; double m_alpha;  internal parameter (learningRate) ;  ; double m_beta;  internal parameter (momentum) ;  ; std::vector< double > m_localGradients;  local gradients for reuse in thread. ;  ; std::vector< double > m_localWeights;  local weights for reuse in thread. ;  ; std::vector< double > m_prevGradients;  vector remembers the gradients of the previous step ;  ; size_t m_repetitions;  . #include <TMVA/NeuralNet.h>; Constructor & Destructor Documentation. ◆ Steepest(). TMVA::DNN::Steepest::Steepest ; (; double ; learningRate = 1e-4, . double ; momentum = 0.5, . size_t ; repetitions = 10 . ). inline . c'tor ; C'tor; Parameters. learningRatedenotes the learning rate for the SGD algorithm ; momentumfraction of the velocity which is taken over from the last step ; repetitionsre-compute the gradients each ""repetitions"" steps . Definition at line 348 of file NeuralNet.h. Member Function Documentation. ◆ operator()(). template<typename Function , typename Weights , typename PassThrough > . double TMVA::DNN::Steepest::operator() ; (; Function & ; fitnessFunction, . Weights & ; weights, . PassThrough & ; passThrough . ). operator to call the steepest gradient descent algorithm ; implementation of the steepest gradient descent algorithm; entry point to start the minimization procedure; Parameters. fitnessFunction(templated) function which has to be provided. This function is minimized ; weights(templated) a reference to a container of weights. The result of the minimization procedure is returned via this reference (needs to support std::begin and std::end ; passThrough(templated) object which can hold any data which the fitness function needs. This object is not touched by the minimizer; This object is provided to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Steepest.html:1410,learn,learningRatedenotes,1410,doc/master/classTMVA_1_1DNN_1_1Steepest.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Steepest.html,2,['learn'],"['learning', 'learningRatedenotes']"
Usability,"onst Double_t *local, Double_t *master) const overrideconvert a point by multiplying its column vector (x, y, z, 1) to matrix inverseDefinition TGeoMatrix.cxx:1067; TGeoRotation::operator*=TGeoRotation & operator*=(const TGeoRotation &other)Composition.Definition TGeoMatrix.cxx:946; TGeoRotation::CheckMatrixvoid CheckMatrix()performes an orthogonality check and finds if the matrix is a reflection Warning(""CheckMatrix"",...Definition TGeoMatrix.cxx:1379; TGeoRotation::ReflectYvoid ReflectY(Bool_t leftside, Bool_t rotonly=kFALSE) overrideMultiply by a reflection respect to ZX.Definition TGeoMatrix.cxx:1185; TGeoRotation::GetPhiRotationDouble_t GetPhiRotation(Bool_t fixX=kFALSE) constReturns rotation angle about Z axis in degrees.Definition TGeoMatrix.cxx:1054; TGeoRotation::FastRotZvoid FastRotZ(const Double_t *sincos)Perform a rotation about Z having the sine/cosine of the rotation angle.Definition TGeoMatrix.cxx:1039; TGeoRotation::GetInversevoid GetInverse(Double_t *invmat) constGet the inverse rotation matrix (which is simply the transpose)Definition TGeoMatrix.cxx:1393; TGeoRotation::DeterminantDouble_t Determinant() constcomputes determinant of the rotation matrixDefinition TGeoMatrix.cxx:1364; TGeoRotation::GetAnglesvoid GetAngles(Double_t &theta1, Double_t &phi1, Double_t &theta2, Double_t &phi2, Double_t &theta3, Double_t &phi3) constRetrieve rotation angles.Definition TGeoMatrix.cxx:1310; TGeoRotation::IsValidBool_t IsValid() constPerform orthogonality test for rotation.Definition TGeoMatrix.cxx:1008; TGeoRotation::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) const overrideconvert a point by multiplying its column vector (x, y, z, 1) to matrixDefinition TGeoMatrix.cxx:1078; TGeoRotation::MakeCloneTGeoMatrix * MakeClone() const overrideMake a clone of this matrix.Definition TGeoMatrix.cxx:1089; TGeoRotation::operator*TGeoRotation operator*(const TGeoRotation &other) constDefinition TGeoMatrix.cxx:954; TGeoRotation::SavePrimitivevoid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:118950,simpl,simply,118950,doc/master/TGeoMatrix_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html,2,['simpl'],['simply']
Usability,"onst Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:26007,clear,clearEmat,26007,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,9,['clear'],"['clear', 'clearEmat']"
Usability,"onst RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvPdf.html:4835,clear,clearEvalErrorLog,4835,root/html532/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html532/RooNumConvPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"onst RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvPdf.html:4835,clear,clearEvalErrorLog,4835,root/html528/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html528/RooNumConvPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"onst RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvPdf.html:4835,clear,clearEvalErrorLog,4835,root/html530/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html530/RooNumConvPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"onst RooArgSet *set=nullptr) override;  Explicitly synchronize RooAbsCategory internal cache. ;  ; virtual bool isValid (const RooCatType &value) const;  Check if given state is defined for this object. ;  ; const RooCatType * defineType (const char *label);  ; const RooCatType * defineType (const char *label, int index);  ; const RooCatType * defineTypeUnchecked (const char *label, value_type index);  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:44399,clear,clearShapeDirty,44399,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,21,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,"onst RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooResolutionModel.html:4568,clear,clearValueDirty,4568,root/html532/RooResolutionModel.html,https://root.cern,https://root.cern/root/html532/RooResolutionModel.html,1,['clear'],['clearValueDirty']
Usability,"onst RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:2880,clear,clearShapeDirty,2880,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,3,['clear'],['clearShapeDirty']
Usability,"onst RooArgSet* iset, const char* rangeName = 0) const; Return list of (partial) integrals whose product defines the integral of this; RooProduct over the observables in iset in range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProduct(*this, newname); }. RooArgSet components(); { RooArgSet tmp(_compRSet) ; tmp.add(_compCSet) ; return tmp ; }. ProdMap* groupProductTerms(const RooArgSet& ) const. » Last changed: Fri Dec 2 14:26:58 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProduct.html:36025,intuit,intuitively,36025,root/html532/RooProduct.html,https://root.cern,https://root.cern/root/html532/RooProduct.html,1,['intuit'],['intuitively']
Usability,"onst RooRealVar&basisConvVar() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooResolutionModel.html:4403,clear,clearEvalError,4403,root/html532/RooResolutionModel.html,https://root.cern,https://root.cern/root/html532/RooResolutionModel.html,1,['clear'],['clearEvalError']
Usability,"onst TLegend &)Assignment operator.Definition TLegend.cxx:290; TLegend::SetEntryLabelvirtual void SetEntryLabel(const char *label)Edit the label of the entry pointed to by the mouse.Definition TLegend.cxx:1066; TLegend::Printvoid Print(Option_t *option="""") const overrideDump this TLegend and its contents.Definition TLegend.cxx:1013; TLegend::PaintPrimitivesvirtual void PaintPrimitives()Paint the entries (list of primitives) for this legend.Definition TLegend.cxx:618; TLegend::EditEntryAttFillvirtual void EditEntryAttFill()Edit the fill attributes for the entry pointed by the mouse.Definition TLegend.cxx:433; TLegend::GetHeadervirtual const char * GetHeader() constReturns the header, which is the title that appears at the top of the legend.Definition TLegend.cxx:521; TLegend::InsertEntryvirtual void InsertEntry(const char *objectName="""", const char *label="""", Option_t *option=""lpf"")Add a new entry before the entry at the mouse position.Definition TLegend.cxx:536; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::kLineNDC@ kLineNDCUse NDC coordinates.Definition TLine.h:33; TLine::Paintvoid Paint(Option_t *option="""") overridePaint this line with its current attributes.Definition TLine.cxx:389; TLine::PaintLineNDCvirtual void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2)Draw this line with new coordinates in NDC.Definition TLine.cxx:409; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::AddBeforevoid AddBefore(const TObject *before, TObject *obj) overrideInsert object before object before in the list.Definition TList.cxx:194; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLegend_8cxx_source.html:51495,simpl,simple,51495,doc/master/TLegend_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html,1,['simpl'],['simple']
Usability,"onst char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsAnaConvPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:60866,clear,clearEvalErrorLog,60866,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,6,['clear'],['clearEvalErrorLog']
Usability,"onst char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argument alows you to; describe different cluster configurations).; The default is proof.conf. Confdir is the directory where the config; file and other PROOF related files are (like motd and noproof files).; Loglevel is the log level (default = 1). User specified custom config; files will be first looked for in $HOME/.conffile. TProof(); Protected constructor to be used by classes deriving from TProof; (they have to call Init themselves and override StartSlaves; appropriately). This constructor simply closes any previous gProof and sets gProof; to this instance. void InitMembers(); Default initializations. ~TProof(); Clean up PROOF environment. Int_t Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); Start the PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. Int_t GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); Set the sandbox path from ' Proof.Sandbox' or the alternative var 'rc'.; Use the existing setting or the default if nothing is found.; If 'assert' is kTRUE, make also sure that the path exists.; Return 0 on success, -1 on failure. void ParseConfigField(const char* config); The config file field may cont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:32865,simpl,simply,32865,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,5,['simpl'],['simply']
Usability,"onst char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argument alows you to; describe different cluster configurations).; The default is proof.conf. Confdir is the directory where the config; file and other PROOF related files are (like motd and noproof files).; Loglevel is the log level (default = 1). User specified custom config; files will be first looked for in $HOME/.conffile. TProof(); Protected constructor to be used by classes deriving from TProof; (they have to call Init themselves and override StartSlaves; appropriately). This constructor simply closes any previous gProof and sets gProof; to this instance. void InitMembers(); Default initializations. ~TProof(); Clean up PROOF environment. Int_t Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); Start the PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. void ParseConfigField(const char* config); The config file field may contain special instructions which need to be; parsed at the beginning, e.g. for debug runs with valgrind. Int_t AssertPath(const char* path, Bool_t writable); Make sure that 'path' exists; if 'writable' is kTRUE, make also sure; that the path is writable. void SetManager(TProofMgr* mgr); Set manager and sche",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:32629,simpl,simply,32629,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['simpl'],['simply']
Usability,"onst. inline . Definition at line 128 of file TGDockableFrame.h. ◆ operator=(). TGDockableFrame & TGDockableFrame::operator= ; (; const TGDockableFrame & ; ). privatedelete . ◆ ProcessMessage(). Bool_t TGDockableFrame::ProcessMessage ; (; Longptr_t ; msg, . Longptr_t ; parm1, . Longptr_t ;  . ). overridevirtual . Process dockable frame messages. ; Reimplemented from TGCompositeFrame.; Definition at line 391 of file TGDockableFrame.cxx. ◆ SavePrimitive(). void TGDockableFrame::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a dockable frame widget as a C++ statement(s) on output stream out. ; Reimplemented from TGCompositeFrame.; Definition at line 457 of file TGDockableFrame.cxx. ◆ SetFixedSize(). void TGDockableFrame::SetFixedSize ; (; Bool_t ; fixed). inline . Definition at line 132 of file TGDockableFrame.h. ◆ SetWindowName(). void TGDockableFrame::SetWindowName ; (; const char * ; name). overridevirtual . Set window name so it appear as title of the undock window. ; Reimplemented from TGWindow.; Definition at line 445 of file TGDockableFrame.cxx. ◆ ShowContainer(). void TGDockableFrame::ShowContainer ; (; ). Show dock container. ; Definition at line 357 of file TGDockableFrame.cxx. ◆ Streamer(). void TGDockableFrame::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGCompositeFrame. ◆ StreamerNVirtual(). void TGDockableFrame::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 139 of file TGDockableFrame.h. ◆ UndockContainer(). void TGDockableFrame::UndockContainer ; (; ). Undock container. ; Definition at line 286 of file TGDockableFrame.cxx. ◆ Undocked(). virtual void TGDockableFrame::Undocked ; (; ). inlinevirtual . Definition at line 113 of file TGDockableFrame.h. Friends And Related Symbol Documentation. ◆ TGUndockedFrame. friend class TGUndockedFrame. friend . Definition at line 83 of file TGDockableFrame.h. Memb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDockableFrame.html:38174,undo,undock,38174,doc/master/classTGDockableFrame.html,https://root.cern,https://root.cern/doc/master/classTGDockableFrame.html,1,['undo'],['undock']
Usability,"onst; Int_tSelectSearch(UChar_t value) const; Int_tSelectSearch(Char_t value) const; Int_tSelectSearch(Bool_t value) const; voidSetSearchMethod(); voidSetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColDimensionsThe number of the dimensions for array (=-1 means it is a ""simple"" array); TStringfColName; Int_tfColOffset; Int_tfColSizeThe size of the selected column in bytes; TTable::EColumnTypefColTypedata type of the selected column; COMPAREMETHODfCompareMethodFunction to sort the original array; const char*fFirstParentRow! pointer to the internal array of TTable object;; Int_tfFirstRowfirst row of the table to be sorted; Int_t*fIndexArray""parsed"" indecis; Int_tfLastFoundThe index of the last found index within fSortIndex; TStringTNamed::fNameobject identifier; Int_tfNumberOfRowsnumber of rows of the table to be sorted; Long_tfParentRowSizeTo be filled from TTable::GetRowSize() method; const TTable*fParentTable!- the back pointer to the sorted table; SEARCHMETHODfSearchMethodFunction selected to search values; void**fSortIndexArray of pointers to columns of the sorted table; TStringTNamed::fTitleobject title; const Char_t*fsimpleArrayPointer to the ""simple"" array;. private:. TTableSorter::fValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTableSorter(); default ctor for RootCint dictionary. TTableSorter(const TTable& table, TString& colName, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table along its column defined with colName. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableSorter.html:11823,simpl,simple,11823,root/html528/TTableSorter.html,https://root.cern,https://root.cern/root/html528/TTableSorter.html,6,['simpl'],['simple']
Usability,"onst; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGaussModel.html:3425,clear,clearEvalErrorLog,3425,root/html534/RooGaussModel.html,https://root.cern,https://root.cern/root/html534/RooGaussModel.html,9,['clear'],['clearEvalErrorLog']
Usability,"onst; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddModel.html:3667,clear,clearValueDirty,3667,root/html528/RooAddModel.html,https://root.cern,https://root.cern/root/html528/RooAddModel.html,2,['clear'],['clearValueDirty']
Usability,"onst; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGaussModel.html:3225,clear,clearEvalError,3225,root/html532/RooGaussModel.html,https://root.cern,https://root.cern/root/html532/RooGaussModel.html,3,['clear'],['clearEvalError']
Usability,"onst; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGaussModel.html:3225,clear,clearEvalError,3225,root/html528/RooGaussModel.html,https://root.cern,https://root.cern/root/html528/RooGaussModel.html,3,['clear'],['clearEvalError']
Usability,"onst; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGaussModel.html:3225,clear,clearEvalError,3225,root/html530/RooGaussModel.html,https://root.cern,https://root.cern/root/html530/RooGaussModel.html,3,['clear'],['clearEvalError']
Usability,"onst; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; 16.5 The TIter Generic Iterator; As stated above, the TIterator class is abstract; it is not possible to create TIterator objects. However, it should be possible to write generic code to process all members of a collection so there is a need for a generic iterator object. A TIter object acts as generic iterator. It provides the same Next() and Reset() methods as TIterator although it has no idea how to support them! It works as follows:. To create a TIter object its constructor must be passed an object that inherits from TCollection. The TIter constructor calls the MakeIterator() method of this collection to get the appropriate iterator object that inherits from TIterator.; The Next() and Reset() methods of TIter simply call the Next() and Reset() methods of the iterator object. Therefore, TIter simply acts as a wrapper for an object of a concrete class inheriting from TIterator.; To see this working in practice, consider the TObjArray collection. Its associated iterator is TObjArrayIter. Suppose myarray is a pointer to a TObjArray that contains MyClass objects, i.e.; TObjArray *myarray;; To create a TIter object called myiter:; TIter myiter(myarray);. As shown in the diagram, this results in several methods being called:. The TIter constructor is passed a TObjArray; TIter asks embedded TCollection to make an iterator; TCollection asks TObjArray to make an iterator; TObjArray returns a TObjArrayIter. Now define a pointer for MyClass objects and set it to each member of the TObjArray:; MyClass *myobject;; while ((myobject = (MyClass *)myiter.Next())) {; // process myobject; }; The heart of this is the myiter.Next() expression which does the following:. The Next() method of the TIter object myiter is called; The TIter forwards the call to the TIterator embedded in the TObjArrayIter; TIterator forwards the call t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:849530,simpl,simply,849530,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simply']
Usability,"onstrates how to combine Timur's GL plots with other scene elements ;  hierarchical_scene.C;  histobrowser.CDemonstates how to use EVE as a histogram browser ;  jetcone.CDemonstrates usage of TEveJetCone class ;  lineset.CDemonstrates usage of class TEveStraightLineSet ;  lineset.py;  MultiView.CMulti-view (3d, rphi, rhoz) service class using EVE Window Manager ;  overlay_palette.C;  pack.CDemonstrates usage of class TGPack ;  paramlist.CDemonstrates usage of simple configuration via TEveParamList class ;  pointset.CDemonstrates usage of class TEvePointSet ;  projection.CDemonstates usage of automatic 2D projections - class TEveProjectionManager ;  projection_prescale.CDemonstates usage pre-scaling for automatic 2D projections ;  pythia_display.CDemo showing H -> ZZ -> 4 mu generated by Pythia ;  quadset.CDemonstates usage of 2D digit class TEveQuadSet ;  quadset_callback.cxx;  selection_sigs.CTest signals from TEveSelection class ;  show_extract.CHelper script for showing of extracted / simplified geometries ;  SplitGLView.CHelper classes for the alice_esd_split.C demo ;  text.CDemonstrates usage of class TEveText - 2D & 3D text in GL ;  track.CDemonstrates usage of TEveTrackPRopagator with different magnetic field configurations ;  triangleset.CDemonstrates usage of class TEveTriangleSet ;  view3ds.CLoading and display of basic 3DS models ;  window_manager.CDemonstrates usage of EVE window-manager ;  ► fft;  FFT.C This tutorial illustrates the Fast Fourier Transforms interface in ROOT ;  ► fit;  combinedFit.C Combined (simultaneous) fit of two histogram with separate functions and some common parameters ;  ConfidenceIntervals.C Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ;  ErrorIntegral.C Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit ;  exampleFit3D.C example of fitting a 3D function Typical multidimensional par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:103327,simpl,simplified,103327,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,4,['simpl'],['simplified']
Usability,"ont*fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetRange(Float_t min, Float_t max); Set min and max of progress bar. void SetPosition(Float_t pos); Set progress position between [min,max]. void Increment(Float_t inc); Increment progress position. void Reset(); Reset progress bar (i.e. set pos to 0). void SetFillType(TGProgressBar::EFillType type); Set fill type. void SetBarType(TGProgressBar::EBarType type); Set bar type. void SetBarColor(ULong_t color); Set progress bar color. void SetBarColor(const char* color = ""blue""); Set progress bar color. void Format(const char* format = ""%.2f""); Set format for displaying a value. FontStruct_t GetDefaultFontStruct(); Return default font structure in use. const TGGC & GetDefaultGC(); Return default graphics context in use. void SetForegroundColor(Pixel_t pixel); Change text color drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save progress bar parameters as a C++ statement(s) on output stream out. Bool_t fDrawBar; // if true draw only bar in DoRedraw(). virtual ~TGProgressBar(); { }. Float_t GetMin() const; { return fMin; }. Float_t GetMax() const; { return fMax; }. Float_t GetPosition() const; { return fPos; }. EFillType GetFillType() const; { return fFillType; }. EBarType GetBarType() const; { return fBarType; }. Bool_t GetShowPos() const; { return fShowPos; }. TString GetFormat() const; { return fFormat; }. const char* GetValueFormat() const; { return fFormat.Data(); }. Bool_t UsePercent() const; { return fPercent; }. Pixel_t GetB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGProgressBar.html:19548,progress bar,progress bar,19548,root/html528/TGProgressBar.html,https://root.cern,https://root.cern/root/html528/TGProgressBar.html,4,['progress bar'],['progress bar']
Usability,"ontext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual voidchangeBasis(RooFormulaVar* basis); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooResolutionModel.html:4924,clear,clearShapeDirty,4924,root/html534/RooResolutionModel.html,https://root.cern,https://root.cern/root/html534/RooResolutionModel.html,2,['clear'],['clearShapeDirty']
Usability,"onymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Option_t*fOptiondraw option; TProof*fProofhandle to PROOF session; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfAlldraw all or selected objects; TStringfNameIdentfier for this object; THashList*fNamesselected objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDrawFeedback(TProof* proof = 0, TSeqCollection* names = 0); Constructor. ~TDrawFeedback(); Destructor. void Feedback(TList* objs); Display feedback. TDrawFeedback(TProof* proof = 0, TSeqCollection* names = 0). const char * GetName() const; { return fName.Data(); }. ULong_t Hash() const; { return fName.Hash(); }. void SetOption(Option_t* option); { fOption = option; }. » Author: Maarten Ballintijn 28/10/2003 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-02 15:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TDrawFeedback.html:9938,feedback,feedback,9938,root/html604/TDrawFeedback.html,https://root.cern,https://root.cern/root/html604/TDrawFeedback.html,1,['feedback'],['feedback']
Usability,"onymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Option_t*fOptiondraw option; TProof*fProofhandle to PROOF session; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfAlldraw all or selected objects; TStringfNameIdentfier for this object; THashList*fNamesselected objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDrawFeedback(TProof* proof = 0, TSeqCollection* names = 0); Constructor. ~TDrawFeedback(); Destructor. void Feedback(TList* objs); Display feedback. TDrawFeedback(TProof* proof = 0, TSeqCollection* names = 0). const char * GetName() const; { return fName.Data(); }. ULong_t Hash() const; { return fName.Hash(); }. void SetOption(Option_t* option); { fOption = option; }. » Author: Maarten Ballintijn 28/10/2003 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-30 14:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDrawFeedback.html:9938,feedback,feedback,9938,root/html602/TDrawFeedback.html,https://root.cern,https://root.cern/root/html602/TDrawFeedback.html,1,['feedback'],['feedback']
Usability,"ooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategoryLValue.html:2167,clear,clearValueDirty,2167,root/html526/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsCategoryLValue.html,1,['clear'],['clearValueDirty']
Usability,"ooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:2098,clear,clearValueDirty,2098,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,1,['clear'],['clearValueDirty']
Usability,"ooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsString.html:1926,clear,clearValueDirty,1926,root/html526/RooAbsString.html,https://root.cern,https://root.cern/root/html526/RooAbsString.html,1,['clear'],['clearValueDirty']
Usability,"ooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBinningCategory.html:1937,clear,clearValueDirty,1937,root/html526/RooBinningCategory.html,https://root.cern,https://root.cern/root/html526/RooBinningCategory.html,5,['clear'],['clearValueDirty']
Usability,"ooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStringVar.html:1821,clear,clearValueDirty,1821,root/html526/RooStringVar.html,https://root.cern,https://root.cern/root/html526/RooStringVar.html,1,['clear'],['clearValueDirty']
Usability,"ooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo2DKeysPdf.html:2644,clear,clearEvalError,2644,root/html532/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html532/Roo2DKeysPdf.html,1,['clear'],['clearEvalError']
Usability,"ooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Roo2DKeysPdf.html:2644,clear,clearEvalError,2644,root/html528/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html528/Roo2DKeysPdf.html,1,['clear'],['clearEvalError']
Usability,"ooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/Roo2DKeysPdf.html:2644,clear,clearEvalError,2644,root/html530/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html530/Roo2DKeysPdf.html,1,['clear'],['clearEvalError']
Usability,"ooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModecanNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddPdf.html:3950,clear,clearEvalError,3950,root/html534/RooAddPdf.html,https://root.cern,https://root.cern/root/html534/RooAddPdf.html,6,['clear'],['clearEvalError']
Usability,"ooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:2803,clear,clearEvalError,2803,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,3,['clear'],['clearEvalError']
Usability,"ooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooIntegralMorph.html:6300,clear,clearEvalError,6300,root/html526/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html526/RooIntegralMorph.html,1,['clear'],['clearEvalError']
Usability,"ooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:3826,clear,clearValueAndShapeDirty,3826,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,3,['clear'],['clearValueAndShapeDirty']
Usability,"ooExtendPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 60 of file RooExtendPdf.h. ◆ selfNormalized(). bool RooExtendPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 46 of file RooExtendPdf.h. ◆ Streamer(). void RooExtendPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooExtendPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 60 of file RooExtendPdf.h. ◆ translate(). void RooExtendPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 177 of file RooExtendPdf.cxx. Member Data Documentation. ◆ _n. RooTemplateProxy<RooAbsReal> RooExtendPdf::_n. protected . Number of expected events. ; Definition at line 56 of file RooExtendPdf.h. ◆ _pdf. RooTemplateProxy<RooAbsPdf> RooExtendPdf::_pdf. protected . Input p.d.f. ; Definition at line 55 of file RooExtendPdf.h. ◆ _rangeName. const TNamed* RooExtendPdf::_rangeName = nullptr. protected . Name of subset range. ; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExtendPdf.html:80389,simpl,simple,80389,doc/master/classRooExtendPdf.html,https://root.cern,https://root.cern/doc/master/classRooExtendPdf.html,1,['simpl'],['simple']
Usability,"ooLinkedList& cmdList); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:3392,clear,clearValueDirty,3392,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['clear'],['clearValueDirty']
Usability,"ooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGaussModel.html:3227,clear,clearValueDirty,3227,root/html526/RooGaussModel.html,https://root.cern,https://root.cern/root/html526/RooGaussModel.html,3,['clear'],['clearValueDirty']
Usability,"ooSimGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimPdfBuilder RooSimultaneous PDF Builder (obsolete); RooSimSplitGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimWSTool Workspace oriented tool for customized cloning of p.d.f. into a simultaneous p.d.f; RooSimWSTool::BuildConfig Build configuration object for RooSimWSTool; RooSimWSTool::MultiBuildConfig Build configuration object for RooSimWSTool with multiple prototype p.d.f.; RooSimWSTool::ObjBuildConfig Validated RooSimWSTool build configuration; RooSimWSTool::ObjSplitRule Validated RooSimWSTool split rule; RooSimWSTool::SplitRule Split rule specification for prototype p.d.f; RooSimultaneous Simultaneous operator p.d.f, functions like C++ 'switch()' on input p.d.fs operating on index category5A; RooSpHarmonic SpHarmonic polynomial; RooStats ; RooStats::AcceptanceRegion A simple class for acceptance regions used for ConfidenceBelt; RooStats::AsymptoticCalculator ; RooStats::BayesianCalculator BayesianCalculator class; RooStats::BernsteinCorrection A utility to add polynomial corrrection terms to a model to improve the description of data.; RooStats::CombinedCalculator A base class that is for tools that can be both HypoTestCalculators and IntervalCalculators; RooStats::ConfInterval Interface for Confidence Intervals; RooStats::ConfidenceBelt A confidence belt for the Neyman Construction; RooStats::DebuggingSampler A simple implementation of the DistributionCreator interface; RooStats::DebuggingTestStat A concrete implementation of the TestStatistic interface, useful for debugging.; RooStats::DetailedOutputAggregator ; RooStats::FeldmanCousins Interface for tools setting limits (producing confidence intervals); RooStats::FrequentistCalculator ; RooStats::HLFactory The high Level Model Factory to create models from datacards; RooStats::Heaviside Your description goes here...; RooStats::HistFactory ; RooStats::HistFactory::Asimov ; Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:44792,simpl,simple,44792,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,3,['simpl'],['simple']
Usability,"ooSimGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimPdfBuilder RooSimultaneous PDF Builder (obsolete); RooSimSplitGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimWSTool Workspace oriented tool for customized cloning of p.d.f. into a simultaneous p.d.f; RooSimWSTool::BuildConfig Build configuration object for RooSimWSTool; RooSimWSTool::MultiBuildConfig Build configuration object for RooSimWSTool with multiple prototype p.d.f.; RooSimWSTool::ObjBuildConfig Validated RooSimWSTool build configuration; RooSimWSTool::ObjSplitRule Validated RooSimWSTool split rule; RooSimWSTool::SplitRule Split rule specification for prototype p.d.f; RooSimultaneous Simultaneous operator p.d.f, functions like C++ 'switch()' on input p.d.fs operating on index category5A; RooSpHarmonic SpHarmonic polynomial; RooStats ; RooStats::AcceptanceRegion A simple class for acceptance regions used for ConfidenceBelt; RooStats::AsymptoticCalculator ; RooStats::BayesianCalculator BayesianCalculator class; RooStats::BernsteinCorrection A utility to add polynomial corrrection terms to a model to improve the description of data.; RooStats::CombinedCalculator A base class that is for tools that can be both HypoTestCalculators and IntervalCalculators; RooStats::ConfInterval Interface for Confidence Intervals; RooStats::ConfidenceBelt A confidence belt for the Neyman Construction; RooStats::DebuggingSampler A simple implementation of the DistributionCreator interface; RooStats::DebuggingTestStat A concrete implementation of the TestStatistic interface, useful for debugging.; RooStats::FeldmanCousins Interface for tools setting limits (producing confidence intervals); RooStats::FrequentistCalculator ; RooStats::HLFactory The high Level Model Factory to create models from datacards; RooStats::Heaviside Your description goes here...; RooStats::HistFactory::EstimateSummary ; RooStats::HistFactory::FlexibleInterpVar flexible inte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:44026,simpl,simple,44026,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['simpl'],['simple']
Usability,"oofMgr*TProof::fManagermanager to which this session belongs (if any); Bool_tTProof::fMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Int_tTProof::fProtocolremote PROOF server protocol version number; TProof::EQueryModeTProof::fQueryModedefault query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TSelector*TProof::fSelectorSelector to be processed, if any; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TList*TProof::fTerminatedSlaveInfoslist of unique infos of terminated slaves; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TCondor*fCondorproxy for our Condor pool; TTimer*fTimertimer for delayed Condor COD suspend. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Start proof using condor. ~TProofCondor(); Clean up Condor PROOF environment. Bool_t StartSlaves(Bool_t ); Setup Condor workers using dynamic information. void SetActive(Bool_t active); Suspend or resume PROOF via Condor. TString GetJobAd(); Get job Ad. void SetActive(); { TProof::SetActive(); }. » Author: Fons Rademakers 13/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:27072,resume,resume,27072,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,1,['resume'],['resume']
Usability,"oofPlayer.; Definition at line 2973 of file TProofPlayer.cxx. ◆ GetNextPacket(). TDSetElement * TProofPlayerRemote::GetNextPacket ; (; TSlave * ; slave, . TMessage * ; r . ). overridevirtual . Get next packet for specified slave. ; Reimplemented from TProofPlayer.; Definition at line 4188 of file TProofPlayer.cxx. ◆ GetPacketizer(). TVirtualPacketizer * TProofPlayerRemote::GetPacketizer ; (; ); const. inlineoverridevirtual . Reimplemented from TProofPlayer.; Definition at line 358 of file TProofPlayer.h. ◆ GetProof(). TProof * TProofPlayerRemote::GetProof ; (; ); const. inlineprotected . Definition at line 307 of file TProofPlayer.h. ◆ HandleHistogram(). TObject * TProofPlayerRemote::HandleHistogram ; (; TObject * ; obj, . Bool_t & ; merged . ). Low statistic histograms need a special treatment when using autobin. ; Definition at line 3695 of file TProofPlayer.cxx. ◆ HandleTimer(). Bool_t TProofPlayerRemote::HandleTimer ; (; TTimer * ; timer). overrideprotectedvirtual . Send feedback objects to client. ; Reimplemented from TObject.; Reimplemented in TProofPlayerSuperMaster.; Definition at line 4130 of file TProofPlayer.cxx. ◆ HistoSameAxis(). Bool_t TProofPlayerRemote::HistoSameAxis ; (; TH1 * ; h0, . TH1 * ; h1 . ). Return kTRUE is the histograms 'h0' and 'h1' have the same binning and ranges on the axis (i.e. ; if they can be just Add-ed for merging). ; Definition at line 3811 of file TProofPlayer.cxx. ◆ Incorporate(). Int_t TProofPlayerRemote::Incorporate ; (; TObject * ; newobj, . TList * ; outlist, . Bool_t & ; merged . ). Incorporate object 'newobj' in the list 'outlist'. ; The object is merged with an object of the same name already existing in the list, or just added. The boolean merged is set to kFALSE when the object is just added to 'outlist'; this happens if the Merge() method does not exist or if a object named as 'obj' is not already in the list. If the obj is not 'merged' than it should not be deleted, unless outlist is not owner of its objects. Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:29557,feedback,feedback,29557,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"ool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:69518,clear,clearShapeDirty,69518,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,3,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,"ool_t TGTextView::HandleDNDLeave ; (; ). overridevirtual . Handle Drag Leave event. ; Reimplemented from TGFrame.; Definition at line 1162 of file TGTextView.cxx. ◆ HandleDNDPosition(). Atom_t TGTextView::HandleDNDPosition ; (; Int_t ; x, . Int_t ; y, . Atom_t ; action, . Int_t ; xroot, . Int_t ; yroot . ). overridevirtual . Handle Drag position event. ; Reimplemented from TGFrame.; Definition at line 1136 of file TGTextView.cxx. ◆ HandleDoubleClick(). Bool_t TGTextView::HandleDoubleClick ; (; Event_t * ; event). overridevirtual . handle double click ; Reimplemented from TGCompositeFrame.; Definition at line 902 of file TGTextView.cxx. ◆ HandleMotion(). Bool_t TGTextView::HandleMotion ; (; Event_t * ; event). overridevirtual . Handle mouse motion event in the text editor widget. ; Reimplemented from TGCompositeFrame.; Definition at line 910 of file TGTextView.cxx. ◆ HandleSelectionClear(). Bool_t TGTextView::HandleSelectionClear ; (; Event_t * ; event). overridevirtual . Handle selection clear event. ; Reimplemented from TGFrame.; Definition at line 956 of file TGTextView.cxx. ◆ HandleSelectionRequest(). Bool_t TGTextView::HandleSelectionRequest ; (; Event_t * ; event). overridevirtual . Handle request to send current clipboard contents to requestor window. ; Reimplemented from TGFrame.; Definition at line 967 of file TGTextView.cxx. ◆ HandleTimer(). Bool_t TGTextView::HandleTimer ; (; TTimer * ; t). overridevirtual . Handle scroll timer. ; Reimplemented from TObject.; Definition at line 719 of file TGTextView.cxx. ◆ HLayout(). void TGTextView::HLayout ; (; ). protectedvirtual . Horizontal layout of widgets (canvas, scrollbar). ; Definition at line 1338 of file TGTextView.cxx. ◆ Init(). void TGTextView::Init ; (; Pixel_t ; bg). protected . Initialize a text view widget. ; Definition at line 73 of file TGTextView.cxx. ◆ IsA(). TClass * TGTextView::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGCompositeFrame.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextView.html:47352,clear,clear,47352,doc/master/classTGTextView.html,https://root.cern,https://root.cern/doc/master/classTGTextView.html,1,['clear'],['clear']
Usability,"ool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs; return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Loop over components for plot sampling hints and merge them if there are multiple. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Loop over components for plot sampling hints and merge them if there are multiple. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; P.d.f is self normalized. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return list of coefficients of component p.d.f.s. const RooArgSet& getCoefNormalization() const; { return _refCoefNorm ; }. const char* getCoefRange() const; { return _refCoefRangeName?RooNameReg::str(_refCoefRangeName):"""" ; }. CacheElem* getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const. » Last changed: Fri Dec 2 14:26:40 2011 » Last generated: 2011-12-02 14:26; This page ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:49705,intuit,intuitively,49705,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,1,['intuit'],['intuitively']
Usability,"ool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParaEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoParaEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoX(); Slot for X. void DoY(); Slot for Y. void DoZ(); Slot for Z. void DoAlpha(); Slot for alpha. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoParaEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoParaEditor.html:21334,undo,undoing,21334,root/html528/TGeoParaEditor.html,https://root.cern,https://root.cern/root/html528/TGeoParaEditor.html,1,['undo'],['undoing']
Usability,"ool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParaEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoParaEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoX(); Slot for X. void DoY(); Slot for Y. void DoZ(); Slot for Z. void DoAlpha(); Slot for alpha. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoParaEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoParaEditor.html:21434,undo,undoing,21434,root/html530/TGeoParaEditor.html,https://root.cern,https://root.cern/root/html530/TGeoParaEditor.html,1,['undo'],['undoing']
Usability,"ool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParaEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoParaEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoX(); Slot for X. void DoY(); Slot for Y. void DoZ(); Slot for Z. void DoAlpha(); Slot for alpha. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoParaEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoParaEditor.html:21434,undo,undoing,21434,root/html532/TGeoParaEditor.html,https://root.cern,https://root.cern/root/html532/TGeoParaEditor.html,1,['undo'],['undoing']
Usability,"oot/minuit:$Id$; 2// Author: Rene Brun, Frederick James 12/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13/*! \class TMinuit; 14\see Minuit2 for a newer version of this package; 15\ingroup MinuitOld; 16 ; 17Implementation in C++ of the Minuit package written by Fred James.; 18This is a straightforward conversion of the original Fortran version.; 19 ; 20The main changes are:; 21 ; 22 - The variables in the various Minuit labelled common blocks; 23 have been changed to the TMinuit class data members.; 24 ; 25 - The internal arrays with a maximum dimension depending on the; 26 maximum number of parameters are now data members arrays with; 27 a dynamic dimension such that one can fit very large problems; 28 by simply initialising the TMinuit constructor with the maximum; 29 number of parameters.; 30 ; 31 - The include file Minuit.h has been commented as much as possible; 32 using existing comments in the code or the printed documentation; 33 ; 34 - The original Minuit subroutines are now member functions.; 35 ; 36 - Constructors and destructor have been added.; 37 ; 38 - Instead of passing the FCN function in the argument; 39 list, the addresses of this function is stored as pointer; 40 in the data members of the class. This is by far more elegant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:1254,simpl,simply,1254,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['simpl'],['simply']
Usability,"ootFinder::~GSLMultiRootFinder ; (; ). virtual . destructor ; Definition at line 95 of file GSLMultiRootFinder.cxx. ◆ GSLMultiRootFinder() [4/5]. ROOT::Math::GSLMultiRootFinder::GSLMultiRootFinder ; (; const GSLMultiRootFinder & ; ). delete . ◆ GSLMultiRootFinder() [5/5]. ROOT::Math::GSLMultiRootFinder::GSLMultiRootFinder ; (; GSLMultiRootFinder && ; ). delete . Member Function Documentation. ◆ AddFunction() [1/2]. int ROOT::Math::GSLMultiRootFinder::AddFunction ; (; const ROOT::Math::IMultiGenFunction & ; func). Definition at line 110 of file GSLMultiRootFinder.cxx. ◆ AddFunction() [2/2]. template<class Function > . int ROOT::Math::GSLMultiRootFinder::AddFunction ; (; Function & ; f, . int ; ndim . ). inline . same method as before but using any function implementing the operator(), so can be wrapped in a IMultiGenFunction interface ; Definition at line 193 of file GSLMultiRootFinder.h. ◆ Clear(). void ROOT::Math::GSLMultiRootFinder::Clear ; (; ). clear list of functions ; Definition at line 127 of file GSLMultiRootFinder.cxx. ◆ ClearFunctions(). void ROOT::Math::GSLMultiRootFinder::ClearFunctions ; (; ). protected . Definition at line 118 of file GSLMultiRootFinder.cxx. ◆ Dim(). unsigned int ROOT::Math::GSLMultiRootFinder::Dim ; (; ); const. inline . return the number of sunctions set in the class. ; The number must be equal to the dimension of the functions ; Definition at line 203 of file GSLMultiRootFinder.h. ◆ Dx(). const double * ROOT::Math::GSLMultiRootFinder::Dx ; (; ); const. return the last step size ; Definition at line 139 of file GSLMultiRootFinder.cxx. ◆ FVal(). const double * ROOT::Math::GSLMultiRootFinder::FVal ; (; ); const. return the function values f(X) solving the system i.e. ; they must be close to zero at the solution ; Definition at line 143 of file GSLMultiRootFinder.cxx. ◆ GetType(). std::pair< bool, int > ROOT::Math::GSLMultiRootFinder::GetType ; (; const char * ; name). protected . Definition at line 207 of file GSLMultiRootFinder.cxx. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootFinder.html:7787,clear,clear,7787,doc/master/classROOT_1_1Math_1_1GSLMultiRootFinder.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootFinder.html,1,['clear'],['clear']
Usability,"oot_fsolver).; Default algorithm is ""hybrids"" (without derivative). virtual ~GSLMultiRootFinder(); destructor. GSLMultiRootFinder(const GSLMultiRootFinder &); usually copying is non trivial, so we make this unaccessible. void SetType(EType type); set the type for an algorithm without derivatives. void SetType(EDerivType type); set the type of algorithm using derivatives. void SetType(const char* name); set the type using a string. int AddFunction(const ROOT::Math::IMultiGenFunction& func). add (set) a single function fi(x1,...xn) which is part of the system of; specifying the begin and end of the iterator.; If using a derivative type algorithm the function must implement the; ROOOT::Math::IMultiGradFunction interface; Return the current number of function in the list and 0 if failed to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__GSLMultiRootFinder.html:5883,clear,clear,5883,root/html530/ROOT__Math__GSLMultiRootFinder.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMultiRootFinder.html,2,['clear'],['clear']
Usability,"ootcint to generate; the dictionary.; If option = ""par"", create a PAR file with the minimal set of code needed to read the content; of the ROOT file. The name of the PAR file is basename(dirname), with extension; '.par' enforced; the PAR file will be created at dirname(dirname) .; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to generate a dirnameProjectDict.cxx file; - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; - a shared lib dirname.so will be created.; If the option ""++"" is specified, the generated shared lib is dynamically; linked with the current executable module.; If the option ""+"" and ""nocompile"" are specified, the utility files are generated; as in the option ""+"" but they are not executed.; Example:; file.MakeProject(""demo"",""*"",""recreate++"");; - creates a new directory demo unless it already exist; - clear the previous directory content; - generate the xxx.h files for all classes xxx found in this file; and not yet known to the CINT dictionary.; - creates the build script MAKEP; - creates a LinkDef.h file; - runs rootcint generating demoProjectDict.cxx; - compiles demoProjectDict.cxx into demoProjectDict.o; - generates a shared lib demo.so; - dynamically links the shared lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. Int_t MakeProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is give",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:44170,clear,clear,44170,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,4,['clear'],['clear']
Usability,oothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlcreatedb.py Create a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlfilldb.py Fill run catalog with nfiles entries ;  SQLiteIPLocation.C ;  SQLitePlatformDistribution.C ;  SQLiteTimeVersionOfRoot.C ;  SQLiteVersionsOfRoot.C ;  sqlselect.CQuery example to MySQL test database ;  sqlselect.py Query example to MySQL test database ;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVACrossValida,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:164415,simpl,simple,164415,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"operties just; 37after the first creation of a volume namespace, since in case of volume families; 38any new member created by the modeler inherits these properties.; 39 ; 40 In order to provide navigation features, volumes have to be able to find; 41the proper container of any point defined in the local reference frame. This; 42can be the volume itself, one of its positioned daughter volumes or none if; 43the point is actually outside. On the other hand, volumes have to provide also; 44other navigation methods such as finding the distances to its shape boundaries; 45or which daughter will be crossed first. The implementation of these features; 46is done at shape level, but the local mother-daughters management is handled; 47by volumes that builds additional optimisation structures upon geometry closure.; 48In order to have navigation features properly working one has to follow the; 49general rules for building a valid geometry (see TGeoManager class).; 50 ; 51 Now let's make a simple volume representing a copper wire. We suppose that; 52a medium is already created (see TGeoMedium class on how to create media).; 53We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm; 54and a half-length dZ=1cm :; 55 ; 56~~~ {.cpp}; 57 TGeoTube *tube = new TGeoTube(""wire_tube"", 0, 0.01, 1);; 58~~~; 59 ; 60One may omit the name for the shape if no retrieving by name is further needed; 61during geometry building. The same shape can be shared by different volumes; 62having different names and materials. Now let's make the volume for our wire.; 63The prototype for volumes constructor looks like :; 64 ; 65 TGeoVolume::TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med); 66 ; 67Since TGeoTube derives from the base shape class, we can provide it to the volume; 68constructor :; 69 ; 70~~~ {.cpp}; 71 TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);; 72~~~; 73 ; 74Do not bother to delete neither the media, shapes or volumes that you have; 75create",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:3234,simpl,simple,3234,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['simpl'],['simple']
Usability,"option.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==1) Hoption.Same += 1;; 4603 goto paintstat;; 4604 }; 4605 if (gridx || gridy) PaintAxis(kTRUE); // Draw the grid only; 4606 ; 4607 // test for opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:173391,clear,clear,173391,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"options (their key words). ; That can be set in the option string.; know options:. nTrees number of trees in the forest to be created; BoostType the boosting type for the trees in the forest (AdaBoost e.t.c..). Known:; AdaBoost; AdaBoostR2 (Adaboost for regression); Bagging; GradBoost. AdaBoostBeta the boosting parameter, beta, for AdaBoost; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; UsePoisson Nvars use UseNvars not as fixed number but as mean of a poisson distribution; SeparationType the separation criterion applied in the node splitting. Known:; GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB. MinNodeSize: minimum percentage of training events in a leaf node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterion; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine misclassification error rate); PruneMethod The Pruning method. Known:; NoPruning // switch off pruning completely; ExpectedError; CostComplexity. PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment; IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal Pair ev. with neg. and pos. weights in training sample and ""annihilate"" them. MaxDepth maximum depth of the decision tree allowed before further splitting is stopped; SkipNormali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:47100,simpl,simply,47100,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['simpl'],['simply']
Usability,"options to be called before options are read from stream ;  ; void WriteOptionsReferenceToFile ();  write complete options to output stream ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; void AdjustSynapseWeights ();  just adjust the synapse weights (should be called in batch mode) ;  ; void BackPropagationMinimize (Int_t nEpochs);  minimize estimator / train network with back propagation algorithm ;  ; void BFGSMinimize (Int_t nEpochs);  train network with BFGS algorithm ;  ; Double_t CalculateEstimator (Types::ETreeType treeType=Types::kTraining, Int_t iEpoch=-1);  calculate the estimator that training is attempting to minimize ;  ; void CalculateNeuronDeltas ();  have each neuron calculate its delta by back propagation ;  ; void ComputeDEDw ();  ; void DecaySynapseWeights (Bool_t lateEpoch);  decay synapse weights in last 10 epochs, lower learning rate even more to find a good minimum ;  ; void DeclareOptions ();  define the options (their key words) that can be set in the option string ;  ; Double_t DerivDir (TMatrixD &Dir);  ; void GeneticMinimize ();  create genetics class similar to GeneticCut give it vector of parameter ranges (parameters = weights) link fitness function of this class to ComputeEstimator instantiate GA (see MethodCuts) run it then this should exist for GA, Minuit and random sampling ;  ; void GetApproxInvHessian (TMatrixD &InvHessian, bool regulate=true);  rank-1 approximation, neglect 2nd derivatives. //zjh ;  ; Double_t GetCEErr (const Event *ev, UInt_t index=0);  zjh ;  ; Double_t GetDesiredOutput (const Event *ev);  get the desired output of this event ;  ; Double_t GetError ();  ; Bool_t GetHessian (TMatrixD &Hessian, TMatrixD &Gamma, TMatrixD &Delta);  ; Double_t GetMSEErr (const Event *ev, UInt_t index=0);  zjh ;  ; void Init ();  default init",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:31407,learn,learning,31407,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['learn'],['learning']
Usability,"options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:20690,simpl,simple,20690,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,1,['simpl'],['simple']
Usability,"opy c'tor of LayerData ;  ;  LayerData (const_iterator_type itInputBegin, const_iterator_type itInputEnd, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  LayerData (LayerData &&other);  move c'tor of LayerData ;  ;  LayerData (size_t inputSize);  c'tor of LayerData ;  ;  LayerData (size_t size, const_iterator_type itWeightBegin, iterator_type itGradientBegin, std::shared_ptr< std::function< double(double)> > activationFunction, std::shared_ptr< std::function< double(double)> > inverseActivationFunction, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  LayerData (size_t size, const_iterator_type itWeightBegin, std::shared_ptr< std::function< double(double)> > activationFunction, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  ~LayerData ();  ; std::shared_ptr< std::function< double(double)> > activationFunction () const;  ; void clear ();  clear the values and the deltas ;  ; void clearDropOut ();  clear the drop-out-data for this layer ;  ; iterator_type deltasBegin ();  returns iterator to the begin of the deltas (back-propagation) ;  ; const_iterator_type deltasBegin () const;  returns const iterator to the begin of the deltas (back-propagation) ;  ; iterator_type deltasEnd ();  returns iterator to the end of the deltas (back-propagation) ;  ; const_iterator_type deltasEnd () const;  returns const iterator to the end of the deltas (back-propagation) ;  ; const_dropout_iterator dropOut () const;  return the begin of the drop-out information ;  ; iterator_type gradientsBegin ();  returns iterator to the begin of the gradients ;  ; const_iterator_type gradientsBegin () const;  returns const iterator to the begin of the gradients ;  ; bool hasDropOut () const;  has this layer drop-out turned on? ;  ; std::shared_ptr< std::function< double(double)> > inverseActivationFunction () const;  ; ModeOutputValues outputMode () const;  returns the output mode ;  ; container_type ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html:1982,clear,clearDropOut,1982,doc/master/classTMVA_1_1DNN_1_1LayerData.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html,1,['clear'],['clearDropOut']
Usability,"opy constructor (disabled, class is not copyable) ;  ;  Fitter (const std::shared_ptr< FitResult > &result);  Constructor from a result. ;  ; virtual ~Fitter ();  Destructor. ;  ; bool ApplyWeightCorrection (const ROOT::Math::IMultiGenFunction &loglw2, bool minimizeW2L=false);  apply correction in the error matrix for the weights for likelihood fits This method can be called only after a fit. ;  ; bool CalculateHessErrors ();  perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the Hessian matrix To be called only after fitting and when a minimizer supporting the Hessian calculations is used otherwise an error (false) is returned. ;  ; bool CalculateMinosErrors ();  perform an error analysis on the result using MINOS To be called only after fitting and when a minimizer supporting MINOS is used otherwise an error (false) is returned. ;  ; FitConfig & Config ();  access to the configuration (non const method) ;  ; const FitConfig & Config () const;  access to the fit configuration (const method) ;  ; bool EvalFCN ();  Perform a simple FCN evaluation. ;  ; bool Fit (const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential);  Fit a binned data set using a least square fit. ;  ; template<class Data , class Function , class cond = typename std::enable_if<!(std::is_same<Function, ROOT::EExecutionPolicy>::value || std::is_same<Function, int>::value), Function>::type> ; bool Fit (const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential);  fit a data set using any generic model function If data set is binned a least square fit is performed If data set is unbinned a maximum likelihood fit (not extended) is done Pre-requisite on the function: it must implement the 1D or multidimensional parametric function interface. ;  ; bool Fit (const std::shared_ptr< BinData > &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html:3166,simpl,simple,3166,doc/master/classROOT_1_1Fit_1_1Fitter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html,1,['simpl'],['simple']
Usability,"or (; itG != itGEnd; ++itG, ++itPrevG); 319 {; 320 double currGrad = (*itG);; 321 double prevGrad = (*itPrevG);; 322 currGrad *= alpha;; 323 ; 324 //(*itPrevG) = m_beta * (prevGrad + currGrad);; 325 currGrad += prevGrad;; 326 (*itG) = currGrad;; 327 (*itPrevG) = currGrad;; 328 ; 329 if (std::fabs (currGrad) > maxGrad); 330 maxGrad = currGrad;; 331 }; 332 ; 333 if (maxGrad > 1); 334 {; 335 m_alpha /= 2;; 336 std::cout << ""\nlearning rate reduced to "" << m_alpha << std::endl;; 337 std::for_each (weights.begin (), weights.end (), [maxGrad](double& w); 338 {; 339 w /= maxGrad;; 340 });; 341 m_prevGradients.clear ();; 342 }; 343 else; 344 {; 345 auto itW = std::begin (weights);; 346 std::for_each (std::begin (m_localGradients), std::end (m_localGradients), [&itW](double& g); 347 {; 348 *itW += g;; 349 ++itW;; 350 });; 351 }; 352 ; 353 ++currentRepetition;; 354 }; 355 return E;; 356 }; 357 ; 358 ; 359 ; 360 ; 361 ; 362 ; 363 ; 364 ; 365 ; 366 ; 367 ; 368 ; 369 ; 370 ; 371 ; 372 ; 373 ; 374 ; 375 ; 376 ; 377/*! \brief sum of squares error function; 378 *; 379 *; 380 */; 381 template <typename ItOutput, typename ItTruth, typename ItDelta, typename InvFnc>; 382 double sumOfSquares (ItOutput itOutputBegin, ItOutput itOutputEnd, ItTruth itTruthBegin, ItTruth /*itTruthEnd*/, ItDelta itDelta, ItDelta itDeltaEnd, InvFnc invFnc, double patternWeight); 383 {; 384 double errorSum = 0.0;; 385 ; 386 // output - truth; 387 ItTruth itTruth = itTruthBegin;; 388 bool hasDeltas = (itDelta != itDeltaEnd);; 389 for (ItOutput itOutput = itOutputBegin; itOutput != itOutputEnd; ++itOutput, ++itTruth); 390 {; 391// assert (itTruth != itTruthEnd);; 392 double output = (*itOutput);; 393 double error = output - (*itTruth);; 394 if (hasDeltas); 395 {; 396 (*itDelta) = (*invFnc.get ()) (output) * error * patternWeight;; 397 ++itDelta;; 398 }; 399 errorSum += error*error * patternWeight;; 400 }; 401 ; 402 return 0.5*errorSum;; 403 }; 404 ; 405 ; 406 ; 407/*! \brief cross entropy error function; 408 *;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:10426,clear,clear,10426,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['clear'],['clear']
Usability,"or a given likelihood and set of parameters of interest. ; The value return by RooProfileLL is the input likelihood nll minimized w.r.t all nuisance parameters (which are all parameters except for those listed in the constructor) minus the -log(L) of the best fit. Note that this function is slow to evaluate as a MIGRAD minimization step is executed for each function evaluation ; Definition at line 22 of file RooProfileLL.h. Public Member Functions;  RooProfileLL ();  Default constructor Should only be used by proof. ;  ;  RooProfileLL (const char *name, const char *title, RooAbsReal &nll, const RooArgSet &observables);  Constructor of profile likelihood given input likelihood nll w.r.t the given set of variables. ;  ;  RooProfileLL (const RooProfileLL &other, const char *name=nullptr);  Copy constructor. ;  ; bool alwaysStartFromMin () const;  ; const RooArgSet & bestFitObs () const;  ; const RooArgSet & bestFitParams () const;  ; void clearAbsMin ();  ; TObject * clone (const char *newname) const override;  ; RooFit::OwningPtr< RooAbsReal > createProfile (const RooArgSet &paramsOfInterest) override;  Optimized implementation of createProfile for profile likelihoods. ;  ; TClass * IsA () const override;  ; RooMinimizer * minimizer ();  ; RooAbsReal & nll ();  ; Int_t numEval () const;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Function that is called at the end of redirectServers(). ;  ; void setAlwaysStartFromMin (bool flag);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProfileLL.html:1326,clear,clearAbsMin,1326,doc/master/classRooProfileLL.html,https://root.cern,https://root.cern/doc/master/classRooProfileLL.html,1,['clear'],['clearAbsMin']
Usability,"or a tools which produce RooStats ConfIntervals. More...;  ; struct  LikelihoodFunction;  ; class  LikelihoodInterval;  LikelihoodInterval is a concrete implementation of the RooStats::ConfInterval interface. More...;  ; class  LikelihoodIntervalPlot;  This class provides simple and straightforward utilities to plot a LikelihoodInterval object. More...;  ; class  MarkovChain;  Stores the steps in a Markov Chain of points. More...;  ; class  MaxLikelihoodEstimateTestStat;  MaxLikelihoodEstimateTestStat: TestStatistic that returns maximum likelihood estimate of a specified parameter. More...;  ; class  MCMCCalculator;  Bayesian Calculator estimating an interval or a credible region using the Markov-Chain Monte Carlo method to integrate the likelihood function with the prior to obtain the posterior function. More...;  ; class  MCMCInterval;  MCMCInterval is a concrete implementation of the RooStats::ConfInterval interface. More...;  ; class  MCMCIntervalPlot;  This class provides simple and straightforward utilities to plot a MCMCInterval object. More...;  ; class  MetropolisHastings;  This class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo. More...;  ; class  MinNLLTestStat;  MinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic. More...;  ; class  ModelConfig;  ModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools. More...;  ; class  NeymanConstruction;  NeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction. More...;  ; class  NuisanceParametersSampler;  Helper class for ToyMCSampler. More...;  ; class  NumberCountingPdfFactory;  A factory for building PDFs and data for a number counting combination. More...;  ; clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:4463,simpl,simple,4463,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['simpl'],['simple']
Usability,"or and then steal its buffer.; 1055 if (!RHS.isSmall()) {; 1056 if (this->Owns()) {; 1057 this->destroy_range(this->begin(), this->end());; 1058 if (!this->isSmall()); 1059 free(this->begin());; 1060 }; 1061 this->fBeginX = RHS.fBeginX;; 1062 this->fSize = RHS.fSize;; 1063 this->fCapacity = RHS.fCapacity;; 1064 RHS.resetToSmall();; 1065 return *this;; 1066 }; 1067 ; 1068 // If we already have sufficient space, assign the common elements, then; 1069 // destroy any excess.; 1070 size_t RHSSize = RHS.size();; 1071 size_t CurSize = this->size();; 1072 if (CurSize >= RHSSize) {; 1073 // Assign common elements.; 1074 iterator NewEnd = this->begin();; 1075 if (RHSSize); 1076 NewEnd = std::move(RHS.begin(), RHS.end(), NewEnd);; 1077 ; 1078 // Destroy excess elements and trim the bounds.; 1079 if (this->Owns()); 1080 this->destroy_range(NewEnd, this->end());; 1081 this->set_size(RHSSize);; 1082 ; 1083 // Clear the RHS.; 1084 RHS.clear();; 1085 ; 1086 return *this;; 1087 }; 1088 ; 1089 // If we have to grow to have enough elements, destroy the current elements.; 1090 // This allows us to avoid copying them during the grow.; 1091 // From the original LLVM implementation:; 1092 // FIXME: this may not actually make any sense if we can efficiently move; 1093 // elements.; 1094 if (this->capacity() < RHSSize) {; 1095 if (this->Owns()) {; 1096 // Destroy current elements.; 1097 this->destroy_range(this->begin(), this->end());; 1098 }; 1099 this->set_size(0);; 1100 CurSize = 0;; 1101 this->grow(RHSSize);; 1102 } else if (CurSize) {; 1103 // Otherwise, use assignment for the already-constructed elements.; 1104 std::move(RHS.begin(), RHS.begin() + CurSize, this->begin());; 1105 }; 1106 ; 1107 // Move-construct the new elements in place.; 1108 this->uninitialized_move(RHS.begin() + CurSize, RHS.end(), this->begin() + CurSize);; 1109 ; 1110 // Set end.; 1111 this->set_size(RHSSize);; 1112 ; 1113 RHS.clear();; 1114 return *this;; 1115}; 1116 ; 1117template <typename T>; 1118bool IsSmall(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:37688,clear,clear,37688,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['clear'],['clear']
Usability,"or categorizing the phase space. More...;  ; class  TMVA::MethodCFMlpANN;  Interface to Clermond-Ferrand artificial neural network. More...;  ; class  TMVA::MethodCFMlpANN_Utils;  Implementation of Clermond-Ferrand artificial neural network. More...;  ; class  TMVA::MethodCompositeBase;  Virtual base class for combining several TMVA method. More...;  ; class  TMVA::MethodCrossValidation;  ; class  TMVA::MethodCuts;  Multivariate optimisation of signal efficiency for given background efficiency, applying rectangular minimum and maximum requirements. More...;  ; class  TMVA::MethodDNN;  Deep Neural Network Implementation. More...;  ; class  TMVA::MethodDT;  Analysis of Boosted Decision Trees. More...;  ; class  TMVA::MethodFDA;  Function discriminant analysis (FDA). More...;  ; class  TMVA::MethodFisher;  Fisher and Mahalanobis Discriminants (Linear Discriminant Analysis) More...;  ; class  TMVA::MethodHMatrix;  H-Matrix method, which is implemented as a simple comparison of chi-squared estimators for signal and background, taking into account the linear correlations between the input variables. More...;  ; class  TMVA::MethodKNN;  Analysis of k-nearest neighbor. More...;  ; class  TMVA::MethodLD;  Linear Discriminant. More...;  ; class  TMVA::MethodLikelihood;  Likelihood analysis (""non-parametric approach"") More...;  ; class  TMVA::MethodMLP;  Multilayer Perceptron class built off of MethodANNBase. More...;  ; class  TMVA::MethodPDEFoam;  The PDEFoam method is an extension of the PDERS method, which divides the multi-dimensional phase space in a finite number of hyper-rectangles (cells) of constant event density. More...;  ; class  TMVA::MethodPDERS;  This is a generalization of the above Likelihood methods to \( N_{var} \) dimensions, where \( N_{var} \) is the number of input variables used in the MVA. More...;  ; class  TMVA::MethodRuleFit;  J Friedman's RuleFit method. More...;  ; class  TMVA::MethodSVM;  SMO Platt's SVM classifier with Keerthi & Shavade improve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__TMVA.html:6556,simpl,simple,6556,doc/master/group__TMVA.html,https://root.cern,https://root.cern/doc/master/group__TMVA.html,1,['simpl'],['simple']
Usability,or future normalizations; 638 if ( fNPoints == 1 ); 639 fRefVolume = binVolume;; 640 else if ( binVolume < fRefVolume ); 641 fRefVolume = binVolume;; 642 }; 643 ; 644 ; 645 void BinData::InitDataVector (); 646 {; 647 fData.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 648 fDataPtr = fData.empty() ? nullptr : &fData.front();; 649 }; 650 ; 651 void BinData::InitializeErrors(); 652 {; 653 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 654 kAsymError == fErrorType || kNoError == fErrorType );; 655 ; 656 if ( fpTmpCoordErrorVector ); 657 {; 658 delete[] fpTmpCoordErrorVector;; 659 fpTmpCoordErrorVector = nullptr;; 660 }; 661 ; 662 if ( kNoError == fErrorType ); 663 {; 664 fCoordErrors.clear();; 665 fCoordErrorsPtr.clear();; 666 ; 667 fDataErrorHigh.clear();; 668 fDataErrorHighPtr = nullptr;; 669 ; 670 fDataErrorLow.clear();; 671 fDataErrorLowPtr = nullptr;; 672 ; 673 fDataError.clear();; 674 fDataErrorPtr = nullptr;; 675 ; 676 return;; 677 }; 678 ; 679 if ( kCoordError == fErrorType || kAsymError == fErrorType ); 680 {; 681 fCoordErrorsPtr.resize( fDim );; 682 fCoordErrors.resize( fDim );; 683 for( unsigned int i=0; i < fDim; i++ ); 684 {; 685 fCoordErrors[i].resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 686 ; 687 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 688 }; 689 ; 690 fpTmpCoordErrorVector = new double[fDim];; 691 }; 692 else; 693 {; 694 fCoordErrors.clear();; 695 fCoordErrorsPtr.clear();; 696 }; 697 ; 698 if ( kValueError == fErrorType || kCoordError == fErrorType ); 699 {; 700 fDataError.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 701 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 702 ; 703 fDataErrorHigh.clear();; 704 fDataErrorHighPtr = nullptr;; 705 fDataErrorLow.clear();; 706 fDataErrorLowPtr = nullptr;; 707 }; 708 else if ( fErrorType == kAsymError ); 709 {; 710 fDataErrorHigh.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 711 fDa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:20628,clear,clear,20628,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj, Bool_t& merged); Low statistic histograms need a special treatment when using autobin. Bool_t HistoSameAxis(TH1* h0, TH1* h1); Return kTRUE is the histograms 'h0' and 'h1' have the same binning and ranges; on the axis (i.e. if they can be just Add-ed for merging). void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of feedback objects. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet for specified slave. Bool_t IsClient() const; Is the player running on the client?. Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (support for TChain::Draw()).; Returns -1 in case of error or number of selected events in case of success. void SetInitTime(); Set init time. TVirtualPacketizer * GetPacketizer() const; { return 0; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProof * GetProof() const; { return fProof; }. TProofPlayerRemote(TProof* proof = 0); { fProgressStatus = new TProofProgressStatus(); }. TProofPlayerRemote(const TProofP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerRemote.html:22422,feedback,feedback,22422,root/html602/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html602/TProofPlayerRemote.html,2,['feedback'],['feedback']
Usability,"or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj, Bool_t& merged); Low statistic histograms need a special treatment when using autobin. Bool_t HistoSameAxis(TH1* h0, TH1* h1); Return kTRUE is the histograms 'h0' and 'h1' have the same binning and ranges; on the axis (i.e. if they can be just Add-ed for merging). void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of feedback objects. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet for specified slave. Bool_t IsClient() const; Is the player running on the client?. Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (support for TChain::Draw()).; Returns -1 in case of error or number of selected events in case of success. void SetInitTime(); Set init time. TVirtualPacketizer * GetPacketizer() const; { return 0; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProof * GetProof() const; { return fProof; }. TProofPlayerRemote(TProof* proof = 0); { fProgressStatus = new TProofProgressStatus(); }. » Author: Maarten Ballintijn 07/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerRemote.html:19479,feedback,feedback,19479,root/html532/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html532/TProofPlayerRemote.html,2,['feedback'],['feedback']
Usability,"or lhr_calc to plot over; norm_set = ROOT.RooArgSet(x_vars); lhr_calc_final_ptr = ROOT.RooFit.Detail.compileForNormSet(lhr_calc, norm_set); lhr_calc_final = ROOT.my_deref(lhr_calc_final_ptr); lhr_calc_final.recursiveRedirectServers(norm_set); ; # Plot the likelihood ratio functions; frame2 = x_vars[0].frame(Title=""Likelihood ratio r(x_{1}|#mu_{1}=2.5);x_{1};p_{gauss}/p_{uniform}""); lhr_learned.plotOn(frame2, LineColor=""kP6Blue"", Name=""learned_ratio""); lhr_calc_final.plotOn(frame2, LineColor=""kP6Blue+1"", Name=""exact""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.8); frame1.Draw(); ; legend1 = ROOT.TLegend(0.43, 0.63, 0.8, 0.87); legend1.SetFillColor(ROOT.kWhite); legend1.SetLineColor(ROOT.kWhite); legend1.SetTextSize(0.04); legend1.AddEntry(""learned"", ""learned (SBI)"", ""L""); legend1.AddEntry(""gauss"", ""true NLL"", ""L""); legend1.AddEntry(""morphed"", ""moment morphing"", ""L""); legend1.Draw(); ; if single_canvas:; c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); else:; c.SaveAs(""rf617_plot_1.png""); c = ROOT.TCanvas("""", """", 600, 600); ; frame2.Draw(); ; legend2 = ROOT.TLegend(0.53, 0.73, 0.87, 0.87); legend2.SetFillColor(ROOT.kWhite); legend2.SetLineColor(ROOT.kWhite); legend2.SetTextSize(0.04); legend2.AddEntry(""learned_ratio"", ""learned (SBI)"", ""L""); legend2.AddEntry(""exact"", ""true ratio"", ""L""); legend2.Draw(); ; if not single_canvas:; c.SaveAs(""rf617_plot_2.png""); ; ; # Use ROOT's minimizer to compute the minimum and display the results; for nll in [nll_gauss, nllr_learned, nll_morph]:; minimizer = ROOT.RooMinimizer(nll); minimizer.setErrorLevel(0.5); minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); result.Print(); ; import sys; ; # Hack to bypass ClearProxiedObjects(); del sys.m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:10892,learn,learned,10892,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html,2,['learn'],['learned']
Usability,"or monitoring and logggingDefinition NeuralNet.h:806; TMVA::DNN::Settings::m_convergenceStepssize_t m_convergenceStepsnumber of steps without improvement to consider the DNN to have convergedDefinition NeuralNet.h:837; TMVA::DNN::Settings::hasConvergedvirtual bool hasConverged(double testError)has this training converged already?Definition NeuralNet.cxx:485; TMVA::DNN::Settings::minimizerTypeMinimizerType minimizerType() constwhich minimizer shall be used (e.g. SGD)Definition NeuralNet.h:774; TMVA::DNN::Settings::m_dropOutstd::vector< double > m_dropOutDefinition NeuralNet.h:850; TMVA::DNN::Settings::m_minProgressdouble m_minProgresscurrent limits for the progress barDefinition NeuralNet.h:833; TMVA::DNN::Settings::cyclevirtual void cycle(double progress, TString text)Definition NeuralNet.h:799; TMVA::DNN::Settings::setProgressLimitsvirtual void setProgressLimits(double minProgress=0, double maxProgress=100)Definition NeuralNet.h:790; TMVA::DNN::Settings::m_maxProgressdouble m_maxProgresscurrent limits for the progress barDefinition NeuralNet.h:834; TMVA::DNN::Settings::endTrainCyclevirtual void endTrainCycle(double)callback for monitoring and loggingDefinition NeuralNet.h:788; TMVA::DNN::Settings::count_dEsize_t count_dEDefinition NeuralNet.h:843; TMVA::DNN::Settings::drawSamplevirtual void drawSample(const std::vector< double > &, const std::vector< double > &, const std::vector< double > &, double)callback for monitoring and loggingDefinition NeuralNet.h:807; TMVA::DNN::Settings::learningRatedouble learningRate() constget the learning rateDefinition NeuralNet.h:771; TMVA::DNN::Settings::m_dropRepetitionsdouble m_dropRepetitionsDefinition NeuralNet.h:849; TMVA::DNN::Settings::dropFractionsconst std::vector< double > & dropFractions() constDefinition NeuralNet.h:762; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::~Settingsvirtual ~Settings()d'torDefinition NeuralNet.cxx:261; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:74111,progress bar,progress barDefinition,74111,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['progress bar'],['progress barDefinition']
Usability,"or();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQCommand(const TQCommand& com); TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:2639,undo,undo,2639,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,4,['undo'],['undo']
Usability,"or();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQUndoManager(); virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:2638,undo,undo,2638,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,4,['undo'],['undo']
Usability,"or();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:2663,undo,undo,2663,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,2,['undo'],['undo']
Usability,"or();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:2662,undo,undo,2662,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,2,['undo'],['undo']
Usability,"or; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighbouring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int shadow; // determines whether shadow will be drawn (no shadow, shadow),; // for rainbowed display modes with shading according to light; int shading; // determines whether the picture will shaded, smoothed (no shading,; // shading), for rainbowed display modes only; int bezier; // determines Bezier interpolation (applies only for simple display; // modes group for grid, x_lines, y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:73012,simpl,simple,73012,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['simpl'],['simple']
Usability,"or<Event *>(allData.begin(), allData.begin() + nTrainingSamples);; 1143 const std::vector<Event *> testInputData =; 1144 std::vector<Event *>(allData.begin() + nTrainingSamples, allData.end());; 1145 ; 1146 if (trainingInputData.size() != nTrainingSamples) {; 1147 Log() << kFATAL << ""Inconsistent training sample size"" << Endl;; 1148 }; 1149 if (testInputData.size() != nTestSamples) {; 1150 Log() << kFATAL << ""Inconsistent test sample size"" << Endl;; 1151 }; 1152 ; 1153 size_t nThreads = 1;; 1154 TMVAInput_t trainingTuple = std::tie(trainingInputData, DataInfo());; 1155 TMVAInput_t testTuple = std::tie(testInputData, DataInfo());; 1156 DataLoader_t trainingData(trainingTuple, nTrainingSamples,; 1157 net.GetBatchSize(), net.GetInputWidth(),; 1158 net.GetOutputWidth(), nThreads);; 1159 DataLoader_t testData(testTuple, nTestSamples, testNet.GetBatchSize(),; 1160 net.GetInputWidth(), net.GetOutputWidth(),; 1161 nThreads);; 1162 DNN::TGradientDescent<TCpu<>> minimizer(settings.learningRate,; 1163 settings.convergenceSteps,; 1164 settings.testInterval);; 1165 ; 1166 std::vector<TNet<TCpu<>>> nets{};; 1167 std::vector<TBatch<TCpu<>>> batches{};; 1168 nets.reserve(nThreads);; 1169 for (size_t i = 0; i < nThreads; i++) {; 1170 nets.push_back(net);; 1171 for (size_t j = 0; j < net.GetDepth(); j++); 1172 {; 1173 auto &masterLayer = net.GetLayer(j);; 1174 auto &layer = nets.back().GetLayer(j);; 1175 TCpu<>::Copy(layer.GetWeights(),; 1176 masterLayer.GetWeights());; 1177 TCpu<>::Copy(layer.GetBiases(),; 1178 masterLayer.GetBiases());; 1179 }; 1180 }; 1181 ; 1182 bool converged = false;; 1183 size_t stepCount = 0;; 1184 size_t batchesInEpoch = nTrainingSamples / net.GetBatchSize();; 1185 ; 1186 std::chrono::time_point<std::chrono::system_clock> start, end;; 1187 start = std::chrono::system_clock::now();; 1188 ; 1189 if (!fInteractive) {; 1190 Log() << std::setw(10) << ""Epoch"" << "" | ""; 1191 << std::setw(12) << ""Train Err.""; 1192 << std::setw(12) << ""Test Err.""; 1193 << std::setw(12",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:42074,learn,learningRate,42074,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['learn'],['learningRate']
Usability,"or<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; const TMatrixDSym&covarianceMatrix() const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMultiVarGaussian.html:3381,clear,clearValueDirty,3381,root/html532/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html532/RooMultiVarGaussian.html,1,['clear'],['clearValueDirty']
Usability,"or=(const TMVA::RegressionVariance&); TMVA::RegressionVarianceRegressionVariance(); TMVA::RegressionVarianceRegressionVariance(const TMVA::RegressionVariance& s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nLeft, const Double_t& targetLeft, const Double_t& target2Left, const Double_t& nTot, const Double_t& targetTot, const Double_t& target2Tot); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system; for the Regression: as the ""Gain is maximised"", the RMS (sqrt(variance)); which is used as a ""separation"" index should be as small as possible.; the ""figure of merit"" here has to be -(rms left+rms-right) or 1/rms... Double_t GetSeparationIndex(const Double_t& n, const Double_t& target, const Double_t& target2); Separation Index: a simple Variance. RegressionVariance(); default constructor. {fName = ""Variance for Regression"";}. RegressionVariance(const TMVA::RegressionVariance& s); copy constructor. {}. virtual ~RegressionVariance(); destructor. {}. TString GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: RegressionVariance.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__RegressionVariance.html:2082,simpl,simple,2082,root/html532/TMVA__RegressionVariance.html,https://root.cern,https://root.cern/root/html532/TMVA__RegressionVariance.html,1,['simpl'],['simple']
Usability,"orD iclo(nrInEqual);; TVectorD icup(nrInEqual);; ; // simple square boundary condition : 0 <= x_i, so only xlo is relevant .; // Like for clo and cup above, we have to define an index vector ixlo and ixup .; // Since each variable has the lower boundary, we can set the whole vector; // ixlo = 1; ; TVectorD xlo (nrVar); xlo = 0;; TVectorD xup (nrVar); xup = 0;; TVectorD ixlo(nrVar); ixlo = 1;; TVectorD ixup(nrVar); ixup = 0;; ; // setup the quadratic programming problem . Since a small number of variables are; // involved and ""Q"" has everywhere entries, we chose the dense version ""TQpProbDens"" .; // In case of a sparse formulation, simply replace all ""Dens"" by ""Sparse"" below and; // use TMatrixDSparse instead of TMatrixDSym and TMatrixD; ; TQpProbDens *qp = new TQpProbDens(nrVar,nrEqual,nrInEqual);; ; // stuff all the matrices/vectors defined above in the proper places; ; TQpDataDens *prob = (TQpDataDens *)qp->MakeData(c,Q,xlo,ixlo,xup,ixup,A,b,C,clo,iclo,cup,icup);; ; // setup the nrStock variables, vars->fX will contain the final solution; ; TQpVar *vars = qp->MakeVariables(prob);; TQpResidual *resid = qp->MakeResiduals(prob);; ; // Now we have to choose the method of solving, either TGondzioSolver or TMehrotraSolver; // The Gondzio method is more sophisticated and therefore numerically more involved; // If one want the Mehrotra method, simply replace ""Gondzio"" by ""Mehrotra"" .; ; TGondzioSolver *s = new TGondzioSolver(qp,prob);; const Int_t status = s->Solve(prob,vars,resid);; ; const TVectorD weight = vars->fX;; ; delete qp; delete prob; delete vars; delete resid; delete s;; if (status != 0) {; cout << ""Could not solve this problem."" <<endl;; return TVectorD(nrStocks);; }; ; return weight;; }; #endif; ; //---------------------------------------------------------------------------; void portfolio(); {; const Int_t sDay = 20000809;; const Int_t eDay = 20040602;; ; const char *fname = ""stock.root"";; TFile *f = 0;; if (!gSystem->AccessPathName(fname)) {; f = TFile::Ope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:9474,simpl,simply,9474,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,2,['simpl'],['simply']
Usability,"orHelper class to iterate over cluster of baskets ;  CTFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends ;  CTTreeCacheA specialized TFileCacheRead object for a TTree ;  CTTreeCacheUnzipSpecialization of TTreeCache for parallel Unzipping ;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  ►CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CRealInstanceCache;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  CTTreePerfStatsTTree I/O performance measurement ;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderTTreeReader is a simple, robust and fast interface to read values from a TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayExtracts array data from a TTree ;  CIterator_t;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ;  CTTVRecordI/O classes for TreeViewer sess",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:191707,simpl,simple,191707,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['simpl'],['simple']
Usability,"orHelper class to iterate over cluster of baskets ;  CTFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends ;  CTTreeCacheA specialized TFileCacheRead object for a TTree ;  CTTreeCacheUnzipSpecialization of TTreeCache for parallel Unzipping ;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  ►CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CRealInstanceCache;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  CTTreePerfStatsTTree I/O performance measurement ;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderTTreeReader is a simple, robust and fast interface to read values from a TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayExtracts array data from a TTree ;  CIterator_tRandom access iterator to the elements of a TTreeReaderArray ;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:210001,simpl,simple,210001,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['simpl'],['simple']
Usability,"orHelper class to iterate over cluster of baskets ;  CTFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends ;  ►CTTreeCache;  CIOPos;  ►CMissCache;  CEntry;  ►CTTreeCacheUnzipSpecialization of TTreeCache for parallel Unzipping ;  CUnzipState;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  ►CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CRealInstanceCache;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  ►CTTreePerfStatsTTree I/O performance measurement ;  CBasketInfo;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderA simple, robust and fast interface to read values from ROOT colmnar datasets such as TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayAn interface for reading collections stored in ROOT columnar datasets ;  CIterator_tRandom access iterator to the elements of a TTreeReaderArray ;  CTTreeReaderValueAn interface for reading values stored in ROOT columnar datasets ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:217413,simpl,simple,217413,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['simpl'],['simple']
Usability,"ordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad]) and HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:20384,simpl,simply,20384,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['simpl'],['simply']
Usability,"order when paused. Function Members (Methods); public:. static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderPaused&operator=(const TRecorderPaused&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder* r); virtual voidResume(TRecorder* r); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRecorderPaused(const TRecorderPaused&). protected:. voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState); TRecorderPaused(TRecorderReplaying* state). private:. virtual~TRecorderPaused(). Data Members; private:. TRecorderReplaying*fReplayingStateReplaying that is paused. Class Charts. Inheritance Chart:. TRecorderState. ←; TRecorderPaused. Function documentation; TRecorderPaused(TRecorderReplaying* state); Rememeber the recorder state that is paused. void Resume(TRecorder* r); Continues replaying. void ReplayStop(TRecorder* r); Replaying is cancelled. TRecorder & operator=(const TRecorderPaused& ). TRecorder::ERecorderState GetState() const; Gets current state of recorder. virtual ~TRecorderPaused(); {}. TRecorderPaused(TRecorderReplaying* state). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 16:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRecorderPaused.html:1548,pause,paused,1548,root/html604/TRecorderPaused.html,https://root.cern,https://root.cern/root/html604/TRecorderPaused.html,2,['pause'],['paused']
Usability,"order when paused. Function Members (Methods); public:. static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderPaused&operator=(const TRecorderPaused&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder* r); virtual voidResume(TRecorder* r); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRecorderPaused(const TRecorderPaused&). protected:. voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState); TRecorderPaused(TRecorderReplaying* state). private:. virtual~TRecorderPaused(). Data Members; private:. TRecorderReplaying*fReplayingStateReplaying that is paused. Class Charts. Inheritance Chart:. TRecorderState. ←; TRecorderPaused. Function documentation; TRecorderPaused(TRecorderReplaying* state); Rememeber the recorder state that is paused. void Resume(TRecorder* r); Continues replaying. void ReplayStop(TRecorder* r); Replaying is cancelled. TRecorder & operator=(const TRecorderPaused& ). TRecorder::ERecorderState GetState() const; Gets current state of recorder. virtual ~TRecorderPaused(); {}. TRecorderPaused(TRecorderReplaying* state). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorderPaused.html:1548,pause,paused,1548,root/html602/TRecorderPaused.html,https://root.cern,https://root.cern/root/html602/TRecorderPaused.html,2,['pause'],['paused']
Usability,"order*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp); virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidStop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ChangeState(TRecorderState *newstate, Bool_t deletePreviousState = kTRUE); Changes state to the new one.; See class documentation for information about state changing. void Start(const char *filename, Option_t *option = ""RECREATE"", Window_t *w = 0, Int_t winCount = 0); Starts recording of events to the given file. void Stop(Bool_t guiCommand = kFALSE); Stops recording of events. Bool_t Replay(const char *filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays recorded events from given file. void Pause(); Pauses replaying. void Resume(); Resumes paused replaying. void ReplayStop(); Stops (cancels) replaying. void ListCmd(const char* ); Prints out the list of recorded commandline events. void ListGui(const char* ); Prints out the list of recorded GUI events. TRecorder::ERecorderState GetState() const; Gets current state of recorder. void PrevCanvases(const char* , Option_t* ); Saves all the canvases previous to the TRecorder. virtual ~TRecorderState(); {}. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecorderState.html:4263,pause,paused,4263,root/html528/TRecorderState.html,https://root.cern,https://root.cern/root/html528/TRecorderState.html,1,['pause'],['paused']
Usability,"order*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp); virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidStop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ChangeState(TRecorderState *newstate, Bool_t deletePreviousState = kTRUE); Changes state to the new one.; See class documentation for information about state changing. void Start(const char *filename, Option_t *option = ""RECREATE"", Window_t *w = 0, Int_t winCount = 0); Starts recording of events to the given file. void Stop(Bool_t guiCommand = kFALSE); Stops recording of events. Bool_t Replay(const char *filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays recorded events from given file. void Pause(); Pauses replaying. void Resume(); Resumes paused replaying. void ReplayStop(); Stops (cancels) replaying. void ListCmd(const char* ); Prints out the list of recorded commandline events. void ListGui(const char* ); Prints out the list of recorded GUI events. TRecorder::ERecorderState GetState() const; Gets current state of recorder. void PrevCanvases(const char* , Option_t* ); Saves all the canvases previous to the TRecorder. virtual ~TRecorderState(); {}. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRecorderState.html:4265,pause,paused,4265,root/html530/TRecorderState.html,https://root.cern,https://root.cern/root/html530/TRecorderState.html,1,['pause'],['paused']
Usability,"order*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp); virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidStop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ChangeState(TRecorderState *newstate, Bool_t deletePreviousState = kTRUE); Changes state to the new one.; See class documentation for information about state changing. void Start(const char *filename, Option_t *option = ""RECREATE"", Window_t *w = 0, Int_t winCount = 0); Starts recording of events to the given file. void Stop(Bool_t guiCommand = kFALSE); Stops recording of events. Bool_t Replay(const char *filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays recorded events from given file. void Pause(); Pauses replaying. void Resume(); Resumes paused replaying. void ReplayStop(); Stops (cancels) replaying. void ListCmd(const char* ); Prints out the list of recorded commandline events. void ListGui(const char* ); Prints out the list of recorded GUI events. TRecorder::ERecorderState GetState() const; Gets current state of recorder. void PrevCanvases(const char* , Option_t* ); Saves all the canvases previous to the TRecorder. virtual ~TRecorderState(); {}. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRecorderState.html:4265,pause,paused,4265,root/html532/TRecorderState.html,https://root.cern,https://root.cern/root/html532/TRecorderState.html,1,['pause'],['paused']
Usability,"order*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidStop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRecorderState(); TRecorderState(const TRecorderState&). protected:. voidChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorder & operator=(const TRecorderState& ). void ChangeState(TRecorderState *newstate, Bool_t deletePreviousState = kTRUE); Changes state to the new one.; See class documentation for information about state changing. void Start(const char *filename, Option_t *option = ""RECREATE"", Window_t *w = 0, Int_t winCount = 0); Starts recording of events to the given file. void Stop(Bool_t guiCommand = kFALSE); Stops recording of events. Bool_t Replay(const char *filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays recorded events from given file. void Pause(); Pauses replaying. void Resume(); Resumes paused replaying. void ReplayStop(); Stops (cancels) replaying. void ListCmd(const char* ); Prints out the list of recorded commandline events. void ListGui(const char* ); Prints out the list of recorded GUI events. TRecorder::ERecorderState GetState() const; Gets current state of recorder. void PrevCanvases(const char* , Option_t* ); Saves all the canvases previous to the TRecorder. virtual ~TRecorderState(); {}. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-09-08 17:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRecorderState.html:4423,pause,paused,4423,root/html604/TRecorderState.html,https://root.cern,https://root.cern/root/html604/TRecorderState.html,1,['pause'],['paused']
Usability,"orderPaused: public TRecorderState. Represents state of TRecorder when paused. Function Members (Methods); public:. TRecorderPaused(const TRecorderPaused&); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderPaused&operator=(const TRecorderPaused&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder* r); virtual voidResume(TRecorder* r); virtual voidShowMembers(TMemberInspector&); virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TRecorderPaused(TRecorderReplaying* state); voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). private:. (unknown)(). Data Members; private:. TRecorderReplaying*fReplayingStateReplaying that is paused. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorderPaused(TRecorderReplaying* state); Rememeber the recorder state that is paused. void Resume(TRecorder* r); Continues replaying. void ReplayStop(TRecorder* r); Replaying is cancelled. TRecorder & operator=(const TRecorderPaused& ). TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderPaused(TRecorderReplaying* state). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-05 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRecorderPaused.html:1499,pause,paused,1499,root/html534/TRecorderPaused.html,https://root.cern,https://root.cern/root/html534/TRecorderPaused.html,2,['pause'],['paused']
Usability,"ore...;  ; class  MetropolisHastings;  This class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo. More...;  ; class  MinNLLTestStat;  MinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic. More...;  ; class  ModelConfig;  ModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools. More...;  ; class  NeymanConstruction;  NeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction. More...;  ; class  NuisanceParametersSampler;  Helper class for ToyMCSampler. More...;  ; class  NumberCountingPdfFactory;  A factory for building PDFs and data for a number counting combination. More...;  ; class  NumEventsTestStat;  NumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting. More...;  ; class  PdfProposal;  PdfProposal is a concrete implementation of the ProposalFunction interface. More...;  ; class  PointSetInterval;  PointSetInterval is a concrete implementation of the ConfInterval interface. More...;  ; class  PosteriorCdfFunction;  ; class  PosteriorFunction;  ; class  PosteriorFunctionFromToyMC;  Posterior function obtaining sampling toy MC for the nuisance according to their pdf. More...;  ; class  ProfileInspector;  Utility class to plot conditional MLE of nuisance parameters vs. More...;  ; class  ProfileLikelihoodCalculator;  The ProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for tools which can produce both a RooStats HypoTestResult and ConfInterval). More...;  ; class  ProfileLikelihoodTestStat;  ProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:5517,simpl,simple,5517,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,2,['simpl'],['simple']
Usability,"ored. The method SetLabelFormat() is used to customize the label format. The format string must contain one of these modifiers:. %txt : to print the text label associated with the slice. %val : to print the numeric value of the slice. %frac : to print the relative fraction of this slice. %perc : to print the % of this slice. mypie->SetLabelFormat(""%txt (%frac)"");; See the macro $ROOTSYS/tutorials/graphics/piechart.C . The picture generated by tutorial macro piechart.C. 3.21 The User Interface for Histograms; The classes T H1 Editor and T H2 Editor provides the user interface for setting histogram’s attributes and rebinning interactively.; 3.21.1 TH1Editor. 3.21.1.1 The Style Tab; 3.21.1.1.1 Title; sets the title of the histogram.; 3.21.1.1.2 Plot; draw a 2D or 3D plot; according to the dimension, different drawing possibilities can be set.; 3.21.1.1.3 Error; add different error bars to the histogram (no errors, simple, etc.).; 3.21.1.1.4 Add; further things which can be added to the histogram (None, simple/smooth line, fill area, etc.); 3.21.1.2 2-D Plot; 3.21.1.2.1 Simple Drawing; draw a simple histogram without errors (= “HIST” draw option). In combination with some other draw options an outer line is drawn on top of the histogram; 3.21.1.2.2 Show markers; draw a marker on to of each bin (=“P” draw option).; 3.21.1.2.3 Draw bar chart; draw a bar chart (=“B” draw option).; 3.21.1.2.4 Bar option; draw a bar chart (=“BAR” draw option); if selected, it will show an additional interface elements for bars: width, offset, percentage and the possibility to draw horizontal bars.; 3.21.1.3 3-D Plot; 3.21.1.3.1 Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf, Surf1…5).; 3.21.1.3.2 Coords; set the coordinate system (Cartesian, Spheric, etc.).; 3.21.1.3.3 Error; same as for 2D plot.; 3.21.1.3.4 Bar; set the bar attributes: width and offset.; 3.21.1.3.5 Horizontal Bar; draw a horizontal bar chart.; 3.21.1.4 The Binning tab; The binning tab has two differe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:135621,simpl,simple,135621,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"orial demonstrates how the highlight mechanism can be used on an histogram. ;  ; file  hstack.C;   Example of stacked histograms: class THStack. ;  ; file  hstackpads.C;   Drawing stack histograms on subpads. ;  ; file  hsum.C;   Histograms filled and drawn in a loop. ;  ; file  hsumTimer.C;   Demo of Timers. ;  ; file  legendautoplaced.C;   The legend can be placed automatically in the current pad in an empty space found at painting time. ;  ; file  logscales.C;   Draw parametric functions with log scales. ;  ; file  movepalette.C;   When an histogram is drawn with the option COLZ, a palette is automatically drawn vertically on the right side of the plot. ;  ; file  multicolor.C;   Use a THStack to show a 2-D hist with cells with different colors. ;  ; file  NormalizeHistogram.C;   Normalizing a Histogram ;  ; file  ratioplot1.C;   Example creating a simple ratio plot of two histograms using the pois division option. ;  ; file  ratioplot1.py;   Example creating a simple ratio plot of two histograms using the pois division option. ;  ; file  ratioplot2.C;   Example of a fit residual plot. ;  ; file  ratioplot2.py;   Example of a fit residual plot. ;  ; file  ratioplot3.C;   Example which shows how you can get the graph of the lower plot and set the y axis range for it. ;  ; file  ratioplot3.py;   Example which shows how you can get the graph of the lower plot and set the y axis range for it. ;  ; file  ratioplot4.C;   Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ;  ; file  ratioplot4.py;   Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ;  ; file  ratioplot5.C;   Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ;  ; file  ratioplot5.py;   Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ;  ; file  ra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__hist.html:3821,simpl,simple,3821,doc/master/group__tutorial__hist.html,https://root.cern,https://root.cern/doc/master/group__tutorial__hist.html,1,['simpl'],['simple']
Usability,"orial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now the event loop on the cached dataset is triggered. This event triggers the loop; // on the `df` data frame lazily.; h->DrawCopy();; }; h#define h(i)Definition RSha256.hxx:106; gROOT#define gROOTDefinition TROOT.h:406; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df019__Cache_8C.html:1286,simpl,simple,1286,doc/master/df019__Cache_8C.html,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html,1,['simpl'],['simple']
Usability,"originators unique address space and can not be used by the consumer process(es)). Consumer processes can map the memory region from this file and access the objects stored in it via the Get() method (which returns a copy of the object stored in the shared memory with correct vtbl ptr set). Only objects of classes with a Streamer() member function defined can be shared.; I know the current implementation is not ideal (you need to copy to and from the shared memory file) but the main problem is with the class' virtual_table pointer. This pointer points to a table unique for every process. Therefore, different options are:; One could allocate an object directly in shared memory in the producer, but the consumer still has to copy the object from shared memory into a local object which has the correct vtbl pointer for that process (copy ctor's can be used for creating the local copy).; Another possibility is to only allow objects without virtual functions in shared memory (like simple C structs), or to forbid (how?) the consumer from calling any virtual functions of the objects in shared memory.; A last option is to copy the object internals to shared memory and copy them again from there. This is what is done in the TMapFile (using the object Streamer() to make a deep copy). Option 1) saves one copy, but requires solid copy ctor's (along the full inheritance chain) to rebuild the object in the consumer. Most classes don't provide these copy ctor's, especially not when objects contain collections, etc. 2) is too limiting or dangerous (calling accidentally a virtual function will segv). So since we have a robust Streamer mechanism I opted for 3). ; Definition at line 26 of file TMapFile.h. Public Types; enum  { kDefaultMapSize = 0x80000; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMapFile.html:1862,simpl,simple,1862,doc/master/classTMapFile.html,https://root.cern,https://root.cern/doc/master/classTMapFile.html,1,['simpl'],['simple']
Usability,"ork[0] = xlow;; 1636 gywork[0] = ylow;; 1637 gxwork[1] = xhigh;; 1638 gywork[1] = yhigh;; 1639 ComputeLogs(2, optionZ);; 1640 if (gyworkl[0] < gPad->GetUymin()) gyworkl[0] = gPad->GetUymin();; 1641 if (gyworkl[1] < gPad->GetUymin()) continue;; 1642 if (gyworkl[1] > gPad->GetUymax()) gyworkl[1] = gPad->GetUymax();; 1643 if (gyworkl[0] > gPad->GetUymax()) continue;; 1644 ; 1645 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1646 }; 1647 } else {; 1648 for (i=1;i<=npoints;i++) {; 1649 xhigh = x[i-1];; 1650 ylow = y[i-1] - dbar;; 1651 yhigh = y[i-1] + dbar;; 1652 xlow = TMath::Max((Double_t)0, gPad->GetUxmin());; 1653 gxwork[0] = xlow;; 1654 gywork[0] = ylow;; 1655 gxwork[1] = xhigh;; 1656 gywork[1] = yhigh;; 1657 ComputeLogs(2, optionZ);; 1658 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1659 }; 1660 }; 1661 theGraph->SetFillColor(FillSave);; 1662 theGraph->TAttFill::Modify();; 1663 }; 1664 gPad->ResetBit(TGraph::kClipFrame);; 1665 ; 1666 gxwork.clear();; 1667 gywork.clear();; 1668 gxworkl.clear();; 1669 gyworkl.clear();; 1670}; 1671 ; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// This is a service method used by `THistPainter`; 1675/// to paint 1D histograms. It is not used to paint TGraph.; 1676///; 1677/// Input parameters:; 1678///; 1679/// - npoints : Number of points in X or in Y.; 1680/// - x[npoints] or x[0] : x coordinates or (xmin,xmax).; 1681/// - y[npoints] or y[0] : y coordinates or (ymin,ymax).; 1682/// - chopt : Option.; 1683///; 1684/// The aspect of the histogram is done according to the value of the chopt.; 1685///; 1686/// | Option | Description |; 1687/// |--------|-----------------------------------------------------------------|; 1688/// |""R"" | Graph is drawn horizontally, parallel to X axis. (default is vertically, parallel to Y axis).If option R is selected the user must give 2 values for Y (y[0]=YMIN and y[1]=YMAX) or N values for X, one for each channel. Oth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:60379,clear,clear,60379,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['clear'],['clear']
Usability,orkerTreeFuncTemplated derivation of TMPWorkerTree handlign generic function tree processing ;  CTMPWorkerTreeSelTemplated derivation of TMPWorkerTree handlign selector tree processing ;  CTMrbSubevent_Caen;  CTMultiDimFitMultidimensional Fits in ROOT ;  CTMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects ;  CTMultiLayerPerceptron;  CTMutex;  CTMutexImp;  CTMySQLResult;  CTMySQLRow;  CTMySQLServer;  ►CTMySQLStatement;  CTParamData;  CTNamedBase class for all named ROOT classes ;  CTNDArray;  CTNDArrayRef;  CTNDArrayT;  CTNetFile;  CTNetFileStager;  CTNetSystem;  CTNetXNGFile;  CTNetXNGFileStager;  CTNetXNGSystem;  CTNeuron;  CTNewChainDlg;  CTNewQueryDlg;  CTNodeTNode description ;  CTNodeDivDescription of parameters to divide a 3-D geometry object ;  CTNonCopyable;  CTNonSplitBrowsableAllows a TBrowser to browse non-split branches as if they were split ;  CTNotifyLinkLinks multiple listeners to be notified on TChain file changes ;  CTNotifyLinkBase;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStepThis class contains implementation of writing OpenCascade's geometry shapes to the STEP file reproducing the original ROOT geometry tree ;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CT,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:197005,simpl,simple,197005,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['simpl'],['simple']
Usability,"orld::FindNextBoundaryOrig ; (; Double_t ; point[3], . Double_t ; dir[3], . Double_t & ; step, . Double_t ; stepmax = 1.E30 . ). private . Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world. ; (original version based on TGeoVoxelFinder) ; Definition at line 519 of file TGeoParallelWorld.cxx. ◆ FindNode(). TGeoPhysicalNode * TGeoParallelWorld::FindNode ; (; Double_t ; point[3]). inline . Definition at line 106 of file TGeoParallelWorld.h. ◆ FindNodeBVH(). TGeoPhysicalNode * TGeoParallelWorld::FindNodeBVH ; (; Double_t ; point[3]). private . Finds physical node containing the point. ; Uses BVH to do so. (Not the best algorithm since not O(1) but good enough.) An improved version could be implemented based on TGeoVoxelGrid caching. ; Definition at line 245 of file TGeoParallelWorld.cxx. ◆ FindNodeLoop(). TGeoPhysicalNode * TGeoParallelWorld::FindNodeLoop ; (; Double_t ; point[3]). private . Finds physical node containing the point using simple algorithm (for debugging) ; Definition at line 353 of file TGeoParallelWorld.cxx. ◆ FindNodeOrig(). TGeoPhysicalNode * TGeoParallelWorld::FindNodeOrig ; (; Double_t ; point[3]). private . Finds physical node containing the point (original version based on TGeoVoxelFinder) ; Definition at line 318 of file TGeoParallelWorld.cxx. ◆ GetAccelerationMode(). AccelerationMode const & TGeoParallelWorld::GetAccelerationMode ; (; ); const. inline . Definition at line 96 of file TGeoParallelWorld.h. ◆ GetBVHSafetyCandidates(). std::pair< double, double > TGeoParallelWorld::GetBVHSafetyCandidates ; (; double ; point[3], . std::vector< int > & ; candidates, . double ; margin = 0. . ); const. private . Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ; Uses BVH to do so. ; Definition at line 802 of file TGeoParallelWorld.cxx. ◆ GetGeometry(). TGeoManager * TGeoParallelWorld::GetGeometry ; (; ); const. inline . Definition at line 142 of file TGeoParallelWorld.h. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:22554,simpl,simple,22554,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['simpl'],['simple']
Usability,"ormIt) delete *formIt;; 381 fCutFormulas.clear();; 382 for (UInt_t clIdx=0; clIdx<dsi.GetNClasses(); clIdx++) {; 383 const TCut& tmpCut = dsi.GetClassInfo(clIdx)->GetCut();; 384 const TString tmpCutExp(tmpCut.GetTitle());; 385 ttf = 0;; 386 if (tmpCutExp!="""") {; 387 ttf = new TTreeFormula( Form(""CutClass%i"",clIdx), tmpCutExp, tr );; 388 Bool_t worked = CheckTTreeFormula( ttf, tmpCutExp, hasDollar );; 389 if( !worked ){; 390 Log() << kWARNING << ""Please check class \"""" << dsi.GetClassInfo(clIdx)->GetName(); 391 << ""\"" cut \"""" << dsi.GetClassInfo(clIdx)->GetCut() << Endl;; 392 }; 393 }; 394 fCutFormulas.push_back( ttf );; 395 }; 396 ; 397 //; 398 // the weights (one per class, if non-existent: formula pointer = 0); 399 //; 400 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName()) << ""transform weights"" << Endl;; 401 for (formIt = fWeightFormula.begin(), formItEnd = fWeightFormula.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 402 fWeightFormula.clear();; 403 for (UInt_t clIdx=0; clIdx<dsi.GetNClasses(); clIdx++) {; 404 const TString tmpWeight = dsi.GetClassInfo(clIdx)->GetWeight();; 405 ; 406 if (dsi.GetClassInfo(clIdx)->GetName() != tinfo.GetClassName() ) { // if the tree is of another class; 407 fWeightFormula.push_back( 0 );; 408 continue;; 409 }; 410 ; 411 ttf = 0;; 412 if (tmpWeight!="""") {; 413 ttf = new TTreeFormula( ""FormulaWeight"", tmpWeight, tr );; 414 Bool_t worked = CheckTTreeFormula( ttf, tmpWeight, hasDollar );; 415 if( !worked ){; 416 Log() << kWARNING << Form(""Dataset[%s] : "",dsi.GetName()) << ""Please check class \"""" << dsi.GetClassInfo(clIdx)->GetName(); 417 << ""\"" weight \"""" << dsi.GetClassInfo(clIdx)->GetWeight() << Endl;; 418 }; 419 }; 420 else {; 421 ttf = 0;; 422 }; 423 fWeightFormula.push_back( ttf );; 424 }; 425 return;; 426 // all this code below is not needed when using TTReeFormula; 427 ; 428 Log() << kDEBUG << Form(""Dataset[%s] : "", dsi.GetName()) << ""enable branches"" << Endl;; 429 // now enable only branches that are nee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:16543,clear,clear,16543,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['clear'],['clear']
Usability,"orms:; 3869/// - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; 3870/// - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1""; 3871/// on the y-axis versus ""e2"" on the x-axis; 3872/// - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; 3873/// vs ""e2"" vs ""e3"" on the z-, y-, x-axis, respectively; 3874/// - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; 3875/// vs ""e2"" vs ""e3"" and ""e4"" mapped on the current color palette.; 3876/// (to create histograms in the 2, 3, and 4 dimensional case,; 3877/// see section ""Saving the result of Draw to an histogram""); 3878/// - ""e1:e2:e3:e4:e5"" with option ""GL5D"" produces a 5D plot using OpenGL. `gStyle->SetCanvasPreferGL(true)` is needed.; 3879/// - Any number of variables no fewer than two can be used with the options ""CANDLE"" and ""PARA""; 3880/// - An arbitrary number of variables can be used with the option ""GOFF""; 3881///; 3882/// Examples:; 3883/// - ""x"": the simplest case, it draws a 1-Dim histogram of column x; 3884/// - ""sqrt(x)"", ""x*y/z"": draw histogram with the values of the specified numerical expression across TTree events; 3885/// - ""y:sqrt(x)"": 2-Dim histogram of y versus sqrt(x); 3886/// - ""px:py:pz:2.5*E"": produces a 3-d scatter-plot of px vs py ps pz; 3887/// and the color number of each marker will be 2.5*E.; 3888/// If the color number is negative it is set to 0.; 3889/// If the color number is greater than the current number of colors; 3890/// it is set to the highest color number. The default number of; 3891/// colors is 50. See TStyle::SetPalette for setting a new color palette.; 3892///; 3893/// The expressions can use all the operations and built-in functions; 3894/// supported by TFormula (see TFormula::Analyze()), including free; 3895/// functions taking numerical arguments (e.g. TMath::Bessel()).; 3896/// In addition, you can call member functions taking numerical; 3897/// arguments. For example, these are two valid expressions:; 38",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:152933,simpl,simplest,152933,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['simpl'],['simplest']
Usability,"ormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train); Sets the Training dataset.; Those events will be used for the minimization. void SetTestDataSet(TEventList* test); Sets the Test dataset.; Those events will not be used for the minimization but for control. void SetTrainingDataSet(const char* train); Sets the Training dataset.; Those events will be used for the minimization.; Note that the tree must be already defined. void SetTestDataSet(const char* test); Sets the Test dataset.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:23427,learn,learning,23427,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,6,['learn'],['learning']
Usability,"ormulaVar&basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooResolutionModel.html:4270,clear,clearShapeDirty,4270,root/html526/RooResolutionModel.html,https://root.cern,https://root.cern/root/html526/RooResolutionModel.html,1,['clear'],['clearShapeDirty']
Usability,"ors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:62553,clear,clearEvalErrorLog,62553,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,7,['clear'],['clearEvalErrorLog']
Usability,"ory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. NB: This function should not be called in the TClonesArray is already; initialized with a class. void SetClass(const char* classname, Int_t size = 1000); see TClonesArray::SetClass(const TCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:21000,simpl,simplified,21000,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['simpl'],['simplified']
Usability,"os = [ 'hpx', 'hpxpy', 'hprof', 'ntuple' ]; 55for name in histos:; 56 exec('%sFill = %s.Fill' % (name,name)); 57 ; 58# Fill histograms randomly.; 59px_ref, py_ref = ctypes.c_double(), ctypes.c_double(); 60kUPDATE = 1000; 61for i in range( 25000 ):; 62 # Generate random values. Use ctypes to pass doubles by reference; 63 rannor( px_ref, py_ref ); 64 # Retrieve the generated values; 65 px = px_ref.value; 66 py = py_ref.value; 67 ; 68 pz = px*px + py*py; 69 random = rndm(1); 70 ; 71 # Fill histograms.; 72 hpx.Fill( px ); 73 hpxpy.Fill( px, py ); 74 hprof.Fill( px, pz ); 75 ntuple.Fill( px, py, pz, random, i ); 76 ; 77 # Update display every kUPDATE events.; 78 if i and i%kUPDATE == 0:; 79 if i == kUPDATE:; 80 hpx.Draw(); 81 ; 82 c1.Modified(); 83 c1.Update(); 84 ; 85 if gSystem.ProcessEvents(): # allow user interrupt; 86 break; 87 ; 88# Destroy member functions cache.; 89for name in histos:; 90 exec('del %sFill' % name); 91del histos; 92 ; 93gBenchmark.Show( 'hsimple' ); 94 ; 95# Save all objects in this file.; 96hpx.SetFillColor( 0 ); 97hfile.Write(); 98hpx.SetFillColor( 48 ); 99c1.Modified(); 100c1.Update(); 101 ; 102# Note that the file is automatically closed when application terminates; 103# or when the file destructor is called.; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TProfileProfile Histogram.Definition TProfile.h:32; SetBorderSizec SetBorderSize(2). tutorialspyroothsimple.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8py_source.html:3730,simpl,simple,3730,doc/master/hsimple_8py_source.html,https://root.cern,https://root.cern/doc/master/hsimple_8py_source.html,1,['simpl'],['simple']
Usability,"os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t getCacheAllNumeric ();  Return minimum dimensions of numeric integration for which values are cached. ;  ; static void setCacheAllNumeric (Int_t ndim);  Global switch to cache all integral values that integrate at least ndim dimensions numerically. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:46690,clear,clearEvalErrorLog,46690,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['clear'],['clearEvalErrorLog']
Usability,"osition; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTorusEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for torus editor. ~TGeoTorusEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoR(); Slot for R. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi. void DoDphi(); Slot for Dphi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTorusEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTorusEditor.html:21315,undo,undoing,21315,root/html528/TGeoTorusEditor.html,https://root.cern,https://root.cern/root/html528/TGeoTorusEditor.html,1,['undo'],['undoing']
Usability,"osition; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTorusEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for torus editor. ~TGeoTorusEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoR(); Slot for R. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi. void DoDphi(); Slot for Dphi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTorusEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTorusEditor.html:21415,undo,undoing,21415,root/html530/TGeoTorusEditor.html,https://root.cern,https://root.cern/root/html530/TGeoTorusEditor.html,1,['undo'],['undoing']
Usability,"osition; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTorusEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for torus editor. ~TGeoTorusEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoR(); Slot for R. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi. void DoDphi(); Slot for Dphi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTorusEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTorusEditor.html:21415,undo,undoing,21415,root/html532/TGeoTorusEditor.html,https://root.cern,https://root.cern/root/html532/TGeoTorusEditor.html,1,['undo'],['undoing']
Usability,"ossible to know ahead what character will be deleted. To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)), one needs to call TQCommand::SetUndoArgs(1, character) from inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);; TQCommand::GetCommandstatic TQCommand * GetCommand()Return a command which is doing redo/undo action.Definition TQCommand.cxx:276. Definition at line 276 of file TQCommand.cxx. ◆ GetName(). const char * TQCommand::GetName ; (; ); const. overridevirtual . Returns the command name. ; Default name is ""ClassName::RedoName(args)"" If list of merged commands is not empty the name is ""ClassName::RedoName(args):cname1:cname2 ..."" ; Reimplemented from TCollection.; Definition at line 670 of file TQCommand.cxx. ◆ GetNRargs(). Int_t TQCommand::GetNRargs ; (; ); const. Returns a number of redo arguments. ; Definition at line 768 of file TQCommand.cxx. ◆ GetNUargs(). Int_t TQCommand::GetNUargs ; (; ); const. Returns a number of undo arguments. ; Definition at line 776 of file TQCommand.cxx. ◆ GetObject(). void * TQCommand::GetObject ; (; ); const. Returns an object for which undo redo actions are applied. ; Definition at line 784 of file TQCommand.cxx. ◆ GetRedo(). TQConnection * TQCommand::GetRedo ; (; ); const. inline . Definition at line 75 of file TQCommand.h. ◆ GetRedoArgs(). Long_t * TQCommand::GetRedoArgs ; (; ); const. Returns a pointer to array of redo arguments. ; Definition at line 752 of file TQCommand.cxx. ◆ GetRedoName(). const char * TQCommand::GetRedoName ; (; ); const. Returns the name of redo command. ; Definition at line 736 of file TQCommand.cxx. ◆ GetStatus(). Int_t TQCommand::GetStatus ; (; ); const. Returns a number of sequential undo or redo operations. ; Definition at line 792 of file TQCommand.cxx. ◆ GetTitle(). const char * TQCommand::GetTitle ; (; ); const. overridevirtual . Returns command description. ; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"" ; Reimpl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:37787,undo,undo,37787,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"ostic ignored ""-Wunreachable-code""; 1627 /* For every compiler, either ""sizeof(pthread_t) > sizeof(unsigned long)""; 1628 * or not, so one of the two conditions will be unreachable by construction.; 1629 * Unfortunately the C standard does not define a way to check this at; 1630 * compile time, since the #if preprocessor conditions can not use the; 1631 * sizeof operator as an argument. */; 1632#endif; 1633 ; 1634 if (sizeof(pthread_t) > sizeof(unsigned long)) {; 1635 /* This is the problematic case for CRYPTO_set_id_callback:; 1636 * The OS pthread_t can not be cast to unsigned long. */; 1637 struct mg_workerTLS *tls =; 1638 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 1639 if (tls == NULL) {; 1640 /* SSL called from an unknown thread: Create some thread index.; 1641 */; 1642 tls = (struct mg_workerTLS *)mg_malloc(sizeof(struct mg_workerTLS));; 1643 tls->is_master = -2; /* -2 means ""3rd party thread"" */; 1644 tls->thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 1645 pthread_setspecific(sTlsKey, tls);; 1646 }; 1647 return tls->thread_idx;; 1648 } else {; 1649 /* pthread_t may be any data type, so a simple cast to unsigned long; 1650 * can rise a warning/error, depending on the platform.; 1651 * Here memcpy is used as an anything-to-anything cast. */; 1652 unsigned long ret = 0;; 1653 pthread_t t = pthread_self();; 1654 memcpy(&ret, &t, sizeof(pthread_t));; 1655 return ret;; 1656 }; 1657 ; 1658#if defined(__clang__); 1659#pragma clang diagnostic pop; 1660#endif; 1661 ; 1662#endif; 1663}; 1664 ; 1665 ; 1666FUNCTION_MAY_BE_UNUSED; 1667static uint64_t; 1668mg_get_current_time_ns(void); 1669{; 1670 struct timespec tsnow;; 1671 clock_gettime(CLOCK_REALTIME, &tsnow);; 1672 return (((uint64_t)tsnow.tv_sec) * 1000000000) + (uint64_t)tsnow.tv_nsec;; 1673}; 1674 ; 1675 ; 1676#if defined(GCC_DIAGNOSTIC); 1677/* Show no warning in case system functions are not used. */; 1678#pragma GCC diagnostic pop; 1679#endif /* defined(GCC_DIAGNOSTIC) */; 1680#if defined(__cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:50750,simpl,simple,50750,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['simpl'],['simple']
Usability,"otDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tTTUBE::fAspectRatiodefines (the ellipse semi-axis in Y)/(the ellipse semi-axis in X); Double_t*TTUBE::fCoTab! Table of cos(fPhi1) .... cos(fPhil+fDphi1); Float_tTTUBE::fDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tfRmax2outside radius at the high z limit; Float_tTTUBE::fRminellipse semi-axis in X inside; Float_tfRmin2inside radius at the high z limit; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCONE(); CONE shape default constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmin1, Float_t rmax1, Float_t rmin2, Float_t rmax2); CONE shape normal constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmax1, Float_t rmax2 = 0); CONE shape ""simplified"" constructor. ~TCONE(); CONE shape default destructor. void SetPoints(Double_t* points) const; Create CONE points. TCONE(). Float_t GetRmin2() const; {return fRmin2;}. Float_t GetRmax2() const; {return fRmax2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TCONE.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2009-12-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCONE.html:9327,simpl,simplified,9327,root/html526/TCONE.html,https://root.cern,https://root.cern/root/html526/TCONE.html,1,['simpl'],['simplified']
Usability,"otDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tTTUBE::fAspectRatiodefines (the ellipse semi-axis in Y)/(the ellipse semi-axis in X); Double_t*TTUBE::fCoTab! Table of cos(fPhi1) .... cos(fPhil+fDphi1); Float_tTTUBE::fDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tfRmax2outside radius at the high z limit; Float_tTTUBE::fRminellipse semi-axis in X inside; Float_tfRmin2inside radius at the high z limit; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCONE(); CONE shape default constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmin1, Float_t rmax1, Float_t rmin2, Float_t rmax2); CONE shape normal constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmax1, Float_t rmax2 = 0); CONE shape ""simplified"" constructor. ~TCONE(); CONE shape default destructor. void SetPoints(Double_t* points) const; Create CONE points. TCONE(). Float_t GetRmin2() const; {return fRmin2;}. Float_t GetRmax2() const; {return fRmax2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TCONE.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCONE.html:9313,simpl,simplified,9313,root/html528/TCONE.html,https://root.cern,https://root.cern/root/html528/TCONE.html,1,['simpl'],['simplified']
Usability,"otDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tTTUBE::fAspectRatiodefines (the ellipse semi-axis in Y)/(the ellipse semi-axis in X); Double_t*TTUBE::fCoTab! Table of cos(fPhi1) .... cos(fPhil+fDphi1); Float_tTTUBE::fDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tfRmax2outside radius at the high z limit; Float_tTTUBE::fRminellipse semi-axis in X inside; Float_tfRmin2inside radius at the high z limit; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCONE(); CONE shape default constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmin1, Float_t rmax1, Float_t rmin2, Float_t rmax2); CONE shape normal constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmax1, Float_t rmax2 = 0); CONE shape ""simplified"" constructor. ~TCONE(); CONE shape default destructor. void SetPoints(Double_t* points) const; Create CONE points. TCONE(). Float_t GetRmin2() const; {return fRmin2;}. Float_t GetRmax2() const; {return fRmax2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TCONE.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TCONE.html:9382,simpl,simplified,9382,root/html530/TCONE.html,https://root.cern,https://root.cern/root/html530/TCONE.html,1,['simpl'],['simplified']
Usability,"otDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tTTUBE::fAspectRatiodefines (the ellipse semi-axis in Y)/(the ellipse semi-axis in X); Double_t*TTUBE::fCoTab! Table of cos(fPhi1) .... cos(fPhil+fDphi1); Float_tTTUBE::fDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tfRmax2outside radius at the high z limit; Float_tTTUBE::fRminellipse semi-axis in X inside; Float_tfRmin2inside radius at the high z limit; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCONE(); CONE shape default constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmin1, Float_t rmax1, Float_t rmin2, Float_t rmax2); CONE shape normal constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmax1, Float_t rmax2 = 0); CONE shape ""simplified"" constructor. ~TCONE(); CONE shape default destructor. void SetPoints(Double_t* points) const; Create CONE points. TCONE(). Float_t GetRmin2() const; {return fRmin2;}. Float_t GetRmax2() const; {return fRmax2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TCONE.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCONE.html:9382,simpl,simplified,9382,root/html532/TCONE.html,https://root.cern,https://root.cern/root/html532/TCONE.html,1,['simpl'],['simplified']
Usability,"otEmbeddedCanvas. ; This method is only called via TRootEmbeddedCanvas::AdoptCanvas. ; Definition at line 1046 of file TCanvas.cxx. ◆ EnterLeave(). void TCanvas::EnterLeave ; (; TPad * ; prevSelPad, . TObject * ; prevSelObj . ). Generate kMouseEnter and kMouseLeave events depending on the previously selected object and the currently selected object. ; Does nothing if the selected object does not change. ; Definition at line 1072 of file TCanvas.cxx. ◆ ExecuteEvent(). void TCanvas::ExecuteEvent ; (; Int_t ; event, . Int_t ; px, . Int_t ; py . ). overrideprotectedvirtual . Execute action corresponding to one event. ; This member function must be implemented to realize the action corresponding to the mouse click on the object in the canvas; Only handle mouse motion events in TCanvas, all other events are ignored for the time being ; Reimplemented from TObject.; Definition at line 1108 of file TCanvas.cxx. ◆ FeedbackMode(). void TCanvas::FeedbackMode ; (; Bool_t ; set). Turn rubberband feedback mode on or off. ; Definition at line 1126 of file TCanvas.cxx. ◆ Flush(). void TCanvas::Flush ; (; ). Flush canvas buffers. ; Definition at line 1143 of file TCanvas.cxx. ◆ ForceUpdate(). void TCanvas::ForceUpdate ; (; ). Force canvas update. ; Definition at line 1175 of file TCanvas.cxx. ◆ GetAutoExec(). Bool_t TCanvas::GetAutoExec ; (; ); const. inline . Definition at line 152 of file TCanvas.h. ◆ GetCanvasID(). Int_t TCanvas::GetCanvasID ; (; ); const. inlineoverridevirtual . Implements TVirtualPad.; Definition at line 157 of file TCanvas.h. ◆ GetCanvasImp(). TCanvasImp * TCanvas::GetCanvasImp ; (; ); const. inlineoverridevirtual . Implements TVirtualPad.; Definition at line 158 of file TCanvas.h. ◆ GetCanvasPainter(). TVirtualPadPainter * TCanvas::GetCanvasPainter ; (; ). Access and (probably) creation of pad painter. ; Definition at line 2603 of file TCanvas.cxx. ◆ GetCanvasPar(). virtual void TCanvas::GetCanvasPar ; (; Int_t & ; wtopx, . Int_t & ; wtopy, . UInt_t & ; ww, . U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:72876,feedback,feedback,72876,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,1,['feedback'],['feedback']
Usability,"otEmbeddedCanvas. ; This method is only called via TRootEmbeddedCanvas::AdoptCanvas. ; Definition at line 1048 of file TCanvas.cxx. ◆ EnterLeave(). void TCanvas::EnterLeave ; (; TPad * ; prevSelPad, . TObject * ; prevSelObj . ). Generate kMouseEnter and kMouseLeave events depending on the previously selected object and the currently selected object. ; Does nothing if the selected object does not change. ; Definition at line 1074 of file TCanvas.cxx. ◆ ExecuteEvent(). void TCanvas::ExecuteEvent ; (; Int_t ; event, . Int_t ; px, . Int_t ; py . ). overrideprotectedvirtual . Execute action corresponding to one event. ; This member function must be implemented to realize the action corresponding to the mouse click on the object in the canvas; Only handle mouse motion events in TCanvas, all other events are ignored for the time being ; Reimplemented from TObject.; Definition at line 1110 of file TCanvas.cxx. ◆ FeedbackMode(). void TCanvas::FeedbackMode ; (; Bool_t ; set). Turn rubberband feedback mode on or off. ; Definition at line 1128 of file TCanvas.cxx. ◆ Flush(). void TCanvas::Flush ; (; ). Flush canvas buffers. ; Definition at line 1145 of file TCanvas.cxx. ◆ ForceUpdate(). void TCanvas::ForceUpdate ; (; ). Force canvas update. ; Definition at line 1177 of file TCanvas.cxx. ◆ GetAutoExec(). Bool_t TCanvas::GetAutoExec ; (; ); const. inline . Definition at line 152 of file TCanvas.h. ◆ GetCanvasID(). Int_t TCanvas::GetCanvasID ; (; ); const. inlineoverridevirtual . Implements TVirtualPad.; Definition at line 157 of file TCanvas.h. ◆ GetCanvasImp(). TCanvasImp * TCanvas::GetCanvasImp ; (; ); const. inlineoverridevirtual . Implements TVirtualPad.; Definition at line 158 of file TCanvas.h. ◆ GetCanvasPainter(). TVirtualPadPainter * TCanvas::GetCanvasPainter ; (; ). Access and (probably) creation of pad painter. ; Definition at line 2616 of file TCanvas.cxx. ◆ GetCanvasPar(). virtual void TCanvas::GetCanvasPar ; (; Int_t & ; wtopx, . Int_t & ; wtopy, . UInt_t & ; ww, . U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvas.html:73252,feedback,feedback,73252,doc/master/classTCanvas.html,https://root.cern,https://root.cern/doc/master/classTCanvas.html,1,['feedback'],['feedback']
Usability,"otFile();; 68 return SQLITE_OK;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////; 72/// Issues a byte range request for a chunk to the raw file; 73int VfsRdOnlyRead(sqlite3_file *pFile, void *zBuf, int count, sqlite_int64 offset); 74{; 75 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 76 auto nbytes = p->fRawFile->ReadAt(zBuf, count, offset);; 77 return (nbytes != static_cast<unsigned int>(count)) ? SQLITE_IOERR : SQLITE_OK;; 78}; 79 ; 80////////////////////////////////////////////////////////////////////////////; 81/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 82int VfsRdOnlyWrite(sqlite3_file * /*pFile*/, const void * /*zBuf*/, int /*iAmt*/, sqlite_int64 /*iOfst*/); 83{; 84 return SQLITE_OPEN_READONLY;; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:4305,simpl,simply,4305,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['simpl'],['simply']
Usability,"otPainter::fZLevels. private:. TGLPlotCoordinatesfCartesianCoord; TAxisfCartesianXAxis; TAxisfCartesianYAxis; TAxisfCartesianZAxis; Int_tfColorScheme; TGLParametricEquation*fEquation; TGL2DArray<TGLParametricPlot::Vertex_t>fMesh; Int_tfMeshSize; Bool_tfShowMesh. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLParametricPlot(TGLParametricEquation* equation, TGLPlotCamera* camera); Constructor. Bool_t InitGeometry(); Build mesh. The surface is 'immutable':; the only reason to rebuild it - the change in size or; if one of equations contain reference to TF2 function, whose; parameters were changed. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. char * GetPlotInfo(Int_t px, Int_t py); No object info yet. void AddOption(const TString& option); No additional options for parametric surfaces. void ProcessEvent(Int_t event, Int_t px, Int_t py); Change color/mesh size or switch on/off mesh/box cut.; Left double click - remove box cut. void InitGL() const; Initialize gl state. void DeInitGL() const; Initialize gl state. void DrawPlot() const; Draw parametric surface. void InitColors(); Calculate colors for vertices,; using one of 20 color themes.; -1 simple 'metal' surface. void DrawSectionXOZ() const; No such sections. void DrawSectionYOZ() const; No such sections. void DrawSectionXOY() const; No such sections. void SetSurfaceColor() const; Set material properties. TGLParametricPlot(TGLParametricEquation* equation, TGLPlotCamera* camera). » Author: Timur Pocheptsov 26/01/2007 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-03-13 19:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLParametricPlot.html:5583,simpl,simple,5583,root/html534/TGLParametricPlot.html,https://root.cern,https://root.cern/root/html534/TGLParametricPlot.html,1,['simpl'],['simple']
Usability,"otect your rights, we need to make restrictions that forbid; distributors to deny you these rights or to ask you to surrender these; rights. These restrictions translate to certain responsibilities for; you if you distribute copies of the library or if you modify it. For example, if you distribute copies of the library, whether gratis; or for a fee, you must give the recipients all the rights that we gave; you. You must make sure that they, too, receive or can get the source; code. If you link other code with the library, you must provide; complete object files to the recipients, so that they can relink them; with the library after making changes to the library and recompiling; it. And you must show them these terms so they know their rights. We protect your rights with a two-step method: (1) we copyright the; library, and (2) we offer you this license, which gives you legal; permission to copy, distribute and/or modify the library. To protect each distributor, we want to make it very clear that; there is no warranty for the free library. Also, if the library is; modified by someone else and passed on, the recipients should know; that what they have is not the original version, so that the original; author's reputation will not be affected by problems that might be; introduced by others.; ; Finally, software patents pose a constant threat to the existence of; any free program. We wish to make sure that a company cannot; effectively restrict the users of a free program by obtaining a; restrictive license from a patent holder. Therefore, we insist that; any patent license obtained for a version of the library must be; consistent with the full freedom of use specified in this license. Most GNU software, including some libraries, is covered by the; ordinary GNU General Public License. This license, the GNU Lesser; General Public License, applies to certain designated libraries, and; is quite different from the ordinary General Public License. We use; this license for c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:4985,clear,clear,4985,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['clear'],['clear']
Usability,"oth are in the same tree.; // We distinguish them using TCut objects: selections as one would use in TTree::Draw(). ; TCut signalCut(""muons.fTriggered"");; TCut backgroundCut(""!muons.fTriggered"");; factory->SetInputTrees(tree, signalCut, backgroundCut);. // Now select which algorithm to run - it's not important here as long as it; // determines the parameter correlations.; factory->BookMethod( TMVA::Types::kFisher, ""Fisher"", ""H:!V"" );; // And start the correlation analysis:; factory->TestAllMethods();; }. Parameter correlations; We want to know what muons.fTriggered depends on. A simple check is to look for correlations: variables that it depends on might be linearly correlated. TMVA tells us that the muon and the X position is completely uncorrelated. It also tells us that the muons' pT and energy are somewhat correlated. But what would be the best parameter to determine the muon trigger efficiency - what is most correlated with it?; . ‹ 5. Fitting; up; 7. Using the TTreeReader ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/6-multivariate-analysis.html:6231,guid,guidelines,6231,d/6-multivariate-analysis.html,https://root.cern,https://root.cern/d/6-multivariate-analysis.html,1,['guid'],['guidelines']
Usability,"other particular case where volume families are used is when we want that a volume positioned inside a container to match one ore more container limits. Suppose we want to position the same box inside 2 different volumes and we want the Z size to match the one of each container:; TGeoVolume *container1 = gGeoManager->MakeBox(""C1"",imed,10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"",imed,10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"",jmed,3,3,-1);; container1->AddNode(pvol,1);; container2->AddNode(pvol,1);; Note that the third parameter of PVOL is negative, which does not make sense as half-length on Z. This is interpreted as: when positioned, create a box replacing all invalid parameters with the corresponding dimensions of the container. This is also internally handled by the TGeoVolumeMulti class, which does not need to be instantiated by users.; 18.4.2.9 Dividing Volumes; Volumes can be divided according a pattern. The simplest division can be done along one axis that can be: X,Y,Z,Phi,Rxy or Rxyz. Let’s take a simple case: we would like to divide a box in N equal slices along X coordinate, representing a new volume family. Supposing we already have created the initial box, this can be done like:; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; Here SLICEX is the name of the new family representing all slices and 1 is the slicing axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtraorpara -1, 2, 3 mean X, Y, Z; for tube, tubs, cone, cons -1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means Rand 2 means phi.; In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. When a volume is divided, a volume family corresponding to the slices is created. In case all slices can be represented",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:954107,simpl,simplest,954107,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simplest']
Usability,"ouble * GSLMultiRootFinder::Dx() const {; 140 // return x; 141 return (fSolver != nullptr) ? fSolver->Dx() : nullptr;; 142}; 143const double * GSLMultiRootFinder::FVal() const {; 144 // return x; 145 return (fSolver != nullptr) ? fSolver->FVal() : nullptr;; 146}; 147const char * GSLMultiRootFinder::Name() const {; 148 // get GSL name; 149 return (fSolver != nullptr) ? fSolver->Name().c_str() : """";; 150}; 151 ; 152// bool GSLMultiRootFinder::AddFunction( const ROOT::Math::IMultiGenFunction & func) {; 153// // clone and add function to the list; 154// // If using a derivative algorithm the function is checked if it implements; 155// // the gradient interface. If this is not the case the type is set to non-derivatibe algo; 156// ROOT::Math::IGenMultiFunction * f = func.Clone();; 157// if (f != 0) return false;; 158// if (fUseDerivAlgo) {; 159// bool gradFunc = (dynamic_cast<ROOT::Math::IMultiGradFunction *> (f) != 0 );; 160// if (!gradFunc) {; 161// MATH_ERROR_MSG(""GSLMultiRootFinder::AddFunction"",""Function does not provide gradient interface"");; 162// MATH_WARN_MSG(""GSLMultiRootFinder::AddFunction"",""clear the function list"");; 163// ClearFunctions();; 164// return false;; 165// }; 166// }; 167// fFunctions.push_back(f);; 168// return true;; 169// }; 170 ; 171 const gsl_multiroot_fsolver_type * GetGSLType(GSLMultiRootFinder::EType type) {; 172 //helper functions to find GSL type; 173 switch(type); 174 {; 175 case ROOT::Math::GSLMultiRootFinder::kHybridS:; 176 return gsl_multiroot_fsolver_hybrids;; 177 case ROOT::Math::GSLMultiRootFinder::kHybrid:; 178 return gsl_multiroot_fsolver_hybrid;; 179 case ROOT::Math::GSLMultiRootFinder::kDNewton:; 180 return gsl_multiroot_fsolver_dnewton;; 181 case ROOT::Math::GSLMultiRootFinder::kBroyden:; 182 return gsl_multiroot_fsolver_broyden;; 183 default:; 184 return gsl_multiroot_fsolver_hybrids;; 185 }; 186 return nullptr;; 187}; 188 ; 189const gsl_multiroot_fdfsolver_type * GetGSLDerivType(GSLMultiRootFinder::EDerivType type) {; 190//",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html:5554,clear,clear,5554,doc/master/GSLMultiRootFinder_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html,1,['clear'],['clear']
Usability,"ouble IntegralLow(const ROOT::Math::IGenFunction& f, double b). double IntegralUp(const ROOT::Math::IGenFunction& f, double a). double Integral(const Function & f, const std::vector<double> & pts). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, unsigned int rule = 3); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, int rule = 3). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html:4856,simpl,simple,4856,root/html526/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html,1,['simpl'],['simple']
Usability,"ouble ymin=0.95)Definition RooGlobalFunc.cxx:783; RooFit::MinosRooCmdArg Minos(bool flag=true)Definition RooGlobalFunc.cxx:681; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657. PyROOT; The RooMCStudy::plotError() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArg of the function. . Definition at line 1087 of file RooMCStudy.cxx. ◆ plotPull() [2/2]. RooPlot * RooMCStudy::plotPull ; (; const RooRealVar & ; param, . double ; lo = -3.0, . double ; hi = 3.0, . Int_t ; nbins = 25, . bool ; fitGauss = false . ). Create a RooPlot of the pull distribution for the given parameter. ; The range lo-hi is plotted in nbins. If fitGauss is set, an unbinned ML fit of the distribution to a Gaussian p.d.f is performed. The fit result is overlaid on the returned RooPlot and a box with the fitted mean and sigma is added.; If the parameters of the models for generation and fit differ, simple heuristics are used to find the corresponding parameters:; Parameters have the same name: They will be used to compute pulls.; Parameters have different names: The position of the fit parameter in the set of fit parameters will be computed. The parameter at the same position in the set of generator parameters will be used. . Definition at line 1242 of file RooMCStudy.cxx. ◆ RecursiveRemove(). void RooMCStudy::RecursiveRemove ; (; TObject * ; obj). overrideprotectedvirtual . If one of the TObject we have a referenced to is deleted, remove the reference. ; Reimplemented from TObject.; Definition at line 1275 of file RooMCStudy.cxx. ◆ refit(). RooFit::OwningPtr< RooFitResult > RooMCStudy::refit ; (; RooAbsData * ; genSample = nullptr). protected . Redo fit on 'current' toy sample, or if genSample is not nullptr do fit on given sample instead. ; Definition at line 621 of file RooMCStudy.cxx. ◆ resetFitParams(). void RooMCStudy::resetFitParams ; (; ). protected . Reset all fit parameters to the initial model paramete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMCStudy.html:39128,simpl,simple,39128,doc/master/classRooMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooMCStudy.html,1,['simpl'],['simple']
Usability,"ouble& weight, RooAbsPdf& pdf) const; This method generates a toy data set for the given parameter point taking; global observables into account.; The values of the generated global observables remain in the pdf's variables.; They have to have those values for the subsequent evaluation of the; test statistics. RooAbsData* Generate(RooAbsPdf& pdf, RooArgSet& observables, const RooDataSet* protoData = __null, int forceEvents = 0) const; This is the generate function to use in the context of the ToyMCSampler; instead of the standard RooAbsPdf::generate(...).; It takes into account whether the number of events is given explicitly; or whether it should use the expected number of events. It also takes; into account the option to generate a binned data set (ie RooDataHist). SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC). void ClearCache(); clear the cache obtained from the pdf used for speeding the toy and global observables generation; needs to be called every time the model pdf (fPdf) changes. ToyMCSampler(). void SetUseMultiGen(Bool_t flag); { fUseMultiGen = flag ; }. void AddTestStatistic(RooStats::TestStatistic* t = __null); The pdf can be NULL in which case the density from SetPdf(); is used. The snapshot and TestStatistic is also optional. RooAbsData* GenerateToyData(RooArgSet& paramPoint, RooAbsPdf& pdf) const; generates toy data; without weight. return GenerateToyData(paramPoint, weight, pdf). RooAbsData* GenerateToyData(RooArgSet& paramPoint) const; with weight. { return GenerateToyData(paramPoint,*fPdf); }. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI, int i); Main interface to evaluate the test statistic on a dataset. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI); { return EvaluateTestStatistic( data,nullPOI, 0 ); }. TestStatistic* GetTestStatistic(unsigned int i) const. TestStatistic* GetTestStatistic(unsigned int i) const; { retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__ToyMCSampler.html:7738,clear,clear,7738,root/html602/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html602/RooStats__ToyMCSampler.html,2,['clear'],['clear']
Usability,"ouble_t w=1, Option_t *option="""")Set tree weight.Definition TTree.cxx:9374; TTree::InitializeBranchListsvoid InitializeBranchLists(bool checkLeafCount)Divides the top-level branches into two vectors: (i) branches to be processed sequentially and (ii) b...Definition TTree.cxx:5781; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::fClusterSizeLong64_t * fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.Definition TTree.h:104; TTree::fFlushedBytesLong64_t fFlushedBytesNumber of auto-flushed bytes.Definition TTree.h:89; TTree::SetPerfStatsvirtual void SetPerfStats(TVirtualPerfStats *perf)Set perf stats.Definition TTree.cxx:9329; TTree::fIMTTotBytesstd::atomic< Long64_t > fIMTTotBytes! Total bytes for the IMT flush basketsDefinition TTree.h:160; TTree::SetCacheLearnEntriesvirtual void SetCacheLearnEntries(Int_t n=10)Interface to TTreeCache to set the number of entries for the learning phase.Definition TTree.cxx:8865; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::Mergevirtual Long64_t Merge(TCollection *list, Option_t *option="""")Merge the trees in the TList into this tree.Definition TTree.cxx:6890; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::DropBasketsvirtual void DropBaskets()Remove some baskets from memory.Definition TTree.cxx:4518; TTree::SetAutoSavevirtual void SetAutoSave(Long64_t autos=-300000000)In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSa...Definition TTree.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:446367,learn,learning,446367,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['learn'],['learning']
Usability,"ouble_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooResolutionModel.html:4503,clear,clearEvalErrorLog,4503,root/html602/RooResolutionModel.html,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html,1,['clear'],['clearEvalErrorLog']
Usability,"ouble_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:6548,clear,clearEvalErrorLog,6548,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"ouble_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig ; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted ; Bool_tfRandomisedTreechoose at each node splitting a random set of variables ; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; Int_tfUseNvarsthe number of variables used in randomised trees;; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseSearchTreecut scan done with binary trees or simple event loop.; vector<Double_t>fVariableImportancethe relative importance of the different variables ; static const Int_tfgDebugLeveldebug level determining some printout/control plots etc.; static const Int_tfgRandomSeedset nonzero for debugging and zero for random seeds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DecisionTree(); default constructor using the GiniIndex as separation criterion,; no restrictions on minium number of events in a leave note or the; separation gain in the node splitting. DecisionTree(TMVA::SeparationBase* sepType, Int_t minSize, Int_t nCuts, UInt_t cls = 0, Bool_t randomisedTree = kFALSE, Int_t useNvars = 0, Bool_t usePoissonNvars = kFALSE, UInt_t nNodesMax = 999999, UInt_t nMaxDepth = 9999999, Int_t iSeed = fgRandomSeed, Float_t purityLimit = 0.5, Int_t treeID = 0); constructor specifying the separation type, the min number of; events in a no that is still subjected to further s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__DecisionTree.html:7935,simpl,simple,7935,root/html528/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html,1,['simpl'],['simple']
Usability,"ouble_tfThhiTheta angle of the normal to the upper plane (0, 90); Double_tfThloTheta angle of the normal to the lower plane (90, 180); TGTextButton*TGeoTubeEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCtubEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for cut tube editor. ~TGeoCtubEditor(); Destructor. void SetModel(TObject* obj); Connect to the selected object. void DoThlo(); Slot for phi1. void DoPhlo(); Slot for phi1. void DoThhi(); Slot for phi1. void DoPhhi(); Slot for phi1. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCtubEditor.html:22547,undo,undoing,22547,root/html534/TGeoCtubEditor.html,https://root.cern,https://root.cern/root/html534/TGeoCtubEditor.html,1,['undo'],['undoing']
Usability,"ound; 1419 - exp, exp2, expm1; 1420 - log, log10, log2, log1p; 1421 - pow; 1422 - sqrt, cbrt; 1423 - sin, cos, tan, asin, acos, atan, atan2, hypot; 1424 - sinh, cosh, tanh, asinh, acosh; 1425 - erf, erfc; 1426 - lgamma, tgamma; 1427 ; 1428If the VDT library is available, the following functions can be invoked. Internally the calculations; 1429are vectorized:; 1430 - fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; 1431 - fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan; 1432 ; 1433\anchor owningandadoptingmemory; 1434## Owning and adopting memory; 1435RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case,; 1436it can be constructed with the address of the memory associated to it and its length. For example:; 1437~~~{.cpp}; 1438std::vector<int> myStlVec {1,2,3};; 1439RVec<int> myRVec(myStlVec.data(), myStlVec.size());; 1440~~~; 1441In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"".; 1442If any method which implies a re-allocation is called, e.g. *emplace_back* or *resize*, the adopted; 1443memory is released and new one is allocated. The previous content is copied in the new memory and; 1444preserved.; 1445 ; 1446\anchor sorting; 1447## Sorting and manipulation of indices; 1448 ; 1449### Sorting; 1450RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms; 1451can be used, for example sorting:; 1452~~~{.cpp}; 1453RVec<double> v{6., 4., 5.};; 1454std::sort(v.begin(), v.end());; 1455~~~; 1456 ; 1457For convenience, helpers are provided too:; 1458~~~{.cpp}; 1459auto sorted_v = Sort(v);; 1460auto reversed_v = Reverse(v);; 1461~~~; 1462 ; 1463### Manipulation of indices; 1464 ; 1465It is also possible to manipulated the RVecs acting on their indices. For example,; 1466the following syntax; 1467~~~{.cpp}; 1468RVecD v0 {9., 7., 8.};; 1469auto v1 = Take(v0, {1, 2, 0});",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:50882,simpl,simply,50882,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['simpl'],['simply']
Usability,"our using the weights of each tree in the chain (see TChain::SetWeight). ; Reimplemented in TChain.; Definition at line 9364 of file TTree.cxx. ◆ Show(). void TTree::Show ; (; Long64_t ; entry = -1, . Int_t ; lenmax = 20 . ). virtual . Print values of all active leaves for entry. . if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. . Definition at line 9375 of file TTree.cxx. ◆ SortBranchesByTime(). void TTree::SortBranchesByTime ; (; ). private . Sorts top-level branches by the last average task time recorded per branch. ; Definition at line 5834 of file TTree.cxx. ◆ StartViewer(). void TTree::StartViewer ; (; ). virtual . Start the TTreeViewer on this tree. . ww is the width of the canvas in pixels; wh is the height of the canvas in pixels . Definition at line 9449 of file TTree.cxx. ◆ StopCacheLearningPhase(). Int_t TTree::StopCacheLearningPhase ; (; ). virtual . Stop the cache learning phase. ; Returns:; 0 learning phase stopped or not active; -1 on error . Definition at line 9464 of file TTree.cxx. ◆ Streamer(). void TTree::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 9535 of file TTree.cxx. ◆ StreamerNVirtual(). void TTree::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 659 of file TTree.h. ◆ UnbinnedFit(). Int_t TTree::UnbinnedFit ; (; const char * ; funcname, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Unbinned fit of one or more variable(s) from a tree. ; funcname is a TF1 function.; See alsoTTree::Draw for explanations of the other parameters.; Fit the variable varexp using the function funcname using the selection cuts given by selection.; The list of fit options is given in parameter option. option = ""Q"" Quiet mode (minimum printing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:218872,learn,learning,218872,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['learn'],['learning']
Usability,"our using the weights of each tree in the chain (see TChain::SetWeight). ; Reimplemented in TChain.; Definition at line 9374 of file TTree.cxx. ◆ Show(). void TTree::Show ; (; Long64_t ; entry = -1, . Int_t ; lenmax = 20 . ). virtual . Print values of all active leaves for entry. . if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. . Definition at line 9385 of file TTree.cxx. ◆ SortBranchesByTime(). void TTree::SortBranchesByTime ; (; ). private . Sorts top-level branches by the last average task time recorded per branch. ; Definition at line 5834 of file TTree.cxx. ◆ StartViewer(). void TTree::StartViewer ; (; ). virtual . Start the TTreeViewer on this tree. . ww is the width of the canvas in pixels; wh is the height of the canvas in pixels . Definition at line 9459 of file TTree.cxx. ◆ StopCacheLearningPhase(). Int_t TTree::StopCacheLearningPhase ; (; ). virtual . Stop the cache learning phase. ; Returns:; 0 learning phase stopped or not active; -1 on error . Definition at line 9474 of file TTree.cxx. ◆ Streamer(). void TTree::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 9545 of file TTree.cxx. ◆ StreamerNVirtual(). void TTree::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 705 of file TTree.h. ◆ UnbinnedFit(). Int_t TTree::UnbinnedFit ; (; const char * ; funcname, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Unbinned fit of one or more variable(s) from a tree. ; funcname is a TF1 function.; See alsoTTree::Draw for explanations of the other parameters.; Fit the variable varexp using the function funcname using the selection cuts given by selection.; The list of fit options is given in parameter option. option = ""Q"" Quiet mode (minimum printing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:221835,learn,learning,221835,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['learn'],['learning']
Usability,"ours); 239 stream << ""\033[0m"";; 240 stream << ""processing file: "" << currentFileIdx << "" / "" << totalFiles << "" "";; 241 ; 242 // Event counts:; 243 if (fUseShellColours); 244 stream << ""\033[32m"";; 245 ; 246 stream << ""processed evts: "" << currentEventCount;; 247 if (GetNEventsOfCurrentFile != 0) {; 248 stream << "" / "" << std::scientific << std::setprecision(2) << GetNEventsOfCurrentFile;; 249 }; 250 stream << "" "";; 251 ; 252 if (fUseShellColours); 253 stream << ""\033[0m"";; 254 ; 255 // events/s; 256 stream << std::scientific << std::setprecision(2) << evtpersec << "" evt/s"";; 257 ; 258 // Time statistics:; 259 if (GetNEventsOfCurrentFile != 0) {; 260 if (fUseShellColours); 261 stream << ""\033[35m"";; 262 std::chrono::seconds remainingSeconds(; 263 static_cast<long long>((ComputeNEventsSoFar() - currentEventCount) / evtpersec));; 264 stream << "" "" << remainingSeconds << "" ""; 265 << "" remaining time (per file being processed)"";; 266 if (fUseShellColours); 267 stream << ""\033[0m"";; 268 }; 269 ; 270 stream << ""] "";; 271}; 272 ; 273void ProgressHelper::PrintStatsFinal(std::ostream &stream, std::chrono::seconds elapsedSeconds) const; 274{; 275 RestoreStreamState restore(stream);; 276 auto totalEvents = ComputeNEventsSoFar();; 277 auto totalFiles = fTotalFiles;; 278 ; 279 if (fUseShellColours); 280 stream << ""\033[35m"";; 281 stream << ""[""; 282 << ""Total elapsed time: "" << elapsedSeconds << "" "";; 283 if (fUseShellColours); 284 stream << ""\033[0m"";; 285 stream << ""processed files: "" << totalFiles << "" / "" << totalFiles << "" "";; 286 ; 287 // Event counts:; 288 if (fUseShellColours); 289 stream << ""\033[32m"";; 290 ; 291 stream << ""processed evts: "" << totalEvents;; 292 if (totalEvents != 0) {; 293 stream << "" / "" << std::scientific << std::setprecision(2) << totalEvents;; 294 }; 295 ; 296 if (fUseShellColours); 297 stream << ""\033[0m"";; 298 ; 299 stream << ""] "";; 300}; 301 ; 302/// Print a progress bar of width `ProgressHelper::fBarWidth` if `fGetNEventsOfCurrentFile` is known.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8cxx_source.html:10739,progress bar,progress bar,10739,doc/master/RDFHelpers_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"ous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_t_debug; TFile*_refFile; list<pair<RooPlot*,string> >_regPlots; list<pair<RooFitResult*,string> >_regResults; list<pair<TH1*,string> >_regTH; list<pair<RooTable*,string> >_regTables; list<pair<Double_t,string> >_regValues; list<pair<RooWorkspace*,string> >_regWS; Int_t_verb; Bool_t_write; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static TDirectory*gMemDir. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooUnitTest(const char* name, TFile* refFile, Bool_t writeRef, Int_t verbose). ~RooUnitTest(). void regPlot(RooPlot* frame, const char* refName). void regResult(RooFitResult* r, const char* refName). void regValue(Double_t value, const char* refName). void regTable(RooTable* t, const char* refName). void regWS(RooWorkspace* ws, const char* refName). void regTH(TH1* h, const char* refName). RooWorkspace* getWS(const char* refName). Bool_t areTHidentical(TH1* htest, TH1* href). Bool_t runCompTests(). void setSilentMode(). void clearSilentMode(). Bool_t runTest(). void setMemDir(TDirectory* memDir); Set gMemDir to memDir. RooUnitTest(const char* name, TFile* refFile, Bool_t writeRef, Int_t verbose). void setDebug(Bool_t flag); { _debug = flag ; }. Bool_t isTestAvailable(); { return kTRUE ; }. Bool_t testCode(). Double_t htol(); { return 5e-4 ; }. Double_t ctol(); { return 2e-3 ; }. Double_t fptol(); { return 1e-3 ; }. Double_t fctol(); { return 1e-3 ; }. Double_t vtol(); { return 1e-3 ; }. » Last changed: Tue Jun 30 14:37:59 2015 » Last generated: 2015-06-30 14:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnitTest.html:8275,clear,clearSilentMode,8275,root/html602/RooUnitTest.html,https://root.cern,https://root.cern/root/html602/RooUnitTest.html,1,['clear'],['clearSilentMode']
Usability,"out . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » First Steps With ROOT Simulation in ROOT. The ROOT framework consists of many classes, grouped into several categories. Finally, the latter are grouped into few top-level categories. Each top-level category comes with a basic description of the framework design and of the purpose of its categories, which also have more detailed documentation about their use. The most complete documentation is the Reference Guide, that contains the automatically generated documentation of each class.; This document is about the top-level categories related to simulation. . ‹ Graphics 3D; up; Virtual Monte-Carlo ›. Navigate through this book; Processing data with ROOT; Showing results with ROOT; Simulation in ROOTVirtual Monte-Carlo; Geometry; Tracks. ROOT I/O. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/simulation-root.html:2844,guid,guidelines,2844,d/simulation-root.html,https://root.cern,https://root.cern/d/simulation-root.html,1,['guid'],['guidelines']
Usability,"oveAll(); virtual voidTCollection::RemoveAll(TCollection* col); virtual TObject*TSeqCollection::RemoveAt(Int_t idx); virtual voidTSeqCollection::RemoveBefore(TObject* before); virtual voidTSeqCollection::RemoveFirst(); virtual voidTList::RemoveLast(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetArgs(Int_t nargs); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTCollection::SetCurrentCollection(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTCollection::SetOwner(Bool_t enable = kTRUE); virtual voidSetRedoArgs(Int_t nargs); virtual voidSetTitle(const char* title); virtual voidSetUndoArgs(Int_t nargs); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTList::Sort(Bool_t order = kSortAscending); static voidTCollection::StartGarbageCollection(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TQCommand(const TQCommand& com); TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); virtual voidUndo(Option_t* option = """")SIGNAL ; voidTSeqCollection::UnSort(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:14219,undo,undo,14219,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,4,['undo'],['undo']
Usability,"oved from the input string opt.; If action == 0, set up the output file accordingly, if action == 1 clean related; output file settings.; If the final target file is local then 'target' is set to the final local path; when action == 0 and used to retrieve the file with TFile::Cp when action == 1. Output file settings are in the form. <previous_option>of=name <next_option>; <previous_option>outfile=name,...;<next_option>. The separator from the next option is either a ' ' or a ';'; Called interanally by TProof::Process. Returns 0 on success, -1 on error. void SetFeedback(TString& opt, TString& optfb, Int_t action); Extract from opt in optfb information about wanted feedback settings.; Feedback are removed from the input string opt.; If action == 0, set up feedback accordingly, if action == 1 clean related; feedback settings (using info in optfb, if available, or reparsing opt). Feedback requirements are in the form. <previous_option>fb=name1,name2,name3,... <next_option>; <previous_option>feedback=name1,name2,name3,...;<next_option>. The special name 'stats' triggers feedback about events and packets.; The separator from the next option is either a ' ' or a ';'.; Called interanally by TProof::Process. Long64_t Process(TDSet* dset, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TDSet) using the specified selector (.C) file or; Tselector object; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(TFileCollection* fc, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TFileCollection) using the specified selector (.C) file; or TSelector object.; The default tree is analyzed (i.e. the first one found). To specify another; tree, the default tree can be changed using TFileCollection::SetDefaultMetaData ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:51301,feedback,feedback,51301,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['feedback'],['feedback']
Usability,"over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Accessing file system; THttpServer provides partial access to the files from file system. First of all, JSROOT scripts and files can be accessed via “jsrootsys/” path like “http://localhost:8080/jsrootsys/modules/core.mjs”. Files from ROOT install directory can be get via “rootsys/” path like “http://localhost:8080/rootsys/icons/about.xpm”. Also files from current directory where ROOT is running can be accessed via “currentdir/” path like “http://localhost:8080/currentdir/file.txt”.; If necessary, one can add custom path as well, using THttpServer::AddLocation method:; serv->AddLocation(""mydir/"", ""/home/user/specials"");; Then files from that directory could be addressed via URL like “http://localhost:8080/mydir/myfile.root”; 1.4 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call.; One could configure argument(s) for the command. For that one should use %arg1, %arg2 and so on identifiers. Like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; User will be requested to enter arguments values, when command element clicked in the browser. Example of the command which executes arbitrary string in application via ProcessLine looks like:; serv->RegisterCommand(""/Process"", ""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; strin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:4755,simpl,simple,4755,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['simpl'],['simple']
Usability,"override;  ; const RooArgList & categoricalComponents () const;  ; TObject * clone (const char *newname) const override;  ; RooArgList components ();  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force internal handling of integration of given observable if any of the product terms depend on it. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Declare that we handle all integrations internally. ;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  Forward the plot sampling hint from the p.d.f. that defines the observable obs. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the product operator construction. ;  ; const RooArgList & realComponents () const;  ; void setCacheAndTrackHints (RooArgSet &) override;  Label OK'ed components of a RooProduct with cache-and-track. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProduct.html:2403,intuit,intuitively,2403,doc/master/classRooProduct.html,https://root.cern,https://root.cern/doc/master/classRooProduct.html,1,['intuit'],['intuitively']
Usability,"overrideprotectedvirtual . Evaluate the category state and return. ; The returned state index should correspond to a state name that has been defined via e.g. defineType(). ; Implements RooAbsCategory.; Definition at line 153 of file RooMappedCategory.cxx. ◆ getOrCreateCache(). const RooMappedCategoryCache * RooMappedCategory::getOrCreateCache ; (; ); const. protected . Definition at line 159 of file RooMappedCategory.cxx. ◆ IsA(). TClass * RooMappedCategory::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCategory.; Definition at line 91 of file RooMappedCategory.h. ◆ map(). bool RooMappedCategory::map ; (; const char * ; inKeyRegExp, . const char * ; outKeyName, . Int_t ; outKeyNum = NoCatIdx . ). Definition at line 106 of file RooMappedCategory.cxx. ◆ printMetaArgs(). void RooMappedCategory::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooMappedCategory to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 253 of file RooMappedCategory.cxx. ◆ printMultiline(). void RooMappedCategory::printMultiline ; (; std::ostream & ; os, . Int_t ; contents, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Print info about this object to the specified stream. ; In addition to the info from RooAbsArg::printStream() we add: Shape : label, index, defined types . Reimplemented from RooAbsCategory.; Definition at line 166 of file RooMappedCategory.cxx. ◆ readFromStream(). bool RooMappedCategory::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Read object contents from stream (dummy for now) ; Reimplemented from RooAbsCategory.; Definition at line 192 of file RooMappedCategory.cxx. ◆ recomputeShape(). void RooMappedCategory::recomputeShape ; (; ). overrideprotectedvirtual . When the input category chan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:47895,intuit,intuitively,47895,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,1,['intuit'],['intuitively']
Usability,"overridevirtual . Read object contents from given stream. ; Reimplemented from RooAbsReal.; Definition at line 212 of file RooFormulaVar.cxx. ◆ redirectServersHook(). bool RooFormulaVar::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overrideprotectedvirtual . Propagate server change information to embedded RooFormula object. ; Reimplemented from RooAbsReal.; Definition at line 173 of file RooFormulaVar.cxx. ◆ Streamer(). void RooFormulaVar::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooFormulaVar::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 93 of file RooFormulaVar.h. ◆ translate(). void RooFormulaVar::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 316 of file RooFormulaVar.cxx. ◆ writeToStream(). void RooFormulaVar::writeToStream ; (; std::ostream & ; os, . bool ; compact . ); const. overridevirtual . Write object contents to given stream. ; Reimplemented from RooAbsReal.; Definition at line 223 of file RooFormulaVar.cxx. Member Data Documentation. ◆ _actualVars. RooListProxy RooFormulaVar::_actualVars. private . Actual parameters used by formula engine. ; Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormulaVar.html:70226,simpl,simple,70226,doc/master/classRooFormulaVar.html,https://root.cern,https://root.cern/doc/master/classRooFormulaVar.html,1,['simpl'],['simple']
Usability,"ow(((y-[MeanY])/[SigmaY]),2)), a 2d Gaussian without correlation.; bigaus is a substitute for [Constant]*ROOT::Math::bigaussian_pdf (x,y,[SigmaX],[SigmaY],[Rho],[MeanX],[MeanY]), a 2d gaussian including a correlation parameter. Three Dimensional functions:; xyzgaus is for a 3d Gaussians without correlations: [Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2 )- 0.5*pow(((z-[MeanZ])/[SigmaZ]),2)). An expanded note on variables and parameters; In a TFormula, a variable is a defined by a name x, y, z or t or an index like x[0], x[1], x[2]; that is x[N] where N is an integer.; TFormula("""", ""x[0] * x[1] + 10""); TFormula::TFormulaTFormula()Definition TFormula.cxx:438; Parameters are similar and can take any name. It is specified using brackets e.g. [expected_mass] or [0].; TFormula("""", ""exp([expected_mass])-1""); Variables and parameters can be combined in the same TFormula. Here we consider a very simple case where we have an exponential decay after some time t and a number of events with timestamps for which we want to evaluate this function.; TFormula tf ("""", ""[0]*exp(-[1]*t)"");; tf.SetParameter(0, 1);; tf.SetParameter(1, 0.5);; ; for (auto & event : events) {; tf.Eval(event.t);; }; The distinction between variables and parameters arose from the TFormula's application in fitting. There parameters are fitted to the data provided through variables. In other applications this distinction can go away.; Parameter values can be provided dynamically using TFormula::EvalPar instead of TFormula::Eval. In this way parameters can be used identically to variables. See below for an example that uses only parameters to model a function.; Int_t params[2] = {1, 2}; // {vel_x, vel_y}; TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");; ; tf.EvalPar(nullptr, params);; int. A note on operators; All operators of C/C++ are allowed in a TFormula with a few caveats.; The operators |, &, % can be used but will raise an error if used in conjunction with a v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFormula.html:6355,simpl,simple,6355,doc/master/classTFormula.html,https://root.cern,https://root.cern/doc/master/classTFormula.html,1,['simpl'],['simple']
Usability,"ow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMixtureEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for mixture editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected mixture. void DoChkFraction(); Check button state changed for fraction. void DoChkNatoms(); Check button state changed for natoms. void DoFraction(); Fraction changed. void DoNatoms(); Natoms changed. void DoSelectElement(Int_t iel); Slot for selecting an element. void DoAddElem(); Slot for adding an element. No undo. void DoApply1(); Slot for applying modifications. void DoUndo1(); Slot for undoing all changes. void UpdateElements(); Update the list of elements in the TGCanvas. TGeoMixtureEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); {}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoMixtureEditor.html:24012,undo,undo,24012,root/html604/TGeoMixtureEditor.html,https://root.cern,https://root.cern/root/html604/TGeoMixtureEditor.html,2,['undo'],"['undo', 'undoing']"
Usability,"ow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMixtureEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for mixture editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected mixture. void DoChkFraction(); Check button state changed for fraction. void DoChkNatoms(); Check button state changed for natoms. void DoFraction(); Fraction changed. void DoNatoms(); Natoms changed. void DoSelectElement(Int_t iel); Slot for selecting an element. void DoAddElem(); Slot for adding an element. No undo. void DoApply1(); Slot for applying modifications. void DoUndo1(); Slot for undoing all changes. void UpdateElements(); Update the list of elements in the TGCanvas. TGeoMixtureEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); {}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoMixtureEditor.html:24012,undo,undo,24012,root/html602/TGeoMixtureEditor.html,https://root.cern,https://root.cern/root/html602/TGeoMixtureEditor.html,2,['undo'],"['undo', 'undoing']"
Usability,"owing classes: TCutG, TMultiDimFit, TPrincipal, TChains. In addition it contains the gHtml object, gMinuit objects, and the array of contours graphs (TGraph) created when calling the Draw method of a histogram with the ""CONT, LIST"" option.; 8.2.2 Access to the Collection Contents; The current content for a collection listed above can be accessed with the corresponding gROOT->GetListOf method (for example gROOT->GetListOfCanvases). In addition, gROOT->GetListOfBrowsables returns a collection of all objects visible on the left side panel in the browser. See the image of the Object Browser in the next figure. The ROOT Object Browser. 8.3 Ownership by Other Objects; When an object creates another, the creating object is the owner of the created one. For example:; myHisto->Fit(""gaus""); The call to Fit copies the global TF1 Gaussian function and attaches the copy to the histogram. When the histogram is deleted, the copy is deleted also.; When a pad is deleted or cleared, all objects in the pad with the kCanDelete bit set are deleted automatically. Currently the objects created by the DrawCopy methods, have the kCanDelete bit set and are therefore owned by the pad.; 8.4 Ownership by the User; The user owns all objects not described in one of the above cases. TObject has two bits, kCanDelete and kMustCleanup, that influence how an object is managed (in TObject::fBits). These are in an enumeration in TObject.h. To set these bits do:; MyObject->SetBit(kCanDelete); MyObject->SetBit(kMustCleanup); The bits can be reset and tested with the TObject::ResetBit and TObject::TestBit methods.; 8.4.1 The kCanDelete Bit; The gROOT collections (see above) own their members and will delete them regardless of the kCanDelete bit. In all other collections, when the collection Clear method is called (i.e. TList::Clear()), members with the kCanDelete bit set, are deleted and removed from the collection. If the kCanDelete bit is not set, the object is only removed from the collection but not del",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:286215,clear,cleared,286215,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['clear'],['cleared']
Usability,"owse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Download Downloading ROOT. We are developing ROOT according to the principle of Release early and release often. However, since a very large portion of the user base requires a stable product we generally keep at least three versions of the system available for download. The development, production and old versions.; Production release; This is a version we feel comfortable with to exposing to a large audience for serious work. We may issue patch releases of production versions with bug fixes. We release about two production versions per year. The old version is the previous production version that people might need for some time before switching to the new version.; Release candidate; A Release Candidate is a preview of the next production release. It allows users to make their code ready for the new production release, and to provide early feedback.; Development release; Use this to get access to the latest and greatest, but as a side effect there might be some instabilities. However, by trying out the development version you can help us converge much more quickly to a stable version that can then become the new production version.; Nightlies; You can download nightly snapshots of ROOT. That's useful to check whether a bug fix actually fixes an issue you reported, or to see the newest feature you heard about. It helps us tremendously to get feedback from you on nightlies: please try them out and report back to us!; Using binaries; After unpacking / installing the binary, and before using ROOT you should use a special script distributed with ROOT:; source <pathname>/root/bin/thisroot.sh (there are versions for [t]csh and fish, too.); where <pathname> is the location where you unpacked the ROOT distribution.; Typically add these lines to your .profile or .login files. Docker (Expe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/downloading-root.html:2707,feedback,feedback,2707,d/downloading-root.html,https://root.cern,https://root.cern/d/downloading-root.html,1,['feedback'],['feedback']
Usability,"oximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin J. 2; H(J) = sum Y E(J) = sum Y; l(J) = sum l L(J) = sum l; h(J) = H(J)/L(J) mean of Y,; s(J) = sqrt(E(J)/L(J)- h(J)**2) standard deviation of Y (e.g. RMS); e(J) = s(J)/sqrt(L(J)) standard error on the mean. The displayed bin content for bin J of a TProfile is always h(J). The corresponding bin error is by default; e(J). In case the option ""s"" is used (in the constructor or by calling TProfile::BuildOptions); the displayed error is s(J). In the special case where s(J) is zero (eg, case of 1 entry only in one bin); the bin error e(J) is computed from the average of the s(J) for all bins if; the static function TProfile::Approximate has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour.; See also TProfile::BuildOptions for other error options and more detailed explanations. Example of a profile histogram with its graphics output; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }. /*; ; */. Function Members (Methods); public:. TProfile(); TProfile(const TProfile& profile); TProfile(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Option_t* option = """"); TProfile(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Option_t* option = """"); TProfile(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Option_t* option = """"); TProfile(const char* nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile.html:1819,simpl,simple,1819,root/html534/TProfile.html,https://root.cern,https://root.cern/root/html534/TProfile.html,1,['simpl'],['simple']
Usability,"oximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin J. 2; H(J) = sum Y E(J) = sum Y; l(J) = sum l L(J) = sum l; h(J) = H(J)/L(J) mean of Y,; s(J) = sqrt(E(J)/L(J)- h(J)**2) standard deviation of Y (e.g. RMS); e(J) = s(J)/sqrt(L(J)) standard error on the mean. The displayed bin content for bin J of a TProfile is always h(J). The corresponding bin error is by default; e(J). In case the option ""s"" is used (in the constructor or by calling TProfile::BuildOptions); the displayed error is s(J). In the special case where s(J) is zero (eg, case of 1 entry only in one bin); the bin error e(J) is computed from the average of the s(J) for all bins if; the static function TProfile::Approximate has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour.; See also TProfile::BuildOptions for other error options and more detailed explanations. Example of a profile histogram with its graphics output; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }. /*; ; */. Function Members (Methods); public:. virtual~TProfile(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAdd(const TH1* h1, Double_t c1 = 1); virtual Bool_tAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual Bool_tAdd(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayD::AddAt(Double_t c, Int_t i); virtual voidTH1D::AddBinContent(Int_t bin); virtual voidTH1D::AddBinConten",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProfile.html:1819,simpl,simple,1819,root/html602/TProfile.html,https://root.cern,https://root.cern/root/html602/TProfile.html,2,['simpl'],['simple']
Usability,"p between the pieces is not defined by neighbors, but by ""containment"". In other words, volumes are put one inside another making an in-depth hierarchy. From outside, the whole thing looks like a big pack that you can open finding out other smaller packs nicely arranged waiting to be opened at their turn. The biggest one containing all others defines the ""world"" of the model. We will often call this ""master reference system (MARS)"". Going on and opening our packs, we will obviously find out some empty ones, otherwise, something is very wrong... We will call these leaves (by analogy with a tree structure).; On the other hand, any volume is a small world by itself - what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:. Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does ""make map"" in root folder.; root[] gSystem->Load(""libGeom"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; We want to create a single volume in our geometry, but since any volume n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:3841,simpl,simplest,3841,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simplest']
Usability,"p for the stochastic method buffer should contain the previous dw vector and will be updated. ; Definition at line 2158 of file TMultiLayerPerceptron.cxx. ◆ operator=(). TMultiLayerPerceptron & TMultiLayerPerceptron::operator= ; (; const TMultiLayerPerceptron & ; ). private . ◆ Randomize(). void TMultiLayerPerceptron::Randomize ; (; ); const. Randomize the weights. ; Definition at line 1239 of file TMultiLayerPerceptron.cxx. ◆ Result(). Double_t TMultiLayerPerceptron::Result ; (; Int_t ; event, . Int_t ; index = 0 . ); const. Computes the output for a given event. ; Look at the output neuron designed by index. ; Definition at line 1033 of file TMultiLayerPerceptron.cxx. ◆ SetData(). void TMultiLayerPerceptron::SetData ; (; TTree * ; data). Set the data source. ; Definition at line 590 of file TMultiLayerPerceptron.cxx. ◆ SetDelta(). void TMultiLayerPerceptron::SetDelta ; (; Double_t ; delta). Sets Delta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 720 of file TMultiLayerPerceptron.cxx. ◆ SetEpsilon(). void TMultiLayerPerceptron::SetEpsilon ; (; Double_t ; eps). Sets Epsilon - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 710 of file TMultiLayerPerceptron.cxx. ◆ SetEta(). void TMultiLayerPerceptron::SetEta ; (; Double_t ; eta). Sets Eta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 700 of file TMultiLayerPerceptron.cxx. ◆ SetEtaDecay(). void TMultiLayerPerceptron::SetEtaDecay ; (; Double_t ; ed). Sets EtaDecay - Eta *= EtaDecay at each epoch (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 730 of file TMultiLayerPerceptron.cxx. ◆ SetEventWeight(). void TMultiLayerPerceptron::SetEventWeight ; (; const char * ; branch)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:44689,learn,learning,44689,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['learn'],['learning']
Usability,"p over all entries on the TTree.; while (subscriptionManager.Next()) {; // Now myTribuneDeGeneve has loaded its data and we can access it.; // TTreeReaderValue behaves like an iterator; you need to use ""->"" on; // it to access the data it refers to.; myTribuneDeGeneve->read();; ...; }. Summary; As you saw, TTree is about. Chunking up similar, disconnected entries of which typically only one needs to be available, just like newspaper issues or data from High Energy Physics collisions, also known as the entries of a TTree; Selecting which data the TTree should provide, i.e. subscribing to certain branches only. Branches can be nested, so depending on the tree you could even subscribe to only the sports section or even only an article, reducing data transfer. A precedure like this is actually what most physicists do to analyze data from a series of TTrees. So let's try it in practice!; . ‹ Using TTree::Draw() to access a TTree; up; Using a Macro to Read a TTree ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/ttree-and-its-data.html:5006,guid,guidelines,5006,d/ttree-and-its-data.html,https://root.cern,https://root.cern/d/ttree-and-its-data.html,1,['guid'],['guidelines']
Usability,"p; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TDataSet::EDataSetPassTDataSet::kPrune; static TDataSet::EDataSetPassTDataSet::kRefs; static TDataSet::EBitOptTDataSet::kReset; static TDataSet::EBitOptTDataSet::kSet; static TObject::(anonymous)TObject::kSingleKey; static TDataSet::EDataSetPassTDataSet::kStop; static TDataSet::EDataSetPassTDataSet::kStruct; static TDataSet::EDataSetPassTDataSet::kUp; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. ULong_tTChair::fLastIndxindex pof the last used table row;; void*TChair::fLastRowpointer to the last used table row; fLastRow = table[fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*TChair::fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TColumnView(const char* colName = """", TTable* table = 0); constructor. ~TColumnView(); destructor. void Browse(TBrowser* b); Create a column histogram for the simple column. TH1 * Histogram(const char* selection = """"); Create a histogram from the context menu. Bool_t IsFolder() const; Treat the column with the pointer to the ""Ptr"" as a ""folder"". TColumnView(const char* colName = """", TTable* table = 0). » Author: Valery Fine(fine@bnl.gov) 13/03/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-06-02 15:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TColumnView.html:11954,simpl,simple,11954,root/html604/TColumnView.html,https://root.cern,https://root.cern/root/html604/TColumnView.html,1,['simpl'],['simple']
Usability,"p; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TDataSet::EDataSetPassTDataSet::kPrune; static TDataSet::EDataSetPassTDataSet::kRefs; static TDataSet::EBitOptTDataSet::kReset; static TDataSet::EBitOptTDataSet::kSet; static TObject::(anonymous)TObject::kSingleKey; static TDataSet::EDataSetPassTDataSet::kStop; static TDataSet::EDataSetPassTDataSet::kStruct; static TDataSet::EDataSetPassTDataSet::kUp; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. ULong_tTChair::fLastIndxindex pof the last used table row;; void*TChair::fLastRowpointer to the last used table row; fLastRow = table[fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*TChair::fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TColumnView(const char* colName = """", TTable* table = 0); constructor. ~TColumnView(); destructor. void Browse(TBrowser* b); Create a column histogram for the simple column. TH1 * Histogram(const char* selection = """"); Create a histogram from the context menu. Bool_t IsFolder() const; Treat the column with the pointer to the ""Ptr"" as a ""folder"". TColumnView(const char* colName = """", TTable* table = 0). » Author: Valery Fine(fine@bnl.gov) 13/03/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TColumnView.html:11954,simpl,simple,11954,root/html602/TColumnView.html,https://root.cern,https://root.cern/root/html602/TColumnView.html,1,['simpl'],['simple']
Usability,"p<SMatrix<T,D1,D2,R>,T,D1,D2>, T, D2, D1, typename TranspPolicy<T,D1,D2,R>::RepType>; 540 Transpose(const SMatrix<T,D1,D2, R>& rhs) {; 541 typedef TransposeOp<SMatrix<T,D1,D2,R>,T,D1,D2> MatTrOp;; 542 ; 543 return Expr<MatTrOp, T, D2, D1, typename TranspPolicy<T,D1,D2,R>::RepType>(MatTrOp(rhs));; 544}; 545 ; 546//==============================================================================; 547// transpose; 548//==============================================================================; 549template <class A, class T, unsigned int D1, unsigned int D2, class R>; 550inline Expr<TransposeOp<Expr<A,T,D1,D2,R>,T,D1,D2>, T, D2, D1, typename TranspPolicy<T,D1,D2,R>::RepType>; 551 Transpose(const Expr<A,T,D1,D2,R>& rhs) {; 552 typedef TransposeOp<Expr<A,T,D1,D2,R>,T,D1,D2> MatTrOp;; 553 ; 554 return Expr<MatTrOp, T, D2, D1, typename TranspPolicy<T,D1,D2,R>::RepType>(MatTrOp(rhs));; 555}; 556 ; 557 ; 558#ifdef ENABLE_TEMPORARIES_TRANSPOSE; 559// sometimes is faster to create a temp, not clear why; 560 ; 561//==============================================================================; 562// transpose; 563//==============================================================================; 564template <class T, unsigned int D1, unsigned int D2, class R>; 565inline SMatrix< T, D2, D1, typename TranspPolicy<T,D1,D2,R>::RepType>; 566 Transpose(const SMatrix<T,D1,D2, R>& rhs) {; 567 typedef TransposeOp<SMatrix<T,D1,D2,R>,T,D1,D2> MatTrOp;; 568 ; 569 return SMatrix< T, D2, D1, typename TranspPolicy<T,D1,D2,R>::RepType>; 570 ( Expr<MatTrOp, T, D2, D1, typename TranspPolicy<T,D1,D2,R>::RepType>(MatTrOp(rhs)) );; 571}; 572 ; 573//==============================================================================; 574// transpose; 575//==============================================================================; 576template <class A, class T, unsigned int D1, unsigned int D2, class R>; 577inline SMatrix< T, D2, D1, typename TranspPolicy<T,D1,D2,R>::RepType>; 578 Transpose(const Expr<A,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MatrixFunctions_8h_source.html:22835,clear,clear,22835,doc/master/MatrixFunctions_8h_source.html,https://root.cern,https://root.cern/doc/master/MatrixFunctions_8h_source.html,1,['clear'],['clear']
Usability,"pFeedback(); Stop feedback (may not be used in this class). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (may not be used in this class). void HandleGetTreeHeader(TMessage* mess); Handle tree header request. void HandleRecvHisto(TMessage* mess); Receive histo from slave. Int_t DrawCanvas(TObject* obj); Draw the object if it is a canvas.; Return 0 in case of success, 1 if it is not a canvas or libProofDraw; is not available. Int_t GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); Parse the arguments from var, sel and opt and fill the selector and; object name accordingly.; Return 0 in case of success, 1 if libProofDraw is not available. void FeedBackCanvas(const char* name, Bool_t create); Create/destroy a named canvas for feedback. Long64_t GetCacheSize(); Return the size in bytes of the cache. Int_t GetLearnEntries(); Return the number of entries in the learning phase. void * GetSender(); { return this; }. TProofPlayer(TProof* proof = 0). TVirtualPacketizer * GetPacketizer() const; { return 0; }. TList * GetInputList() const; { return fInput; }. TList * GetListOfResults() const; { return fQueryResults; }. TQueryResult * GetCurrentQuery() const; { return fQuery; }. void SetMaxDrawQueries(Int_t max); { fMaxDrawQueries = max; }. void RestorePreviousQuery(); { fQuery = fPreviousQuery; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). Bool_t IsClient() const; { return kFALSE; }. void SetExitStatus(TVirtualProofPlayer::EExitStatus st); { fExitStatus = st; }. EExitStatus GetExitStatus() const; { return fExitStatus; }. Long64_t GetEventsProcessed() const; { return fProgressStatus->GetEntr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayer.html:22657,learn,learning,22657,root/html602/TProofPlayer.html,https://root.cern,https://root.cern/root/html602/TProofPlayer.html,2,['learn'],['learning']
Usability,"pFeedback(); Stop feedback (may not be used in this class). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (may not be used in this class). void HandleGetTreeHeader(TMessage* mess); Handle tree header request. void HandleRecvHisto(TMessage* mess); Receive histo from slave. Int_t DrawCanvas(TObject* obj); Draw the object if it is a canvas.; Return 0 in case of success, 1 if it is not a canvas or libProofDraw; is not available. Int_t GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); Parse the arguments from var, sel and opt and fill the selector and; object name accordingly.; Return 0 in case of success, 1 if libProofDraw is not available. void FeedBackCanvas(const char* name, Bool_t create); Create/destroy a named canvas for feedback. Long64_t GetCacheSize(); Return the size in bytes of the cache. Int_t GetLearnEntries(); Return the number of entries in the learning phase. void * GetSender(); { return this; }. TVirtualPacketizer * GetPacketizer() const; { return 0; }. TList * GetInputList() const; { return fInput; }. TList * GetListOfResults() const; { return fQueryResults; }. TQueryResult * GetCurrentQuery() const; { return fQuery; }. void SetMaxDrawQueries(Int_t max); { fMaxDrawQueries = max; }. void RestorePreviousQuery(); { fQuery = fPreviousQuery; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). Bool_t IsClient() const; { return kFALSE; }. EExitStatus GetExitStatus() const; { return fExitStatus; }. Long64_t GetEventsProcessed() const; { return fProgressStatus->GetEntries(); }. void AddEventsProcessed(Long64_t ev); { fProgressStatus->IncEntries(ev); }. void SetInitTime(); { }. TP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayer.html:18689,learn,learning,18689,root/html528/TProofPlayer.html,https://root.cern,https://root.cern/root/html528/TProofPlayer.html,3,['learn'],['learning']
Usability,"pFeedback(); Stop feedback (may not be used in this class). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (may not be used in this class). void HandleGetTreeHeader(TMessage* mess); Handle tree header request. void HandleRecvHisto(TMessage* mess); Receive histo from slave. Int_t DrawCanvas(TObject* obj); Draw the object if it is a canvas.; Return 0 in case of success, 1 if it is not a canvas or libProofDraw; is not available. Int_t GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); Parse the arguments from var, sel and opt and fill the selector and; object name accordingly.; Return 0 in case of success, 1 if libProofDraw is not available. void FeedBackCanvas(const char* name, Bool_t create); Create/destroy a named canvas for feedback. Long64_t GetCacheSize(); Return the size in bytes of the cache. Int_t GetLearnEntries(); Return the number of entries in the learning phase. void * GetSender(); { return this; }. TVirtualPacketizer * GetPacketizer() const; { return 0; }. TList * GetInputList() const; { return fInput; }. TList * GetListOfResults() const; { return fQueryResults; }. TQueryResult * GetCurrentQuery() const; { return fQuery; }. void SetMaxDrawQueries(Int_t max); { fMaxDrawQueries = max; }. void RestorePreviousQuery(); { fQuery = fPreviousQuery; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). Bool_t IsClient() const; { return kFALSE; }. void SetExitStatus(TVirtualProofPlayer::EExitStatus st); { fExitStatus = st; }. EExitStatus GetExitStatus() const; { return fExitStatus; }. Long64_t GetEventsProcessed() const; { return fProgressStatus->GetEntries(); }. void AddEventsProcessed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:21979,learn,learning,21979,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,1,['learn'],['learning']
Usability,"pNet_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Matrix_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 47 of file Adadelta.h. ◆ Scalar_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 48 of file Adadelta.h. Constructor & Destructor Documentation. ◆ TAdadelta(). template<typename Architecture_t , typename Layer_t , typename DeepNet_t > . TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::TAdadelta ; (; DeepNet_t & ; deepNet, . Scalar_t ; learningRate = 1.0, . Scalar_t ; rho = 0.95, . Scalar_t ; epsilon = 1e-8 . ). Constructor. ; Definition at line 102 of file Adadelta.h. ◆ ~TAdadelta(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::~TAdadelta ; (; ). default . Destructor. . Member Function Documentation. ◆ GetEpsilon(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::GetEpsilon ; (; ); const. inline . Definition at line 82 of file Adadelta.h. ◆ GetPastSquaredBiasGradients(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector< std::vector< Matrix_t > > & TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html:5615,learn,learningRate,5615,doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,1,['learn'],['learningRate']
Usability,"pVar.cxx. ◆ setInterpCode(). void FlexibleInterpVar::setInterpCode ; (; RooAbsReal & ; param, . int ; code . ). Definition at line 115 of file FlexibleInterpVar.cxx. ◆ setLow(). void FlexibleInterpVar::setLow ; (; RooAbsReal & ; param, . double ; newLow . ). Definition at line 150 of file FlexibleInterpVar.cxx. ◆ setNominal(). void FlexibleInterpVar::setNominal ; (; double ; newNominal). Definition at line 141 of file FlexibleInterpVar.cxx. ◆ Streamer(). void RooStats::HistFactory::FlexibleInterpVar::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooStats::HistFactory::FlexibleInterpVar::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 74 of file FlexibleInterpVar.h. ◆ translate(). void FlexibleInterpVar::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 221 of file FlexibleInterpVar.cxx. ◆ variables(). const RooListProxy & RooStats::HistFactory::FlexibleInterpVar::variables ; (; ); const. inline . Definition at line 54 of file FlexibleInterpVar.h. Member Data Documentation. ◆ _high. std::vector<double> RooStats::HistFactory::FlexibleInterpVar::_high. protected . Definition at line 68 of file FlexibleInterpVar.h. ◆ _interpBoundary. double RooStats::HistFactory::FlexibleInterpV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html:67091,simpl,simple,67091,doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html,1,['simpl'],['simple']
Usability,"page lists a number of ROOT tutorials and courses. Some are made by third parties others by the ROOT team.; Basic. ROOT Basic Course (CERN Technical Training: register here) ; CERN Summer Students' Introductory Tutorial (2018 2017, 2016, 2015 ); First Steps With ROOT; Introductory Tutorials (approx 2 hours); Lectures at the CERN School of Computing (CSC); Bill Seligman's ROOT Tutorial. Intermediate; These are general ROOT tutorials covering the basics of ROOT like Histograms, Trees, I/O, PROOF and Fitting. They are made by the ROOT team and consists of slides and a series of exercises described in corresponding TWIKI pages. ROOT tutorial at JRC-IRMM, Belgium, Feb 2014; ROOT tutorial at Gridka School, Aug 2013 (Slides, Exercises) ; ROOT 6 Analysis Workshop (GridKA 2014); ROOT Tree-I/O tutorial at Desy C++ School, Nov 2013 (Slides, Exercises) ; ROOT tutorial at La Plata (ULP), Nov 2013 . RooFit/RooStats tutorials. RooFit/RooStats tutorial for INFN School of statistics 2013 (Slides, Exercises); RooFit/RooStats tutorial for Desy School of Statistics 2015 (RooFit slides, RooStats slides, Exercises). Older but still very valuable resources. BaBar tutorials; FNAL tutorials; Minos tutorials. Preparing ROOT courses for the CERN technical training. ROOT courses proposal; Working document for the courses. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/courses.html:3424,guid,guidelines,3424,d/courses.html,https://root.cern,https://root.cern/d/courses.html,1,['guid'],['guidelines']
Usability,"pand(this, fNumber);; 2994 } else {; 2995 if (!infos->At(fNumber)) {; 2996 infos->AddAt(this, fNumber);; 2997 }; 2998 }; 2999 ; 3000 assert(fComp == 0 && fCompFull == 0 && fCompOpt == 0);; 3001 ; 3002 ; 3003 Int_t ndata = fElements->GetEntriesFast();; 3004 ; 3005 ; 3006 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 3007 else fReadObjectWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3008 ; 3009 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 3010 else fWriteObjectWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3011 ; 3012 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 3013 else fReadMemberWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3014 ; 3015 if (fReadText) fReadText->fActions.clear();; 3016 else fReadText = new TStreamerInfoActions::TActionSequence(this,ndata);; 3017 ; 3018 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 3019 else fWriteMemberWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3020 ; 3021 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 3022 else fReadMemberWiseVecPtr = new TStreamerInfoActions::TActionSequence(this, ndata, kTRUE);; 3023 ; 3024 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 3025 else fWriteMemberWiseVecPtr = new TStreamerInfoActions::TActionSequence(this, ndata, kTRUE);; 3026 ; 3027 if (fWriteText) fWriteText->fActions.clear();; 3028 else fWriteText = new TStreamerInfoActions::TActionSequence(this,ndata);; 3029 ; 3030 if (!ndata) {; 3031 // This may be the case for empty classes (e.g., TAtt3D).; 3032 // We still need to properly set the size of emulated classes (i.e. add the virtual table); 3033 if (fClass->GetState() == TClass::kEmulated && fNVirtualInfoLoc!=0) {; 3034 fSize = sizeof(TStreamerInfo*);; 3035 }; 3036 fComp = new TCompInfo[1];; 3037 fCompFull = new TCompInfo*[1];; 3038 fCompOpt = new TCompInfo*[1];; 3039 fCompOpt[0] = fCompFull[0] = &(fComp[0]);; 3040 SetIsCompiled();; 304",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:132220,clear,clear,132220,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['clear'],['clear']
Usability,"parison procedure can include an analysis of the residuals which is often helpful in identifying the bins of histograms responsible for a significant overall \( \chi^{2} \) value. Most convenient for analysis are the adjusted (normalized) residuals [4] ; \[; r_{i} = \frac{n_{i}-N\hat{p}_{i}}{\sqrt{N\hat{p}_{i}}\sqrt{(1-N/(N+M))(1-(n_{i}+m_{i})/(N+M))}}; \]. If hypotheses of homogeneity are valid then residuals ri are approximately independent and identically distributed random variables having N(0,1) distribution. The application of the \( \chi^{2} \) test has restrictions related to the value of the expected frequencies Npi, Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the expectations must be 1 or greater for both histograms. In practical cases when expected frequencies are not known the estimated expected frequencies \( M\hat{p}_{i}, N\hat{p}_{i}, i=1,...,r \) can be used.; Unweighted and weighted histograms comparison:; A simple modification of the ideas described above can be used for the comparison of the usual (unweighted) and weighted histograms. Let us denote the number of events in the ith bin in the unweighted histogram as ni and the common weight of events in the ith bin of the weighted histogram as wi. The total number of events in the unweighted histogram is equal to ; \[; N = \sum_{i=1}^{r} n_{i}; \]. and the total weight of events in the weighted histogram is equal to ; \[; W = \sum_{i=1}^{r} w_{i}; \]. Let us formulate the hypothesis of identity of an unweighted histogram to a weighted histogram so that there exist r constants p1,...,pr, such that ; \[; \sum_{i=1}^{r} p_{i} = 1; \]. for the unweighted histogram. The weight wi is a random variable with a distribution approximated by the normal probability distribution \( N(Wp_{i},\sigma_{i}^{2}) \) where \( \sigma_{i}^{2} \) is the variance of the weight wi. If we replace the variance \( \sigma_{i}^{2} \) with estimate \( s_{i}^{2} \) (sum of squares of weights of events in the i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:90924,simpl,simple,90924,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['simpl'],['simple']
Usability,"pdateNetwork() [2/2]. void TMVA::MethodMLP::UpdateNetwork ; (; Double_t ; desired, . Double_t ; eventWeight = 1.0 . ). private . update the network based on how closely the output matched the desired output ; Definition at line 1286 of file MethodMLP.cxx. ◆ UpdatePriors(). void TMVA::MethodMLP::UpdatePriors ; (; ). private . zjh ; Definition at line 1454 of file MethodMLP.cxx. ◆ UpdateRegulators(). void TMVA::MethodMLP::UpdateRegulators ; (; ). private . zjh ; Definition at line 1468 of file MethodMLP.cxx. ◆ UpdateSynapses(). void TMVA::MethodMLP::UpdateSynapses ; (; ). private . update synapse error fields and adjust the weights (if in sequential mode) ; Definition at line 1412 of file MethodMLP.cxx. Member Data Documentation. ◆ fBatchSize. Int_t TMVA::MethodMLP::fBatchSize. private . batch size, only matters if in batch learning mode ; Definition at line 192 of file MethodMLP.h. ◆ fBPMode. EBPTrainingMode TMVA::MethodMLP::fBPMode. private . backprop learning mode (sequential or batch) ; Definition at line 190 of file MethodMLP.h. ◆ fBpModeS. TString TMVA::MethodMLP::fBpModeS. private . backprop learning mode option string (sequential or batch) ; Definition at line 191 of file MethodMLP.h. ◆ fCalculateErrors. bool TMVA::MethodMLP::fCalculateErrors. private . compute inverse hessian matrix at the end of the training ; Definition at line 165 of file MethodMLP.h. ◆ fDecayRate. Double_t TMVA::MethodMLP::fDecayRate. private . decay rate for above learning rate ; Definition at line 189 of file MethodMLP.h. ◆ fDeviationsFromTargets. std::vector<std::pair<Float_t,Float_t> >* TMVA::MethodMLP::fDeviationsFromTargets. private . deviation from the targets, event weight ; Definition at line 204 of file MethodMLP.h. ◆ fEpochMon. Bool_t TMVA::MethodMLP::fEpochMon. private . create and fill epoch-wise monitoring histograms (makes outputfile big!) ; Definition at line 194 of file MethodMLP.h. ◆ fGA_nsteps. Int_t TMVA::MethodMLP::fGA_nsteps. private . GA settings: number of steps. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:49961,learn,learning,49961,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['learn'],['learning']
Usability,"pe = P->getType().getAsString();; 1034 if (type.at(type.length()-1) == '*') {; 1035 type.at(type.length()-2) = '*';; 1036 type.erase(type.length()-1);; 1037 }; 1038 prototype += type;; 1039 }; 1040 ; 1041 prototype = ""("" + prototype + "")"";; 1042 return true;; 1043 }; 1044 else {; 1045 ShowWarning(""can't convert Decl to FunctionDecl"","""");; 1046 return false;; 1047 }; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051 ; 1052void RScanner::Scan(const clang::ASTContext &C); 1053{; 1054 fSourceManager = &C.getSourceManager();; 1055 ; 1056// if (fVerboseLevel >= 3) fSelectionRules.PrintSelectionRules();; 1057 ; 1058 if (fVerboseLevel > 0 && fSelectionRules.GetHasFileNameRule()) {; 1059 std::cout<<""File name detected""<<std::endl;; 1060 }; 1061 ; 1062 if (fScanType == EScanType::kTwoPasses); 1063 TraverseDecl(C.getTranslationUnitDecl());; 1064 ; 1065 fFirstPass=false;; 1066 fselectedRecordDecls.clear();; 1067 fSelectedEnums.clear();; 1068 fSelectedTypedefs.clear();; 1069 fSelectedVariables.clear();; 1070 fSelectedFunctions.clear();; 1071 TraverseDecl(C.getTranslationUnitDecl());; 1072 ; 1073 // The RecursiveASTVisitor uses range-based for; we must not modify the AST; 1074 // during iteration / visitation. Instead, buffer the lookups that could; 1075 // potentially create new template specializations, and handle them here:; 1076 AddDelayedAnnotatedRecordDecls();; 1077}; 1078 ; 1079 ; 1080////////////////////////////////////////////////////////////////////////////////; 1081/// Set the callback to the RecordDecl and return the previous one.; 1082 ; 1083RScanner::DeclCallback RScanner::SetRecordDeclCallback(RScanner::DeclCallback callback); 1084{; 1085 DeclCallback old = fRecordDeclCallback;; 1086 fRecordDeclCallback = callback;; 1087 return old;; 1088}; IntToStrstd::string IntToStr(int num)Definition Scanner.cxx:161; APIntToLonglong APIntToLong(const llvm::APInt &num)Definition Scanner.cxx:147; gInterpcling::Interpreter * gI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Scanner_8cxx_source.html:36782,clear,clear,36782,doc/master/Scanner_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html,1,['clear'],['clear']
Usability,"pe(const char* label); Define a state with given name, the lowest available; positive integer is assigned as index. Category; state labels may not contain semicolons.; Error status is return if state with given name; is already defined. Bool_t defineType(const char* label, Int_t index); Define a state with given name and index. Category; state labels may not contain semicolons; Error status is return if state with given name; or index is already defined. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; compact only at the moment. void clearRange(const char* name, Bool_t silent); Check that both input arguments are not null pointers. void setRange(const char* rangeName, const char* stateNameList). void addToRange(const char* rangeName, const char* stateNameList); Check that both input arguments are not null pointers. Bool_t isStateInRange(const char* rangeName, const char* stateName) const; Check that both input arguments are not null pointers. void Streamer(TBuffer& b). TObject* clone(const char* newname) const; { return new RooCategory(*this,newname); }. Int_t getIndex() const; Value modifiers. const char* getLabel() const. Bool_t isFundamental() const; We implement a fundamental type of AbsArg that can be stored in a dataset. Bool_t isDerived() const; Does value or shape of this arg depend on any other arg?. void clearTypes(); { RooAbsCategory::clearTypes() ; }. Bool_t inRange(const char* rangeName) const; Returns true of current value of category is inside given range. Bool_t hasRange(const char* rangeName) const; Returns true if category has range with given name. RooCatType evaluate() const; Dummy implementation. » Last changed: Thu Nov 3 20:07:43 2011 » Last generated: 2011-11-03 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCategory.html:24947,clear,clearTypes,24947,root/html532/RooCategory.html,https://root.cern,https://root.cern/root/html532/RooCategory.html,2,['clear'],['clearTypes']
Usability,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategoryLValue.html:2242,clear,clearShapeDirty,2242,root/html532/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html532/RooAbsCategoryLValue.html,1,['clear'],['clearShapeDirty']
Usability,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsString.html:2001,clear,clearShapeDirty,2001,root/html532/RooAbsString.html,https://root.cern,https://root.cern/root/html532/RooAbsString.html,1,['clear'],['clearShapeDirty']
Usability,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategory.html:2173,clear,clearShapeDirty,2173,root/html532/RooAbsCategory.html,https://root.cern,https://root.cern/root/html532/RooAbsCategory.html,1,['clear'],['clearShapeDirty']
Usability,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBinningCategory.html:2012,clear,clearShapeDirty,2012,root/html532/RooBinningCategory.html,https://root.cern,https://root.cern/root/html532/RooBinningCategory.html,5,['clear'],['clearShapeDirty']
Usability,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStringVar.html:1896,clear,clearShapeDirty,1896,root/html532/RooStringVar.html,https://root.cern,https://root.cern/root/html532/RooStringVar.html,1,['clear'],['clearShapeDirty']
Usability,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategoryLValue.html:2242,clear,clearShapeDirty,2242,root/html528/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html528/RooAbsCategoryLValue.html,2,['clear'],['clearShapeDirty']
Usability,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:2173,clear,clearShapeDirty,2173,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,2,['clear'],['clearShapeDirty']
Usability,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsDat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsString.html:2001,clear,clearShapeDirty,2001,root/html528/RooAbsString.html,https://root.cern,https://root.cern/root/html528/RooAbsString.html,2,['clear'],['clearShapeDirty']
Usability,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBinningCategory.html:2012,clear,clearShapeDirty,2012,root/html528/RooBinningCategory.html,https://root.cern,https://root.cern/root/html528/RooBinningCategory.html,10,['clear'],['clearShapeDirty']
Usability,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStringVar.html:1896,clear,clearShapeDirty,1896,root/html528/RooStringVar.html,https://root.cern,https://root.cern/root/html528/RooStringVar.html,2,['clear'],['clearShapeDirty']
Usability,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddToRange(const char* rangeName, const char* stateNameList); virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; Bool_tdefineType(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCategory.html:1953,clear,clearShapeDirty,1953,root/html526/RooCategory.html,https://root.cern,https://root.cern/root/html526/RooCategory.html,1,['clear'],['clearShapeDirty']
Usability,"pecials = 0 . ). protected . produce code to access member of given class. ; Parameter specials has following meaning: 0 - nothing special 1 - cast to data type 2 - produce pointer on given member 3 - skip casting when produce pointer by buf.P() function ; Definition at line 333 of file TXMLPlayer.cxx. ◆ ElementSetter(). const char * TXMLPlayer::ElementSetter ; (; TClass * ; cl, . const char * ; membername, . char * ; endch . ). protected . Produce code to set value to given data member. ; endch should be output after value is specified. ; Definition at line 392 of file TXMLPlayer.cxx. ◆ GetBasicTypeName(). TString TXMLPlayer::GetBasicTypeName ; (; TStreamerElement * ; el). protected . return simple data types for given TStreamerElement object ; Definition at line 260 of file TXMLPlayer.cxx. ◆ GetBasicTypeReaderMethodName(). TString TXMLPlayer::GetBasicTypeReaderMethodName ; (; Int_t ; type, . const char * ; realname . ). protected . return functions name to read simple data type from xml file ; Definition at line 293 of file TXMLPlayer.cxx. ◆ GetMemberTypeName(). TString TXMLPlayer::GetMemberTypeName ; (; TDataMember * ; member). protected . returns name of simple data type for given data member ; Definition at line 222 of file TXMLPlayer.cxx. ◆ GetStreamerName(). TString TXMLPlayer::GetStreamerName ; (; TClass * ; cl). protected . returns streamer function name for given class ; Definition at line 150 of file TXMLPlayer.cxx. ◆ IsA(). TClass * TXMLPlayer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 52 of file TXMLPlayer.h. ◆ ProduceCode(). Bool_t TXMLPlayer::ProduceCode ; (; TList * ; cllist, . const char * ; filename . ). Produce streamers for provide class list TList should include list of classes, for which code should be generated. ; filename specify name of file (without extension), where streamers should be created. Function produces two files: header file and source file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLPlayer.html:13865,simpl,simple,13865,doc/master/classTXMLPlayer.html,https://root.cern,https://root.cern/doc/master/classTXMLPlayer.html,1,['simpl'],['simple']
Usability,"pect to each other, the maximum height can be influenced by SetBarWidth(). Deactivated, the height of the bin with the maximum content of each individual violin is set to a constant value using SetBarWidth(). The static function will affect all violin-charts in the running program. Default is true. Scaling between multiple violin-charts (using ""same"" or THStack) is not supported, yet.; The zero indicator line; Typical for violin charts is a line in the background over the whole histogram indicating the bins with zero entries. The zero indicator line can be activated with z=1. The line color will always be the same as the fill-color of the histogram.; The Mean; The Mean is illustrated with the same mechanism as used for candle plots. Usually a circle is used.; Whiskers; The whiskers are illustrated by the same mechanism as used for candle plots. There is only one difference. When using the simple whisker definition (w=1) and the zero indicator line (z=1), then the whiskers will be forced to be solid (usually hashed); Points; The points are illustrated by the same mechanism as used for candle plots. E.g. VIOLIN2 uses better whisker definition (w=2) and outliers (p=1).; Other options; It is possible to combine all options of candle or violin plots with each other. E.g. a violin plot including a box-plot.; How to use the violin-plots drawing option; There are two predefined violin-plot representations:; ""VIOLINX1"": Standard violin (histogram, mean, whisker over full distribution, zero indicator line); ""VIOLINX2"": Line VIOLINX1 both with better whisker definition + outliers. A solid fill style is recommended for this plot (as opposed to a hollow or hashed style).; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; Int_t nx(6), ny(40);; double xmin(0.0), xmax(+6.0), ymin(0.0), ymax(+4.0);; auto hviolin = new TH2F(""hviolin"", ""Option VIOLIN example"", nx, xmin, xmax, ny, ymin, ymax);; TF1 f1(""f1"", ""gaus"", +0,0 +4.0);; double x,y;; for (Int_t iBin=1; iBin<hviolin->GetNbinsX(); ++i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:70302,simpl,simple,70302,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['simpl'],['simple']
Usability,"pedCommand == "".help"") || (strippedCommand == "".?"")) {; 1243 gInterpreter->ProcessLine(line);; 1244 Printf(""\n ROOT special commands."");; 1245 Printf("" =============================================================================="");; 1246 Printf("" .L <filename>[flags]: load the given file with optional flags like\n""; 1247 "" + to compile or ++ to force recompile.\n""; 1248 "" Type .? TSystem::CompileMacro for a list of all flags.\n""; 1249 "" <filename> can also be a shared library; skip flags."");; 1250 Printf("" .(x|X) <filename>[flags](args) :\n""; 1251 "" same as .L <filename>[flags] and runs then a function\n""; 1252 "" with signature: ret_type filename(args)."");; 1253 Printf("" .credits : show credits"");; 1254 Printf("" .demo : launch GUI demo"");; 1255 Printf("" .forum bug : ask for help with a bug or crash at the ROOT forum."");; 1256 Printf("" .gh [bug|feature|improvement]\n""; 1257 "" : submit a bug report, feature or improvement suggestion"");; 1258 Printf("" .help Class::Member : open reference guide for that class member (or .?).\n""; 1259 "" Specifying '::Member' is optional."");; 1260 Printf("" .help edit : show line editing shortcuts (or .?)"");; 1261 Printf("" .license : show license"");; 1262 Printf("" .libraries : show loaded libraries"");; 1263 Printf("" .ls : list contents of current TDirectory"");; 1264 Printf("" .pwd : show current TDirectory, pad and style"");; 1265 Printf("" .quit (or .exit) : quit ROOT (long form of .q)"");; 1266 Printf("" .R [user@]host[:dir] [-l user] [-d dbg] [script] :\n""; 1267 "" launch process in a remote host"");; 1268 Printf("" .qqq : quit ROOT - mandatory"");; 1269 Printf("" .qqqqq : exit process immediately"");; 1270 Printf("" .qqqqqqq : abort process"");; 1271 Printf("" .which [file] : show path of macro file"");; 1272 Printf("" .![OS_command] : execute OS-specific shell command"");; 1273 Printf("" .!root -? : print ROOT usage (CLI options)"");; 1274 return;; 1275 } else {; 1276 // If the user wants to use the extended "".help scopeName"" command to access; 1277 //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:49956,guid,guide,49956,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['guid'],['guide']
Usability,"pedef Int_t (*COMPAREMETHOD)(const void **, const void **);. - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the nu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableSorter.html:16291,simpl,simpleArray,16291,root/html528/TTableSorter.html,https://root.cern,https://root.cern/root/html528/TTableSorter.html,6,['simpl'],['simpleArray']
Usability,"pe . ). protected . Set Objective function. ; Definition at line 137 of file Fitter.cxx. ◆ DoUnbinnedLikelihoodFit(). bool ROOT::Fit::Fitter::DoUnbinnedLikelihoodFit ; (; bool ; extended = false, . const ROOT::EExecutionPolicy & ; executionPolicy = ROOT::EExecutionPolicy::kSequential . ). protected . un-binned likelihood fit ; Definition at line 440 of file Fitter.cxx. ◆ DoUpdateFitConfig(). void ROOT::Fit::Fitter::DoUpdateFitConfig ; (; ). protected . Definition at line 860 of file Fitter.cxx. ◆ DoUpdateMinimizerOptions(). bool ROOT::Fit::Fitter::DoUpdateMinimizerOptions ; (; bool ; canDifferentMinim = true). protected . Definition at line 763 of file Fitter.cxx. ◆ DoWeightMinimization(). template<class ObjFunc_t > . bool ROOT::Fit::Fitter::DoWeightMinimization ; (; std::unique_ptr< ObjFunc_t > ; f, . const ROOT::Math::IMultiGenFunction * ; chifunc = nullptr . ). protected . Definition at line 845 of file Fitter.cxx. ◆ EvalFCN(). bool ROOT::Fit::Fitter::EvalFCN ; (; ). Perform a simple FCN evaluation. ; FitResult will be modified and contain the value of the FCN ; Definition at line 288 of file Fitter.cxx. ◆ ExamineFCN(). void ROOT::Fit::Fitter::ExamineFCN ; (; ). protected . look at the user provided FCN and get data and model function is they derive from ROOT::Fit FCN classes ; Definition at line 979 of file Fitter.cxx. ◆ Fit() [1/5]. bool ROOT::Fit::Fitter::Fit ; (; const BinData & ; data, . const ROOT::EExecutionPolicy & ; executionPolicy = ROOT::EExecutionPolicy::kSequential . ). inline . Fit a binned data set using a least square fit. ; Note that the provided input data are copied in the Fitter class. Use the next function (passing a shared_ptr to the BinData class if you want to avoid copying. ; Definition at line 157 of file Fitter.h. ◆ Fit() [2/5]. template<class Data , class Function , class cond = typename std::enable_if<!(std::is_same<Function, ROOT::EExecutionPolicy>::value || std::is_same<Function, int>::value), Function>::type> . bool ROOT::Fit::Fitte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html:21071,simpl,simple,21071,doc/master/classROOT_1_1Fit_1_1Fitter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html,1,['simpl'],['simple']
Usability,"ph point; 1782/// with the first one. It is clear that the order of the point is essential in defining the polygon.; 1783/// Also note that the segments should not intersect.; 1784///; 1785/// NB:; 1786/// - if last=-1 (default) last is set to the last point.; 1787/// - if (first <0) the first point (0) is taken.; 1788///; 1789/// ### Method:; 1790///; 1791/// There are many ways to calculate the surface of a polygon. It all depends on what kind of data; 1792/// you have to deal with. The most evident solution would be to divide the polygon in triangles and; 1793/// calculate the surface of them. But this can quickly become complicated as you will have to test; 1794/// every segments of every triangles and check if they are intersecting with a current polygon's; 1795/// segment or if it goes outside the polygon. Many calculations that would lead to many problems...; 1796///; 1797/// ### The solution (implemented by R.Brun); 1798/// Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; 1799/// segments don't intersect.; 1800/// It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; 1801/// vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied; 1802/// by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.; 1803///; 1804/// ### Sources; 1805/// - http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; 1806/// - http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon; 1807 ; 1808Double_t TGraph::Integral(Int_t first, Int_t last) const; 1809{; 1810 if (first < 0) first = 0;; 1811 if (last < 0) last = fNpoints - 1;; 1812 if (last >= fNpoints) last = fNpoints - 1;; 1813 if (first >= last) return 0;; 1814 Int_t np = last - first + 1;; 1815 Double_t sum = 0.0;; 1816 //for(Int_t i=first;i<=last;i++) {; 1817 // Int_t j = first + (i-first+1)%np;; 1818 // sum += TMath::Ab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:64731,simpl,simple,64731,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['simpl'],['simple']
Usability,"ph; ; . void PaintGraph(TGraph* theGraph, Int_t npoints, const Double_t* x, const Double_t* y, Option_t* chopt). Control function to draw a graph.; . void PaintGrapHist(TGraph* theGraph, Int_t npoints, const Double_t* x, const Double_t* y, Option_t* chopt). This is a service method used by; THistPainter; to paint 1D histograms. It is not used to paint TGraph.; ; Input parameters:; ; npoints : Number of points in X or in Y.; x[npoints] or x[0] : x coordinates or (xmin,xmax).; y[npoints] or y[0] : y coordinates or (ymin,ymax).; chopt : Option.; . The aspect of the histogram is done according to the value of the chopt.; . ""R""; Graph is drawn horizontaly, parallel to X axis. (default is vertically,; parallel to Y axis); ; If option R is selected the user must give:; ; 2 values for Y (y[0]=YMIN and y[1]=YMAX); N values for X, one for each channel.; ; Otherwise the user must give:; ; N values for Y, one for each channel.; 2 values for X (x[0]=XMIN and x[1]=XMAX); . ""L""; A simple polyline beetwen every points is drawn.; ; ""H""; An Histogram with equidistant bins is drawn as a polyline.; ; ""F""; An histogram with equidistant bins is drawn as a fill area. Contour is not; drawn unless chopt='H' is also selected..; ; ""N""; Non equidistant bins (default is equidistant). If N is the number of channels; array X and Y must be dimensionned as follow:; ; >If option R is not selected (default) then the user must give:. (N+1) values for X (limits of channels).; N values for Y, one for each channel. Otherwise the user must give:. (N+1) values for Y (limits of channels).; N values for X, one for each channel. ""F1""; Idem as 'F' except that fill area base line is the minimum of the pad instead; of Y=0.; ; ""F2""; Draw a Fill area polyline connecting the center of bins; ; ""C""; A smooth Curve is drawn.; ; ""*""; A Star is plotted at the center of each bin.; ; ""P""; Idem with the current marker.; ; ""P0""; Idem with the current marker. Empty bins also drawn.; ; ""B""; A Bar chart with equidistant bins i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphPainter.html:22013,simpl,simple,22013,root/html532/TGraphPainter.html,https://root.cern,https://root.cern/root/html532/TGraphPainter.html,4,['simpl'],['simple']
Usability,"pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 204",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:72288,usab,usable,72288,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['usab'],['usable']
Usability,"ple weights; sample_weight_higgs = np.array([results[""higgs""][""weight_modified""]]).flatten(); sample_weight_zz = np.array([results[""zz""][""weight_modified""]]).flatten(); ; # Putting sample weights together in the same manner as the training data; sample_weight = np.concatenate([sample_weight_higgs, sample_weight_zz]); ; # For Training purposes we have to get rid of the negative weights, since xgb can't handle them; sample_weight[sample_weight < 0] = 1e-6; ; # Prepare the features and labels; X = np.concatenate((higgs_data, zz_data), axis=0).reshape(-1, 1); y = np.concatenate([np.ones(len(higgs_data)), np.zeros(len(zz_data))]); ; # Train the Classifier to discriminate between higgs and zz; model_xgb = xgb.XGBClassifier(n_estimators=1000, max_depth=5, eta=0.2, min_child_weight=1e-6, nthread=1); model_xgb.fit(X, y, sample_weight=sample_weight); ; ; # Building a RooRealVar based on the observed data; m4l = ROOT.RooRealVar(""m4l"", ""Four Lepton Invariant Mass"", 0.0); ; ; # Define functions to compute the learned likelihood.; def calculate_likelihood_xgb(m4l_arr: np.ndarray) -> np.ndarray:; prob = model_xgb.predict_proba(m4l_arr.T)[:, 0]; return (1 - prob) / prob; ; ; llh = ROOT.RooFit.bindFunction(f""llh"", calculate_likelihood_xgb, m4l); ; # Number of signals and background; n_signal = results[""higgs""][""weight""].sum(); n_back = results[""zz""][""weight""].sum(); ; ; # Define weight functions; def weight_back(mu):; return n_back / (n_back + mu * n_signal); ; ; def weight_signal(mu):; return 1 - weight_back(mu); ; ; # Define the likelihood ratio accordingly to mixture models; def likelihood_ratio(llr: np.ndarray, mu: np.ndarray) -> np.ndarray:; ; m = 2; ; w_0 = np.array([weight_back(0), weight_signal(0)]); w_1 = np.array([weight_back(mu[0]), weight_signal(mu[0])]); ; w = np.outer(w_1, 1.0 / w_0); ; p = np.ones((m, m, len(llr))); p[1, 0] = llr; for i in range(m):; for j in range(i):; p[j, i] = 1.0 / p[i, j]; ; return 1.0 / np.sum(1.0 / np.sum(np.expand_dims(w, axis=2) * p, axis=0), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf618__mixture__models_8py.html:4314,learn,learned,4314,doc/master/rf618__mixture__models_8py.html,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html,1,['learn'],['learned']
Usability,"plementation of copy constructor; 59 (*this) = rhs;; 60}; 61 ; 62FitConfig & FitConfig::operator = (const FitConfig &rhs) {; 63 // Implementation of assignment operator.; 64 if (this == &rhs) return *this; // time saving self-test; 65 ; 66 fNormErrors = rhs.fNormErrors;; 67 fParabErrors = rhs.fParabErrors;; 68 fMinosErrors = rhs.fMinosErrors;; 69 fUpdateAfterFit = rhs.fUpdateAfterFit;; 70 fWeightCorr = rhs.fWeightCorr;; 71 ; 72 fSettings = rhs.fSettings;; 73 fMinosParams = rhs.fMinosParams;; 74 ; 75 fMinimizerOpts = rhs.fMinimizerOpts;; 76 ; 77 return *this;; 78}; 79 ; 80void FitConfig::SetFromFitResult(const FitResult &result) {; 81 // Implementation of setting of parameters from the result of the fit; 82 // all the other options will stay the same.; 83 // If the size of parameters do not match they will be re-created; 84 // but in that case the bound on the parameter will be lost; 85 ; 86 unsigned int npar = result.NPar();; 87 if (fSettings.size() != npar) {; 88 fSettings.clear();; 89 fSettings.resize(npar);; 90 }; 91 // fill the parameter settings; 92 for (unsigned int i = 0; i < npar; ++i) {; 93 if (result.IsParameterFixed(i) ); 94 fSettings[i].Set(result.ParName(i), result.Value(i) );; 95 else {; 96 fSettings[i].Set( result.ParName(i), result.Value(i), result.Error(i) );; 97 // check if parameter is bound; 98 double lower = 0;; 99 double upper = 0;; 100 if (result.ParameterBounds(i,lower,upper) ) {; 101 if (lower == -std::numeric_limits<double>::infinity()) fSettings[i].SetUpperLimit(upper);; 102 else if (upper == std::numeric_limits<double>::infinity()) fSettings[i].SetLowerLimit(lower);; 103 else fSettings[i].SetLimits(lower,upper);; 104 }; 105 ; 106 // query if parameter needs to run Minos; 107 if (result.HasMinosError(i) ) {; 108 if (fMinosParams.empty()) {; 109 fMinosErrors = true;; 110 fMinosParams.reserve(npar-i);; 111 }; 112 fMinosParams.push_back(i);; 113 }; 114 }; 115 }; 116 ; 117 // set information about errors; 118 SetNormErrors( result.NormalizedErr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8cxx_source.html:2516,clear,clear,2516,doc/master/FitConfig_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html,1,['clear'],['clear']
Usability,"ples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVACrossValidationApplication.C This macro provides an example of how to use TMVA for k-folds cross evaluation in application ;  TMVACrossValidationRegression.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMinimalClassification.C Minimal self-contained example for setting up TMVA with binary classification ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionApplication.C This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  ► tree;  basic.C Read data from an ascii file and create a root file with an histogram and an ntuple ;  basic2.C Create can ntuple reading data from an ascii file ;  bill.C Benchmark comparing row-wise and colum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:159608,simpl,simple,159608,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,2,['simpl'],['simple']
Usability,"plex widget as a dialog can have the value of HasFocus() sets as true. WantFocus() - returns kTRUE if the flag kWidgetWantFocus is set.; 25.5.3 TGWindow; TGWindow is a ROOT GUI window base class. It inherits from TGObject and TGFrame derives from it. The application does not use it directly. It creates and registers a new window within the system. This window has common characteristics: existing parent, location, size in height and width (it has a default minimum size 1, 1 under which it cannot shrink), border with particular view, state, specific attributes. If there are no specified arguments their values will be taken from the parent. It receives events from the window system and can paint a representation of itself on the screen. 25.5.4 Frames; Most of the frame classes are mainly created for arranging widgets in a window. The class TGFrame is a subclass of TGWindow providing additional window characteristics and overriding some methods of TGWindow. It is a base class for the simple widgets as buttons, labels, etc. Its only purpose is to draw a frame around widgets that do not have a frame of their own. The main groups of TGFrame member functions are:. Window’s functions: DoRedraw(), DeleteWindow(), Activate(), etc.; Geometry functions: Move(), Resize(), SetSize(), etc.; Graphics handlers: ChangeBackground(), ChangeOptions(), etc.; Mouse and keyboard functions: HandleButton(), HandleFocusChange(), HandleKey(), HandleMotion(), etc.; Event handlers: HandleEvent(), ProcessEvent(), GetSender(), SendMessage(),ProcessMessage(), GetLastClick(), etc. The GUI classes hierarchy. Ones of TGFrame member functions provide direct functionality; others - will be overridden by TGFrame subclasses to ensure particular widget’s functionality. There are two constructors provided in TGFrame class. One creates a frame using an externally created window:; TGFrame(TGClient *c,Window_t id,const TGWindow *parent = 0);; For example, it can register the root window (called by TGClient), or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1150393,simpl,simple,1150393,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"plot or violin plot.Definition Hoption.h:53; Hoption_t::Specint Spec""SPEC"" TSpectrum graphicsDefinition Hoption.h:61; Hoption_t::FrontBoxint FrontBox""FB"" Suppress the front box for the 3D plots.Definition Hoption.h:56; Hoption_t::Pieint Pie""PIE"" Draw 1D plot as a pie chart.Definition Hoption.h:52; Hoption_t::Starint Star""*"" With option ""P"", a * is plotted at each point.Definition Hoption.h:39; Hoption_t::Zeroint Zero""0"" if selected with any LEGO option the empty bins are not drawn.Definition Hoption.h:62; Hoption_t::Logzint Logzlog scale in Z. Also set by histogram optionDefinition Hoption.h:72; Hoption_t::Triint Tri""TRI"" Draw TGraph2D with Delaunay triangles.Definition Hoption.h:51; Hoption_t::BackBoxint BackBox""BB"" Suppress the back box for the 3D plots.Definition Hoption.h:57; Hoption_t::Markint Mark""P"" The current Marker is drawn at each point.Definition Hoption.h:37; Hoption_t::Arrowint Arrow""ARR"" Draw 2D plot with Arrows.Definition Hoption.h:40; Hoption_t::Lineint Line""L"" A simple polyline through every point is drawn.Definition Hoption.h:36; Hoption_t::Sameint Same""SAME"" Histogram is plotted in the current pad.Definition Hoption.h:38; Hoption_t::Legoint Lego""LEGO"" and ""LEGOn"" Draw as a Lego plot(1 <= n <= 4).Definition Hoption.h:47; Hoption_t::Barint Bar""B"", ""BAR"" and ""HBAR"" A Bar chart is drawn at each point.Definition Hoption.h:31; Hoption_t::Fillint Fill""F"" A fill area is drawn (""CF"" draw a smooth fill area).Definition Hoption.h:34; Hoption_t::Histint Hist""HIST"" Draw only the histogram.Definition Hoption.h:46; Hoption_t::Surfint Surf""SURF"" and ""SURFn"" Draw as a Surface ((1 <= n <= 4).Definition Hoption.h:49; Hoption_t::Logyint Logylog scale in Y. Also set by histogram optionDefinition Hoption.h:71; Hoption_t::Systemint System""POL"", ""CYL"", ""SPH"" and ""PSR"" Type of coordinate system for 3D plots.Definition Hoption.h:54; Hoption_t::Errorint Error""En"" Draw Errors with current marker type and size (0 <= n <=6).Definition Hoption.h:33; Hparam_tHistogram parameter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:499173,simpl,simple,499173,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['simpl'],['simple']
Usability,"poTestResult Base class to represent results of a hypothesis test; RooStats::IntervalCalculator Interface for tools setting limits (producing confidence intervals); RooStats::LikelihoodInterval Concrete implementation of a ConfInterval based on a likelihood ratio; RooStats::LikelihoodIntervalPlot Class containing the results of the IntervalCalculator; RooStats::MCMCCalculator Markov Chain Monte Carlo calculator for Bayesian credible intervals; RooStats::MCMCInterval Concrete implementation of a ConfInterval based on MCMC calculation; RooStats::ModelConfig A class that holds configuration information for a model using a workspace as a store; RooStats::NeymanConstruction Interface for tools setting limits (producing confidence intervals); RooStats::NumEventsTestStat ; RooStats::NumberCountingPdfFactory A factory specific to common number counting problems.; RooStats::NumberCountingUtils ; RooStats::PointSetInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::ProfileLikelihoodCalculator A concrete implementation of CombinedCalculator that uses the ProfileLikelihood ratio.; RooStats::ProfileLikelihoodTestStat implements the profile likelihood ratio as a test statistic to be used with several tools; RooStats::ProposalFunction Interface for the proposal function used with Markov Chain Monte Carlo; RooStats::SPlot Class used for making sPlots; RooStats::SamplingDistPlot Class containing the results of the HybridCalculator; RooStats::SamplingDistribution Class containing the results of the HybridCalculator; RooStats::SamplingSummary A summary of acceptance regions for confidence belt; RooStats::SamplingSummaryLookup A simple class used by ConfidenceBelt; RooStats::SimpleInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::TestStatSampler Interface for tools setting limits (producing confidence intervals); RooStats::TestStatistic Interface for tools setting limits (producing co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:43583,simpl,simple,43583,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['simpl'],['simple']
Usability,"point-sizes and line-widths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void DoASavImageGUIBaseName(const char* t); Update base-name. void DoASavImageGUIOutMode(Int_t m); Update output mode. void DoASavImageStart(); Start auto-rotator image auto-save. void DoASavImageStop(); Stop auto-rotator image auto-save. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLViewerEditor.html:24064,guid,guides,24064,root/html530/TGLViewerEditor.html,https://root.cern,https://root.cern/root/html530/TGLViewerEditor.html,1,['guid'],['guides']
Usability,"point-sizes and line-widths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void DoASavImageGUIBaseName(const char* t); Update base-name. void DoASavImageGUIOutMode(Int_t m); Update output mode. void DoASavImageStart(); Start auto-rotator image auto-save. void DoASavImageStop(); Stop auto-rotator image auto-save. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2011-11-03 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLViewerEditor.html:24064,guid,guides,24064,root/html532/TGLViewerEditor.html,https://root.cern,https://root.cern/root/html532/TGLViewerEditor.html,1,['guid'],['guides']
Usability,"ported right now) . Definition at line 1011 of file TApplication.cxx. ◆ OpenGitHubIssue(). void TApplication::OpenGitHubIssue ; (; const TString & ; type). It opens a GitHub issue in a web browser with prefilled ROOT version. ; Parameters. [in]typethe issue type (bug, feature or improvement) . Definition at line 1034 of file TApplication.cxx. ◆ OpenInBrowser(). void TApplication::OpenInBrowser ; (; const TString & ; url). The function generates and executes a command that loads the Doxygen URL in a browser. ; It works for Mac, Windows and Linux. In the case of Linux, the function also checks if the DISPLAY is set. If it isn't, a warning message and the URL will be displayed on the terminal.; Parameters. [in]urlweb page to be displayed in a browser . Definition at line 629 of file TApplication.cxx. ◆ OpenReferenceGuideFor(). void TApplication::OpenReferenceGuideFor ; (; const TString & ; strippedClass). It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ; If the user types incorrect value, it will return an error or warning.; Parameters. [in]strippedClassthe scope or scope::member . Definition at line 1065 of file TApplication.cxx. ◆ operator=(). TApplication & TApplication::operator= ; (; const TApplication & ; ). privatedelete . ◆ ParseRemoteLine(). Int_t TApplication::ParseRemoteLine ; (; const char * ; ln, . TString & ; hostdir, . TString & ; user, . Int_t & ; dbg, . TString & ; script . ). staticprotected . Parse the content of a line starting with "".R"" (already stripped-off) The format is. ; [user@]host[:dir] [-l user] [-d dbg] [script]; d#define d(i)Definition RSha256.hxx:102; lTLine lDefinition textangle.C:4; The variable 'dir' is the remote directory to be used as working dir. The username can be specified in two ways, ""-l"" having the priority (as in ssh). A 'dbg' value > 0 gives increasing verbosity. The last argument 'script' allows to spe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplication.html:33675,guid,guide,33675,doc/master/classTApplication.html,https://root.cern,https://root.cern/doc/master/classTApplication.html,1,['guid'],['guide']
Usability,"possibly loaded) on an as-needed basis. Note carefully how this is different from other Python (extension) modules, and what to expect if you use the normal inspection tools (such as e.g. ‘dir()’). This feature prevents the inspection tools from being swamped by an enormous amount of classes, but they can no longer be used to explore unknown parts of the system (e.g. to find out which classes are available). Furthermore, because of this approach, <tab>-completion will usually not be available until after the first use (and hence creation) of a class.; Access to class static functions, public data members, enums, etc. is as expected. Many more example uses of ROOT classes from Python can be found in the tutorials directory in the ROOT distribution. The recipes section contains a description on working with your own classes (see “Using Your Own Classes”).; 19.1.5.2 Access to STL Classes; The STL classes live in the ROOT.std namespace (or, if you prefer to get them from there, in the ROOT module directly, but doing so makes the code less clear, of course). Be careful in their use, because Python already has types called “string” and “list.”; In order to understand how to get access to a templated class, think of the general template as a meta class. By instantiating the meta class with the proper parameters, you get an actual class, which can then be used to create object instances. An example usage:; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; The parameters to the template instantiation can either be an actual type or value (as is used here, “int”), or a string representation of the parameters (e.g. “‘double’”), or a mixture of both (e.g. “‘TCanvas, 0’” or “‘double’, 0” ). The “std::vector<int>” class is one of the classes builtin by default into the Cling extension dlls. You will get a non-funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1052507,clear,clear,1052507,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['clear'],['clear']
Usability,"pplies only for kPicture2ModeGroupLightHeight modes group. void SetChanMarks(Int_t enable, Int_t color, Int_t width, Int_t height, Int_t style); Sets enables/disables drawing of channel marks and sets their attributes:; -enable - decides whether the channel marks are shown or not; -color - color of channel marks; -width - width of channel marks in pixels; -height - height of channel marks in pixels; -style - style of channel marks (dot, cross, star, rectangle, X, diamond, triangle). void SetChanGrid(Int_t enable, Int_t color); This function sets enables/disables drawing of channel grid and sets its color:; -enable - decides whether the channel grid is shown or not; -color - color of channel grid. void GetDisplayMode(Int_t& modeGroup, Int_t& displayMode); Gets display group mode and display mode:; -modeGroup - the following group modes might have been set: simple modes-kPicture2ModeGroupSimple, modes with shading according to light-kPicture2ModeGroupLight, modes with shading according to channels counts-kPicture2ModeGroupHeight, modes of combination of shading according to light and to channels counts-kPicture2ModeGroupLightHeight; -displayMode - display modes that might have been set: points, grid, contours, bars, x_lines, y_lines, bars_x, bars_y, needles, surface, triangles. void GetPenAttr(Int_t& color, Int_t& style, Int_t& width); Gets pen attributes:; -color - color of spectrum; -style - style of pen (solid, dash, dot, dash-dot); -width - width of pen in pixels. void GetNodes(Int_t& nodesx, Int_t& nodesy); Gets nodes in both directions:; -nodesx, nodesy, only the bins at the nodes points are displayed. void GetAngles(Int_t& alpha, Int_t& beta, Int_t& view); Gets angles of the view:; -alpha - angle between base line of Canvas and right lower edge of picture base plane; -beta - angle between base line of Canvas and left lower edge of picture base plane; -view - rotation angle of the view, it can be 0, 90, 180, 270 degrees. void GetZScale(Int_t& scale); Gets z-axis ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Painter.html:31677,simpl,simple,31677,root/html528/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Painter.html,6,['simpl'],['simple']
Usability,"producing confidence intervals); RooStats::NumEventsTestStat ; RooStats::NumberCountingPdfFactory A factory specific to common number counting problems.; RooStats::NumberCountingUtils ; RooStats::PdfProposal ; RooStats::PointSetInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::ProfileLikelihoodCalculator A concrete implementation of CombinedCalculator that uses the ProfileLikelihood ratio.; RooStats::ProfileLikelihoodTestStat implements the profile likelihood ratio as a test statistic to be used with several tools; RooStats::ProposalFunction Interface for the proposal function used with Markov Chain Monte Carlo; RooStats::ProposalHelper ; RooStats::SPlot Class used for making sPlots; RooStats::SamplingDistPlot Class containing the results of the HybridCalculator; RooStats::SamplingDistribution Class containing the results of the HybridCalculator; RooStats::SamplingSummary A summary of acceptance regions for confidence belt; RooStats::SamplingSummaryLookup A simple class used by ConfidenceBelt; RooStats::SimpleInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::TestStatSampler Interface for tools setting limits (producing confidence intervals); RooStats::TestStatistic Interface for tools setting limits (producing confidence intervals); RooStats::ToyMCSampler A simple implementation of the TestStatSampler interface; RooStats::UniformProposal A concrete implementation of ProposalFunction, that uniformly samples the parameter space.; RooStats::UpperLimitMCSModule MCStudy module to calculate upperlimit of a given poi; RooStepFunction Step Function; RooStreamParser Utility class that parses iostream data into tokens; RooStringVar String-valued variable ; RooStudyManager A general purpose workspace oriented parallelizing study manager; RooStudyPackage A general purpose workspace oriented parallelizing study manager; RooSuperCategory Lvalue product operator for catategory ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:45435,simpl,simple,45435,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,3,['simpl'],['simple']
Usability,"production adapted from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the –full-dataset argument and you can also run only on a fraction of the original dataset using the argument –lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.05,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.05 # The preskimmed dataset contains only 0.5 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.1f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:1402,usab,usable,1402,doc/master/df107__SingleTopAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html,1,['usab'],['usable']
Usability,"propagation). Double_t CLsError() const; Returns an estimate of the error on CLs through combination of the; errors on CLb and CLsplusb:. void UpdatePValue(const RooStats::SamplingDistribution* distr, Double_t& pvalue, Double_t& perror, Bool_t pIsRightTail); updates the pvalue if sufficient data is available. void Print(const Option_t* = """") const; Print out some information about the results; Note: use Alt/Null labels for the hypotheses here as the Null; might be the s+b hypothesis. Double_t NullPValue() const; Return p-value for null hypothesis. { return fNullPValue; }. Double_t AlternatePValue() const; Return p-value for alternate hypothesis. { return fAlternatePValue; }. Double_t CLb() const; Convert NullPValue into a ""confidence level"". { return !fBackgroundIsAlt ? NullPValue() : AlternatePValue(); }. Double_t CLsplusb() const; Convert AlternatePValue into a ""confidence level"". { return !fBackgroundIsAlt ? AlternatePValue() : NullPValue(); }. Double_t CLs() const; CLs is simply CLs+b/CLb (not a method, but a quantity). Double_t Significance() const; familiar name for the Null p-value in terms of 1-sided Gaussian significance. {return RooStats::PValueToSignificance( NullPValue() ); }. SamplingDistribution* GetNullDistribution(void); { return fNullDistr; }. SamplingDistribution* GetAltDistribution(void); { return fAltDistr; }. RooDataSet* GetNullDetailedOutput(void); { return fNullDetailedOutput; }. RooDataSet* GetAltDetailedOutput(void); { return fAltDetailedOutput; }. RooDataSet* GetFitInfo(void); { return fFitInfo; }. Double_t GetTestStatisticData(void); { return fTestStatisticData; }. const RooArgList* GetAllTestStatisticsData(void); { return fAllTestStatisticsData; }. void SetAltDetailedOutput(RooDataSet* d); { fAltDetailedOutput = d; }. void SetNullDetailedOutput(RooDataSet* d); { fNullDetailedOutput = d; }. void SetFitInfo(RooDataSet* d); { fFitInfo = d; }. Bool_t GetPValueIsRightTail(void); { return fPValueIsRightTail; }. void SetBackgroundAsAlt(Bool_t l ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestResult.html:11183,simpl,simply,11183,root/html602/RooStats__HypoTestResult.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestResult.html,2,['simpl'],['simply']
Usability,"property implementations; RooSharedPropertiesList Manager for shared properties among clones of certain RooAbsArg-derived types; RooSimGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimPdfBuilder RooSimultaneous PDF Builder (obsolete); RooSimWSTool Workspace oriented tool for customized cloning of p.d.f. into a simultaneous p.d.f; RooSimWSTool::BuildConfig Build configuration object for RooSimWSTool; RooSimWSTool::MultiBuildConfig Build configuration object for RooSimWSTool with multiple prototype p.d.f.; RooSimWSTool::ObjBuildConfig Validated RooSimWSTool build configuration; RooSimWSTool::ObjSplitRule Validated RooSimWSTool split rule; RooSimWSTool::SplitRule Split rule specification for prototype p.d.f; RooSimultaneous Simultaneous operator p.d.f, functions like C++ 'switch()' on input p.d.fs operating on index category5A; RooStats ; RooStats::AcceptanceRegion A simple class for acceptance regions used for ConfidenceBelt; RooStats::BayesianCalculator BayesianCalculator class; RooStats::BernsteinCorrection A utility to add polynomial corrrection terms to a model to improve the description of data.; RooStats::CombinedCalculator A base class that is for tools that can be both HypoTestCalculators and IntervalCalculators; RooStats::ConfInterval Interface for Confidence Intervals; RooStats::ConfidenceBelt A confidence belt for the Neyman Construction; RooStats::DebuggingSampler A simple implementation of the DistributionCreator interface; RooStats::DebuggingTestStat A concrete implementation of the TestStatistic interface, useful for debugging.; RooStats::FeldmanCousins Interface for tools setting limits (producing confidence intervals); RooStats::HLFactory The high Level Model Factory to create models from datacards; RooStats::Heavyside Your description goes here...; RooStats::HybridCalculator Hypothesis test calculator using a Bayesian-frequentist hybrid method; RooStats::HybridPlot Provides the plots for an HybridResult; RooSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:42082,simpl,simple,42082,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['simpl'],['simple']
Usability,"propriate relationships and then instantiate an RDataFrame; 1327with the main tree:; 1328 ; 1329~~~{.cpp}; 1330TTree main([...]);; 1331TTree friend([...]);; 1332main.AddFriend(&friend, ""myFriend"");; 1333 ; 1334RDataFrame df(main);; 1335auto df2 = df.Filter(""myFriend.MyCol == 42"");; 1336~~~; 1337 ; 1338The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; 1339or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; 1340""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree).; 1341 ; 1342\note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; 1343 entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; 1344 one: rows will be mismatched.; 1345 ; 1346Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; 1347When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; 1348""index"" columns have a value identical to the one in the main one. For example, in Python:; 1349 ; 1350~~~{.py}; 1351main_tree = ...; 1352aux_tree = ...; 1353 ; 1354# If a friend tree has an index on `commonColumn`, when the main tree loads; 1355# a given row, it also loads the row of the friend tree that has the same; 1356# value of `commonColumn`; 1357aux_tree.BuildIndex(""commonColumn""); 1358 ; 1359mainTree.AddFriend(aux_tree); 1360 ; 1361df = ROOT.RDataFrame(mainTree); 1362~~~; 1363 ; 1364RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode.; 1365 ; 1366\anchor other-file-formats; 1367### Reading data formats other than ROOT trees; 1368RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an AP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:78155,simpl,simple,78155,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"propriate relationships and then instantiate an RDataFrame; 1367with the main tree:; 1368 ; 1369~~~{.cpp}; 1370TTree main([...]);; 1371TTree friend([...]);; 1372main.AddFriend(&friend, ""myFriend"");; 1373 ; 1374RDataFrame df(main);; 1375auto df2 = df.Filter(""myFriend.MyCol == 42"");; 1376~~~; 1377 ; 1378The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; 1379or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; 1380""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree).; 1381 ; 1382\note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; 1383 entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; 1384 one: rows will be mismatched.; 1385 ; 1386Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; 1387When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; 1388""index"" columns have a value identical to the one in the main one. For example, in Python:; 1389 ; 1390~~~{.py}; 1391main_tree = ...; 1392aux_tree = ...; 1393 ; 1394# If a friend tree has an index on `commonColumn`, when the main tree loads; 1395# a given row, it also loads the row of the friend tree that has the same; 1396# value of `commonColumn`; 1397aux_tree.BuildIndex(""commonColumn""); 1398 ; 1399mainTree.AddFriend(aux_tree); 1400 ; 1401df = ROOT.RDataFrame(mainTree); 1402~~~; 1403 ; 1404RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode.; 1405 ; 1406\anchor other-file-formats; 1407### Reading data formats other than ROOT trees; 1408RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an AP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:79835,simpl,simple,79835,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"protected:. TStringfGetterName! buffer for name of getter method; TStringfSetterName! buffer for name of setter method; TXMLSetupfXmlSetup! buffer for xml names convertion. Class Charts. Inheritance Chart:. TObject. ←; TXMLPlayer. Function documentation; TXMLPlayer(); default constructor. ~TXMLPlayer(); destructor of TXMLPlayer object. TString GetStreamerName(TClass* cl); returns streamer function name for given class. Bool_t ProduceCode(TList* cllist, const char* filename); Produce streamers for provide class list; TList should include list of classes, for which code should be generated.; filename specify name of file (without extension), where streamers should be; created. Function produces two files: header file and source file.; For instance, if filename is ""streamers"", files ""streamers.h"" and ""streamers.cxx""; will be created. TString GetMemberTypeName(TDataMember* member); returns name of simple data type for given data member. TString GetBasicTypeName(TStreamerElement* el); return simple data types for given TStreamerElement object. TString GetBasicTypeReaderMethodName(Int_t type, const char* realname); return functions name to read simple data type from xml file. const char* ElementGetter(TClass* cl, const char* membername, int specials = 0); produce code to access member of given class.; Parameter specials has following meaning:; 0 - nothing special; 1 - cast to data type; 2 - produce pointer on given member; 3 - skip casting when produce pointer by buf.P() function. const char* ElementSetter(TClass* cl, const char* membername, char* endch); Produce code to set value to given data member.; endch should be output after value is specified. void ProduceStreamerSource(ostream& fs, TClass* cl, TList* cllist); Produce source code of streamer function for specified class. void ReadSTLarg(ostream& fs, TString& argname, int argtyp, Bool_t isargptr, TClass* argcl, TString& tname, TString& ifcond); Produce code to read argument of stl container from xml file. void Writ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXMLPlayer.html:10907,simpl,simple,10907,root/html602/TXMLPlayer.html,https://root.cern,https://root.cern/root/html602/TXMLPlayer.html,2,['simpl'],['simple']
Usability,"protected:. static Bool_t_clearObsListClear obslist on sterilize?; Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndexLast slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSizeMaximum size; RooNormSetCache*RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen! ; list<RooArgSet*>_optCacheObsList! list of all optCacheObservables owned; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooObjCacheManager.html:3807,clear,clearCacheOnServerRedirect,3807,root/html530/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html530/RooObjCacheManager.html,2,['clear'],"['clearCacheOnServerRedirect', 'cleared']"
Usability,"proxy class ROOT::Math::RootFinder which creates behind the chosen algorithms which are implemented using the ROOT::Math::IRootFinderMethod interface . Classes; class  ROOT::Math::Roots::Bisection;  Roots::Bisection Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one. More...;  ; class  ROOT::Math::Roots::Brent;  Brent-Dekker algorithm which combines an interpolation strategy with the bisection algorithm See the GSL manual for more information. More...;  ; class  ROOT::Math::BrentRootFinder;  Class for finding the root of a one dimensional function using the Brent algorithm. More...;  ; class  ROOT::Math::Roots::FalsePos;  False Position algorithm based on linear interpolation. More...;  ; class  ROOT::Math::GSLRootFdFSolver;  Root-Finder with derivatives implementation class using GSL. More...;  ; class  ROOT::Math::GSLRootFinder;  Base class for GSL Root-Finding algorithms for one dimensional functions which do not use function derivatives. More...;  ; class  ROOT::Math::GSLRootFinderDeriv;  Base class for GSL Root-Finding algorithms for one dimensional functions which use function derivatives. More...;  ; class  ROOT::Math::GSLRootFSolver;  Root-Finder implementation class using GSL. More...;  ; class  ROOT::Math::IRootFinderMethod;  Interface for finding function roots of one-dimensional functions. More...;  ; class  ROOT::Math::Roots::Newton;  a Newton algorithm, which computes the derivative at each iteration See the GSL manual for more information More...;  ; class  ROOT::Math::RootFinder;  User Class to find the Root of one dimensional functions. More...;  ; class  ROOT::Math::Roots::Secant;  Secant algorithm, simplified version of Newton method, which does not require the derivative at every step. More...;  ; class  ROOT::Math::Roots::Steffenson;  Steffenson method, providing the fastes convergence. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__RootFinders.html:2075,simpl,simplified,2075,doc/master/group__RootFinders.html,https://root.cern,https://root.cern/doc/master/group__RootFinders.html,1,['simpl'],['simplified']
Usability,"ps://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ;  simpleTableTest.CThis TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface ;  Slider3Demo.CSimple macro showing capabilities of triple slider ;  splitbuttonTest.CA simple example that shows the usage of a TGSplitButton ;  splitterHorizontal.CThis macro gives an example of how to create a horizontal splitter ;  splitterVertical.CThis macro gives an example of how to create a vertical splitter ;  staffTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  statusBar.CThis macro gives an example of how to create a status bar related to an embedded canvas that shows the info of the selected object, exactly as the status bar of any canvas window ;  textEntries.CThis macro gives an example of how to set/change text entry attributes ;  textviewostream.CThis macro gives an example of how to use the TGTextViewostream widget ;  WorldMap.CThis macro shows how to use a TGImageMap class ;  ► hist;  candledecay.C Candle Decay, illustrate a time development of a certain value ;  candlehisto.C Example showing how to combine the various candle plot options ;  candleplot.C Example of candle plot with 2-D histograms ;  candleplotoption.C Example showing how to combine the various candle plot options ;  candleplotstack.C Example showing how a THStack with candle plot option ;  candleplotwhiskers.C Example of candle plot showing the whiskers definition ;  ContourList.C Getting Contours From TH2D ;  cumulative.C Il",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:121729,simpl,simple,121729,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['simpl'],['simple']
Usability,"ps://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ;  simpleTableTest.CThis TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface ;  Slider3Demo.CSimple macro showing capabilities of triple slider ;  splitbuttonTest.CA simple example that shows the usage of a TGSplitButton ;  splitterHorizontal.CThis macro gives an example of how to create a horizontal splitter ;  splitterVertical.CThis macro gives an example of how to create a vertical splitter ;  staffTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  statusBar.CThis macro gives an example of how to create a status bar related to an embedded canvas that shows the info of the selected object, exactly as the status bar of any canvas window ;  textEntries.CThis macro gives an example of how to set/change text entry attributes ;  textviewostream.CThis macro gives an example of how to use the TGTextViewostream widget ;  WorldMap.CThis macro shows how to use a TGImageMap class ;  ► hist;  candledecay.C Candle Decay, illustrate a time development of a certain value ;  candlehisto.C Example showing how to combine the various candle plot options ;  candleplot.C Example of candle plot with 2-D histograms ;  candleplotoption.C Example showing how to combine the various candle plot options ;  candleplotstack.C Example showing how a THStack with candle plot option ;  candleplotwhiskers.C Example of candle plot showing the whiskers definition ;  candlescaled.C Candle Scaled, illustrates what scaleing doe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:120656,simpl,simple,120656,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['simpl'],['simple']
Usability,"ps://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ;  simpleTableTest.CThis TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface ;  Slider3Demo.CSimple macro showing capabilities of triple slider ;  splitbuttonTest.CA simple example that shows the usage of a TGSplitButton ;  splitterHorizontal.CThis macro gives an example of how to create a horizontal splitter ;  splitterVertical.CThis macro gives an example of how to create a vertical splitter ;  staffTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  statusBar.CThis macro gives an example of how to create a status bar related to an embedded canvas that shows the info of the selected object, exactly as the status bar of any canvas window ;  textEntries.CThis macro gives an example of how to set/change text entry attributes ;  textviewostream.CThis macro gives an example of how to use the TGTextViewostream widget ;  WorldMap.CThis macro shows how to use a TGImageMap class ;  ► hist;  candleplot.C Example of candle plot with 2-D histograms ;  candleplotoption.C Example showing how to combine the various candle plot options ;  candleplotstack.C Example showing how a THStack with candle plot option ;  candleplotwhiskers.C Example of candle plot showing the whiskers definition ;  ContourList.C Getting Contours From TH2D ;  cumulative.C Illustrate use of the TH1::GetCumulative method ;  draw2dopt.C Display the various 2-d drawing options ;  DynamicSlice.C Show the slice of a TH2 following the mou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:120962,simpl,simple,120962,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"ptimize)))) return;; 2983 fOptimized = kFALSE;; 2984 fNdata = 0;; 2985 fNfulldata = 0;; 2986 ; 2987 TObjArray* infos = (TObjArray*) gROOT->GetListOfStreamerInfo();; 2988 if (fNumber < 0) {; 2989 ++fgCount;; 2990 fNumber = fgCount;; 2991 }; 2992 if (fNumber >= infos->GetSize()) {; 2993 infos->AddAtAndExpand(this, fNumber);; 2994 } else {; 2995 if (!infos->At(fNumber)) {; 2996 infos->AddAt(this, fNumber);; 2997 }; 2998 }; 2999 ; 3000 assert(fComp == 0 && fCompFull == 0 && fCompOpt == 0);; 3001 ; 3002 ; 3003 Int_t ndata = fElements->GetEntriesFast();; 3004 ; 3005 ; 3006 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 3007 else fReadObjectWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3008 ; 3009 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 3010 else fWriteObjectWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3011 ; 3012 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 3013 else fReadMemberWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3014 ; 3015 if (fReadText) fReadText->fActions.clear();; 3016 else fReadText = new TStreamerInfoActions::TActionSequence(this,ndata);; 3017 ; 3018 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 3019 else fWriteMemberWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3020 ; 3021 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 3022 else fReadMemberWiseVecPtr = new TStreamerInfoActions::TActionSequence(this, ndata, kTRUE);; 3023 ; 3024 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 3025 else fWriteMemberWiseVecPtr = new TStreamerInfoActions::TActionSequence(this, ndata, kTRUE);; 3026 ; 3027 if (fWriteText) fWriteText->fActions.clear();; 3028 else fWriteText = new TStreamerInfoActions::TActionSequence(this,ndata);; 3029 ; 3030 if (!ndata) {; 3031 // This may be the case for empty classes (e.g., TAtt3D).; 3032 // We still need to properly set the size of emulated classes (i.e. add the virtual table);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:131930,clear,clear,131930,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['clear'],['clear']
Usability,"ption). Draw a bar char in a rotated pad (X vertical, Y horizontal).; . void PaintBoxes(Option_t* option). Control function to draw a 2D histogram as a box plot.; . void PaintCandlePlot(Option_t* option). Control function to draw a 2D histogram as a candle (box) plot.; . void PaintViolinPlot(Option_t* option). Control function to draw a 2D histogram as a violin plot.; . void PaintColorLevels(Option_t* option). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Double_t x1, Double_t y1, Double_t elev2, Int_t icont2, Double_t x2, Double_t y2, Double_t* xarr, Double_t* yarr, Int_t* itarr, Double_t* levels). Fill the matrix XARR YARR for Contour Plot.; ; . void PaintErrors(Option_t* option). Draw 1D histograms error bars.; . void Paint2DErrors(Option_t* option). Draw 2D histograms errors.; ; . void PaintFrame(). Calculate range and clear pad (canvas).; ; . void PaintFunction(Option_t* option). Paint functions associated to an histogram.; . void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D histogram as a scatter plot.; . void PaintSpecialObjects(const TObject* obj, Option_t* option). Static function to paint specia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:90853,clear,clear,90853,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,3,['clear'],['clear']
Usability,"ption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==1) Hoption.Same += 1;; 4603 goto paintstat;; 4604 }; 4605 if (gridx || gridy) PaintAxis(kTRUE); // Draw the grid only; 4606 ; 4607 // test for options BAR or HBAR; 4608 if (Hoption.Bar >= 10) {; 4609 PaintBar(option);; 4610 }; 4611 ; 4612 // do not draw histogram if error bars required; 4613 if (!Hoption.Error) {; 4614 if (Hoption.Hist && Hoption.Bar<10) PaintHist(option);; 4615 }; 4616 ; 4617 // test for error bars or option E; 4618 if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:173640,clear,clear,173640,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"ption; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::SplitRule. class RooSimWSTool::SplitRule: public TNamed. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__SplitRule.html:1102,simpl,simple,1102,root/html526/RooSimWSTool__SplitRule.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__SplitRule.html,4,['simpl'],['simple']
Usability,"ptions(Int_t* argc, char** argv); const char*TProofServ::GetOrdinal() const; const char*TProofServ::GetPackageDir() const; const char*TProofServ::GetPrefix() const; TProof*TProofServ::GetProof() const; Int_tTProofServ::GetProtocol() const; Int_tTProofServ::GetQuerySeqNum() const; Float_tTProofServ::GetRealTime() const; static Long_tTProofServ::GetResMemMax(); const char*TProofServ::GetService() const; const char*TProofServ::GetSessionDir() const; const char*TProofServ::GetSessionTag() const; TSignalHandler*TApplication::GetSignalHandler() const; TSocket*TProofServ::GetSocket() const; virtual const char*TObject::GetTitle() const; const char*TProofServ::GetTopSessionTag() const; Int_tTProofServ::GetTotSessions() const; virtual UInt_tTObject::GetUniqueID() const; const char*TProofServ::GetUser() const; static Long_tTProofServ::GetVirtMemMax(); const char*TProofServ::GetWorkDir() const; virtual TProofServ::EQueryActionTProofServ::GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); virtual voidTProofServ::HandleException(Int_t sig); virtual voidHandleFork(TMessage* mess); virtual voidTApplication::HandleIdleTimer()SIGNAL ; virtual voidHandleSigPipe(); virtual voidTProofServ::HandleSocketInput(); virtual Int_tTProofServ::HandleSocketInput(TMessage* mess, Bool_t all); virtual voidHandleTermination(); virtual Bool_tTApplication::HandleTermInput(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual voidTProofServ::HandleUrgentData(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTApplication::Hide(); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTApplication::Iconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTApplication::Init(); voidTApplication::In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServLite.html:7725,resume,resume,7725,root/html534/TProofServLite.html,https://root.cern,https://root.cern/root/html534/TProofServLite.html,3,['resume'],['resume']
Usability,"ptr . ). constructor specifying the volume by std::vectors of floats ; Definition at line 56 of file Volume.cxx. ◆ Volume() [2/7]. TMVA::Volume::Volume ; (; std::vector< Double_t > * ; l = nullptr, . std::vector< Double_t > * ; u = nullptr . ). constructor specifying the volume by std::vectors of doubles ; Definition at line 47 of file Volume.cxx. ◆ Volume() [3/7]. TMVA::Volume::Volume ; (; Volume & ; V). copy constructor ; Definition at line 125 of file Volume.cxx. ◆ Volume() [4/7]. TMVA::Volume::Volume ; (; Float_t * ; l, . Float_t * ; u, . Int_t ; nvar . ). constructor specifying the volume by c-style arrays of floats ; Definition at line 86 of file Volume.cxx. ◆ Volume() [5/7]. TMVA::Volume::Volume ; (; Double_t * ; l, . Double_t * ; u, . Int_t ; nvar . ). constructor specifying the volume by c-style arrays of doubles ; Definition at line 71 of file Volume.cxx. ◆ Volume() [6/7]. TMVA::Volume::Volume ; (; Float_t ; l, . Float_t ; u . ). simple constructors for 1 dimensional values (float) ; Definition at line 113 of file Volume.cxx. ◆ Volume() [7/7]. TMVA::Volume::Volume ; (; Double_t ; l, . Double_t ; u . ). simple constructors for 1 dimensional values (double) ; Definition at line 101 of file Volume.cxx. ◆ ~Volume(). TMVA::Volume::~Volume ; (; void ; ). virtual . destructor ; Definition at line 153 of file Volume.cxx. Member Function Documentation. ◆ Delete(). void TMVA::Volume::Delete ; (; void ; ). delete array of volume bondaries ; Definition at line 162 of file Volume.cxx. ◆ operator=(). TMVA::Volume & TMVA::Volume::operator= ; (; const Volume & ; V). assignment operator ; Definition at line 135 of file Volume.cxx. ◆ Print(). void TMVA::Volume::Print ; (; void ; ); const. printout of the volume boundaries ; Definition at line 193 of file Volume.cxx. ◆ Scale(). void TMVA::Volume::Scale ; (; Double_t ; f). ""scale"" the volume by multiplying each upper and lower boundary by ""f"" ; Definition at line 171 of file Volume.cxx. ◆ ScaleInterval(). void TMVA::Volume::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Volume.html:3060,simpl,simple,3060,doc/master/classTMVA_1_1Volume.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Volume.html,1,['simpl'],['simple']
Usability,"put handling settings. ;  ; Int_t Init (const char *masterurl, const char *conffile, const char *confdir, Int_t loglevel, const char *alias=0);  Start the PROOF environment. ;  ; void InitMembers ();  Default initializations. ;  ; virtual TVirtualProofPlayer * MakePlayer (const char *player=0, TSocket *s=0);  Construct a TProofPlayer object. ;  ; void PrepareInputDataFile (TString &dataFile);  Prepare the file with the input data objects to be sent the master; the objects are taken from the dedicated list and / or the specified file. ;  ; Int_t RemoveWorkers (TList *wrks);  Used for shuting down the workres after a query is finished. ;  ; virtual void SaveWorkerInfo ();  Save information about the worker set in the file .workers in the working dir. ;  ; Int_t SendFile (const char *file, Int_t opt=(kBinary|kForward|kCp|kCpBin), const char *rfile=0, TSlave *sl=0);  Send a file to master or slave servers. ;  ; void SetDSet (TDSet *dset);  ; void SetFeedback (TString &opt, TString &optfb, Int_t action);  Extract from opt in optfb information about wanted feedback settings. ;  ; void SetPlayer (TVirtualProofPlayer *player);  Set a new PROOF player. ;  ; void SetupWorkersEnv (TList *wrks, Bool_t increasingpool=kFALSE);  Set up packages, loaded macros, include and lib paths ... ;  ; virtual Bool_t StartSlaves (Bool_t attach=kFALSE);  Start up PROOF slaves. ;  ; void UpdateDialog ();  Final update of the progress dialog. ;  ; virtual void ValidateDSet (TDSet *dset);  Validate a TDSet. ;  ; Int_t VerifyDataSetParallel (const char *uri, const char *optStr);  Internal function for parallel dataset verification used TProof::VerifyDataSet and TProofLite::VerifyDataSet. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:38632,feedback,feedback,38632,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['feedback'],['feedback']
Usability,putation DIRECT does not further transformation; SIGMOID applies a sigmoid transformation to each output value (to create a probability); SOFTMAX applies a softmax transformation to all output values (mutually exclusive probability) . Definition at line 122 of file NeuralNet.cxx. ◆ LayerData() [5/6]. TMVA::DNN::LayerData::LayerData ; (; const LayerData & ; other). inline . copy c'tor of LayerData ; Definition at line 515 of file NeuralNet.h. ◆ LayerData() [6/6]. TMVA::DNN::LayerData::LayerData ; (; LayerData && ; other). inline . move c'tor of LayerData ; Definition at line 538 of file NeuralNet.h. Member Function Documentation. ◆ activationFunction(). std::shared_ptr< std::function< double(double)> > TMVA::DNN::LayerData::activationFunction ; (; ); const. inline . Definition at line 607 of file NeuralNet.h. ◆ clear(). void TMVA::DNN::LayerData::clear ; (; ). inline . clear the values and the deltas ; Definition at line 576 of file NeuralNet.h. ◆ clearDropOut(). void TMVA::DNN::LayerData::clearDropOut ; (; ). inline . clear the drop-out-data for this layer ; Definition at line 620 of file NeuralNet.h. ◆ computeProbabilities(). LayerData::container_type TMVA::DNN::LayerData::computeProbabilities ; (; ); const. private . compute the probabilities from the node values ; Definition at line 140 of file NeuralNet.cxx. ◆ deltasBegin() [1/2]. iterator_type TMVA::DNN::LayerData::deltasBegin ; (; ). inline . returns iterator to the begin of the deltas (back-propagation) ; Definition at line 591 of file NeuralNet.h. ◆ deltasBegin() [2/2]. const_iterator_type TMVA::DNN::LayerData::deltasBegin ; (; ); const. inline . returns const iterator to the begin of the deltas (back-propagation) ; Definition at line 594 of file NeuralNet.h. ◆ deltasEnd() [1/2]. iterator_type TMVA::DNN::LayerData::deltasEnd ; (; ). inline . returns iterator to the end of the deltas (back-propagation) ; Definition at line 592 of file NeuralNet.h. ◆ deltasEnd() [2/2]. const_iterator_type TMVA::DNN::LayerData:,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html:11077,clear,clearDropOut,11077,doc/master/classTMVA_1_1DNN_1_1LayerData.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html,1,['clear'],['clearDropOut']
Usability,"py. void SetOutputFilePrefix(const string& prefix); set output prefix. { fOutputFilePrefix = prefix; }. std::string GetOutputFilePrefix(); retrieve prefix for output files. { return fOutputFilePrefix; }. void SetPOI(const string& POI); insert PoI at beginning of vector of PoIs. { fPOI.insert( fPOI.begin(), POI ); }. void AddPOI(const string& POI); append parameter to vector of PoIs. { fPOI.push_back(POI); }. std::string GetPOI(unsigned int i = 0); get name of PoI at given index. { return fPOI.at(i); }. std::vector<std::string>& GetPOIList(); get vector of PoI names. { return fPOI; }. void ClearConstantParams(); empty vector of constant parameters. { fConstantParams.clear(); }. std::vector< std::string >& GetConstantParams(); get vector of all constant parameters. { return fConstantParams; }. std::map<std::string, double>& GetParamValues(); get map: parameter name <--> parameter value. { return fParamValues; }. void ClearParamValues(); clear map of parameter values. { fParamValues.clear(); }. void AddFunctionObject(const RooStats::HistFactory::PreprocessFunction function); add a preprocess function object. { fFunctionObjects.push_back( function ); }. void SetFunctionObjects(vector<RooStats::HistFactory::PreprocessFunction> objects); get vector of defined function objects. { fFunctionObjects = objects; }. std::vector< RooStats::HistFactory::PreprocessFunction >& GetFunctionObjects(); { return fFunctionObjects; }. std::vector< RooStats::HistFactory::Asimov >& GetAsimovDatasets(); get vector of defined Asimov Datasets. { return fAsimovDatasets; }. void AddAsimovDataset(RooStats::HistFactory::Asimov dataset); add an Asimov Dataset. { fAsimovDatasets.push_back(dataset); }. void SetLumi(double Lumi); set integrated luminosity used to normalise histograms (if NormalizeByTheory is true for this sample). { fLumi = Lumi; }. void SetLumiRelErr(double RelErr); set relative uncertainty on luminosity. { fLumiRelErr = RelErr; }. double GetLumi(); retrieve integrated luminosity. { re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__Measurement.html:12269,clear,clear,12269,root/html534/RooStats__HistFactory__Measurement.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__Measurement.html,1,['clear'],['clear']
Usability,"queSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCategory.html:2059,clear,clearValueAndShapeDirty,2059,root/html602/RooCategory.html,https://root.cern,https://root.cern/root/html602/RooCategory.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"quested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:1859,learn,learning,1859,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['learn'],['learning']
Usability,"r * GetSessionDir() const; { return fSessionDir; }. const char * GetPackageDir() const; { return fPackageDir; }. const char * GetDataDir() const; { return fDataDir; }. Int_t GetProtocol() const; { return fProtocol; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetGroupId() const; { return fGroupId; }. Int_t GetGroupSize() const; { return fGroupSize; }. Int_t GetLogLevel() const; { return fLogLevel; }. TSocket * GetSocket() const; { return fSocket; }. Float_t GetRealTime() const; { return fRealTime; }. Float_t GetCpuTime() const; { return fCpuTime; }. Int_t GetQuerySeqNum() const; { return fQuerySeqNum; }. Int_t GetTotSessions() const; { return fTotSessions; }. Int_t GetActSessions() const; { return fActSessions; }. Float_t GetEffSessions() const; { return fEffSessions; }. TList * GetEnabledPackages() const; { return fEnabledPackages; }. Int_t GetInflateFactor() const; { return fInflateFactor; }. Long64_t GetMsgSizeHWM() const; { return fMsgSizeHWM; }. const char * GetPrefix() const; { return fPrefix; }. TProofLockPath * GetCacheLock(); { return fCacheLock; }. EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE). void HandleTermination(); { Terminate(0); }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsEndMaster() const; { return fEndMaster; }. Bool_t IsMaster() const; { return fMasterServ; }. Bool_t IsTopMaster() const; { return fOrdinal == ""0""; }. void ReleaseWorker(const char* ); { }. void DisableTimeout(); Disable / Enable read timeout. { }. void EnableTimeout(); { }. void LogToMaster(Bool_t on = kTRUE); Log control. { fSendLogToMaster = on; }. » Author: Fons Rademakers 16/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProofServ.h 39696 2011-06-13 21:35:34Z pcanal $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofServ.html:32952,resume,resume,32952,root/html532/TProofServ.html,https://root.cern,https://root.cern/root/html532/TProofServ.html,1,['resume'],['resume']
Usability,"r * GetSessionDir() const; { return fSessionDir; }. const char * GetPackageDir() const; { return fPackageDir; }. const char * GetDataDir() const; { return fDataDir; }. Int_t GetProtocol() const; { return fProtocol; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetGroupId() const; { return fGroupId; }. Int_t GetGroupSize() const; { return fGroupSize; }. Int_t GetLogLevel() const; { return fLogLevel; }. TSocket * GetSocket() const; { return fSocket; }. Float_t GetRealTime() const; { return fRealTime; }. Float_t GetCpuTime() const; { return fCpuTime; }. Int_t GetQuerySeqNum() const; { return fQuerySeqNum; }. Int_t GetTotSessions() const; { return fTotSessions; }. Int_t GetActSessions() const; { return fActSessions; }. Float_t GetEffSessions() const; { return fEffSessions; }. TList * GetEnabledPackages() const; { return fEnabledPackages; }. Int_t GetInflateFactor() const; { return fInflateFactor; }. Long64_t GetMsgSizeHWM() const; { return fMsgSizeHWM; }. const char * GetPrefix() const; { return fPrefix; }. TProofLockPath * GetCacheLock(); { return fCacheLock; }. EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE). void HandleTermination(); { Terminate(0); }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsEndMaster() const; { return fEndMaster; }. Bool_t IsMaster() const; { return fMasterServ; }. Bool_t IsTopMaster() const; { return fOrdinal == ""0""; }. void ReleaseWorker(const char* ); { }. void DisableTimeout(); Disable / Enable read timeout. { }. void EnableTimeout(); { }. void LogToMaster(Bool_t on = kTRUE); Log control. { fSendLogToMaster = on; }. » Author: Fons Rademakers 16/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProofServ.h 39697 2011-06-13 21:43:43Z pcanal $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:32952,resume,resume,32952,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,1,['resume'],['resume']
Usability,"r * TEveSelection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEveSelection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 104 of file TEveSelection.h. ◆ DeactivateSelection(). void TEveSelection::DeactivateSelection ; (; ). virtual . Deactivate this selection. ; Definition at line 271 of file TEveSelection.cxx. ◆ DeclFileName(). static const char * TEveSelection::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 104 of file TEveSelection.h. ◆ DoElementSelect(). void TEveSelection::DoElementSelect ; (; TEveSelection::SelMap_i ; entry). protected . Select element indicated by the entry and fill its implied-selected set. ; Definition at line 62 of file TEveSelection.cxx. ◆ DoElementUnselect(). void TEveSelection::DoElementUnselect ; (; TEveSelection::SelMap_i ; entry). protected . Deselect element indicated by the entry and clear its implied-selected set. ; Definition at line 77 of file TEveSelection.cxx. ◆ GetIsMaster(). Bool_t TEveSelection::GetIsMaster ; (; ); const. inline . Definition at line 67 of file TEveSelection.h. ◆ GetPickToSelect(). Int_t TEveSelection::GetPickToSelect ; (; ); const. inline . Definition at line 64 of file TEveSelection.h. ◆ IsA(). TClass * TEveSelection::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TEveElementList.; Definition at line 104 of file TEveSelection.h. ◆ MapPickedToSelected(). TEveElement * TEveSelection::MapPickedToSelected ; (; TEveElement * ; el). Given element el that was picked or clicked by the user, find the parent/ancestor element that should actually become the main selected element according to current selection mode. ; Definition at line 283 of file TEveSelection.cxx. ◆ operator=(). TEveSelection & TEveSelection::operator= ; (; const TEveSelection & ; ). private . ◆ RecheckImpliedSet(). vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveSelection.html:42903,clear,clear,42903,doc/master/classTEveSelection.html,https://root.cern,https://root.cern/doc/master/classTEveSelection.html,1,['clear'],['clear']
Usability,"r *ind="""");  Hook function interface for object to insert additional information when printed in the context of a tree structure. ;  ; void printComponentTree (const char *indent="""", const char *namePat=nullptr, Int_t nLevel=999);  Print tree structure of expression tree on given ostream, only branch nodes are printed. ;  ; void printDirty (bool depth=true) const;  Print information about current value dirty state information. ;  ; void printName (std::ostream &os) const override;  Print object name. ;  ; void printTitle (std::ostream &os) const override;  Print object title. ;  ; void printTree (std::ostream &os, TString indent="""") const override;  Print object tree structure. ;  ; bool recursiveCheckObservables (const RooArgSet *nset) const;  Recursively call checkObservables on all nodes in the expression tree. ;  ; void removeStringAttribute (const Text_t *key);  Delete a string attribute with a given key. ;  ; void resetDataToken ();  ; void setAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setDataToken (std::size_t index);  Sets the token for retrieving results in the BatchMode. For internal use only. ;  ; void setLocalNoDirtyInhibit (bool flag) const;  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetNameTitle (const char *name, const char *title) override;  Set all the TNamed parameters (name and title). ;  ; void setProhibitServerRedirect (bool flag);  ; void setStringAttribute (const Text_t *key, const Text_t *value);  Associate string 'value' to this object under key 'key'. ;  ; void setTransientAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setWorkspace (RooWorkspace &ws);  ; const std::map< std::string, std::string > & stringAttributes () const;  ; const std::set< std::string > & transientAttributes () const;  ; RooWorkspace * workspace () const;  ; TIterator * cli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:41358,clear,clear,41358,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,3,['clear'],['clear']
Usability,"r *ind="""");  Hook function interface for object to insert additional information when printed in the context of a tree structure. ;  ; void printComponentTree (const char *indent="""", const char *namePat=nullptr, Int_t nLevel=999);  Print tree structure of expression tree on given ostream, only branch nodes are printed. ;  ; void printDirty (bool depth=true) const;  Print information about current value dirty state information. ;  ; void printName (std::ostream &os) const override;  Print object name. ;  ; void printTitle (std::ostream &os) const override;  Print object title. ;  ; void printTree (std::ostream &os, TString indent="""") const override;  Print object tree structure. ;  ; bool recursiveCheckObservables (const RooArgSet *nset) const;  Recursively call checkObservables on all nodes in the expression tree. ;  ; void removeStringAttribute (const Text_t *key);  Delete a string attribute with a given key. ;  ; void resetDataToken ();  ; void setAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setDataToken (std::size_t index);  Sets the token for retrieving results in the BatchMode. For internal use only. ;  ; void setLocalNoDirtyInhibit (bool flag) const;  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetNameTitle (const char *name, const char *title) override;  Set all the TNamed parameters (name and title). ;  ; void setProhibitServerRedirect (bool flag);  ; void setStringAttribute (const Text_t *key, const Text_t *value);  Associate string 'value' to this object under key 'key'. ;  ; void setTransientAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setWorkspace (RooWorkspace &ws);  ; const std::map< std::string, std::string > & stringAttributes () const;  ; const std::set< std::string > & transientAttributes () const;  ; RooWorkspace * workspace () const;  ; const RefCountL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormulaVar.html:30259,clear,clear,30259,doc/master/classRooFormulaVar.html,https://root.cern,https://root.cern/doc/master/classRooFormulaVar.html,8,['clear'],['clear']
Usability,"r *ind="""");  Hook function interface for object to insert additional information when printed in the context of a tree structure. ;  ; void printComponentTree (const char *indent="""", const char *namePat=nullptr, Int_t nLevel=999);  Print tree structure of expression tree on given ostream, only branch nodes are printed. ;  ; void printDirty (bool depth=true) const;  Print information about current value dirty state information. ;  ; void printName (std::ostream &os) const override;  Print object name. ;  ; void printTitle (std::ostream &os) const override;  Print object title. ;  ; void printTree (std::ostream &os, TString indent="""") const override;  Print object tree structure. ;  ; bool recursiveCheckObservables (const RooArgSet *nset) const;  Recursively call checkObservables on all nodes in the expression tree. ;  ; void removeStringAttribute (const Text_t *key);  Delete a string attribute with a given key. ;  ; void resetDataToken ();  ; void setAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setDataToken (std::size_t index);  Sets the token for retrieving results in the BatchMode. For internal use only. ;  ; void setLocalNoDirtyInhibit (bool flag) const;  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetNameTitle (const char *name, const char *title) override;  Set all the TNamed parameters (name and title). ;  ; void setProhibitServerRedirect (bool flag);  ; void setStringAttribute (const Text_t *key, const Text_t *value);  Associate string 'value' to this object under key 'key'. ;  ; void setTransientAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setWorkspace (RooWorkspace &ws);  ; const std::map< std::string, std::string > & stringAttributes () const;  ; const std::set< std::string > & transientAttributes () const;  ; virtual void translate (RooFit::Detail::CodeSquashCon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:38724,clear,clear,38724,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,8,['clear'],['clear']
Usability,"r *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows to make connection from any object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TQCommand.h>. Inheritance diagram for TQCommand:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TQCommand() [1/3]. TQCommand::TQCommand ; (; const char * ; clname = nullptr, . void * ; obj = nullptr, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; clname - class name.; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments:; if either clname or obj is NULL that means that redo/undo is function; to specify default arguments for redo/undo method/function '=' must precede to argument value. Example: TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case undo parameter can be omitted.; Example: TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. Definition at line 168 of file TQCommand.cxx. ◆ TQCommand() [2/3]. TQCommand::TQCommand ; (; TObject * ; obj, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments: to specify default arguments for redo/undo method/function '=' must precede to argument value.; Example: TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:32101,undo,undo,32101,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,2,['undo'],['undo']
Usability,"r += std::get<0>(result) / batches.size ();; 823 std::vector<double> output = std::get<1>(result);; 824 if (output.size() == (outputSize() - 1) * itBatch->size()); 825 {; 826 auto output_iterator = output.begin();; 827 for (auto pattern_it = itBatch->begin(); pattern_it != itBatch->end(); ++pattern_it); 828 {; 829 for (size_t output_index = 1; output_index < outputSize(); ++output_index); 830 {; 831 settings.testSample (0, *output_iterator, (*pattern_it).output ().at (0),; 832 (*pattern_it).weight ());; 833 ++output_iterator;; 834 }; 835 }; 836 }; 837 ++itBatch;; 838 }; 839 ; 840 }; 841 else; 842 {; 843 std::vector<double> output;; 844 //for (auto it = begin (testPattern), itEnd = end (testPattern); it != itEnd; ++it); 845 {; 846 //const Pattern& p = (*it);; 847 //double weight = p.weight ();; 848 //Batch batch (it, it+1);; 849 Batch batch (begin (testPattern), end (testPattern));; 850 output.clear ();; 851 pass_through_type passThrough (settings, batch, dropContainerTest);; 852 double testPatternError = (*this) (passThrough, weights, ModeOutput::FETCH, output);; 853 if (output.size() == (outputSize() - 1) * batch.size()); 854 {; 855 auto output_iterator = output.begin();; 856 for (auto pattern_it = batch.begin(); pattern_it != batch.end(); ++pattern_it); 857 {; 858 for (size_t output_index = 1; output_index < outputSize(); ++output_index); 859 {; 860 settings.testSample (0, *output_iterator, (*pattern_it).output ().at (0),; 861 (*pattern_it).weight ());; 862 ++output_iterator;; 863 }; 864 }; 865 }; 866 testError += testPatternError; /// batch.size ();; 867 }; 868 // testError /= testPattern.size ();; 869 }; 870 settings.endTestCycle ();; 871// testError /= weightSum;; 872 ; 873 settings.computeResult (*this, weights);; 874 ; 875 hasConverged = settings.hasConverged (testError);; 876 if (!hasConverged && !isWeightsForDrop); 877 {; 878 dropOutWeightFactor (weights, dropFractions, true); // inverse; 879 isWeightsForDrop = true;; 880 }; 881 }; 882 ++testCycleCount;; 883",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:25627,clear,clear,25627,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['clear'],['clear']
Usability,"r ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; textOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; TPave.h; TText.h; TAttTextText Attributes class.Definition TAttText.h:18; TBoxCreate a Box.Definition TBox.h:22; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TListA doubly linked list.Definition TList.h:38; TObjectMother of all ROOT objects.Definition TObject.h:41; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::fLongestInt_t fLongestLength of the longest line.Definition TPaveText.h:25; TPaveText::GetSizevirtual Int_t GetSize() constreturn number of text lines (ignoring TLine, etc)Definition TPaveText.cxx:373; TPaveText::~TPaveText~TPaveText() overridepavetext default destructor.Definition TPaveText.cxx:118; TPaveText::GetListOfLinesvirtual TList * GetListOfLines() constDefinition TPaveText.h:48; TPaveText::GetLabelconst char * GetLabel() constDefinition TPaveText.h:45; TPaveText::fLinesTList * fLinesList of labels.Definition TPaveText.h:27; TPaveText::PaintPrimit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPaveText_8h_source.html:5061,simpl,simple,5061,doc/master/TPaveText_8h_source.html,https://root.cern,https://root.cern/doc/master/TPaveText_8h_source.html,1,['simpl'],['simple']
Usability,"r Functions |; Private Attributes |; Friends |; List of all members ; ROOT::RDF::RResultPtr< T > Class Template ReferenceDataframe. ; template<typename T>; class ROOT::RDF::RResultPtr< T >Smart pointer for the return type of actions. ; A wrapper around the result of RDataFrame actions able to trigger calculations lazily. Template Parameters. TType of the action result. A smart pointer which allows to access the result of a RDataFrame action. The methods of the encapsulated object can be accessed via the arrow operator. Upon invocation of the arrow operator or dereferencing (operator*), the loop on the events and calculations of all scheduled actions are executed if needed. It is possible to iterate on the result proxy if the proxied object is a collection. for (auto& myItem : myResultProxy) { ... };; If iteration is not supported by the type of the proxied object, a compilation error is thrown. ; Definition at line 119 of file RResultPtr.hxx. Public Types; using Value_t = T;  Convenience alias to simplify access to proxied type. ;  . Public Member Functions;  RResultPtr ()=default;  ;  RResultPtr (const RResultPtr &)=default;  ; template<typename T2 , std::enable_if_t< std::is_constructible< std::shared_ptr< T >, std::shared_ptr< T2 > >::value, int > = 0> ;  RResultPtr (const RResultPtr< T2 > &r);  Convert a RResultPtr<T2> to a RResultPtr<T>. ;  ;  RResultPtr (RResultPtr &&)=default;  ; RIterationHelper< T >::Iterator_t begin ();  Return an iterator to the beginning of the contained object if this makes sense, throw a compilation error otherwise. ;  ; RIterationHelper< T >::Iterator_t end ();  Return an iterator to the end of the contained object if this makes sense, throw a compilation error otherwise. ;  ; T * GetPtr ();  Get the pointer to the encapsulated object. ;  ; const T & GetValue ();  Get a const reference to the encapsulated object. ;  ; bool IsReady () const;  Check whether the result has already been computed. ;  ; RResultPtr< T > & OnPartialResult (UL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html:1278,simpl,simplify,1278,doc/master/classROOT_1_1RDF_1_1RResultPtr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html,1,['simpl'],['simplify']
Usability,"r Undo(); TStringTQCommand::fTitlecommand description; TQConnection*TQCommand::fUndoundo action; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:48; This page has been automatically generated. For comments or s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQUndoManager.html:19385,undo,undo,19385,root/html534/TQUndoManager.html,https://root.cern,https://root.cern/root/html534/TQUndoManager.html,1,['undo'],['undo']
Usability,"r Undo(); TStringTQCommand::fTitlecommand description; TQConnection*TQCommand::fUndoundo action; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 25128 2008-08-12 17:59:19Z pcanal $ » Last generated: 2010-09-23 20:20; This page has",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:19182,undo,undo,19182,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,1,['undo'],['undo']
Usability,"r Undo(); TStringTQCommand::fTitlecommand description; TQConnection*TQCommand::fUndoundo action; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 39365 2011-05-24 19:53:19Z pcanal $ » Last generated: 2011-07-04 15:36; This page has",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TQUndoManager.html:19366,undo,undo,19366,root/html530/TQUndoManager.html,https://root.cern,https://root.cern/root/html530/TQUndoManager.html,1,['undo'],['undo']
Usability,"r Undo(); TStringTQCommand::fTitlecommand description; TQConnection*TQCommand::fUndoundo action; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 39365 2011-05-24 19:53:19Z pcanal $ » Last generated: 2011-11-03 20:22; This page has",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQUndoManager.html:19366,undo,undo,19366,root/html532/TQUndoManager.html,https://root.cern,https://root.cern/root/html532/TQUndoManager.html,1,['undo'],['undo']
Usability,"r WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. It is not simple to activate the cache; by default (except case1 below) because there are many possible configurations.; In some applications you know a priori the list of branches to read.; In other applications the analysis loop calls several layers of user functions; where it is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the sy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:3715,simpl,simple,3715,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,3,['simpl'],['simple']
Usability,"r another; TH1 histogram (for all dimensions).; For example the following two statements create and fill an histogram; 10000 times with a default gaussian distribution of mean 0 and sigma 1:. TH1F h1(""h1"", ""histo from a gaussian"", 100, -3, 3);; h1.FillRandom(""gaus"", 10000);. TH1::GetRandom can be used to return a random number distributed; according the contents of an histogram.; Making a copy of an histogram; Like for any other ROOT object derived from TObject, one can use; the Clone() function. This makes an identical copy of the original; histogram including all associated errors and functions, e.g.:. TH1F *hnew = (TH1F*)h->Clone(""hnew"");. Normalizing histograms; One can scale an histogram such that the bins integral is equal to; the normalization parameter via TH1::Scale(Double_t norm), where norm; is the desired normalization divided by the integral of the histogram.; Drawing histograms; Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; Many drawing options are supported.; See THistPainter::Paint() for more details. The same histogram can be drawn with different options in different pads.; When an histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If an histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of an histogram in a pad, one can use. h->DrawCopy();. This makes a clone (see Clone below) of the histogram. Once the clone; is drawn, the original histogram may be modified or deleted without; affecting the aspect of the clone. One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular; value for the maximum or the minimum scale on the plot. (For 1-D; histograms this means the y-axis, while for 2-D histograms these; fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:13452,usab,usable,13452,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['usab'],['usable']
Usability,"r block ;  ; Bool_t fCanCreateObjects {kTRUE};  ! indicates if canvas allowed to create extra objects for interactive painting ;  ; Long64_t fCanvVersion {1};  ! actual canvas version, changed with every new Modified() call ;  ; UInt_t fClientBits {0};  ! latest status bits from client like editor visible or not ;  ; UInt_t fColorsHash {0};  ! last hash of colors/palette ;  ; Long64_t fColorsVersion {0};  ! current colors/palette version, checked every time when new snapshot created ;  ; Bool_t fFixedSize {kFALSE};  ! is canvas size fixed ;  ; std::vector< std::unique_ptr< ROOT::RWebDisplayHandle > > fHelpHandles;  ! array of handles for help widgets ;  ; Int_t fJsonComp {0};  ! compression factor for messages send to the client ;  ; Bool_t fLongerPolling {kFALSE};  ! when true, make longer polling in blocking operations ;  ; ObjectSelectSignal_t fObjSelectSignal;  ! signal emitted when new object selected in the pad ;  ; PadClickedSignal_t fPadClickedSignal;  ! signal emitted when simple mouse click performed on the pad ;  ; PadClickedSignal_t fPadDblClickedSignal;  ! signal emitted when simple mouse click performed on the pad ;  ; std::map< TPad *, PadStatus > fPadsStatus;  ! map of pads in canvas and their status flags ;  ; Int_t fPaletteDelivery {1};  ! colors palette delivery 0:never, 1:once, 2:always, 3:per subpad ;  ; Int_t fPrimitivesMerge {100};  ! number of PS primitives, which will be merged together ;  ; Bool_t fProcessingData {kFALSE};  ! flag used to prevent blocking methods when process data is invoked ;  ; Bool_t fReadOnly {kFALSE};  !< configured display ;  ; Int_t fStyleDelivery {0};  ! gStyle delivery to clients: 0:never, 1:once, 2:always ;  ; UInt_t fStyleHash {0};  ! last hash of gStyle ;  ; Long64_t fStyleVersion {0};  ! current gStyle object version, checked every time when new snapshot created ;  ; Int_t fTF1UseSave {1};  ! use save buffer for TF1/TF2, 0:off, 1:prefer, 2:force ;  ; TWebCanvasTimer * fTimer {nullptr};  ! timer to submit control",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:14854,simpl,simple,14854,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['simpl'],['simple']
Usability,"r chamber; by positioning it 1000 times in different positions of the pad. Unfortunatelly,; this is far from being the optimal way of doing what we want.; Imagine that we would like to find out which of the 1000 chambers is containing; a (x,y,z) point defined in the pad reference. You will never have to do that,; since the modeller will take care of it for you, but let's guess what it has; to do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current chamber; contains the point or not. This might be efficient for pads with few chambers,; but definitely not for 1000. Fortunately the modeler is smarter than that and; create for each volume some optimization structures called voxels (see Voxelization); to minimize the penalty having too many daughters, but if you have 100 pads like; this in your geometry you will anyway loose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the; usage of divisions. We will describe them in detail later on. Let's think now; at a different situation : instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical and have; a wire inside, but their dimensions are different. However, we would like all; to be represented by a single volume family, since they have the same properties. Volume families (TGeoVolumeMulti). A volume family is represented by the class TGeoVolumeMulti. It represents; a class of volumes having the same shape type and each member will be; identified by the same name and volume ID. Any operation applied to a; TGeoVolume equally affects all volumes in that family. The creation of a; family is generally not a user task, but can be forced in particular cases:. TGeoManager::Volume(const char *vname, const char *shape, Int_t nmed);. where VNAME is the family name, NMED is the medium number and SHAPE is the; shape type that can",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:10025,simpl,simple,10025,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,9,['simpl'],['simple']
Usability,"r class ;  CTSplineBase class for spline implementation containing the Draw/Paint methods // ;  CTSpline3;  CTSpline5;  CTSplinePoly;  CTSplinePoly3;  CTSplinePoly5;  CTSPlot;  CTSQLClassColumnInfo;  CTSQLClassInfoContains information about tables specific to one class and version ;  CTSQLColumnData;  CTSQLColumnInfo;  CTSQLFileAccess an SQL db via the TFile interface ;  CTSQLiteResult;  CTSQLiteRow;  CTSQLiteServer;  CTSQLiteStatement;  CTSQLMonitoringWriter;  CTSQLObjectDataTSQLObjectData is used in TBufferSQL2 class in reading procedure ;  CTSQLObjectDataPoolXML object keeper class ;  CTSQLObjectInfoInfo (classname, version) about object in database ;  CTSQLResult;  CTSQLRow;  CTSQLServer;  CTSQLStatement;  CTSQLStructureThis is hierarhical structure, which is created when data is written by TBufferSQL2 ;  CTSQLTableData;  CTSQLTableInfo;  CTSSLSocket;  CTStatisticStatistical variable, defined by its mean and variance (RMS) ;  CTStatsFeedbackUtility class to display PROOF stats feedback histos during queries ;  CTStatusThis class holds the status of an ongoing operation and collects error messages ;  CTStdExceptionHandler;  CTStopwatchStopwatch class ;  CTStorageStorage manager ;  CTStreamerArtificial;  CTStreamerBase;  CTStreamerBasicPointer;  CTStreamerBasicType;  CTStreamerElement;  ►CTStreamerInfoDescribe Streamer information for one class version ;  CTCompInfo;  CTPointerCollectionAdapter;  CTStreamerLoop;  CTStreamerObject;  CTStreamerObjectAny;  CTStreamerObjectAnyPointer;  CTStreamerObjectPointer;  CTStreamerSTL;  CTStreamerSTLstring;  CTStreamerString;  ►CTStringBasic string class ;  CLongStr_t;  CRawStr_t;  CRep_t;  CShortStr_t;  CUStr_t;  CTStringLongATTENTION: this class is obsolete ;  CTStringTokenProvides iteration through tokens of a given string ;  CTStructNode;  CTStructNodeEditor;  CTStructNodeProperty;  CTStructViewer;  CTStructViewerGUI;  CTStyleTStyle objects may be created to define special styles ;  CTStyleDialog;  CTStyleManager;  CTStylePr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:188050,feedback,feedback,188050,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['feedback'],['feedback']
Usability,"r collection and the other collection have a size of one, the arguments are always synchronized without checking if they have the same name. . Definition at line 305 of file RooAbsCollection.cxx. ◆ begin(). const_iterator RooAbsCollection::begin ; (; ); const. inline . Definition at line 253 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCollection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 432 of file RooAbsCollection.h. ◆ clear(). void RooAbsCollection::clear ; (; ). inline . Clear contents. If the collection is owning, it will also delete the contents. ; Definition at line 282 of file RooAbsCollection.h. ◆ clearStructureTags(). void RooAbsCollection::clearStructureTags ; (; ). inlineprotected . Definition at line 392 of file RooAbsCollection.h. ◆ clone(). virtual TObject * RooAbsCollection::clone ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ Clone(). TObject * RooAbsCollection::Clone ; (; const char * ; newname = nullptr); const. inlineoverridevirtual . Make a clone of an object using the Streamer facility. ; If the object derives from TNamed, this function is called by TNamed::Clone. TNamed::Clone uses the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:35942,clear,clear,35942,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['clear'],['clear']
Usability,"r expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:23661,learn,learning,23661,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['learn'],['learning']
Usability,"r file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::QuickMVAProbEstimator. class TMVA::QuickMVAProbEstimator. Function Members (Methods); public:. virtual~QuickMVAProbEstimator(); voidAddEvent(Double_t val, Double_t weight, Int_t type); static TClass*Class(); static boolcompare(TMVA::QuickMVAProbEstimator::EventInfo e1, TMVA::QuickMVAProbEstimator::EventInfo e2); Double_tGetMVAProbAt(Double_t value); virtual TClass*IsA() const; TMVA::QuickMVAProbEstimator&operator=(const TMVA::QuickMVAProbEstimator&); TMVA::QuickMVAProbEstimatorQuickMVAProbEstimator(const TMVA::QuickMVAProbEstimator&); TMVA::QuickMVAProbEstimatorQuickMVAProbEstimator(Int_t nMin = 40, Int_t nMax = 5000); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. vector<TMVA::QuickMVAProbEstimator::EventInfo>fEvtVector; Bool_tfIsSorted; TMVA::MsgLogger*fLogger; UInt_tfNMax; UInt_tfNMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddEvent(Double_t val, Double_t weight, Int_t type). Double_t GetMVAProbAt(Double_t value); Well.. if it's fast is actually another question all together, merely; it's a quick and dirty simple kNN approach to the 1-Dim signal/backgr. MVA; distributions. bool compare(TMVA::QuickMVAProbEstimator::EventInfo e1, TMVA::QuickMVAProbEstimator::EventInfo e2); {return e1.eventValue < e2.eventValue;}. QuickMVAProbEstimator(Int_t nMin = 40, Int_t nMax = 5000); { fLogger = new MsgLogger(""QuickMVAProbEstimator"");}. virtual ~QuickMVAProbEstimator(); {delete fLogger;}. » Last changed: Tue Jun 30 15:17:30 2015 » Last generated: 2015-06-30 15:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__QuickMVAProbEstimator.html:1505,simpl,simple,1505,root/html602/TMVA__QuickMVAProbEstimator.html,https://root.cern,https://root.cern/root/html602/TMVA__QuickMVAProbEstimator.html,1,['simpl'],['simple']
Usability,"r int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDTree_int_double_.html:4118,simpl,simplify,4118,root/html528/TKDTree_int_double_.html,https://root.cern,https://root.cern/root/html528/TKDTree_int_double_.html,12,['simpl'],['simplify']
Usability,r interface for a user.; TRecorderInactive Represents state of TRecorder after its creation; TRecorderPaused Represents state of TRecorder when paused; TRecorderRecording Represents state of TRecorder when recording events; TRecorderReplaying Represents state of TRecorder when replaying; TRecorderState Abstract class that defines interface for a state of recorder; TRedirectOutputGuard Exception safe output redirection; TRef Persistent Reference link to a TObject; TRefArray An array of references to TObjects; TRefArrayIter Object array iterator; TRefCnt ; TRefTable Table of referenced objects during an I/O operation; TRegexp Regular expression class; TRemoteObject A remote object; TResponseTable Generic Geant detector response table; TRint ROOT Interactive Application Interface; TRobustEstimator Minimum Covariance Determinant Estimator; TRolke ; TRootApplication ROOT native GUI application environment; TRootAuth client auth interface; TRootBrowser New ROOT Browser; TRootBrowserLite ROOT native GUI version of browser; TRootCanvas ROOT native GUI version of main window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TRuby Ruby/ROOT interface; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class ; TSQLColumnData Single SQL column data.; TSQLColumnInfo Summur,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:123450,pause,paused,123450,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['pause'],['paused']
Usability,r list tree. ;  ; TGCompositeFrame * fListHdr;  Header for list view. ;  ; TGLabel * fLbl1;  Label for list tree. ;  ; TGLabel * fLbl2;  Label for list view. ;  ; TGHorizontalFrame * fBFrame;  Button frame. ;  ; TGHorizontalFrame * fHpb;  Progress bar frame. ;  ; TGHProgressBar * fProgressBar;  Progress bar. ;  ; TGLabel * fBLbl4;  Label for input list entry. ;  ; TGLabel * fBLbl5;  Label for output list entry. ;  ; TGTextEntry * fBarListIn;  Tree input event list name entry. ;  ; TGTextEntry * fBarListOut;  Pree output event list name entry. ;  ; TGPictureButton * fDRAW;  DRAW button. ;  ; TGTextButton * fSPIDER;  SPIDER button. ;  ; TGPictureButton * fSTOP;  Interrupt current command (not yet) ;  ; TGPictureButton * fREFR;  REFRESH button ///<ia. ;  ; TGStatusBar * fStatusBar;  Status bar. ;  ; TGComboBox * fCombo;  Combo box with session records. ;  ; TGPictureButton * fBGFirst;  ; TGPictureButton * fBGPrevious;  ; TGPictureButton * fBGRecord;  ; TGPictureButton * fBGNext;  ; TGPictureButton * fBGLast;  ; TGTextButton * fReset;  clear expression's entries ;  ; ListTree; TGCanvas * fTreeView;  ListTree canvas container. ;  ; TGListTree * fLt;  ListTree with file and tree items. ;  ; ListView; TGListView * fListView;  ListView with branches and leaves. ;  ; TTVLVContainer * fLVContainer;  Container for listview. ;  ; TList * fWidgets;  List of widgets to be deleted. ;  . Friends; class TGButton;  ; class TGClient;  . Additional Inherited Members;  Protected Types inherited from TGMainFrame; enum  { kDontCallClose = (1ULL << ( 14 )); };  ;  Protected Types inherited from TGFrame; enum  { kDeleteWindowCalled = (1ULL << ( 15 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGMainFrame; TString GetMWMfuncString () const;  used in SaveSource() ;  ; TString GetMWMinpString () const;  used in SaveSource() ;  ; TString GetMWMvalueString () const;  used in SaveSource() ;  ;  Protecte,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeViewer.html:42595,clear,clear,42595,doc/master/classTTreeViewer.html,https://root.cern,https://root.cern/doc/master/classTTreeViewer.html,1,['clear'],['clear']
Usability,"r object (i.e. the text buffer will be deleted by the text entry widget). ; Definition at line 247 of file TGTextEntry.cxx. ◆ TGTextEntry() [3/4]. TGTextEntry::TGTextEntry ; (; const TGWindow * ; parent = nullptr, . const char * ; text = nullptr, . Int_t ; id = -1 . ). Simple text entry constructor. ; Definition at line 269 of file TGTextEntry.cxx. ◆ TGTextEntry() [4/4]. TGTextEntry::TGTextEntry ; (; const TString & ; contents, . const TGWindow * ; parent, . Int_t ; id = -1 . ). Simple test entry constructor. ; Notice TString argument comes before the parent argument (to make this ctor different from the first one taking a const char*). ; Definition at line 287 of file TGTextEntry.cxx. ◆ ~TGTextEntry(). TGTextEntry::~TGTextEntry ; (; ). override . Delete a text entry widget. ; Definition at line 303 of file TGTextEntry.cxx. Member Function Documentation. ◆ AppendText(). void TGTextEntry::AppendText ; (; const char * ; text). virtual . Appends text to the end of text entry, clears the selection and moves the cursor to the end of the line. ; If necessary the text is truncated to fit MaxLength(). See also GetText(), InsertText(), SetText(), RemoveText(). ; Definition at line 1689 of file TGTextEntry.cxx. ◆ Backspace(). void TGTextEntry::Backspace ; (; ). Deletes the character on the left side of the text cursor and moves the cursor one position to the left. ; If a text has been marked by the user (e.g. by clicking and dragging) the cursor will be put at the beginning of the marked text and the marked text will be removed. See also Del(). ; Definition at line 873 of file TGTextEntry.cxx. ◆ Class(). static TClass * TGTextEntry::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGTextEntry::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGTextEntry::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 184 of file TGTextEntry.h. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEntry.html:43674,clear,clears,43674,doc/master/classTGTextEntry.html,https://root.cern,https://root.cern/doc/master/classTGTextEntry.html,1,['clear'],['clears']
Usability,"r only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Calculate and return 'raw' unnormalized value of p.d.f. ;  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; Int_t * randomizeProtoOrd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooEffProd.html:59364,simpl,simple,59364,doc/master/classRooEffProd.html,https://root.cern,https://root.cern/doc/master/classRooEffProd.html,1,['simpl'],['simple']
Usability,"r package 'pack'. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; Bool_t Has (const char *pack);  Method to check if this package manager has package 'pack'. ;  ; Int_t Install (const char *par, Bool_t rmold=kFALSE);  Install package from par (unpack the file in the directory); par can be an URL for remote retrieval. ;  ; TClass * IsA () const override;  ; Bool_t IsInDir (const char *path);  Method to check if 'path' is in the managed directory Return kTRUE or kFALSE. ;  ; Bool_t IsPackageEnabled (const char *pack);  ; Int_t Load (const char *pack, const char *opts);  Method to load a package taking an option const char * Return -1 on error, 0 otherwise. ;  ; Int_t Load (const char *pack, TList *optls=0);  Method to load a package taking an option list Return -1 on error, 0 otherwise. ;  ; TMD5 * ReadMD5 (const char *pack);  Read MD5 checksum of the PAR file from the PROOF-INF/md5.txt file. ;  ; Int_t Remove (const char *pack=0, Bool_t dolock=kTRUE);  Remove package 'pack' If 'pack' is null or empty all packages are cleared. ;  ; void SetLogger (TPackMgrLog_t logger);  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetPrefix (const char *pfx);  ; void Show (const char *title=0);  Show available packages. ;  ; void ShowEnabled (const char *title=0);  Show enabled packages. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t Unload (const char *pack);  Method to unload a package. ;  ; Int_t Unpack (const char *pack, TMD5 *sum=0);  Read MD5 checksum of the PAR file from the PROOF-INF/md5.txt file. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:3840,clear,cleared,3840,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['clear'],['cleared']
Usability,"r suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoSphereEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for sphere editor. ~TGeoSphereEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given sphere. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoTheta1(); Slot for theta1. void DoTheta2(); Slot for theta2. void DoTheta(); Slot for theta slider. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphereEditor.html:21709,undo,undoing,21709,root/html534/TGeoSphereEditor.html,https://root.cern,https://root.cern/root/html534/TGeoSphereEditor.html,1,['undo'],['undoing']
Usability,"r this element; TEntryList*TEventIter::fEntryList! entry list for processing; Long64_tTEventIter::fEntryListPos! current position in the entrylist; TEventList*TEventIter::fEventList! eventList for processing; Int_tTEventIter::fEventListPos! current position in the eventList; TFile*TEventIter::fFileCurrent file; TStringTEventIter::fFilenameName of the current file; Long64_tTEventIter::fFirstfirst entry to process; Long64_tTEventIter::fNumnumber of entries to process; Long64_tTEventIter::fOldBytesReadlast reported number of bytes read; TList*TEventIter::fPacketslist of packets processed packets; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile); Load a tree from s TDSetElement. Int_t GetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0); Get loop range",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEventIterTree.html:7408,learn,learning,7408,root/html534/TEventIterTree.html,https://root.cern,https://root.cern/root/html534/TEventIterTree.html,1,['learn'],['learning']
Usability,"r this element; TEntryList*TEventIter::fEntryList! entry list for processing; Long64_tTEventIter::fEntryListPos! current position in the entrylist; TEventList*TEventIter::fEventList! eventList for processing; Int_tTEventIter::fEventListPos! current position in the eventList; TFile*TEventIter::fFileCurrent file; TStringTEventIter::fFilenameName of the current file; Long64_tTEventIter::fFirstfirst entry to process; Long64_tTEventIter::fNumnumber of entries to process; Long64_tTEventIter::fOldBytesReadlast reported number of bytes read; TList*TEventIter::fPacketslist of packets processed packets; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile, const char* objname = 0); Load a tree from s TDSetElement. Int_t GetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList**",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEventIterTree.html:7901,learn,learning,7901,root/html602/TEventIterTree.html,https://root.cern,https://root.cern/root/html602/TEventIterTree.html,2,['learn'],['learning']
Usability,"r to match one ore more container; 273limits. Suppose we want to position the same box inside 2 different volumes; 274and we want the Z size to match the one of each container:; 275 ; 276~~~ {.cpp}; 277 TGeoVolume *container1 = gGeoManager->MakeBox(""C1"", imed, 10,10,30);; 278 TGeoVolume *container2 = gGeoManager->MakeBox(""C2"", imed, 10,10,20);; 279 TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"", jmed, 3,3,-1);; 280 container1->AddNode(pvol, 1);; 281 container2->AddNode(pvol, 1);; 282~~~; 283 ; 284 Note that the third parameter of PVOL is negative, which does not make sense; 285as half-length on Z. This is interpreted as: when positioned, create a box; 286replacing all invalid parameters with the corresponding dimensions of the; 287container. This is also internally handled by the TGeoVolumeMulti class, which; 288does not need to be instantiated by users.; 289 ; 290### Dividing volumes; 291 ; 292 Volumes can be divided according a pattern. The most simple division can; 293be done along one axis, that can be: X, Y, Z, Phi, Rxy or Rxyz. Let's take; 294the most simple case: we would like to divide a box in N equal slices along X; 295coordinate, representing a new volume family. Supposing we already have created; 296the initial box, this can be done like:; 297 ; 298~~~ {.cpp}; 299 TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N);; 300~~~; 301 ; 302where SLICE is the name of the new family representing all slices and 1 is the; 303slicing axis. The meaning of the axis index is the following: for all volumes; 304having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; 305tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; 306pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; 307 In fact, the division operation has the same effect as positioning volumes; 308in a given order inside the divided container - the advantage being that the; 309navigation in such a structure is much faster. When a volume is div",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:14711,simpl,simple,14711,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['simpl'],['simple']
Usability,"r to the created sub-directory or to the top sub-directory of the hierarchy (in the above example, the returned TDirectory * always points to ""a""). ; Reimplemented from TDirectory.; Definition at line 1249 of file TDirectoryFile.cxx. ◆ OpenFile(). TFile * TDirectoryFile::OpenFile ; (; const char * ; name, . Option_t * ; option = """", . const char * ; ftitle = """", . Int_t ; compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, . Int_t ; netopt = 0 . ). overridevirtual . Interface to TFile::Open. ; Reimplemented from TDirectory.; Definition at line 1233 of file TDirectoryFile.cxx. ◆ operator=(). void TDirectoryFile::operator= ; (; const TDirectoryFile & ; ). privatedelete . ◆ Purge(). void TDirectoryFile::Purge ; (; Short_t ; nkeep = 1). overridevirtual . Purge lowest key cycles in a directory. ; By default, only the highest cycle of a key is kept. Keys for which the ""KEEP"" flag has been set are not removed. See TKey::Keep(). NOTE: This does not reduce the size of a TFile– the space is simply freed up to be overwritten. ; Reimplemented from TDirectory.; Definition at line 1290 of file TDirectoryFile.cxx. ◆ ReadAll(). void TDirectoryFile::ReadAll ; (; Option_t * ; opt = """"). overridevirtual . Read objects from a ROOT file directory into memory. ; If an object is already in memory, the memory copy is deleted and the object is again read from the file. If opt==""dirs"", only subdirectories will be read If opt==""dirs*"" complete directory tree will be read ; Reimplemented from TDirectory.; Definition at line 1326 of file TDirectoryFile.cxx. ◆ ReadKeys(). Int_t TDirectoryFile::ReadKeys ; (; Bool_t ; forceRead = kTRUE). overridevirtual . Read the linked list of keys. ; Every directory has a linked list (fKeys). This linked list has been written on the file via WriteKeys as a single data record.; It is interesting to call this function in the following situation. Assume another process1 is connecting this directory in Update mode; Process1 is adding/updating obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDirectoryFile.html:42898,simpl,simply,42898,doc/master/classTDirectoryFile.html,https://root.cern,https://root.cern/doc/master/classTDirectoryFile.html,1,['simpl'],['simply']
Usability,"r values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t hesse(); Execute HESSE. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t minos(); Execute MINOS. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t minos(const RooArgSet& minosParamList); Execute MINOS for given list of parameters. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t seek(); Execute SEEK. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t simplex(); Execute SIMPLEX. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t improve(); Execute IMPROVE. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t setPrintLevel(Int_t newLevel); Change the MINUIT internal printing level. void optimizeConst(Bool_t flag); If flag is true, perform constant term optimization on; function being minimized. RooFitResult* save(const char* name = 0, const char* title = 0); Save and return a RooFitResult snaphot of current minimizer status.; This snapshot contains the values of all constant parameters,; the value of all floating parameters at RooMinimizer construction and; after the last MINUIT operation, the MINUIT status, variance quality,; EDM setting, number of calls with evaluation problems, the minimized; function value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMinimizer.html:10399,simpl,simplex,10399,root/html526/RooMinimizer.html,https://root.cern,https://root.cern/root/html526/RooMinimizer.html,3,['simpl'],['simplex']
Usability,"r values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t hesse(); Execute HESSE. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t minos(); Execute MINOS. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t minos(const RooArgSet& minosParamList); Execute MINOS for given list of parameters. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t seek(); Execute SEEK. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t simplex(); Execute SIMPLEX. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t improve(); Execute IMPROVE. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t setPrintLevel(Int_t newLevel); Change the MINUIT internal printing level. void optimizeConst(Int_t flag); If flag is true, perform constant term optimization on; function being minimized. RooFitResult* save(const char* name = 0, const char* title = 0); Save and return a RooFitResult snaphot of current minimizer status.; This snapshot contains the values of all constant parameters,; the value of all floating parameters at RooMinimizer construction and; after the last MINUIT operation, the MINUIT status, variance quality,; EDM setting, number of calls with evaluation problems, the minimized; function value ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMinimizer.html:10553,simpl,simplex,10553,root/html532/RooMinimizer.html,https://root.cern,https://root.cern/root/html532/RooMinimizer.html,4,['simpl'],['simplex']
Usability,"r values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t hesse(); Execute HESSE. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t minos(); Execute MINOS. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t minos(const RooArgSet& minosParamList); Execute MINOS for given list of parameters. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t seek(); Execute SEEK. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t simplex(); Execute SIMPLEX. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t improve(); Execute IMPROVE. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t setPrintLevel(Int_t newLevel); Change the MINUIT internal printing level. void setNoWarn(); Instruct MINUIT to suppress warnings. Int_t setWarnLevel(Int_t newLevel); Set MINUIT warning level to given level. Bool_t synchronize(Bool_t verbose); Internal function to synchronize TMinuit with current; information in RooAbsReal function parameters. void optimizeConst(Bool_t flag); If flag is true, perform constant term optimization on; function being minimized. RooFitResult* save(const char* name = 0, const char* title = 0); Save and return a RooFitResult snaphot of current minimizer status.; This snapshot cont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMinuit.html:10709,simpl,simplex,10709,root/html526/RooMinuit.html,https://root.cern,https://root.cern/root/html526/RooMinuit.html,3,['simpl'],['simplex']
Usability,"r values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t hesse(); Execute HESSE. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t minos(); Execute MINOS. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t minos(const RooArgSet& minosParamList); Execute MINOS for given list of parameters. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t seek(); Execute SEEK. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t simplex(); Execute SIMPLEX. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t improve(); Execute IMPROVE. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t setPrintLevel(Int_t newLevel); Change the MINUIT internal printing level. void setNoWarn(); Instruct MINUIT to suppress warnings. Int_t setWarnLevel(Int_t newLevel); Set MINUIT warning level to given level. Bool_t synchronize(Bool_t verbose); Internal function to synchronize TMinuit with current; information in RooAbsReal function parameters. void optimizeConst(Int_t flag); If flag is true, perform constant term optimization on; function being minimized. RooFitResult* save(const char* name = 0, const char* title = 0); Save and return a RooFitResult snaphot of current minimizer status.; This snapshot conta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMinuit.html:10982,simpl,simplex,10982,root/html532/RooMinuit.html,https://root.cern,https://root.cern/root/html532/RooMinuit.html,4,['simpl'],['simplex']
Usability,"r(""myFilter(x)"").Sum(""y""); print(sum.GetValue()); To increase the performance even further, you can also pre-compile a C++ library with full code optimizations and load the function into the RDataFrame computation as follows.; ROOT.gSystem.Load(""path/to/myLibrary.so"") # Library with the myFilter function; ROOT.gInterpreter.Declare('#include ""myLibrary.h""') # Header with the declaration of the myFilter function; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""myFilter(x)"").Sum(""y""); print(sum.GetValue()); A more thorough explanation of how to use C++ code from Python can be found in the PyROOT manual.; Python code; ROOT also offers the option to compile Python functions with fundamental types and arrays thereof using Numba. Such compiled functions can then be used in a C++ expression provided to RDataFrame.; The function to be compiled should be decorated with ROOT.Numba.Declare, which allows to specify the parameter and return types. See the following snippet for a simple example or the full tutorial here.; @ROOT.Numba.Declare([""float""], ""bool""); def myFilter(x):; return x > 10; ; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""Numba::myFilter(x)"").Sum(""y""); print(sum.GetValue()); It also works with collections: RVec objects of fundamental types can be transparently converted to/from numpy arrays:; @ROOT.Numba.Declare(['RVec<float>', 'int'], 'RVec<float>'); def pypowarray(numpyvec, pow):; return numpyvec**pow; ; df.Define('array', 'ROOT::RVecF{1.,2.,3.}')\; .Define('arraySquared', 'Numba::pypowarray(array, 2)'); Note that this functionality requires the Python packages numba and cffi to be installed. Interoperability with NumPy; Conversion to NumPy arrays; Eventually, you probably would like to inspect the content of the RDataFrame or process the data further with Python libraries. For this purpose, we provide the AsNumpy() function, which returns the columns of your RDataFrame as a dictionary of NumPy arrays. See a simple example bel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:81738,simpl,simple,81738,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simple']
Usability,"r() );; 539 std::vector<Double_t> cMax( GetNvar() );; 540 Double_t trueEffS = GetCuts( effS, cMin, cMax );; 541 for (UInt_t ivar=0; ivar<GetNvar(); ivar++) {; 542 cutMin[ivar] = cMin[ivar];; 543 cutMax[ivar] = cMax[ivar];; 544 }; 545 return trueEffS;; 546}; 547 ; 548////////////////////////////////////////////////////////////////////////////////; 549/// retrieve cut values for given signal efficiency; 550 ; 551Double_t TMVA::MethodCuts::GetCuts( Double_t effS,; 552 std::vector<Double_t>& cutMin,; 553 std::vector<Double_t>& cutMax ) const; 554{; 555 // find corresponding bin; 556 Int_t ibin = fEffBvsSLocal->FindBin( effS );; 557 ; 558 // get the true efficiency which is the one on the ""left hand"" side of the bin; 559 Double_t trueEffS = fEffBvsSLocal->GetBinLowEdge( ibin );; 560 ; 561 ibin--; // the 'cut' vector has 0...fNbins indices; 562 if (ibin < 0 ) ibin = 0;; 563 else if (ibin >= fNbins) ibin = fNbins - 1;; 564 ; 565 cutMin.clear();; 566 cutMax.clear();; 567 for (UInt_t ivar=0; ivar<GetNvar(); ivar++) {; 568 cutMin.push_back( fCutMin[ivar][ibin] );; 569 cutMax.push_back( fCutMax[ivar][ibin] );; 570 }; 571 ; 572 return trueEffS;; 573}; 574 ; 575////////////////////////////////////////////////////////////////////////////////; 576/// training method: here the cuts are optimised for the training sample; 577 ; 578void TMVA::MethodCuts::Train( void ); 579{; 580 if (fEffMethod == kUsePDFs) CreateVariablePDFs(); // create PDFs for variables; 581 ; 582 // create binary trees (global member variables) for signal and background; 583 if (fBinaryTreeS != 0) { delete fBinaryTreeS; fBinaryTreeS = 0; }; 584 if (fBinaryTreeB != 0) { delete fBinaryTreeB; fBinaryTreeB = 0; }; 585 ; 586 // the variables may be transformed by a transformation method: to coherently; 587 // treat signal and background one must decide which transformation type shall; 588 // be used: our default is signal-type; 589 ; 590 fBinaryTreeS = new BinarySearchTree();; 591 fBinaryTreeS->Fill( GetEventCollection",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:21284,clear,clear,21284,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['clear'],['clear']
Usability,"r(Int_t mode, Int_t ctyp, Int_t &x, Int_t &y) overrideRequest Locator position.Definition TGX11.cxx:1505; TGX11::OpenDisplayInt_t OpenDisplay(void *display)Open the display. Return -1 if the opening fails, 0 when ok.Definition TGX11.cxx:1091; TGX11::DrawPolyLinevoid DrawPolyLine(Int_t n, TPoint *xy) overrideDraw a line through all points.Definition TGX11.cxx:624; TGX11::RemovePixmapvoid RemovePixmap(Drawable *pix)Remove the pixmap pix.Definition TGX11.cxx:1472; TGX11::SetClipRegionvoid SetClipRegion(Int_t wid, Int_t x, Int_t y, UInt_t w, UInt_t h) overrideSet clipping region for the window wid.Definition TGX11.cxx:2020; TGX11::AddPixmapInt_t AddPixmap(ULong_t pixid, UInt_t w, UInt_t h) overrideRegister pixmap created by gVirtualGL.Definition TGX11.cxx:3645; TGX11::SetRGBvoid SetRGB(Int_t cindex, Float_t r, Float_t g, Float_t b) overrideSet color intensities for given color index.Definition TGX11.cxx:3035; TGX11::FindUsableVisualvoid FindUsableVisual(RXVisualInfo *vlist, Int_t nitems)Check if visual is usable, if so set fVisual, fDepth, fColormap, fBlackPixel and fWhitePixel.Definition TGX11.cxx:848; TGX11::GetCharacterUpvoid GetCharacterUp(Float_t &chupx, Float_t &chupy) overrideReturn character up vector.Definition TGX11.cxx:899; TGX11::SetDoubleBuffervoid SetDoubleBuffer(Int_t wid, Int_t mode) overrideSet the double buffer on/off on window wid.Definition TGX11.cxx:2091; TGX11::fMaxNumberOfWindowsInt_t fMaxNumberOfWindowsMaximum number of windows.Definition TGX11.h:83; TGX11::SetMarkerStylevoid SetMarkerStyle(Style_t markerstyle) overrideSet marker style.Definition TGX11.cxx:2435; TGX11::GetRGBvoid GetRGB(Int_t index, Float_t &r, Float_t &g, Float_t &b) overrideGet rgb values for color ""index"".Definition TGX11.cxx:1027; TGX11::ImgPickPalettevoid ImgPickPalette(RXImage *image, Int_t &ncol, Int_t *&R, Int_t *&G, Int_t *&B)Returns in R G B the ncol colors of the palette used by the image.Definition TGX11.cxx:3331; TGX11::FindColorInt_t FindColor(ULong_t pixel, ULong_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:154718,usab,usable,154718,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['usab'],['usable']
Usability,"r(j);; 1175 TCpu<>::Copy(layer.GetWeights(),; 1176 masterLayer.GetWeights());; 1177 TCpu<>::Copy(layer.GetBiases(),; 1178 masterLayer.GetBiases());; 1179 }; 1180 }; 1181 ; 1182 bool converged = false;; 1183 size_t stepCount = 0;; 1184 size_t batchesInEpoch = nTrainingSamples / net.GetBatchSize();; 1185 ; 1186 std::chrono::time_point<std::chrono::system_clock> start, end;; 1187 start = std::chrono::system_clock::now();; 1188 ; 1189 if (!fInteractive) {; 1190 Log() << std::setw(10) << ""Epoch"" << "" | ""; 1191 << std::setw(12) << ""Train Err.""; 1192 << std::setw(12) << ""Test Err.""; 1193 << std::setw(12) << ""GFLOP/s""; 1194 << std::setw(12) << ""Conv. Steps"" << Endl;; 1195 std::string separator(62, '-');; 1196 Log() << separator << Endl;; 1197 }; 1198 ; 1199 while (!converged); 1200 {; 1201 stepCount++;; 1202 // Perform minimization steps for a full epoch.; 1203 trainingData.Shuffle();; 1204 for (size_t i = 0; i < batchesInEpoch; i += nThreads) {; 1205 batches.clear();; 1206 for (size_t j = 0; j < nThreads; j++) {; 1207 batches.reserve(nThreads);; 1208 batches.push_back(trainingData.GetBatch());; 1209 }; 1210 if (settings.momentum > 0.0) {; 1211 minimizer.StepMomentum(net, nets, batches, settings.momentum);; 1212 } else {; 1213 minimizer.Step(net, nets, batches);; 1214 }; 1215 }; 1216 ; 1217 if ((stepCount % minimizer.GetTestInterval()) == 0) {; 1218 ; 1219 // Compute test error.; 1220 Double_t testError = 0.0;; 1221 for (auto batch : testData) {; 1222 auto inputMatrix = batch.GetInput();; 1223 auto outputMatrix = batch.GetOutput();; 1224 auto weightMatrix = batch.GetWeights();; 1225 testError += testNet.Loss(inputMatrix, outputMatrix, weightMatrix);; 1226 }; 1227 testError /= (Double_t) (nTestSamples / settings.batchSize);; 1228 ; 1229 //Log the loss value; 1230 fTrainHistory.AddValue(""testError"",stepCount,testError);; 1231 ; 1232 end = std::chrono::system_clock::now();; 1233 ; 1234 // Compute training error.; 1235 Double_t trainingError = 0.0;; 1236 for (auto batch : traini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:43452,clear,clear,43452,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['clear'],['clear']
Usability,"r* leaflist, Int_t bufsize); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidTTree::Browse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeSQL.html:2467,undo,undo,2467,root/html528/TTreeSQL.html,https://root.cern,https://root.cern/root/html528/TTreeSQL.html,4,['undo'],['undo']
Usability,"r* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfAlternatePValuep-value for the alternate hypothesis (small number means disfavored); TStringTNamed::fNameobject identifier; Double_tfNullPValuep-value for the null hypothesis (small number means disfavored); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HypoTestResult(const char* name); Default constructor. HypoTestResult(const char* name, Double_t nullp, Double_t altp); Alternate constructor. ~HypoTestResult(); Destructor. explicit HypoTestResult(const char* name = 0); default constructor. Double_t NullPValue() const; Return p-value for null hypothesis. {return fNullPValue;}. Double_t AlternatePValue() const; Return p-value for alternate hypothesis. {return fAlternatePValue;}. Double_t CLb() const; Convert NullPValue into a ""confidence level"". {return 1.-NullPValue();}. Double_t CLsplusb() const; Convert AlternatePValue into a ""confidence level"". {return AlternatePValue();}. Double_t CLs() const; CLs is simply CLs+b/CLb (not a method, but a quantity). Double_t Significance() const; familiar name for the Null p-value in terms of 1-sided Gaussian significance. {return RooStats::PValueToSignificance( NullPValue() ); }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: HypoTestResult.h 31276 2009-11-18 15:06:42Z moneta $ » Last generated: 2009-12-07 13:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HypoTestResult.html:7359,simpl,simply,7359,root/html526/RooStats__HypoTestResult.html,https://root.cern,https://root.cern/root/html526/RooStats__HypoTestResult.html,1,['simpl'],['simply']
Usability,"r* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operastor. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TToggleGroup.h 26606 2008-12-02 20:36:09Z pcanal $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TToggleGroup.html:6565,clear,clears,6565,root/html528/TToggleGroup.html,https://root.cern,https://root.cern/root/html528/TToggleGroup.html,1,['clear'],['clears']
Usability,"r* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operastor. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TToggleGroup.h 26606 2008-12-02 20:36:09Z pcanal $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TToggleGroup.html:6634,clear,clears,6634,root/html530/TToggleGroup.html,https://root.cern,https://root.cern/root/html530/TToggleGroup.html,1,['clear'],['clears']
Usability,"r* name) const; const RooRealVar&basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooResolutionModel.html:4385,clear,clearShapeDirty,4385,root/html528/RooResolutionModel.html,https://root.cern,https://root.cern/root/html528/RooResolutionModel.html,1,['clear'],['clearShapeDirty']
Usability,"r* name) const; const RooRealVar&basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooResolutionModel.html:4385,clear,clearShapeDirty,4385,root/html530/RooResolutionModel.html,https://root.cern,https://root.cern/root/html530/RooResolutionModel.html,1,['clear'],['clearShapeDirty']
Usability,"r*gPad->GetLeftMargin(),; 1064 ymin - dyr*gPad->GetBottomMargin(),; 1065 xmax + dxr*gPad->GetRightMargin(),; 1066 ymax + dyr*gPad->GetTopMargin());; 1067 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 1068 }; 1069 if (middle) {; 1070 for(i=0;i<theNpoints;i++) {; 1071 if (badcase) continue; //do not update if big zoom and points moved; 1072 if (!x.empty()) theX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 1073 if (!y.empty()) theY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 1074 }; 1075 } else {; 1076 theX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 1077 theY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 1078 if (theGraph->InheritsFrom(""TCutG"")) {; 1079 //make sure first and last point are the same; 1080 if (ipoint == 0) {; 1081 theX[theNpoints-1] = theX[0];; 1082 theY[theNpoints-1] = theY[0];; 1083 }; 1084 if (ipoint == theNpoints-1) {; 1085 theX[0] = theX[theNpoints-1];; 1086 theY[0] = theY[theNpoints-1];; 1087 }; 1088 }; 1089 }; 1090 badcase = kFALSE;; 1091 x.clear();; 1092 y.clear();; 1093 gPad->Modified(kTRUE);; 1094 gVirtualX->SetLineColor(-1);; 1095 }; 1096}; 1097 ; 1098 ; 1099////////////////////////////////////////////////////////////////////////////////; 1100 ; 1101char *TGraphPainter::GetObjectInfoHelper(TGraph * /*theGraph*/, Int_t /*px*/, Int_t /*py*/) const; 1102{; 1103 return (char*)"""";; 1104}; 1105 ; 1106 ; 1107////////////////////////////////////////////////////////////////////////////////; 1108/// Return the highlighted point for theGraph; 1109 ; 1110Int_t TGraphPainter::GetHighlightPoint(TGraph *theGraph) const; 1111{; 1112 if (theGraph == gHighlightGraph) return gHighlightPoint;; 1113 else return -1;; 1114}; 1115 ; 1116 ; 1117////////////////////////////////////////////////////////////////////////////////; 1118/// Set highlight (enable/disable) mode for theGraph; 1119 ; 1120void TGraphPainter::SetHighlight(TGraph *theGraph); 1121{; 1122 gHighlightPoint = -1; // must be -1; 1123 gHighlightGraph = nullptr;; 1124 if (theGraph->IsHighli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:40088,clear,clear,40088,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"r-defined function on each entry. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. . ForeachSlot() Same as Foreach(), but the user-defined function must take an extra unsigned int slot as its first parameter. slot will take a different value, 0 to nThreads - 1, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case slot will always be 0. . Snapshot() Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made lazy setting the appropriate flag in the snapshot options. . Queries; These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object. Operation Description . Describe() Get useful information describing the dataframe, e.g. columns and their types. . GetColumnNames() Get the names of all the available columns of the dataset. . GetColumnType() Return the type of a given column as a string. . GetColumnTypeNamesList() Return the list of type names of columns in the dataset. . GetDefinedColumnNames() Get the names of all the defined columns. . GetFilterNames() Return the names of all filters in the computation graph. . GetNRuns() Return the number of event loops run by this RDataFrame instance so far. . GetNSlots() Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). . SaveGraph() Store the computation graph of an RDataFrame in DOT format (graphviz) for easy inspection. See the relevant section for details. . Introduction; Users define their analysis as a sequence of operations to be performed on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:8964,simpl,simply,8964,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simply']
Usability,"r. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. Int_t DefinedVariable(TString& variable, Int_t& action); Check if expression is in the list of defined variables. This member function can be overloaded in derived classes. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the action parameter. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula. The current value of variables x,y,z,t is passed through x, y, z and t.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula. The current value of variables x,y,z,t is passed through the pointer x.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. /*; ; */. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from the internal TFormula member variables. This function uses the internal member variables of TFormula to; construct the mathematical expression associated with t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFormula.html:23205,usab,usable,23205,root/html534/TFormula.html,https://root.cern,https://root.cern/root/html534/TFormula.html,3,['usab'],['usable']
Usability,"r. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void Le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:26697,learn,learning,26697,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['learn'],['learning']
Usability,"r.; #ifdef __ROOTCLING__. #pragma link off all globals;; #pragma link off all classes;; #pragma link off all functions;; #pragma link C++ class EventHeader+;; #pragma link C++ class Event-;; #pragma link C++ class HistogramManager+;; #pragma link C++ class Track+;. #endif; #pragma link C++ class EventHeader+;; The “+” sign tells rootcling to use the new Streamersystem introduced in ROOT 3.0. The following is an example of a customized Streamerfor Event. The Streamer takes a TBuffer as a parameter, and first checks to see if this is a case of reading or writing the buffer.; void Event::Streamer(TBuffer &R__b) {; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; fTransient = gDirectory; //save current directory; fPt= TMath::Sqrt(fPx*fPx + fPy*fPy + fPz*fPz);; } else {; Event::Class()->WriteBuffer(R__b, this);; }; }; 11.3.8 Writing Objects; The Streamer decomposes the objects into data members and writes them to a buffer. It does not write the buffer to a file, it simply populates a buffer with bytes representing the object. This allows us to write the buffer to a file or do anything else we could do with the buffer. For example, we can write it to a socket to send it over the network. This is beyond the scope of this chapter, but it is worthwhile to emphasize the need and advantage of separating the creation of the buffer from its use. Let us look how a buffer is written to a file. The dictionary for a class needs to be loaded before any object of that type can be saved.; The TObject::Write method does the following:. Creates a TKey object in the current directory; Creates a TBuffer object which is part of the newly created TKey; Fills the TBuffer with a call to the class::Streamer method; Creates a second buffer for compression, if needed; Reserves space by scanning the TFree list. At this point, the size of the buffer is known.; Writes the buffer to the file; Releases the TBuffer part of the key. In other words, the TObject::Write calls the Streamer m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:474393,simpl,simply,474393,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simply']
Usability,"r.cxx. ◆ DoRotatorStop(). void TGLViewerEditor::DoRotatorStop ; (; ). Stop auto-rotator. ; Definition at line 822 of file TGLViewerEditor.cxx. ◆ DoUpdateScene(). void TGLViewerEditor::DoUpdateScene ; (; ). UpdateScene was clicked. ; Definition at line 294 of file TGLViewerEditor.cxx. ◆ IsA(). TClass * TGLViewerEditor::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGCompositeFrame.; Definition at line 164 of file TGLViewerEditor.h. ◆ MakeLabeledNEntry(). TGNumberEntry * TGLViewerEditor::MakeLabeledNEntry ; (; TGCompositeFrame * ; p, . const char * ; name, . Int_t ; labelw, . Int_t ; nd = 7, . Int_t ; s = 5 . ). static . Helper function to create fixed width TGLabel and TGNumberEntry in same row. ; Definition at line 437 of file TGLViewerEditor.cxx. ◆ operator=(). TGLViewerEditor & TGLViewerEditor::operator= ; (; const TGLViewerEditor & ; ). private . ◆ SetGuides(). void TGLViewerEditor::SetGuides ; (; ). Configuration of guides GUI called from SetModel(). ; Definition at line 706 of file TGLViewerEditor.cxx. ◆ SetModel(). void TGLViewerEditor::SetModel ; (; TObject * ; obj). overridevirtual . Sets model or disables/hides viewer. ; Implements TGedFrame.; Definition at line 182 of file TGLViewerEditor.cxx. ◆ SetRotatorMode(). void TGLViewerEditor::SetRotatorMode ; (; ). Definition at line 760 of file TGLViewerEditor.cxx. ◆ Streamer(). void TGLViewerEditor::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGCompositeFrame. ◆ StreamerNVirtual(). void TGLViewerEditor::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 164 of file TGLViewerEditor.h. ◆ UpdateCameraCenter(). void TGLViewerEditor::UpdateCameraCenter ; (; ). Update current camera with GUI state. ; Definition at line 387 of file TGLViewerEditor.cxx. ◆ UpdateMaxDrawTimes(). void TGLViewerEditor::UpdateMaxDrawTimes ; (; ). Slot for fMaxSceneDrawTimeHQ and fMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewerEditor.html:42103,guid,guides,42103,doc/master/classTGLViewerEditor.html,https://root.cern,https://root.cern/doc/master/classTGLViewerEditor.html,1,['guid'],['guides']
Usability,"r2->AddNode(pvol, 1);; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; Note that the third parameter of PVOL is negative, which does not make sense as half-length on Z. This is interpreted as: when positioned, create a box replacing all invalid parameters with the corresponding dimensions of the container. This is also internally handled by the TGeoVolumeMulti class, which does not need to be instantiated by users. Dividing volumes; Volumes can be divided according a pattern. The most simple division can be done along one axis, that can be: X, Y, Z, Phi, Rxy or Rxyz. Let's take the most simple case: we would like to divide a box in N equal slices along X coordinate, representing a new volume family. Supposing we already have created the initial box, this can be done like:; TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N);; N#define N; TGeoVolume::Dividevirtual TGeoVolume * Divide(const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""")Division a la G3.Definition TGeoVolume.cxx:1103; where SLICE is the name of the new family representing all slices and 1 is the slicing axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi. In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeMulti.html:4517,simpl,simple,4517,doc/master/classTGeoVolumeMulti.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeMulti.html,1,['simpl'],['simple']
Usability,"r::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooChangeTracker::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 49 of file RooChangeTracker.h. ◆ clone(). TObject * RooChangeTracker::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 30 of file RooChangeTracker.h. ◆ DeclFileName(). static const char * RooChangeTracker::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 49 of file RooChangeTracker.h. ◆ evaluate(). double RooChangeTracker::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 47 of file RooChangeTracker.h. ◆ hasChanged(). bool RooChangeTracker::hasChanged ; (; bool ; clearState). Returns true if state has changed since last call with clearState=true. ; If clearState is true, changeState flag will be cleared. ; Definition at line 104 of file RooChangeTracker.cxx. ◆ IsA(). TClass * RooChangeTracker::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 49 of file RooChangeTracker.h. ◆ parameters(). RooArgSet RooChangeTracker::parameters ; (; ); const. Definition at line 188 of file RooChangeTracker.cxx. ◆ Streamer(). void RooChangeTracker::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooChangeTracker::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 49 of file RooChangeTracker.h. Member Data Documentation. ◆ _catRef. std::vector<Int_t> RooChangeTracker::_catRef. protected . Reference values for categories. ; Definition at line 42 of file RooChangeTracker.h. ◆ _catSet. RooList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChangeTracker.html:62796,clear,clearState,62796,doc/master/classRooChangeTracker.html,https://root.cern,https://root.cern/doc/master/classRooChangeTracker.html,1,['clear'],['clearState']
Usability,"r; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:47646,clear,clearCacheObject,47646,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,2,['clear'],['clearCacheObject']
Usability,"r;  CMinimumParameters;  CMinimumSeedMinimumSeed contains the starting values for the minimization produced by the SeedGenerator ;  CMinimumSeedGeneratorBase class for seed generators (starting values); the seed generator prepares initial starting values from the input (MnUserParameterState) for the minimization; ;  CMinimumStateMinimumState keeps the information (position, Gradient, 2nd deriv, etc) after one minimization step (usually in MinimumBuilder) ;  CMinosErrorClass holding the result of Minos (lower and upper values) for a specific parameter ;  CMinuit2MinimizerMinuit2Minimizer class implementing the ROOT::Math::Minimizer interface for Minuit2 minimization algorithm ;  CMinuitParameterClass for the individual Minuit Parameter with Name and number; contains the input numbers for the minimization or the output result from minimization; possible interactions: Fix/release, set/remove limits, set Value/error; ;  CMnApplicationApplication interface class for minimizers (migrad, simplex, Minimize, Scan) User normally instantiates the derived class like ROOT::Minuit2::MnMigrad for using Migrad for minimization ;  CMnContoursAPI class for Contours Error analysis (2-dim errors); minimization has to be done before and Minimum must be valid; possibility to ask only for the points or the points and associated Minos errors; ;  CMnCovarianceSqueezeClass to reduce the covariance matrix when a parameter is fixed by removing the corresponding row and index ;  ►CMnCross;  CCrossFcnLimit;  CCrossNewMin;  CCrossParLimit;  CMnEigenAPI class for calculating the eigenvalues of symmetric matrix ;  CMnFcnWrapper class to FCNBase interface used internally by Minuit ;  CMnFumiliMinimizeAPI class for minimization using Fumili technology; allows for user interaction: set/change parameters, do minimization, change parameters, re-do minimization etc ;  CMnFunctionCrossMnFunctionCross ;  CMnGlobalCorrelationCoeffClass for global correlation coefficient ;  CMnHesseAPI class for calculating ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:58926,simpl,simplex,58926,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,7,['simpl'],['simplex']
Usability,"r<ROOT::RWebDisplayHandle> > TWebCanvas::fHelpHandles. protected . ! array of handles for help widgets ; Definition at line 117 of file TWebCanvas.h. ◆ fJsonComp. Int_t TWebCanvas::fJsonComp {0}. protected . ! compression factor for messages send to the client ; Definition at line 98 of file TWebCanvas.h. ◆ fLongerPolling. Bool_t TWebCanvas::fLongerPolling {kFALSE}. protected . ! when true, make longer polling in blocking operations ; Definition at line 100 of file TWebCanvas.h. ◆ fObjSelectSignal. ObjectSelectSignal_t TWebCanvas::fObjSelectSignal. protected . ! signal emitted when new object selected in the pad ; Definition at line 115 of file TWebCanvas.h. ◆ fPadClickedSignal. PadClickedSignal_t TWebCanvas::fPadClickedSignal. protected . ! signal emitted when simple mouse click performed on the pad ; Definition at line 113 of file TWebCanvas.h. ◆ fPadDblClickedSignal. PadClickedSignal_t TWebCanvas::fPadDblClickedSignal. protected . ! signal emitted when simple mouse click performed on the pad ; Definition at line 114 of file TWebCanvas.h. ◆ fPadsStatus. std::map<TPad*, PadStatus> TWebCanvas::fPadsStatus. protected . ! map of pads in canvas and their status flags ; Definition at line 86 of file TWebCanvas.h. ◆ fPaletteDelivery. Int_t TWebCanvas::fPaletteDelivery {1}. protected . ! colors palette delivery 0:never, 1:once, 2:always, 3:per subpad ; Definition at line 96 of file TWebCanvas.h. ◆ fPrimitivesMerge. Int_t TWebCanvas::fPrimitivesMerge {100}. protected . ! number of PS primitives, which will be merged together ; Definition at line 97 of file TWebCanvas.h. ◆ fProcessingData. Bool_t TWebCanvas::fProcessingData {kFALSE}. protected . ! flag used to prevent blocking methods when process data is invoked ; Definition at line 101 of file TWebCanvas.h. ◆ fReadOnly. Bool_t TWebCanvas::fReadOnly {kFALSE}. protected . !< configured display ; ! in read-only mode canvas cannot be changed from client side ; Definition at line 90 of file TWebCanvas.h. ◆ fStyleDelivery. Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:42585,simpl,simple,42585,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['simpl'],['simple']
Usability,"rAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. Double_t EvalInstance(Int_t i = 0, const char** stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:22474,simpl,simple,22474,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,3,['simpl'],['simple']
Usability,"rAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char** stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeFormula.html:22792,simpl,simple,22792,root/html534/TTreeFormula.html,https://root.cern,https://root.cern/root/html534/TTreeFormula.html,1,['simpl'],['simple']
Usability,"rAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeFormula.html:28042,simpl,simple,28042,root/html602/TTreeFormula.html,https://root.cern,https://root.cern/root/html602/TTreeFormula.html,2,['simpl'],['simple']
Usability,"rColor () const;  ; EBarType GetBarType () const;  ; EFillType GetFillType () const;  ; FontStruct_t GetFontStruct () const;  ; TString GetFormat () const;  ; Float_t GetMax () const;  ; Float_t GetMin () const;  ; GContext_t GetNormGC () const;  ; Float_t GetPosition () const;  ; Bool_t GetShowPos () const;  ; const char * GetValueFormat () const;  ; void Increment (Float_t inc);  Increment progress position. ;  ; virtual void Reset ();  Reset progress bar (i.e. set pos to 0). ;  ; void SetBarColor (const char *color=""blue"");  Set progress bar color. ;  ; virtual void SetBarColor (Pixel_t color);  Set progress bar color. ;  ; void SetBarType (EBarType type);  Set bar type. ;  ; void SetFillType (EFillType type);  Set fill type. ;  ; void SetForegroundColor (Pixel_t pixel) override;  Change text color drawing. ;  ; void SetMax (Float_t max);  ; void SetMin (Float_t min);  ; void SetPosition (Float_t pos);  Set progress position between [min,max]. ;  ; void SetRange (Float_t min, Float_t max);  Set min and max of progress bar. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t UsePercent () const;  ;  Public Member Functions inherited from TGFrame;  TGFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=0, Pixel_t back=GetDefaultFrameBackground());  Create a TGFrame object. Options is an OR of the EFrameTypes. ;  ;  TGFrame (TGClient *c, Window_t id, const TGWindow *parent=nullptr);  Create a frame using an externally created window. ;  ;  ~TGFrame () override;  Destructor. ;  ; virtual void Activate (Bool_t);  ; void AddInput (UInt_t emask);  Add events specified in the emask to the events the frame should handle. ;  ; virtual void ChangeBackground (Pixel_t back);  Change frame background color. ;  ; virtual void ChangeOptions (UInt_t options);  Change frame options. Options is an OR of the EFrameTypes. ;  ; Bool_t Contains (Int_t x, Int_t y) const;  ; void Delete (Option_t *="""") override;  Delete this object. ;  ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGVProgressBar.html:2982,progress bar,progress bar,2982,doc/master/classTGVProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGVProgressBar.html,1,['progress bar'],['progress bar']
Usability,"rEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1113 of file TUnfoldSys.cxx. ◆ GetEmatrixSysTau(). void TUnfoldSys::GetEmatrixSysTau ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from error on regularisation parameter ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the assigned uncertainty on the parameter tau, see method SetTauError(). ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1176 of file TUnfoldSys.cxx. ◆ GetEmatrixSysUncorr(). void TUnfoldSys::GetEmatrixSysUncorr ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). Covariance contribution from uncorrelated uncertainties of the response matrix. ; Parameters. [in,out]ematrixcovariance matrix histogram ; [in]binMapmapping of histogram bins ; [in]clearEmatif true, ematrix is cleared prior to adding this covariance matrix contribution. This method propagates the uncertainties of the response matrix histogram, specified with the constructor, to the unfolding result. It is assumed that the entries of that histogram are bin-to-bin uncorrelated. In many cases this corresponds to the ""Monte Carlo statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 760 of file TUnfoldSys.cxx. ◆ GetEmatrixTotal(). void TUnfoldSys::GetEmatrixTotal ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr . ). Get total error matrix, summing up all contributions. ; Parameters. [out]ematrixhistogram which will be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:41800,clear,clearEmat,41800,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,"rEntry; TGNumberEntryLayout Layout manager for number entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectBox TreeView dialog widget; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider widget abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used internally by TGTable.; TGTabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:84178,simpl,simple,84178,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,1,['simpl'],['simple']
Usability,rLowPtr = nullptr;; 672 ; 673 fDataError.clear();; 674 fDataErrorPtr = nullptr;; 675 ; 676 return;; 677 }; 678 ; 679 if ( kCoordError == fErrorType || kAsymError == fErrorType ); 680 {; 681 fCoordErrorsPtr.resize( fDim );; 682 fCoordErrors.resize( fDim );; 683 for( unsigned int i=0; i < fDim; i++ ); 684 {; 685 fCoordErrors[i].resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 686 ; 687 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 688 }; 689 ; 690 fpTmpCoordErrorVector = new double[fDim];; 691 }; 692 else; 693 {; 694 fCoordErrors.clear();; 695 fCoordErrorsPtr.clear();; 696 }; 697 ; 698 if ( kValueError == fErrorType || kCoordError == fErrorType ); 699 {; 700 fDataError.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 701 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 702 ; 703 fDataErrorHigh.clear();; 704 fDataErrorHighPtr = nullptr;; 705 fDataErrorLow.clear();; 706 fDataErrorLowPtr = nullptr;; 707 }; 708 else if ( fErrorType == kAsymError ); 709 {; 710 fDataErrorHigh.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 711 fDataErrorHighPtr = fDataErrorHigh.empty() ? nullptr : &fDataErrorHigh.front();; 712 ; 713 fDataErrorLow.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 714 fDataErrorLowPtr = fDataErrorLow.empty() ? nullptr : &fDataErrorLow.front();; 715 ; 716 fDataError.clear();; 717 fDataErrorPtr = nullptr;; 718 }; 719 else; 720 {; 721 assert(false);; 722 }; 723 }; 724 ; 725 void BinData::InitBinEdge(); 726 {; 727 fBinEdge.resize( fDim );; 728 ; 729 for( unsigned int i=0; i<fDim; i++ ); 730 {; 731 fBinEdge[i].reserve(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 732 }; 733 ; 734 if ( fpTmpBinEdgeVector ); 735 {; 736 delete[] fpTmpBinEdgeVector;; 737 fpTmpBinEdgeVector = nullptr;; 738 }; 739 ; 740 fpTmpBinEdgeVector = new double[ fDim ];; 741 }; 742 ; 743 void BinData::UnWrap( ); 744 {; 745 assert( fWrapped );; 746 assert( kValueError == fErrorType || kCoordError == ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:21528,clear,clear,21528,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"r_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableBlending); Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y). void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawText(Double_t x, Double_t y, const wchar_t* text, TVirtualPadPainter::ETextMode mode); That's a special version working with wchar_t and required by TMathText (who uses utf-8(?)). void DrawTextNDC(Double_t u, Double_t v, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPadPainter.html:5896,simpl,simple,5896,root/html534/TPadPainter.html,https://root.cern,https://root.cern/root/html534/TPadPainter.html,1,['simpl'],['simple']
Usability,"r_t, DeepNet_t>>(; 1358 new DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>(settings.learningRate, deepNet, settings.momentum));; 1359 break;; 1360 ; 1361 case EOptimizer::kAdam: {; 1362 optimizer = std::unique_ptr<DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>>(; 1363 new DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>(; 1364 deepNet, settings.learningRate, settings.optimizerParams[""ADAM_beta1""],; 1365 settings.optimizerParams[""ADAM_beta2""], settings.optimizerParams[""ADAM_eps""]));; 1366 break;; 1367 }; 1368 ; 1369 case EOptimizer::kAdagrad:; 1370 optimizer = std::unique_ptr<DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>>(; 1371 new DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1372 settings.optimizerParams[""ADAGRAD_eps""]));; 1373 break;; 1374 ; 1375 case EOptimizer::kRMSProp:; 1376 optimizer = std::unique_ptr<DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>>(; 1377 new DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate, settings.momentum,; 1378 settings.optimizerParams[""RMSPROP_rho""],; 1379 settings.optimizerParams[""RMSPROP_eps""]));; 1380 break;; 1381 ; 1382 case EOptimizer::kAdadelta:; 1383 optimizer = std::unique_ptr<DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>>(; 1384 new DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1385 settings.optimizerParams[""ADADELTA_rho""],; 1386 settings.optimizerParams[""ADADELTA_eps""]));; 1387 break;; 1388 }; 1389 ; 1390 ; 1391 // Initialize the vector of batches, one batch for one slave network; 1392 std::vector<TTensorBatch<Architecture_t>> batches{};; 1393 ; 1394 bool converged = false;; 1395 size_t convergenceCount = 0;; 1396 size_t batchesInEpoch = nTrainingSamples / deepNet.GetBatchSize();; 1397 ; 1398 // start measuring; 1399 std::chrono::time_point<std::chrono::system_clock> tstart, tend;; 1400 tstart = std::chrono::system_clock::now();; 1401 ; 1402 // function building string with optimizer parameters values for logging",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:54655,learn,learningRate,54655,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['learn'],['learningRate']
Usability,"raining dataset.; Those events will be used for the minimization.; Note that the tree must be already defined. void SetTestDataSet(const char* test); Sets the Test dataset.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:24112,learn,learning,24112,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,6,['learn'],['learning']
Usability,"ram for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  box.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 boxes in it (RBox) ;  concurrentfill.cxx;  draw.cxx;  draw_mt.cxxThis macro demonstrate usage of ROOT7 graphics from many threads Three different canvases in three different threads are started and regularly updated ;  draw_rh1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_subpads.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 lines in it (RLine) ;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  vo004_SortAndSelect.C In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo004_SortAndSelect.py In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo005_Combinations.C In this tutorial we learn how combinations of RVecs can be build ;  vo005_Combinations.py In this tutorial we learn how combinations of RVecs can be build ;  vo006_IndexManipulation.C In this tutor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:172005,simpl,simple,172005,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"ram.frame(100,-10,10) ; mcstudy.paramOn(frame,LineStyle(kDashed)) ;; Any named arguments passed to plotParamOn() are forwarded to the underlying plotOn() call. PyROOT; The RooMCStudy::plotParamOn() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArg of the function. . Definition at line 884 of file RooMCStudy.cxx. ◆ plotPull() [1/2]. RooMCStudy::plotPull ; (; const RooRealVar & ; param, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). Plot the distribution of pull values for the specified parameter on a newly created frame. ; If asymmetric errors are calculated in the fit (by MINOS) those will be used in the pull calculation.; If the parameters of the models for generation and fit differ, simple heuristics are used to find the corresponding parameters:; Parameters have the same name: They will be used to compute pulls.; Parameters have different names: The position of the fit parameter in the set of fit parameters will be computed. The parameter at the same position in the set of generator parameters will be used. Further options: . Arguments Effect . FrameRange(double lo, double hi) Set range of frame to given specification . FrameBins(int bins) Set default number of bins of frame to given number . Frame() Pass supplied named arguments to RooAbsRealLValue::frame() function. See there for list of allowed arguments . FitGauss(bool flag) Add a gaussian fit to the frame . If no frame specifications are given, the AutoSymRange() feature will be used to set a default range. Any other named argument is passed to the RooAbsData::plotOn(). See that function for allowed options.; If you want to have more control over the Gaussian fit to the pull distribution, you can also do it after the call to plotPull():; Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMCStudy.html:35805,simpl,simple,35805,doc/master/classRooMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooMCStudy.html,1,['simpl'],['simple']
Usability,"rame(TEveFrameBox *b)Set TEveFrameBox pointer.Definition TEveDigitSet.cxx:423; TEveFrameBoxDescription of a 2D or 3D frame that can be used to visually group a set of objects.Definition TEveFrameBox.h:19; A single TEveFrameBox can be shared among several digit-sets (it is reference-counted). The following flags affect how the frame-box will drawn and used for selection and highlight: Bool_t fSelectViaFrame;; Bool_t fHighlightFrame;; TEveDigitSet::fHighlightFrameBool_t fHighlightFrameDefinition TEveDigitSet.h:74; TEveDigitSet::fSelectViaFrameBool_t fSelectViaFrameDefinition TEveDigitSet.h:73; bool; TEveDigitSet is sub-classed from TEveSecondarySelectable – this means individual digits can be selected. By calling: TEveSecondarySelectable::SetAlwaysSecSelect(kTRUE);; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TEveSecondarySelectable::SetAlwaysSecSelectvoid SetAlwaysSecSelect(Bool_t f)Definition TEveSecondarySelectable.h:47; one can enforce immediate feedback (highlight, tooltip and select on normal left-mouse click) on given digit-set.; See also: TEveQuadSet: rectangle, hexagon or line per digit; TEveBoxSet a 3D box per digit; a#define a(i)Definition RSha256.hxx:99; TEveBoxSetCollection of 3D primitives (fixed-size boxes, boxes of different sizes, or arbitrary sexto-epipeds,...Definition TEveBoxSet.h:22; TEveQuadSetSupports various internal formats that result in rendering of a set of planar (lines,...Definition TEveQuadSet.h:20; lineTLine * lineDefinition entrylistblock_figure1.C:235; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1. Definition at line 29 of file TEveDigitSet.h. Classes; struct  DigitBase_t;  . Public Types; typedef void(* Callback_foo) (TEveDigitSet *, Int_t, TObject *);  ; enum  ERenderMode_e { kRM_AsIs; , kRM_Line; , kRM_Fill; };  ; typedef TString(* TooltipCB_foo) (TEveDigitSet *, Int_t);  ;  Public Types inherited from TEveElement; enum  EChangeBits { kCBColorSelection = (1ULL << ( 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveDigitSet.html:3026,feedback,feedback,3026,doc/master/classTEveDigitSet.html,https://root.cern,https://root.cern/doc/master/classTEveDigitSet.html,1,['feedback'],['feedback']
Usability,"rame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTorusEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for torus editor. ~TGeoTorusEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoR(); Slot for R. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi. void DoDphi(); Slot for Dphi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTorusEditor.html:21434,undo,undoing,21434,root/html534/TGeoTorusEditor.html,https://root.cern,https://root.cern/root/html534/TGeoTorusEditor.html,1,['undo'],['undoing']
Usability,"rame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHProgressBar.html:21659,progress bar,progress bar,21659,root/html602/TGHProgressBar.html,https://root.cern,https://root.cern/root/html602/TGHProgressBar.html,2,['progress bar'],['progress bar']
Usability,"rame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTVLVEntry(const TGWindow* p, const TGPicture* bigpic, const TGPicture* smallpic, TGString* name, TGString** subnames, EListViewMode ViewMode); TGTreeLVEntry constructor. ~TTVLVEntry(); TGTreeLVEntry destructor. const char * ConvertAliases(); Convert all aliases into true names. Bool_t FullConverted(); Return true if converted name is alias free. void CopyItem(TTVLVEntry* dest); Copy this item's name and alias to an other. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HasAlias(); Check if alias name is not empty. void PrependTilde(); Prepend a ~ to item alias. void SetItemName(const char* name); redraw this entry with new name. void SetCutType(Bool_t type = kFALSE); Set cut type. void SetExpression(const char* name, const char* alias, Bool_t cutType = kFALSE); Set the true name, alias and type of the expression, then refresh it. void Empty(); clear all names and alias. void SetToolTipText(const char* text, Long_t delayms = 1000); Set tool tip text associated with this item. The delay is in; milliseconds (minimum 250). To remove tool tip call method with text = 0. void SetSmallPic(const TGPicture* spic); Set small picture. const char * GetAlias(); {return fAlias.Data();}. TTVLVContainer * GetContainer(); {return fContainer;}. TGItemContext * GetContext(); {return fContext;}. const char * GetConvName(); {return fConvName;}. const char * GetTrueName(); {return fTrueName.Data();}. TGToolTip * GetTip(); {return fTip;}. Bool_t IsCut(); {return fIsCut;}. void SetAlias(const char* alias); {fAlias = alias;}. void SetTrueName(const char* name); {fTrueName = name;}. » Last changed: root/treeviewer:$Id: TTVLVContainer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTVLVEntry.html:20654,clear,clear,20654,root/html530/TTVLVEntry.html,https://root.cern,https://root.cern/root/html530/TTVLVEntry.html,1,['clear'],['clear']
Usability,"rame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTVLVEntry(const TGWindow* p, const TGPicture* bigpic, const TGPicture* smallpic, TGString* name, TGString** subnames, EListViewMode ViewMode); TGTreeLVEntry constructor. ~TTVLVEntry(); TGTreeLVEntry destructor. const char * ConvertAliases(); Convert all aliases into true names. Bool_t FullConverted(); Return true if converted name is alias free. void CopyItem(TTVLVEntry* dest); Copy this item's name and alias to an other. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HasAlias(); Check if alias name is not empty. void PrependTilde(); Prepend a ~ to item alias. void SetItemName(const char* name); redraw this entry with new name. void SetCutType(Bool_t type = kFALSE); Set cut type. void SetExpression(const char* name, const char* alias, Bool_t cutType = kFALSE); Set the true name, alias and type of the expression, then refresh it. void Empty(); clear all names and alias. void SetToolTipText(const char* text, Long_t delayms = 1000); Set tool tip text associated with this item. The delay is in; milliseconds (minimum 250). To remove tool tip call method with text = 0. void SetSmallPic(const TGPicture* spic); Set small picture. const char * GetAlias(); {return fAlias.Data();}. TTVLVContainer * GetContainer(); {return fContainer;}. TGItemContext * GetContext(); {return fContext;}. const char * GetConvName(); {return fConvName;}. const char * GetTrueName(); {return fTrueName.Data();}. TGToolTip * GetTip(); {return fTip;}. Bool_t IsCut(); {return fIsCut;}. void SetAlias(const char* alias); {fAlias = alias;}. void SetTrueName(const char* name); {fTrueName = name;}. » Last changed: root/treeviewer:$Id: TTVLVContainer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTVLVEntry.html:20654,clear,clear,20654,root/html532/TTVLVEntry.html,https://root.cern,https://root.cern/root/html532/TTVLVEntry.html,1,['clear'],['clear']
Usability,"rameters (i.e. pass zero); 212 fX[0] = x;; 213 Double_t fval = fFunc->EvalPar(fX, nullptr);; 214 if (fAbsVal && fval < 0) return -fval;; 215 return fval;; 216 }; 217 // evaluate x * |f(x)|; 218 Double_t EvalFirstMom(Double_t x); 219 {; 220 fX[0] = x;; 221 return fX[0] * TMath::Abs(fFunc->EvalPar(fX, nullptr));; 222 }; 223 // evaluate (x - x0) ^n * f(x); 224 Double_t EvalNMom(Double_t x) const; 225 {; 226 fX[0] = x;; 227 return TMath::Power(fX[0] - fX0, fN) * TMath::Abs(fFunc->EvalPar(fX, nullptr));; 228 }; 229 ; 230 TF1 *fFunc;; 231 mutable Double_t fX[1];; 232 const double *fPar;; 233 Bool_t fAbsVal;; 234 Double_t fN;; 235 Double_t fX0;; 236};; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/** \class TF1; 240 \ingroup Functions; 241 \brief 1-Dim function class; 242 ; 243 ; 244## TF1: 1-Dim function class; 245 ; 246A TF1 object is a 1-Dim function defined between a lower and upper limit.; 247The function may be a simple function based on a TFormula expression or a precompiled user function.; 248The function may have associated parameters.; 249TF1 graphics function is via the TH1 and TGraph drawing functions.; 250 ; 251The following types of functions can be created:; 252 ; 2531. [Expression using variable x and no parameters](\ref F1); 2542. [Expression using variable x with parameters](\ref F2); 2553. [Lambda Expression with variable x and parameters](\ref F3); 2564. [A general C function with parameters](\ref F4); 2575. [A general C++ function object (functor) with parameters](\ref F5); 2586. [A member function with parameters of a general C++ class](\ref F6); 259 ; 260 ; 261 ; 262\anchor F1; 263### 1 - Expression using variable x and no parameters; 264 ; 265#### Case 1: inline expression using standard C++ functions/operators; 266 ; 267Begin_Macro(source); 268{; 269 auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; 270 fa1->Draw();; 271}; 272End_Macro; 273 ; 274#### Case 2: inline expression using a ROOT function (e.g. fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:7483,simpl,simple,7483,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['simpl'],['simple']
Usability,"rameters of projecteds. ;  ; virtual void RemoveProjected (TEveProjected *p);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAtt3D;  TAtt3D ();  ; virtual ~TAtt3D ();  ; virtual void Sizeof3D () const;  Set total size of this 3D object (used by X3D interface). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAttBBox;  TAttBBox ();  ; virtual ~TAttBBox ();  ; Float_t * AssertBBox ();  ; Float_t * GetBBox ();  ; Bool_t GetBBoxOK () const;  ; TAttBBox & operator= (const TAttBBox &tab);  ; void ResetBBox ();  ; void SetupBBoxCube (Float_t extent, Float_t x, Float_t y, Float_t z);  Setup bounding box as cube with given extent and center position. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TEveTriangleSet * ReadTrivialFile (const char *file);  Read a simple ascii input file describing vertices and triangles. ;  ;  Static Public Member Functions inherited from TEveElementList; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TEveElement; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTriangleSet.html:29078,simpl,simple,29078,doc/master/classTEveTriangleSet.html,https://root.cern,https://root.cern/doc/master/classTEveTriangleSet.html,1,['simpl'],['simple']
Usability,"rams in parallel and write them on file ;  mtbb101_fillNtuples.CFill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.CParallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallelMergeTest.C;  pclient.CClient program to test parallel sockets ;  pserv.CServer program to test parallel sockets ;  spy.CClient program which allows the snooping of objects from a spyserv process ;  spyserv.CServer program which allows clients, ""spies"", to connect and snoop objects ;  TestAuth.CMacro test authentication methods stand alone ;  testTUDPSocket.CAs test echo server use udpserver.c in the same directory ;  treeClient.CClient program which creates and fills 2 histograms and a TTree ;  TUriTest.CRudimentary TUri test macro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:134335,simpl,simple,134335,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['simpl'],['simple']
Usability,"ranch {; 40 ; 41// Friends; 42 friend class TTreeCloner;; 43 friend class TLeafElement;; 44 ; 45/// Types; 46protected:; 47 enum EStatusBits {; 48 kBranchFolder = BIT(14),; 49 kDeleteObject = BIT(16), ///< We are the owner of fObject.; 50 kCache = BIT(18), ///< Need to pushd/pop fOnfileObject.; 51 kOwnOnfileObj = BIT(19), ///< We are the owner of fOnfileObject.; 52 kAddressSet = BIT(20), ///< The addressing set have been called for this branch; 53 kMakeClass = BIT(21), ///< This branch has been switched to using the MakeClass Mode; 54 kDecomposedObj = BIT(21) ///< More explicit alias for kMakeClass.; 55 };; 56 ; 57 ; 58// Data Members; 59protected:; 60 TString fClassName; ///< Class name of referenced object; 61 TString fParentName; ///< Name of parent class; 62 TString fClonesName; ///< Name of class in TClonesArray (if any); 63 TVirtualCollectionProxy *fCollProxy; ///<! collection interface (if any); 64 UInt_t fCheckSum; ///< CheckSum of class; 65 Version_t fClassVersion; ///< Version number of class; 66 Int_t fID; ///< element serial number in fInfo; 67 Int_t fType; ///< Branch type; 68 ///<; 69 ///< Note on fType values:; 70 ///< * -1 unsplit object with custom streamer at time of writing; 71 ///< * 0 unsplit object with default streamer at time of writing; 72 ///< OR simple data member of split object (fID==-1 for the former); 73 ///< * 1 base class of a split object.; 74 ///< * 2 class typed data member of a split object; 75 ///< * 3 branch count of a split TClonesArray; 76 ///< * 31 data member of the content of a split TClonesArray; 77 ///< * 4 branch count of a split STL Collection.; 78 ///< * 41 data member of the content of a split STL collection; 79 Int_t fStreamerType; ///< branch streamer type; 80 Int_t fMaximum; ///< Maximum entries for a TClonesArray or variable array; 81 Int_t fSTLtype; ///<! STL container type; 82 Int_t fNdata; ///<! Number of data in this branch; 83 TBranchElement *fBranchCount; ///< pointer to primary branchcount branch; 84 TBranc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8h_source.html:2593,simpl,simple,2593,doc/master/TBranchElement_8h_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html,1,['simpl'],['simple']
Usability,"rand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Cristina Cristescu, CERN/SFT,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/SFT,; Enrico Guiraud, CERN/SFT,; Burt Holzman, Fermilab, CMS,; Lukasz Janyst, CERN/IT,; Christopher Jones, Fermilab, CMS,; Wim Lavrijsen, LBNL, PyRoot,; Sergey Linev, GSI, http, JSROOT,; Pere Mato, CERN/SFT,; Lorenzo Moneta, CERN/SFT,; Axel Naumann, CERN/SFT,; Danilo Piparo, CERN/SFT,; Timur Pocheptsov, CERN/SFT,; Fons Rademakers, CERN/IT/Openlab,; Paul Russo, FNAL,; Enric Tejedor Saavedra, CERN/SFT,; Liza Sakellari, CERN/SFT,; Manuel Tobias Schiller,CERN, LHCb; David Smith, CERN/IT,; Matevz Tadel, UCSD/CMS, Eve,; Vassil Vassilev, CERN/SFT; Wouter Verkerke, NIKHEF/Atlas, RooFit,; Omar, Zapata, Medellin, Columbia; Maciej Zimnoch, GSoC, Poland; ROOT reference manual; The ROOT reference manual has been moved into Doxygen. Still some work and polish has to be done but the reference guide in this new format is now online and can be seen from the ROOT home page.; Core Libraries; Dictionary generation; Fixed the dictionary generation in the case of class inside a namespace marked inlined.; Added mechanisms to stop the dictionary generation while parsing the XML and while selecting in presence of duplicates.; Fix ROOT-7760 : fully allow the usage of the dylib extension on OSx.; Fix ROOT-7723 : allow IOCtors to have as argument a ref to a type called void.; We added a dictionary for map as part of the default STL dictionary.; We added support for template parameter packs in class name involved in the I/O.; Thread safety and thread awareness; We added the function TMethodCall::GetCallFunc to allow direct access to the function wrapper.; We reduced thread serialization in TClass::GetCheckSum, TClass::GetBaseClassOffset and TClass::Property; TObjArray::Delete was updated to allow its caller to explicitly avoid costly checks (extra RecursiveRemove and lock); We removed the need to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:2663,guid,guide,2663,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['guid'],['guide']
Usability,ransformBaseLinear interpolation class ;  CVarTransformHandler;  CVolumeVolume for BinarySearchTree ;  ►NTStreamerInfoActions;  CTActionSequence;  CTConfigurationBase class of the Configurations ;  CTConfiguredAction;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CApplicationWindowMain Qt&Root Application Window: ;  CBalancerInfo;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CClusterD;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CData;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CDUMMY;  CEditor;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  CFUMILI2;  Cfuncptr_and_voidptr_t;  CGaussFunction;  CGcCache_t;  CGCValues_t;  Cgroup;  CGSL_BFGS;  CGSL_BFGS2;  CGSL_FR;  CGSL_NLS;  CGSL_PR;  Ch1analysis;  Ch1analysisTreeReader;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CLINEAR;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_option;  ►Cmg_request_info;  Cmg_header;  Cmg_server_ports;  CMINUIT2;  CMultiDistFree functions adapter ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:81190,simpl,simple,81190,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['simpl'],['simple']
Usability,"ransformBaseLinear interpolation class ;  CVarTransformHandler;  CVolumeVolume for BinarySearchTree ;  ►NTStreamerInfoActions;  ►CTActionSequence;  CSequencePtr;  CTConfigurationBase class of the Configurations ;  CTConfiguredAction;  CTIDNode;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  CTNestedIDs;  ►Nvecgeom;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CBalancerInfo;  Cbasic_string_view;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_option;  ►Cmg_request_info;  Cmg_header;  Cmg_server_ports;  CMultiDistFree functions adapter needed by UNURAN for multidimensional cont distribution ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:88409,simpl,simple,88409,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['simpl'],['simple']
Usability,"raph2DPainter object; TH1*fHpointer to histogram to paint; TPainter3dAlgorithms*fLegopointer to a TPainter3dAlgorithms object; Int_tfNcutsNumber of graphical cuts; TPie*fPiepointer to a TPie in case of option PIE; TStringfShowOptionOption to draw the projection; Int_tfShowProjectionTrue if a projection must be drawn; TList*fStackPointer to stack of histograms (if any); TAxis*fXaxispointer to X axis; Double_t*fXbufX buffer coordinates; TAxis*fYaxispointer to Y axis; Double_t*fYbufY buffer coordinates; TAxis*fZaxispointer to Z axis. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THistPainter(). Default constructor.; ; . ~THistPainter(). Default destructor.; ; . Int_t DistancetoPrimitive(Int_t px, Int_t py). Compute the distance from the point px,py to a line.; ; Compute the closest distance of approach from point px,py to elements of; an histogram. The distance is computed in pixels units.; ; Algorithm:; Currently, this simple model computes the distance from the mouse to the; histogram contour only.; ; . void DrawPanel(). Display a panel with all histogram drawing options.; ; . void ExecuteEvent(Int_t event, Int_t px, Int_t py). Execute the actions corresponding to ""event"".; ; This function is called when a histogram is clicked with the locator at; the pixel position px,py.; ; . TList * GetContourList(Double_t contour) const. Get a contour (as a list of TGraphs) using the Delaunay triangulation.; ; . char * GetObjectInfo(Int_t px, Int_t py) const. Display the histogram info (bin number, contents, integral up to bin; corresponding to cursor position px,py.; ; . Bool_t IsInside(Int_t x, Int_t y). Return kTRUE if the cell ix, iy is inside one of the graphical cuts.; ; . Bool_t IsInside(Double_t x, Double_t y). Return kTRUE if the point x,y is inside one of the graphical cuts.; ; . Int_t MakeChopt(Option_t* option). Decode string ""choptin"" and fill Hoption structure.; ; . Int_t MakeCuts(char* cutsopt). Decode string ""choptin"" an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:82626,simpl,simple,82626,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,6,['simpl'],['simple']
Usability,"raphPainter::PaintGraphMultiErrors ; (; TGraph * ; theGraph, . Option_t * ; option . ). Paint this TGraphMultiErrors with its current attributes. ; Definition at line 2720 of file TGraphPainter.cxx. ◆ PaintGraphPolar(). void TGraphPainter::PaintGraphPolar ; (; TGraph * ; theGraph, . Option_t * ; option . ). Paint this TGraphPolar with its current attributes. ; Definition at line 3789 of file TGraphPainter.cxx. ◆ PaintGraphQQ(). void TGraphPainter::PaintGraphQQ ; (; TGraph * ; theGraph, . Option_t * ; option . ). Paint this graphQQ. No options for the time being. ; Definition at line 4084 of file TGraphPainter.cxx. ◆ PaintGraphReverse(). void TGraphPainter::PaintGraphReverse ; (; TGraph * ; theGraph, . Option_t * ; option . ). Paint theGraph reverting values along X and/or Y axis. a new graph is created. ; Definition at line 4144 of file TGraphPainter.cxx. ◆ PaintGraphSimple(). void TGraphPainter::PaintGraphSimple ; (; TGraph * ; theGraph, . Option_t * ; option . ). Paint a simple graph, without errors bars. ; Definition at line 4584 of file TGraphPainter.cxx. ◆ PaintHelper(). void TGraphPainter::PaintHelper ; (; TGraph * ; theGraph, . Option_t * ; option . ). overridevirtual . Paint a any kind of TGraph. ; Implements TVirtualGraphPainter.; Definition at line 1211 of file TGraphPainter.cxx. ◆ PaintHighlightPoint(). void TGraphPainter::PaintHighlightPoint ; (; TGraph * ; theGraph, . Option_t * ; option . ). virtual . Paint highlight point as TMarker object (open circle) ; Definition at line 1165 of file TGraphPainter.cxx. ◆ PaintPolyLineHatches(). void TGraphPainter::PaintPolyLineHatches ; (; TGraph * ; theGraph, . Int_t ; n, . const Double_t * ; x, . const Double_t * ; y . ). Paint a polyline with hatches on one side showing an exclusion zone. ; x and y are the vectors holding the polyline and n the number of points in the polyline and w the width of the hatches. w can be negative. This method is not meant to be used directly. It is called automatically according to t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPainter.html:48653,simpl,simple,48653,doc/master/classTGraphPainter.html,https://root.cern,https://root.cern/doc/master/classTGraphPainter.html,1,['simpl'],['simple']
Usability,"raphics from many threads Three different canvases in three different threads are started and regularly updated ;  draw_rh1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_subpads.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 lines in it (RLine) ;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  vo004_SortAndSelect.C In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo004_SortAndSelect.py In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo005_Combinations.C In this tutorial we learn how combinations of RVecs can be build ;  vo005_Combinations.py In this tutorial we learn how combinations of RVecs can be build ;  vo006_IndexManipulation.C In this tutorial we demonstrate RVec helpers for index manipulation ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlread",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:172499,learn,learn,172499,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['learn'],['learn']
Usability,"raries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). If option ""S"" a TFitResult object is returned and it can be used to obtain; additional fit information, like covariance or correlation matrix. Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed, this; should be done by specifying non-null parameter limits, with lower; limits larger than upper limits. On output, f1 contains the fitted parameters and errors, as well as; the number of d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBinomialEfficiencyFitter.html:10183,simpl,simply,10183,root/html602/TBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/root/html602/TBinomialEfficiencyFitter.html,2,['simpl'],['simply']
Usability,"rary a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22598,guid,guide,22598,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['guid'],['guide']
Usability,"ras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVACrossValidationApplication.C This macro provides an example of how to use TMVA for k-folds cross evaluation in application ;  TMVACrossValidationRegression.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMinimalClassification.C Minimal self-contained example for setting up TMVA with binary classification ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:159305,simpl,simple,159305,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,2,['simpl'],['simple']
Usability,"ration Index: Measure of the ""Variance"" of a sample.; Separation Gain: the measure of how the quality of separation of the sample increases by splitting the sample e.g. into a ""left-node"" and a ""right-node"" (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right) this is then the quality criteria which is optimized for when trying to increase the information in the system (making the best selection ; Definition at line 66 of file RegressionVariance.h. Public Member Functions;  RegressionVariance ();  ;  RegressionVariance (const RegressionVariance &s);  ; virtual ~RegressionVariance ();  ; TString GetName ();  ; Double_t GetSeparationGain (const Double_t nLeft, const Double_t targetLeft, const Double_t target2Left, const Double_t nTot, const Double_t targetTot, const Double_t target2Tot);  Separation Gain: the measure of how the quality of separation of the sample increases by splitting the sample e.g. ;  ; virtual Double_t GetSeparationIndex (const Double_t n, const Double_t target, const Double_t target2);  Separation Index: a simple Variance. ;  ; virtual TClass * IsA () const;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Attributes; TString fName;  name of the concrete Separation Index implementation ;  . #include <TMVA/RegressionVariance.h>; Constructor & Destructor Documentation. ◆ RegressionVariance() [1/2]. TMVA::RegressionVariance::RegressionVariance ; (; ). inline . Definition at line 71 of file RegressionVariance.h. ◆ RegressionVariance() [2/2]. TMVA::RegressionVariance::RegressionVariance ; (; const RegressionVariance & ; s). inline . Definition at line 74 of file RegressionVariance.h. ◆ ~RegressionVariance(). virtual TMVA::RegressionVariance::~RegressionVariance ; (; ). inlinevirtual . De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RegressionVariance.html:1552,simpl,simple,1552,doc/master/classTMVA_1_1RegressionVariance.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RegressionVariance.html,1,['simpl'],['simple']
Usability,"rator=(const TMVA::RegressionVariance&); TMVA::RegressionVarianceRegressionVariance(); TMVA::RegressionVarianceRegressionVariance(const TMVA::RegressionVariance& s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nLeft, const Double_t& targetLeft, const Double_t& target2Left, const Double_t& nTot, const Double_t& targetTot, const Double_t& target2Tot); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system; for the Regression: as the ""Gain is maximised"", the RMS (sqrt(variance)); which is used as a ""separation"" index should be as small as possible.; the ""figure of merit"" here has to be -(rms left+rms-right) or 1/rms... Double_t GetSeparationIndex(const Double_t& n, const Double_t& target, const Double_t& target2); Separation Index: a simple Variance. RegressionVariance(); default constructor. {fName = ""Variance for Regression"";}. RegressionVariance(const TMVA::RegressionVariance& s); copy constructor. {}. virtual ~RegressionVariance(); destructor. {}. TString GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: RegressionVariance.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-12-10 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__RegressionVariance.html:2082,simpl,simple,2082,root/html528/TMVA__RegressionVariance.html,https://root.cern,https://root.cern/root/html528/TMVA__RegressionVariance.html,1,['simpl'],['simple']
Usability,"rblock; 3903/// \param [in] selection; 3904/// \parblock; 3905/// A string containing a selection expression.; 3906/// In a selection all usual C++ mathematical and logical operators are allowed.; 3907/// The value corresponding to the selection expression is used as a weight; 3908/// to fill the histogram (a weight of 0 is equivalent to not filling the histogram).\n; 3909/// \n; 3910/// Examples:; 3911/// - ""x<y && sqrt(z)>3.2"": returns a weight = 0 or 1; 3912/// - ""(x+y)*(sqrt(z)>3.2)"": returns a weight = x+y if sqrt(z)>3.2, 0 otherwise\n; 3913/// \n; 3914/// If the selection expression returns an array, it is iterated over in sync with the; 3915/// array returned by the varexp argument (as described below in ""Drawing expressions using arrays and array; 3916/// elements""). For example, if, for a given event, varexp evaluates to; 3917/// `{1., 2., 3.}` and selection evaluates to `{0, 1, 0}`, the resulting histogram is filled with the value 2. For example, for each event here we perform a simple object selection:; 3918/// ~~~{.cpp}; 3919/// // Muon_pt is an array: fill a histogram with the array elements > 100 in each event; 3920/// tree->Draw('Muon_pt', 'Muon_pt > 100'); 3921/// ~~~; 3922/// \endparblock; 3923/// \param [in] option; 3924/// \parblock; 3925/// The drawing option.; 3926/// - When an histogram is produced it can be any histogram drawing option; 3927/// listed in THistPainter.; 3928/// - when no option is specified:; 3929/// - the default histogram drawing option is used; 3930/// if the expression is of the form ""e1"".; 3931/// - if the expression is of the form ""e1:e2""or ""e1:e2:e3"" a cloud of; 3932/// unbinned 2D or 3D points is drawn respectively.; 3933/// - if the expression has four fields ""e1:e2:e3:e4"" a cloud of unbinned 3D; 3934/// points is produced with e1 vs e2 vs e3, and e4 is mapped on the current color; 3935/// palette.; 3936/// - If option COL is specified when varexp has three fields:; 3937/// ~~~ {.cpp}; 3938/// tree.Draw(""e1:e2:e3"","""",""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:155086,simpl,simple,155086,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['simpl'],['simple']
Usability,"rce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian ter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1075,simpl,simply,1075,root/html530/RooAbsPdf__GenSpec.html,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html,5,['simpl'],['simply']
Usability,"rce graph to be drawn in high resolution mode. By default, the graph is; drawn in low resolution in case the number of points is greater than the; number of pixels in the current pad.; ; ""][""; ""Cutoff"" style. When this option is selected together with H option, the; first and last vertical lines of the histogram are not drawn.; . . void PaintGraphAsymmErrors(TGraph* theGraph, Option_t* option). Paint this TGraphAsymmErrors with its current attributes.; . void PaintGraphBentErrors(TGraph* theGraph, Option_t* option). Paint this TGraphBentErrors with its current attributes.; . void PaintGraphErrors(TGraph* theGraph, Option_t* option). Paint this TGraphErrors with its current attributes.; . void PaintGraphPolar(TGraph* theGraph, Option_t* option). Paint this TGraphPolar with its current attributes.; . void PaintGraphQQ(TGraph* theGraph, Option_t* option). Paint this graphQQ. No options for the time being.; ; . void PaintGraphSimple(TGraph* theGraph, Option_t* option). Paint a simple graph, without errors bars.; ; . void PaintPolyLineHatches(TGraph* theGraph, Int_t n, const Double_t* x, const Double_t* y). Paint a polyline with hatches on one side showing an exclusion zone. x and y; are the the vectors holding the polyline and n the number of points in the; polyline and w the width of the hatches. w can be negative.; This method is not meant to be used directly. It is called automatically; according to the line style convention.; ; . void PaintStats(TGraph* theGraph, TF1* fit). Paint the statistics box with the fit info.; ; . void Smooth(TGraph* theGraph, Int_t npoints, Double_t* x, Double_t* y, Int_t drawtype). Smooth a curve given by N points.; ; The original code is from an underlaying routine for Draw based on the; CERN GD3 routine TVIPTE:; ; Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; ; This method draws a smooth tangentially continuous curve through; the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)).; The curve is approximated by a poly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphPainter.html:24074,simpl,simple,24074,root/html532/TGraphPainter.html,https://root.cern,https://root.cern/root/html532/TGraphPainter.html,1,['simpl'],['simple']
Usability,"rce:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeViewer.html:1416,progress bar,progress bar,1416,root/html602/TTreeViewer.html,https://root.cern,https://root.cern/root/html602/TTreeViewer.html,2,['progress bar'],['progress bar']
Usability,"rce; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to addin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:25427,clear,clearEmat,25427,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,9,['clear'],"['clear', 'clearEmat']"
Usability,"rder to use these algorithm the user needs to provide a function. ROOT provides a common way of specifying them via some interfaces; 13.7 ROOT::Math Function interfaces; To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function. In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ROOT::Math Function interface structure. 13.7.1 One-dimensional Function Interfaces; These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions. For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. ROOT::Math::IBaseFunctionOneDim: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing double operator() (const double ). The user class defined only needs to reimplement the pure abstract method double DoEval(double x), that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from IBaseFunctionOneDim:; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionOneDim; {; double DoEval(double x) const; {; return x*x;; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyFunction();; }; };. ROOT::Math::IGradientFunctionOneDim: Some of the numerical algorithm will need to calculate the derivatives of the function. In these cases, the user will have to provide the necessary code for this to happen. The interface defined in IGradientFunctionOneDim introduced the method double Derivative(double x) that will return the derivative of the function at the point x. The class inherit by the user will ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:687459,simpl,simple,687459,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"re compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. void FillLeaves(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when reading or writing; branches that may contain referenced objects. TRefTable * GetRefTable() const; {return fRefTable;}. void SetRequestedEntry(Long64_t entry); {fRequestedEntry = entry;}. » Author: Rene Brun 19/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchRef.h 39635 2011-06-09 15:37:27Z pcanal $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBranchRef.html:14714,clear,cleared,14714,root/html530/TBranchRef.html,https://root.cern,https://root.cern/root/html530/TBranchRef.html,1,['clear'],['cleared']
Usability,"re then follow the instructions on how to report a bug with JIRA.; When you submit a bug, please follow these guidelines:. If you submit a problem, always indicate your ROOT version number (e.g. 6.02.00, 5.34.22) and the platform you are running on (e.g. Ubuntu 14 gcc49, SLC6 clang35).; The bug title subject line should clearly identify the problem.; If you use a non recent version of ROOT, try to test your problem with newer version. If this is too difficult, consult the release and development notes to check if your problem has not already been solved.; Try to quickly search the internet and look in the forum if your problem has been already solved.; Try to share the maximum amount of information. A bug report which only says ""My macro crashes when running on kubuntu but on windows works"" is much less likely to be solved quickly than a complete message with a gdb stacktrace and a reproducer (see next item).; Send a minimal program or macro reproducing the problem. Make sure that your script can be executed directly. If it uses a data file, send the smallest possible data file as a mail attachment, or indicate how to get this file.; If for some reason it is not possible to share a minimal reproducer, try to make sure that your explanations are sufficient to speed up the whole fixing procedure. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/guidelines-submitting-bug.html:3862,guid,guidelines,3862,d/guidelines-submitting-bug.html,https://root.cern,https://root.cern/d/guidelines-submitting-bug.html,1,['guid'],['guidelines']
Usability,"re& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:4796,clear,clearValueDirty,4796,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,1,['clear'],['clearValueDirty']
Usability,"re's PyPy. All existing binding generator tools (including PyROOT) rely on CPython internals, or at least on the Python C-API. That does not jive with PyPy as it has for example a garbage collector instead of reference counting. Through some heroics, it does expose a Python C-API, but it's slow as it interferes (blocks, really) the just-in-time compiler. Therefore, within PyPy, there are two new approaches: cffi for C and cppyy for C++. Both are part of the standard PyPy releases. There is also already a PyROOT version for the latter (see: http://root.cern.ch/drupal/content/pypyroot).; Cheers,; Wim. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:49 Permalink . Why? . I don't understand. You wish to maintain backwards compatibility. This implies maintaining the insanity that is the equivalence of ""."" and ""->"". Not only is this wrong, this egregiously ignores performance concerns that come with dereferencing. It also ensures that people using ROOT/Cling while learning C++ will have trouble compiling their programs using actual compilers. It implies that you intend to keep the (at best) insane class hierarchy TF1 <- TF2 <- TF3 and so on. This example shows some of the major design flaws in ROOT -- a 2-dimensional function IS a 1-dimensional function? There is no abstract base class? No templates? It implies that you plan to keep the pointless T in front of all the names of ROOT, even though you will have access to namespaces (finally) and thus can move past the 1970's C practice of avoiding name collisions by a sort of weird Hungarian notation. It implies that you plan to maintain the outdated interfaces which make no use of templates. Templates are one of the most powerful features of C++, are more relevant to performance critical tasks than inheritance, and help ensure the type-safety of code (thereby ensuring the accuracy of data by helping to prevent accidental narrowing etc). It implies that you intend to continue to encourage the use of bare new and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:9021,learn,learning,9021,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['learn'],['learning']
Usability,"re(0,6,""const "")==0) {; 1517 newName = ""const "";; 1518 name.erase(0,6);; 1519 }; 1520 std::string suffix;; 1521 UInt_t nstars = 0;; 1522 while(name[name.length()-nstars-1]=='*') {; 1523 ++nstars;; 1524 suffix.append(""*"");; 1525 }; 1526 if (nstars) {; 1527 name.erase(name.length()-nstars,nstars);; 1528 }; 1529 ; 1530 std::string alternate(context->GetName());; 1531 alternate.append(""::"");; 1532 alternate.append(name);; 1533 ; 1534 TClass *altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1535 if (altcl) {; 1536 newName.append(altcl->GetName());; 1537 newName.append(suffix);; 1538 return altcl;; 1539 }; 1540 ; 1541 size_t ctxt_cursor = strlen(context->GetName());; 1542 for (size_t level = 0; ctxt_cursor != 0; --ctxt_cursor) {; 1543 switch (context->GetName()[ctxt_cursor]) {; 1544 case '<': --level; break;; 1545 case '>': ++level; break;; 1546 case ':': if (level == 0) {; 1547 // we encountered a scope not within a template; 1548 // parameter.; 1549 alternate.clear();; 1550 alternate.append(context->GetName(),ctxt_cursor+1);; 1551 alternate.append(name);; 1552 altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1553 if (altcl) {; 1554 newName.append(altcl->GetName());; 1555 newName.append(suffix);; 1556 return altcl;; 1557 }; 1558 }; 1559 }; 1560 }; 1561 newName.clear();; 1562 return 0;; 1563 }; 1564 ; 1565 TClass *FixCollectionV5(TClass *context, TClass *oldClass, TClass *newClass); 1566 {; 1567 assert(oldClass->GetCollectionProxy() && newClass->GetCollectionProxy());; 1568 ; 1569 TVirtualCollectionProxy *old = oldClass->GetCollectionProxy();; 1570 TVirtualCollectionProxy *current = newClass->GetCollectionProxy();; 1571 Int_t stlkind = old->GetCollectionType();; 1572 ; 1573 if (stlkind == ROOT::kSTLmap || stlkind == ROOT::kSTLmultimap) {; 1574 ; 1575 if (current->GetValueClass() == nullptr) {; 1576 // This should really never happen (the content of map should always; 1577 // be a pair and thus have a TClass ... so let's just give up ...;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:59457,clear,clear,59457,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['clear'],['clear']
Usability,"re(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooIntegralMorph.html:6456,clear,clearEvalErrorLog,6456,root/html532/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html532/RooIntegralMorph.html,1,['clear'],['clearEvalErrorLog']
Usability,"re(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooIntegralMorph.html:6456,clear,clearEvalErrorLog,6456,root/html528/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html528/RooIntegralMorph.html,1,['clear'],['clearEvalErrorLog']
Usability,"re(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooIntegralMorph.html:6456,clear,clearEvalErrorLog,6456,root/html530/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html530/RooIntegralMorph.html,1,['clear'],['clearEvalErrorLog']
Usability,re*fBaseIconbase list tree icon picture; Bool_tfBusyKTRUE if busy i.e : connecting; TGPopupMenu*fCascadeMenuoptions menu entry; Bool_tfChangePicKTRUE if animation active; TStringfConfigFileconfiguration file name; TGHProgressBar*fConnectProgconnection progress bar; TContextMenu*fContextMenuinput/output objects context menu; time_tfElapsedtime of connection; TGPopupMenu*fFileMenufile menu entry; TGPopupMenu*fHelpMenuhelp menu entry; TGHorizontalFrame*fHf; TSessionInputFrame*fInputFrameinput frame; const TGPicture*fLocallocal session icon picture; TSessionLogView*fLogWindowexternal log window; TGMenuBar*fMenuBarapplication main menu bar; TGPopupMenu*fOptionsMenuoptions menu entry; TSessionOutputFrame*fOutputFrameoutput frame; TGPopupMenu*fPopupQryquery related popup menu; TGPopupMenu*fPopupSrvserver related popup menu; const TGPicture*fProofConconnected server icon picture; const TGPicture*fProofDiscondisconnected server icon picture; const TGPicture*fQueryConconnected(?) query icon picture; const TGPicture*fQueryDiscondisconnected(?) query icon picture; TSessionQueryFrame*fQueryFrameright side query frame; TGPopupMenu*fQueryMenuquery menu entry; TGIcon*fRightIconassociated picture; TGPicture*fRightIconPicturelower bottom left icon used to show connection status; TSessionServerFrame*fServerFrameright side server frame; TSessionFrame*fSessionFrameright side session frame; TGListTree*fSessionHierarchymain sessions/queries hierarchy list tree; TGListTreeItem*fSessionItembase (main) session list tree item; TGPopupMenu*fSessionMenusession menu entry; TList*fSessionslist of sessions; time_tfStart; TGStatusBar*fStatusBarbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionViewer.html:23598,progress bar,progress bar,23598,root/html528/TSessionViewer.html,https://root.cern,https://root.cern/root/html528/TSessionViewer.html,4,['progress bar'],['progress bar']
Usability,reacting to messages received from it as specified by the Notify and HandleInput methods ;  CTMPWorkerTreeFuncTemplated derivation of TMPWorkerTree handlign generic function tree processing ;  CTMPWorkerTreeSelTemplated derivation of TMPWorkerTree handlign selector tree processing ;  CTMrbSubevent_Caen;  CTMultiDimFitMultidimensional Fits in ROOT ;  CTMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects ;  CTMultiLayerPerceptron;  CTMutex;  CTMutexImp;  CTMySQLResult;  CTMySQLRow;  CTMySQLServer;  ►CTMySQLStatement;  CTParamData;  CTNamedBase class for all named ROOT classes ;  CTNDArray;  CTNDArrayRef;  CTNDArrayT;  CTNetFile;  CTNetFileStager;  CTNetSystem;  CTNetXNGFile;  CTNetXNGFileStager;  CTNetXNGSystem;  CTNeuron;  CTNewChainDlg;  CTNewQueryDlg;  CTNodeTNode description ;  CTNodeDivDescription of parameters to divide a 3-D geometry object ;  CTNonCopyable;  CTNonSplitBrowsableAllows a TBrowser to browse non-split branches as if they were split ;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStep;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CTOrdCollectionIterIterator of ordered collection ;  CTOutputListSelectorDataMapSet the selector's data members to the corresponding elemen,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:181110,simpl,simple,181110,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['simpl'],['simple']
Usability,reacting to messages received from it as specified by the Notify and HandleInput methods ;  CTMPWorkerTreeFuncTemplated derivation of TMPWorkerTree handlign generic function tree processing ;  CTMPWorkerTreeSelTemplated derivation of TMPWorkerTree handlign selector tree processing ;  CTMrbSubevent_Caen;  CTMultiDimFitMultidimensional Fits in ROOT ;  CTMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects ;  CTMultiLayerPerceptron;  CTMutex;  CTMutexImp;  CTMySQLResult;  CTMySQLRow;  CTMySQLServer;  ►CTMySQLStatement;  CTParamData;  CTNamedBase class for all named ROOT classes ;  CTNDArray;  CTNDArrayRef;  CTNDArrayT;  CTNetFile;  CTNetFileStager;  CTNetSystem;  CTNetXNGFile;  CTNetXNGFileStager;  CTNetXNGSystem;  CTNeuron;  CTNewChainDlg;  CTNewQueryDlg;  CTNodeTNode description ;  CTNodeDivDescription of parameters to divide a 3-D geometry object ;  CTNonCopyable;  CTNonSplitBrowsableAllows a TBrowser to browse non-split branches as if they were split ;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStepThis class contains implementation of writing OpenCascade's geometry shapes to the STEP file reproducing the original ROOT geometry tree ;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CT,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:189677,simpl,simple,189677,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,2,['simpl'],['simple']
Usability,"readExecutor::Map; This class inherits its interfaces from ROOT::TExecutorCRTP; , adapting them for multithreaded parallelism and extends them supporting:; Parallel Foreach operations.; Custom task granularity and partial reduction, by specifying reduction function and the number of chunks as extra parameters for the Map call. This is specially useful to reduce the size of intermediate results when dealing with a sizeable number of elements in the input data. The two possible usages of the Map method are:. Map(F func, unsigned nTimes): func is executed nTimes with no arguments; Map(F func, T& args): func is executed on each element of the collection of arguments args. For either signature, func is executed as many times as needed by a pool of nThreads threads, where nThreads typically defaults to the number of cores.; A collection containing the result of each execution is returned.; Note: the user is responsible for the deletion of any object that might be created upon execution of func, returned objects included: ROOT::TThreadExecutor never deletes what it returns, it simply forgets it.; Parameters. funca callable object, such as a lambda expression, an std::function, a functor object or a function that takes zero arguments (for the first signature) or one (for the second signature). ; argsa standard vector, a ROOT::TSeq of integer type or an initializer list for the second signature. An integer only for the first. . Note: in cases where the function to be executed takes more than zero/one argument but all are fixed except zero/one, the function can be wrapped in a lambda or via std::bind to give it the right signature.; Return value:; An std::vector. The elements in the container will be the objects returned by func.; Examples:; root[] ROOT::TThreadExecutor pool; auto hists = pool.Map(CreateHisto, 10);; root[] ROOT::TThreadExecutor pool(2); auto squares = pool.Map([](int a) { return a*a; }, {1,2,3});; a#define a(i)Definition RSha256.hxx:99; ROOT::TThreadExecutorT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html:1554,simpl,simply,1554,doc/v632/classROOT_1_1TThreadExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html,2,['simpl'],['simply']
Usability,reads.C Fill the same TNtuple from different threads ;  mt201_parallelHistoFill.C Parallel fill of a histogram ;  mt301_TTaskGroupSimple.C Shows how to run items of work asynchronously with a TTaskGroup ;  mt302_TTaskGroupNested.C Calculate Fibonacci numbers exploiting nested parallelism through TTaskGroup ;  mt304_fillHistos.CFill histograms in parallel with automatic binning ;  mtbb001_fillHistos.C Fill histograms in parallel and write them on file ;  mtbb101_fillNtuples.C Fill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.C Parallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallelMergeTest.C;  pclient.CClient program to test parallel sockets ;  pserv.CServer program to test parallel sockets ;  spy.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:138601,simpl,simple,138601,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['simpl'],['simple']
Usability,"ready created.; 181 ; 182~~~ {.cpp}; 183 chamber->AddNode(wire_co, 1, new TGeoTranslation(-0.2,0,0));; 184 chamber->AddNode(wire_co, 2, new TGeoTranslation(0.2,0,0));; 185~~~; 186 ; 187 The 2 nodes that we have created inside chamber will both point to a wire_co; 188object, but will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will; 189want now to place symmetrically 1000 chambers on a pad, following a pattern; 190of 20 rows and 50 columns. One way to do this will be to replicate our chamber; 191by positioning it 1000 times in different positions of the pad. Unfortunately,; 192this is far from being the optimal way of doing what we want.; 193Imagine that we would like to find out which of the 1000 chambers is containing; 194a (x,y,z) point defined in the pad reference. You will never have to do that,; 195since the modeller will take care of it for you, but let's guess what it has; 196to do. The most simple algorithm will just loop over all daughters, convert; 197the point from mother to local reference and check if the current chamber; 198contains the point or not. This might be efficient for pads with few chambers,; 199but definitely not for 1000. Fortunately the modeler is smarter than that and; 200create for each volume some optimization structures called voxels (see Voxelization); 201to minimize the penalty having too many daughters, but if you have 100 pads like; 202this in your geometry you will anyway loose a lot in your tracking performance.; 203 ; 204 The way out when volumes can be arranged according to simple patterns is the; 205usage of divisions. We will describe them in detail later on. Let's think now; 206at a different situation : instead of 1000 chambers of the same type, we may; 207have several types of chambers. Let's say all chambers are cylindrical and have; 208a wire inside, but their dimensions are different. However, we would like all; 209to be represented by a single volume family, since they have the same properties.; 210*/; 211 ; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:10598,simpl,simple,10598,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['simpl'],['simple']
Usability,"ream &, TNtupleD &, char, bool);  ; template Long64_t FillNtupleFromStream< Float_t, TNtuple > (std::istream &, TNtuple &, char, bool);  ; bool NextCharacterIsEOL (std::istream &input);  Either '\r' | '\n' or eof of some problem. ;  ; void SkipComment (std::istream &input);  Skips everything from '#' to (including) '\r' or '\n'. ;  ; void SkipEmptyLines (std::istream &input);  Skips empty lines (newline-characters), ws-lines (consisting only of whitespace characters + newline-characters). ;  ; void SkipWSCharacters (std::istream &input);  Skip whitespace characters, but not newline-characters we support ('\r' or '\n'). ;  . Function Documentation. ◆ FillNtupleFromStream(). template<class DataType , class Tuple > . Long64_t ROOT::TreeUtils::FillNtupleFromStream ; (; std::istream & ; inputStream, . Tuple & ; tuple, . char ; delimiter, . bool ; strictMode . ). Function to fill tuples (TNtuple/TNtupleD) from a simple ASCII data file. ; With auto and decltype - we can get rid of DataType parameter :) (or with a simple typedef inside ntuple class). An input file consists of non-empty lines (separated by newline-characters), possibly empty lines, and comments (treated as empty lines). Each non-empty line should contain N numbers - entry for a tuple. Non-strict mode lets you to have newline-characters inside a tuple's row (as it worked in ROOT prior to v5.3xxx). ; Definition at line 80 of file TreeUtils.cxx. ◆ FillNtupleFromStream< Double_t, TNtupleD >(). template Long64_t ROOT::TreeUtils::FillNtupleFromStream< Double_t, TNtupleD > ; (; std::istream & ; , . TNtupleD & ; , . char ; , . bool ;  . ). ◆ FillNtupleFromStream< Float_t, TNtuple >(). template Long64_t ROOT::TreeUtils::FillNtupleFromStream< Float_t, TNtuple > ; (; std::istream & ; , . TNtuple & ; , . char ; , . bool ;  . ). ◆ NextCharacterIsEOL(). bool ROOT::TreeUtils::NextCharacterIsEOL ; (; std::istream & ; input). Either '\r' | '\n' or eof of some problem. ; Definition at line 298 of file TreeUtils.cxx. ◆ SkipComm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1TreeUtils.html:1738,simpl,simple,1738,doc/master/namespaceROOT_1_1TreeUtils.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TreeUtils.html,2,['simpl'],['simple']
Usability,"reamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. ULong_t_max!; RooNameSet_name1!; RooNameSet_name2!; ULong_t_next!; map<pair<const RooArgSet*,const RooArgSet*>,unsigned long>_pairToIdx!; vector<pair<const RooArgSet*,const RooArgSet*> >_pairs!; TNamed*_set2RangeName!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNormSetCache(ULong_t max = 32). ~RooNormSetCache(); Destructor. void clear(); Clear contents. void add(const RooArgSet* set1, const RooArgSet* set2 = 0); Add given pair of RooArgSet pointers to our store. Bool_t autoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); If RooArgSets set1 and set2 or sets with similar contents have; been seen by this cache manager before return kFALSE If not,; return kTRUE. If sets have not been seen and doRefill is true,; update cache reference to current input sets. RooNormSetCache(ULong_t max = 32). Int_t index(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Match range name first. Bool_t contains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); { return (index(set1,set2,set2RangeName) >= 0); }. Bool_t containsSet1(const RooArgSet* set1). const RooArgSet* lastSet1() const; { return _pairs.empty()?0:_pairs.back().first; }. const RooArgSet* lastSet2() const; { return _pairs.empty()?0:_pairs.back().second; }. const RooNameSet& nameSet1() const; { return _name1; }. const RooNameSet& nameSet2() const; { return _name2; }. Int_t entries() const; { return _pairs.size(); }. void initialize(const RooNormSetCache& other); { clear(); *this = other; }. » Last changed: Tue Mar 10 17:18:10 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNormSetCache.html:3729,clear,clear,3729,root/html534/RooNormSetCache.html,https://root.cern,https://root.cern/root/html534/RooNormSetCache.html,1,['clear'],['clear']
Usability,"reases opportunity for reuse of design. 1.5 Installing ROOT. To install ROOT you have the choice to download the binaries or the source. The source is quicker to transfer since it is only ~22 MB, but you will need to compile and link it. The binaries compiled with no debug information range from ~35 MB to ~45 MB depending on the target platform.; The installation and building of ROOT is described in Appendix A: Install and Build ROOT. You can download the binaries, or the source. The GNU g++ compiler on most UNIX platforms can compile ROOT.; Before downloading a binary version make sure your machine contains the right run-time environment. In most cases it is not possible to run a version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is installed. In such cases you’ll have to install ROOT from source.; ROOT is currently running on the following platforms: supported platforms. GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc, Portland/PGCC,KAI/KCC); Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC); FreeBSD and OpenBSD (GCC); GNU/Hurd (GCC); HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC); IBM AIX 4.1 (xlC compiler, GCC); Sun Solaris for SPARC (SUN C++ compiler, GCC); Sun Solaris for x86 (SUN C++ compiler, KAI/KCC); Compaq Alpha (GCC, KAI/KCC, DEC/CXX); SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler); Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC); MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl); PowerPC with GNU/Linux and GCC, Debian v2; PowerPC64 with GNU/Linux and GCC; ARM with GNU/Linux and GCC; LynxOS. 1.6 The Organization of the ROOT Framework; Now after we know in abstract terms what the ROOT framework is, let us look at the physical directories and files that come with the ROOT installation. You may work on a platform where your system administrator has already installed ROOT. You will need to follow the specific development environment for your setup and you may not have write access to the directorie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:15494,UX,UX,15494,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['UX'],['UX']
Usability,"reate a histogram with the desired axis range first. Draw the empty histogram and then draw the graph using the existing axis from the histogram.; {; c1 = new TCanvas(""c1"",""A Zoomed Graph"",200,10,700,500);; hpx = new TH2F(""hpx"",""Zoomed Graph Example"",10,0,0.5,10,1.0,8.0);; hpx->SetStats(kFALSE); // no statistics; hpx->Draw();; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; gr = new TGraph(n,x,y);; gr->SetMarkerColor(4);; gr->SetMarkerStyle(20);; gr->Draw(""LP"");// and draw it without an axis; }; The next example is the same graph as above with a zoom in the x and y directions. A zoomed graph. 4.15 The User Interface for Graphs; The class TGraphEditor provides the user interface for setting the following graph attributes interactively:. Title text entry field … sets the title of the graph.; Shape radio button group - sets the graph shapes:. No Line: draw unconnected points;; Smooth Line: a smooth curve;; Simple Line: a simple poly-line;; Bart Chart: a bar chart at each point.; Fill Area: a fill area is drawn. Show Marker - sets markers as visible or invisible.; Exclusion Zone - specifies the exclusion zone parameters :. ’+-‘ check button: sets on which side of the line the exclusion zone will be drawn;; Width combo box: defines the width of the zone. 5 Fitting Histograms; To fit a histogram you can use the Fit Panel on a visible histogram via the context menu, or you can use the TH1::Fit method. The Fit Panel, which is limited, is best for prototyping. The histogram needs to be drawn in a pad before the Fit Panel is invoked. The method TH1::Fit is more powerful and is used in scripts and programs.; 5.1 The Fit Method; The Fit method is implemented in ROOT for the histogram classes TH1, the sparse histogram classes, THnSparse, the graph classes, TGraph, TGraph2D and TMultiGraph for fitting a collection of Graphs with the same function.; 5.1.1 The TH1::Fit Method; To fit a histogram program",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:162899,simpl,simple,162899,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"rebinned bin number. ;  ; TGNumberEntryField * fBinNumberEntry1;  Label which shows the rebinned bin number for ntuple histogram. ;  ; TGHSlider * fBinOffsetSld;  Add an offset to the origin of the histogram. ;  ; TGHSlider * fBinSlider;  Slider to set rebinning integer value. ;  ; TGHSlider * fBinSlider1;  Slider to set rebinning integer value for ntuple histogram. ;  ; TGTextButton * fCancel;  Cancel-Button to reprobate the rebinned histogram. ;  ; TGComboBox * fCoordsCombo;  Coordinate System combo box. ;  ; TGCheckButton * fDelaydraw;  Delayed drawing of the new axis range. ;  ; TGRadioButton * fDim;  2D-Plot RadioButton ;  ; TGRadioButton * fDim0;  3D-Plot RadioButton ;  ; TGLayoutHints * fDim0lh;  layout hints for 3D-Plot RadioButton ;  ; TGHButtonGroup * fDimGroup;  Radiobuttongroup to change 2D <-> 3D-Plot. ;  ; TGLayoutHints * fDimlh;  layout hints for 2D-Plot RadioButton ;  ; TGComboBox * fErrorCombo;  Error combo box. ;  ; TH1 * fHist;  histogram object ;  ; TGCheckButton * fHistOnOff;  Draw a simple histogram with default options. ;  ; TGCheckButton * fMakeHBar;  Draw Horizontal Bar Chart. ;  ; TGNumberEntryField * fOffsetNumberEntry;  Shows the offset to the origin of the histogram. ;  ; TGComboBox * fPercentCombo;  Percentage of the Bar which is drawn in a different color. ;  ; Bool_t fSameOpt;  flag for option ""same"" ;  ; TGNumberEntryField * fSldMax;  Contains the maximum value of the x-Axis. ;  ; TGNumberEntryField * fSldMin;  Contains the minimum value of the x-Axis. ;  ; TGDoubleHSlider * fSlider;  Slider to set x-axis range. ;  ; TGTextEntry * fTitle;  histogram title input field ;  ; Int_t fTitlePrec;  font precision level ;  ; TGComboBox * fTypeCombo;  histogram type combo box ;  ;  Protected Attributes inherited from TGedFrame; Bool_t fAvoidSignal;  flag for executing slots ;  ; TList * fExtraTabs;  addtional tabs in ged editor ;  ; TGedEditor * fGedEditor;  manager of this frame ;  ; Bool_t fInit;  init flag for setting signals/slots ;  ; TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1Editor.html:34723,simpl,simple,34723,doc/master/classTH1Editor.html,https://root.cern,https://root.cern/doc/master/classTH1Editor.html,1,['simpl'],['simple']
Usability,"recatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TProof (const char *masterurl, const char *conffile=kPROOF_ConfFile, const char *confdir=kPROOF_ConfDir, Int_t loglevel=0, const char *alias=0, TProofMgr *mgr=0);  Create a PROOF environment. ;  ;  ~TProof () override;  Clean up PROOF environment. ;  ; Int_t ActivateWorker (const char *ord, Bool_t save=kTRUE);  Make sure that the worker identified by the ordinal number 'ord' is in the active list. ;  ; void AddChain (TChain *chain);  Add chain to data set. ;  ; Int_t AddDynamicPath (const char *libpath, Bool_t onClient=kFALSE, TList *wrks=0, Bool_t doCollect=kTRUE);  Add 'libpath' to the lib path search. ;  ; void AddFeedback (const char *name);  Add object to feedback list. ;  ; Int_t AddIncludePath (const char *incpath, Bool_t onClient=kFALSE, TList *wrks=0, Bool_t doCollect=kTRUE);  Add 'incpath' to the inc path search. ;  ; void AddInput (TObject *obj);  Add objects that might be needed during the processing of the selector (see Process()). ;  ; void AddInputData (TObject *obj, Bool_t push=kFALSE);  Add data objects that might be needed during the processing of the selector (see Process()). ;  ; Int_t Archive (const char *queryref, const char *url=0);  Send archive request for the query specified by ref. ;  ; Int_t Archive (Int_t query, const char *url);  Send archive request for the qry-th query in fQueries. ;  ; void Browse (TBrowser *b) override;  Build the PROOF's structure in the browser. ;  ; virtual Bool_t CancelStagingDataSet (const char *dataset);  Cancels a dataset staging request. ;  ; void cd (Int_t id=-1);  Set session with 'id' the default one. ;  ; Int_t CleanupSession (const char *sessiontag);  Send ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:3182,feedback,feedback,3182,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['feedback'],['feedback']
Usability,"recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:26553,learn,learning,26553,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['learn'],['learning']
Usability,"red quantities X, Y, Z and T can always be visualized by a four-dimensional histogram or scatter-plot; its representation on the line-printer is not particularly satisfactory, except for sparse data. If T is an unknown (but single-valued) approximate function of X,Y,Z this function is displayed by a profile3D histogram with much better precision than by a scatter-plot.; The following formulae show the cumulated contents (capital letters) and the values displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 2; H(I,J,K) = sum T E(I,J,K) = sum T; l(I,J,K) = sum l L(I,J,K) = sum l; h(I,J,K) = H(I,J,K)/L(I,J,K) s(I,J,K) = sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2); e(I,J,K) = s(I,J,K)/sqrt(L(I,J,K)); In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell) e(I,J,K) is computed from the average of the s(I,J,K) for all cells, if the static function TProfile3D::Approximate has been called. This simple/crude approximation was suggested in order to keep the cell during a fit operation. But note that this approximation is not the default behaviour.; Example of a profile3D histogram {; auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; auto hprof3d = new TProfile3D(""hprof3d"",""Profile of pt versus px, py and pz"",40,-4,4,40,-4,4,40,0,20);; Double_t px, py, pz, pt;; TRandom3 r(0);; for ( Int_t i=0; i<25000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; pt = r.Landau(0,1);; hprof3d->Fill(px,py,pz,pt,1);; }; hprof3d->Draw();; }; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TCanvasThe Canvas class.Definition TCanvas.h:23; TProfile3D::TProfile3DTProfile3D()Default constructor for Profile3D histograms.Definition TProfile3D.cxx:76; TRandom3Random number generator class based on M.Definition TRandom3.h:27",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:1546,simpl,simple,1546,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,1,['simpl'],['simple']
Usability,"redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can un",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:19203,undo,undo,19203,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,6,['undo'],['undo']
Usability,"ree * ; dt . ). private . The AdaBoost implementation. ; a new training sample is generated by weighting events that are misclassified by the decision tree. The weight applied is \( w = \frac{(1-err)}{err} \) or more general: \( w = (\frac{(1-err)}{err})^\beta \) where \(err\) is the fraction of misclassified events in the tree ( <0.5 assuming demanding the that previous selection was better than random guessing) and ""beta"" being a free parameter (standard: beta = 1) that modifies the boosting. ; Definition at line 1845 of file MethodBDT.cxx. ◆ AdaBoostR2(). Double_t TMVA::MethodBDT::AdaBoostR2 ; (; std::vector< const TMVA::Event * > & ; eventSample, . DecisionTree * ; dt . ). private . Adaption of the AdaBoost to regression problems (see H.Drucker 1997). ; Definition at line 2192 of file MethodBDT.cxx. ◆ AdaCost(). Double_t TMVA::MethodBDT::AdaCost ; (; std::vector< const TMVA::Event * > & ; eventSample, . DecisionTree * ; dt . ). private . The AdaCost boosting algorithm takes a simple cost Matrix (currently fixed for all events... later could be modified to use individual cost matrices for each events as in the original paper... ; true_signal true_bkg; ----------------------------------; sel_signal | Css Ctb_ss Cxx.. in the range [0,1]; sel_bkg | Cts_sb Cbb; and takes this into account when calculating the mis class. cost (former: error fraction): err = sum_events ( weight* y_true*y_sel * beta(event) . Definition at line 2023 of file MethodBDT.cxx. ◆ AddWeightsXMLTo(). void TMVA::MethodBDT::AddWeightsXMLTo ; (; void * ; parent); const. virtual . Write weights to XML. ; Implements TMVA::MethodBase.; Definition at line 2309 of file MethodBDT.cxx. ◆ ApplyPreselectionCuts(). Double_t TMVA::MethodBDT::ApplyPreselectionCuts ; (; const Event * ; ev). private . Apply the preselection cuts before even bothering about any Decision Trees in the GetMVA . ; . --> -1 for background +1 for Signal ; Definition at line 3132 of file MethodBDT.cxx. ◆ Bagging(). Double_t TMVA::MethodB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:43267,simpl,simple,43267,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['simpl'],['simple']
Usability,"ree header request. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddOutput (TList *out) override;  Incorporate output list (may not be used in this class). ;  ; Int_t AddOutputObject (TObject *obj) override;  Incorporate output object (may not be used in this class). ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; Long64_t DrawSelect (TDSet *set, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSlave.html:1551,feedback,feedback,1551,doc/master/classTProofPlayerSlave.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSlave.html,1,['feedback'],['feedback']
Usability,"ree.C Copy a subset of a Tree to a new Tree ;  copytree2.C Copy a subset of a Tree to a new Tree, one branch in a separate file ;  copytree3.C Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries ;  drawsparse.C Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord ;  h1analysis.C Example of analysis class for the H1 data ;  h1analysis.h;  h1analysisProxy.CExample of analysis class for the H1 data using code generated by MakeProxy ;  h1analysisProxy.h;  h1analysisProxyCut.C;  h1analysisTreeReader.C;  h1analysisTreeReader.h;  h1chain.C Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed ;  hsimpleProxy.C ;  hsimpleProxyDriver.C This is the driver of the hsimpleProxy example It provides the infrastructure to run that code on an ntuple To be run from the tutorials directory ;  hsimpleReader.C TTreeReader simplest example ;  htest.C Save histograms in Tree branches ;  hvector.C Write and read STL vectors in a tree ;  JetEvent.cxx;  JetEvent.h;  jets.CUsage of a Tree using the JetEvent class ;  ntuple1.C Simple tree analysis ;  parallelcoord.C Script illustrating the use of the TParalleCoord class ;  parallelcoordtrans.C Use of transparency with ||-Coord ;  printSizes.C This macro can be used to get aggregate information on the size take on disk or in memory by the various branches in a TTree ;  run_h1analysis.C Macro driving the analysis can specify file name and type ;  spider.C TSpider example ;  staff.C Create a plot of the data in cernstaff.root To create cernstaff.root, execute tutorial $ROOTSYS/tutorials/tree/cernbuild.C ;  tcl.C How to write a TClonesArray to a TTree ;  tree.C Display the Tree data structures ;  tree0.C Simple Event class example ;  tree1.C This example is a variant of hsimple.C but using a TTree instead of a TNtuple ;  tree2.C This example illustrates how to make a Tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:156231,simpl,simplest,156231,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,4,['simpl'],['simplest']
Usability,"ree.cxx:9374; TTree::InitializeBranchListsvoid InitializeBranchLists(bool checkLeafCount)Divides the top-level branches into two vectors: (i) branches to be processed sequentially and (ii) b...Definition TTree.cxx:5781; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::fClusterSizeLong64_t * fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.Definition TTree.h:104; TTree::fFlushedBytesLong64_t fFlushedBytesNumber of auto-flushed bytes.Definition TTree.h:89; TTree::SetPerfStatsvirtual void SetPerfStats(TVirtualPerfStats *perf)Set perf stats.Definition TTree.cxx:9329; TTree::GetVar2TTreeFormula * GetVar2()Definition TTree.h:568; TTree::fIMTTotBytesstd::atomic< Long64_t > fIMTTotBytes! Total bytes for the IMT flush basketsDefinition TTree.h:160; TTree::SetCacheLearnEntriesvirtual void SetCacheLearnEntries(Int_t n=10)Interface to TTreeCache to set the number of entries for the learning phase.Definition TTree.cxx:8865; TTree::SetBranchAddressInt_t SetBranchAddress(const char *bname, T *add, TBranch **ptr=nullptr)Definition TTree.h:637; TTree::SetTargetMemoryRatiovoid SetTargetMemoryRatio(Float_t ratio)Definition TTree.h:692; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::DebugInt_t Debug() constDefinition TTree.h:429; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::Mergevirtual Long64_t Merge(TCollection *list, Option_t *option="""")Merge the trees in the TList into this tree.Definition TTree.cxx:6890; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::DropBasketsvirtual void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:66717,learn,learning,66717,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['learn'],['learning']
Usability,"ree::SetEstimate. A possible recipee is to do; tree->SetEstimate(tree->GetEntries());; You must call SetEstimate if the expected number of selected rows; is greater than 10000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accomodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called comitting or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:85349,simpl,simple,85349,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,4,['simpl'],['simple']
Usability,"reeprotectedvirtual; Browse(TBrowser *b) overrideTNtuplevirtual; BuildIndex(const char *majorname, const char *minorname=""0"")TTreevirtual; BuildStreamerInfo(TClass *cl, void *pointer=nullptr, bool canOptimize=true)TTree; ChangeFile(TFile *file)TTreevirtual; CheckBranchAddressType(TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr)TTreeprotectedvirtual; CheckedHash()TObjectinline; Class()TNtuplestatic; Class_Name()TNtuplestatic; Class_Version()TNtupleinlinestatic; ClassName() constTObjectvirtual; Clear(Option_t *option="""") overrideTNamedvirtual; Clone(const char *newname="""") const overrideTNamedvirtual; CloneTree(Long64_t nentries=-1, Option_t *option="""") overrideTNtuplevirtual; Compare(const TObject *obj) const overrideTNamedvirtual; TNamed::Copy(TObject &named) const overrideTNamedvirtual; TAttLine::Copy(TAttLine &attline) constTAttLine; TAttFill::Copy(TAttFill &attfill) constTAttFill; TAttMarker::Copy(TAttMarker &attmarker) constTAttMarker; CopyAddresses(TTree *, bool undo=false)TTreevirtual; CopyEntries(TTree *tree, Long64_t nentries=-1, Option_t *option="""", bool needCopyAddresses=false)TTreevirtual; CopyTree(const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)TTreevirtual; CreateBasket(TBranch *)TTreevirtual; Debug() constTTreeinline; DeclFileName()TNtupleinlinestatic; Delete(Option_t *option="""") overrideTTreevirtual; DirectoryAutoAdd(TDirectory *)TTreevirtual; DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2)TAttLine; DistancetoPrimitive(Int_t px, Int_t py)TObjectvirtual; DoError(int level, const char *location, const char *fmt, va_list va) constTObjectprotectedvirtual; Draw(Option_t *opt) overrideTTreeinlinevirtual; Draw(const char *varexp, const TCut &selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)TTreevirtual; Draw(const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firsten",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple-members.html:4230,undo,undo,4230,doc/master/classTNtuple-members.html,https://root.cern,https://root.cern/doc/master/classTNtuple-members.html,1,['undo'],['undo']
Usability,"ref=""http://www.cplusplus.com/reference/random/ranlux48/"">std::ranlux48</a>). The drawback of this generator is its; 58slow generation time.; 59- TRandom2 is based on the Tausworthe generator of L'Ecuyer, and it has the advantage; 60of being fast and using only 3 words (of 32 bits) for the state. The period however is not impressively long, it is; 6110**26.; 62 ; 63Using the template TRandomGen class (template on the contained Engine type), it is possible to add any generator based; 64on the standard C++ random library (see the C++ <a href=""http://www.cplusplus.com/reference/random/"">random</a>; 65documentation.) or different variants of the MIXMAX generator using the ROOT::Math::MixMaxEngine. Some of the listed; 66generator above (e.g. TRandomMixMax256 or TRandomMT64) are convenient typedef's of generator built using the template; 67TRandomGen class.; 68 ; 69Please note also that this class (TRandom) implements also a very simple generator (linear congruential) with period =; 70\f$10^9\f$, known to have defects (the lower random bits are correlated) and it is failing the majority of the random; 71number generator tests. Therefore it should NOT be used in any statistical study.; 72 ; 73The following table shows some timings (in nanoseconds/call); 74for the random numbers obtained using a macbookpro 2.6 GHz Intel Core i7 CPU:; 75 ; 76 ; 77- TRandom 3 ns/call (but this is a very BAD Generator, not to be used); 78- TRandom2 5 ns/call; 79- TRandom3 5 ns/call; 80- ::TRandomMixMax 6 ns/call; 81- ::TRandomMixMax17 6 ns/call; 82- ::TRandomMT64 9 ns/call; 83- ::TRandomMixMax256 10 ns/call; 84- ::TRandomRanluxpp 14 ns/call; 85- ::TRandom1 80 ns/call; 86- ::TRandomRanlux48 250 ns/call; 87 ; 88The following methods are provided to generate random numbers distributed according to some basic distributions:; 89 ; 90- Exp(Double_t tau); 91- Integer(UInt_t imax); 92- Gaus(Double_t mean, Double_t sigma); 93- Rndm(); 94- Uniform(Double_t); 95- Landau(Double_t mean, Double_t sigma); 96-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRandom_8cxx_source.html:5385,simpl,simple,5385,doc/master/TRandom_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html,1,['simpl'],['simple']
Usability,"rence Guide ; .  . Loading...; Searching...; No Matches. Files ; Net tutorialsTutorials. ; Examples showing the net classes. . Files; file  authclient.C;  This macro should be run together with authserv.C to test authentication between two remote ROOT sessions. ;  ; file  authserv.C;  This macro should be run together with authclient.C to test authentication between two remote ROOT sessions. ;  ; file  fastMergeServer.C;  This script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block. ;  ; file  hclient.C;  Client program which creates and fills a histogram. ;  ; file  hcons.C;  Histogram consumer script. ;  ; file  hprod.C;  Histogram producer script. ;  ; file  hserv.C;  Server program which waits for two clients to connect. ;  ; file  hserv2.C;  This script shows how to make a simple iterative server that can accept connections while handling currently open connections. ;  ; file  parallelMergeClient.C;  Client program which creates and fills 2 histograms and a TTree. ;  ; file  parallelMergeServer.C;  This script shows how to make a simple iterative server that can accept connections while handling currently open connections. ;  ; file  parallelMergeTest.C;  ; file  pclient.C;  Client program to test parallel sockets. ;  ; file  pserv.C;  Server program to test parallel sockets. ;  ; file  spy.C;  Client program which allows the snooping of objects from a spyserv process. ;  ; file  spyserv.C;  Server program which allows clients, ""spies"", to connect and snoop objects. ;  ; file  TestAuth.C;  Macro test authentication methods stand alone. ;  ; file  testTUDPSocket.C;  As test echo server use udpserver.c in the same directory. ;  ; file  treeClient.C;  Client program which creates and fills 2 histograms and a TTree. ;  ; file  TUriTest.C;  Rudimentary TUri test macro. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__net.html:1189,simpl,simple,1189,doc/master/group__tutorial__net.html,https://root.cern,https://root.cern/doc/master/group__tutorial__net.html,1,['simpl'],['simple']
Usability,"rence to read object. ;  ; void ExtractReference (XMLNodePointer_t node, const void *ptr, const TClass *cl);  Analyze if node has ""ref"" attribute and register it to object map. ;  ; Int_t GetCompressionAlgorithm () const;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; void PerformPostProcessing ();  Function is converts TObject and TString structures to more compact representation. ;  ; void PerformPreProcessing (const TStreamerElement *elem, XMLNodePointer_t elemnode);  Function is unpack TObject and TString structures to be able read them from custom streamers of this objects. ;  ; TXMLStackObj * PopStack ();  Remove one level from xml stack. ;  ; Bool_t ProcessPointer (const void *ptr, XMLNodePointer_t node);  Add ""ptr"" attribute to node, if ptr is null or if ptr is pointer on object, which is already saved in buffer Automatically add ""ref"" attribute to node, where referenced object is stored. ;  ; TXMLStackObj * PushStack (XMLNodePointer_t current, Bool_t simple=kFALSE);  Add new level to xml stack. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; void SetXML (TXMLEngine *xml);  ; void ShiftStack (const char *info=nullptr);  Shift stack node to next. ;  ; TXMLStackObj * Stack (UInt_t depth=0);  ; XMLNodePointer_t StackNode ();  Return pointer on current xml node. ;  ; Bool_t VerifyAttr (XMLNodePointer_t node, const char *name, const char *value, const char *errinfo=nullptr);  Checks, that attribute of specified name exists and has specified value. ;  ; Bool_t VerifyElemNode (const TStreamerElement *elem);  Checks if stack ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferXML.html:40220,simpl,simple,40220,doc/master/classTBufferXML.html,https://root.cern,https://root.cern/doc/master/classTBufferXML.html,1,['simpl'],['simple']
Usability,"rent attributes. ; Definition at line 3499 of file TGraphPainter.cxx. ◆ PaintGrapHist(). void TGraphPainter::PaintGrapHist ; (; TGraph * ; theGraph, . Int_t ; npoints, . const Double_t * ; x, . const Double_t * ; y, . Option_t * ; chopt . ). overridevirtual . This is a service method used by THistPainter to paint 1D histograms. ; It is not used to paint TGraph.; Input parameters:. npoints : Number of points in X or in Y.; x[npoints] or x[0] : x coordinates or (xmin,xmax).; y[npoints] or y[0] : y coordinates or (ymin,ymax).; chopt : Option. The aspect of the histogram is done according to the value of the chopt. Option Description . ""R"" Graph is drawn horizontally, parallel to X axis. (default is vertically, parallel to Y axis).If option R is selected the user must give 2 values for Y (y[0]=YMIN and y[1]=YMAX) or N values for X, one for each channel. Otherwise the user must give, N values for Y, one for each channel or 2 values for X (x[0]=XMIN and x[1]=XMAX) . ""L"" A simple polyline between every points is drawn. . ""H"" An Histogram with equidistant bins is drawn as a polyline. . ""F"" An histogram with equidistant bins is drawn as a fill area. Contour is not drawn unless chopt='H' is also selected.. . ""N"" Non equidistant bins (default is equidistant). If N is the number of channels array X and Y must be dimensioned as follow: If option R is not selected (default) then the user must give (N+1) values for X (limits of channels) or N values for Y, one for each channel. Otherwise the user must give (N+1) values for Y (limits of channels). or N values for X, one for each channel . ""F1"" Idem as 'F' except that fill area base line is the minimum of the pad instead of Y=0. . ""F2"" Draw a Fill area polyline connecting the center of bins . ""C"" A smooth Curve is drawn. . ""*"" A Star is plotted at the center of each bin. . ""P"" Idem with the current marker. . ""P0"" Idem with the current marker. Empty bins also drawn. . ""B"" A Bar chart with equidistant bins is drawn as fill areas (Conto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPainter.html:46366,simpl,simple,46366,doc/master/classTGraphPainter.html,https://root.cern,https://root.cern/doc/master/classTGraphPainter.html,1,['simpl'],['simple']
Usability,"rent buttons' layout. ;  ; file  buttonTest.C;  This macro gives an example of how to set/change text button attributes. ;  ; file  calendar.C;  This macro gives an example of how to use html widget to display tabular data. ;  ; file  CPUMeter.C;  Simple macro showing capabilities of the TGSpeedo widget. ;  ; file  customContextMenu.C;  Example showing how to add a function to the class context menu. ;  ; file  customTH1Fmenu.C;  Example showing how to customize a context menu for a class. ;  ; file  drag_and_drop.C;  This tutorial illustrates how to use drag and drop within ROOT. ;  ; file  exec3.C;  Example of using signal/slot in TCanvas/TPad to get feedback about processed events. ;  ; file  exec_macro.C;  This utility macro executes the macro ""macro"" given as first argument and save a capture in a png file. ;  ; file  games.C;  This macro runs three ""games"" that each nicely illustrate the graphics capabilities of ROOT. ;  ; file  gtreeTableTest.C;  This TableTest class is a simple example of how to use a TGTreeTable. ;  ; file  guilabels.C;  This macro gives an example of how to create different kind of labels and the possibility to enable/disable them. ;  ; file  guitest.C;  Test program for ROOT native GUI classes Exactly like $ROOTSYS/test/guitest.cxx but using the new signal and slots communication mechanism. ;  ; file  guitest_playback.C;  This macro plays a recorded ROOT session showing how to perform various interactive GUI operations with the guitest.C macro While replaying the session, several temporary macros (guitest0xx.C) macros will be saved. ;  ; file  guiWithCLING.C;  A simple example of entering CLING commands and having the CLING output in a ROOT GUI application window. ;  ; file  iconAsXPMData.C;  A simple example of creating icon image from XPM data, included into the code. ;  ; file  listBox.C;  This macro gives an example of how to create a list box and how to set and use its multiple selection feature. ;  ; file  mditest.C;  GUI MDI feature",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__gui.html:1537,simpl,simple,1537,doc/master/group__tutorial__gui.html,https://root.cern,https://root.cern/doc/master/group__tutorial__gui.html,1,['simpl'],['simple']
Usability,replayer interface for a user.; TRecorderInactive Represents state of TRecorder after its creation; TRecorderPaused Represents state of TRecorder when paused; TRecorderRecording Represents state of TRecorder when recording events; TRecorderReplaying Represents state of TRecorder when replaying; TRecorderState Abstract class that defines interface for a state of recorder; TRedirectOutputGuard Exception safe output redirection; TRef Persistent Reference link to a TObject; TRefArray An array of references to TObjects; TRefArrayIter Object array iterator; TRefCnt ; TRefTable Table of referenced objects during an I/O operation; TRegexp Regular expression class; TRemoteObject A remote object; TResponseTable Generic Geant detector response table; TRint ROOT Interactive Application Interface; TRobustEstimator Minimum Covariance Determinant Estimator; TRolke ; TRootApplication ROOT native GUI application environment; TRootAuth client auth interface; TRootBrowser New ROOT Browser; TRootBrowserLite ROOT native GUI version of browser; TRootCanvas ROOT native GUI version of main window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TRuby Ruby/ROOT interface; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class ; TSQLColumnData Single SQL column data.; TSQLColumnInfo Summury infor,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:113872,pause,paused,113872,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['pause'],['paused']
Usability,"representations can be cumulated on the same plot. This technique allows seeing clearly where the clusters are on an individual axis but it does not give any hints about the correlations between the axes.; Avery simple technique allows to make the clusters appearing: Instead of painting solid lines we paint dotted lines. The cluttering of each individual line is reduced and the clusters show clearly as we can see on the next figure. The spacing between the dots is a parameter which can be adjusted in order to get the best results. Using dotted lines is a very simple method to reduce the cluttering. Interactivity is a very important aspect of the Parallel Coordinates plots. To really explore the data set it is essential to act directly with the events and the axes. For instance, changing the axes order may show clusters which were not visible in a different order. On the next figure the axes order has been changed interactively. We can see that many more clusters appear and all the “random spheres” we put in the data set are now clearly visible. Having moved the variables u,v,w after the variables x,y,z the correlation between these two sets of variables is clear also. Axis order is very important to show clusters. To pursue further data sets exploration we have implemented the possibility to define selections interactively. A selection is a set of ranges combined together. Within a selection, ranges along the same axis are combined with logical OR, and ranges on different axes with logical AND. A selection is displayed on top of the complete data set using its own color. Only the events fulfilling the selection criteria (ranges) are displayed. Ranges are defined interactively using cursors, like on the first axis on the figure. Several selections can be defined at the same time, each selection having its own color. Selections are set of ranges which can be defined interactively. Several selections can been defined. Each cluster is now clearly visible and the zone wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:614430,clear,clearly,614430,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['clear'],['clearly']
Usability,"request for the qry-th query in fQueries. ;  ; void Browse (TBrowser *b) override;  Build the PROOF's structure in the browser. ;  ; virtual Bool_t CancelStagingDataSet (const char *dataset);  Cancels a dataset staging request. ;  ; void cd (Int_t id=-1);  Set session with 'id' the default one. ;  ; Int_t CleanupSession (const char *sessiontag);  Send cleanup request for the session specified by tag. ;  ; virtual void ClearCache (const char *file=0);  Remove file from all file caches. ;  ; void ClearData (UInt_t what=kUnregistered, const char *dsname=0);  Remove files for the data directory. ;  ; virtual void ClearDataSetCache (const char *dataset=0);  Clear the content of the dataset cache, if any (matching 'dataset', if defined). ;  ; void ClearFeedback ();  Clear feedback list. ;  ; void ClearInput ();  Clear input object list. ;  ; void ClearInputData (const char *name);  Remove obj 'name' form the input data list;. ;  ; void ClearInputData (TObject *obj=0);  Remove obj form the input data list; if obj is null (default), clear the input data info. ;  ; Int_t ClearPackage (const char *package);  Remove a specific package. ;  ; Int_t ClearPackages ();  Remove all packages. ;  ; void Close (Option_t *option="""");  Close all open slave servers. ;  ; void CloseProgressDialog ();  Close progress dialog. ;  ; TDrawFeedback * CreateDrawFeedback ();  Draw feedback creation proxy. ;  ; void DataSetStatus (const char *msg, Bool_t status, Int_t done, Int_t total);  Send dataset preparation status. ;  ; Int_t DeactivateWorker (const char *ord, Bool_t save=kTRUE);  Remove the worker identified by the ordinal number 'ord' from the the active list. ;  ; void DeleteDrawFeedback (TDrawFeedback *f);  Delete draw feedback object. ;  ; void DeleteParameters (const char *wildcard);  Delete the input list parameters specified by a wildcard (e.g. ;  ; void Detach (Option_t *opt="""");  Detach this instance to its proofserv. ;  ; void DisableGoAsyn ();  Signal to disable related switches. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:4847,clear,clear,4847,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['clear'],['clear']
Usability,"ress()) {; 3399 tree->SetBranchAddress(branch->GetName(), (void*) branch->GetAddress());; 3400 TBranch* br = tree->GetBranch(branch->GetName());; 3401 if (br) {; 3402 if (br->IsA() != branch->IsA()) {; 3403 Error(; 3404 ""CopyAddresses"",; 3405 ""Branch kind mismatch between input tree '%s' and output tree '%s' for branch '%s': '%s' vs '%s'"",; 3406 tree->GetName(), br->GetTree()->GetName(), br->GetName(), branch->IsA()->GetName(),; 3407 br->IsA()->GetName());; 3408 }; 3409 // The copy does not own any object allocated by SetAddress().; 3410 // FIXME: We do too much here, br may not be a top-level branch.; 3411 if (br->InheritsFrom(TBranchElement::Class())) {; 3412 ((TBranchElement*) br)->ResetDeleteObject();; 3413 }; 3414 } else {; 3415 Warning(""CopyAddresses"", ""Could not find branch named '%s' in tree named '%s'"", branch->GetName(), tree->GetName());; 3416 }; 3417 } else {; 3418 tleaf->SetAddress(leaf->GetValuePointer());; 3419 }; 3420 }; 3421 }; 3422 ; 3423 if (undo &&; 3424 ( tree->IsA()->InheritsFrom(""TNtuple"") || tree->IsA()->InheritsFrom(""TNtupleD"") ); 3425 ) {; 3426 tree->ResetBranchAddresses();; 3427 }; 3428}; 3429 ; 3430namespace {; 3431 ; 3432 enum EOnIndexError { kDrop, kKeep, kBuild };; 3433 ; 3434 bool R__HandleIndex(EOnIndexError onIndexError, TTree *newtree, TTree *oldtree); 3435 {; 3436 // Return true if we should continue to handle indices, false otherwise.; 3437 ; 3438 bool withIndex = true;; 3439 ; 3440 if ( newtree->GetTreeIndex() ) {; 3441 if ( oldtree->GetTree()->GetTreeIndex() == nullptr ) {; 3442 switch (onIndexError) {; 3443 case kDrop:; 3444 delete newtree->GetTreeIndex();; 3445 newtree->SetTreeIndex(nullptr);; 3446 withIndex = false;; 3447 break;; 3448 case kKeep:; 3449 // Nothing to do really.; 3450 break;; 3451 case kBuild:; 3452 // Build the index then copy it; 3453 if (oldtree->GetTree()->BuildIndex(newtree->GetTreeIndex()->GetMajorName(), newtree->GetTreeIndex()->GetMinorName())) {; 3454 newtree->GetTreeIndex()->Append(oldtree->GetTree()-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:135608,undo,undo,135608,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['undo'],['undo']
Usability,"ressBar can be also added when the multithread (MT) mode is enabled.; ProgressBar is added after creating the dataframe object (df): ROOT::RDataFrame df(""tree"", ""file.root"");; ROOT::RDF::Experimental::AddProgressBar(df);; ROOT::RDF::Experimental::AddProgressBarvoid AddProgressBar(ROOT::RDF::RNode df)Add ProgressBar to a ROOT::RDF::RNode.Definition RDFHelpers.cxx:373; Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility For example, it can be called at any computational node, such as Filter or Define, not only the head node, with no change to the ProgressBar function itself (please see the Efficient analysis in Python section for appropriate usage in Python): ROOT::RDataFrame df(""tree"", ""file.root"");; auto df_1 = ROOT::RDF::RNode(df.Filter(""x>1""));; ROOT::RDF::Experimental::AddProgressBar(df_1);; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefinition InterfaceUtils.hxx:57; Examples of implemented progress bars can be seen by running Higgs to Four Lepton tutorial and Dimuon tutorial. Efficient analysis in Python; You can use RDataFrame in Python thanks to the dynamic Python/C++ translation of PyROOT. In general, the interface is the same as for C++, a simple example follows.; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""x > 10"").Sum(""y""); print(sum.GetValue()). User code in the RDataFrame workflow; C++ code; In the simple example that was shown above, a C++ expression is passed to the Filter() operation as a string (""x > 0""), even if we call the method from Python. Indeed, under the hood, the analysis computations run in C++, while Python is just the interface language.; To perform more complex operations that don't fit into a simple expression string, you can just-in-time compile C++ functions - via the C++ interpreter cling - and use those functions in an expression. See the following snippet for an example:; # JIT a C++ function from Python; ROOT.gInterpreter.Declare(""""""; bool myFilte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:79572,progress bar,progress bars,79572,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['progress bar'],['progress bars']
Usability,"ressBar can be also added when the multithread (MT) mode is enabled.; ProgressBar is added after creating the dataframe object (df): ROOT::RDataFrame df(""tree"", ""file.root"");; ROOT::RDF::Experimental::AddProgressBar(df);; ROOT::RDF::Experimental::AddProgressBarvoid AddProgressBar(ROOT::RDF::RNode df)Add ProgressBar to a ROOT::RDF::RNode.Definition RDFHelpers.cxx:373; Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility For example, it can be called at any computational node, such as Filter or Define, not only the head node, with no change to the ProgressBar function itself (please see the Efficient analysis in Python section for appropriate usage in Python): ROOT::RDataFrame df(""tree"", ""file.root"");; auto df_1 = ROOT::RDF::RNode(df.Filter(""x>1""));; ROOT::RDF::Experimental::AddProgressBar(df_1);; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefinition InterfaceUtils.hxx:57; Examples of implemented progress bars can be seen by running Higgs to Four Lepton tutorial and Dimuon tutorial. Working with missing values in the dataset; In certain situations a dataset might be missing one or more values at one or more of its entries. For example:. If the dataset is composed of multiple files and one or more files is missing one or more columns required by the analysis.; When joining different datasets horizontally according to some index value (e.g. the event number), if the index does not find a match in one or more other datasets for a certain entry. For example, suppose that column ""y"" does not have a value for entry 42:; +-------+---+---+; | Entry | x | y |; +-------+---+---+; | 42 | 1 | |; +-------+---+---+; If the RDataFrame application reads that column, for example if a Take() action was requested, the default behaviour is to throw an exception indicating that that column is missing an entry.; The following paragraphs discuss the functionalities provided by RDataFrame to work with missing values in the datas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:80994,progress bar,progress bars,80994,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['progress bar'],['progress bars']
Usability,"ression= 2.80 *; *............................................................................*; *Br 2 :x : x/F *; *Entries : 8460 : Total Size= 34451 bytes File Size = 28849 *; *Baskets : 2 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 3 :y : y/F *; *Entries : 8460 : Total Size= 34451 bytes File Size = 28757 *; *Baskets : 2 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 4 :z : z/F *; *Entries : 8460 : Total Size= 34451 bytes File Size = 30674 *; *Baskets : 2 : Basket Size= 32000 bytes Compression= 1.11 *; *............................................................................*; nok = 8460, fentries=8460; . ; ; #include ""TTree.h""; #include ""TFile.h""; #include ""TRandom.h""; #include ""TTree.h""; #include ""TTree.h""; ; Int_t Run, Event;; Float_t x,y,z;; ; void CreateParentTree() {; // create a simple TTree with 5 branches; // Two branches (""Run"" and ""Event"") will be used to index the Tree; TFile *f = new TFile(""treeparent.root"",""recreate"");; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&Run,""Run/I"");; T->Branch(""Event"",&Event,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) Run = 1;; else Run = 2;; Event = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; T->Print();; T->Write();; delete f;; }; void CreateFriendTree() {; // Open the file created by CreateParentTree; // Copy a subset of the TTree into a new TTree; // (see also tutorials copytree.C, copytree2.C and copytree3.C); // Create an index on the new TTree (""Run"",""Event""); // Write the new TTree (including its index); ; TFile *f = new TFile(""treeparent.root"");; TTree *T = (TTree*)f->Get(""T"");; TFile *ff = new TFile(""treefriend.root"",""recreate"");; TTree *TF = T->CopyTree(""z<10"");; TF->SetName(""TF"");; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/treefriend_8C.html:3796,simpl,simple,3796,doc/master/treefriend_8C.html,https://root.cern,https://root.cern/doc/master/treefriend_8C.html,1,['simpl'],['simple']
Usability,"retation and number of arguments are mapped to the constructor arguments of the class (after the name and title). . MyPdf(x,m,s) As above, but with an implicitly defined (unique) object name . Creating sets and lists (to be used as inputs above) . {a,b,c} Create RooArgSet or RooArgList (as determined by context) from given contents . Objects that are not created, are assumed to exist in the workspace Object creation expressions as shown above can be nested, e.g. one can do RooGaussian::g(x[-10,10],m[0],3); xDouble_t x[n]Definition legend1.C:17; mTMarker mDefinition textangle.C:8; to create a pdf and its variables in one go. This nesting can be applied recursively e.g. SUM::model( f[0.5,0,1] * RooGaussian::g( x[-10,10], m[0], 3] ),; RooChebychev::c( x, {a0[0.1],a1[0.2],a2[-0.3]} )); f#define f(i)Definition RSha256.hxx:104; creates the sum of a Gaussian and a Chebychev and all its variables.; A separate series of operator meta-type exists to simplify the construction of composite expressions meta-types in all capitals (SUM) create pdfs, meta types in lower case (sum) create functions. Expression Effect . SUM::name(f1*pdf1,f2*pdf2,pdf3] Create sum pdf name with value f1*pdf1+f2*pdf2+(1-f1-f2)*pdf3 . RSUM::name(f1*pdf1,f2*pdf2,pdf3] Create recursive sum pdf name with value f1*pdf1 + (1-f1)(f2*pdf2 + (1-f2)pdf3) . ASUM::name(f1*amp1,f2*amp2,amp3] Create sum pdf name with value f1*amp1+f2*amp2+(1-f1-f2)*amp3 where amplX are amplitudes of type RooAbsReal . sum::name(a1,a2,a3] Create sum function with value a1+a2+a3 . sum::name(a1*b1,a2*b2,a3*b 3] Create sum function with value a1*b1+a2*b2+a3*b3 . PROD::name(pdf1,pdf2] Create product of pdf with name with given input pdfs . PROD::name(pdf1|x,pdf2] Create product of conditional pdf pdf1 given x and pdf2 . prod::name(a,b,c] Create production function with value a*b*c . SIMUL::name(cat,a=pdf1,b=pdf2] Create simultaneous pdf index category cat. Make pdf1 to state a, pdf2 to state b . EXPR::name(<expr>,var,...] Create a generic p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFactoryWSTool.html:34289,simpl,simplify,34289,doc/master/classRooFactoryWSTool.html,https://root.cern,https://root.cern/doc/master/classRooFactoryWSTool.html,2,['simpl'],['simplify']
Usability,"return (1+Int_t(color));; }; ; //______________________________________________________________________________; void raytrace() {; raytracing = !raytracing;; if (gGeoManager && gPad) {; auto top = gGeoManager->GetTopVolume();; bool drawn = gPad->GetListOfPrimitives()->FindObject(top);; if (drawn) top->SetVisRaytrace(raytracing);; gPad->Modified();; gPad->Update();; }; }; ; //______________________________________________________________________________; void help() {; ; auto c =(TCanvas *) gROOT->GetListOfCanvases()->FindObject(""geom_help"");; if (c) {; c->Clear();; c->Update();; c->cd();; } else {; c = new TCanvas(""geom_help"",""Help to run demos"",200,10,700,600);; }; ; TPaveText *welcome = new TPaveText(.1,.8,.9,.97);; welcome->AddText(""Welcome to the new geometry package"");; welcome->SetTextFont(32);; welcome->SetTextColor(4);; welcome->SetFillColor(24);; welcome->Draw();; ; TPaveText *hdemo = new TPaveText(.05,.05,.95,.7);; hdemo->SetTextAlign(12);; hdemo->SetTextFont(52);; hdemo->AddText(""- Demo for building TGeo basic shapes and simple geometry. Shape parameters are"");; hdemo->AddText("" displayed in the right pad"");; hdemo->AddText(""- Click left mouse button to execute one demo"");; hdemo->AddText(""- While pointing the mouse to the pad containing the geometry, do:"");; hdemo->AddText(""- .... click-and-move to rotate"");; hdemo->AddText(""- .... press j/k to zoom/unzoom"");; hdemo->AddText(""- .... press l/h/u/i to move the view center around"");; hdemo->AddText(""- Click Ray-trace ON/OFF to toggle ray-tracing"");; hdemo->AddText(""- Use <View with x3d> from the <View> menu to get an x3d view"");; hdemo->AddText(""- .... same methods to rotate/zoom/move the view"");; hdemo->AddText(""- Execute box(1,8) to divide a box in 8 equal slices along X"");; hdemo->AddText(""- Most shapes can be divided on X,Y,Z,Rxy or Phi :"");; hdemo->AddText(""- .... root[0] <shape>(IAXIS, NDIV, START, STEP);"");; hdemo->AddText("" .... IAXIS = 1,2,3 meaning (X,Y,Z) or (Rxy, Phi, Z)"");; hdemo->AddText("" ..",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geodemo_8C.html:5899,simpl,simple,5899,doc/master/geodemo_8C.html,https://root.cern,https://root.cern/doc/master/geodemo_8C.html,1,['simpl'],['simple']
