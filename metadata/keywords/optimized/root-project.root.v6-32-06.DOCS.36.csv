quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Usability,"in; Python via ""import KF5.Config"".; * The bindings are loaded lazily, which limits the discoverability of the; content of the bindings.; * ``cppyy`` supports customization of the bindings via 'Pythonization' but; there is no automated way to load them. These issues are addressed by the CMake support. This is a blend of Python; packaging and CMake where CMake provides:. * Platform-independent scripting of the creation of a Python 'wheel' package; for the bindings.; * An facility for CMake-based projects to automate the entire bindings; generation process, including basic automated tests. .. note::. The JIT needs to resolve linker symbols in order to call them through; generated wrappers.; Thus, any classes, functions, and data that will be used in Python need; to be exported.; This is the default behavior on Mac and Linux, but not on Windows.; On that platform, use ``__declspec(dllexport)`` to explicitly export the; classes and function you expect to call.; CMake has simple `support for exporting all`_ C++ symbols. Python packaging; ----------------. Modern Python packaging usage is based on the 'wheel'. This is places the onus; on the creation of binary artifacts in the package on the distributor. In this; case, this includes the platform-dependent steps necessary to compile the .cpp; file. The generated package also takes advantage of the __init__.py load-time; mechanism to enhance the bindings:. * The bindings are rehosted in a ""native"" namespace so that C++ code from; KF5::Config appears in Python via ""import KF5.Config"".; * (TBD) Load Pythonizations. Both of these need/can use the output of the; :ref:`cppyy-generator <cppyy-generator>` (included in the package) as well as; other runtime support included in ``cppyy``. CMake usage; -----------. The CMake usage is via two modules:. * FindLibClang.cmake provides some bootstrap support needed to locate clang.; This is provided mostly as a temporary measure; hopefully upstream support; will allow this to be eliminate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:1571,simpl,simple,1571,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['simpl'],['simple']
Usability,"inatorTree`` is called by pass; manager before returning a reference to the desired pass. If your pass is capable of updating analyses if they exist (e.g.,; ``BreakCriticalEdges``, as described above), you can use the; ``getAnalysisIfAvailable`` method, which returns a pointer to the analysis if; it is active. For example:. .. code-block:: c++. if (DominatorSet *DS = getAnalysisIfAvailable<DominatorSet>()) {; // A DominatorSet is active. This code will update it.; }. Implementing Analysis Groups; ----------------------------. Now that we understand the basics of how passes are defined, how they are used,; and how they are required from other passes, it's time to get a little bit; fancier. All of the pass relationships that we have seen so far are very; simple: one pass depends on one other specific pass to be run before it can; run. For many applications, this is great, for others, more flexibility is; required. In particular, some analyses are defined such that there is a single simple; interface to the analysis results, but multiple ways of calculating them.; Consider alias analysis for example. The most trivial alias analysis returns; ""may alias"" for any alias query. The most sophisticated analysis a; flow-sensitive, context-sensitive interprocedural analysis that can take a; significant amount of time to execute (and obviously, there is a lot of room; between these two extremes for other implementations). To cleanly support; situations like this, the LLVM Pass Infrastructure supports the notion of; Analysis Groups. Analysis Group Concepts; ^^^^^^^^^^^^^^^^^^^^^^^. An Analysis Group is a single simple interface that may be implemented by; multiple different passes. Analysis Groups can be given human readable names; just like passes, but unlike passes, they need not derive from the ``Pass``; class. An analysis group may have one or more implementations, one of which is; the ""default"" implementation. Analysis groups are used by client passes just like other passes a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:35071,simpl,simple,35071,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"include(LLVMExternalProjectUtils). set(CLANG_PGO_TRAINING_DATA ""${CMAKE_CURRENT_SOURCE_DIR}"" CACHE PATH; ""The path to a lit testsuite containing samples for PGO and order file generation""; ); set(CLANG_PGO_TRAINING_DATA_SOURCE_DIR OFF CACHE STRING ""Path to source directory containing cmake project with source files to use for generating pgo data""); set(CLANG_PGO_TRAINING_DEPS """" CACHE STRING ""Extra dependencies needed to build the PGO training data.""). if(LLVM_BUILD_INSTRUMENTED); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/pgo-data/lit.site.cfg; ). add_lit_testsuite(generate-profraw ""Generating clang PGO data""; ${CMAKE_CURRENT_BINARY_DIR}/pgo-data/; EXCLUDE_FROM_CHECK_ALL; DEPENDS clang clear-profraw ${CLANG_PGO_TRAINING_DEPS}; ). add_custom_target(clear-profraw; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py clean ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_BINARY_DIR}/profiles/ profraw; COMMENT ""Clearing old profraw data""). if(NOT LLVM_PROFDATA); find_program(LLVM_PROFDATA llvm-profdata); endif(). if(NOT LLVM_PROFDATA); message(STATUS ""To enable merging PGO data LLVM_PROFDATA has to point to llvm-profdata""); else(); add_custom_target(generate-profdata; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py merge ${LLVM_PROFDATA} ${CMAKE_CURRENT_BINARY_DIR}/clang.profdata ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_BINARY_DIR}/profiles/; COMMENT ""Merging profdata""; DEPENDS generate-profraw); if (CLANG_PGO_TRAINING_DATA_SOURCE_DIR); llvm_ExternalProject_Add(generate-profraw-external ${CLANG_PGO_TRAINING_DATA_SOURCE_DIR}; USE_TOOLCHAIN EXLUDE_FROM_ALL NO_INSTALL DEPENDS generate-profraw); add_dependencies(generate-profdata generate-profraw-external); endif(); endif(); endif(). find_program(DTRACE dtrace); # TODO: Look into supporting this for the driver build. It will require changing; # the perf-helper.py file to understand to call `llvm` as `llvm clang`.; if(APPLE AND DTRACE AND N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt:751,clear,clear-profraw,751,interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,3,"['Clear', 'clear']","['Clearing', 'clear-profraw']"
Usability,"include`` directives for headers that they actually depend on. As with the problem of conflicting definitions, this only affects unlucky users who don't happen to include headers in the right order. With modules, the headers of a particular module will be parsed in isolation, so the module may fail to build if there are missing includes. **Headers that vend multiple APIs at different times**; Some systems have headers that contain a number of different kinds of API definitions, only some of which are made available with a given include. For example, the header may vend ``size_t`` only when the macro ``__need_size_t`` is defined before that header is included, and also vend ``wchar_t`` only when the macro ``__need_wchar_t`` is defined. Such headers are often included many times in a single translation unit, and will have no include guards. There is no sane way to map this header to a submodule. One can either eliminate the header (e.g., by splitting it into separate headers, one per actual API) or simply ``exclude`` it in the module map. To detect and help address some of these problems, the ``clang-tools-extra`` repository contains a ``modularize`` tool that parses a set of given headers and attempts to detect these problems and produce a report. See the tool's in-source documentation for information on how to check your system or library headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no fun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:55653,simpl,simply,55653,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simply']
Usability,"includes functions, constant global variables, and the null pointer.; Locally-invariant memory is memory that we know is invariant for the lifetime; of its SSA value, but not necessarily for the life of the program: for example,; the memory pointed to by ``readonly`` ``noalias`` parameters is known-invariant; for the duration of the corresponding function call. Given Mod/Ref information; ``MRI`` for a memory location ``Loc``, ``MRI`` can be refined with a statement; like ``MRI &= AA.getModRefInfoMask(Loc);``. Another useful idiom is; ``isModSet(AA.getModRefInfoMask(Loc))``; this checks to see if the given; location can be modified at all. For convenience, there is also a method; ``pointsToConstantMemory(Loc)``; this is synonymous with; ``isNoModRef(AA.getModRefInfoMask(Loc))``. .. _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref information for function; calls. The ``doesNotAccessMemory`` method returns true for a function if the; analysis can prove that the function never reads or writes to memory, or if the; function only reads from constant memory. Functions with this property are; side-effect free and only depend on their input arguments, allowing them to be; eliminated if they form common subexpressions or be hoisted out of loops. Many; common functions behave this way (e.g., ``sin`` and ``cos``) but many others do; not (e.g., ``acos``, which modifies the ``errno`` variable). The ``onlyReadsMemory`` method returns true for a function if analysis can prove; that (at most) the function only reads from non-volatile memory. Functions with; this property are side-effect free, only depending on their input arguments and; the state of memory when they are called. This property allows calls to these; functions to be eliminated and moved around, as long as there is no store; instruction that changes the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:8359,simpl,simple,8359,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['simpl'],['simple']
Usability,"indows. 1. Download binary win32 build like https://cef-builds.spotifycdn.com/cef_binary_95.7.12%2Bg99c4ac0%2Bchromium-95.0.4638.54_windows32.tar.bz2. 2. Extract in directory without spaces like `C:\Soft\cef`. 3. Modify `cmake/cef_variables.cmake` to set dynamic linking, replace ""/MT"" by ""/MD"" in approx line 389. 4. Start ""x86 Native tools Command Prompt for VS 2019"". Do:; ~~~; $ cd C:\Soft\cef; $ mkdir build; $ cd build; $ cmake -G""Visual Studio 16 2019"" -A Win32 -Thost=x64 ..; $ cmake --build . --config Release --target libcef_dll_wrapper; ~~~. 5. Before compiling ROOT, `set CEF_ROOT=C:\Soft\cef` variable. ## Using plain CEF in ROOT batch mode on Linux. Default CEF builds, provided by [https://cef-builds.spotifycdn.com/index.html](https://cef-builds.spotifycdn.com/index.html), do; not include support of Ozone framework, which the only support headless mode in CEF. To run ROOT in headless (or batch) made with such CEF distribution,; one can use `Xvfb` server. Most simple way is to use `xvfb-run` utility like:. ~~~; $ xvfb-run --server-args='-screen 0, 1024x768x16' root.exe -l --web=cef $ROOTSYS/tutorials/rcanvas/rline.cxx -q; ~~~. Or run `Xvfb` before starting ROOT:. ~~~; $ Xvfb :99 &; $ export DISPLAY=:99; $ root.exe -l --web=cef $ROOTSYS/tutorials/rcanvas/rline.cxx -q; ~~~. ## Compile CEF with ozone support. Since March 2019 one can compile [CEF without X11](https://bitbucket.org/chromiumembedded/cef/issues/2296/), but such builds not provided.; Therefore to be able to use real headless mode in CEF, one should compile it from sources.; On [CEF build tutorial](https://bitbucket.org/chromiumembedded/cef/wiki/AutomatedBuildSetup.md) one can find complete compilation documentation.; Several Ubuntu distributions are supported by CEF, all others may require extra work. Once all depndencies are installed,; CEF with ozone support can be compiled with following commands:. ~~~; $ export GN_DEFINES=""is_official_build=true use_sysroot=true use_allocator=none symbol_level=1 i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/Readme.md:2774,simpl,simple,2774,gui/cefdisplay/Readme.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/Readme.md,1,['simpl'],['simple']
Usability,"ine XX``"" idiom to prevent multiple; inclusion. If a buffer does, subsequent includes can be ignored if the; ""``XX``"" macro is defined. .. _TokenLexer:. The ``TokenLexer`` class; ------------------------. The ``TokenLexer`` class is a token provider that returns tokens from a list of; tokens that came from somewhere else. It typically used for two things: 1); returning tokens from a macro definition as it is being expanded 2) returning; tokens from an arbitrary buffer of tokens. The later use is used by; ``_Pragma`` and will most likely be used to handle unbounded look-ahead for the; C++ parser. .. _MultipleIncludeOpt:. The ``MultipleIncludeOpt`` class; --------------------------------. The ``MultipleIncludeOpt`` class implements a really simple little state; machine that is used to detect the standard ""``#ifndef XX`` / ``#define XX``""; idiom that people typically use to prevent multiple inclusion of headers. If a; buffer uses this idiom and is subsequently ``#include``'d, the preprocessor can; simply check to see whether the guarding condition is defined or not. If so,; the preprocessor can completely ignore the include of the header. .. _Parser:. The Parser Library; ==================. This library contains a recursive-descent parser that polls tokens from the; preprocessor and notifies a client of the parsing progress. Historically, the parser used to talk to an abstract ``Action`` interface that; had virtual methods for parse events, for example ``ActOnBinOp()``. When Clang; grew C++ support, the parser stopped supporting general ``Action`` clients --; it now always talks to the :ref:`Sema library <Sema>`. However, the Parser; still accesses AST objects only through opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents of these; wrappers. .. _AST:. The AST Library; ===============. .. _ASTPhilosophy:. Design philosophy; -----------------. Immutability; ^^^^^^^^^^^^. Clang AST nodes (types, declarations, state",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:56630,simpl,simply,56630,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability,"ine arguments, we need to tell the; system which ones we want, and what type of arguments they are. The CommandLine; library uses a declarative syntax to model command line arguments with the; global variable declarations that capture the parsed values. This means that; for every command line option that you would like to support, there should be a; global variable declaration to capture the result. For example, in a compiler,; we would like to support the Unix-standard '``-o <filename>``' option to specify; where to put the output. With the CommandLine library, this is represented like; this:. .. _scalars arguments:; .. _here:. .. code-block:: c++. cl::opt<string> OutputFilename(""o"", cl::desc(""Specify output filename""), cl::value_desc(""filename""));. This declares a global variable ""``OutputFilename``"" that is used to capture the; result of the ""``o``"" argument (first parameter). We specify that this is a; simple scalar option by using the ""``cl::opt``"" template (as opposed to the; ""``cl::list``"" template), and tell the CommandLine library that the data; type that we are parsing is a string. The second and third parameters (which are optional) are used to specify what to; output for the ""``-help``"" option. In this case, we get a line that looks like; this:. ::. USAGE: compiler [options]. OPTIONS:; -h - Alias for -help; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename. Because we specified that the command line option should parse using the; ``string`` data type, the variable declared is automatically usable as a real; string in all contexts that a normal C++ string object may be used. For; example:. .. code-block:: c++. ...; std::ofstream Output(OutputFilename.c_str());; if (Output.good()) ...; ... There are many different options that you can use to customize the command line; option handling library, but the above example shows the general interface to; these options. The options can be specified in any order, and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:5286,simpl,simple,5286,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"ine frame to; be available in the continuation function. This frame is stored as a tail to the; `async context`. Every suspend point takes an `context projection function` argument which; describes how-to obtain the continuations `async context` and every suspend; point has an associated `resume function` denoted by the; `llvm.coro.async.resume` intrinsic. The coroutine is resumed by calling this; `resume function` passing the `async context` as the one of its arguments; argument. The `resume function` can restore its (the caller's) `async context`; by applying a `context projection function` that is provided by the frontend as; a parameter to the `llvm.coro.suspend.async` intrinsic. .. code-block:: c. // For example:; struct async_context {; struct async_context *caller_context;; ...; }. char *context_projection_function(struct async_context *callee_ctxt) {; return callee_ctxt->caller_context;; }. .. code-block:: llvm. %resume_func_ptr = call ptr @llvm.coro.async.resume(); call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function. The frontend should provide a `async function pointer` struct associated with; each async coroutine by `llvm.coro.id.async`'s argument. The initial size and; alignment of the `async context` must be provided as arguments to the; `llvm.coro.id.async` intrinsic. Lowering will update the size entry with the; coroutine frame requirements. The frontend is responsible for allocating the; memory for the `async context` but can use the `async function pointer` struct; to obtain the required size. .. code-block:: c. struct async_function_pointer {; uint32_t relative_function_pointer_to_async_impl;; uint32_t context_size;; }. Lowering will split an async coroutine into a ramp function and one resume; function per suspend point. How control-flow is passed between caller, suspension point, and back to; resume function is left up to the frontend. The suspend point takes a function and its ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:9244,resume,resume,9244,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ineType(""electron"", 1);` |; | `cat[""muon""] = 2;` | `cat.defineType(""muon"", 2);` |. See also [Category reference guide](https://root.cern.ch/doc/master/classRooCategory.html). ### Type-safe proxies for RooFit objects; RooFit's proxy classes have been modernised. The class `RooTemplateProxy` allows for access to other RooFit objects; similarly to a smart pointer. In older versions of RooFit, the objects held by *e.g.* `RooRealProxy` had to be; accessed like this:; RooAbsArg* absArg = realProxy.absArg();; RooAbsPdf* pdf = dynamic_cast<RooAbsPdf*>(absArg);; assert(pdf); // This *should* work, but the proxy doesn't have a way to check; pdf->fitTo(...);; That is, a `RooRealProxy` stores a pointer to a RooAbsArg, and this pointer has to be cast. There was no type; safety, *i.e.*, any object deriving from RooAbsArg could be stored in that proxy, and the user had to take care; of ensuring that types are correct.; Now, if one uses; RooTemplateProxy<RooAbsPdf> pdfProxy;; instead of; RooRealProxy realProxy;; in RooFit classes, the above code can be simplified to; pdfProxy->fitTo(...);. Check the [doxygen reference guide](https://root.cern.ch/doc/master/classRooTemplateProxy.html) for `RooTemplateProxy` for; more information on how to modernise old code. ### HistFactory. #### Switch default statistical MC errors to Poisson; When defining HistFactory samples with statistical errors from C++, e.g.; Sample background1( ""background1"", ""background1"", InputFile );; background1.ActivateStatError();; statistical MC errors now have Poisson instead of Gaussian constraints. This better reflects the uncertainty of the MC simulations.; This can be reverted as follows:; // C++:; Channel chan(""channel1"");; chan.SetStatErrorConfig( 0.05, ""Gauss"" );; // Within <Channel ... > XML:; <StatErrorConfig RelErrorThreshold=""0.05"" ConstraintType=""Gauss"" />. #### Less verbose HistFactory; HistFactory was very verbose, writing to the terminal with lots of `cout`. Now, many HistFactory messages are going; in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:4947,simpl,simplified,4947,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['simpl'],['simplified']
Usability,"ined behavior if the coroutine; executes a call to ``llvm.coro.suspend.retcon`` after resuming in any way. Coroutine Transformation Passes; ===============================; CoroEarly; ---------; The pass CoroEarly lowers coroutine intrinsics that hide the details of the; structure of the coroutine frame, but, otherwise not needed to be preserved to; help later coroutine passes. This pass lowers `coro.frame`_, `coro.done`_,; and `coro.promise`_ intrinsics. .. _CoroSplit:. CoroSplit; ---------; The pass CoroSplit builds coroutine frame and outlines resume and destroy parts; into separate functions. CoroElide; ---------; The pass CoroElide examines if the inlined coroutine is eligible for heap; allocation elision optimization. If so, it replaces; `coro.begin` intrinsic with an address of a coroutine frame placed on its caller; and replaces `coro.alloc` and `coro.free` intrinsics with `false` and `null`; respectively to remove the deallocation code.; This pass also replaces `coro.resume` and `coro.destroy` intrinsics with direct; calls to resume and destroy functions for a particular coroutine where possible. CoroCleanup; -----------; This pass runs late to lower all coroutine related intrinsics not replaced by; earlier passes. Attributes; ==========. coro_only_destroy_when_complete; -------------------------------. When the coroutine are marked with coro_only_destroy_when_complete, it indicates; the coroutine must reach the final suspend point when it get destroyed. This attribute only works for switched-resume coroutines now. Metadata; ========. '``coro.outside.frame``' Metadata; ---------------------------------. ``coro.outside.frame`` metadata may be attached to an alloca instruction to; to signify that it shouldn't be promoted to the coroutine frame, useful for; filtering allocas out by the frontend when emitting internal control mechanisms.; Additionally, this metadata is only used as a flag, so the associated; node must be empty. .. code-block:: text. %__coro_gro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:57110,resume,resume,57110,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ined if the object location; description becomes invalid between the two expression evaluations.*. A change of a thread's program location may not make a location description; invalid, yet may still render it as no longer meaningful. Accessing such a; location description, or using it as the object context or initial stack context; of an expression evaluation, may produce an undefined result. *For example, a location description may specify a register that no longer holds; the intended program object after a program location change. One way to avoid; such problems is to recompute location descriptions associated with threads when; their program locations change.*. .. _amdgpu-dwarf-operation-expressions:. A.2.5.4 DWARF Operation Expressions; +++++++++++++++++++++++++++++++++++. An operation expression is comprised of a stream of operations, each consisting; of an opcode followed by zero or more operands. The number of operands is; implied by the opcode. Operations represent a postfix operation on a simple stack machine. Each stack; entry can hold either a value or a location description. Operations can act on; entries on the stack, including adding entries and removing entries. If the kind; of a stack entry does not match the kind required by the operation and is not; implicitly convertible to the required kind (see; :ref:`amdgpu-dwarf-memory-location-description-operations`), then the DWARF; operation expression is ill-formed. Evaluation of an operation expression starts with an empty stack on which the; entries from the initial stack provided by the context are pushed in the order; provided. Then the operations are evaluated, starting with the first operation; of the stream. Evaluation continues until either an operation has an evaluation; error, or until one past the last operation of the stream is reached. The result of the evaluation is:. * If an operation has an evaluation error, or an operation evaluates an; expression that has an evaluation error, then the re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:64323,simpl,simple,64323,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simple']
Usability,"information like ""file not found"", ""insufficient; privileges"", etc. while other errors are much harder like ""out of space"", ""bad; disk sector"", or ""system call interrupted"". We'll call the first group ""*soft*""; errors and the second group ""*hard*"" errors. ``lib/Support`` must always attempt to minimize soft errors. This is a design; requirement because the minimization of soft errors can affect the granularity; and the nature of the interface. In general, if you find that you're wanting to; throw soft errors, you must review the granularity of the interface because it; is likely you're trying to implement something that is too low level. The rule; of thumb is to provide interface functions that **can't** fail, except when; faced with hard errors. For a trivial example, suppose we wanted to add an ""``OpenFileForWriting``""; function. For many operating systems, if the file doesn't exist, attempting to; open the file will produce an error. However, ``lib/Support`` should not simply; throw that error if it occurs because its a soft error. The problem is that the; interface function, ``OpenFileForWriting`` is too low level. It should be; ``OpenOrCreateFileForWriting``. In the case of the soft ""doesn't exist"" error,; this function would just create it and then open it for writing. This design principle needs to be maintained in ``lib/Support`` because it; avoids the propagation of soft error handling throughout the rest of LLVM.; Hard errors will generally just cause a termination for an LLVM tool so don't; be bashful about throwing them. Rules of thumb:. #. Don't throw soft errors, only hard errors. #. If you're tempted to throw a soft error, re-think the interface. #. Handle internally the most common normal/good/soft error conditions; so the rest of LLVM doesn't have to. No throw Specifications; -----------------------. None of the ``lib/Support`` interface functions may be declared with C++; ``throw()`` specifications on them. This requirement makes sure that the; com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:8504,simpl,simply,8504,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['simpl'],['simply']
Usability,"ing and objects drawing, one can provide number of URL parameters in address string like:. - file - name of the file, which will be automatically open with page loading; - files - array of file names for loading; - json - name of JSON file with stored ROOT object like histogram or canvas; - item - item name to be displayed; - opt - drawing option for the item; - items - array of items name to be displayed; - opts - array of drawing options for the items; - expand - item name(s) to be expanded in the hierarchy browser; - focus - item name to be focused on in the hierarchy browser; - title - set browser title; - dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; - layout - can be 'simple', 'flex', 'tabs', 'gridNxM', 'horizNMK', 'vertNMK'; - browser - layout of the browser 'fix' (default), 'float', 'no' (hidden), 'off' (fully disabled); - nobrowser - do not display file browser (same as browser=no); - float - display floating browser (same as browser=float); - status - configure status line 'no' (default), 'off' (completely disable), 'size'; - inject - name of extra JavaScript to load, see several examples in demo/ subdir; - optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; - palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); - interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; - noselect - hide file-selection part in the browser (only when file name is specified); - mathjax - use MathJax for latex output; - latex - 'off', 'symbols', 'normal', 'mathjax', 'alwaysmath' control of TLatex processor; - style - name of TStyle object to define global JSROOT style; - toolbar - show canvas tool buttons 'off', 'on' and 'popup', 'left' or 'right' for position, 'vert' for vertical; - divsize - fixed size in pixels for main div element like &dvisize=1500x800; - canvsize - default canvas size in pixels like &canvsize=1200x800; - optstat - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:1730,simpl,simple,1730,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['simpl'],['simple']
Usability,"ing at the body of the loop that the; container isn't being modified, which makes it easier to read the code and; understand what it does. While the second form of the loop is a few extra keystrokes, we do strongly; prefer it. ``#include <iostream>`` is Forbidden; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The use of ``#include <iostream>`` in library files is hereby **forbidden**,; because many common implementations transparently inject a `static constructor`_; into every translation unit that includes it. Note that using the other stream headers (``<sstream>`` for example) is not; problematic in this regard --- just ``<iostream>``. However, ``raw_ostream``; provides various APIs that are better performing for almost every use than; ``std::ostream`` style APIs. .. note::. New code should always use `raw_ostream`_ for writing, or the; ``llvm::MemoryBuffer`` API for reading files. .. _raw_ostream:. Use ``raw_ostream``; ^^^^^^^^^^^^^^^^^^^. LLVM includes a lightweight, simple, and efficient stream implementation in; ``llvm/Support/raw_ostream.h``, which provides all of the common features of; ``std::ostream``. All new code should use ``raw_ostream`` instead of; ``ostream``. Unlike ``std::ostream``, ``raw_ostream`` is not a template and can be forward; declared as ``class raw_ostream``. Public headers should generally not include; the ``raw_ostream`` header, but use forward declarations and constant references; to ``raw_ostream`` instances. Avoid ``std::endl``; ^^^^^^^^^^^^^^^^^^^. The ``std::endl`` modifier, when used with ``iostreams`` outputs a newline to; the output stream specified. In addition to doing this, however, it also; flushes the output stream. In other words, these are equivalent:. .. code-block:: c++. std::cout << std::endl;; std::cout << '\n' << std::flush;. Most of the time, you probably have no reason to flush the output stream, so; it's better to use a literal ``'\n'``. Don't use ``inline`` when defining a function in a class definition; ^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:55710,simpl,simple,55710,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['simpl'],['simple']
Usability,"ing multiple tests divided into logical blocks, one; or more ``CHECK:`` directives may inadvertently succeed by matching lines in a; later block. While an error will usually eventually be generated, the check; flagged as causing the error may not actually bear any relationship to the; actual source of the problem. In order to produce better error messages in these cases, the ""``CHECK-LABEL:``""; directive can be used. It is treated identically to a normal ``CHECK``; directive except that FileCheck makes an additional assumption that a line; matched by the directive cannot also be matched by any other check present in; ``match-filename``; this is intended to be used for lines containing labels or; other unique identifiers. Conceptually, the presence of ``CHECK-LABEL`` divides; the input stream into separate blocks, each of which is processed independently,; preventing a ``CHECK:`` directive in one block matching a line in another block.; If ``--enable-var-scope`` is in effect, all local variables are cleared at the; beginning of the block. For example,. .. code-block:: llvm. define %struct.C* @C_ctor_base(%struct.C* %this, i32 %x) {; entry:; ; CHECK-LABEL: C_ctor_base:; ; CHECK: mov [[SAVETHIS:r[0-9]+]], r0; ; CHECK: bl A_ctor_base; ; CHECK: mov r0, [[SAVETHIS]]; %0 = bitcast %struct.C* %this to %struct.A*; %call = tail call %struct.A* @A_ctor_base(%struct.A* %0); %1 = bitcast %struct.C* %this to %struct.B*; %call2 = tail call %struct.B* @B_ctor_base(%struct.B* %1, i32 %x); ret %struct.C* %this; }. define %struct.D* @D_ctor_base(%struct.D* %this, i32 %x) {; entry:; ; CHECK-LABEL: D_ctor_base:. The use of ``CHECK-LABEL:`` directives in this case ensures that the three; ``CHECK:`` directives only accept lines corresponding to the body of the; ``@C_ctor_base`` function, even if the patterns match lines found later in; the file. Furthermore, if one of these three ``CHECK:`` directives fail,; FileCheck will recover by continuing to the next block, allowing multiple test; fa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:22387,clear,cleared,22387,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['clear'],['cleared']
Usability,"ing the block ID we are describing, *not* the ``BLOCKINFO`` block; itself. The abbreviations defined in ``BLOCKINFO`` blocks receive abbreviation; IDs as described in `DEFINE_ABBREV`_. The ``BLOCKNAME`` record (code 2) can optionally occur in this block. The; elements of the record are the bytes of the string name of the block.; llvm-bcanalyzer can use this to dump out bitcode files symbolically. The ``SETRECORDNAME`` record (code 3) can also optionally occur in this block.; The first operand value is a record ID number, and the rest of the elements of; the record are the bytes for the string name of the record. llvm-bcanalyzer can; use this to dump out bitcode files symbolically. Note that although the data in ``BLOCKINFO`` blocks is described as ""metadata,""; the abbreviations they contain are essential for parsing records from the; corresponding blocks. It is not safe to skip them. .. _wrapper:. Bitcode Wrapper Format; ======================. Bitcode files for LLVM IR may optionally be wrapped in a simple wrapper; structure. This structure contains a simple header that indicates the offset; and size of the embedded BC file. This allows additional information to be; stored alongside the BC file. The structure of this file header is:. :raw-html:`<tt><blockquote>`; [Magic\ :sub:`32`, Version\ :sub:`32`, Offset\ :sub:`32`, Size\ :sub:`32`, CPUType\ :sub:`32`]; :raw-html:`</blockquote></tt>`. Each of the fields are 32-bit fields stored in little endian form (as with the; rest of the bitcode file fields). The Magic number is always ``0x0B17C0DE`` and; the version is currently always ``0``. The Offset field is the offset in bytes; to the start of the bitcode stream in the file, and the Size field is the size; in bytes of the stream. CPUType is a target-specific value that can be used to; encode the CPU of the target. .. _native object file:. Native Object File Wrapper Format; =================================. Bitcode files for LLVM IR may also be wrapped in a native obj",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:18047,simpl,simple,18047,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['simpl'],['simple']
Usability,"ing"" some volumes ""inside"" others.; Any volume is an un-positioned object in the sense that it defines only; a ""local frame"" (matching the one of its ""shape""). In order; to fully define the mother-daughter relationship between two volumes one; has to specify how the daughter will be positioned inside. This is; accomplished by defining a ""local geometrical transformation"" of; the daughter with respect to the mother coordinate system. These; transformations will be subsequently used in the example. **Q:** ""I see the lines defining the top level volume as in the previous example,; but what about the other volumes named REPLICA and ROOT?"". **A:** You will also notice that several other volumes are created; by using lines like:. ~~~{.cpp}; TGeoVolume *someVolume = gGeoManager->MakeXXX(""someName"",; ptrMedium, /* parameters coresponding to XXX ...*/); ~~~. In the method above XXX represent some shape name (Box, Tube,; etc.). This is just a simple way of creating a volume having a given; shape in one-step (see also section: ""Creating and Positioning; Volumes""). As for REPLICA and %ROOT volumes, they are just some; ""virtual volumes"" used for grouping and positioning together other; ""real volumes"". See ""Positioned Volumes (Nodes)"". The same; structure represented by (a real or) a virtual volume can be; ""replicated"" several times in the geometry. **Q:** ""Fine, so probably the real volumes are the ones composing the letters R,; O and T. Why one have to define so many volumes to make an R?"". **A:** Well, in real life some objects have much more complex shapes; that an ""R"". The modeller cannot just know all of them; the idea; is to make a complex object by using elementary building blocks that; have known shapes (called ""primitive shapes""). Gluing these; together in the appropriate way is the user responsibility. **Q:** ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode() that I do not understand."". **A:** A vol",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:9163,simpl,simple,9163,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"ing, static analysis, code generation,; etc.); Allow tight integration with IDEs; Use the LLVM 'Apache 2'; License. Internal Design and; Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++, and Objective C++; Conformance with C/C++/ObjC and their variants. Of course this is only a rough outline of the goals and features of; Clang. To get a true sense of what it is all about, see the Features section, which breaks; each of these down and explains them in more detail. Why?. Development of the new front-end was started out of a need; for a compiler that allows better diagnostics, better integration with; IDEs, a license that is compatible with commercial products, and a; nimble compiler that is easy to develop and maintain. All of these were; motivations for starting work on a new front-end that could; meet these needs. Current Status. Clang is considered to; be a production quality C, Objective-C, C++ and Objective-C++ compiler when; targeting any target supported by LLVM. As example, Clang is used in; production to build performance-critical software like Chrome or Firefox.; If you are looking for source analysis or source-to-source; transformation tools, Clang is probably a great solution for you. Please see; the C++ status page or the; C status page for more information about what; standard modes and features are supported. Get it and get involved!. Start by getting the code, building it, and; playing with it. This will show you the sorts of things we can do; today and will let you have the ""Clang experience"" first hand: hopefully; it will ""resonate"" with you. :); Once you've done that, please consider getting; involved in the Clang community. The Clang developers include numerous; volunteer contributors with a variety of backgrounds. If you're; interested in; following the development of Clang, signing up for a mailing list is a good; way to learn about how the project works. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html:2699,learn,learn,2699,interpreter/llvm-project/clang/www/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html,1,['learn'],['learn']
Usability,"ings. Other binders do not have this initial memory overhead, but do of course; occur an overhead per module, class, function, etc.; At scale, however, cppyy has some advantages: all binding is lazy (including; the option of automatic loading), standard classes are never duplicated, and; there is no additional ""per-module"" overhead.; Thus, eventually (depending on the number of classes bound, across how many; modules, what use fraction, etc.), this initial cost is recouped when; compared to other binders.; As a rule of thumb, if about 10% of classes are used, it takes several; hundreds of bound classes before the cppyy-approach is beneficial.; In High Energy Physics, from which it originated, cppyy is regularly used in; software stacks of many thousands of classes, where this advantage is very; important. `Distributing headers`; ----------------------. cppyy requires C/C++ headers to be available at run-time, which was never a; problem in the developer-centric world from which it originated: software; always had supported C++ APIs already, made available through header files,; and Python simply piggy-backed onto those.; JIT-ing code in those headers, which potentially picked up system headers; that were configured differently, was thus also never a problem.; Or rather, the same problem exists for C++, and configuration for C++ to; resolve potential issues translates transparently to Python. There are only two alternatives: precompile headers into LLVM bitcode and; distribute those or provide a restricted set of headers.; Precompiled headers (and modules) were never designed to be portable and; relocatable, however, thus that may not be the panacea it seems.; A restricted set of headers is some work, but cppyy can operate on abstract; interface classes just fine (including Python-side cross-inheritance). `Large deployment`; ------------------. The single biggest headache in maintaining an installation of Python; extension modules is that Python patch releases can bre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:9885,simpl,simply,9885,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['simpl'],['simply']
Usability,"insic and ``D`` be the convergent operation that; defines the token value used as the ``convergencectrl`` operand to ``U``. Two; threads execute converged dynamic instances of ``U`` if and only if:. 1. The token value in both threads was returned by converged dynamic; instances of ``D``, and,; 2. There is an integer *n* such that both threads execute ``U`` for the *n*'th time; with that token value. It is an error to omit the ``convergencectrl`` operand bundle on a; call to this intrinsic. If this intrinsic occurs in a basic block, then it must precede any other; convergent operation in the same basic block. .. _convergence_cycle_heart:. **Heart of a Cycle:**. If a :ref:`cycle <cycle-terminology>` ``C`` contains an occurrence ``H`` of; this intrinsic whose token operand is defined outside ``C``, then ``H`` is; called the heart of ``C``. .. note::. The static rules for cycles imply that a heart can occur only in the header; of a natural loop. This ensures that the heart closely represents the; intuitive notion of a loop iteration. If this restriction is relaxed, the; resulting semantics provides a new notion of ""cycle iteration"" even for; irreducible cycles. But this allows a natural loop to have a heart in a; node other than its header, which has interesting consequences on the; meaning of a loop iteration in terms of convergence. For now, we disallow; this situation since its practical application is very rare. .. _llvm.experimental.convergence.anchor:. ``llvm.experimental.convergence.anchor``; ----------------------------------------. .. code-block:: llvm. token @llvm.experimental.convergence.anchor() convergent readnone. This intrinsic produces an initial convergence token that is independent from; any ""outer scope"". The set of threads executing converged dynamic instances of; this intrinsic is implementation-defined. It is an error to pass a ``convergencectrl`` operand bundle at a; call to this intrinsic. .. note::. The expectation is that all threads within a g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:25906,intuit,intuitive,25906,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['intuit'],['intuitive']
Usability,"insic behaves as if there were a `coro.save` immediately preceding; the `coro.suspend` intrinsic. The second argument indicates whether this suspension point is `final`_.; The second argument only accepts constants. If more than one suspend point is; designated as final, the resume and destroy branches should lead to the same; basic blocks. Example (normal suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %resume; i8 1, label %cleanup]. Example (final suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. while.end:; %s.final = call i8 @llvm.coro.suspend(token none, i1 true); switch i8 %s.final, label %suspend [i8 0, label %trap; i8 1, label %cleanup]; trap:; call void @llvm.trap(); unreachable. Semantics:; """""""""""""""""""". If a coroutine that was suspended at the suspend point marked by this intrinsic; is resumed via `coro.resume`_ the control will transfer to the basic block; of the 0-case. If it is resumed via `coro.destroy`_, it will proceed to the; basic block indicated by the 1-case. To suspend, coroutine proceed to the; default label. If suspend intrinsic is marked as final, it can consider the `true` branch; unreachable and can perform optimizations that can take advantage of that fact. .. _coro.save:. 'llvm.coro.save' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.save(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.save``' marks the point where a coroutine need to update its; state to prepare for resumption to be considered suspended (and thus eligible; for resumption). It is illegal to merge two '``llvm.coro.save``' calls unless their; '``llvm.coro.suspend``' users are also merged. So '``llvm.coro.save``' is currently; tagged with the `no_merge` function attribute. Arguments:; """""""""""""""""""". The first argument points to a coroutine handle of the enclosing coroutine. Semantics:; """""""""""""""""""". Wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:51265,resume,resume,51265,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"install with sudo or within a virtual; environment. Under Windows, install Python for all users and then run; ``pip install psutil`` in an elevated command prompt. For more information on using the :program:`lit` tool, see ``llvm-lit --help``; or the :doc:`lit man page <CommandGuide/lit>`. Debugging Information tests; ---------------------------. To run debugging information tests simply add the ``cross-project-tests``; project to your ``LLVM_ENABLE_PROJECTS`` define on the cmake; command-line. Regression test structure; =========================. The LLVM regression tests are driven by :program:`lit` and are located in the; ``llvm/test`` directory. This directory contains a large array of small tests that exercise; various features of LLVM and to ensure that regressions do not occur.; The directory is broken into several sub-directories, each focused on a; particular area of LLVM. Writing new regression tests; ----------------------------. The regression test structure is very simple, but does require some; information to be set. This information is gathered via ``cmake``; and is written to a file, ``test/lit.site.cfg.py`` in the build directory.; The ``llvm/test`` Makefile does this work for you. In order for the regression tests to work, each directory of tests must; have a ``lit.local.cfg`` file. :program:`lit` looks for this file to determine; how to run the tests. This file is just Python code and thus is very; flexible, but we've standardized it for the LLVM regression tests. If; you're adding a directory of tests, just copy ``lit.local.cfg`` from; another directory to get running. The standard ``lit.local.cfg`` simply; specifies which files to look in for tests. Any directory that contains; only directories does not need the ``lit.local.cfg`` file. Read the :doc:`Lit; documentation <CommandGuide/lit>` for more information. Each test file must contain lines starting with ""RUN:"" that tell :program:`lit`; how to run it. If there are no RUN lines, :program:`lit`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:7397,simpl,simple,7397,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['simpl'],['simple']
Usability,"instance variable which is named, possibly implicitly, by the; ``@synthesize`` declaration. If the associated instance variable already; exists, then its ownership qualification must equal the ownership of the; property; otherwise, the instance variable is created with that ownership; qualification. A property of retainable object pointer type which is synthesized without a; source of ownership has the ownership of its associated instance variable, if it; already exists; otherwise, :when-revised:`[beginning Apple 3.1, LLVM 3.1]`; :revision:`its ownership is implicitly` ``strong``. Prior to this revision, it; was ill-formed to synthesize such a property. .. admonition:: Rationale. Using ``strong`` by default is safe and consistent with the generic ARC rule; about :ref:`inferring ownership <arc.ownership.inference.variables>`. It is,; unfortunately, inconsistent with the non-ARC rule which states that such; properties are implicitly ``assign``. However, that rule is clearly; untenable in ARC, since it leads to default-unsafe code. The main merit to; banning the properties is to avoid confusion with non-ARC practice, which did; not ultimately strike us as sufficient to justify requiring extra syntax and; (more importantly) forcing novices to understand ownership rules just to; declare a property when the default is so reasonable. Changing the rule away; from non-ARC practice was acceptable because we had conservatively banned the; synthesis in order to give ourselves exactly this leeway. Applying ``__attribute__((NSObject))`` to a property not of retainable object; pointer type has the same behavior it does outside of ARC: it requires the; property type to be some sort of pointer and permits the use of modifiers other; than ``assign``. These modifiers only affect the synthesized getter and; setter; direct accesses to the ivar (even if synthesized) still have primitive; semantics, and the value in the ivar will not be automatically released during; deallocation. .. _arc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:36331,clear,clearly,36331,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['clear'],['clearly']
Usability,"instruction selector. Note that; physical registers should have a short lifetime for good code generation, and; all physical registers are assumed dead on entry to and exit from basic blocks; (before register allocation). Thus, if you need a value to be live across basic; block boundaries, it *must* live in a virtual register. Call-clobbered registers; ^^^^^^^^^^^^^^^^^^^^^^^^. Some machine instructions, like calls, clobber a large number of physical; registers. Rather than adding ``<def,dead>`` operands for all of them, it is; possible to use an ``MO_RegisterMask`` operand instead. The register mask; operand holds a bit mask of preserved registers, and everything else is; considered to be clobbered by the instruction. Machine code in SSA form; ^^^^^^^^^^^^^^^^^^^^^^^^. ``MachineInstr``'s are initially selected in SSA-form, and are maintained in; SSA-form until register allocation happens. For the most part, this is; trivially simple since LLVM is already in SSA form; LLVM PHI nodes become; machine code PHI nodes, and virtual registers are only allowed to have a single; definition. After register allocation, machine code is no longer in SSA-form because there; are no virtual registers left in the code. .. _MachineBasicBlock:. The ``MachineBasicBlock`` class; -------------------------------. The ``MachineBasicBlock`` class contains a list of machine instructions; (:raw-html:`<tt>` `MachineInstr`_ :raw-html:`</tt>` instances). It roughly; corresponds to the LLVM code input to the instruction selector, but there can be; a one-to-many mapping (i.e. one LLVM basic block can map to multiple machine; basic blocks). The ``MachineBasicBlock`` class has a ""``getBasicBlock``"" method,; which returns the LLVM basic block that it comes from. .. _MachineFunction:. The ``MachineFunction`` class; -----------------------------. The ``MachineFunction`` class contains a list of machine basic blocks; (:raw-html:`<tt>` `MachineBasicBlock`_ :raw-html:`</tt>` instances). It; corresponds on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:21817,simpl,simple,21817,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"int** to consider; any options starting with ""``-``"" to be part of the **--args** option, not as; options to **bugpoint** itself. **--tool-args** *tool args*. Pass all arguments specified after **--tool-args** to the LLVM tool under test; (**llc**, **lli**, etc.) whenever it runs. You should use this option in the; following way:. .. code-block:: bash. bugpoint [bugpoint args] --tool-args -- [tool args]. The ""``--``"" right after the **--tool-args** option tells **bugpoint** to; consider any options starting with ""``-``"" to be part of the **--tool-args**; option, not as options to **bugpoint** itself. (See **--args**, above.). **--safe-tool-args** *tool args*. Pass all arguments specified after **--safe-tool-args** to the ""safe"" execution; tool. **--gcc-tool-args** *gcc tool args*. Pass all arguments specified after **--gcc-tool-args** to the invocation of; **gcc**. **--opt-args** *opt args*. Pass all arguments specified after **--opt-args** to the invocation of **opt**. **--disable-{dce,simplifycfg}**. Do not run the specified passes to clean up and reduce the size of the test; program. By default, **bugpoint** uses these passes internally when attempting to; reduce test programs. If you're trying to find a bug in one of these passes,; **bugpoint** may crash. **--enable-valgrind**. Use valgrind to find faults in the optimization phase. This will allow; bugpoint to find otherwise asymptomatic problems caused by memory; mis-management. **-find-bugs**. Continually randomize the specified passes and run them on the test program; until a bug is found or the user kills **bugpoint**. **-help**. Print a summary of command line options. **--input** *filename*. Open *filename* and redirect the standard input of the test program, whenever; it runs, to come from that file. **--load** *plugin*. Load the dynamic object *plugin* into **bugpoint** itself. This object should; register new optimization passes. Once loaded, the object will add new command; line options to enable variou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst:2502,simpl,simplifycfg,2502,interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,1,['simpl'],['simplifycfg']
Usability,"inted; to standard error, and the tool returns 1. USING MARKERS TO ANALYZE SPECIFIC CODE BLOCKS; ---------------------------------------------; :program:`llvm-mca` allows for the optional usage of special code comments to; mark regions of the assembly code to be analyzed. A comment starting with; substring ``LLVM-MCA-BEGIN`` marks the beginning of an analysis region. A; comment starting with substring ``LLVM-MCA-END`` marks the end of a region.; For example:. .. code-block:: none. # LLVM-MCA-BEGIN; ...; # LLVM-MCA-END. If no user-defined region is specified, then :program:`llvm-mca` assumes a; default region which contains every instruction in the input file. Every region; is analyzed in isolation, and the final performance report is the union of all; the reports generated for every analysis region. Analysis regions can have names. For example:. .. code-block:: none. # LLVM-MCA-BEGIN A simple example; add %eax, %eax; # LLVM-MCA-END. The code from the example above defines a region named ""A simple example"" with a; single instruction in it. Note how the region name doesn't have to be repeated; in the ``LLVM-MCA-END`` directive. In the absence of overlapping regions,; an anonymous ``LLVM-MCA-END`` directive always ends the currently active user; defined region. Example of nesting regions:. .. code-block:: none. # LLVM-MCA-BEGIN foo; add %eax, %edx; # LLVM-MCA-BEGIN bar; sub %eax, %edx; # LLVM-MCA-END bar; # LLVM-MCA-END foo. Example of overlapping regions:. .. code-block:: none. # LLVM-MCA-BEGIN foo; add %eax, %edx; # LLVM-MCA-BEGIN bar; sub %eax, %edx; # LLVM-MCA-END foo; add %eax, %edx; # LLVM-MCA-END bar. Note that multiple anonymous regions cannot overlap. Also, overlapping regions; cannot have the same name. There is no support for marking regions from high-level source code, like C or; C++. As a workaround, inline assembly directives may be used:. .. code-block:: c++. int foo(int a, int b) {; __asm volatile(""# LLVM-MCA-BEGIN foo"":::""memory"");; a += 42;; __asm vol",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:9038,simpl,simple,9038,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['simpl'],['simple']
Usability,"inter to the coroutine object and returns; `void`. Because the resume and destroy functions are shared across all suspend; points, suspend points must store the index of the active suspend in; the coroutine object, and the resume/destroy functions must switch over; that index to get back to the correct point. Hence the name of this; lowering. Pointers to the resume and destroy functions are stored in the coroutine; object at known offsets which are fixed for all coroutines. A completed; coroutine is represented with a null resume function. There is a somewhat complex protocol of intrinsics for allocating and; deallocating the coroutine object. It is complex in order to allow the; allocation to be elided due to inlining. This protocol is discussed; in further detail below. The frontend may generate code to call the coroutine function directly;; this will become a call to the ramp function and will return a pointer; to the coroutine object. The frontend should always resume or destroy; the coroutine using the corresponding intrinsics. Returned-Continuation Lowering; ------------------------------. In returned-continuation lowering, signaled by the use of; `llvm.coro.id.retcon` or `llvm.coro.id.retcon.once`, some aspects of; the ABI must be handled more explicitly by the frontend. In this lowering, every suspend point takes a list of ""yielded values""; which are returned back to the caller along with a function pointer,; called the continuation function. The coroutine is resumed by simply; calling this continuation function pointer. The original coroutine; is divided into the ramp function and then an arbitrary number of; these continuation functions, one for each suspend point. LLVM actually supports two closely-related returned-continuation; lowerings:. - In normal returned-continuation lowering, the coroutine may suspend; itself multiple times. This means that a continuation function; itself returns another continuation pointer, as well as a list of; yielded values. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:5200,resume,resume,5200,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thing you need to do with ROOT is install it, don't you ? Obtaining; the latest ROOT version is straightforward. Just seek the ""Pro"" version; on this webpage <http://root.cern.ch/downloading-root>.; You will find precompiled versions for the different architectures, or; the ROOT source code to compile yourself. Just pick up the flavour you; need and follow the installation instructions. **Let's dive into ROOT!**; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:4718,guid,guide,4718,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['guid'],['guide']
Usability,"ion `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i32 0, i32 2; store i32 %inc, ptr %inc.spill.addr; call void @print(i32 %n). ret ptr %frame; }. Outlined resume part of the coroutine will reside in function `f.resume`:. .. code-block:: llvm. define internal fastcc void @f.resume(ptr %frame.ptr.resume) {; entry:; %inc.spill.addr = getelementptr %f.frame, ptr %frame.ptr.resume, i64 0, i32 2; %inc.spill = load i32, ptr %inc.spill.addr, align 4; %inc = add i32 %inc.spill, 1; store i32 %inc, ptr %inc.spill.addr, align 4; tail call void @print(i32 %inc); ret void; }. Whereas function `f.destroy` will contain the cleanup code for the coroutine:. .. code-block:: llvm. define internal fastcc void @f.destroy(ptr %frame.ptr.destroy) {; entry:; tail call void @free(ptr %frame.ptr.destroy); ret void; }. Avoiding Heap Allocations; -------------------------. A particular coroutine usage pattern, which is illustrated by the `main`; function in the overview section, where a coroutine is created, manipulated and; destroyed by the same calling function, is common for coroutines implementing; RAII idiom and is suitable for allocation elision optimization which avoid; dynamic allocation by storing the coroutine frame as a static `alloca` in its; caller. In the entry block, we will call `coro.alloc`_ intrinsic that will return `true`; when dynamic allocation is required, and `false` i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:15710,resume,resume,15710,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ion in; ROOT and it is important to understand how it is constructed. The; example program is written as a named script. See ""Cling the C++; Interpreter"". Remember that the named script can be executed via. ``` {.cpp}; root[] .x example.C; ```. only if the filename (without extension) and the function entry point; are both the same. ![](pictures/02000202.jpg). We need to say a few words about the parent-children relationship; between the widgets before going through the real code. The widgets'; behaviors are based on this relationship. Every parent widget is; responsible for where the children are and it ensures all properties and; behavior for them. For example, if you want to hide several widgets, it; will be enough to hide their parent widget. Later you can show the; parent and the children will appear too. Writing your code you have to; specify the parent-child relationship. Usually in a child constructor; the address of the parent is passed as an argument. In general frames; are parents of simple widgets. In this example you will see how we; organize the parent-children relationship by using frame widgets in; addition to the canvas window and button widgets. Let's now go through the code of the `example.C`. The first lines include ROOT header files. The header file names are; almost always as the class names (**`TApplication`**, **`TF1`**,; **`TCanvas`**), but there are cases when similar classes are grouped; together in one header file: all frames are declared in `TGFrame.h`, all; buttons - in `TGButton.h`, etc. Our small example is based on an object; of the class `MyMainFrame`. ``` {.cpp}; new MyMainFrame(gClient->GetRoot(),200,200);; ```. The first parameter `gClient->GetRoot()` makes the initial connection to; the window server. It is a pointer to the root window of the screen,; which is obtained from ***`gClient`***. The next two parameters; initialize the width and height of the application window in pixels. Let; see what `MyMainFrame` is. The three argu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:4148,simpl,simple,4148,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"ion is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Gaussian; (the ""signal"") plus a parabolic function, the ""background"". - Lines *10-12*: Some make-up for the Canvas. In particular we want; that the parameters of the fit appear very clearly and nicely on the; plot. - Lines *20-25*: Define and initialise an instance of `TF1`. - Lines *27-31*: Define and fill a histogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:3542,simpl,simply,3542,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,1,['simpl'],['simply']
Usability,"ion is reading or writing a `ROOT::RVec` object from/to a ROOT file. We assume this is an; exceedingly rare case, as the ROOT interface typically used to manipulate `RVec`s is `RDataFrame`, and `RDataFrame` performs an on-the-fly; `RVec <-> std::vector` conversion rather than writing `RVec`s to disk. Note that, currently, `RVecs` written e.g. in a `TTree` cannot be read back; using certain ROOT interfaces (e.g. `TTreeReaderArray`, `RDataFrame` and the experimental `RNTuple`). All these limitations will be lifted in v6.26.; - Portable implementation of the RANLUX++ generator, see [RanluxppEngine](https://root.cern/doc/master/classROOT_1_1Math_1_1RanluxppEngine.html) and [our blog post](https://root.cern/blog/ranluxpp/). ## TMVA. - Introducing TMVA PyTorch Interface, a method to use PyTorch internally with TMVA for deep learning. This can be used as an alternative to PyKeras Interface for complex models providing more flexibility and power. ## RooFit Libraries. - Extension / updates of the doxygen reference guide.; - Allow for removing RooPlot from global directory management, see [RooPlot::AddDirectory](https://root.cern/doc/v624/classRooPlot.html#a47f7ba71dcaca30ad9ee295dee89c9b8); and [RooPlot::SetDirectory](https://root.cern/doc/v624/classRooPlot.html#a5938bc6d5c47d94c2f04fdcc10c1c026); - Hash-assisted finding of elements in RooWorkspace. Large RooWorkspace objects were slow in finding elements.; This was improved using a hash map.; - Stabilise RooStats::HypoTestInverter. It can now tolerate a few failed fits when conducting hypothesis tests.; This is relevant when a few points in a parameter scan don't converge due to numerical or model instabilities.; These points will be skipped, and HypoTestInverter can continue.; - Tweak pull / residual plots. ROOT automatically zoomed out a bit when a pull / residual plot is created. Now, the; axis range of the original plot is transferred to the residual plot, so the pulls can be drawn below the main plot. ### Massive speed",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:13909,guid,guide,13909,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['guid'],['guide']
Usability,"ion itself, but within; its entire cluster, since neighboring regions may be accessed via pointer; arithmetic. Region invalidation typically does even more than this, however. Because it; usually represents the complete escape of a region from the analyzer's model,; its *contents* must also be transitively invalidated. (For example, if a region; ``p`` of type ``int **`` is invalidated, the contents of ``*p`` and ``**p`` may; have changed as well.) The algorithm that traverses this transitive closure of; accessible regions is known as ClusterAnalysis, and is also used for finding; all live bindings in the store (in order to throw away the dead ones). The name; ""ClusterAnalysis"" predates the cluster-based organization of bindings, but; refers to the same concept: during invalidation and liveness analysis, all; bindings within a cluster must be treated in the same way for a conservative; model of program behavior. Default Bindings; ----------------. Most bindings in RegionStore are simple scalar values -- integers and pointers.; These are known as ""Direct"" bindings. However, RegionStore supports a second; type of binding called a ""Default"" binding. These are used to provide values to; all the elements of an aggregate type (struct or array) without having to; explicitly specify a binding for each individual element. When there is no Direct binding for a particular region, the store manager; looks at each super-region in turn to see if there is a Default binding. If so,; this value is used as the value of the original region. The search ends when; the base region is reached, at which point the RegionStore will pick an; appropriate default value for the region (usually a symbolic value, but; sometimes zero, for static data, or ""uninitialized"", for stack variables). .. code-block:: cpp. int manyInts[10];; manyInts[1] = 42; // Creates a Direct binding for manyInts[1].; print(manyInts[1]); // Retrieves the Direct binding for manyInts[1];; print(manyInts[0]); // There is no D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:4976,simpl,simple,4976,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,1,['simpl'],['simple']
Usability,"ion of the migration. If you want to contribute to LLVM; now, please use GitHub. For more information about the workflow of using GitHub; Pull Requests see our :ref:`GitHub <github-reviews>` documentation. To make sure the right people see your patch, please select suitable reviewers; and add them to your patch when requesting a review. Suitable reviewers are the; code owner (see CODE_OWNERS.txt) and other people doing work in the area your; patch touches. Github will normally suggest some reviewers based on rules or; people that have worked on the code before. If you are a new contributor, you; will not be able to select reviewers in such a way, in which case you can still; get the attention of potential reviewers by CC'ing them in a comment -- just; @name them. A reviewer may request changes or ask questions during the review. If you are; uncertain on how to provide test cases, documentation, etc., feel free to ask; for guidance during the review. Please address the feedback and re-post an; updated version of your patch. This cycle continues until all requests and comments; have been addressed and a reviewer accepts the patch with a `Looks good to me` or `LGTM`.; Once that is done the change can be committed. If you do not have commit; access, please let people know during the review and someone should commit it; on your behalf. If you have received no comments on your patch for a week, you can request a; review by 'ping'ing the GitHub PR with ""Ping"". The common courtesy 'ping' rate; is once a week. Please remember that you are asking for valuable time from other; professional developers. For more information on LLVM's code-review process, please see :doc:`CodeReview`. .. _commit_from_git:. For developers to commit changes from Git; -----------------------------------------. Once a patch is reviewed, you can select the ""Squash and merge"" button in the; GitHub web interface. You might need to rebase your change before pushing; it to the repo. LLVM currently has a li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst:4585,feedback,feedback,4585,interpreter/llvm-project/llvm/docs/Contributing.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst,1,['feedback'],['feedback']
Usability,"ion provides code conventions used when the target triple OS is; ``amdpal`` (see :ref:`amdgpu-target-triples`). .. _amdgpu-amdpal-code-object-metadata-section:. Code Object Metadata; ~~~~~~~~~~~~~~~~~~~~. .. note::. The metadata is currently in development and is subject to major; changes. Only the current version is supported. *When this document; was generated the version was 2.6.*. Code object metadata is specified by the ``NT_AMDGPU_METADATA`` note; record (see :ref:`amdgpu-note-records-v3-onwards`). The metadata is represented as Message Pack formatted binary data (see; [MsgPack]_). The top level is a Message Pack map that includes the keys; defined in table :ref:`amdgpu-amdpal-code-object-metadata-map-table`; and referenced tables. Additional information can be added to the maps. To avoid conflicts, any; key names should be prefixed by ""*vendor-name*."" where ``vendor-name``; can be the name of the vendor and specific vendor tool that generates the; information. The prefix is abbreviated to simply ""."" when it appears; within a map that has been added by the same *vendor-name*. .. table:: AMDPAL Code Object Metadata Map; :name: amdgpu-amdpal-code-object-metadata-map-table. =================== ============== ========= ======================================================================; String Key Value Type Required? Description; =================== ============== ========= ======================================================================; ""amdpal.version"" sequence of Required PAL code object metadata (major, minor) version. The current values; 2 integers are defined by *Util::Abi::PipelineMetadata(Major|Minor)Version*.; ""amdpal.pipelines"" sequence of Required Per-pipeline metadata. See; map :ref:`amdgpu-amdpal-code-object-pipeline-metadata-map-table` for the; definition of the keys included in that map.; =================== ============== ========= ======================================================================. .. .. table:: AMDPAL Code Object Pip",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:402175,simpl,simply,402175,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['simpl'],['simply']
Usability,ionEngine/Orc/IRTransformLayer.h; llvm/include/llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h; llvm/include/llvm/ExecutionEngine/Orc/Layer.h; llvm/include/llvm/ExecutionEngine/Orc/LazyReexports.h; llvm/include/llvm/ExecutionEngine/Orc/LookupAndRecordAddrs.h; llvm/include/llvm/ExecutionEngine/Orc/MachOPlatform.h; llvm/include/llvm/ExecutionEngine/Orc/Mangling.h; llvm/include/llvm/ExecutionEngine/Orc/ObjectFileInterface.h; llvm/include/llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h; llvm/include/llvm/ExecutionEngine/Orc/ObjectTransformLayer.h; llvm/include/llvm/ExecutionEngine/Orc/OrcABISupport.h; llvm/include/llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h; llvm/include/llvm/ExecutionEngine/Orc/SpeculateAnalyses.h; llvm/include/llvm/ExecutionEngine/Orc/Speculation.h; llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/OrcRTBridge.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/SimplePackedSerialization.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/ExecutorBootstrapService.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleExecutorDylibManager.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/TargetExecutionUtils.h; llvm/include/llvm/FileCheck/FileCheck.h; llvm/include/llvm/Frontend/OpenMP/OMPAssume.h; llvm/include/llvm/Frontend/OpenMP/OMPConstants.h; llvm/include/llvm/Frontend/OpenMP/OMPContext.h; llvm/include/llvm/Frontend/OpenMP/OMPGridValues.h; llvm/include/llvm/InterfaceStub/ELFObjHandler.h; llvm/include/llvm/InterfaceStub/IFSHandler.h; llvm/include/llvm/Int,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:253990,Simpl,SimplePackedSerialization,253990,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimplePackedSerialization']
Usability,"ions...; double evaluate() override {; // Do some bookkeeping; return doFoo();; };; double analyticalIntegral(Int_t code, const char* rangeName) override {; // Select the right paths for integration using codes or whatever.; return integralFoo();; }; };; ```. \note All RooFit classes are deriving from the RooAbsReal object, but; its details are not relevant to the current example. Note how the `evaluate()` function overrides the `RooAbsReal` for the RooFoo; class. Similarly, the `analyticalIntegral()` function has also been overridden; from the `RooAbsReal` class. The `evaluate()` function includes some bookkeeping steps (commented out in; above example) that are not relevant to AD. The important part is that it; calls a specific function (doFoo() in this example), and returns the results. Similarly, the `analyticalIntegral()` function calls a specific function (; `integralFoo()` in this example), and returns the results. It may also include; some code that may need to be looked at, but for simplicity, its contents are; commented out in this example. #### Adding Code Generation Support to RooFoo class. Before creating the translate() function, move the mathematical logic (; `doFoo()` function in this example) out of the source class (RooFoo in this; example) and into a separate header file called `MathFuncs.h`. Also note; that the parameters a and b have been defined as inputs, instead of them just; being class members. ``` {.cpp}; ///// The MathFuncs.h file; int doFoo(int a, int b) { return a* b + a + b; }; ```. > Directory path: [roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h](https://github.com/root-project/root/blob/master/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h). So now that the `doFoo()` function exists in the `MathFuncs` namespace, we; need to comment out its original function definition in the RooFoo class and; also add the namespace `MathFuncs` to wherever `doFoo()` it is referenced; (and also define input parameters for it). ``` {.cpp}; class RooFo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:20495,simpl,simplicity,20495,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simplicity']
Usability,"ions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A. 221; CD1; Must compound assignment operators be member functions?; Clang 3.6. 222; CD1; Sequence points and lvalue-returning operators; Duplicate of 637. 223; CD3; The meaning of deprecation; N/A. 224; CD1; Definition of dependent names; Clang 16. 225; NAD; Koenig lookup and fundamental types; Yes. 226; CD1; Default template arguments for function templates; No. 227; TC1; How many scopes in an if statement?",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:13995,clear,clearly,13995,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['clear'],['clearly']
Usability,"ior to obtaining commit access, it is common practice to request that; someone with commit access commits on your behalf. When doing so, please; provide the name and email address you would like to use in the Author; property of the commit. For external tracking purposes, committed changes are automatically reflected; on a commits mailing list soon after the commit lands (e.g. llvm-commits_).; Note that these mailing lists are moderated, and it is not unusual for a large; commit to require a moderator to approve the email, so do not be concerned if a; commit does not immediately appear in the archives. If you have recently been granted commit access, these policies apply:. #. You are granted *commit-after-approval* to all parts of LLVM. For; information on how to get approval for a patch, please see :doc:`CodeReview`.; When approved, you may commit it yourself. #. You are allowed to commit patches without approval which you think are; obvious. This is clearly a subjective decision --- we simply expect you to; use good judgement. Examples include: fixing build breakage, reverting; obviously broken patches, documentation/comment changes, any other minor; changes. Avoid committing formatting- or whitespace-only changes outside of; code you plan to make subsequent changes to. Also, try to separate; formatting or whitespace changes from functional changes, either by; correcting the format first (ideally) or afterward. Such changes should be; highly localized and the commit message should clearly state that the commit; is not intended to change functionality, usually by stating it is; :ref:`NFC <nfc>`. #. You are allowed to commit patches without approval to those portions of LLVM; that you have contributed or maintain (i.e., have been assigned; responsibility for), with the proviso that such commits must not break the; build. This is a ""trust but verify"" policy, and commits of this nature are; reviewed after they are committed. #. Multiple violations of these policies or ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:24506,clear,clearly,24506,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,2,"['clear', 'simpl']","['clearly', 'simply']"
Usability,"ipate within these spaces. Important examples ; include `sexual and gender-based violence`_, `hate crimes`_, and `hate speech`_. ; We do not conduct proactive research, but we have an obligation to respond ; to any reported concerns. We are not interested in evaluating severity, ; responding punitively, or holding people accountable. Both the relevance ; and our response is instead focused on how a person’s continued participation ; impacts the community’s safety, wellbeing, and inclusivity. We specifically ; prioritize remaining a welcoming community to victims as well as groups ; subjected to systemic marginalization or underrepresentation. In addition, violations of this code outside these spaces may, in rare; cases, affect a person's ability to participate within them, when the conduct; amounts to an egregious violation of this code. If you believe someone is violating the code of conduct, we ask that you report; it by emailing conduct@llvm.org. For more details please see the ; :doc:`Reporting Guide <ReportingGuide>`. .. _be friendly and patient:. * **Be friendly and patient.**. .. _be welcoming:. * **Be welcoming.** We strive to be a community that welcomes and supports; people of all backgrounds and identities. This includes, but is not limited; to members of any race, ethnicity, culture, national origin, colour,; immigration status, social and economic class, educational level, sex, sexual; orientation, gender identity and expression, age, size, family status,; political belief, religion or lack thereof, and mental and physical ability. .. _be considerate:. * **Be considerate.** Your work will be used by other people, and you in turn; will depend on the work of others. Any decision you take will affect users; and colleagues, and you should take those consequences into account. Remember; that we're a world-wide community, so you might not be communicating in; someone else's primary language. .. _be respectful:. * **Be respectful.** Not all of us will agree all",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:2453,Guid,Guide,2453,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['Guid'],['Guide']
Usability,"ipated in one (if any) security issue in the last year.; - If already in the LLVM Security Group, has actively participated in most membership discussions in the last year.; - If already in the LLVM Security Group, has actively participated in writing or reviewing a transparency report in the last year.; - When employed by a company or other entity, the parent entity has no more than three members already in the LLVM Security Group.; - When nominated as a vendor contact, their position with that vendor remains the same as when originally nominated.; - Nominees are trusted by existing Security Group members to keep communications embargoed while still active. Nomination process; ------------------. Anyone who feels they meet these criteria can nominate themselves, or may be nominated by a third party such as an existing LLVM Security Group member. The nomination should state whether the nominee is nominated as an individual, researcher, or as a vendor contact. It should clearly describe the grounds for nomination. For the moment, nominations are generally proposed, discussed, and voted on using Phabricator. An `example nomination is available here`_. The use of Phabricator helps keep membership discussions open, transparent, and easily accessible to LLVM developers in many ways. If, for any reason, a fully-world-readable nomination seems inappropriate, you may `open a new issue`_, and a discussion can be had about the best way to approach nomination, given the constraints that individuals are under. Our recommended method of nomination may change as our `Discussion Medium`_ story evolves over time. Choosing new members; --------------------. If a nomination for LLVM Security Group membership is supported by a majority of existing LLVM Security Group members, then it carries within five business days unless an existing member of the Security Group objects. If an objection is raised, the LLVM Security Group members should discuss the matter and try to come to consensus;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:5374,clear,clearly,5374,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['clear'],['clearly']
Usability,"ire provides a barrier of the sort necessary to acquire a lock to access; other memory with normal loads and stores. Relevant standard; This corresponds to the C++/C ``memory_order_acquire``. It should also be; used for C++/C ``memory_order_consume``. Notes for frontends; If you are writing a frontend which uses this directly, use with caution.; Acquire only provides a semantic guarantee when paired with a Release; operation. Notes for optimizers; Optimizers not aware of atomics can treat this like a nothrow call. It is; also possible to move stores from before an Acquire load or read-modify-write; operation to after it, and move non-Acquire loads from before an Acquire; operation to after it. Notes for code generation; Architectures with weak memory ordering (essentially everything relevant today; except x86 and SPARC) require some sort of fence to maintain the Acquire; semantics. The precise fences required varies widely by architecture, but for; a simple implementation, most architectures provide a barrier which is strong; enough for everything (``dmb`` on ARM, ``sync`` on PowerPC, etc.). Putting; such a fence after the equivalent Monotonic operation is sufficient to; maintain Acquire semantics for a memory operation. Release; -------. Release is similar to Acquire, but with a barrier of the sort necessary to; release a lock. Relevant standard; This corresponds to the C++/C ``memory_order_release``. Notes for frontends; If you are writing a frontend which uses this directly, use with caution.; Release only provides a semantic guarantee when paired with an Acquire; operation. Notes for optimizers; Optimizers not aware of atomics can treat this like a nothrow call. It is; also possible to move loads from after a Release store or read-modify-write; operation to before it, and move non-Release stores from after a Release; operation to before it. Notes for code generation; See the section on Acquire; a fence before the relevant operation is usually; sufficient for Rel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:12439,simpl,simple,12439,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['simpl'],['simple']
Usability,"irective is used to verify that a string doesn't occur; between two matches (or before the first match, or after the last match). For; example, to verify that a load is removed by a transformation, a test like this; can be used:. .. code-block:: llvm. define i8 @coerce_offset0(i32 %V, i32* %P) {; store i32 %V, i32* %P. %P2 = bitcast i32* %P to i8*; %P3 = getelementptr i8* %P2, i32 2. %A = load i8* %P3; ret i8 %A; ; CHECK: @coerce_offset0; ; CHECK-NOT: load; ; CHECK: ret i8; }. The ""CHECK-COUNT:"" directive; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If you need to match multiple lines with the same pattern over and over again; you can repeat a plain ``CHECK:`` as many times as needed. If that looks too; boring you can instead use a counted check ""``CHECK-COUNT-<num>:``"", where; ``<num>`` is a positive decimal number. It will match the pattern exactly; ``<num>`` times, no more and no less. If you specified a custom check prefix,; just use ""``<PREFIX>-COUNT-<num>:``"" for the same effect.; Here is a simple example:. .. code-block:: text. Loop at depth 1; Loop at depth 1; Loop at depth 1; Loop at depth 1; Loop at depth 2; Loop at depth 3. ; CHECK-COUNT-6: Loop at depth {{[0-9]+}}; ; CHECK-NOT: Loop at depth {{[0-9]+}}. The ""CHECK-DAG:"" directive; ~~~~~~~~~~~~~~~~~~~~~~~~~~. If it's necessary to match strings that don't occur in a strictly sequential; order, ""``CHECK-DAG:``"" could be used to verify them between two matches (or; before the first match, or after the last match). For example, clang emits; vtable globals in reverse order. Using ``CHECK-DAG:``, we can keep the checks; in the natural order:. .. code-block:: c++. // RUN: %clang_cc1 %s -emit-llvm -o - | FileCheck %s. struct Foo { virtual void method(); };; Foo f; // emit vtable; // CHECK-DAG: @_ZTV3Foo =. struct Bar { virtual void method(); };; Bar b;; // CHECK-DAG: @_ZTV3Bar =. ``CHECK-NOT:`` directives could be mixed with ``CHECK-DAG:`` directives to; exclude strings between the surrounding ``CHECK-DAG:`` directives. As a r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:17643,simpl,simple,17643,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['simpl'],['simple']
Usability,"irectories. - `cycle` =\* means all cycles (memory and file). - `cycle` ="""" means apply to a memory object. - `cycle` = 9999 also means apply to a memory object. - `namecycle` = """" means the same as `namecycle` =""T\*"". - `namecycle` = `T*` delete subdirectories. For example to delete a directory from a file, you must specify the; directory cycle:. ``` {.cpp}; root[] f->Delete(""Wed011003;1""); ```. Some other examples of `namecycle` format are:. - `foo`:delete the object named `foo` from memory. - `foo;1`: delete the cycle 1 of the object named `foo` from the file. - `foo;*`: delete all cycles of `foo` from the file and also from; memory. - `*;2`: delete all objects with cycle number 2 from the file. - `*;*: delete` all objects from memory and from the file. - `T*;*`: delete all objects from memory and from the file including; all subdirectories. ## Streamers. To follow the discussion on `Streamers`, you need to know what a; *simple* data type is. A variable is of a simple data type if it cannot; be decomposed into other types. Examples of simple data types are longs,; shorts, floats, and chars. In contrast, a variable is of a *composite*; data type if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:41972,simpl,simple,41972,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"irement to be satisfied to perform I/O of instances; of a certain class is that the ROOT type system is aware of the layout; in memory of that class.; This topic is beyond the scope of this document: it is worth to mention; that I/O can be performed out of the box for the almost complete set; of ROOT classes. We can explore this functionality with histograms and two simple macros. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_to_file.C; ```. Not bad, eh ? Especially for a language that does not foresees; persistency natively like C++. The *RECREATE* option forces ROOT to; create a new file even if a file with the same name exists on disk. Now, you may use the Cling command line to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple repres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:1381,simpl,simple,1381,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['simpl'],['simple']
Usability,"is being worked on. .. _submit_patch:. How to Submit a Patch; =====================; Once you have a patch ready, it is time to submit it. The patch should:. * include a small unit test; * conform to the :doc:`CodingStandards`. You can use the `clang-format-diff.py`_ or `git-clang-format`_ tools to automatically format your patch properly.; * not contain any unrelated changes; * be an isolated change. Independent changes should be submitted as separate patches as this makes reviewing easier.; * have a single commit (unless stacked on another Differential), up-to-date with the upstream ``origin/main`` branch, and don't have merges. .. _format patches:. Before sending a patch for review, please also try to ensure it is; formatted properly. We use ``clang-format`` for this, which has git integration; through the ``git-clang-format`` script. On some systems, it may already be; installed (or be installable via your package manager). If so, you can simply; run it -- the following command will format only the code changed in the most; recent commit:. .. code-block:: console. % git clang-format HEAD~1. Note that this modifies the files, but doesn't commit them -- you'll likely want; to run. .. code-block:: console. % git commit --amend -a. in order to update the last commit with all pending changes. .. note::; If you don't already have ``clang-format`` or ``git clang-format`` installed; on your system, the ``clang-format`` binary will be built alongside clang, and; the git integration can be run from; ``clang/tools/clang-format/git-clang-format``. The LLVM project has migrated to GitHub Pull Requests as its review process.; We still have an active :ref:`Phabricator <phabricator-reviews>`; instance for the duration of the migration. If you want to contribute to LLVM; now, please use GitHub. For more information about the workflow of using GitHub; Pull Requests see our :ref:`GitHub <github-reviews>` documentation. To make sure the right people see your patch, please select su",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst:2827,simpl,simply,2827,interpreter/llvm-project/llvm/docs/Contributing.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst,1,['simpl'],['simply']
Usability,"is can be used in PDF and PS file names.; - In PDF files, italic greek characters were not correct for non null; text angle. ### TImageDump; - Fix a `TBox` clipping issue. ### TSVG; - Some markers did not show in Google-Chrome. ### New class TTeXDump: Graphics interface to TeX. This class allow to generate `PGF/TikZ` vector graphics output; which can be included in TeX and LaTeX documents. `PGF` is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friedly syntax layer called `TikZ`. To generate a such file it is enough to do:. ```; gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");; ```. Then, the generated file (<tt>hpx.tex</tt>) can be included in a; LaTeX document (`simple.tex`) in the following way:. ```; \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}; ```. Note the two directive needed at the top of the LaTeX file:. ```; \usepackage{tikz}; \usetikzlibrary{patterns}; ```. Then including the picture in the document is done with the; `\input` directive. The command `pdflatex simple.tex` will generate the corresponding pdf; file `simple.pdf`. ### X11 fonts. - A coverity fix in `Rotated.cxx` had a side effect on rotated text; drawn with X11 fonts. ### TCanvas and TPad. - `TPad::SaveAs` produces named macros in .C files.; - Change the way the string input is done in the Pad toolbar for text; and Pave Label. It doesn't use anymore the `TGX11` function `RequestString`.; Now the text appears directly as it will show and it is possible to; enter several text string. The input is not block in the `RequestString` event loop.; - The toolbar methods now work without XOR mode (useful for OpenGL()).; - A new """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md:1330,simpl,simple,1330,graf2d/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md,1,['simpl'],['simple']
Usability,"is instance random numbers distributed according to; different probability density functions, like the Uniform one at; lines *27-29*. See the on-line documentation to appreciate the full; power of this ROOT feature. - Line *8*: You are already familiar with the `TF1` class. This is; its two-dimensional version. At line *16* two random numbers; distributed according to the `TF2` formula are drawn with the method; `TF2::GetRandom2(double& a, double&b)`. - Line *27-29*: Fitting a 2-dimensional function just works like in; the one-dimensional case, i.e. initialisation of parameters and; calling of the `Fit()` method. - Line *34*: The *Surf1* option draws the `TF2` objects (but also; bi-dimensional histograms) as coloured surfaces with a wire-frame on; three-dimensional canvases. See Figure [4.3](#f43). - Line *35-40*: Retrieve the axis pointer and define the axis titles. - Line *41*: Draw the cloud of points on top of the coloured surface. - Line *43-49*: Here you learn how to create a canvas, partition it in; two sub-pads and access them. It is very handy to show multiple; plots in the same window or image. [f43]: figures/fitted2dFunction.png ""f43""; <a name=""f43""></a>. ![A dataset fitted with a bidimensional function visualised as a colored; surface.\label{f43}][f43]. \newpage. ## Multiple graphs ##. The class `TMultigraph` allows to manipulate a set of graphs as a single entity.; It is a collection of `TGraph` (or derived) objects. When drawn, the X and Y axis; ranges are automatically computed such as all the graphs will be visible. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/multigraph.C; ```; - Line *6* creates the multigraph. - Line *9-28*: create two graphs with errors and add them in the multigraph. - Line *30-32*: draw the multigraph. The axis limits are computed automatically; to make sure all the graphs' points will be in range. [f44]: figures/multigraph.png ""f44""; <a name=""f44""></a>. ![A set of graphs grouped in a multigraph.\label{f44}][f44]. [^3] ht",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:4380,learn,learn,4380,documentation/primer/graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md,1,['learn'],['learn']
Usability,"is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePart, label %eh.resume, label %cleanup.cont. cleanup.cont:; ; rest of the cleanup. eh.resume:; %exn = load ptr, ptr %exn.slot, align 8; %sel = load i32, ptr %ehselector.slot, align 4; %lpad.val = insertvalue { ptr, i32 } undef, ptr %exn, 0; %lpad.val29 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1; resume { ptr, i32 } %lpad.val29. The `CoroSpit` pass replaces `coro.end` with ``True`` in the resume functions,; thus leading to immediate unwind to the caller, whereas in start function it; is replaced with ``False``, thus allowing to proceed to the rest of the cleanup; code that is only needed during initial invocation of the coroutine. For Windows Exception handling model, a frontend should attach a funclet bundle; referring to an enclosing cleanuppad as follows:. .. code-block:: llvm. ehcleanup:; %tok = cleanuppad within none []; %unused = call i1 @llvm.coro.end(ptr null, i1 true, token none) [ ""funclet""(token %tok) ]; cleanupret from %tok unwind label %RestOfTheCleanup. The `CoroSplit` pass, if the funclet bundle is present, will insert; ``cleanupret from %tok unwind to caller`` before; the `coro.end`_ intrinsic and will remove the rest of the block. In the unwind path (when the argument is `true`), `coro.end` will mark the coroutine; as done, making it undefined behavior to resume th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:45175,resume,resume,45175,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"is pass, only available in ``opt``, prints the post dominator tree into a; ``.dot`` graph. This graph can then be processed with the :program:`dot` tool; to convert it to postscript or some other suitable format. ``dot-post-dom-only``: Print postdominance tree of function to ""dot"" file (with no function bodies); ---------------------------------------------------------------------------------------------------. This pass, only available in ``opt``, prints the post dominator tree into a; ``.dot`` graph, omitting the function bodies. This graph can then be processed; with the :program:`dot` tool to convert it to postscript or some other suitable; format. ``globals-aa``: Simple mod/ref analysis for globals; ---------------------------------------------------. This simple pass provides alias and mod/ref information for global values that; do not have their address taken, and keeps track of whether functions read or; write memory (are ""pure""). For this simple (but very common) case, we can; provide pretty accurate and useful information. ``instcount``: Counts the various types of ``Instruction``\ s; -------------------------------------------------------------. This pass collects the count of all instructions and reports them. ``iv-users``: Induction Variable Users; --------------------------------------. Bookkeeping for ""interesting"" users of expressions computed from induction; variables. ``lazy-value-info``: Lazy Value Information Analysis; ----------------------------------------------------. Interface for lazy computation of value constraint information. ``lint``: Statically lint-checks LLVM IR; ----------------------------------------. This pass statically checks for common and easily-identified constructs which; produce undefined or likely unintended behavior in LLVM IR. It is not a guarantee of correctness, in two ways. First, it isn't; comprehensive. There are checks which could be done statically which are not; yet implemented. Some of these are indicated by TO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:5715,simpl,simple,5715,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"is still in active development. This document may become outdated; over time. If you see something that's incorrect, please update it. Use Cases; ---------. MIR patterns are supported in the following places:. * GlobalISel ``GICombineRule``; * GlobalISel ``GICombinePatFrag``. Syntax; ------. MIR patterns use the DAG datatype in TableGen. .. code-block:: text. (inst operand0, operand1, ...). ``inst`` must be a def which inherits from ``Instruction`` (e.g. ``G_FADD``); or ``GICombinePatFrag``. Operands essentially fall into one of two categories:. * immediates. * untyped, unnamed: ``0``; * untyped, named: ``0:$y``; * typed, unnamed: ``(i32 0)``; * typed, named: ``(i32 0):$y``. * machine operands. * untyped: ``$x``; * typed: ``i32:$x``. Semantics:. * A typed operand always adds an operand type check to the matcher.; * There is a trivial type inference system to propagate types. * e.g. You only need to use ``i32:$x`` once in any pattern of a; ``GICombinePatFrag`` alternative or ``GICombineRule``, then all; other patterns in that rule/alternative can simply use ``$x``; (``i32:$x`` is redundant). * A named operand's behavior depends on whether the name has been seen before. * For match patterns, reusing an operand name checks that the operands; are identical (see example 2 below).; * For apply patterns, reusing an operand name simply copies that operand into; the new instruction (see example 2 below). Operands are ordered just like they would be in a MachineInstr: the defs (outs); come first, then the uses (ins). Patterns are generally grouped into another DAG datatype with a dummy operator; such as ``match``, ``apply`` or ``pattern``. Finally, any DAG datatype in TableGen can be named. This also holds for; patterns. e.g. the following is valid: ``(G_FOO $root, (i32 0):$cst):$mypat``.; This may also be helpful to debug issues. Patterns are *always* named, and if; they don't have a name, an ""anonymous"" one is given to them. If you're trying; to debug an error related to a M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:1334,simpl,simply,1334,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['simpl'],['simply']
Usability,"ise; * Assumes BasicBlocks are dead unless proven otherwise; * Proves values to be constant, and replaces them with constants; * Proves conditional branches to be unconditional. Note that this pass has a habit of making definitions be dead. It is a good; idea to run a :ref:`DCE <passes-dce>` pass sometime after running this pass. .. _passes-simplifycfg:. ``simplifycfg``: Simplify the CFG; ---------------------------------. Performs dead code elimination and basic block merging. Specifically:. * Removes basic blocks with no predecessors.; * Merges a basic block into its predecessor if there is only one and the; predecessor only has one successor.; * Eliminates PHI nodes for basic blocks with a single predecessor.; * Eliminates a basic block that only contains an unconditional branch. ``sink``: Code sinking; ----------------------. This pass moves instructions into successor blocks, when possible, so that they; aren't executed on paths where their results aren't needed. .. _passes-simple-loop-unswitch:. ``simple-loop-unswitch``: Unswitch loops; ----------------------------------------. This pass transforms loops that contain branches on loop-invariant conditions; to have multiple loops. For example, it turns the left into the right code:. .. code-block:: c++. for (...) if (lic); A for (...); if (lic) A; B; C; B else; C for (...); A; C. This can increase the size of the code exponentially (doubling it every time a; loop is unswitched) so we only unswitch if the resultant code will be smaller; than a threshold. This pass expects :ref:`LICM <passes-licm>` to be run before it to hoist; invariant conditions out of the loop, to make the unswitching opportunity; obvious. ``strip``: Strip all symbols from a module; ------------------------------------------. Performs code stripping. This transformation can delete:. * names for virtual registers; * symbols for internal globals and functions; * debug information. Note that this transformation makes code much less readable, so it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:35368,simpl,simple-loop-unswitch,35368,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple-loop-unswitch']
Usability,"isfy both it and this License would be to; refrain entirely from distribution of the Program. If any portion of this section is held invalid or unenforceable under; any particular circumstance, the balance of the section is intended to; apply and the section as a whole is intended to apply in other; circumstances. It is not the purpose of this section to induce you to infringe any; patents or other property right claims or to contest validity of any; such claims; this section has the sole purpose of protecting the; integrity of the free software distribution system, which is; implemented by public license practices. Many people have made; generous contributions to the wide range of software distributed; through that system in reliance on consistent application of that; system; it is up to the author/donor to decide if he or she is willing; to distribute software through any other system and a licensee cannot; impose that choice. This section is intended to make thoroughly clear what is believed to; be a consequence of the rest of this License. 8. If the distribution and/or use of the Program is restricted in; certain countries either by patents or by copyrighted interfaces, the; original copyright holder who places the Program under this License; may add an explicit geographical distribution limitation excluding; those countries, so that distribution is permitted only in or among; countries not thus excluded. In such case, this License incorporates; the limitation as if written in the body of this License. 9. The Free Software Foundation may publish revised and/or new versions; of the General Public License from time to time. Such new versions will; be similar in spirit to the present version, but may differ in detail to; address new problems or concerns. Each version is given a distinguishing version number. If the Program; specifies a version number of this License which applies to it and ""any; later version"", you have the option of following the terms and conditio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt:12021,clear,clear,12021,misc/rootql/LICENSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt,2,['clear'],['clear']
Usability,"ist of metadata that; describe the IR. For our purposes, we need to declare a metadata node that; assigns the ""kernel"" attribute to the LLVM IR function that should be emitted; as a PTX `kernel` function. These metadata nodes take the form:. .. code-block:: text. !{<function ref>, metadata !""kernel"", i32 1}. For the previous example, we have:. .. code-block:: llvm. !nvvm.annotations = !{!0}; !0 = !{void (float addrspace(1)*,; float addrspace(1)*,; float addrspace(1)*)* @kernel, !""kernel"", i32 1}. Here, we have a single metadata declaration in ``nvvm.annotations``. This; metadata annotates our ``@kernel`` function with the ``kernel`` attribute. Running the Kernel; ------------------. Generating PTX from LLVM IR is all well and good, but how do we execute it on; a real GPU device? The CUDA Driver API provides a convenient mechanism for; loading and JIT compiling PTX to a native GPU device, and launching a kernel.; The API is similar to OpenCL. A simple example showing how to load and; execute our vector addition code is shown below. Note that for brevity this; code does not perform much error checking!. .. note::. You can also use the ``ptxas`` tool provided by the CUDA Toolkit to offline; compile PTX to machine code (SASS) for a specific GPU architecture. Such; binaries can be loaded by the CUDA Driver API in the same way as PTX. This; can be useful for reducing startup time by precompiling the PTX kernels. .. code-block:: c++. #include <iostream>; #include <fstream>; #include <cassert>; #include ""cuda.h"". void checkCudaErrors(CUresult err) {; assert(err == CUDA_SUCCESS);; }. /// main - Program entry point; int main(int argc, char **argv) {; CUdevice device;; CUmodule cudaModule;; CUcontext context;; CUfunction function;; CUlinkState linker;; int devCount;. // CUDA initialization; checkCudaErrors(cuInit(0));; checkCudaErrors(cuDeviceGetCount(&devCount));; checkCudaErrors(cuDeviceGet(&device, 0));. char name[128];; checkCudaErrors(cuDeviceGetName(name, 128, device));; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:19081,simpl,simple,19081,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['simpl'],['simple']
Usability,"ist+e1; ...&item=[histo1,histo2]&opt=[hist,e1]; 6. Support loading of TStyle object, providing in URL; ...&style=item_name or ...&style=json_file_name; All values are copied directly to JSROOT.gStyle object.; 7. Add callback argument into JSROOT.draw() function.; Function will be called after drawing of object is completed.; Painter for drawn object will be provided as first argument (or null in case of error).; 8. Improve cleanup of JSROOT objects. ## Changes in 4.7.1; 1. Workaround for MathJax output - scaling not always works in Firefox; 2. Fix - bin scaling for box draw option for TH2 and TH3 histograms; 3. Fix - increase points limits for contour plots; 4. Fix - position of 3D canvas in WebKit browsers; 5. Fix - use abs bin content in RMS calculations; 6. Fix - support char star* and object arrays in I/O; 7. Fix - correct decoding of TAxis time offset; 8. Fix - checksum reading for foreign classes. ## Changes in 4.7.0; 1. Implement simple TTree::Draw over single leaf (#80); Support basic types, fixed-size arrays and several vector types; 2. Display of TEveTrack(s) and TEvePointSet(s) over drawn geometry (drag and drop); Also browsing, toggling, highlight of tracks and hits are done.; 3. Let set default geo colors as TGeoManager::DefaultColors() does; 4. Let use original ROOT macros to configure visibility of geometry volumes. Like:; &file=files/alice2.root&item=Geometry;1&opt=macro:macros/geomAlice.C; One can set default colors or colors/transparency for selected volumes.; Also volume, selected for drawing in the macro, will be used in the JSROOT; 5. Support drawing of TH2Poly class with 'col' and 'lego' options; 6. Implement 'CONT', 'ARR' and 'SURF' draw options for TH2 class; 7. Support basic drawing of TPolyLine class; 8. Interactive axis zooming in 3D with mouse, very much like to 2D; 9. Zooming and tool buttons via keyboards. ## Changes in 4.6.0; 1. Improvements in TGeo drawings; - support of large (~10M volumes) models, only most significant volumes are sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:51596,simpl,simple,51596,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,"isting `RooNLLVar` functionality, e.g. ranges are not yet supported. For more details, consult the usage notes in the [TestStatistics README.md](https://github.com/root-project/root/tree/master/roofit/roofitcore/src/TestStatistics/README.md).; For benchmarking results on the prototype version of the parallelized gradient calculator, see the corresponding [CHEP19 proceedings paper](https://doi.org/10.1051/epjconf/202024506027). ### New pythonizations. Various new pythonizations are introduced to streamline your RooFit code in Python. For a complete list of all pythonized classes and functions, please see the [RooFit pythonizations page in the reference guide](https://root.cern/doc/v626/group__RoofitPythonizations.html).; All RooFit Python tutorials have been updated to profit from all available pythonizations. Some notable highlights are listed in the following. #### Keyword argument pythonizations. All functions that take RooFit command arguments as parameters now accept equivalent Python keyword arguments, for example simplifying calls to [RooAbsPdf::fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5) such as:; ```Python; model.fitTo(data, ROOT.RooFit.Range(""left,right""), ROOT.RooFit.Save()); ```; which becomes:; ```Python; model.fitTo(data, Range=""left,right"", Save=True); ```. #### String to enum pythonizations. Many functions that take an enum as a parameter now accept also a string with the enum label. Take for example this expression:; ```Python; data.plotOn(frame, ROOT.RooFit.DataError(ROOT.RooAbsData.SumW2); ```; Combining the enum pythonization with the keyword argument pythonization explained before, this becomes:; ```Python; data.plotOn(frame, DataError=""SumW2""); ```. This pythonization is also useful for your calls to [RooFit::LineColor()](https://root.cern/doc/v626/group__Plotting.html#gad309cf5f63ec87ae5a7025d530f0398f) or [RooFit::LineStyle](https://root.cern/doc/v626/group__Plotting.html#gaf1f7922ba5965c1a5a9791a0",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:19386,simpl,simplifying,19386,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['simpl'],['simplifying']
Usability,"istogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:4065,simpl,simple,4065,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,1,['simpl'],['simple']
Usability,"it (``changeTo(...)``) says to *change* the code matched by the; pattern *to* the text ""MakeX"". Finally, we use ``cat`` again to build a message; that explains the change. Here are some example changes that this rule would make:. +--------------------------+----------------------------+; | Original | Result |; +==========================+============================+; | ``X x = MkX(3);`` | ``X x = MakeX(3);`` |; +--------------------------+----------------------------+; | ``CallFactory(MkX, 3);`` | ``CallFactory(MakeX, 3);`` |; +--------------------------+----------------------------+; | ``auto f = MkX;`` | ``auto f = MakeX;`` |; +--------------------------+----------------------------+. Example: method to function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Next, let's write a rule to replace a method call with a (free) function call,; applied to the original method call's target object. Specifically, ""change; ``s.size()`` to ``Size(s)``, where ``s`` is a ``string``."" We start with a simpler; change that ignores the type of ``s``. That is, it will modify *any* method call; where the method is named ""size"":. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr().bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. We express the pattern with the given AST matcher, which binds the method call's; target to ``s`` [#f1]_. For the edit, we again use ``changeTo``, but this; time we construct the term from multiple parts, which we compose with ``cat``. The; second part of our term is ``node(s)``, which selects the source code; corresponding to the AST node ``s`` that was bound when a match was found in the; AST for our rule's pattern. ``node(s)`` constructs a ``RangeSelector``, which, when; used in ``cat``, indicates that the selected source should be inserted in the; output at that point. Now, we probably don't want to rewrite *all* invocat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:5822,simpl,simpler,5822,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['simpl'],['simpler']
Usability,"it is initialized as follows:. .. code-block:: c. struct __block_literal_1 __block_literal_1 = {; &_NSConcreteGlobalBlock,; (1<<28)|(1<<29), <uninitialized>,; __block_invoke_1,; &__block_descriptor_1; };. that is, a different address is provided as the first value and a particular; (1<<28) bit is set in the ``flags`` field, and otherwise it is the same as for; stack based ``Block`` literals. This is an optimization that can be used for; any ``Block`` literal that imports no ``const`` or ``__block`` storage; variables. Imported Variables; ==================. Variables of ``auto`` storage class are imported as ``const`` copies. Variables; of ``__block`` storage class are imported as a pointer to an enclosing data; structure. Global variables are simply referenced and not considered as; imported. Imported ``const`` copy variables; ---------------------------------. Automatic storage variables not marked with ``__block`` are imported as; ``const`` copies. The simplest example is that of importing a variable of type ``int``:. .. code-block:: c. int x = 10;; void (^vv)(void) = ^{ printf(""x is %d\n"", x); }; x = 11;; vv();. which would be compiled to:. .. code-block:: c. struct __block_literal_2 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_2 *);; struct __block_descriptor_2 *descriptor;; const int x;; };. void __block_invoke_2(struct __block_literal_2 *_block) {; printf(""x is %d\n"", _block->x);; }. static struct __block_descriptor_2 {; unsigned long int reserved;; unsigned long int Block_size;; } __block_descriptor_2 = { 0, sizeof(struct __block_literal_2) };. and:. .. code-block:: c. struct __block_literal_2 __block_literal_2 = {; &_NSConcreteStackBlock,; (1<<29), <uninitialized>,; __block_invoke_2,; &__block_descriptor_2,; x; };. In summary, scalars, structures, unions, and function pointers are generally; imported as ``const`` copies with no need for helper functions. Imported ``const`` copy of ``Block`` reference; ----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:7061,simpl,simplest,7061,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['simpl'],['simplest']
Usability,"it normalized sum of functions) and in TF1Convolution; * Add a new histogram fitting option, `WIDTH` to fit directly density. The bin content in this case is scaled by the histogram bin width. ### TFormula. * Fix several bugs in the new TFormula class.; * Add as new pre-defined functions: `crystalball`, `breitwigner` and `cheb0,cheb1,...cheb10` for the Chebyshev polynomials. . ## Math Libraries. ### Random numbers. * Move from MathMore to MathCore the class `ROOT::Math::Random`. Make it a new interface class for random number generation. Add interfaces for standard; ROOT random engines, GSL random engines and random engines provided by the C++ standard library (`std::random`).; * Add a new randomengine, `MIXMAX` based on matrix-recursive random number generator from Kostas and George Savvidy. See this [paper](http://dx.doi.org/10.1016/j.cpc.2015.06.003). ## R Interface. Apply several improvements in the interface to R, allowing to use R functions within ROOT.; See more at the [ROOT-R User Guide](http://oproject.org/tiki-index.php?page=ROOT%20R%20Users%20Guide). . ## TMVA. Add new TMVA plug-in based on R and Python (using Scikit-Learn) ; * See the [RMVA Web page](http://oproject.org/tiki-index.php?page=RMVA) for a detailed description of the new TMVA method based on R; * See the [PyMVA Web page](http://oproject.org/tiki-index.php?page=PyMVA) for detailed description of the machine learning methods added in TMVA and based on the Python Scikit-Learn package. ## RooFit Libraries; . ## 2D Graphics Libraries. ### THistPainter. Improve the algorithm to compute the lower limit of an axis in log scale when its; real lower limit is 0. The problem was reported in ROOT-7414. Using the `COL` option with histograms having some negative bins; the empty bins; (containing 0) are drawn. In some cases one wants to not draw empty bins; (containing 0) of histograms having a negative minimum. The option `1`, used with; the option `COL`, allows to do that. Implement the Log option for `CA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:13984,Guid,Guide,13984,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['Guid'],['Guide']
Usability,"it value of the induction variable. If the only purpose; of the loop is to compute the exit value of some derived expression, this; transformation will make the loop dead. This transformation should be followed by strength reduction after all of the; desired loop transformations have been performed. Additionally, on targets; where it is profitable, the loop could be transformed to count down to zero; (the ""do loop"" optimization). ``inline``: Function Integration/Inlining; -----------------------------------------. Bottom-up inlining of functions into callees. .. _passes-instcombine:. ``instcombine``: Combine redundant instructions; -----------------------------------------------. Combine instructions to form fewer, simple instructions. This pass does not; modify the CFG. This pass is where algebraic simplification happens. This pass combines things like:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. into:. .. code-block:: llvm. %Z = add i32 %X, 2. This is a simple worklist driven algorithm. This pass guarantees that the following canonicalizations are performed on the; program:. #. If a binary operator has a constant operand, it is moved to the right-hand; side.; #. Bitwise operators with constant operands are always grouped so that shifts; are performed first, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant power-of-two argument are transformed into; shifts.; #. … etc. This pass can also simplify calls to specific well-known function calls (e.g.; runtime library functions). For example, a call ``exit(3)`` that occurs within; the ``main()`` function can be transformed into simply ``return 3``. Whether or; not library calls are simplified is controlled by the; :ref:`-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:19690,simpl,simple,19690,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"itch i8 %2, label %suspend [i8 0, label %loop.resume; i8 1, label %cleanup]; loop.resume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; loop:; %inc = add nsw i32 %n, 1; store i32 %inc, ptr %n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code needs to get executed for different suspend points,; a similar switch will be in the `f.destroy` function. .. note ::. Using suspend index in a coroutine state and having a switch in `f.resume` and; `f.destroy` is one of the possible implementation strategies. We explored; another option where a distinct `f.resume1`, `f.resume2`, etc. are created for; every suspend point, and instead of storing an index, the resume and destroy; function pointers are updated at every suspend. Early testing showed that the; current approach is easier on the optimizer than the latter so it is a; lowering strategy implemented at the moment",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:19477,resume,resume,19477,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ite canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); // canvas is added to ""c1.ps""; // and ps file is closed; }; ```. The `TCanvas::Print(""file.ps("")` mechanism is very useful, but it can be; a little inconvenient to have the action of opening/closing a file being; atomic with printing a page. Particularly if pages are being generated; in some loop, one needs to detect the special cases of first and last; page. The ""`[`"" and ""`]`"" can be used instead of ""`(`"" and ""`)`"" as; shown in the next example. ``` {.cpp}; c1.Print(""file.ps[""); // no actual print; just open file.ps; for (i=0; i<10; ++i) {; // fill canvas for context i; ...; c1.Print(""file.ps""); // actually print canvas to file.ps; } // end loop; c1.Print(""file.ps]""); // no actual print; just close file.ps; ```. The following script illustrates how to open a postscript file and draw; several pictures. The generation of a new postscript page is automatic; when **`TCanvas::Clear` is called by `object->Draw()`.**. ``` {.cpp}; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. //select PostScript output type; Int_t type = 111; //portrait ps; // Int_t type = 112; //landscape ps; // Int_t type = 113; //eps. //create a PostScript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a script; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; ```. The next example does the same:. ``` {.cpp}; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. //set x,y of printed page; gStyle->SetPaperSize(16,24);. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1->Print(""test1.ps("", ""Portrait"");; hprof->Draw();; c1->Print(""test1.ps"");; hpx->Draw(""lego1"");; c1->Print(""test1.ps)"");; }; ```. This following example shows",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:97086,Clear,Clear,97086,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['Clear'],['Clear']
Usability,"ites such as SPEC can be enabled by either. - placing (or linking) them into the `test-suite/test-suite-externals/xxx` directory (example: `test-suite/test-suite-externals/speccpu2000`); - using a configuration option such as `-D TEST_SUITE_SPEC2000_ROOT=path/to/speccpu2000`. You can find further information in the respective README files such as; `test-suite/External/SPEC/README`. For the SPEC benchmarks you can switch between the `test`, `train` and; `ref` input datasets via the `TEST_SUITE_RUN_TYPE` configuration option.; The `train` dataset is used by default. Custom Suites; -------------. You can build custom suites using the test-suite infrastructure. A custom suite; has a `CMakeLists.txt` file at the top directory. The `CMakeLists.txt` will be; picked up automatically if placed into a subdirectory of the test-suite or when; setting the `TEST_SUITE_SUBDIRS` variable:. ```bash; % cmake -DTEST_SUITE_SUBDIRS=path/to/my/benchmark-suite ../test-suite; ```. Profile Guided Optimization; ---------------------------. Profile guided optimization requires to compile and run twice. First the; benchmark should be compiled with profile generation instrumentation enabled; and setup for training data. The lit runner will merge the profile files; using `llvm-profdata` so they can be used by the second compilation run. Example:; ```bash; # Profile generation run using LLVM IR PGO:; % cmake -DTEST_SUITE_PROFILE_GENERATE=ON \; -DTEST_SUITE_USE_IR_PGO=ON \; -DTEST_SUITE_RUN_TYPE=train \; ../test-suite; % make; % llvm-lit .; # Use the profile data for compilation and actual benchmark run:; % cmake -DTEST_SUITE_PROFILE_GENERATE=OFF \; -DTEST_SUITE_PROFILE_USE=ON \; -DTEST_SUITE_RUN_TYPE=ref \; .; % make; % llvm-lit -o result.json .; ```. To use Clang frontend's PGO instead of LLVM IR PGO, set `-DTEST_SUITE_USE_IR_PGO=OFF`. The `TEST_SUITE_RUN_TYPE` setting only affects the SPEC benchmark suites. Cross Compilation and External Devices; --------------------------------------. ### Comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:9940,Guid,Guided,9940,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['Guid'],['Guided']
Usability,"itial adjustment. .. code-block:: c++. enum RelocationType {; reloc_pcrel_word = 0, // add reloc value after adjusting for the PC loc; reloc_picrel_word = 1, // add reloc value after adjusting for the PIC base; reloc_absolute_word = 2, // absolute relocation; no additional adjustment; reloc_absolute_dword = 3 // absolute relocation; no additional adjustment; };. Target JIT Info; ---------------. ``XXXJITInfo.cpp`` implements the JIT interfaces for target-specific; code-generation activities, such as emitting machine code and stubs. At; minimum, a target-specific version of ``XXXJITInfo`` implements the following:. * ``getLazyResolverFunction`` --- Initializes the JIT, gives the target a; function that is used for compilation. * ``emitFunctionStub`` --- Returns a native function with a specified address; for a callback function. * ``relocate`` --- Changes the addresses of referenced globals, based on; relocation types. * Callback function that are wrappers to a function stub that is used when the; real target is not initially known. ``getLazyResolverFunction`` is generally trivial to implement. It makes the; incoming parameter as the global ``JITCompilerFunction`` and returns the; callback function that will be used a function wrapper. For the Alpha target; (in ``AlphaJITInfo.cpp``), the ``getLazyResolverFunction`` implementation is; simply:. .. code-block:: c++. TargetJITInfo::LazyResolverFn AlphaJITInfo::getLazyResolverFunction(; JITCompilerFn F) {; JITCompilerFunction = F;; return AlphaCompilationCallback;; }. For the X86 target, the ``getLazyResolverFunction`` implementation is a little; more complicated, because it returns a different callback function for; processors with SSE instructions and XMM registers. The callback function initially saves and later restores the callee register; values, incoming arguments, and frame and return address. The callback; function needs low-level access to the registers or stack, so it is typically; implemented with assembler.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:83024,simpl,simply,83024,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['simpl'],['simply']
Usability,"itize-coverage=trace-pc-guard; % ASAN_OPTIONS=coverage=1 ./a.out; wc -c *.sancov; main; SanitizerCoverage: ./a.out.7312.sancov 2 PCs written; 24 a.out.7312.sancov; % ASAN_OPTIONS=coverage=1 ./a.out foo ; wc -c *.sancov; foo; main; SanitizerCoverage: ./a.out.7316.sancov 3 PCs written; 24 a.out.7312.sancov; 32 a.out.7316.sancov. Every time you run an executable instrumented with SanitizerCoverage; one ``*.sancov`` file is created during the process shutdown.; If the executable is dynamically linked against instrumented DSOs,; one ``*.sancov`` file will be also created for every DSO. Sancov data format; ------------------. The format of ``*.sancov`` files is very simple: the first 8 bytes is the magic,; one of ``0xC0BFFFFFFFFFFF64`` and ``0xC0BFFFFFFFFFFF32``. The last byte of the; magic defines the size of the following offsets. The rest of the data is the; offsets in the corresponding binary/DSO that were executed during the run. Sancov Tool; -----------. A simple ``sancov`` tool is provided to process coverage files.; The tool is part of LLVM project and is currently supported only on Linux.; It can handle symbolization tasks autonomously without any extra support; from the environment. You need to pass .sancov files (named; ``<module_name>.<pid>.sancov`` and paths to all corresponding binary elf files.; Sancov matches these files using module names and binaries file names. .. code-block:: console. USAGE: sancov [options] <action> (<binary file>|<.sancov file>)... Action (required); -print - Print coverage addresses; -covered-functions - Print all covered functions.; -not-covered-functions - Print all not covered functions.; -symbolize - Symbolizes the report. Options; -blocklist=<string> - Blocklist file (sanitizer blocklist format).; -demangle - Print demangled function name.; -strip_path_prefix=<string> - Strip this prefix from file paths in reports. Coverage Reports; ----------------. **Experimental**. ``.sancov`` files do not contain enough information to gener",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:17328,simpl,simple,17328,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['simpl'],['simple']
Usability,"its |; | Maximum number of clusters per group | 4B (foreseen: <10k) | List frame limits, cluster group summary encoding |; | Maximum number of pages per cluster per column | 4B | List frame limits |; | Maximum number of entries per cluster | 2^56 | Cluster summary encoding |; | Maximum string length (meta-data) | 4GB | String encoding |; | Maximum RBlob size | 128 PiB | 1GiB / 8B * 1GiB (with maxKeySize=1GiB, offsetSize=8B) |. ## Glossary. ### Anchor. The anchor is a data block that represents the entry point to an RNTuple.; The anchor is specific to the RNTuple container in which the RNTuple data are embedded (e.g., a ROOT file or an object store).; The anchor must provide the information to load the header and the footer **envelopes**. ### Cluster. A cluster is a set of **pages** that contain all the data belonging to an entry range.; The data set is partitioned in clusters.; A typical cluster size is tens to hundreds of megabytes. ### Column. A column is a storage backed vector of a number of **elements** of a simple type.; Column elements have a fixed bit-length that depends on the column type.; Some column types allow setting the bit lengths within specific limits (e.g. for floats with truncated mantissa). ### Envelope. An envelope is a data block with RNTuple meta-data, such as the header and the footer. ### Field. A field describes a serialized C++ type.; A field can have a hierarchy of subfields representing a composed C++ type (e.g., a vector of integers).; A field has zero, one, or multiple **columns** attached to it.; The columns contain the data related to the field but not to its subfields, which have their own columns. ### Frame. A frame is a byte range with metadata information in an **envelope**.; A frame starts with its size and thus can be extended in a forward-compatible way. ### Locator. A locator is a generalized way to identify a byte range in the RNTuple container.; For a file container, for instance, a locator consists of an offset and a size",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:50533,simpl,simple,50533,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['simpl'],['simple']
Usability,"itself. This can be done using the following syntax:. .. code-block:: c++. // expected-error@path/include.h:15 {{error message}}. The path can be absolute or relative and the same search paths will be used as; for ``#include`` directives. The line number in an external file may be; substituted with ``*`` meaning that any line number will match (useful where; the included file is, for example, a system header where the actual line number; may change and is not critical). As an alternative to specifying a fixed line number, the location of a; diagnostic can instead be indicated by a marker of the form ``#<marker>``.; Markers are specified by including them in a comment, and then referenced by; appending the marker to the diagnostic with ``@#<marker>``, as with:. .. code-block:: c++. #warning some text // #1; // ... other code ...; // expected-warning@#1 {{some text}}. The name of a marker used in a directive must be unique within the compilation. The simple syntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ``expected-<type> <n> {{diag text}}``, where ``<type>`` is one of; ``error``, ``warning``, ``remark``, or ``note``, and ``<n>`` is a positive; integer. This allows the diagnostic to appear as many times as specified. For; example:. .. code-block:: c++. void f(); // expected-note 2 {{previous declaration is here}}. Where the diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:159444,simpl,simple,159444,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"itted to the repository. Must Code Be Reviewed Prior to Being Committed?; -----------------------------------------------. Code can be reviewed either before it is committed or after. We expect; significant patches to be reviewed before being committed. Smaller patches; (or patches where the developer owns the component) that meet; likely-community-consensus requirements (as apply to all patch approvals) can; be committed prior to an explicit review. In situations where there is any; uncertainty, a patch should be reviewed prior to being committed. Please note that the developer responsible for a patch is also; responsible for making all necessary review-related changes, including; those requested during any post-commit review. .. _post_commit_review:. Can Code Be Reviewed After It Is Committed?; -------------------------------------------. Post-commit review is encouraged, and can be accomplished using any of the; tools detailed below. There is a strong expectation that authors respond; promptly to post-commit feedback and address it. Failure to do so is cause for; the patch to be :ref:`reverted <revert_policy>`. If a community member expresses a concern about a recent commit, and this; concern would have been significant enough to warrant a conversation during; pre-commit review (including around the need for more design discussions),; they may ask for a revert to the original author who is responsible to revert; the patch promptly. Developers often disagree, and erring on the side of the; developer asking for more review prevents any lingering disagreement over; code in the tree. This does not indicate any fault from the patch author,; this is inherent to our post-commit review practices.; Reverting a patch ensures that design discussions can happen without blocking; other development; it's entirely possible the patch will end up being reapplied; essentially as-is once concerns have been resolved. Before being recommitted, the patch generally should undergo furthe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:1861,feedback,feedback,1861,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['feedback'],['feedback']
Usability,ittests/Demangle/DLangDemangleTest.cpp; llvm/unittests/Demangle/OutputBufferTest.cpp; llvm/unittests/Demangle/RustDemangleTest.cpp; llvm/unittests/Demangle/StringViewTest.cpp; llvm/unittests/ExecutionEngine/JITLink/LinkGraphTests.cpp; llvm/unittests/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManagerTest.cpp; llvm/unittests/ExecutionEngine/Orc/EPCGenericMemoryAccessTest.cpp; llvm/unittests/ExecutionEngine/Orc/ExecutionSessionWrapperFunctionCallsTest.cpp; llvm/unittests/ExecutionEngine/Orc/ExecutorAddressTest.cpp; llvm/unittests/ExecutionEngine/Orc/JITTargetMachineBuilderTest.cpp; llvm/unittests/ExecutionEngine/Orc/LazyCallThroughAndReexportsTest.cpp; llvm/unittests/ExecutionEngine/Orc/LookupAndRecordAddrsTest.cpp; llvm/unittests/ExecutionEngine/Orc/ObjectLinkingLayerTest.cpp; llvm/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp; llvm/unittests/ExecutionEngine/Orc/ResourceTrackerTest.cpp; llvm/unittests/ExecutionEngine/Orc/SimpleExecutorMemoryManagerTest.cpp; llvm/unittests/ExecutionEngine/Orc/SimplePackedSerializationTest.cpp; llvm/unittests/ExecutionEngine/Orc/TaskDispatchTest.cpp; llvm/unittests/ExecutionEngine/Orc/ThreadSafeModuleTest.cpp; llvm/unittests/Frontend/OpenACCTest.cpp; llvm/unittests/Frontend/OpenMPContextTest.cpp; llvm/unittests/Frontend/OpenMPParsingTest.cpp; llvm/unittests/InterfaceStub/ELFYAMLTest.cpp; llvm/unittests/IR/DemandedBitsTest.cpp; llvm/unittests/IR/ManglerTest.cpp; llvm/unittests/IR/ModuleTest.cpp; llvm/unittests/IR/TimePassesTest.cpp; llvm/unittests/IR/UseTest.cpp; llvm/unittests/IR/VectorTypesTest.cpp; llvm/unittests/MC/Disassembler.cpp; llvm/unittests/MC/DwarfLineTableHeaders.cpp; llvm/unittests/MC/MCInstPrinter.cpp; llvm/unittests/MC/TargetRegistry.cpp; llvm/unittests/MC/AMDGPU/DwarfRegMappings.cpp; llvm/unittests/MC/SystemZ/SystemZAsmLexerTest.cpp; llvm/unittests/ObjCopy/ObjCopyTest.cpp; llvm/unittests/Object/ArchiveTest.cpp; llvm/unittests/Object/ELFObjectFileTest.cpp; llvm/unittests/Object/ELFTest.cpp; llvm/unittests/Object/ELFTypesT,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:346111,Simpl,SimplePackedSerializationTest,346111,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimplePackedSerializationTest']
Usability,"ity/wikis/doc/cmake/CrossCompiling>`_ for; generic instructions on how to cross-compile with CMake. It goes into detailed; explanations and may seem daunting, but it is not. On the wiki page there are; several examples including toolchain files. Go directly to the; ``Information how to set up various cross compiling toolchains`` section; for a quick solution. Also see the `LLVM-related variables`_ section for variables used when; cross-compiling. Embedding LLVM in your project; ==============================. From LLVM 3.5 onwards the CMake build system exports LLVM libraries as; importable CMake targets. This means that clients of LLVM can now reliably use; CMake to develop their own LLVM-based projects against an installed version of; LLVM regardless of how it was built. Here is a simple example of a CMakeLists.txt file that imports the LLVM libraries; and uses them to build a simple application ``simple-tool``. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(SimpleProject). find_package(LLVM REQUIRED CONFIG). message(STATUS ""Found LLVM ${LLVM_PACKAGE_VERSION}""); message(STATUS ""Using LLVMConfig.cmake in: ${LLVM_DIR}""). # Set your project compile flags.; # E.g. if using the C++ header files; # you will need to enable C++11 support; # for your compiler. include_directories(${LLVM_INCLUDE_DIRS}); separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_definitions(${LLVM_DEFINITIONS_LIST}). # Now build our tools; add_executable(simple-tool tool.cpp). # Find the libraries that correspond to the LLVM components; # that we wish to use; llvm_map_components_to_libnames(llvm_libs support core irreader). # Link against LLVM libraries; target_link_libraries(simple-tool ${llvm_libs}). The ``find_package(...)`` directive when used in CONFIG mode (as in the above; example) will look for the ``LLVMConfig.cmake`` file in various locations (see; cmake manual for details). It creates a ``LLVM_DIR`` cache entry to save the; directory w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:41337,Simpl,SimpleProject,41337,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['Simpl'],['SimpleProject']
Usability,"ivation for this design is to allow a runtime to; commandeer a stack frame when execution reaches an instruction address; associated with a stack map. The runtime must be able to rebuild a; stack frame and resume program execution using the information; provided by the stack map. For example, execution may resume in an; interpreter or a recompiled version of the same function. This usage restricts LLVM optimization. Clearly, LLVM must not move; stores across a stack map. However, loads must also be handled; conservatively. If the load may trigger an exception, hoisting it; above a stack map could be invalid. For example, the runtime may; determine that a load is safe to execute without a type check given; the current state of the type system. If the type system changes while; some activation of the load's function exists on the stack, the load; becomes unsafe. The runtime can prevent subsequent execution of that; load by immediately patching any stack map location that lies between; the current call site and the load (typically, the runtime would; simply patch all stack map locations to invalidate the function). If; the compiler had hoisted the load above the stack map, then the; program could crash before the runtime could take back control. To enforce these semantics, stackmap and patchpoint intrinsics are; considered to potentially read and write all memory. This may limit; optimization more than some clients desire. This limitation may be; avoided by marking the call site as ""readonly"". In the future we may; also allow meta-data to be added to the intrinsic call to express; aliasing, thereby allowing optimizations to hoist certain loads above; stack maps. Direct Stack Map Entries; ^^^^^^^^^^^^^^^^^^^^^^^^. As shown in :ref:`stackmap-section`, a Direct stack map location; records the address of frame index. This address is itself the value; that the runtime requested. This differs from Indirect locations,; which refer to a stack locations from which the requested ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:18551,simpl,simply,18551,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['simpl'],['simply']
Usability,"iven that ROOT injects `using namespace std` directive, _all_ the names in the `std` namespace become available in the global scope. However, in some circumstances users inadvertently introduce a declaration that conflicts with a name in `std` making references to the former declaration result in ambiguous lookup.; A fairly common case is trying to declare a global variable named `data` which conflict with [`std::data`](https://en.cppreference.com/w/cpp/iterator/data) [C++17]. See [ROOT-5971](https://sft.its.cern.ch/jira/browse/ROOT-5971) for a discussion.; As of v6.28, such declarations result in; ```; root [] int data;; ROOT_prompt_0:1:1: warning: 'data' shadows a declaration with the same name in the 'std' namespace; use '::data' to reference this declaration; int data;; ^; ```. - Line editing at the ROOT interactive prompt has been improved. This version introduces useful shortcuts for common actions, e.g. Xterm-like fast movement between words using Ctrl+Left and Ctrl+Right, Ctrl+Del to delete the word under the cursor, or clearing the screen using Ctrl+L. Most users coming from a GUI will find these shortcuts convenient.; A list of the available key bindings is printed by; ```; root [] .help edit; ```. ## I/O Libraries. ### Faster reading from EOS. A new cross-protocol redirection has been added to allow files on EOS mounts to be opened; by `TFile::Open` via XRootD protocol rather than via FUSE when that is possible. The; redirection uses the `eos.url.xroot` extended file attribute that is present on files in EOS.; The attribute can be viewed with `getfattr -n eos.url.xroot [file]` on the command line.; When the URL passed into `TFile::Open` is a for a file on an EOS mount, the extended; attribute is used to attempt the redirection to XRootD protocol. If the redirection fails,; the file is opened using the plain file path as before. This feature is controlled by the; pre-existing configuration option `TFile.CrossProtocolRedirects` and is enabled by default.; I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:7443,clear,clearing,7443,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['clear'],['clearing']
Usability,"ize Offsetting of Location Descriptions; --------------------------------------------------. The ``DW_OP_plus`` and ``DW_OP_minus`` operations can be defined to operate on a; memory location description in the default target architecture specific address; space and a generic type value to produce an updated memory location; description. This allows them to continue to be used to offset an address. To generalize offsetting to any location description, including location; descriptions that describe when bytes are in registers, are implicit, or a; composite of these, the ``DW_OP_LLVM_offset``, ``DW_OP_LLVM_offset_uconst``, and; ``DW_OP_LLVM_bit_offset`` offset operations are added. The offset operations can operate on location storage of any size. For example,; implicit location storage could be any number of bits in size. It is simpler to; define offsets that exceed the size of the location storage as being an; evaluation error, than having to force an implementation to support potentially; infinite precision offsets to allow it to correctly track a series of positive; and negative offsets that may transiently overflow or underflow, but end up in; range. This is simple for the arithmetic operations as they are defined in terms; of two's complement arithmetic on a base type of a fixed size. Therefore, the; offset operation define that integer overflow is ill-formed. This is in contrast; to the ``DW_OP_plus``, ``DW_OP_plus_uconst``, and ``DW_OP_minus`` arithmetic; operations which define that it causes wrap-around. Having the offset operations allows ``DW_OP_push_object_address`` to push a; location description that may be in a register, or be an implicit value. The; DWARF expression of ``DW_TAG_ptr_to_member_type`` can use the offset operations; without regard to what kind of location description was pushed. Since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack` has; generalized location storage to be bit indexable, ``DW_OP_LLVM_bit_offset``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:11565,simpl,simpler,11565,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simpler']
Usability,"ized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2); !1 = !DIFile(filename: ""debugify-sample.ll"", directory: ""/""); !2 = !{}; !3 = !{i32 5}; !4 = !{i32 2}; !5 = !{i32 2, !""Debug Info Version"", i32 3}; !6 = distinct !DISubprogram(name: ""f"", linkageName: ""f"", scope: null, file: !1, line: 1, type: !7, isLocal: false, isDefinition: true, scopeLine: 1, isOptimized: true, unit: !0, retainedNodes: !8); !7 = !DISubroutineType(types: !2); !8 = !{!9, !11}; !9 = !DILocalVariable(name: ""1"", scope: !6, file: !1, line: 1, type: !10); !10 = !DIBasicType(name: ""ty64"", size: 64, encoding: DW_ATE_unsigned); !11 = !DILocalVariable(name: ""2"", scope: !6, file: !1, line: 3, type: !10); !12 = !DILocation(line: 1, column: 1, scope: !6); !13 = !DILocation(line: 2, column: 1, scope: !6); !14 = !DILocation(line: 3, column: 1, scope: !6); !15 = !DILocation(line: 4, column: 1, scope: !6); !16 = !DILocation(line: 5, column: 1, scope: !6). Using ``debugify``; ^^^^^^^^^^^^^^^^^^. A simple way to use ``debugify`` is as follows:. .. code-block:: bash. $ opt -debugify -pass-to-test -check-debugify sample.ll. This will inject synthetic DI to ``sample.ll`` run the ``pass-to-test`` and; then check for missing DI. The ``-check-debugify`` step can of course be; omitted in favor of more customizable FileCheck directives. Some other ways to run debugify are available:. .. code-block:: bash. # Same as the above example.; $ opt -enable-debugify -pass-to-test sample.ll. # Suppresses verbose debugify output.; $ opt -enable-debugify -debugify-quiet -pass-to-test sample.ll. # Prepend -debugify before and append -check-debugify -strip after; # each pass on the pipeline (similar to -verify-each).; $ opt -debugify-each -O2 sample.ll. In order for ``check-debugify`` to work, the DI must be coming from; ``debugify``. Thus, modules with existing DI will be skipped. ``debugify`` can be used to test a backend, e.g:. .. code-block:: bash. $ opt -debugify < sample.ll | llc -o -. There is also a MIR-level debug",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:12005,simpl,simple,12005,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simple']
Usability,"izeof(char));; p = p - 1;; free(p); // warn: argument to free() is offset by -4 bytes; }. unix.MallocSizeof; (C); Check for dubious malloc, calloc or; realloc arguments involving sizeof. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. unix.MismatchedDeallocator; (C, C++, ObjC); Check for mismatched deallocators (e.g. passing a pointer allocating; with new to free()). // C, C++; void test() {; int *p = (int *)malloc(sizeof(int));; delete p; // warn; }. // C, C++; void __attribute((ownership_returns(malloc))) *user_malloc(size_t);. void test() {; int *p = (int *)user_malloc(sizeof(int));; delete p; // warn; }. // C, C++; void test() {; int *p = new int;; free(p); // warn; }. // C, C++; void test() {; int *p = new int[1];; realloc(p, sizeof(long)); // warn; }. // C, C++; template <typename T>; struct SimpleSmartPointer {; T *ptr;. explicit SimpleSmartPointer(T *p = 0) : ptr(p) {}; ~SimpleSmartPointer() {; delete ptr; // warn; }; };. void test() {; SimpleSmartPointer<int> a((int *)malloc(4));; }. // C++; void test() {; int *p = (int *)operator new(0);; delete[] p; // warn; }. // Objective-C, C++; void test(NSUInteger dataLength) {; int *p = new int;; NSData *d = [NSData dataWithBytesNoCopy:p; length:sizeof(int) freeWhenDone:1];; // warn +dataWithBytesNoCopy:length:freeWhenDone: cannot take; // ownership of memory allocated by 'new'; }. unix.Vfork; (C); Check for proper usage of vfork. int test(int x) {; pid_t pid = vfork(); // warn; if (pid != 0); return 0;. switch (x) {; case 0:; pid = 1;; execl("""", """", 0);; _exit(1);; break;; case 1:; x = 0; // warn: this assignment is prohibited; break;; case 2:; foo(); // warn: this function call is prohibited; break;; default:; return 0; // warn: return is prohibited; }. while(1);; }. unix.cstring.BadSizeArg; (C); Check the size argument passed to strncat for common erroneous; patterns. Use -Wno-strncat-size compiler option ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:25644,Simpl,SimpleSmartPointer,25644,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['Simpl'],['SimpleSmartPointer']
Usability,"ject/releases>`_.; Select the last link: ``Source code (zip)`` and unpack the downloaded file using; Windows Explorer built-in zip support or any other unzip tool. 12. Finally, configure LLVM using CMake:. .. code-block:: bat. cmake -S llvm\llvm -B build -DLLVM_ENABLE_PROJECTS=clang -DLLVM_TARGETS_TO_BUILD=X86 -Thost=x64; exit. ``LLVM_ENABLE_PROJECTS`` specifies any additional LLVM projects you want to; build while ``LLVM_TARGETS_TO_BUILD`` selects the compiler targets. If; ``LLVM_TARGETS_TO_BUILD`` is omitted by default all targets are built; slowing compilation and using more disk space.; See the :doc:`LLVM CMake guide <CMake>` for detailed information about; how to configure the LLVM build. The ``cmake`` command line tool is bundled with Visual Studio but its GUI is; not. You may install `CMake <http://www.cmake.org/>`_ to use its GUI to change; CMake variables or modify the above command line. * Once CMake is installed then the simplest way is to just start the; CMake GUI, select the directory where you have LLVM extracted to, and; the default options should all be fine. One option you may really; want to change, regardless of anything else, might be the; ``CMAKE_INSTALL_PREFIX`` setting to select a directory to INSTALL to; once compiling is complete, although installation is not mandatory for; using LLVM. Another important option is ``LLVM_TARGETS_TO_BUILD``,; which controls the LLVM target architectures that are included on the; build.; * CMake generates project files for all build types. To select a specific; build type, use the Configuration manager from the VS IDE or the; ``/property:Configuration`` command line option when using MSBuild.; * By default, the Visual Studio project files generated by CMake use the; 32-bit toolset. If you are developing on a 64-bit version of Windows and; want to use the 64-bit toolset, pass the ``-Thost=x64`` flag when; generating the Visual Studio solution. This requires CMake 3.8.0 or later. 13. Start Visual Studio and select",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:5704,simpl,simplest,5704,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['simpl'],['simplest']
Usability,"jectLayer to link the object file produced by our compiler. So far we have learned how to optimize and compile our LLVM IR, but we have; not focused on when compilation happens. Our current REPL optimizes and; compiles each function as soon as it is referenced by any other code,; regardless of whether it is ever called at runtime. In the next chapter we; will introduce a fully lazy compilation, in which functions are not compiled; until they are first called at run-time. At this point the trade-offs get much; more interesting: the lazier we are, the quicker we can start executing the; first function, but the more often we will have to pause to compile newly; encountered functions. If we only code-gen lazily, but optimize eagerly, we; will have a longer startup time (as everything is optimized at that time) but; relatively short pauses as each function just passes through code-gen. If we; both optimize and code-gen lazily we can start executing the first function; more quickly, but we will have longer pauses as each function has to be both; optimized and code-gen'd when it is first executed. Things become even more; interesting if we consider interprocedural optimizations like inlining, which; must be performed eagerly. These are complex trade-offs, and there is no; one-size-fits all solution to them, but by providing composable layers we leave; the decisions to the person implementing the JIT, and make it easy for them to; experiment with different configurations. `Next: Adding Per-function Lazy Compilation <BuildingAJIT3.html>`_. Full Code Listing; =================. Here is the complete code listing for our running example with an; IRTransformLayer added to enable optimization. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h; :",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:11312,pause,pauses,11312,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['pause'],['pauses']
Usability,jectTransformLayer.h; llvm/include/llvm/ExecutionEngine/Orc/OrcABISupport.h; llvm/include/llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h; llvm/include/llvm/ExecutionEngine/Orc/SpeculateAnalyses.h; llvm/include/llvm/ExecutionEngine/Orc/Speculation.h; llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/OrcRTBridge.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/SimplePackedSerialization.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/ExecutorBootstrapService.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleExecutorDylibManager.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/TargetExecutionUtils.h; llvm/include/llvm/FileCheck/FileCheck.h; llvm/include/llvm/Frontend/OpenMP/OMPAssume.h; llvm/include/llvm/Frontend/OpenMP/OMPConstants.h; llvm/include/llvm/Frontend/OpenMP/OMPContext.h; llvm/include/llvm/Frontend/OpenMP/OMPGridValues.h; llvm/include/llvm/InterfaceStub/ELFObjHandler.h; llvm/include/llvm/InterfaceStub/IFSHandler.h; llvm/include/llvm/InterfaceStub/IFSStub.h; llvm/include/llvm/IR/Assumptions.h; llvm/include/llvm/IR/BuiltinGCs.h; llvm/include/llvm/IR/Comdat.h; llvm/include/llvm/IR/Constants.h; llvm/include/llvm/IR/DebugInfo.h; llvm/include/llvm/IR/DebugInfoMetadata.h; llvm/include/llvm/IR/DiagnosticHandler.h; llvm/include/llvm/IR/DiagnosticPrinter.h; llvm/include/llvm/IR/EHPersonalities.h; llvm/include/llvm/IR/GlobalIFunc.h; llvm/include/llvm/IR/GlobalObject.h; llvm/include/llvm/IR/GVMaterializer.h; llvm/include/llvm/IR/IRPrintingPasses.h; llvm/include/llvm/I,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:254525,Simpl,SimpleRemoteEPCServer,254525,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimpleRemoteEPCServer']
Usability,"jects located; at multiple places. Collectively these changes expand the set of architectures; that can be supported and improves support for optimized code. Several approaches were considered, and the one presented, together with the; extensions it enables, appears to be the simplest and cleanest one that offers; the greatest improvement of DWARF's ability to support debugging optimized GPU; and non-GPU code. Examining the GDB debugger and LLVM compiler, it appears only; to require modest changes as they both already have to support general use of; location descriptions. It is anticipated that will also be the case for other; debuggers and compilers. GDB has been modified to evaluate DWARF Version 5 expressions with location; descriptions as stack entries and with implicit conversions. All GDB tests have; passed, except one that turned out to be an invalid test case by DWARF Version 5; rules. The code in GDB actually became simpler as all evaluation is done on a; single stack and there was no longer a need to maintain a separate structure for; the location description results. This gives confidence in backwards; compatibility. See :ref:`amdgpu-dwarf-expressions` and nested sections. This extension is separately described at *Allow Location Descriptions on the; DWARF Expression Stack* [:ref:`AMDGPU-DWARF-LOC; <amdgpu-dwarf-AMDGPU-DWARF-LOC>`]. 2.2 Generalize CFI to Allow Any Location Description Kind; ---------------------------------------------------------. CFI describes restoring callee saved registers that are spilled. Currently CFI; only allows a location description that is a register, memory address, or; implicit location description. AMDGPU optimized code may spill scalar registers; into portions of vector registers. This requires extending CFI to allow any; location description kind to be supported. See :ref:`amdgpu-dwarf-call-frame-information`. 2.3 Generalize DWARF Operation Expressions to Support Multiple Places; -----------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:7708,simpl,simpler,7708,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simpler']
Usability,"k, nor is there; any streamerinfo for such a member. A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a; pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL); is written. If the declaration line has a comment beginning with ""//->"", this indicates; that the pointer value will never be null, which allows a performance optimization.; Another optimization is that if two or more pointers pointing to the same object are; streamed in the same I/O operation, the object is written only once. The remaining; pointers reference the object through a unique object identifier. This saves space; and avoids the infinite loop that might otherwise arise if the directed graph of object; instance pointer references contains a cycle. If a data member is a pointer to a simple type, the Streamer presumes it is an array,; with the dimension defined in a comment of the form ""//[<length>]"", where length is; either an integer constant or a variable that is an integer data member of the class.; If a variable is used, it must be defined ahead of its use or in a base class. The above describes the function of the StreamerInfo record in decomposing a; self-identifying object if the user uses the streamer generated by ""rootcint"".; There are two reasons why a user may need to write a specialized streamer for a class.; One reason is that it may be necessary to execute some code before or after data is read; or written, for example, to initialize some non-persistent data members after the; persistent data is read. In this case, the custom streamer can use the StreamerInfo record; to decompose a self-identifying object in the exact same manner as the generated; streamer would have done. An example is given (for the Event class) in the Root User's; Guide (URL below) (Input/Output chapter, Streamers subchapter). On the other hand, if; the user needs to writ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md:8511,simpl,simple,8511,io/doc/TFile/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md,1,['simpl'],['simple']
Usability,"kay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CMake's files. Finally, run ninja one last time, and you're done. Step 1: Create a ClangTool; ==========================. Now that we have enough background knowledge, it's time to create the; simplest productive ClangTool in existence: a syntax checker. While this; already exists as ``clang-check``, it's important to understand what's; going on. First, we'll need to create a new directory for our tool and tell CMake; that it exists. As this is not going to be a core clang tool, it will; live in the ``clang-tools-extra`` repository. .. code-block:: console. cd ~/clang-llvm/llvm-project; mkdir clang-tools-extra/loop-convert; echo 'add_subdirectory(loop-convert)' >> clang-tools-extra/CMakeLists.txt; vim clang-tools-extra/loop-convert/CMakeLists.txt. CMakeLists.txt should have the following contents:. ::. set(LLVM_LINK_COMPONENTS support). add_clang_executable(loop-convert; LoopConvert.cpp; ); target_link_libraries(loop-convert; PRIVATE; clangAST; clangASTMatchers; clangBasic; clangFrontend; clangSerialization; clangTooling; ). With that done, Ninja will be able to compile our tool. Let's give it; something to compile! Put the following into; ``clang-tools-extra/loop-conve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:2516,simpl,simplest,2516,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simplest']
Usability,"kdir PATH_TO_MINIUT2_BUILD; cd PATH_TO_MINUIT2_BUILD; cmake PATH_TO_MINUIT2_SOURCE; cmake --build .; ```. Of course, GUIs, IDEs, etc. that work with [CMake] will work with this package. The standard method of CMake building, with a build directory inside the Minuit2 source directory and using the makefile generator, would look like:. ```bash; cd PATH_TO_MINUIT2_SOURCE; mkdir build; cd build; cmake ..; make; ```. The standard [CMake] variables, such as `CMAKE_BUILD_TYPE` and `CMAKE_INSTALL_PREFIX`, work with Minuit2. There are two other options:. * `minuit2_mpi` activates the (outdated C++) MPI bindings.; * `minuit2_omp` activates OpenMP (make sure all FCNs are threadsafe). ## Testing. You can run `ctest` or `make test` to run the Minuit2 test suite. ## Installing or using in another package. You can install the package using `cmake --build --target install .` (or `make install` if directly using the make system), or you can use it from the build directory. You can also include it in another CMake project using `add_subdirectory()` and linking to the `Minuit2` target. Since this package also exports targets, `find_package(Minuit2)` will also work once this package is built or installed. (For the curious, CMake adds a config script to `~/.cmake/packages` when building or; `$CMAKE_INSTALL_PREFIX/share/cmake/Modules` when installing a package that has export commands.). To repeat; using this in your own CMake project usually amounts to:. ```cmake; find_package(Minuit2); # OR; add_subdirectory(Minuit2). target_link_libraries(MyExeOrLib PUBLIC Minuit2::Minuit2); ```. You do not need to add include directories or anything else for Minuit2; the CMake target system handles all of this for you. ## Packaging. To build a binary package (add other generators with `-G`):; ```bash; make package; ```. [DEVELOP.md]: ./DEVELOP.md; [ROOT]: https://root.cern; [minuitdoc]: https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html#minuit2-package; [CMake]: https://cmake.org; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/README.md:2565,guid,guides,2565,math/minuit2/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/README.md,2,['guid'],"['guide', 'guides']"
Usability,"ke check LIT_ARGS=""-v --vg --vg-leak"". to enable testing with valgrind and with leak checking enabled. To run individual tests or subsets of tests, you can use the ``llvm-lit``; script which is built as part of LLVM. For example, to run the; ``Integer/BitPacked.ll`` test by itself you can run:. .. code-block:: bash. % llvm-lit ~/llvm/test/Integer/BitPacked.ll. or to run all of the ARM CodeGen tests:. .. code-block:: bash. % llvm-lit ~/llvm/test/CodeGen/ARM. The regression tests will use the Python psutil module only if installed in a; **non-user** location. Under Linux, install with sudo or within a virtual; environment. Under Windows, install Python for all users and then run; ``pip install psutil`` in an elevated command prompt. For more information on using the :program:`lit` tool, see ``llvm-lit --help``; or the :doc:`lit man page <CommandGuide/lit>`. Debugging Information tests; ---------------------------. To run debugging information tests simply add the ``cross-project-tests``; project to your ``LLVM_ENABLE_PROJECTS`` define on the cmake; command-line. Regression test structure; =========================. The LLVM regression tests are driven by :program:`lit` and are located in the; ``llvm/test`` directory. This directory contains a large array of small tests that exercise; various features of LLVM and to ensure that regressions do not occur.; The directory is broken into several sub-directories, each focused on a; particular area of LLVM. Writing new regression tests; ----------------------------. The regression test structure is very simple, but does require some; information to be set. This information is gathered via ``cmake``; and is written to a file, ``test/lit.site.cfg.py`` in the build directory.; The ``llvm/test`` Makefile does this work for you. In order for the regression tests to work, each directory of tests must; have a ``lit.local.cfg`` file. :program:`lit` looks for this file to determine; how to run the tests. This file is just Python code a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:6788,simpl,simply,6788,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['simpl'],['simply']
Usability,"ke.org/cmake/help/v3.4/manual/cmake-language.7.html>`_. 10,000 ft View; ==============. CMake is a tool that reads script files in its own language that describe how a; software project builds. As CMake evaluates the scripts it constructs an; internal representation of the software project. Once the scripts have been; fully processed, if there are no errors, CMake will generate build files to; actually build the project. CMake supports generating build files for a variety; of command line build tools as well as for popular IDEs. When a user runs CMake it performs a variety of checks similar to how autoconf; worked historically. During the checks and the evaluation of the build; description scripts CMake caches values into the CMakeCache. This is useful; because it allows the build system to skip long-running checks during; incremental development. CMake caching also has some drawbacks, but that will be; discussed later. Scripting Overview; ==================. CMake's scripting language has a very simple grammar. Every language construct; is a command that matches the pattern _name_(_args_). Commands come in three; primary types: language-defined (commands implemented in C++ in CMake), defined; functions, and defined macros. The CMake distribution also contains a suite of; CMake modules that contain definitions for useful functionality. The example below is the full CMake build for building a C++ ""Hello World""; program. The example uses only CMake language-defined functions. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(HelloWorld); add_executable(HelloWorld HelloWorld.cpp). The CMake language provides control flow constructs in the form of foreach loops; and if blocks. To make the example above more complicated you could add an if; block to define ""APPLE"" when targeting Apple platforms:. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(HelloWorld); add_executable(HelloWorld HelloWorld.cpp); if(APPLE); target_compile_def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:1726,simpl,simple,1726,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['simpl'],['simple']
Usability,"ke:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26217,simpl,simplifies,26217,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplifies']
Usability,"ken for long periods of time (weeks or more).; * Clearly superior alternatives are in use and maintenance is painful.; * Builds and tests are harder / take longer, increasing the cost of; maintenance, overtaking the perceived benefits. If the maintenance cost is higher than it is acceptable by the majority of; developers, it means that either the sub-community is too small (and the extra; cost should be paid locally), or not active enough (and the problems won't be; fixed any time soon). In either case, removal of such problematic component is; justified. Steps for removal; -----------------. However clear the needs for removal are, we should take an incremental approach; to deprecating code, especially when there's still a sub-community that cares; about it. In that sense, code will never be removed outright without a series; of steps are taken. A minimum set of steps should be:; #. A proposal for removal / deactivation should be made to the Discourse forums ; (under the appropriate category), with a clear; statement of the maintenance costs imposed and the alternatives, if; applicable.; #. There must be enough consensus on the list that removal is warranted, and no; pending proposals to fix the situation from a sub-community.; #. An announcement for removal must be made on the same lists, with ample time; for downstream users to take action on their local infrastructure. The time; will depend on what is being removed. #. If a script or documents are to be removed, they can always be pulled; from previous revision, and can be removed within days.; #. if a whole target is removed, we need to first announce publicly, and; potentially mark as deprecated in one release, only to remove on the; next release.; #. Everything else will fall in between those two extremes.; #. The removal is made by either the proposer or the sub-community that used to; maintain it, with replacements and arrangements made atomically on the same; commit. If a proposal for removal is delayed by",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:9541,clear,clear,9541,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['clear'],['clear']
Usability,"ken>). Overview:; """""""""""""""""". The '``llvm.coro.end``' marks the point where execution of the resume part of; the coroutine should end and control should return to the caller. Arguments:; """""""""""""""""""". The first argument should refer to the coroutine handle of the enclosing; coroutine. A frontend is allowed to supply null as the first parameter, in this; case `coro-early` pass will replace the null with an appropriate coroutine; handle value. The second argument should be `true` if this coro.end is in the block that is; part of the unwind sequence leaving the coroutine body due to an exception and; `false` otherwise. Non-trivial (non-none) token argument can only be specified for unique-suspend; returned-continuation coroutines where it must be a token value produced by; '``llvm.coro.end.results``' intrinsic. Only none token is allowed for coro.end calls in unwind sections. Semantics:; """"""""""""""""""""; The purpose of this intrinsic is to allow frontends to mark the cleanup and; other code that is only relevant during the initial invocation of the coroutine; and should not be present in resume and destroy parts. In returned-continuation lowering, ``llvm.coro.end`` fully destroys the; coroutine frame. If the second argument is `false`, it also returns from; the coroutine with a null continuation pointer, and the next instruction; will be unreachable. If the second argument is `true`, it falls through; so that the following logic can resume unwinding. In a yield-once; coroutine, reaching a non-unwind ``llvm.coro.end`` without having first; reached a ``llvm.coro.suspend.retcon`` has undefined behavior. The remainder of this section describes the behavior under switched-resume; lowering. This intrinsic is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:43555,resume,resume,43555,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26576,simpl,simplifying,26576,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplifying']
Usability,"ks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize generated code. This pass obviously modifies the CFG, but updates loop information and; dominator information. ``loop-unroll``: Unroll loops; -----------------------------. This pass implements a simple loop unroller. It works best when loops have; been canonicalized by the :ref:`indvars <passes-indvars>` pass, allowing it to; determine the trip counts of loops easily. ``loop-unroll-and-jam``: Unroll and Jam loops; ---------------------------------------------. This pass implements a simple unroll and jam classical loop optimisation pass.; It transforms loop from:. .. code-block:: c++. for i.. i+= 1 for i.. i+= 4; for j.. for j..; code(i, j) code(i, j); code(i+1, j); code(i+2, j); code(i+3, j); remainder loop. Which can be seen as unrolling the outer loop and ""jamming"" (fusing) the inner; loops into one. When variables or loads can be shared in the new inner loop, this; can lead to significant performance improvements. It uses; :ref:`Dependence Analysis <passes-da>` for proving the transformations are safe. ``lower-global-dtors``: Lower global destructors; ------------------------------------------------. This pass lowers global module destructors (``llvm.global_dtors``) by creating; wrapper functions that are registered as global constructors in; ``llvm.global_ctors`` and which contain a call to ``__cxa_atexit`` to register; their destructor functions. ``loweratomic``: Lower atomic intrinsics to non-atomic form; -----------------------------------------------------------. This pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:28265,simpl,simple,28265,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"l :ref:`operand bundles <opbundles>` list. Semantics:; """""""""""""""""""". This instruction is designed to operate as a standard '``call``'; instruction in most regards. The primary difference is that it; establishes an association with additional labels to define where control; flow goes after the call. The output values of a '``callbr``' instruction are available only to; the '``fallthrough``' block, not to any '``indirect``' blocks(s). The only use of this today is to implement the ""goto"" feature of gcc inline; assembly where additional labels can be provided as locations for the inline; assembly to jump to. Example:; """""""""""""""". .. code-block:: llvm. ; ""asm goto"" without output constraints.; callbr void asm """", ""r,!i""(i32 %x); to label %fallthrough [label %indirect]. ; ""asm goto"" with output constraints.; <result> = callbr i32 asm """", ""=r,r,!i""(i32 %x); to label %fallthrough [label %indirect]. .. _i_resume:. '``resume``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. resume <type> <value>. Overview:; """""""""""""""""". The '``resume``' instruction is a terminator instruction that has no; successors. Arguments:; """""""""""""""""""". The '``resume``' instruction requires one argument, which must have the; same type as the result of any '``landingpad``' instruction in the same; function. Semantics:; """""""""""""""""""". The '``resume``' instruction resumes propagation of an existing; (in-flight) exception whose unwinding was interrupted with a; :ref:`landingpad <i_landingpad>` instruction. Example:; """""""""""""""". .. code-block:: llvm. resume { ptr, i32 } %exn. .. _i_catchswitch:. '``catchswitch``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind to caller; <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind label <default>. Overview:; """""""""""""""""". The '``catchswitch``' instruction is used by `LLVM's exception handling system; <ExceptionHandling.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:369779,resume,resume,369779,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability,"l MnStrategy and will be; more reliable if you instantiate it with a high–level MnStrategy; (although the latter option may not help much). Its main weakness is; that it depends heavily on knowledge of the first derivatives, and fails; miserably if they are very inaccurate. If first derivatives are a; problem, they can be calculated analytically inside $\mbox{FCN}$; (see [howto:fcn]) or if this is not feasible, the user can try to; improve the accuracy of M 's numerical approximation by adjusting values; of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and; [api:strategy]). ### $\mbox{MINIMIZE}$ ###. This is equivalent to $\mbox{MIGRAD}$, except that if; $\mbox{MIGRAD}$ fails, it reverts to $\mbox{SIMPLEX}$ and then; calls $\mbox{MIGRAD}$ again. ### $\mbox{SCAN}$ ###. This is not intended to minimize, and just scans the function, one; parameter at a time. It does however retain the best value after each; scan, so it does some sort of highly primitive minimization. ### $\mbox{SIMPLEX}$ ###. This genuine multidimensional minimization routine is usually much; slower than $\mbox{MIGRAD}$, but it does not use first derivatives,; so it should not be so sensitive to the precision of the; $\mbox{FCN}$ calculations, and is even rather robust with respect to; gross fluctuations in the function value. However, it gives no reliable; information about parameter errors, no information whatsoever about; parameter correlations, and worst of all cannot be expected to converge; accurately to the minimum in a finite time. Its estimate of the; *expected distance to the minimum* $\mbox{EDM}$ is largely fantasy,; so it would not even know if it did converge. ## Floating point precision ##. M figures out at execution time the machine precision [api:epsmac], and; assumes that $\mbox{FCN}$ provides about the same precision. That; means not just the length of the numbers used and returned by; $\mbox{FCN}$, but the actual mathematical accuracy of the; calculations. Section [install:e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:62183,SIMPL,SIMPLEX,62183,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['SIMPL'],['SIMPLEX']
Usability,"l boundaries as 1-element vectors (which is the same as if they were loaded with ``LDR``). Bitconverts; -----------. .. image:: ARM-BE-bitcastfail.png; :align: right. The main problem with the ``LD1`` solution is dealing with bitconverts (or bitcasts, or reinterpret casts). These are pseudo instructions that only change the compiler's interpretation of data, not the underlying data itself. A requirement is that if data is loaded and then saved again (called a ""round trip""), the memory contents should be the same after the store as before the load. If a vector is loaded and is then bitconverted to a different vector type before storing, the round trip will currently be broken. Take for example this code sequence::. %0 = load <4 x i32> %x; %1 = bitcast <4 x i32> %0 to <2 x i64>; store <2 x i64> %1, <2 x i64>* %y. This would produce a code sequence such as that in the figure on the right. The mismatched ``LD1`` and ``ST1`` cause the stored data to differ from the loaded data. .. container:: clearer. When we see a bitcast from type ``X`` to type ``Y``, what we need to do is to change the in-register representation of the data to be *as if* it had just been loaded by a ``LD1`` of type ``Y``. .. image:: ARM-BE-bitcastsuccess.png; :align: right. Conceptually this is simple - we can insert a ``REV`` undoing the ``LD1`` of type ``X`` (converting the in-register representation to the same as if it had been loaded by ``LDR``) and then insert another ``REV`` to change the representation to be as if it had been loaded by an ``LD1`` of type ``Y``. For the previous example, this would be::. LD1 v0.4s, [x]. REV64 v0.4s, v0.4s // There is no REV128 instruction, so it must be synthesizedcd; EXT v0.16b, v0.16b, v0.16b, #8 // with a REV64 then an EXT to swap the two 64-bit elements. REV64 v0.2d, v0.2d; EXT v0.16b, v0.16b, v0.16b, #8. ST1 v0.2d, [y]. It turns out that these ``REV`` pairs can, in almost all cases, be squashed together into a single ``REV``. For the example above, a ``REV1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst:10667,clear,clearer,10667,interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,1,['clear'],['clearer']
Usability,"l data classes as needed for; analysis were parsable by CINT and consequently, by using CINT for the; bindings, at the very least one could run any analysis in Python.; This was key. Besides not being able to parse some code (a problem that's history for cppyy; since moving to Cling), all automatic parsers suffer from the problem that; the bindings produced have a strong ""C++ look-and-feel"" and that choices need; to be made in cases that can be bound in different, equally valid, ways.; As an example of the latter, consider the return of an ``std::vector``:; should this be automatically converted to a Python ``list``?; Doing so is more ""pythonic"", but incurs a significant overhead, and no; automatic choice will satisfy all cases: user input is needed. The typical way to solve these issues, is to provide an intermediate language; where corner cases can be brushed up, code can be made more Python friendly,; and design choices can be resolved.; Unfortunately, learning an intermediate language is quite an investment in; time and effort.; With cppyy, however, no such extra language is needed: using Cling, C++ code; can be embedded and JIT-ed for the same purpose.; In particular, cppyy can handle `boxed` Python objects and the full Python; C-API is available through Cling, allowing complete manual control where; necessary, and all within a single code base.; Similarly, a more pythonistic look-and-feel can be achieved in Python itself.; As a rule, Python is always the best place, far more so than any intermediate; language, to do Python-thingies.; Since all bound proxies are normal Python classes, functions, etc., Python's; introspection (and regular expressions engine) can be used to provide rule; based improvements in a way similar to the use of directives in an; intermediate language. On a practical note, it's often said that an automatic binder can provide; bindings to 95% of your code out-of-the-box, with only the remaining part; needing manual intervention.; This is b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:6423,learn,learning,6423,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['learn'],['learning']
Usability,"l data of an object, and that this reference will be; invalidated if the object is destroyed. When such a message is sent to an; object, the object's lifetime will be extended until at least the earliest of:. * the last use of the returned pointer, or any pointer derived from it, in the; calling function or; * the autorelease pool is restored to a previous state. .. admonition:: Rationale. Rationale: not all memory and resources are managed with reference counts; it; is common for objects to manage private resources in their own, private way.; Typically these resources are completely encapsulated within the object, but; some classes offer their users direct access for efficiency. If ARC is not; aware of methods that return such ""interior"" pointers, its optimizations can; cause the owning object to be reclaimed too soon. This attribute informs ARC; that it must tread lightly. The extension rules are somewhat intentionally vague. The autorelease pool; limit is there to permit a simple implementation to simply retain and; autorelease the receiver. The other limit permits some amount of; optimization. The phrase ""derived from"" is intended to encompass the results; both of pointer transformations, such as casts and arithmetic, and of loading; from such derived pointers; furthermore, it applies whether or not such; derivations are applied directly in the calling code or by other utility code; (for example, the C library routine ``strchr``). However, the implementation; never need account for uses after a return from the code which calls the; method returning an interior pointer. As an exception, no extension is required if the receiver is loaded directly; from a ``__strong`` object with :ref:`precise lifetime semantics; <arc.optimization.precise>`. .. admonition:: Rationale. Implicit autoreleases carry the risk of significantly inflating memory use,; so it's important to provide users a way of avoiding these autoreleases.; Tying this to precise lifetime semantics is ideal,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:100765,simpl,simple,100765,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['simpl'],"['simple', 'simply']"
Usability,"l have; just two functions:. 1. ``Error addModule(std::unique_ptr<Module> M)``: Make the given IR module; available for execution.; 2. ``Expected<ExecutorSymbolDef> lookup()``: Search for pointers to; symbols (functions or variables) that have been added to the JIT. A basic use-case for this API, executing the 'main' function from a module,; will look like:. .. code-block:: c++. JIT J;; J.addModule(buildModule());; auto *Main = J.lookup(""main"").getAddress().toPtr<int(*)(int, char *[])>();; int Result = Main();. The APIs that we build in these tutorials will all be variations on this simple; theme. Behind this API we will refine the implementation of the JIT to add; support for concurrent compilation, optimization and lazy compilation.; Eventually we will extend the API itself to allow higher-level program; representations (e.g. ASTs) to be added to the JIT. KaleidoscopeJIT; ===============. In the previous section we described our API, now we examine a simple; implementation of it: The KaleidoscopeJIT class [1]_ that was used in the; `Implementing a language with LLVM <LangImpl01.html>`_ tutorials. We will use; the REPL code from `Chapter 7 <LangImpl07.html>`_ of that tutorial to supply the; input for our JIT: Each time the user enters an expression the REPL will add a; new IR module containing the code for that expression to the JIT. If the; expression is a top-level expression like '1+1' or 'sin(x)', the REPL will also; use the lookup method of our JIT class find and execute the code for the; expression. In later chapters of this tutorial we will modify the REPL to enable; new interactions with our JIT class, but for now we will take this setup for; granted and focus our attention on the implementation of our JIT itself. Our KaleidoscopeJIT class is defined in the KaleidoscopeJIT.h header. After the; usual include guards and #includes [2]_, we get to the definition of our class:. .. code-block:: c++. #ifndef LLVM_EXECUTIONENGINE_ORC_KALEIDOSCOPEJIT_H; #define LLVM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:3797,simpl,simple,3797,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['simpl'],['simple']
Usability,"l minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional; function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in %ROOT is; organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:. - \ref MinuitOld ""Minuit"": library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; - \ref Minuit2Page ""Minuit2"": new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; - **Fumili**: library providing the implementation of the original Fumili fitting algorithm (class TFumili). - **Linear algebra**. Two libraries are contained in %ROOT for describing linear algebra matrices and vector classes:. - Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; - \ref SMatrixPage ""SMatrix"": package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. - **Physics Vectors**: Classes for describing vectors in 2, 3 and 4 dimensions (re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/index.md:2175,Simpl,Simplex,2175,math/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/index.md,1,['Simpl'],['Simplex']
Usability,"l processing; framework, RDataFrame, that can considerably speed up an analysis, taking ; full advantage of multi-core and distributed systems. ROOT is performance critical software written in C++ and enables rapid prototyping ; powered by a unique C++ compliant interpreter called Cling. ; Cling also enables performant C++ type introspection which is a building block of automatic ; interoperability with Python. Thanks to PyROOT, leveraging the cppyy technology, ; ROOT offers efficient, on-demand C++/Python interoperability in a uniform cross-language ; execution environment. ROOT fully embraces open-source, it's made with passion by its community,; for the benefit of its community. [![License: LGPL v2.1+](https://img.shields.io/badge/License-LGPL%20v2.1+-blue.svg)](https://www.gnu.org/licenses/lgpl.html); [![CII Best Practices](https://bestpractices.coreinfrastructure.org/projects/5060/badge)](https://bestpractices.coreinfrastructure.org/projects/5060). ## Contribution Guidelines; - [How to contribute](https://github.com/root-project/root/blob/master/CONTRIBUTING.md); - [Coding conventions](https://root.cern/coding-conventions); - [Meetings](https://root.cern/meetings). ## Cite; When citing ROOT, please use both the reference reported below and the DOI specific to your ROOT version available [on Zenodo](https://zenodo.org/badge/latestdoi/10994345) [![DOI](https://zenodo.org/badge/10994345.svg)](https://zenodo.org/badge/latestdoi/10994345). For example, you can copy-paste and fill in the following citation:. Rene Brun and Fons Rademakers, ROOT - An Object Oriented Data Analysis Framework,; Proceedings AIHENP'96 Workshop, Lausanne, Sep. 1996,; Nucl. Inst. & Meth. in Phys. Res. A 389 (1997) 81-86.; See also ""ROOT"" [software], Release vX.YY/ZZ, dd/mm/yyyy. ## Live Demo for CERN Users; [![](https://img.shields.io/badge/Launch-SWAN-orange)](http://cern.ch/swanserver/cgi-bin/go?projurl=https://github.com/cernphsft/rootbinder.git). See more screenshots on our [gallery](http",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README.md:2041,Guid,Guidelines,2041,README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README.md,1,['Guid'],['Guidelines']
Usability,"l threads of the group may be available to; participate in this communication. This is the defining characteristic that; distinguishes convergent operations from other inter-thread communication:. A convergent operation involves inter-thread communication or synchronization; that occurs outside of the memory model, where the set of threads which; participate in communication is implicitly affected by control flow. For example, in the following GPU compute kernel, communication during the; convergent operation is expected to occur precisely among those threads of an; implementation-defined execution scope (such as workgroup or subgroup) for; which ``condition`` is true:. .. code-block:: c++. void example_kernel() {; ...; if (condition); convergent_operation();; ...; }. In structured programming languages, there is often an intuitive and; unambiguous way of determining the threads that are expected to communicate.; However, this is not always the case even in structured programming languages,; and the intuition breaks down entirely in unstructured control flow. This; document describes the formal semantics in LLVM, i.e. how to determine the set; of communicating threads for convergent operations. The definitions in this document leave many details open, such as how groups of; threads are formed in the first place. It focuses on the questions that are; relevant for deciding the correctness of generic program transforms and; convergence-related analyses such as :ref:`uniformity analysis; <convergence-and-uniformity>`. .. _convergent_operations:. Convergent Operations; =====================. In LLVM IR, the only way to communicate between threads as described; above is by calling target-defined convergent intrinsics. Hence, only; a call-site in LLVM IR (a :ref:`call <i_call>`, :ref:`invoke; <i_invoke>`, or :ref:`callbr <i_callbr>` instruction) can result in a; convergent operation. A function in LLVM IR is said to be *convergent* if it has the; :ref:`convergent <attr_con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:1607,intuit,intuition,1607,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['intuit'],['intuition']
Usability,"l visible level put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what should appear on the; screen. However, there are situations when users want to see a volume; branch displayed down to the maximum depth, keeping at the same time a; limitation or even suppressing others. In order to accomplish that, one; should use the volume attribute: `Visible daughters`. By default, all; daughters of all volumes are displayed if there is no limitation related; with their level depth with respect to the top drawn volume. ### Ray Tracing. Ray tracing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. While; there are currently existing quite sophisticated ray tracing models,; **`TGeo`** is currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the number of rays that have to be tracked matches; the size in pixels of the pad, the time required by this algorithm is; proportional to the pad size. On the other hand, the speed is quite; acceptable for the default ROOT pad size and the images produced by; using this technique have high quality. Since the algorithm is; practically using all navigation features, producing ray-traced pictures; is also a geometry validation check. Ray tracing can be activated at; volume level as the normal `Draw()`. ![Ray-traced view in a pad](pictures/020001E4.jpg). ``` {.cpp}; myVolume->Raytrace(); ```. Once ray-tracing a view, this can be zoomed or rotated as a usual one.; Objects on the screen are no longer highlighted when picking the; vertices but the corre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:143496,simpl,simple,143496,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"l::ParseCommandLineOptions(argc, argv, ""This is a small program to demo the LLVM CommandLine API"");; ...; }. .. _cl::ParseCommandLineOptions:. The ``cl::ParseCommandLineOptions`` function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::ParseCommandLineOptions`` function is designed to be called directly; from ``main``, and is used to fill in the values of all of the command line; option variables once ``argc`` and ``argv`` are available. The ``cl::ParseCommandLineOptions`` function requires two parameters (``argc``; and ``argv``), but may also take an optional third parameter which holds; `additional extra text`_ to emit when the ``-help`` option is invoked. The ``cl::SetVersionPrinter`` function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::SetVersionPrinter`` function is designed to be called directly from; ``main`` and *before* ``cl::ParseCommandLineOptions``. Its use is optional. It; simply arranges for a function to be called in response to the ``--version``; option instead of having the ``CommandLine`` library print out the usual version; string for LLVM. This is useful for programs that are not part of LLVM but wish; to use the ``CommandLine`` facilities. Such programs should just define a small; function that takes no arguments and returns ``void`` and that prints out; whatever version information is appropriate for the program. Pass the address of; that function to ``cl::SetVersionPrinter`` to arrange for it to be called when; the ``--version`` option is given by the user. .. _cl::opt:; .. _scalar:. The ``cl::opt`` class; ^^^^^^^^^^^^^^^^^^^^^. The ``cl::opt`` class is the class used to represent scalar command line; options, and is the one used most of the time. It is a templated class which; can take up to three arguments (all except for the first have default values; though):. .. code-block:: c++. namespace cl {; template <class DataType, bool ExternalStorage = false,; class ParserClass = parser<DataType> >; class opt;; }. The first template",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:53719,simpl,simply,53719,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simply']
Usability,"l; to the cfe-dev; mailing list to notify other members of the community. Release checkers from ""alpha""; New checkers which were contributed to the analyzer,; but have not passed a rigorous evaluation process,; are committed as ""alpha checkers"" (from ""alpha version""),; and are not enabled by default.; Ideally, only the checkers which are actively being worked on should be in; ""alpha"",; but over the years the development of many of those has stalled.; Such checkers should either be improved; up to a point where they can be enabled by default,; or removed from the analyzer entirely. ; alpha.security.ArrayBound and; alpha.security.ArrayBoundV2; Array bounds checking is a desired feature,; but having an acceptable rate of false positives might not be possible; without a proper; loop widening support.; Additionally, it might be more promising to perform index checking based on; tainted index values.; (Difficulty: Medium). alpha.unix.StreamChecker; A SimpleStreamChecker has been presented in the Building a Checker in 24; Hours talk; (slides; video).; This alpha checker is an attempt to write a production grade stream checker.; However, it was found to have an unacceptably high false positive rate.; One of the found problems was that eagerly splitting the state; based on whether the system call may fail leads to too many reports.; A delayed split where the implication is stored in the state; (similarly to nullability implications in TrustNonnullChecker); may produce much better results.; (Difficulty: Medium). Improve C++ support; ; Handle construction as part of aggregate initialization.; Aggregates; are objects that can be brace-initialized without calling a; constructor (that is, ; CXXConstructExpr does not occur in the AST),; but potentially calling; constructors for their fields and base classes; These; constructors of sub-objects need to know what object they are constructing.; Moreover, if the aggregate contains; references, lifetime extension needs to be properly mod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:1263,Simpl,SimpleStreamChecker,1263,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['Simpl'],['SimpleStreamChecker']
Usability,"lStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; safe_int m_t;; };. void instantiate() { TemplStruct<int> ti; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. Add prefix to member initializer. cxxCtorInitializer(; forField(fieldDecl()); ).bind(""add_prefix""). given:. struct Simple {};. struct Record {; Record() : i(42) {}; private:; int i;; Simple s;; };. 2 matches found. Replacement produces incorrect output:. struct Simple {};. struct Record {; m_Record() : m_i(42) {}; private:; int i;; Simple s;; };. 1 match found. Replacement produces correct output:. struct Simple {};. struct Record {; Record() : m_i(42) {}; private:; int i;; Simple s;; };. Ignored default arguments. callExpr(; callee(functionDecl(; hasName(""hasDefaultArg""); )),; argumentCountIs(1); ).bind(""add_prefix""). given:. void hasDefaultArg(int i, int j = 0) {}; void callDefaultArg() { hasDefaultArg(42); }. No match. 1 match found. Lambda fields. fieldDecl(; hasType(asString(""int"")); ).bind(""make_safe""). given:. struct S {; int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [safe_a, safe_b = c](int d) { int e = d; };; l(43);; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. Rewritten binary operators. binaryOperator(; hasOperatorName(""<""),; hasRHS(hasDescendant(int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:6250,Simpl,Simple,6250,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Simpl'],['Simple']
Usability,"l_array_with_indices(int *__counted_by(count) p, size_t count) {; // off-by-one error; for (size_t i = 0; i <= count; ++i); p[i] = i;; }. External bounds annotations include ``__counted_by``, ``__sized_by``, and; ``__ended_by``. These annotations do not change the pointer representation,; meaning they do not have ABI implications. * ``__counted_by(N)`` : The pointer points to memory that contains ``N``; elements of pointee type. ``N`` is an expression of integer type which can be; a simple reference to declaration, a constant including calls to constant; functions, or an arithmetic expression that does not have side effect. The; ``__counted_by`` annotation cannot apply to pointers to incomplete types or; types without size such as ``void *``. Instead, ``__sized_by`` can be used to; describe the byte count.; * ``__sized_by(N)`` : The pointer points to memory that contains ``N`` bytes.; Just like the argument of ``__counted_by``, ``N`` is an expression of integer; type which can be a constant, a simple reference to a declaration, or an; arithmetic expression that does not have side effects. This is mainly used for; pointers to incomplete types or types without size such as ``void *``.; * ``__ended_by(P)`` : The pointer has the upper bound of value ``P``, which is; one past the last element of the pointer. In other words, this annotation; describes a range that starts with the pointer that has this annotation and; ends with ``P`` which is the argument of the annotation. ``P`` itself may be; annotated with ``__ended_by(Q)``. In this case, the end of the range extends; to the pointer ``Q``. This is used for ""iterator"" support in C where you're; iterating from one pointer value to another until a final pointer value is; reached (and the final pointer value is not dereferencable). Accessing a pointer outside the specified bounds causes a run-time trap or a; compile-time error. Also, the model maintains correctness of bounds annotations; when the pointer and/or the related v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:10599,simpl,simple,10599,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['simpl'],['simple']
Usability,"language options are; not table generated nodes, new language options must be created manually and; should specify the spelling used by ``LangOptions`` class. Custom accessors can be generated for an attribute based on the spelling list; for that attribute. For instance, if an attribute has two different spellings:; 'Foo' and 'Bar', accessors can be created:; ``[Accessor<""isFoo"", [GNU<""Foo"">]>, Accessor<""isBar"", [GNU<""Bar"">]>]``; These accessors will be generated on the semantic form of the attribute,; accepting no arguments and returning a ``bool``. Attributes that do not require custom semantic handling should set the; ``SemaHandler`` field to ``0``. Note that anything inheriting from; ``IgnoredAttr`` automatically do not get a semantic handler. All other; attributes are assumed to use a semantic handler by default. Attributes; without a semantic handler are not given a parsed attribute ``Kind`` enumerator. ""Simple"" attributes, that require no custom semantic processing aside from what; is automatically provided, should set the ``SimpleHandler`` field to ``1``. Target-specific attributes may share a spelling with other attributes in; different targets. For instance, the ARM and MSP430 targets both have an; attribute spelled ``GNU<""interrupt"">``, but with different parsing and semantic; requirements. To support this feature, an attribute inheriting from; ``TargetSpecificAttribute`` may specify a ``ParseKind`` field. This field; should be the same value between all arguments sharing a spelling, and; corresponds to the parsed attribute's ``Kind`` enumerator. This allows; attributes to share a parsed attribute kind, but have distinct semantic; attribute classes. For instance, ``ParsedAttr`` is the shared; parsed attribute kind, but ARMInterruptAttr and MSP430InterruptAttr are the; semantic attributes generated. By default, attribute arguments are parsed in an evaluated context. If the; arguments for an attribute should be parsed in an unevaluated context (akin to; the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:140220,Simpl,Simple,140220,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['Simpl'],"['Simple', 'SimpleHandler']"
Usability,"language's runtime; library. The compiler plugin is responsible for generating code which conforms; to the binary interface defined by library, most essentially the :ref:`stack map; <stack-map>`. To subclass ``llvm::GCStrategy`` and register it with the compiler:. .. code-block:: c++. // lib/MyGC/MyGC.cpp - Example LLVM GC plugin. #include ""llvm/CodeGen/GCStrategy.h""; #include ""llvm/CodeGen/GCMetadata.h""; #include ""llvm/Support/Compiler.h"". using namespace llvm;. namespace {; class LLVM_LIBRARY_VISIBILITY MyGC : public GCStrategy {; public:; MyGC() {}; };. GCRegistry::Add<MyGC>; X(""mygc"", ""My bespoke garbage collector."");; }. This boilerplate collector does nothing. More specifically:. * ``llvm.gcread`` calls are replaced with the corresponding ``load``; instruction. * ``llvm.gcwrite`` calls are replaced with the corresponding ``store``; instruction. * No safe points are added to the code. * The stack map is not compiled into the executable. Using the LLVM makefiles, this code; can be compiled as a plugin using a simple makefile:. .. code-block:: make. # lib/MyGC/Makefile. LEVEL := ../..; LIBRARYNAME = MyGC; LOADABLE_MODULE = 1. include $(LEVEL)/Makefile.common. Once the plugin is compiled, code using it may be compiled using ``llc; -load=MyGC.so`` (though MyGC.so may have some other platform-specific; extension):. ::. $ cat sample.ll; define void @f() gc ""mygc"" {; entry:; ret void; }; $ llvm-as < sample.ll | llc -load=MyGC.so. It is also possible to statically link the collector plugin into tools, such as; a language-specific compiler front-end. .. _collector-algos:. Overview of available features; ------------------------------. ``GCStrategy`` provides a range of features through which a plugin may do useful; work. Some of these are callbacks, some are algorithms that can be enabled,; disabled, or customized. This matrix summarizes the supported (and planned); features and correlates them with the collection techniques which typically; require them. .. |v| unicode:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:25182,simpl,simple,25182,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['simpl'],['simple']
Usability,"lar; shared variables. (`Java Specification; <http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html>`_). * gcc-compatible ``__sync_*`` builtins. (`Description; <https://gcc.gnu.org/onlinedocs/gcc/_005f_005fsync-Builtins.html>`_). * Other scenarios with atomic semantics, including ``static`` variables with; non-trivial constructors in C++. Atomic and volatile in the IR are orthogonal; ""volatile"" is the C/C++ volatile,; which ensures that every volatile load and store happens and is performed in the; stated order. A couple examples: if a SequentiallyConsistent store is; immediately followed by another SequentiallyConsistent store to the same; address, the first store can be erased. This transformation is not allowed for a; pair of volatile stores. On the other hand, a non-volatile non-atomic load can; be moved across a volatile load freely, but not an Acquire load. This document is intended to provide a guide to anyone either writing a frontend; for LLVM or working on optimization passes for LLVM with a guide for how to deal; with instructions with special semantics in the presence of concurrency. This; is not intended to be a precise guide to the semantics; the details can get; extremely complicated and unreadable, and are not usually necessary. .. _Optimization outside atomic:. Optimization outside atomic; ===========================. The basic ``'load'`` and ``'store'`` allow a variety of optimizations, but can; lead to undefined results in a concurrent environment; see `NotAtomic`_. This; section specifically goes into the one optimizer restriction which applies in; concurrent environments, which gets a bit more of an extended description; because any optimization dealing with stores needs to be aware of it. From the optimizer's point of view, the rule is that if there are not any; instructions with atomic ordering involved, concurrency does not matter, with; one exception: if a variable might be visible to another thread or signal; handler, a store cannot b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:2020,guid,guide,2020,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,2,['guid'],['guide']
Usability,"lassification cost-sensitive boosting}, Proceedings of the 16th International conference on machine learning (ICML 1999)}. With the currently; chosen DEFAULT settings (all costs equal and set to ""one""), it is equivalent to the ""real-AdaBoost"" (i.e. using the option !UseYesNoLeaf (which uses the leave node purity rather than a signal or background attribute in the leaf node of each individual tree). Unfortunatly, no reasonable performance has been achieved yet when choosing different cost parameters. c) BDT's with little tree depth (as favoured for good performance) do not *like* it if; there are very clean signal and background separation cuts available, which however ; have NOT been applied yet as preselection. Now there is a possibility to choose the option; ""DoPreselection"" that looks for suitable preselection cuts and applies them prior to ; the Decision Tree training. While that works fine, this clearly gives ""sharp"" peaks at +1 (-1); for the MVA output distribution and therefore the ""smoothing"" of this distribution used to; produce the ROC curve and efficiency estimates are somewhat thwarted.; ; --> It's better if you do these preselection cuts YOURSELF when defining training and test; sample!. d) Removed completely the (hopefully never used) option of treating negative events weights; via: PairNegWeightsInNode. e) Renamed option: IgnoreNegEvents --> IgnoreNegEventsInTraining; and removed the IDENTICAL option NoNegeventsInTraining. 6) SVM; All but the Gauss kernel options have been ""removed"" (guess that was done already some; time ago, probably with the introduction of ""regression"", but was not properly announced; so far. 5) minor bug fixes . a) fix calculation of mean values of the MVA distribution; for signal and background samples, which is used to; decide if a cut on the MVA variable selects signal or; background. Due to the bug it sometimes was swapped. b) equalize the interpolation of the PDF-class that is used to; smooth the Gauss-Transformation, betwee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt:2966,clear,clearly,2966,documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt,1,['clear'],['clearly']
Usability,"late <class DataType, class Storage = bool,; class ParserClass = parser<DataType> >; class bits;; }. This class works the exact same as the `cl::list`_ class, except that the second; argument must be of **type** ``unsigned`` if external storage is used. .. _cl::alias:. The ``cl::alias`` class; ^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::alias`` class is a nontemplated class that is used to form aliases for; other arguments. .. code-block:: c++. namespace cl {; class alias;; }. The `cl::aliasopt`_ attribute should be used to specify which option this is an; alias for. Alias arguments default to being `cl::Hidden`_, and use the aliased; options parser to do the conversion from string to data. .. _cl::extrahelp:. The ``cl::extrahelp`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::extrahelp`` class is a nontemplated class that allows extra help text; to be printed out for the ``-help`` option. .. code-block:: c++. namespace cl {; struct extrahelp;; }. To use the extrahelp, simply construct one with a ``const char*`` parameter to; the constructor. The text passed to the constructor will be printed at the; bottom of the help message, verbatim. Note that multiple ``cl::extrahelp``; **can** be used, but this practice is discouraged. If your tool needs to print; additional help information, put all that help into a single ``cl::extrahelp``; instance. For example:. .. code-block:: c++. cl::extrahelp(""\nADDITIONAL HELP:\n\n This is the extra help\n"");. .. _cl::OptionCategory:. The ``cl::OptionCategory`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::OptionCategory`` class is a simple class for declaring; option categories. .. code-block:: c++. namespace cl {; class OptionCategory;; }. An option category must have a name and optionally a description which are; passed to the constructor as ``const char*``. Note that declaring an option category and associating it with an option before; parsing options (e.g. statically) will change the output of ``-help`` from; uncategorized to categor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:57408,simpl,simply,57408,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simply']
Usability,"lation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thing you need to do with ROOT is install it, don't you ? Obtaining; the latest ROOT version is straig",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3877,guid,guide,3877,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['guid'],['guide']
Usability,"lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. .. _alpha-unix-SimpleStream:. alpha.unix.SimpleStream (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check for misuses of stream APIs. Check for misuses of stream APIs: ``fopen, fclose``; (demo checker, the subject of the demo (`Slides <https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf>`_ ,; `Video <https://youtu.be/kdxlsP5QVPw>`_) by Anna Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); """"""""""""""""""""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTermina",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:77107,clear,clearerr,77107,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['clear'],['clearerr']
Usability,"ld contain an entry for each DWARF DIE whose; ``DW_TAG`` is a ``DW_TAG_label``, ``DW_TAG_inlined_subroutine``, or; ``DW_TAG_subprogram`` that has address attributes: ``DW_AT_low_pc``,; ``DW_AT_high_pc``, ``DW_AT_ranges`` or ``DW_AT_entry_pc``. It also contains; ``DW_TAG_variable`` DIEs that have a ``DW_OP_addr`` in the location (global and; static variables). All global and static variables should be included,; including those scoped within functions and classes. For example using the; following code:. .. code-block:: c. static int var = 0;. void f (); {; static int var = 0;; }. Both of the static ``var`` variables would be included in the table. All; functions should emit both their full names and their basenames. For C or C++,; the full name is the mangled name (if available) which is usually in the; ``DW_AT_MIPS_linkage_name`` attribute, and the ``DW_AT_name`` contains the; function basename. If global or static variables have a mangled name in a; ``DW_AT_MIPS_linkage_name`` attribute, this should be emitted along with the; simple name found in the ``DW_AT_name`` attribute. ""``.apple_types``"" sections should contain an entry for each DWARF DIE whose; tag is one of:. * DW_TAG_array_type; * DW_TAG_class_type; * DW_TAG_enumeration_type; * DW_TAG_pointer_type; * DW_TAG_reference_type; * DW_TAG_string_type; * DW_TAG_structure_type; * DW_TAG_subroutine_type; * DW_TAG_typedef; * DW_TAG_union_type; * DW_TAG_ptr_to_member_type; * DW_TAG_set_type; * DW_TAG_subrange_type; * DW_TAG_base_type; * DW_TAG_const_type; * DW_TAG_immutable_type; * DW_TAG_file_type; * DW_TAG_namelist; * DW_TAG_packed_type; * DW_TAG_volatile_type; * DW_TAG_restrict_type; * DW_TAG_atomic_type; * DW_TAG_interface_type; * DW_TAG_unspecified_type; * DW_TAG_shared_type. Only entries with a ``DW_AT_name`` attribute are included, and the entry must; not be a forward declaration (``DW_AT_declaration`` attribute with a non-zero; value). For example, using the following code:. .. code-block:: c. int main (); {; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:78400,simpl,simple,78400,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['simpl'],['simple']
Usability,"ld; like JIT'd code to be able to ""dlopen"" and ""dlclose"" JITDylibs, running all of; their initializers/deinitializers on the current thread. This would require; support from the runtime library described above. 3. **Debugging support**. ORC currently supports the GDBRegistrationListener API when using RuntimeDyld; as the underlying JIT linker. We will need a new solution for JITLink based; platforms. Further Future Work; -------------------. 1. **Speculative Compilation**. ORC's support for concurrent compilation allows us to easily enable; *speculative* JIT compilation: compilation of code that is not needed yet,; but which we have reason to believe will be needed in the future. This can be; used to hide compile latency and improve JIT throughput. A proof-of-concept; example of speculative compilation with ORC has already been developed (see; ``llvm/examples/SpeculativeJIT``). Future work on this is likely to focus on; re-using and improving existing profiling support (currently used by PGO) to; feed speculation decisions, as well as built-in tools to simplify use of; speculative compilation. .. [1] Formats/architectures vary in terms of supported features. MachO and; ELF tend to have better support than COFF. Patches very welcome!. .. [2] The ``LazyEmittingLayer``, ``RemoteObjectClientLayer`` and; ``RemoteObjectServerLayer`` do not have counterparts in the new; system. In the case of ``LazyEmittingLayer`` it was simply no longer; needed: in ORCv2, deferring compilation until symbols are looked up is; the default. The removal of ``RemoteObjectClientLayer`` and; ``RemoteObjectServerLayer`` means that JIT stacks can no longer be split; across processes, however this functionality appears not to have been; used. .. [3] Weak definitions are currently handled correctly within dylibs, but if; multiple dylibs provide a weak definition of a symbol then each will end; up with its own definition (similar to how weak definitions are handled; in Windows DLLs). This will be fix",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:37616,simpl,simplify,37616,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['simpl'],['simplify']
Usability,"le LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike ``printf`` it deduces the type; to be formatted at compile time, so it does not need a format specifier such as; ``%d``. This reduces the mental overhead of trying to construct portable format; strings, especially for platform-specific types like ``size_t`` or pointer types.; Unlike both ``printf`` and Python, it additionally fails to compile if LLVM does; not know how to format the type. These two properties ensure that the function; is both safer and simpler to use than traditional formatting methods such as; the ``printf`` family of functions. Simple formatting; ^^^^^^^^^^^^^^^^^. A call to ``formatv`` involves a single **format string** consisting of 0 or more; **replacement sequences**, followed by a variable length list of **replacement values**.; A replacement sequence is a string of the form ``{N[[,align]:style]}``. ``N`` refers to the 0-based index of the argument from the list of replacement; values. Note that this means it is possible to reference the same parameter; multiple times, possibly with different style and/or alignment options, in any order. ``align`` is an optional string specifying the width of the field to format; the value into, and the alignment of the value within the field. It is specified as; an optional **alignment style** followed by a positive integral **field width**. The; alignment style can be one of the characters ``-`` (left align), ``=`` (center align),; or ``+`` (right align). The default is right aligned. ``style`` is an optional string consisting of a type specific that controls the; formatting of the val",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:12215,Simpl,Simple,12215,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['Simpl'],['Simple']
Usability,"le extends from the; ``defvar`` statement to the end of the body. It cannot be set to a different; value within its scope. The ``defvar`` statement can also be used in the statement; list of a ``foreach``, which establishes a scope. A variable named ``V`` in an inner scope shadows (hides) any variables ``V``; in outer scopes. In particular, there are several cases:. * ``V`` in a record body shadows a global ``V``. * ``V`` in a record body shadows template argument ``V``. * ``V`` in template arguments shadows a global ``V``. * ``V`` in a ``foreach`` statement list shadows any ``V`` in surrounding record or; global scopes. Variables defined in a ``foreach`` go out of scope at the end of; each loop iteration, so their value in one iteration is not available in; the next iteration. The following ``defvar`` will not work::. defvar i = !add(i, 1). How records are built; ---------------------. The following steps are taken by TableGen when a record is built. Classes are simply; abstract records and so go through the same steps. 1. Build the record name (:token:`NameValue`) and create an empty record. 2. Parse the parent classes in the :token:`ParentClassList` from left to; right, visiting each parent class's ancestor classes from top to bottom. a. Add the fields from the parent class to the record.; b. Substitute the template arguments into those fields.; c. Add the parent class to the record's list of inherited classes. 3. Apply any top-level ``let`` bindings to the record. Recall that top-level; bindings only apply to inherited fields. 4. Parse the body of the record. * Add any fields to the record.; * Modify the values of fields according to local ``let`` statements.; * Define any ``defvar`` variables. 5. Make a pass over all the fields to resolve any inter-field references. 6. Add the record to the final record list. Because references between fields are resolved (step 5) after ``let`` bindings are; applied (step 3), the ``let`` statement has unusual power. For example:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:53350,simpl,simply,53350,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simply']
Usability,"le of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8768,clear,clear,8768,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['clear'],['clear']
Usability,"le to create our wire with a single line:. ``` {.cpp}; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"",ptrCOPPER,; 0,0.01,1); //(*); ```. **(\*)** The same applies for all primitive shapes, for which there can; be found corresponding `MakeSHAPE()` methods. Their usage is much more; convenient unless a shape has to be shared between more volumes. Let us make now an aluminum wire having the same shape, supposing that; we have created the copper wire with the line above:. ``` {.cpp}; TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"",wire_co>GetShape(),; ptrAL);; ```. We would like now to position our wire in the middle of a gas chamber.; We need first to define the gas chamber:. ``` {.cpp}; TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"",ptrGAS,; 0,1,1);; ```. Now we can put the wire inside:. ``` {.cpp}; chamber->AddNode(wire_co,1);; ```. If we inspect now the chamber volume in a browser, we will notice that; it has one daughter. Of course, the gas has some container also, but let; us keeps it like that for the sake of simplicity. Since we did not; supply the third argument, the wire will be positioned with an identity; transformation inside the chamber. #### Overlapping Volumes. Positioning volumes that does not overlap their neighbors nor extrude; their container is sometimes quite strong constraint. Having a limited; set of geometric shapes might force sometimes overlaps. Since; overlapping is contradictory to containment, a point belonging to an; overlapping region will naturally belong to all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite shapes. What we ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:74919,simpl,simplicity,74919,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simplicity']
Usability,"le, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guaranteed to be deterministic, so; any uses which require that should instead use a std::map. .. _dss_indexmap:. llvm/ADT/IndexedMap.h; ^^^^^^^^^^^^^^^^^^^^^. IndexedMap is a specialized container for mapping small dense integers (or; values that can be mapped to small dense integers) to some other type. It is; internally implemented as a vector with a mapping function that maps the keys; to the dense integer range. This is useful for cases like virtual registers in the LLVM code generator: they; have a dense mapping that is offset by a compile-time constant (the first; virtual register ID). .. _dss_densemap:. llvm/ADT/DenseMap.h; ^^^^^^^^^^^^^^^^^^^. DenseMap is a simple quadratically probed hash table. It excels at supporting; small keys and values: it uses a single allocation to hold all of the pairs; that are currently inserted in the map. DenseMap is a great way to map; pointers to pointers, or map other small types to each other. There are several aspects of DenseMap that you should be aware of, however.; The iterators in a DenseMap are invalidated whenever an insertion occurs,; unlike map. Also, because DenseMap allocates space for a large number of; key/value pairs (it starts with 64 by default), it will waste a lot of space if; your keys or values are large. Finally, you must implement a partial; specialization of DenseMapInfo for the key that you want, if it isn't already; supported. This is required to tell DenseMap about two special marker values; (which can never be inserted into the map) that it needs internally. DenseMap's find_as() method supports lookup operations using an alternate key; type. This is useful in cases where the normal key typ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:90681,simpl,simple,90681,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"le. But it may produce surprising results if the; debugging code depends on consistent use of ``NDEBUG`` also in other translation units. Definitions consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translation units. However, in the practice, we found the existing ODR checking mechanism is not stable; enough. Many people suffers from the false positive ODR violation diagnostics, AKA,; the compiler are complaining two identical declarations have different definitions; incorrectly. Also the true positive ODR violations are rarely reported.; Also we learned that MSVC don't perform ODR check for declarations in the global module; fragment. So in order to get better user experience, save the time checking ODR and keep consistent; behavior with MSVC, we disabled the ODR check for the declarations in the global module; fragment by default. Users who want more strict check can still use the; ``-Xclang -fno-skip-odr-check-in-gmf`` flag to get the ODR check enabled. It is also; encouraged to report issues if users find false positive ODR violations or false negative ODR; violations with the flag enabled. ABI Impacts; -----------. The declarations in a module unit which are not in the global module fragment have new linkage names. For example,. .. code-block:: c++. export module M;; namespace NS {; export int foo();; }. The linkage name of ``NS::foo()`` would be ``_ZN2NSW1M3fooEv``.; This couldn't be demangled by previous versions of the debugger or demangler.; As of LLVM 15.x, users can utilize ``llvm-cxxfilt`` to demangle this:. .. code-block:: console. $ llvm-cxxfilt _ZN2NSW",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:17749,learn,learned,17749,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['learn'],['learned']
Usability,"le;; auto await_ready() { return false; }; auto await_suspend(std::coroutine_handle<> continuation) {; handle.promise().continuation = continuation;; return handle;; }; int await_resume() {; int ret = handle.promise().result;; handle.destroy();; return ret;; }; };; return Awaiter{std::exchange(handle, nullptr)};; }. int syncStart() {; handle.resume();; return handle.promise().result;; }. private:; std::coroutine_handle<promise_type> handle;; };. task task::promise_type::get_return_object() {; return std::coroutine_handle<promise_type>::from_promise(*this);; }. namespace detail {; template <int N>; task chain_fn() {; co_return N + co_await chain_fn<N - 1>();; }. template <>; task chain_fn<0>() {; // This is the default breakpoint.; __builtin_debugtrap();; co_return 0;; }; } // namespace detail. task chain() {; co_return co_await detail::chain_fn<30>();; }. int main() {; std::cout << chain().syncStart() << ""\n"";; return 0;; }. In the example, the ``task`` coroutine holds a ``continuation`` field,; which would be resumed once the ``task`` completes.; In another word, the ``continuation`` is the asynchronous caller for the ``task``.; Just like the normal function returns to its caller when the function completes. So we can use the ``continuation`` field to construct the asynchronous stack:. .. code-block:: python. # debugging-helper.py; import gdb; from gdb.FrameDecorator import FrameDecorator. class SymValueWrapper():; def __init__(self, symbol, value):; self.sym = symbol; self.val = value. def __str__(self):; return str(self.sym) + "" = "" + str(self.val). def get_long_pointer_size():; return gdb.lookup_type('long').pointer().sizeof. def cast_addr2long_pointer(addr):; return gdb.Value(addr).cast(gdb.lookup_type('long').pointer()). def dereference(addr):; return long(cast_addr2long_pointer(addr).dereference()). class CoroutineFrame(object):; def __init__(self, task_addr):; self.frame_addr = task_addr; self.resume_addr = task_addr; self.destroy_addr = task_addr + get_long",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:14614,resume,resumed,14614,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resumed']
Usability,"le`, `Event.cxx`, and `Event.h` for an example, or follow this; link: <http://root.cern.ch/root/RootCintMan.html>. ## genreflex: A Comfortable Interface to rootcling. Version 5 supported both `Cint` and `Reflex` dictionaries. The tool to create; `Reflex` dictionaries was a Python script called `genreflex` and was very; successful in the user community.; Even if version 6 has only one type of dictionaries, `cling` dictionaries,; a re-implementation of `genreflex` is provided.; More precisely, in ROOT6, `genreflex` is nothing but a wrapper around; `rootcling`, which offers an identical CLI and behaviour to the old Python; tool.; The input to `genreflex` is a C++ header file, a set of switches and a; *selection XML file*. The output, as for `rootcling`, is a C++ dictionary; source and a `pcm` files.; An exhaustive documentation of the CLI switches of `genreflex` can be; inspected with the `genreflex --help` command. The entity corresponding to the `LinkDef` file for `genreflex` is the; *selection XML file*, also called *selection XML* or simply *selection file*.; A *selection XML file* allows to describe a list of classes for which; the dictionaries are to be created. In addition, it allows to specify; properties of classes or data members, without the need to add comments in; the source code. This is of primary importance when dictionaries must be; created for classes residing in code which cannot be modified.; For a complete description of the structure of the *selection XML files*; and the way in which attributes can be set, refer to the `genreflex --help`; command. It is important to observe that *selection XML files* can be used in presence; of `rootcling` invocations instead of `LinkDef` files. ### The `ROOT::Meta::Selection` namespace. Not only `LinkDef` and `selection` files allow to select the classes for which; the dictionaries must be created: a third method is available. This is; represented by the `ROOT::Meta::Selection` namespace. The idea behind this; tec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:34566,simpl,simply,34566,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['simpl'],['simply']
Usability,"ledVGPRs"" integer Number of stores from; a vector register to; a register allocator; created spill; location.; ============================ ============== ========= =====================. .. _amdgpu-amdhsa-code-object-metadata-v3:. Code Object V3 Metadata; +++++++++++++++++++++++. .. warning::; Code object V3 generation is no longer supported by this version of LLVM. Code object V3 and above metadata is specified by the ``NT_AMDGPU_METADATA`` note; record (see :ref:`amdgpu-note-records-v3-onwards`). The metadata is represented as Message Pack formatted binary data (see; [MsgPack]_). The top level is a Message Pack map that includes the; keys defined in table; :ref:`amdgpu-amdhsa-code-object-metadata-map-table-v3` and referenced; tables. Additional information can be added to the maps. To avoid conflicts,; any key names should be prefixed by ""*vendor-name*."" where; ``vendor-name`` can be the name of the vendor and specific vendor; tool that generates the information. The prefix is abbreviated to; simply ""."" when it appears within a map that has been added by the; same *vendor-name*. .. table:: AMDHSA Code Object V3 Metadata Map; :name: amdgpu-amdhsa-code-object-metadata-map-table-v3. ================= ============== ========= =======================================; String Key Value Type Required? Description; ================= ============== ========= =======================================; ""amdhsa.version"" sequence of Required - The first integer is the major; 2 integers version. Currently 1.; - The second integer is the minor; version. Currently 0.; ""amdhsa.printf"" sequence of Each string is encoded information; strings about a printf function call. The; encoded information is organized as; fields separated by colon (':'):. ``ID:N:S[0]:S[1]:...:S[N-1]:FormatString``. where:. ``ID``; A 32-bit integer as a unique id for; each printf function call. ``N``; A 32-bit integer equal to the number; of arguments of printf function call; minus 1. ``S[i]`` (where i = 0, 1, .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:130264,simpl,simply,130264,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['simpl'],['simply']
Usability,"ler itself.; Fortunately, our current setup makes it very easy to add global; variables: just have value lookup check to see if an unresolved; variable is in the global variable symbol table before rejecting it.; To create a new global variable, make an instance of the LLVM; ``GlobalVariable`` class.; - **typed variables** - Kaleidoscope currently only supports variables; of type double. This gives the language a very nice elegance, because; only supporting one type means that you never have to specify types.; Different languages have different ways of handling this. The easiest; way is to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is so nifty/unconventional, it `has its own; FAQ <../../GetElementPtr.html>`_!; - **standard runtime** - Our current language allows the user to access; arbitrary external functions, and we use it for things like ""printd""; and ""putchard"". As you extend the language to add higher-level; constructs, often these constructs make the most sense if they are; lowered to calls into a language-supplied runtime. For example, if; you add hash tables to the language, it would probably make sense to; add the routines to a runtime, instead of inlining them all the way.; - **memory management** - Currently we can only access the stack in; Kaleidoscope. It would also be useful to be able to allocate heap; memory, either with calls to the standard libc malloc/free interface; or with a garbage collector. If you would like to use garbage; collection, note that LLVM fully supports `Accurate Garbage",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:2542,learn,learning,2542,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['learn'],['learning']
Usability,"ler. Disable scheduling after register allocation. .. option:: -disable-spill-fusing. Disable fusing of spill code into instructions. .. option:: -jit-enable-eh. Exception handling should be enabled in the just-in-time compiler. .. option:: -join-liveintervals. Coalesce copies (default=true). .. option:: -nozero-initialized-in-bss. Don't place zero-initialized symbols into the BSS section. .. option:: -pre-RA-sched=scheduler. Instruction schedulers available (before register allocation):. .. code-block:: text. =default: Best scheduler for the target; =none: No scheduling: breadth first sequencing; =simple: Simple two pass scheduling: minimize critical path and maximize processor utilization; =simple-noitin: Simple two pass scheduling: Same as simple except using generic latency; =list-burr: Bottom-up register reduction list scheduling; =list-tdrr: Top-down register reduction list scheduling; =list-td: Top-down list scheduler. .. option:: -regalloc=allocator. Register allocator to use (default=linearscan). .. code-block:: text. =bigblock: Big-block register allocator; =linearscan: linear scan register allocator; =local: local register allocator; =simple: simple register allocator. .. option:: -relocation-model=model. Choose relocation model from:. .. code-block:: text. =default: Target default relocation model; =static: Non-relocatable code; =pic: Fully relocatable, position independent code; =dynamic-no-pic: Relocatable external references, non-relocatable code. .. option:: -spiller. Spiller to use (default=local). .. code-block:: text. =simple: simple spiller; =local: local spiller. .. option:: -x86-asm-syntax=syntax. Choose style of code to emit from X86 backend:. .. code-block:: text. =att: Emit AT&T-style assembly; =intel: Emit Intel-style assembly. EXIT STATUS; -----------. If :program:`lli` fails to load the program, it will exit with an exit code of 1.; Otherwise, it will return the exit code of the program it executes. SEE ALSO; --------. :manpage:`llc(1)`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst:5001,simpl,simple,5001,interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst,4,['simpl'],['simple']
Usability,"lick on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the |; | | `rootcling` utility to generate the Cling interface |; | | `EventCint.cxx` |; +-------------------+--------------------------------------------------------+; | `Event.cxx` | Implementation for classes Event and Track |; +-------------------+--------------------------------------------------------+; | `minexam.cxx` | Simple test program for data fitting |; +-------------------+--------------------------------------------------------+; | `tcollex.cxx` | Example usage of the ROOT collection classes |; +-------------------+--------------------------------------------------------+; | `tcollbm.cxx` | Benchmarks of ROOT collection classes |; +-------------------+--------------------------------------------------------+",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:2152,Simpl,Simple,2152,documentation/users-guide/TutorialsandTests.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md,2,"['Simpl', 'simpl']","['Simple', 'simple']"
Usability,"lidity of the pointer value. In particular if the; pointer points, directly or indirectly, back to the current object, this; will result in an infinite recursion and the abrupt end of the process. ``` {.cpp}; TClonesArray *fTracks; //->; TH1F *fH; //->; ```. ### Variable Length Array. When the `Streamer `comes across a pointer to a simple type, it assumes; it is an array. Somehow, it has to know how many elements are in the; array to reserve enough space in the buffer and write out the; appropriate number of elements. This is done in the class definition.; For example:. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; ```. The array `fClosestDistance` is defined as a pointer of floating point; numbers. A comment mark (//), and the number in square brackets tell the; `Streamer `the length of the array for this object. In general the; syntax is:. ``` {.cpp}; <simple type> *<name>//[<length>]; ```. The length cannot be an expression. If a variable is used, it needs to; be an integer data member of the class. It must be defined ahead of its; use, or in a base class. The same notation also applies to variable length array of object and; variable length array of pointer to objects. ``` {.cpp}; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; ```. ### Double32\_t. Math operations very often require double precision, but on saving; single usually precision is sufficient. For this purpose we support the; typedef Double32\_t which is stored in memory as a double and on disk as; a float or integer. The actual size of disk (before compression) is; determined by the parameter next to the data member declaration. For; example:. ``` {.cpp}; Double32_t m_data; //[min,max<,nbits>]; ```. If the comment is absent or does not contain `min`, `max`,; `nbits`, the member is saved as a `float`. If `min` and `max` are present, they are saved with 32 bits precision.; `min`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:47394,simpl,simple,47394,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"lify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize generated code. This pass obviously modifies the CFG, but updates loop information and; dominator information. ``loop-unroll``: Unroll loops; -----------------------------. This pass implements a simple loop unroller. It works best when loops have; been canonicalized by the :ref:`indvars <passes-indvars>` pass, allowing it to; determine the trip counts of loops easily. ``loop-unroll-and-jam``: Unroll and Jam loops; ---------------------------------------------. This pass implements a simple unroll and jam classical loop optimisation pass.; It transforms loop from:. .. code-block:: c++. for i.. i+= 1 for i.. i+= 4; for j.. for j..; code(i, j) code(i, j); code(i+1, j); code(i+2, j); code(i+3, j); remainder loop. Which can be seen as unrolling the outer loop and ""jamming"" (fusing) the inner; loops into one. When variables or loads can be shared in the new inner loop, this; can lead to significant performance improvements. It uses; :ref:`Dependence Analysis <passes-da>` for proving the transformations are safe. ``lower-global-dtors``: Lower global destructors; ------------------------------------------------. This pass lowers global module destructors (``llvm.global_dtors``) by cr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:27972,simpl,simple,27972,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"limits or the FUMILI algorithm, which is an optimized method for least square and log likelihood minimizations. The package has been originally developed by M. Winkler and F. James. More information on the new C++ version can be found on the <a href=""http://www.cern.ch/minuit"">MINUIT Web Site</a> and in particular the online doc can be found here <a href=""http://www.cern.ch/mathlibs/sw/html/Minuit2.html"">here</a>.<p>; Minuit2, originally developed in the SEAL project, is now distributed within ROOT. The API has been then changed in this new version to follow the ROOT coding convention (function names starting with capital letters) and the classes have been moved inside the namespace <em>ROOT::Minuit2</em>. In addition, the ROOT distribution contains classes like TFitterMinuit and TFitterFumili needed to integrate Minuit2 in the ROOT framework. <p>; In the latest version (from 5.17.08) a new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements the interface; ROOT::Math::Minimizer from <a href=""http://www.cern.ch/mathlibs/sw/html/MathCore.html"">MathCore</a>.; . It can be instantiates also using the ROOT plug-in manager. It is a convenient entry point for using Minuit2. <h3>References</h3>; <p>; <ol>; <li>; F. James, <em>Fortran MINUIT Reference Manual</em> (<a href=""https://cern-tex.web.cern.ch/cern-tex/minuit/minmain.html"">html</a>); </li>; <li>; F. James and M. Winkler, <em>C++ MINUIT User's Guide</em> (<a href=""http://seal.cern.ch/documents/minuit/mnusersguide.pdf"">pdf</a>); </li>; <li>; F. James, <em>Minuit Tutorial on Function Minimization</em> (<a href=""http://seal.cern.ch/documents/minuit/mntutorial.pdf"">pdf</a>); </li>; <li>; F. James, <em>The Interpretation of Errors in Minuit</em> (<a href=""http://seal.cern.ch/documents/minuit/mnerror.pdf"">pdf</a>); </li>; </ol>; <p>; <hr>; <h3>See also:</h3>; <ul>; <li>Recommended <a href=""http://www.cern.ch/mathlibs/sw/html/Minuit2.html"">Online doc for all Minuit2 classes</a></li>; </ul>; END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/index.txt:1862,Guid,Guide,1862,math/minuit2/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/index.txt,1,['Guid'],['Guide']
Usability,"list of commands that are used in documentation comments. ArmNeon; -------. Generate arm_neon.h for clang. ArmNeonSema; -----------. Generate ARM NEON sema support for clang. ArmNeonTest; -----------. Generate ARM NEON tests for clang. AttrDocs; --------. **Purpose**: Creates ``AttributeReference.rst`` from ``AttrDocs.td``, and is; used for documenting user-facing attributes. General BackEnds; ================. Print Records; -------------. The TableGen command option ``--print-records`` invokes a simple backend; that prints all the classes and records defined in the source files. This is; the default backend option. See the :doc:`TableGen Backend Developer's Guide; <./BackGuide>` for more information. Print Detailed Records; ----------------------. The TableGen command option ``--print-detailed-records`` invokes a backend; that prints all the global variables, classes, and records defined in the; source files, with more detail than the default record printer. See the; :doc:`TableGen Backend Developer's Guide <./BackGuide>` for more; information. JSON Reference; --------------. **Purpose**: Output all the values in every ``def``, as a JSON data; structure that can be easily parsed by a variety of languages. Useful; for writing custom backends without having to modify TableGen itself,; or for performing auxiliary analysis on the same TableGen data passed; to a built-in backend. **Output**:. The root of the output file is a JSON object (i.e. dictionary),; containing the following fixed keys:. * ``!tablegen_json_version``: a numeric version field that will; increase if an incompatible change is ever made to the structure of; this data. The format described here corresponds to version 1. * ``!instanceof``: a dictionary whose keys are the class names defined; in the TableGen input. For each key, the corresponding value is an; array of strings giving the names of ``def`` records that derive; from that class. So ``root[""!instanceof""][""Instruction""]``, for; example, would li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:14775,Guid,Guide,14775,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,1,['Guid'],['Guide']
Usability,"lit - LLVM Integrated Tester; ============================. .. program:: lit. SYNOPSIS; --------. :program:`lit` [*options*] [*tests*]. DESCRIPTION; -----------. :program:`lit` is a portable tool for executing LLVM and Clang style test; suites, summarizing their results, and providing indication of failures.; :program:`lit` is designed to be a lightweight testing tool with as simple a; user interface as possible. :program:`lit` should be run with one or more *tests* to run specified on the; command line. Tests can be either individual test files or directories to; search for tests (see :ref:`test-discovery`). Each specified test will be executed (potentially concurrently) and once all; tests have been run :program:`lit` will print summary information on the number; of tests which passed or failed (see :ref:`test-status-results`). The; :program:`lit` program will execute with a non-zero exit code if any tests; fail. By default :program:`lit` will use a succinct progress display and will only; print summary information for test failures. See :ref:`output-options` for; options controlling the :program:`lit` progress display and output. :program:`lit` also includes a number of options for controlling how tests are; executed (specific features may depend on the particular test format). See; :ref:`execution-options` for more information. Finally, :program:`lit` also supports additional options for only running a; subset of the options specified on the command line, see; :ref:`selection-options` for more information. :program:`lit` parses options from the environment variable ``LIT_OPTS`` after; parsing options from the command line. ``LIT_OPTS`` is primarily useful for; supplementing or overriding the command-line options supplied to :program:`lit`; by ``check`` targets defined by a project's build system. :program:`lit` can also read options from response files which are specified as; inputs using the ``@path/to/file.rsp`` syntax. Arguments read from a file must; be one p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:379,simpl,simple,379,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['simpl'],['simple']
Usability,"lities -; check this out:. ::. ready> extern sin(x);; Read extern:; declare double @sin(double). ready> extern cos(x);; Read extern:; declare double @cos(double). ready> sin(1.0);; Read top-level expression:; define double @2() {; entry:; ret double 0x3FEAED548F090CEE; }. Evaluated to 0.841471. ready> def foo(x) sin(x)*sin(x) + cos(x)*cos(x);; Read function definition:; define double @foo(double %x) {; entry:; %calltmp = call double @sin(double %x); %multmp = fmul double %calltmp, %calltmp; %calltmp2 = call double @cos(double %x); %multmp4 = fmul double %calltmp2, %calltmp2; %addtmp = fadd double %multmp, %multmp4; ret double %addtmp; }. ready> foo(4.0);; Read top-level expression:; define double @3() {; entry:; %calltmp = call double @foo(double 4.000000e+00); ret double %calltmp; }. Evaluated to 1.000000. Whoa, how does the JIT know about sin and cos? The answer is surprisingly; simple: The KaleidoscopeJIT has a straightforward symbol resolution rule that; it uses to find symbols that aren't available in any given module: First; it searches all the modules that have already been added to the JIT, from the; most recent to the oldest, to find the newest definition. If no definition is; found inside the JIT, it falls back to calling ""``dlsym(""sin"")``"" on the; Kaleidoscope process itself. Since ""``sin``"" is defined within the JIT's; address space, it simply patches up calls in the module to call the libm; version of ``sin`` directly. But in some cases this even goes further:; as sin and cos are names of standard math functions, the constant folder; will directly evaluate the function calls to the correct result when called; with constants like in the ""``sin(1.0)``"" above. In the future we'll see how tweaking this symbol resolution rule can be used to; enable all sorts of useful features, from security (restricting the set of; symbols available to JIT'd code), to dynamic code generation based on symbol; names, and even lazy compilation. One immediate benefit of the symb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:22642,simpl,simple,22642,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simple']
Usability,"lity guarantees for the raw; profile format. Raw profiles may be dependent on the specific compiler; revision used to generate them. It's inadvisable to store raw profiles for; long periods of time. * Tools must retain **backwards** compatibility with indexed profile formats.; These formats are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that the mapping; from source regions to profile counters is immutable, and is generated before; the llvm optimizer kicks in. The optimizer can't prove that profile counter; instrumentation is safe to delete (because it's not: it affects the profile the; program emits), and so leaves it alone. Note that this coverage feature does not rely on information that can degrade; during the course of optimization, such as debug info line tables. Using the profiling runtime without static initializers; =======================================================. By default the compiler runtime uses a static initializer to determine the; profile output path and to register a writer function. To collect profiles; without using static initializers, do this manually:. * Export a ``int __llvm_profile_runtime`` symbol from each instrumented shared; library and executable. When the linker finds a definition of this symbol, it; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:14756,simpl,simplification,14756,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['simpl'],['simplification']
Usability,"lity. - The following code should produce a plot. It did not. ``` {.cpp}; TH1F* h=new TH1F(""hist"", ""histogram"", 10, 0, 3);; h->FillRandom(""gaus"");; h->Draw(""same"");; ```; - Make sure histograms having quotes in title are properly saved in .C files. ### TH2, TH3. - Add new functions `TH2::QuantilesX` and `TH2::QuantilesY` to return in a 1D histogram the projected quantiles distribution along; the other Y or X axis. The return histogram will have as bin error an approximate error on the quantile assuming a normal distribution of the; bin contents in the other axis. - Update Projection methods of both TH2 and TH3 to not return a null; pointer when an histogram with the same name already existed and it; was not compatible. Now just set the new correct binning on the; previously existing histogram. ### TGraph. - `TGraph::Draw()` needed at least the option `AL` to draw the graph; axis even when there was no active canvas or when the active canvas; did not have any axis defined. This was counter-intuitive. Now if; `TGraph::Draw()` is invoked without parameter and if there is no; axis defined in the current canvas, the option `ALP` is automatically; set.; - Change `SavePrimtive()` to improve speed compilation on generated macros. ### TGraph2D. - When `GetX(YZ)axis` were called on a `TGraph2D`, the frame limit and; plotting options were changed.; - Modify the `Clear` function in order to be able to reuse a; `TGraph2D` after a `Clear` is performed.; - In `GetHistogram()` the lower and higher axis limits are always; different.; - Protection added to avoid a Seg Fault on `.q` when `SetHistogram()`; is called on a `TGraph2D`. ### TMultiGraph. - In `TMultiGraph::Add(TMultiGraph *multigraph, Option_t *chopt)`; If `chopt` is defined all the graphs in `multigraph` will be added; with the `chopt` option. If `chopt` is undefined each graph will; be added with the option it had in `multigraph`.; - The option ""A"" in the `Draw()` was not cleaning properly the; current pad.; - Implement t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:10845,intuit,intuitive,10845,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['intuit'],['intuitive']
Usability,"ll call; ``abandon`` to indicate that some error occurred during linking. A call to the; ``InFlightAlloc::finalize`` method should cause content for the allocation to be; transferred from working to executor memory, and permissions to be run. A call; to ``abandon`` should result in both kinds of memory being deallocated. On successful finalization, the ``InFlightAlloc::finalize`` method should; construct a ``FinalizedAlloc`` object (an opaque uint64_t id that the; ``JITLinkMemoryManager`` can use to identify executor memory for deallocation); and pass it to the ``OnFinalized`` callback. Finalized allocations (represented by ``FinalizedAlloc`` objects) can be; deallocated by calling the ``JITLinkMemoryManager::dealloc`` method. This method; takes a vector of ``FinalizedAlloc`` objects, since it is common to deallocate; multiple objects at the same time and this allows us to batch these requests for; transmission to the executing process. JITLink provides a simple in-process implementation of this interface:; ``InProcessMemoryManager``. It allocates pages once and re-uses them as both; working and target memory. ORC provides a cross-process-capable ``MapperJITLinkMemoryManager`` that can use; shared memory or ORC-RPC-based communication to transfer content to the executing; process. JITLinkMemoryManager and Security; ---------------------------------. JITLink's ability to link JIT'd code for a separate executor process can be; used to improve the security of a JIT system: The executor process can be; sandboxed, run within a VM, or even run on a fully separate machine. JITLink's memory manager interface is flexible enough to allow for a range of; trade-offs between performance and security. For example, on a system where code; pages must be signed (preventing code from being updated), the memory manager; can deallocate working memory pages after linking to free memory in the process; running JITLink. Alternatively, on a system that allows RWX pages, the memory; manager",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:30330,simpl,simple,30330,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['simpl'],['simple']
Usability,"ll double @foo(); br label %ifcont. else: ; preds = %entry; %calltmp1 = call double @bar(); br label %ifcont. ifcont: ; preds = %else, %then; %iftmp = phi double [ %calltmp, %then ], [ %calltmp1, %else ]; ret double %iftmp; }. To visualize the control flow graph, you can use a nifty feature of the; LLVM '`opt <https://llvm.org/cmds/opt.html>`_' tool. If you put this LLVM; IR into ""t.ll"" and run ""``llvm-as < t.ll | opt -passes=view-cfg``"", `a; window will pop up <../../ProgrammersManual.html#viewing-graphs-while-debugging-code>`_ and you'll; see this graph:. .. figure:: LangImpl05-cfg.png; :align: center; :alt: Example CFG. Example CFG. Another way to get this is to call ""``F->viewCFG()``"" or; ""``F->viewCFGOnly()``"" (where F is a ""``Function*``"") either by; inserting actual calls into the code and recompiling or by calling these; in the debugger. LLVM has many nice features for visualizing various; graphs. Getting back to the generated code, it is fairly simple: the entry block; evaluates the conditional expression (""x"" in our case here) and compares; the result to 0.0 with the ""``fcmp one``"" instruction ('one' is ""Ordered; and Not Equal""). Based on the result of this expression, the code jumps; to either the ""then"" or ""else"" blocks, which contain the expressions for; the true/false cases. Once the then/else blocks are finished executing, they both branch back; to the 'ifcont' block to execute the code that happens after the; if/then/else. In this case the only thing left to do is to return to the; caller of the function. The question then becomes: how does the code; know which expression to return?. The answer to this question involves an important SSA operation: the; `Phi; operation <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; If you're not familiar with SSA, `the wikipedia; article <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; is a good introduction and there are various other introductions to it; available on your favorite sea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:6574,simpl,simple,6574,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['simpl'],['simple']
Usability,"ll page budget is reached,; pages larger than the page at hand are flushed before the page at hand is flushed.; For the parallel writer, every fill context maintains the page memory budget independently. Note that the total amount of memory consumed for writing is usually larger than the write page budget.; For instance, if buffered writing is used (the default), additional memory is required.; Use RNTupleModel::EstimateWriteMemoryUsage() for the total estimated memory use for writing. The default values are tuned for a total write memory of around 300 MB per writer resp. fill context.; In order to decrease the memory consumption,; users should decrease the target cluster size before tuning more intricate memory settings. Notes; =====. Approximation of the compressed cluster size; --------------------------------------------. The estimator for the compressed cluster size uses the average compression factor; of the so far written clusters.; This has been choosen as a simple, yet expectedly accurate enough estimator (to be validated).; The following alternative strategies were discussed:. - The average compression factor of all so-far written pages.; Easy to implement.; It would better prevent outlier clusters from skewing the estimate of the successor clusters.; It would be slower though in adjusting to systematic changes in the data set,; e.g. ones that are caused by changing experimental conditions during data taking. - The average over a window of the last $k$ clusters, possibly with exponential smoothing.; More code compared to the average compression factor or all so-far written clusters.; It would be faster in adjusting to systematic changes in the data set,; e.g. ones that are caused by changing experimental conditions during data taking.; Could be a viable option if cluster compression ratios turn out to change significantly in a single file. - Calculate the cluster compression ratio from column-based individual estimators.; More complex to implement and to r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/tuning.md:3345,simpl,simple,3345,tree/ntuple/v7/doc/tuning.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/tuning.md,1,['simpl'],['simple']
Usability,"ll use JSROOT provided with ROOT installation. This allows to use notebooks; without internet connection (offline). ## JavaScript ROOT; - Provide monitoring capabilities for TGeoManager object. Now geomtry with some tracks can be displayed and; updated in web browser, using THttpServer monitoring capability like histogram objects. ## Tutorials; - Add the ""Legacy"" category collecting the old tutorials which do not represent any more best practices. ## Class Reference Guide; - Images in tutorials can now be displayed à JavaScript thanks to the (js) option; added next to the directive `\macro_image`; - As the tutorial `palettes.C` is often hit when searching the keyword `palette`; in the reference guide, a direct link from this example to the full list of; predefined palettes given in `TColor` has been added.; - Revisited the TSpectrum2 documentation. All the static images have been replaced; by macros generating images at reference guide build time. These macros have; been added in the tutorial section of the reference guide.; - The Reference Guide can now be accessed directly from the ROOT prompt thanks to; a great extension (implemented by Desislava Kalaydjieva) of the `.help` command.; For example to access the Reference Guide for `TTree` it is enough to type:; ~~~ {.cpp}; root[0] .help TTree; ~~~; To open the reference guide for a function/member:; ~~~ {.cpp}; root[0] .help TTree::Draw; ~~~. ## Build, Configuration and Testing Infrastructure. - Make MLP optional via the `-Dmlp={OFF,ON}` switch for CMake; - Make Spectrum optional via the `-Dspectrum={OFF,ON}` switch for CMake; - ROOT now fails to configure when any package is missing; when `-Dfail-on-missing=ON` is passed to CMake; - The `-Dall=ON` now switches the default value of all optional packages to `ON`; - The options `astiff`, `cling`, `pch`, `thread`, and `explicitlink` have been; removed and are now ignored. They either had no effect (their value was not; being used in the build system), or could not be ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:7422,guid,guide,7422,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['guid'],['guide']
Usability,"ll.; If '``address``' is ``poison`` or ``undef``, this instruction has undefined; behavior. Implementation:; """""""""""""""""""""""""""""". This is typically implemented with a jump through a register. Example:; """""""""""""""". .. code-block:: llvm. indirectbr ptr %Addr, [ label %bb1, label %bb2, label %bb3 ]. .. _i_invoke:. '``invoke``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = invoke [cconv] [ret attrs] [addrspace(<num>)] <ty>|<fnty> <fnptrval>(<function args>) [fn attrs]; [operand bundles] to label <normal label> unwind label <exception label>. Overview:; """""""""""""""""". The '``invoke``' instruction causes control to transfer to a specified; function, with the possibility of control flow transfer to either the; '``normal``' label or the '``exception``' label. If the callee function; returns with the ""``ret``"" instruction, control flow will return to the; ""normal"" label. If the callee (or any indirect callees) returns via the; "":ref:`resume <i_resume>`"" instruction or other exception handling; mechanism, control is interrupted and continued at the dynamically; nearest ""exception"" label. The '``exception``' label is a `landing; pad <ExceptionHandling.html#overview>`_ for the exception. As such,; '``exception``' label is required to have the; "":ref:`landingpad <i_landingpad>`"" instruction, which contains the; information about the behavior of the program after unwinding happens,; as its first non-PHI instruction. The restrictions on the; ""``landingpad``"" instruction's tightly couples it to the ""``invoke``""; instruction, so that the important information contained within the; ""``landingpad``"" instruction can't be lost through normal code motion. Arguments:; """""""""""""""""""". This instruction requires several arguments:. #. The optional ""cconv"" marker indicates which :ref:`calling; convention <callingconv>` the call should use. If none is; specified, the call defaults to using C calling conventions.; #. The optional :ref:`Parameter Attributes <paramattrs>` list for ret",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:362071,resume,resume,362071,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability,"llection::iterator()`: same; - `RooAbsCollection::fwdIterator()`: same. - `RooWorkspace::componentIterator()`: use `RooWorkspace::components()` with range-based loop. ### Deprecation of legacy test statistics classes in public interface. Instantiating the following classes and even including their header files is deprecated, and the headers will be removed in ROOT 6.34:. * RooAbsTestStatistic; * RooAbsOptTestStatistic; * RooNLLVar; * RooChi2Var; * RooXYChi2Var. Please use the higher-level functions `RooAbsPdf::createNLL()` and `RooAbsPdf::createChi2()` if you want to create objects that represent test statistics. ### Change of RooParamHistFunc. The `RooParamHistFunc` didn't take any observable `RooRealVar` as constructor; argument. It assumes as observable the internal variables in the passed; RooDataHist. This means it was in most contexts unusable, because the input; can't be changed, other than loading a different bin in the dataset. Furthermore, there was actually a constructor that took a `RooAbsArg x`, but it; was simply ignored. To fix all these problems, the existing constructors were replaced by a new one; that takes the observable explicitly. Since the old constructors resulted in wrong computation graphs that caused; trouble with the new CPU evaluation backend, they had to be removed without; deprecation. Please adapt your code if necessary. ### Renaming of some RooFit classes. The `RooPower` was renamed to `RooPowerSum`, and `RooExpPoly` was renamed to `RooLegacyExpPoly`. This was a necessary change, because the names of these classes introduced in ROOT 6.28 collided with some classes in CMS combine, which were around already long before. Therefore, the classes had to be renamed to not cause any problems for CMS. In the unlikeliy case where you should have used these new classes for analysis already, please adapt your code to the new names and re-create your workspaces. ## RDataFrame. * The `RDataFrame` constructors that take in input one or more file nam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:13560,simpl,simply,13560,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['simpl'],['simply']
Usability,"lling the ``emit`` method of its base; layer. For example, in this tutorial our IRTransformLayer calls through to; our IRCompileLayer to compile the transformed IR, and our IRCompileLayer in; turn calls our ObjectLayer to link the object file produced by our compiler. So far we have learned how to optimize and compile our LLVM IR, but we have; not focused on when compilation happens. Our current REPL optimizes and; compiles each function as soon as it is referenced by any other code,; regardless of whether it is ever called at runtime. In the next chapter we; will introduce a fully lazy compilation, in which functions are not compiled; until they are first called at run-time. At this point the trade-offs get much; more interesting: the lazier we are, the quicker we can start executing the; first function, but the more often we will have to pause to compile newly; encountered functions. If we only code-gen lazily, but optimize eagerly, we; will have a longer startup time (as everything is optimized at that time) but; relatively short pauses as each function just passes through code-gen. If we; both optimize and code-gen lazily we can start executing the first function; more quickly, but we will have longer pauses as each function has to be both; optimized and code-gen'd when it is first executed. Things become even more; interesting if we consider interprocedural optimizations like inlining, which; must be performed eagerly. These are complex trade-offs, and there is no; one-size-fits all solution to them, but by providing composable layers we leave; the decisions to the person implementing the JIT, and make it easy for them to; experiment with different configurations. `Next: Adding Per-function Lazy Compilation <BuildingAJIT3.html>`_. Full Code Listing; =================. Here is the complete code listing for our running example with an; IRTransformLayer added to enable optimization. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:11136,pause,pauses,11136,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['pause'],['pauses']
Usability,"llo; World Pass"". The last two arguments describe its behavior: if a pass walks CFG; without modifying it then the third argument is set to ``true``; if a pass is; an analysis pass, for example dominator tree pass, then ``true`` is supplied as; the fourth argument. As a whole, the ``.cpp`` file looks like:. .. code-block:: c++. #include ""llvm/Pass.h""; #include ""llvm/IR/Function.h""; #include ""llvm/Support/raw_ostream.h"". #include ""llvm/IR/LegacyPassManager.h"". using namespace llvm;. namespace {; struct Hello : public FunctionPass {; static char ID;; Hello() : FunctionPass(ID) {}. bool runOnFunction(Function &F) override {; errs() << ""Hello: "";; errs().write_escaped(F.getName()) << '\n';; return false;; }; }; // end of struct Hello; } // end of anonymous namespace. char Hello::ID = 0;; static RegisterPass<Hello> X(""hello"", ""Hello World Pass"",; false /* Only looks at CFG */,; false /* Analysis Pass */);. Now that it's all together, compile the file with a simple ""``gmake``"" command; from the top level of your build directory and you should get a new file; ""``lib/LLVMHello.so``"". Note that everything in this file is; contained in an anonymous namespace --- this reflects the fact that passes; are self contained units that do not need external interfaces (although they; can have them) to be useful. Running a pass with ``opt``; ---------------------------. Now that you have a brand new shiny shared object file, we can use the; :program:`opt` command to run an LLVM program through your pass. Because you; registered your pass with ``RegisterPass``, you will be able to use the; :program:`opt` tool to access it, once loaded. To test it, follow the example at the end of the :doc:`GettingStarted` to; compile ""Hello World"" to LLVM. We can now run the bitcode file (hello.bc) for; the program through our transformation like this (or course, any bitcode file; will work):. .. code-block:: console. $ opt -load lib/LLVMHello.so -hello < hello.bc > /dev/null; Hello: __main; Hello: puts;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:7296,simpl,simple,7296,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"llowed by glue nodes. A SelectionDAG has designated ""Entry"" and ""Root"" nodes. The Entry node is; always a marker node with an Opcode of ``ISD::EntryToken``. The Root node is; the final side-effecting node in the token chain. For example, in a single basic; block function it would be the return node. One important concept for SelectionDAGs is the notion of a ""legal"" vs.; ""illegal"" DAG. A legal DAG for a target is one that only uses supported; operations and supported types. On a 32-bit PowerPC, for example, a DAG with a; value of type i1, i8, i16, or i64 would be illegal, as would a DAG that uses a; SREM or UREM operation. The `legalize types`_ and `legalize operations`_ phases; are responsible for turning an illegal DAG into a legal DAG. .. _SelectionDAG-Process:. SelectionDAG Instruction Selection Process; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SelectionDAG-based instruction selection consists of the following steps:. #. `Build initial DAG`_ --- This stage performs a simple translation from the; input LLVM code to an illegal SelectionDAG. #. `Optimize SelectionDAG`_ --- This stage performs simple optimizations on the; SelectionDAG to simplify it, and recognize meta instructions (like rotates; and ``div``/``rem`` pairs) for targets that support these meta operations.; This makes the resultant code more efficient and the `select instructions; from DAG`_ phase (below) simpler. #. `Legalize SelectionDAG Types`_ --- This stage transforms SelectionDAG nodes; to eliminate any types that are unsupported on the target. #. `Optimize SelectionDAG`_ --- The SelectionDAG optimizer is run to clean up; redundancies exposed by type legalization. #. `Legalize SelectionDAG Ops`_ --- This stage transforms SelectionDAG nodes to; eliminate any operations that are unsupported on the target. #. `Optimize SelectionDAG`_ --- The SelectionDAG optimizer is run to eliminate; inefficiencies introduced by operation legalization. #. `Select instructions from DAG`_ --- Finally, the target in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:36985,simpl,simple,36985,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"llows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 14 onwards SPIR-V can be generated directly as detailed in; :ref:`the SPIR-V support section <spir-v>`. Clang currently supports OpenCL C language standards up to v2.0. Clang mainly; supports full profile. There is only very limited support of the embedded; profile.; From clang 9 a C++ mode is available for OpenCL (see; :ref:`C++ for OpenCL <cxx_for_opencl>`). OpenCL v3.0 support is complete but it remains in experimental state, see more; details about the experimental features and limitations in :doc:`OpenCLSupport`; page. OpenCL Specific Options; -----------------------. Most of the OpenCL build options from `the specification v2.0 section 5.8.4; <https://www.khronos.org/registry/cl/specs/opencl-2.0.pdf#200>`_ are available. Examples:. .. code-block:: console. $ clang -cl-std=CL2.0 -cl-single-precision-constant test.cl. Many flags used for the compilation for C sources can also be passed while; compiling for OpenCL, examples: ``-c``, `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:141858,Guid,Guide,141858,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['Guid'],['Guide']
Usability,"llvm-cxxfilt - LLVM symbol name demangler; =========================================. .. program:: llvm-cxxfilt. SYNOPSIS; --------. :program:`llvm-cxxfilt` [*options*] [*mangled names...*]. DESCRIPTION; -----------. :program:`llvm-cxxfilt` is a symbol demangler that can be used as a replacement; for the GNU :program:`c++filt` tool. It takes a series of symbol names and; prints their demangled form on the standard output stream. If a name cannot be; demangled, it is simply printed as is. If no names are specified on the command-line, names are read interactively from; the standard input stream. When reading names from standard input, each input; line is split on characters that are not part of valid Itanium name manglings,; i.e. characters that are not alphanumeric, '.', '$', or '_'. Separators between; names are copied to the output as is. EXAMPLE; -------. .. code-block:: console. $ llvm-cxxfilt _Z3foov _Z3bari not_mangled; foo(); bar(int); not_mangled; $ cat input.txt; | _Z3foov *** _Z3bari *** not_mangled |; $ llvm-cxxfilt < input.txt; | foo() *** bar(int) *** not_mangled |. OPTIONS; -------. .. option:: --format=<value>, -s. Mangling scheme to assume. Valid values are ``auto`` (default, auto-detect the; style) and ``gnu`` (assume GNU/Itanium style). .. option:: --help, -h. Print a summary of command line options. .. option:: --no-params, -p. Do not demangle function parameters or return types. .. option:: --no-strip-underscore, -n. Do not strip a leading underscore. This is the default for all platforms; except Mach-O based hosts. .. option:: --strip-underscore, -_. Strip a single leading underscore, if present, from each input name before; demangling. On by default on Mach-O based platforms. .. option:: --types, -t. Attempt to demangle names as type names as well as function names. .. option:: --version. Display the version of the :program:`llvm-cxxfilt` executable. .. option:: @<FILE>. Read command-line options from response file `<FILE>`. EXIT STATUS; -------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cxxfilt.rst:471,simpl,simply,471,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cxxfilt.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cxxfilt.rst,1,['simpl'],['simply']
Usability,"llvm-nm - list LLVM bitcode and object file's symbol table; ==========================================================. .. program:: llvm-nm. SYNOPSIS; --------. :program:`llvm-nm` [*options*] [*filenames...*]. DESCRIPTION; -----------. The :program:`llvm-nm` utility lists the names of symbols from LLVM bitcode; files, object files, and archives. Each symbol is listed along with some simple; information about its provenance. If no filename is specified, *a.out* is used; as the input. If *-* is used as a filename, :program:`llvm-nm` will read a file; from its standard input stream. :program:`llvm-nm`'s default output format is the traditional BSD :program:`nm`; output format. Each such output record consists of an (optional) 8-digit; hexadecimal address, followed by a type code character, followed by a name, for; each symbol. One record is printed per line; fields are separated by spaces.; When the address is omitted, it is replaced by 8 spaces. The supported type code characters are as follows. Where both lower and; upper-case characters are listed for the same meaning, a lower-case character; represents a local symbol, whilst an upper-case character represents a global; (external) symbol:. a, A. Absolute symbol. b, B. Uninitialized data (bss) object. C. Common symbol. Multiple definitions link together into one definition. d, D. Writable data object. i, I. COFF: .idata symbol or symbol in a section with IMAGE_SCN_LNK_INFO set. n. ELF: local symbol from non-alloc section. COFF: debug symbol. N. ELF: debug section symbol, or global symbol from non-alloc section. s, S. COFF: section symbol. Mach-O: absolute symbol or symbol from a section other than __TEXT_EXEC __text,; __TEXT __text, __DATA __data, or __DATA __bss. r, R. Read-only data object. t, T. Code (text) object. u. ELF: GNU unique symbol. U. Named object is undefined in this file. v. ELF: Undefined weak object. It is not a link failure if the object is not; defined. V. ELF: Defined weak object symbol. This defi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst:387,simpl,simple,387,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst,1,['simpl'],['simple']
Usability,"llvm-profgen - LLVM SPGO profile generation tool; ================================================. .. program:: llvm-profgen. SYNOPSIS; --------. :program:`llvm-profgen` [*commands*] [*options*]. DESCRIPTION; -----------. The :program:`llvm-profgen` utility generates a profile data file; from given perf script data files for sample-based profile guided; optimization(SPGO). COMMANDS; --------; At least one of the following commands are required:. .. option:: --perfscript=<string[,string,...]>. Path of perf-script trace created by Linux perf tool with `script`; command(the raw perf.data should be profiled with -b). .. option:: --binary=<string[,string,...]>. Path of the input profiled binary files. .. option:: --output=<string>. Path of the output profile file. OPTIONS; -------; :program:`llvm-profgen` supports the following options:. .. option:: --format=[text|binary|extbinary|compbinary|gcc]. Specify the format of the generated profile. Supported <format> are `text`,; `binary`, `extbinary`, `compbinary`, `gcc`, see `llvm-profdata` for more; descriptions of the format. .. option:: --show-mmap-events. Print mmap events. .. option:: --show-disassembly. Print disassembled code. .. option:: --x86-asm-syntax=[att|intel]. Specify whether to print assembly code in AT&T syntax (the default) or Intel; syntax.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-profgen.rst:349,guid,guided,349,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-profgen.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-profgen.rst,1,['guid'],['guided']
Usability,"llvm; define void @f(void ()* %fp) {; call void %fp() [ ""ptrauth""(i32 <key>, i64 <data>) ]; ret void; }; ```. is functionally equivalent to:. ```llvm; define void @f(void ()* %fp) {; %fp_i = ptrtoint void ()* %fp to i64; %fp_auth = call i64 @llvm.ptrauth.auth(i64 %fp_i, i32 <key>, i64 <data>); %fp_auth_p = inttoptr i64 %fp_auth to void ()*; call void %fp_auth_p(); ret void; }; ```. but with the added guarantee that `%fp_i`, `%fp_auth`, and `%fp_auth_p`; are not stored to (and reloaded from) memory. ## AArch64 Support. AArch64 is currently the only architecture with full support of the pointer; authentication primitives, based on Armv8.3-A instructions. ### Armv8.3-A PAuth Pointer Authentication Code. The Armv8.3-A architecture extension defines the PAuth feature, which provides; support for instructions that manipulate Pointer Authentication Codes (PAC). #### Keys. 5 keys are supported by the PAuth feature. Of those, 4 keys are interchangeably usable to specify the key used in IR; constructs:; * `ASIA`/`ASIB` are instruction keys (encoded as respectively 0 and 1).; * `ASDA`/`ASDB` are data keys (encoded as respectively 2 and 3). `ASGA` is a special key that cannot be explicitly specified, and is only ever; used implicitly, to implement the; [`llvm.ptrauth.sign_generic`](#llvm-ptrauth-sign-generic) intrinsic. #### Instructions. The IR [Intrinsics](#intrinsics) described above map onto these; instructions as such:; * [`llvm.ptrauth.sign`](#llvm-ptrauth-sign): `PAC{I,D}{A,B}{Z,SP,}`; * [`llvm.ptrauth.auth`](#llvm-ptrauth-auth): `AUT{I,D}{A,B}{Z,SP,}`; * [`llvm.ptrauth.strip`](#llvm-ptrauth-strip): `XPAC{I,D}`; * [`llvm.ptrauth.blend`](#llvm-ptrauth-blend): The semantics of the blend; operation are specified by the ABI. In both the ELF PAuth ABI Extension and; arm64e, it's a `MOVK` into the high 16 bits. Consequently, this limits; the width of the integer discriminator used in blends to 16 bits.; * [`llvm.ptrauth.sign_generic`](#llvm-ptrauth-sign-generic): `PACGA`; * [`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md:8131,usab,usable,8131,interpreter/llvm-project/llvm/docs/PointerAuth.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md,1,['usab'],['usable']
Usability,"llvm_stackmaps"". The segment name is ""__LLVM_STACKMAPS"". For ELF (e.g. on Linux), the stack map section name is; "".llvm_stackmaps"". The segment name is ""__LLVM_STACKMAPS"". Stack Map Usage; ===============. The stack map support described in this document can be used to; precisely determine the location of values at a specific position in; the code. LLVM does not maintain any mapping between those values and; any higher-level entity. The runtime must be able to interpret the; stack map record given only the ID, offset, and the order of the; locations, records, and functions, which LLVM preserves. Note that this is quite different from the goal of debug information,; which is a best-effort attempt to track the location of named; variables at every instruction. An important motivation for this design is to allow a runtime to; commandeer a stack frame when execution reaches an instruction address; associated with a stack map. The runtime must be able to rebuild a; stack frame and resume program execution using the information; provided by the stack map. For example, execution may resume in an; interpreter or a recompiled version of the same function. This usage restricts LLVM optimization. Clearly, LLVM must not move; stores across a stack map. However, loads must also be handled; conservatively. If the load may trigger an exception, hoisting it; above a stack map could be invalid. For example, the runtime may; determine that a load is safe to execute without a type check given; the current state of the type system. If the type system changes while; some activation of the load's function exists on the stack, the load; becomes unsafe. The runtime can prevent subsequent execution of that; load by immediately patching any stack map location that lies between; the current call site and the load (typically, the runtime would; simply patch all stack map locations to invalidate the function). If; the compiler had hoisted the load above the stack map, then the; program could cr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:17693,resume,resume,17693,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['resume'],['resume']
Usability,"lly matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<TypeLoc>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<TypeLoc>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Type>booleanType; Matches type bool. Given; struct S { bool func(); };; functionDecl(returns(booleanType())); matches ""bool func();"". Matcher<Type>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; compoundStmt(; forEachDescendant(varDecl().bind(""d"")),; forEachDescendant(declRefExpr(to(decl(equalsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<Type>equalsNodeconst Type* Other; Matches if a node equal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:121111,Usab,Usable,121111,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"load into a compare. The; pattern is written as (cmp reg, (load p)). Because the compare isn't; commutative, it is not matched with the load on both sides. The dag combiner; should be made smart enough to canonicalize the load into the RHS of a compare; when it can invert the result of the compare for free. //===---------------------------------------------------------------------===//. In many cases, LLVM generates code like this:. _test:; movl 8(%esp), %eax; cmpl %eax, 4(%esp); setl %al; movzbl %al, %eax; ret. on some processors (which ones?), it is more efficient to do this:. _test:; movl 8(%esp), %ebx; xor %eax, %eax; cmpl %ebx, 4(%esp); setl %al; ret. Doing this correctly is tricky though, as the xor clobbers the flags. //===---------------------------------------------------------------------===//. We should generate bts/btr/etc instructions on targets where they are cheap or; when codesize is important. e.g., for:. void setbit(int *target, int bit) {; *target |= (1 << bit);; }; void clearbit(int *target, int bit) {; *target &= ~(1 << bit);; }. //===---------------------------------------------------------------------===//. Instead of the following for memset char*, 1, 10:. 	movl $16843009, 4(%edx); 	movl $16843009, (%edx); 	movw $257, 8(%edx). It might be better to generate. 	movl $16843009, %eax; 	movl %eax, 4(%edx); 	movl %eax, (%edx); 	movw al, 8(%edx); 	; when we can spare a register. It reduces code size. //===---------------------------------------------------------------------===//. Evaluate what the best way to codegen sdiv X, (2^C) is. For X/8, we currently; get this:. define i32 @test1(i32 %X) {; %Y = sdiv i32 %X, 8; ret i32 %Y; }. _test1:; movl 4(%esp), %eax; movl %eax, %ecx; sarl $31, %ecx; shrl $29, %ecx; addl %ecx, %eax; sarl $3, %eax; ret. GCC knows several different ways to codegen it, one of which is this:. _test1:; movl 4(%esp), %eax; cmpl $-1, %eax; leal 7(%eax), %ecx; cmovle %ecx, %eax; sarl $3, %eax; ret. which is probably slower, but it's",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:3685,clear,clearbit,3685,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['clear'],['clearbit']
Usability,"loading from null is undefined:. struct S { int w, x, y, z; };; struct T { int r; struct S s; };; void bar (struct S, int);; void foo (int a, struct T b); {; struct S *c = 0;; if (a); c = &b.s;; bar (*c, a);; }. //===---------------------------------------------------------------------===//. simplifylibcalls should do several optimizations for strspn/strcspn:. strcspn(x, ""a"") -> inlined loop for up to 3 letters (similarly for strspn):. size_t __strcspn_c3 (__const char *__s, int __reject1, int __reject2,; int __reject3) {; register size_t __result = 0;; while (__s[__result] != '\0' && __s[__result] != __reject1 &&; __s[__result] != __reject2 && __s[__result] != __reject3); ++__result;; return __result;; }. This should turn into a switch on the character. See PR3253 for some notes on; codegen. 456.hmmer apparently uses strcspn and strspn a lot. 471.omnetpp uses strspn. //===---------------------------------------------------------------------===//. simplifylibcalls should turn these snprintf idioms into memcpy (GCC PR47917). char buf1[6], buf2[6], buf3[4], buf4[4];; int i;. int foo (void) {; int ret = snprintf (buf1, sizeof buf1, ""abcde"");; ret += snprintf (buf2, sizeof buf2, ""abcdef"") * 16;; ret += snprintf (buf3, sizeof buf3, ""%s"", i++ < 6 ? ""abc"" : ""def"") * 256;; ret += snprintf (buf4, sizeof buf4, ""%s"", i++ > 10 ? ""abcde"" : ""defgh"")*4096;; return ret;; }. //===---------------------------------------------------------------------===//. ""gas"" uses this idiom:; else if (strchr (""+-/*%|&^:[]()~"", *intel_parser.op_string)); ..; else if (strchr (""<>"", *intel_parser.op_string). Those should be turned into a switch. SimplifyLibCalls only gets the second; case. //===---------------------------------------------------------------------===//. 252.eon contains this interesting code:. %3072 = getelementptr [100 x i8]* %tempString, i32 0, i32 0; %3073 = call i8* @strcpy(i8* %3072, i8* %3071) nounwind; %strlen = call i32 @strlen(i8* %3072) ; uses = 1; %endptr = getelementptr [1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:37448,simpl,simplifylibcalls,37448,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplifylibcalls']
Usability,"lobal i32 0. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.01 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.01; }. The mem2reg pass implements the standard ""iterated dominance frontier""; algorithm for constructing SSA form and has a number of optimizations; that speed up (very common) degenerate cases. The mem2reg optimization; pass is the answer to dealing with mutable variables, and we highly; recommend that you depend on it. Note that mem2reg only works on; variables in certain circumstances:. #. mem2reg is alloca-driven: it looks for allocas and if it can handle; them, it promotes them. It does not apply to global variables or heap; allocations.; #. mem2reg only looks for alloca instructions in the entry block of the; function. Being in the entry block guarantees that the alloca is only; executed once, which makes analysis simpler.; #. mem2reg only promotes allocas whose uses are direct loads and stores.; If the address of the stack object is passed to a function, or if any; funny pointer arithmetic is involved, the alloca will not be; promoted.; #. mem2reg only works on allocas of `first; class <../../LangRef.html#first-class-types>`_ values (such as pointers,; scalars and vectors), and only if the array size of the allocation is; 1 (or missing in the .ll file). mem2reg is not capable of promoting; structs or arrays to registers. Note that the ""sroa"" pass is; more powerful and can promote structs, ""unions"", and arrays in many; cases. All of these properties are easy to satisfy for most imperative; languages, and we'll illustrate it below with Kaleidoscope. The final; question you may be asking is: should I bother with this nonsense for my; front-end? Wouldn't it be better if I just did SSA construction; directly, avoiding use of the mem2reg optimization pass?",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:8091,simpl,simpler,8091,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simpler']
Usability,"loc(i32 %size); br label %coro.begin; coro.begin:; %phi = phi ptr [ null, %entry ], [ %alloc, %dyn.alloc ]; %hdl = call noalias ptr @llvm.coro.begin(token %id, ptr %phi); br label %loop; loop:; %n.val = phi i32 [ %n, %coro.begin ], [ %inc, %loop ]; %inc = add nsw i32 %n.val, 1; store i32 %n.val, ptr %promise; %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %loop; i8 1, label %cleanup]; cleanup:; %mem = call ptr @llvm.coro.free(token %id, ptr %hdl); call void @free(ptr %mem); br label %suspend; suspend:; %unused = call i1 @llvm.coro.end(ptr %hdl, i1 false, token none); ret ptr %hdl; }. A coroutine consumer can rely on the `coro.promise`_ intrinsic to access the; coroutine promise. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); %promise.addr = call ptr @llvm.coro.promise(ptr %hdl, i32 4, i1 false); %val0 = load i32, ptr %promise.addr; call void @print(i32 %val0); call void @llvm.coro.resume(ptr %hdl); %val1 = load i32, ptr %promise.addr; call void @print(i32 %val1); call void @llvm.coro.resume(ptr %hdl); %val2 = load i32, ptr %promise.addr; call void @print(i32 %val2); call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. After example in this section is compiled, result of the compilation will be:. .. code-block:: llvm. define i32 @main() {; entry:; tail call void @print(i32 4); tail call void @print(i32 5); tail call void @print(i32 6); ret i32 0; }. .. _final:; .. _final suspend:. Final Suspend; -------------. A coroutine author or a frontend may designate a particular suspend to be final,; by setting the second argument of the `coro.suspend`_ intrinsic to `true`.; Such a suspend point has two properties:. * it is possible to check whether a suspended coroutine is at the final suspend; point via `coro.done`_ intrinsic;. * a resumption of a coroutine stopped at the final suspend point leads to; undefined behavior. The only possible action for a coroutine at a final; suspend point is dest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:23969,resume,resume,23969,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"local; jump tables, this is easily arranged by testing the input to the jump table; within each destination (not yet implemented, use retpolines):; ```; pushq %rax; xorl %eax, %eax # Zero out initial predicate state.; movq $-1, %r8 # Put all-ones mask into a register.; jmpq *.LJTI0_0(,%rdi,8) # Indirect jump through table.; .LBB0_2: # %sw.bb; testq $0, %rdi # Validate index used for jump table.; cmovneq %r8, %rax # Conditionally update predicate state.; ...; jmp _Z4leaki # TAILCALL. .LBB0_3: # %sw.bb1; testq $1, %rdi # Validate index used for jump table.; cmovneq %r8, %rax # Conditionally update predicate state.; ...; jmp _Z4leaki # TAILCALL. .LBB0_5: # %sw.bb10; testq $2, %rdi # Validate index used for jump table.; cmovneq %r8, %rax # Conditionally update predicate state.; ...; jmp _Z4leaki # TAILCALL; ... .section .rodata,""a"",@progbits; .p2align 3; .LJTI0_0:; .quad .LBB0_2; .quad .LBB0_3; .quad .LBB0_5; ...; ```. Returns have a simple mitigation technique on x86-64 (or other ABIs which have; what is called a ""red zone"" region beyond the end of the stack). This region is; guaranteed to be preserved across interrupts and context switches, making the; return address used in returning to the current code remain on the stack and; valid to read. We can emit code in the caller to verify that a return edge was; not mispredicted:; ```; callq other_function; return_addr:; testq -8(%rsp), return_addr # Validate return address.; cmovneq %r8, %rax # Update predicate state.; ```. For an ABI without a ""red zone"" (and thus unable to read the return address; from the stack), we can compute the expected return address prior to the call; into a register preserved across the call and use that similarly to the above. Indirect calls (and returns in the absence of a red zone ABI) pose the most; significant challenge to propagate. The simplest technique would be to define a; new ABI such that the intended call target is passed into the called function; and checked in the entry. Unfortunat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:19107,simpl,simple,19107,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simple']
Usability,"lock:: c. for (int i = 0; i < n; i+=1) // original loop; A[i] = B[0];. into:. .. code-block:: c. if (rtc) {; auto b = B[0];; for (int i = 0; i < n; i+=1) // versioned loop; A[i] = b;; } else {; for (int i = 0; i < n; i+=1) // unversioned loop; A[i] = B[0];; }. The runtime condition (``rtc``) checks that the array ``A`` and the; element `B[0]` do not alias. Currently, this transformation does not support followup-attributes. Loop Interchange; ----------------. Currently, the ``LoopInterchange`` pass does not use any metadata. Ambiguous Transformation Order; ==============================. If there multiple transformations defined, the order in which they are; executed depends on the order in LLVM's pass pipeline, which is subject; to change. The default optimization pipeline (anything higher than; ``-O0``) has the following order. When using the legacy pass manager:. - LoopInterchange (if enabled); - SimpleLoopUnroll/LoopFullUnroll (only performs full unrolling); - VersioningLICM (if enabled); - LoopDistribute; - LoopVectorizer; - LoopUnrollAndJam (if enabled); - LoopUnroll (partial and runtime unrolling). When using the legacy pass manager with LTO:. - LoopInterchange (if enabled); - SimpleLoopUnroll/LoopFullUnroll (only performs full unrolling); - LoopVectorizer; - LoopUnroll (partial and runtime unrolling). When using the new pass manager:. - SimpleLoopUnroll/LoopFullUnroll (only performs full unrolling); - LoopDistribute; - LoopVectorizer; - LoopUnrollAndJam (if enabled); - LoopUnroll (partial and runtime unrolling). Leftover Transformations; ========================. Forced transformations that have not been applied after the last; transformation pass should be reported to the user. The transformation; passes themselves cannot be responsible for this reporting because they; might not be in the pipeline, there might be multiple passes able to; apply a transformation (e.g. ``LoopInterchange`` and Polly) or a; transformation attribute may be 'hidden' inside another",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:13834,Simpl,SimpleLoopUnroll,13834,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['Simpl'],['SimpleLoopUnroll']
Usability,"logo.png ""OpenSSL Logo"")](https://www.openssl.org/). [![Mbed TLS](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/mbedTLS_logo.png ""mbedTLS Logo"")](https://github.com/ARMmbed/mbedtls). Support; -------. This project is very easy to install and use.; Please read the [documentation](https://github.com/civetweb/civetweb/blob/master/docs/); and have a look at the [examples](https://github.com/civetweb/civetweb/blob/master/examples/). Recent questions and discussions usually use [GitHub issues](https://github.com/civetweb/civetweb/issues).; Some old information may be found on the [mailing list](https://groups.google.com/d/forum/civetweb), ; but this information may be outdated. Feel free to create a GitHub issue for bugs, feature requests, questions, suggestions or if you want to share tips and tricks.; When creating an issues for a bug, add enough description to reproduce the issue - at least add CivetWeb version and operating system.; Please see also the guidelines for [Contributions](https://github.com/civetweb/civetweb/blob/master/docs/Contribution.md) and the [Security Policy](https://github.com/civetweb/civetweb/blob/master/SECURITY.md). Note: We do not take any liability or warranty for any linked contents. Visit these pages and try the community support suggestions at your own risk.; Any link provided in this project (including source and documentation) is provided in the hope that this information will be helpful.; However, we cannot accept any responsibility for any content on an external page. Contributions; -------------. Contributions are welcome provided all contributions carry the MIT license. DO NOT APPLY fixes copied from Mongoose to this project to prevent GPL tainting.; Since 2013, CivetWeb and Mongoose are developed independently.; By now the code base differs, so patches cannot be safely transferred in either direction. Some guidelines can be found in [docs/Contribution.md](https://github.com/civetweb/civetweb/blob/master/docs/C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:8866,guid,guidelines,8866,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['guid'],['guidelines']
Usability,"ls (256). Color in every level is calculated by adding the; increments of the `r` , `g` , `b` components to the previous level.; Using this function one can change the color increments between two; neighboring color levels. The function does not apply on the Simple; Display Modes Group. The default values are: (1,1,1). The operator ""`ca(color_algorithm)`"" allows to choose the Color; Algorithm. To define the colors one can use one of the following color; algorithms (RGB, CMY, CIE, YIQ, HVS models). When the level of a; component reaches the limit value one can choose either smooth; transition (by decreasing the limit value) or a sharp modulo; transition (continuing with 0 value). This allows various visual; effects. One can choose from the following set of the algorithms:. - 0 = RGB Smooth,; - 1 = RGB Modulo,; - 2 = CMY Smooth,; - 3 = CMY Modulo,; - 4 = CIE Smooth; - 5 = CIE Modulo,; - 6 = YIQ Smooth,; - 7 = YIQ Modulo,; - 8 = HVS Smooth,; - 9 = HVS Modulo. This function does not apply on Simple display modes group. Default; value is 0. Example choosing CMY Modulo to paint the 2D histogram:. ``` {.cpp}; h2->Draw(""SPEC c1(3) dm(0,1) a(30,30,0)"");; ```. The operator ""`lp(x,y,z)`"" sets the light position. In Light and; LightHeight display modes groups the color palette is calculated; according to the fictive light source position in 3-d space. Using; this function one can change the source's position and thus achieve; various graphical effects. This function does not apply for Simple and; Height display modes groups. Default is: `lp(1000,1000,100)` . The operator ""`s(shading,shadow)`"" allows to set the shading. The; surface picture is composed of triangles. The edges of the neighboring; triangles can be smoothed (shaded). The shadow can be painted as well.; The function does not apply on Simple display modes group. The; possible values for shading are:. - 0 = Not Shaded,; - 1 = Shaded. The possible values for shadow are:. - 0 = Shadows are not painted,; - 1 = Shadows ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:39216,Simpl,Simple,39216,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['Simpl'],['Simple']
Usability,"ls all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's; lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. Calling ``llvm.lifetime.end`` on an already dead alloca is no-op. If ``ptr`` is a non-stack-allocated object or it does not point to the first; byte of the object, it is equivalent to simply filling all bytes of the object; with ``poison``. '``llvm.invariant.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare ptr @llvm.invariant.start.p0(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.start``' intrinsic specifies that the contents of; a memory object will not change. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". This intrinsic indicates that until an ``llvm.invariant.end`` that uses; the return value, the referenced memory location is constant and; unchanging. '``llvm.invariant.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:863538,simpl,simply,863538,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"ls.; * Core idea of masking out loaded bits was part of the original mitigation; suggested by Jann Horn when these attacks were reported. ### Indirect Branches, Calls, and Returns. It is possible to attack control flow other than conditional branches with; variant #1 style mispredictions.; * A prediction towards a hot call target of a virtual method can lead to it; being speculatively executed when an expected type is used (often called; ""type confusion"").; * A hot case may be speculatively executed due to prediction instead of the; correct case for a switch statement implemented as a jump table.; * A hot common return address may be predicted incorrectly when returning from; a function. These code patterns are also vulnerable to Spectre variant #2, and as such are; best mitigated with a; [retpoline](https://support.google.com/faqs/answer/7625886) on x86 platforms.; When a mitigation technique like retpoline is used, speculation simply cannot; proceed through an indirect control flow edge (or it cannot be mispredicted in; the case of a filled RSB) and so it is also protected from variant #1 style; attacks. However, some architectures, micro-architectures, or vendors do not; employ the retpoline mitigation, and on future x86 hardware (both Intel and; AMD) it is expected to become unnecessary due to hardware-based mitigation. When not using a retpoline, these edges will need independent protection from; variant #1 style attacks. The analogous approach to that used for conditional; control flow should work:; ```; uintptr_t all_ones_mask = std::numerical_limits<uintptr_t>::max();; uintptr_t all_zeros_mask = 0;; void leak(int data);; void example(int* pointer1, int* pointer2) {; uintptr_t predicate_state = all_ones_mask;; switch (condition) {; case 0:; // Assuming ?: is implemented using branchless logic...; predicate_state = (condition != 0) ? all_zeros_mask : predicate_state;; // ... lots of code ...; //; // Harden the pointer so it can't be loaded; pointer1 &= predica",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:9151,simpl,simply,9151,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simply']
Usability,"ls; might reference the same underlying values.; . To summarize, MemRegions are unique names for blocks of memory. Symbols are; unique names for abstract symbolic values. Some MemRegions represents abstract; symbolic chunks of memory, and thus are also based on symbols. SVals are just; references to values, and can reference either MemRegions, Symbols, or concrete; values (e.g., the number 1). Idea for a Checker; Here are several questions which you should consider when evaluating your; checker idea:; ; Can the check be effectively implemented without path-sensitive; analysis? See AST Visitors.; How high the false positive rate is going to be? Looking at the occurrences; of the issue you want to write a checker for in the existing code bases might; give you some ideas. ; How the current limitations of the analysis will effect the false alarm; rate? Currently, the analyzer only reasons about one procedure at a time (no; inter-procedural analysis). Also, it uses a simple range tracking based; solver to model symbolic execution.; Consult the GitHub Issues; to get some ideas for new checkers and consider starting with improving/fixing; bugs in the existing checkers. Once an idea for a checker has been chosen, there are two key decisions that; need to be made:; ; Which events the checker should be tracking. This is discussed in more; detail in the section Events, Callbacks, and; Checker Class Structure.; What checker-specific data needs to be stored as part of the program; state (if any). This should be minimized as much as possible. More detail about; implementing custom program state is given in section Custom Program States.; ; Checker Registration; All checker implementation files are located in; clang/lib/StaticAnalyzer/Checkers folder. The steps below describe; how the checker SimpleStreamChecker, which checks for misuses of; stream APIs, was registered with the analyzer.; Similar steps should be followed for a new checker. A new checker implementation file, SimpleS",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:7886,simpl,simple,7886,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['simpl'],['simple']
Usability,"luded in TeX and LaTeX documents. `PGF` is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friedly syntax layer called `TikZ`. To generate a such file it is enough to do:. ```; gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");; ```. Then, the generated file (<tt>hpx.tex</tt>) can be included in a; LaTeX document (`simple.tex`) in the following way:. ```; \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}; ```. Note the two directive needed at the top of the LaTeX file:. ```; \usepackage{tikz}; \usetikzlibrary{patterns}; ```. Then including the picture in the document is done with the; `\input` directive. The command `pdflatex simple.tex` will generate the corresponding pdf; file `simple.pdf`. ### X11 fonts. - A coverity fix in `Rotated.cxx` had a side effect on rotated text; drawn with X11 fonts. ### TCanvas and TPad. - `TPad::SaveAs` produces named macros in .C files.; - Change the way the string input is done in the Pad toolbar for text; and Pave Label. It doesn't use anymore the `TGX11` function `RequestString`.; Now the text appears directly as it will show and it is possible to; enter several text string. The input is not block in the `RequestString` event loop.; - The toolbar methods now work without XOR mode (useful for OpenGL()).; - A new ""vertex compression"" algorithm added to deal with complex histograms; (thousands/millions of bins - polygons with thousands/millions of vertices) -; optimization/fix for X11 crashes. ### TGaxis and TAxis. - The time axis behavior should now be correct along time zone and; summer saving time. A fix has been done with the of Philippe Gras; (CEA Saclay. IRFU/S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md:1730,simpl,simple,1730,graf2d/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md,1,['simpl'],['simple']
Usability,"lueType`` register type values that are; defined in ``include/llvm/CodeGen/ValueTypes.td``. Defined values include; integer types (such as ``i16``, ``i32``, and ``i1`` for Boolean),; floating-point types (``f32``, ``f64``), and vector types (for example,; ``v8i16`` for an ``8 x i16`` vector). All registers in a ``RegisterClass``; must have the same ``ValueType``, but some registers may store vector data in; different configurations. For example a register that can process a 128-bit; vector may be able to handle 16 8-bit integer elements, 8 16-bit integers, 4; 32-bit integers, and so on. * The third argument of the ``RegisterClass`` definition specifies the; alignment required of the registers when they are stored or loaded to; memory. * The final argument, ``regList``, specifies which registers are in this class.; If an alternative allocation order method is not specified, then ``regList``; also defines the order of allocation used by the register allocator. Besides; simply listing registers with ``(add R0, R1, ...)``, more advanced set; operators are available. See ``include/llvm/Target/Target.td`` for more; information. In ``SparcRegisterInfo.td``, three ``RegisterClass`` objects are defined:; ``FPRegs``, ``DFPRegs``, and ``IntRegs``. For all three register classes, the; first argument defines the namespace with the string ""``SP``"". ``FPRegs``; defines a group of 32 single-precision floating-point registers (``F0`` to; ``F31``); ``DFPRegs`` defines a group of 16 double-precision registers; (``D0-D15``). .. code-block:: text. // F0, F1, F2, ..., F31; def FPRegs : RegisterClass<""SP"", [f32], 32, (sequence ""F%u"", 0, 31)>;. def DFPRegs : RegisterClass<""SP"", [f64], 64,; (add D0, D1, D2, D3, D4, D5, D6, D7, D8,; D9, D10, D11, D12, D13, D14, D15)>;. def IntRegs : RegisterClass<""SP"", [i32], 32,; (add L0, L1, L2, L3, L4, L5, L6, L7,; I0, I1, I2, I3, I4, I5,; O0, O1, O2, O3, O4, O5, O7,; G1,; // Non-allocatable regs:; G2, G3, G4,; O6, // stack ptr; I6, // frame ptr; I7, // r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:22599,simpl,simply,22599,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['simpl'],['simply']
Usability,"ly 3 sessions. Additional requests are queued; and run as soon as one of the running; sessions goes idle. The current policy is FIFO, so that there is a; rotation among queued; sessions. In the case of load-based worker assignment, the max number; of running; queries is determined dynamically.; Add support for repeat functionality in the xrd.worker; directive. To avoid repeating the same line N times; one can just add; 'repeat=N'; in the line; for; example;            ;     xpd.worker worker; proofwrks:2093 repeat=4; will define 4 workers on port 2093 of machine 'proofwrks'.; Add support for port specification via the directive; 'xpd.port'; Enable variable; substitution in 'xpd.' directives using the standard; Scalla mechanism described in; http://xrootd.slac.stanford.edu/doc/dev/Syntax_config.htm .; Build also a binary named 'xproofd' which runs; a xrootd; daemon with only the XrdProofdProtocol (i.e. no data serving).; This simplifies setups when data serving is not needed and also allows; to better disantagle problems related to one specific protocol. The new; binary accepts the same arguments as 'xrootd' and parses the same; directives form the same configuration file, with the exception of; 'xpd.protocol xproofd libXrdProofd.so' which should now be dropped. AN; alternative port can be specified via the new 'xpd.port' directive (see; above).; Add support for 'MasterOnly' mode in starting a PROOF; session. This avoids starting the workers when one wants just to browse; the datasets or retrieve results. To start a session in 'MasterOnly'; mode enter ""masteronly""; as second argument to TProof::Open, e.g.;  ;          root[]; TProof *p = TProof::Open(""<masterurl>"", ""masteronly""); Add full support for placeholders; <uid>,; <gid>, <group> and <homedir>; for the directives specified via 'xpd.putenv'; Add the configuration directive 'proofservparents' to; allow specifying a different list of parent names for the 'proofserv'; tasks. This is needed to avoid untimely killing",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:1591,simpl,simplifies,1591,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['simpl'],['simplifies']
Usability,"ly acceptable course of action.; * Negatively affect development of core tier code, with the sub-community; involved responsible for making changes to address specific concerns.; * Negatively affect other peripheral tier code, with the sub-communities; involved tasked to resolve the issues, still making sure the solution doesn't; break or invalidate the core tier.; * Impose sub-optimal implementation strategies on core tier components as a; result of idiosyncrasies in the peripheral component.; * Have build infrastructure that spams all developers about their breakages.; * Fall into disrepair. This is a reflection of lack of an active sub-community; and will result in removal. Code in this tier should:; * Have infrastructure to test, whenever meaningful, with either no warnings or; notification contained within the sub-community.; * Have support and testing that scales with the complexity and resilience of; the component, with the bar for simple and gracefully-degrading components; (such as editor bindings) much lower than for complex components that must; remain fresh with HEAD (such as experimental back-ends or alternative build; systems).; * Have a document making clear the status of implementation, level of support; available, who the sub-community is and, if applicable, roadmap for inclusion; into the core tier.; * Be restricted to a specific directory or have a consistent pattern (ex.; unique file suffix), making it easy to remove when necessary. Inclusion Policy; ================. To add a new peripheral component, send an RFC to the appropriate dev list; proposing its addition and explaining how it will meet the support requirements; listed above. Different types of components could require different levels of; detail. when in doubt, ask the community what's the best approach. Inclusion must reach consensus in the RFC by the community and the approval of; the corresponding review (by multiple members of the community) is the official; note of acceptance. Aft",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:6144,simpl,simple,6144,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['simpl'],['simple']
Usability,"ly allows it via; the ``lib/Support`` interface. Use Standard C Headers; ----------------------. The **standard** C headers (the ones beginning with ""c"") are allowed to be; exposed through the ``lib/Support`` interface. These headers and the things they; declare are considered to be platform agnostic. LLVM source files may include; them directly or obtain their inclusion through ``lib/Support`` interfaces. Use Standard C++ Headers; ------------------------. The **standard** C++ headers from the standard C++ library and standard; template library may be exposed through the ``lib/Support`` interface. These; headers and the things they declare are considered to be platform agnostic.; LLVM source files may include them or obtain their inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. For example, consider what is needed to execute a program, wait for it to; complete, and return its result code. On Unix, this involves the following; operating system calls: ``getenv``, ``fork``, ``execve``, and ``wait``. The; correct thing for ``lib/Support`` to provide is a function, say; ``ExecuteProgramAndWait``, that implements the functionality completely. what; we don't want is wrappers for the operating system calls involved. There must **not** be a one-to-one relationship between operating system; calls and the Support library's interface. Any such interface function will be; suspicious. No Unused Functionality; -----------------------. There must be no functionality specified in the interface of ``lib/Support``; that isn't actually used by LLVM. We're not writing a general purpose operating; system wrapper here, just enou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:4099,simpl,simply,4099,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['simpl'],['simply']
Usability,"ly if; needed) email conduct@llvm.org. Code of Conduct Committee; =========================. The committee will consist of a minimum of 5 members and members are asked to; serve at least a 1 year term. New committee members will be selected by the; current committee and the LLVM Foundation Board of Directors. When responding to a Code of Conduct report, the committee follows the; following ; :doc:`Response Guide<ResponseGuide>`. The current committee members are:. * Kit Barton (kbarton\@llvm.org); * Kristof Beyls (kristof.beyls\@llvm.org); * Stella Stamenova (sstamenova\@llvm.org); * David Blaikie (dblaikie\@llvm.org); * Mike Edwards (medwards\@llvm.org); * Cyndy Ishida (cishida\@llvm.org); * Tanya Lattner (tanyalattner\@llvm.org). Transparency Reports; ====================. * `July 15, 2023 <https://llvm.org/coc-reports/2023-07-15-report.html>`_; * `July 15, 2022 <https://llvm.org/coc-reports/2022-07-15-report.html>`_; * `April 28, 2022 <https://llvm.org/coc-reports/2022-04-28-report.html>`_. For details about what a Transparency Report is and what it contains, please see the :doc:`Response Guide<ResponseGuide>`. Questions?; ==========. If you have questions, please feel free to contact the LLVM Foundation Code of; Conduct Committee by emailing conduct@llvm.org. Thanks!; =======. This text is based on the `Django Project`_ Code of Conduct, which is in turn; based on wording from the `Speak Up! project`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Speak Up! project: http://speakup.io/coc.html; .. _sexual and gender-based violence:; .. _hate crimes: https://hatecrime.osce.org; .. _hate speech: https://www.un.org/en/genocideprevention/documents/UN%20Strategy%20and%20Plan%20of%20Action%20on%20Hate%20Speech%2018%20June%20SYNOPSIS.pdf; .. _Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/licenses/by/3.0/; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:7725,Guid,Guide,7725,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['Guid'],['Guide']
Usability,"ly styled function createIntegral running integrals and c.d.f. can be created; over any number of observables, e.g createCdf(RooArgSet(x,y,z)) will create a three-dimensional; cumulative distribution function. C.d.f and running integrals that are calculated from p.d.fs that have; support for analytical integration are constructed from an appropriately reconnected RooRealIntegral.; If numeric integration is required, the c.d.f or running integral is calculated by a dedicated class; RooRunningIntegral that precalculates results for all observable values, which is more efficient; in most use cases. Cumulative distributions functions that are calculated numerically are handled slightly differently; that standard running integrals: their values is constructed to converge to exactly zero at the lower bound; and exactly 1 at the upper bound so that algorithms that make use of that property of c.d.f can do so reliably. Constraints management. New tools have been added to simplify studies with fits involving (external) constraints on parameters.; The general philosophy is that constraints on parameters can be represented as probability density functions; and can thus be modeled by RooAbsPdf classes (e.g. a RooGaussian for a simple Gaussian constraint on a parameter).; There are two modes of operation: you can add parameter constraints to your problem definition by multiplying; the constraint p.d.f.s with your 'master' p.d.f. or you specify them externally in each operation. The; first mode of operation keeps all information in your master p.d.f and may make the logistics of non-trivial; fitting problems easier. It works as follows: first you define your regular p.d.f, then you define your; constraint p.d.f and you multiply them with RooProdPdf. // Construct constraint; RooGaussian fconstraint(""fconstraint"",""fconstraint"",f,RooConst(0.8),RooConst(0.1)) ;. // Multiply constraint with p.d.f; RooProdPdf pdfc(""pdfc"",""p.d.f with constraint"",RooArgSet(p.d.f,fconstraint)) ;. If your ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:6632,simpl,simplify,6632,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['simpl'],['simplify']
Usability,"ly these entries / subentries are used to fill histograms. About the class . The class derives from TEntryList and can be used basically in the same way. This same class is used to keep entries and subentries, so there are two types of TEntryListArray's:. The ones that only hold subentries; fEntry is set to the entry# for which the subentries correspond; fSubLists must be 0; The ones that hold entries and eventually lists with subentries in fSubLists.; fEntry = -1 for those; If there are no sublists for a given entry, all the subentries will be used in the selection. Additions with respect to TEntryList ; Data members:; fSubLists: a container to hold the sublists; fEntry: the entry number if the list is used to hold subentries; fLastSubListQueried and fSubListIter: a pointer to the last sublist queried and an iterator to resume the loop from the last sublist queried (to speed up selection and insertion in TTree::Draw); Public methods:; Contains, Enter and Remove with subentry as argument; GetSubListForEntry: to return the sublist corresponding to the given entry; Protected methods:; AddEntriesAndSubLists: called by Add when adding two TEntryList arrays with sublists; ConvertToTEntryListArray: convert TEntryList to TEntryListArray; RemoveSubList: to remove the given sublist; RemoveSubListForEntry: to remove the sublist corresponding to the given entry; SetEntry: to get / set a sublist for the given entry. Others changes. Reduced the memory used by a TTree in half by refactoring the code reading and writing the TBasket data;; A single transient buffer holding the compressed data is now managed by TTree (and could be made thread local); rather than having one per TBranch. Updated TBranchElement::Unroll to no longer split a base class; that can not be split (i.e. respect the information returned; by TStreamerElement::CannotSplit (and thus TClass::CanSplit). This disabling is currently _not_ done automatically for backward compatibility reasons and because; ; Without TCl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v532/index.html:1684,resume,resume,1684,tree/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v532/index.html,1,['resume'],['resume']
Usability,"m is ill-formed, because the result of reading an element; is always an Objective-C object pointer and no binary operators are; legal on such pointers. If the expression appears in any other position,; the element is read as described below. It is an error to take the; address of a subscript expression, or (in C++) to bind a reference to; it. Programs can use object subscripting with Objective-C object pointers of; type ``id``. Normal dynamic message send rules apply; the compiler must; see *some* declaration of the subscripting methods, and will pick the; declaration seen first. Caveats; =======. Objects created using the literal or boxed expression syntax are not; guaranteed to be uniqued by the runtime, but nor are they guaranteed to; be newly-allocated. As such, the result of performing direct comparisons; against the location of an object literal (using ``==``, ``!=``, ``<``,; ``<=``, ``>``, or ``>=``) is not well-defined. This is usually a simple; mistake in code that intended to call the ``isEqual:`` method (or the; ``compare:`` method). This caveat applies to compile-time string literals as well.; Historically, string literals (using the ``@""...""`` syntax) have been; uniqued across translation units during linking. This is an; implementation detail of the compiler and should not be relied upon. If; you are using such code, please use global string constants instead; (``NSString * const MyConst = @""...""``) or use ``isEqual:``. Grammar Additions; =================. To support the new syntax described above, the Objective-C; ``@``-expression grammar has the following new productions:. ::. objc-at-expression : '@' (string-literal | encode-literal | selector-literal | protocol-literal | object-literal); ;. object-literal : ('+' | '-')? numeric-constant; | character-constant; | boolean-constant; | array-literal; | dictionary-literal; ;. boolean-constant : '__objc_yes' | '__objc_no' | 'true' | 'false' /* boolean keywords. */; ;. array-literal : '[' assignment-expres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:17435,simpl,simple,17435,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['simpl'],['simple']
Usability,"m/ADT/Twine.h; ^^^^^^^^^^^^^^^^. The Twine class is used as an intermediary datatype for APIs that want to take a; string that can be constructed inline with a series of concatenations. Twine; works by forming recursive instances of the Twine datatype (a simple value; object) on the stack as temporary objects, linking them together into a tree; which is then linearized when the Twine is consumed. Twine is only safe to use; as the argument to a function, and should always be a const reference, e.g.:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; foo(X + ""."" + Twine(i));. This example forms a string like ""blarg.42"" by concatenating the values; together, and does not form intermediate strings containing ""blarg"" or ""blarg."". Because Twine is constructed with temporary objects on the stack, and because; these instances are destroyed at the end of the current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient than intermediate std::string temporaries, and they work; really well with StringRef. Just be aware of their limitations. .. _dss_smallstring:. llvm/ADT/SmallString.h; ^^^^^^^^^^^^^^^^^^^^^^. SmallString is a subclass of :ref:`SmallVector <dss_smallvector>` that adds some; convenience APIs like += that takes StringRef's. SmallString avoids allocating; memory in the case when the preallocated space is enough to hold its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:74526,simpl,simple,74526,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"m/civetweb/civetweb/blob/master/docs/Building.md) - Building the Server (quick start guide); - [docs/Embedding.md](https://github.com/civetweb/civetweb/blob/master/docs/Embedding.md) - Embedding (how to add HTTP support to an existing application); - [docs/OpenSSL.md](https://github.com/civetweb/civetweb/blob/master/docs/OpenSSL.md) - Adding HTTPS (SSL/TLS) support using OpenSSL.; - [API documentation](https://github.com/civetweb/civetweb/tree/master/docs/api) - Additional documentation on the civetweb application programming interface ([civetweb.h](https://github.com/civetweb/civetweb/blob/master/include/civetweb.h)).; - [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md) - Release Notes; - [SECURITY.md](https://github.com/civetweb/civetweb/blob/master/SECURITY.md) - Security Policy; - [LICENSE.md](https://github.com/civetweb/civetweb/blob/master/LICENSE.md) - Copyright License. Overview; --------. CivetWeb keeps the balance between functionality and; simplicity by a carefully selected list of features:. - Liberal, commercial-friendly, permissive,; [MIT license](http://en.wikipedia.org/wiki/MIT_License); - Free from copy-left licenses, like GPL, because you should innovate without; restrictions.; - Forked from [Mongoose](https://code.google.com/p/mongoose/) in 2013, before; it changed the licence from MIT to commercial + GPL. A lot of enhancements; have been added since that time, see; [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md).; - Works on Windows, Mac, Linux, UNIX, iPhone, Android, Buildroot, and many; other platforms.; - Scripting and database support (CGI, SQLite database, Lua Server Pages,; Server side Lua scripts, Server side JavaScript).; This provides a ready to go, powerful web development platform in a one; single-click executable with **no dependencies**.0; - Support for CGI, SSI, HTTP digest (MD5) authorization, WebSocket,; WebDAV.; - HTTPS (SSL/TLS) support using [OpenSSL](htt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:5222,simpl,simplicity,5222,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['simpl'],['simplicity']
Usability,"main source file. For example, if you misuse a C++ function declared in a header the primary diagnostic will be in the caller (in the main source file). The full expanded path, however, will show the bug in the header code as well. These kind of cross-file issues are currently only support by Xcode, not the HTML output.; This build is built with LLVM's Link-Time Optimization (LTO), which should make it slightly faster.; LTO also reduces the download size (about 19% smaller than checker-274).; Many sundry fixes. checker-274; built: April 23, 2013; download: checker-274.tar.bz2; highlights:. Improved use-after-free and mismatched deallocator checking.; Diagnostic polish.; Fixes crashes found in checker-273. checker-273; built: April 8, 2013; download: checker-273.tar.bz2; highlights:. Additional checks for misuse of Foundation collection APIs.; New C++ checker for attempting to create a reference to null.; New use-after-free checker for C++ 'delete'.; New checker for simple cases of mismatched allocators and deallocators, e.g. ""delete malloc(4);""; Support for basic interprocedural analysis of C++ destructors.; Additional heuristics for suppressing null pointer false positives.; Misc. bug fixes and performance enhancements. checker-272; built: March 1, 2013; highlights:. Better modeling of C++ constructors:; ; Interprocedural analysis support for constructors of types with trivial destructors; Efficient model of trivial copy and move constructors. Better diagnostics for loops that execute 0 times; Fixes a linking issue that prevented the checker from running on OS X v10.6 and earlier; Fixes for misc. crashes and false positives. checker-271; built: February 8, 2013; highlights:. Faster analysis for scan-build xcodebuild when using Xcode 4.6 and higher:; ; scan-build now uses Xcode's built-in interposition mechanism for the static analyzer to provide faster builds while doing static analysis (PCH files are now built).; This change also allows scan-build to have better s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:4870,simpl,simple,4870,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,1,['simpl'],['simple']
Usability,"main() {; entry:; call void @print(i32 4); call void @print(i32 5); call void @print(i32 6); ret i32 0; }. Multiple Suspend Points; -----------------------. Let's consider the coroutine that has more than one suspend point:. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend>; print(-n);; <suspend>; }; }. Matching LLVM code would look like (with the rest of the code remaining the same; as the code in the previous section):. .. code-block:: llvm. loop:; %n.addr = phi i32 [ %n, %entry ], [ %inc, %loop.resume ]; call void @print(i32 %n.addr) #4; %2 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %2, label %suspend [i8 0, label %loop.resume; i8 1, label %cleanup]; loop.resume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; loop:; %inc = add nsw i32 %n, 1; store i32 %inc, ptr %n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:18922,resume,resume,18922,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"make an R?"". ***`A:`*** Well, in real life some objects have much more complex shapes; that an ***`R`***. The modeller cannot just know all of them; the idea; is to make a complex object by using elementary building blocks that; have known shapes (called ***`primitive shapes`***). Gluing these; together in the appropriate way is the user responsibility. ***`Q:`*** ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode() that I do not understand."". ***`A:`*** A volume is positioned inside another one by using this; method. The relative geometrical transformation as well as a copy number; must be specified. When positioned, a volume becomes a ***`node`*** of; its container and a new object of the class **`TGeoNode`** is; automatically created. This method is therefore the key element for the; creation of a hierarchical link between two volumes. As it will be; described further on in this document, there are few other methods; performing similar actions, but let us keep things simple for the time; being. In addition, notice that there are some visualization-related; calls in the example followed by a final `TGeoVolume::Draw() `call for; the top volume. These are explained in details in the section; ""Visualization Settings and Attributes"". At this point, you will; probably like to see how this geometry looks like. You just need to run; the example and you will get the following picture that you can rotate; using the mouse; or you can zoom / move it around (see what the Help; menu of the GL window displays). ``` {.cpp}; % root rootgeom.C; ```. ![](pictures/020001B1.jpg). Now let us browse the hierarchy that was just created. Start a browser; and double-click on the item simple1 representing the; ***`gGeoManager`*** object. Note that right click opens the context menu; of the manager class where several global methods are available. ``` {.cpp}; root[] new TBrowser;; ```. ![](pictures/020001B2.jpg). The folde",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:8112,simpl,simple,8112,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"maller; changes increases the odds that any of the work will be committed to the main; repository. To address these problems, LLVM uses an incremental development style and we; require contributors to follow this practice when making a large/invasive; change. Some tips:. * Large/invasive changes usually have a number of secondary changes that are; required before the big change can be made (e.g. API cleanup, etc). These; sorts of changes can often be done before the major change is done,; independently of that work. * The remaining inter-related work should be decomposed into unrelated sets of; changes if possible. Once this is done, define the first increment and get; consensus on what the end goal of the change is. * Each change in the set can be stand alone (e.g. to fix a bug), or part of a; planned series of changes that works towards the development goal. * Each change should be kept as small as possible. This simplifies your work; (into a logical progression), simplifies code review and reduces the chance; that you will get negative feedback on the change. Small increments also; facilitate the maintenance of a high quality code base. * Often, an independent precursor to a big change is to add a new API and slowly; migrate clients to use the new API. Each change to use the new API is often; ""obvious"" and can be committed without review. Once the new API is in place; and used, it is much easier to replace the underlying implementation of the; API. This implementation change is logically separate from the API; change. If you are interested in making a large change, and this scares you, please make; sure to first `discuss the change/gather consensus`_ then ask about the best way; to go about making the change. Attribution of Changes; ----------------------. When contributors submit a patch to an LLVM project, other developers with; commit access may commit it for the author once appropriate (based on the; progression of code review, etc.). When doing so, it is impo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:28779,simpl,simplifies,28779,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,3,"['feedback', 'simpl']","['feedback', 'simplifies']"
Usability,"mat::reformat(...)`` functions, the format is specified; by supplying the `clang::format::FormatStyle; <https://clang.llvm.org/doxygen/structclang_1_1format_1_1FormatStyle.html>`_; structure. Configurable Format Style Options; =================================. This section lists the supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5532,guid,guide,5532,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['guid'],['guide']
Usability,"mations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAnyOfnodeMatcherFunction...; Matches any of the NodeMatchers with InnerMatchers nested within. Given; if (true);; for (; true; );; with the matcher; mapAnyOf(ifStmt, forStmt).with(; hasCondition(cxxBoolLiteralExpr(equals(true))); ).bind(""trueCond""); matches the if and the for. It is equivalent to:; auto trueCond = hasCondition(cxxBoolLiteralExpr(equals(true)));; anyOf(; ifStmt(trueCond).bind(""trueCond""),; forStmt(trueCond).bind(""trueCond""); );. The with() chain-call accepts",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53758,Usab,Usable,53758,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"mber = @true; // equivalent to [NSNumber numberWithBool:(BOOL)true]; NSNumber *falseNumber = @false; // equivalent to [NSNumber numberWithBool:(BOOL)false]; #endif; }. Discussion; ----------. NSNumber literals only support literal scalar values after the ``'@'``.; Consequently, ``@INT_MAX`` works, but ``@INT_MIN`` does not, because; they are defined like this:. .. code-block:: objc. #define INT_MAX 2147483647 /* max value for an int */; #define INT_MIN (-2147483647-1) /* min value for an int */. The definition of ``INT_MIN`` is not a simple literal, but a; parenthesized expression. Parenthesized expressions are supported using; the `boxed expression <#objc_boxed_expressions>`_ syntax, which is; described in the next section. Because ``NSNumber`` does not currently support wrapping ``long double``; values, the use of a ``long double NSNumber`` literal (e.g.; ``@123.23L``) will be rejected by the compiler. Previously, the ``BOOL`` type was simply a typedef for ``signed char``,; and ``YES`` and ``NO`` were macros that expand to ``(BOOL)1`` and; ``(BOOL)0`` respectively. To support ``@YES`` and ``@NO`` expressions,; these macros are now defined using new language keywords in; ``<objc/objc.h>``:. .. code-block:: objc. #if __has_feature(objc_bool); #define YES __objc_yes; #define NO __objc_no; #else; #define YES ((BOOL)1); #define NO ((BOOL)0); #endif. The compiler implicitly converts ``__objc_yes`` and ``__objc_no`` to; ``(BOOL)1`` and ``(BOOL)0``. The keywords are used to disambiguate; ``BOOL`` and integer literals. Objective-C++ also supports ``@true`` and ``@false`` expressions, which; are equivalent to ``@YES`` and ``@NO``. Boxed Expressions; =================. Objective-C provides a new syntax for boxing C expressions:. .. code-block:: objc. @( <expression> ). Expressions of scalar (numeric, enumerated, BOOL), C string pointer; and some C structures (via NSValue) are supported:. .. code-block:: objc. // numbers.; NSNumber *smallestInt = @(-INT_MAX - 1); // [NSNumber",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:3483,simpl,simply,3483,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['simpl'],['simply']
Usability,"mdArgs;; // ... + for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {; + CmdArgs.push_back(Args.MakeArgString(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic shared object file."">,; + MarshallingInfoStringVector<CodeGenOpts<""PassPlugins"">>;. Inner workings of the system are introduced in the :ref:`marshalling; infrastructure <OptionMarshalling>` section and the available annotations are; listed :ref:`here <OptionMarshallingAnnotations>`. In case the marshalling infrastructure does not support the desired semantics,; consider simplifying it to fit the existing model. This makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args /*...*/) {; // ... + Opts.PassPlugins = Args.getAllArgValues(OPT_fpass_plugin_EQ);; }. static void GenerateCodeGenArgs(const CodeGenOptions &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:32566,simpl,simplifying,32566,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simplifying']
Usability,"mdat. Instruction Reference; =====================. The LLVM instruction set consists of several different classifications; of instructions: :ref:`terminator instructions <terminators>`, :ref:`binary; instructions <binaryops>`, :ref:`bitwise binary; instructions <bitwiseops>`, :ref:`memory instructions <memoryops>`, and; :ref:`other instructions <otherops>`. .. _terminators:. Terminator Instructions; -----------------------. As mentioned :ref:`previously <functionstructure>`, every basic block in a; program ends with a ""Terminator"" instruction, which indicates which; block should be executed after the current block is finished. These; terminator instructions typically yield a '``void``' value: they produce; control flow, not values (the one exception being the; ':ref:`invoke <i_invoke>`' instruction). The terminator instructions are: ':ref:`ret <i_ret>`',; ':ref:`br <i_br>`', ':ref:`switch <i_switch>`',; ':ref:`indirectbr <i_indirectbr>`', ':ref:`invoke <i_invoke>`',; ':ref:`callbr <i_callbr>`'; ':ref:`resume <i_resume>`', ':ref:`catchswitch <i_catchswitch>`',; ':ref:`catchret <i_catchret>`',; ':ref:`cleanupret <i_cleanupret>`',; and ':ref:`unreachable <i_unreachable>`'. .. _i_ret:. '``ret``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. ret <type> <value> ; Return a value from a non-void function; ret void ; Return from void function. Overview:; """""""""""""""""". The '``ret``' instruction is used to return control flow (and optionally; a value) from a function back to the caller. There are two forms of the '``ret``' instruction: one that returns a; value and then causes control flow, and one that just causes control; flow to occur. Arguments:; """""""""""""""""""". The '``ret``' instruction optionally accepts a single argument, the; return value. The type of the return value must be a ':ref:`first; class <t_firstclass>`' type. A function is not :ref:`well formed <wellformed>` if it has a non-void; return type and contains a '``ret``' instruction with no return value or; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:355210,resume,resume,355210,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability,"me library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the full file name. The option; ``-fsanitize-undefined-strip-path-components=N`` can be used to trim this; information. If ``N`` is positive, file information emitted by; UndefinedBehaviorSanitizer will drop the first ``N`` components from the file; path. If ``N`` is negative, the last ``N`` components will be kept. Example; -------. For a file called ``/code/library/file.cpp``, here is what would be emitted:. * Default (No flag, or ``-fsanitize-undefined-strip-path-components=0``): ``/code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=1``: ``code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=2``: ``library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=-1``: ``file.cpp``; * ``-fsanitize-undefined-strip-path-components=-2``: ``library/file.cpp``. More Information; ================. * From Oracle blog, including a discussion of error messages:; `Improving Application Security with UndefinedBehaviorSanitizer (UBSan) and GCC; <https://blogs.oracle.com/linux/improving-application-security-with-undefinedbehaviorsanitizer-ubsan-and-gcc>`_; * From LLVM project blog:; `What Every C Programmer Should Know About Undefined Behavior; <http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html>`_; * From John Regehr's *Embedded in Academia* blog:; `A Guide to Undefined Behavior in C and C++; <https://blog.regehr.org/archives/213>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:17549,Guid,Guide,17549,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['Guid'],['Guide']
Usability,"me strings as **``parser<bool>``**. .. _strings:. * The **parser<string> specialization** simply stores the parsed string into the; string value specified. No conversion or modification of the data is; performed. .. _integers:; .. _int:. * The **parser<int> specialization** uses the C ``strtol`` function to parse the; string input. As such, it will accept a decimal number (with an optional '+'; or '-' prefix) which must start with a non-zero digit. It accepts octal; numbers, which are identified with a '``0``' prefix digit, and hexadecimal; numbers with a prefix of '``0x``' or '``0X``'. .. _doubles:; .. _float:; .. _double:. * The **parser<double>** and **parser<float> specializations** use the standard; C ``strtod`` function to convert floating point strings into floating point; values. As such, a broad range of string formats is supported, including; exponential notation (ex: ``1.7e15``) and properly supports locales. .. _Extension Guide:; .. _extending the library:. Extension Guide; ===============. Although the CommandLine library has a lot of functionality built into it; already (as discussed previously), one of its true strengths lie in its; extensibility. This section discusses how the CommandLine library works under; the covers and illustrates how to do some simple, common, extensions. .. _Custom parsers:; .. _custom parser:; .. _Writing a Custom Parser:. Writing a custom parser; -----------------------. One of the simplest and most common extensions is the use of a custom parser.; As `discussed previously`_, parsers are the portion of the CommandLine library; that turns string input from the user into a particular parsed data type,; validating the input in the process. There are two ways to use a new parser:. #. Specialize the `cl::parser`_ template for your custom data type. This approach has the advantage that users of your custom data type will; automatically use your custom parser whenever they define an option with a; value type of your data type. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:61405,Guid,Guide,61405,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['Guid'],['Guide']
Usability,"me. Here we use the `cl::init`_ option to specify an initial; value for the command line option, which is used if the option is not specified; (if you do not specify a `cl::init`_ modifier for an option, then the default; constructor for the data type is used to initialize the value). Command line; options default to being optional, so if we would like to require that the user; always specify an input filename, we would add the `cl::Required`_ flag, and we; could eliminate the `cl::init`_ modifier, like this:. .. code-block:: c++. cl::opt<string> InputFilename(cl::Positional, cl::desc(""<input file>""), cl::Required);. Again, the CommandLine library does not require the options to be specified in; any particular order, so the above declaration is equivalent to:. .. code-block:: c++. cl::opt<string> InputFilename(cl::Positional, cl::Required, cl::desc(""<input file>""));. By simply adding the `cl::Required`_ flag, the CommandLine library will; automatically issue an error if the argument is not specified, which shifts all; of the command line option verification code out of your application into the; library. This is just one example of how using flags can alter the default; behaviour of the library, on a per-option basis. By adding one of the; declarations above, the ``-help`` option synopsis is now extended to:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -h - Alias for -help; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename. ... indicating that an input filename is expected. Boolean Arguments; -----------------. In addition to input and output filenames, we would like the compiler example to; support three boolean flags: ""``-f``"" to force writing binary output to a; terminal, ""``--quiet``"" to enable quiet mode, and ""``-q``"" for backwards; compatibility with some of our users. We can support these by declaring options; of boolean type like this:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Enable ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:8115,simpl,simply,8115,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simply']
Usability,"meType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TypeLoc>locMatcher<QualType> InnerMatcher; Matches TypeLocs for which the given inner; QualType-matcher matches. Matcher<TypedefNameDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<TypedefNameDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<TypedefType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:245711,Usab,Usable,245711,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"med objects. .. _arc.misc.autoreleasepool:. ``@autoreleasepool``; --------------------. To simplify the use of autorelease pools, and to bring them under the control; of the compiler, a new kind of statement is available in Objective-C. It is; written ``@autoreleasepool`` followed by a *compound-statement*, i.e. by a new; scope delimited by curly braces. Upon entry to this block, the current state; of the autorelease pool is captured. When the block is exited normally,; whether by fallthrough or directed control flow (such as ``return`` or; ``break``), the autorelease pool is restored to the saved state, releasing all; the objects in it. When the block is exited with an exception, the pool is not; drained. ``@autoreleasepool`` may be used in non-ARC translation units, with equivalent; semantics. A program is ill-formed if it refers to the ``NSAutoreleasePool`` class. .. admonition:: Rationale. Autorelease pools are clearly important for the compiler to reason about, but; it is far too much to expect the compiler to accurately reason about control; dependencies between two calls. It is also very easy to accidentally forget; to drain an autorelease pool when using the manual API, and this can; significantly inflate the process's high-water-mark. The introduction of a; new scope is unfortunate but basically required for sane interaction with the; rest of the language. Not draining the pool during an unwind is apparently; required by the Objective-C exceptions implementation. .. _arc.misc.externally_retained:. Externally-Retained Variables; -----------------------------. In some situations, variables with strong ownership are considered; externally-retained by the implementation. This means that the variable is; retained elsewhere, and therefore the implementation can elide retaining and; releasing its value. Such a variable is implicitly ``const`` for safety. In; contrast with ``__unsafe_unretained``, an externally-retained variable still; behaves as a strong variable o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:91347,clear,clearly,91347,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['clear'],['clearly']
Usability,"ment is *only* loaded, then it can pass the value into the function instead; of the address of the value. This can cause recursive simplification of code; and lead to the elimination of allocas (especially in C++ template code like; the STL). This pass also handles aggregate arguments that are passed into a function,; scalarizing them if the elements of the aggregate are only loaded. Note that; it refuses to scalarize aggregates which would require passing in more than; three operands to the function, because passing thousands of operands for a; large array or structure is unprofitable!. Note that this transformation could also be done for arguments that are only; stored to (returning the value instead), but does not currently. This case; would be best handled when and if LLVM starts supporting multiple return values; from functions. ``block-placement``: Profile Guided Basic Block Placement; ---------------------------------------------------------. This pass is a very simple profile guided basic block placement algorithm. The; idea is to put frequently executed blocks together at the start of the function; and hopefully increase the number of fall-through conditional branches. If; there is no profile information for a particular function, this pass basically; orders blocks in depth-first order. ``break-crit-edges``: Break critical edges in CFG; -------------------------------------------------. Break all of the critical edges in the CFG by inserting a dummy basic block.; It may be ""required"" by passes that cannot deal with critical edges. This; transformation obviously invalidates the CFG, but can update forward dominator; (set, immediate dominators, tree, and frontier) information. ``codegenprepare``: Optimize for code generation; ------------------------------------------------. This pass munges the code in the input function to better prepare it for; SelectionDAG-based code generation. This works around limitations in its; basic-block-at-a-time approach. It shoul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:13658,simpl,simple,13658,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,2,"['guid', 'simpl']","['guided', 'simple']"
Usability,"ments for public APIs into the; header file. Documentation comments for private APIs can go to the; implementation file. In any case, implementation files can include additional; comments (not necessarily in Doxygen markup) to explain implementation details; as needed. Don't duplicate function or class name at the beginning of the comment.; For humans it is obvious which function or class is being documented;; automatic documentation processing tools are smart enough to bind the comment; to the correct declaration. Avoid:. .. code-block:: c++. // Example.h:. // example - Does something important.; void example();. // Example.cpp:. // example - Does something important.; void example() { ... }. Preferred:. .. code-block:: c++. // Example.h:. /// Does something important.; void example();. // Example.cpp:. /// Builds a B-tree in order to do foo. See paper by...; void example() { ... }. Error and Warning Messages; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Clear diagnostic messages are important to help users identify and fix issues in; their inputs. Use succinct but correct English prose that gives the user the; context needed to understand what went wrong. Also, to match error message; styles commonly produced by other tools, start the first sentence with a; lower-case letter, and finish the last sentence without a period, if it would; end in one otherwise. Sentences which end with different punctuation, such as; ""did you forget ';'?"", should still do so. For example this is a good error message:. .. code-block:: none. error: file.o: section header 3 is corrupt. Size is 10 when it should be 20. This is a bad message, since it does not provide useful information and uses the; wrong style:. .. code-block:: none. error: file.o: Corrupt section header. As with other coding standards, individual projects, such as the Clang Static; Analyzer, may have preexisting styles that do not conform to this. If a; different formatting scheme is used consistently throughout the project, use; that st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:14023,Clear,Clear,14023,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['Clear'],['Clear']
Usability,ments vs the ODR; Unknown. 2368; CD5; Differences in relational and three-way constant comparisons; Unknown. 2369; CD6; Ordering between constraints and substitution; Unknown. 2370; CD6; friend declarations of namespace-scope functions; No. 2371; CD5; Use of the English term “attributes” is confusing; Unknown. 2372; CD5; Incorrect matching rules for block-scope extern declarations; Unknown. 2373; CD5; Incorrect handling of static member function templates in partial ordering; Unknown. 2374; C++20; Overly permissive specification of enum direct-list-initialization; Unknown. 2375; NAD; Multiple redeclarations of constexpr static data members; Unknown. 2376; CD5; Class template argument deduction with array declarator; Unknown. 2377; NAD; Explicit copy constructor vs function viability; Unknown. 2378; C++20; Inconsistent grammar for reference init-capture of pack; Unknown. 2379; CD5; Missing prohibition against constexpr in friend declaration; Unknown. 2380; CD5; capture-default makes too many references odr-usable; Unknown. 2381; CD5; Composite pointer type of pointers to plain and noexcept member functions; Unknown. 2382; CD5; Array allocation overhead for non-allocating placement new; Unknown. 2383; NAD; Variadic member functions of variadic class templates; Unknown. 2384; CD5; Conversion function templates and qualification conversions; Unknown. 2385; CD5; Lookup for conversion-function-ids; N/A. 2386; CD5; tuple_size requirements for structured binding; Clang 9. 2387; CD5; Linkage of const-qualified variable template; Clang 9. 2388; NAD; Applicability of contract-attribute-specifiers; Unknown. 2389; CD6; Agreement of deduced and explicitly-specified variable types; Unknown. 2390; CD5; Is the argument of __has_cpp_attribute macro-expanded?; Clang 14. 2391; dup; Additional template parameters following pack expansion; Unknown. 2392; C++23; new-expression size check and constant evaluation; Unknown. 2393; NAD; Pseudo-destructors and object lifetime; Unknown. 2394; CD,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:162631,usab,usable,162631,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['usab'],['usable']
Usability,"ments, not; an exact sequence of operations that a program will be compiled into. .. _arc.objects.operands:. Retainable object pointers as operands and arguments; ----------------------------------------------------. In general, ARC does not perform retain or release operations when simply using; a retainable object pointer as an operand within an expression. This includes:. * loading a retainable pointer from an object with non-weak :ref:`ownership; <arc.ownership>`,; * passing a retainable pointer as an argument to a function or method, and; * receiving a retainable pointer as the result of a function or method call. .. admonition:: Rationale. While this might seem uncontroversial, it is actually unsafe when multiple; expressions are evaluated in ""parallel"", as with binary operators and calls,; because (for example) one expression might load from an object while another; writes to it. However, C and C++ already call this undefined behavior; because the evaluations are unsequenced, and ARC simply exploits that here to; avoid needing to retain arguments across a large number of calls. The remainder of this section describes exceptions to these rules, how those; exceptions are detected, and what those exceptions imply semantically. .. _arc.objects.operands.consumed:. Consumed parameters; ^^^^^^^^^^^^^^^^^^^. A function or method parameter of retainable object pointer type may be marked; as :arc-term:`consumed`, signifying that the callee expects to take ownership; of a +1 retain count. This is done by adding the ``ns_consumed`` attribute to; the parameter declaration, like so:. .. code-block:: objc. void foo(__attribute((ns_consumed)) id x);; - (void) foo: (id) __attribute((ns_consumed)) x;. This attribute is part of the type of the function or method, not the type of; the parameter. It controls only how the argument is passed and received. When passing such an argument, ARC retains the argument prior to making the; call. When receiving such an argument, ARC releases",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:16278,simpl,simply,16278,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['simpl'],['simply']
Usability,"merged in one go. This is to guarantee; that all changes are good as a single block.; 6. After the initial merge, the target community can stop numbering patches and; start working asynchronously on the target to complete support. They should; still seek review from those who helped them in the initial phase, to make; sure the progress is still consistent.; 7. Once all official requirements have been fulfilled (as above), the code owner; should request the target to be enabled by default by sending another RFC to; the `LLVM Discourse forums`_. Adding an Established Project To the LLVM Monorepo; --------------------------------------------------. The `LLVM monorepo <https://github.com/llvm/llvm-project>`_ is the centerpoint; of development in the LLVM world, and has all of the primary LLVM components,; including the LLVM optimizer and code generators, Clang, LLDB, etc. `Monorepos; in general <https://en.wikipedia.org/wiki/Monorepo>`_ are great because they; allow atomic commits to the project, simplify CI, and make it easier for; subcommunities to collaborate. Like new targets, most projects already in the monorepo are considered to be in; the *core tier* of our :doc:`support policy<SupportPolicy>`. The burden to add; things to the LLVM monorepo needs to be very high - code that is added to this; repository is checked out by everyone in the community. As such, we hold; components to a high bar similar to ""official targets"", they:. * Must be generally aligned with the mission of the LLVM project to advance; compilers, languages, tools, runtimes, etc.; * Must conform to all of the policies laid out in this developer policy; document, including license, patent, coding standards, and code of conduct.; * Must have an active community that maintains the code, including established; code owners.; * Should have reasonable documentation about how it works, including a high; quality README file.; * Should have CI to catch breakage within the project itself or due to; underlying",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:45351,simpl,simplify,45351,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['simpl'],['simplify']
Usability,"merging of different page sources into one page sink. This also means that RNTuples can be merged through `hadd`.; - Zero-copy bulk reading has been added, with extra optimizations for `ROOT::RVec` fields.; - It is now possible to use the `RNTupleView` with an external address with type erasure, e.g.:; ```cpp; std::shared_ptr<void> data{new float()};; auto view = reader->GetView(""pt"", data);; ```; This enables use cases such as reading one specific entry of one specific field into a previously allocated memory location.; - Further integration with [RDataFrame](#rdataframe): it is now possible to create RDataFrame for chains of RNTuples. This addition also comes with improvements to the multi-threaded work scheduling.; - Many additional bug fixes and improvements. Please, report any issues regarding the above mentioned features should you encounter them. RNTuple is still in pre-production. The on-disk format is scheduled to be finalized by the end of 2024. Thus, we appreciate feedback and suggestions for improvement. ## Histogram Libraries. - Implement the FLT_MAX mechanism for `THStack::GetMaximum()` and `THStack::GetMiniumum()`.; - Print a warning when the range given to `TAxis::SetRange` is invalid.; - Fix projection name in `TH3` as requested [here](https://root-forum.cern.ch/t/project3d-letter-d-in-name-option/57612). ## Parallelism; - The ROOT::Experimental::TFuture template has been removed. ## RooFit Libraries. ### New CPU likelihood evaluation backend by default. The new vectorizing CPU evaluation backend is not the default for RooFit likelihoods.; Likelihood minimization is now up to 10x faster on a single CPU core. If you experience unexpected problems related to the likelihood evaluation, you; can revert back to the old backend by passing `RooFit::EvalBackend(""legacy"")`; to `RooAbsPdf::fitTo()` or `RooAbsPdf::createNLL()`. In case you observe any slowdowns with the new likelihood evaluation, please; open a GitHub issue about this, as such a performance re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:6557,feedback,feedback,6557,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['feedback'],['feedback']
Usability,"meters. A function can also return an object to a caller by a means of an out parameter; (a pointer-to-OSObject-pointer is passed, and a callee writes a pointer to an; object into an argument).; Currently the analyzer does not track unannotated out; parameters by default, but with annotations we distinguish four separate cases:. 1. Non-retained out parameters, identified using; LIBKERN_RETURNS_NOT_RETAINED applied to parameters, e.g.:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). Such functions write a non-retained object into an out parameter, and the; caller has no further obligations.; 2. Retained out parameters,; identified using LIBKERN_RETURNS_RETAINED:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). In such cases a retained object is written into an out parameter, which the caller has then to release in order to avoid a leak. These two cases are simple - but in practice a functions returning an out-parameter usually also return a return code, and then an out parameter may or may not be written, which conditionally depends on the exit code, e.g.:. bool maybeCreateObject(LIBKERN_RETURNS_RETAINED OSObject **obj);. For such functions, the usual semantics is that an object is written into on ""success"", and not written into on ""failure"".; For LIBKERN_RETURNS_RETAINED we assume the following definition of; success:; For functions returning OSReturn or IOReturn; (any typedef to kern_return_t) success is defined as having an output of zero (kIOReturnSuccess is zero).; For all others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *data, LIBKERN_RETURNS_RETAINED_ON_ZERO OSString **errString);. Then the caller has to release an object if the function has returned zero.; 4. Retained out parameters on non-zero",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:18158,simpl,simple,18158,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['simpl'],['simple']
Usability,method UpperLimit returns to the user the upper limit value. The HypoTestInverter implements various option for performing the scan. HypoTestInverter::RunFixedScan will scan using a fixed grid the parameter of interest. HypoTestInverter::RunAutoScan will perform an automatic scan to find optimally the curve and it will stop when the desired precision is obtained.; The confidence level value at a given point can also be done via HypoTestInverter::RunOnePoint.; The class can scan the CLs+b values (default) or alternatively CLs (if the; method HypoTestInverter::UseCLs has been called).; The estimated error due to the MC toys statistics from the HybridCalculator is propagated into the limits obtained from the HypoTestResult; A new tutorial rs801_HypoTestInverter.C has been added in the tutorials/roostats directory to show the usage of this class. New class BayesianCalculator. New class for calculating Bayesian interval using numerical integration. It implements the IntervalCalculator interface and returns as result a SimpleInterval. . The BayesianCalculator::GetInterval() method returns a SimpleInterval which contains the lower and upper value of the bayesian interval obtained from the posterior probability for the given confidence level.; The class return also the posterior pdf (BayesianCalculator::GetPosteriorPdf()) obtained from integrating (marginalizing) on the nuisance parameters.; It works currently only for one-dimensional problems by relying on RooFit for performing analytical or numerical integration.; A plot of the posterior and the desired interval can be obtained using BayesianCalculator::GetPosteriorPlot().; A new tutorial rs701_BayesianCalculator.C has been added in the tutorials/roostats directory to show the usage of this class. MCMCCalculator. Add possibility to specify the prior function in the constructor of the class to have a signature similar to the BayesianCalculator class. When no prior is specified it is assumed is part of the global model (pdf),MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:16093,Simpl,SimpleInterval,16093,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['Simpl'],['SimpleInterval']
Usability,"milar to dead instruction elimination, but it; rechecks instructions that were used by removed instructions to see if they; are newly dead. ``deadargelim``: Dead Argument Elimination; ------------------------------------------. This pass deletes dead arguments from internal functions. Dead argument; elimination removes arguments which are directly dead, as well as arguments; only passed into function calls as dead arguments of other functions. This; pass also deletes dead arguments in a similar way. This pass is often useful as a cleanup pass to run after aggressive; interprocedural passes, which add possibly-dead arguments. ``dse``: Dead Store Elimination; -------------------------------. A trivial dead store elimination that only considers basic-block local; redundant stores. .. _passes-function-attrs:. ``function-attrs``: Deduce function attributes; ----------------------------------------------. A simple interprocedural pass which walks the call-graph, looking for functions; which do not access or only read non-local memory, and marking them; ``readnone``/``readonly``. In addition, it marks function arguments (of; pointer type) ""``nocapture``"" if a call to the function does not create any; copies of the pointer value that outlive the call. This more or less means; that the pointer is only dereferenced, and not returned from the function or; stored in a global. This pass is implemented as a bottom-up traversal of the; call-graph. ``globaldce``: Dead Global Elimination; --------------------------------------. This transform is designed to eliminate unreachable internal globals from the; program. It uses an aggressive algorithm, searching out globals that are known; to be alive. After it finds all of the globals which are needed, it deletes; whatever is left over. This allows it to delete recursive chunks of the; program which are unreachable. ``globalopt``: Global Variable Optimizer; ----------------------------------------. This pass transforms simple global varia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:16076,simpl,simple,16076,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"miliMinimizer.cxx; FumiliStandardChi2FCN.cxx; FumiliStandardMaximumLikelihoodFCN.cxx; HessianGradientCalculator.cxx; InitialGradientCalculator.cxx; LaEigenValues.cxx; LaInnerProduct.cxx; LaInverse.cxx; LaOuterProduct.cxx; LaSumOfElements.cxx; LaVtMVSimilarity.cxx; MPIProcess.cxx; MinimumBuilder.cxx; Minuit2Minimizer.cxx; MnApplication.cxx; MnContours.cxx; MnCovarianceSqueeze.cxx; MnEigen.cxx; MnFcn.cxx; MnFumiliMinimize.cxx; MnFunctionCross.cxx; MnGlobalCorrelationCoeff.cxx; MnHesse.cxx; MnLineSearch.cxx; MnMachinePrecision.cxx; MnMinos.cxx; MnParabolaFactory.cxx; MnParameterScan.cxx; MnPlot.cxx; MnPosDef.cxx; MnPrint.cxx; MnPrintImpl.cxx; MnScan.cxx; MnSeedGenerator.cxx; MnStrategy.cxx; MnTiny.cxx; MnTraceObject.cxx; MnUserFcn.cxx; MnUserParameterState.cxx; MnUserParameters.cxx; MnUserTransformation.cxx; ModularFunctionMinimizer.cxx; NegativeG2LineSearch.cxx; Numerical2PGradientCalculator.cxx; ParametricFunction.cxx; ScanBuilder.cxx; SimplexBuilder.cxx; SimplexParameters.cxx; SimplexSeedGenerator.cxx; SinParameterTransformation.cxx; SqrtLowParameterTransformation.cxx; SqrtUpParameterTransformation.cxx; VariableMetricBuilder.cxx; VariableMetricEDMEstimator.cxx; mnbins.cxx; mndasum.cxx; mndaxpy.cxx; mnddot.cxx; mndscal.cxx; mndspmv.cxx; mndspr.cxx; mnlsame.cxx; mnteigen.cxx; mntplot.cxx; mnvert.cxx; mnxerbla.cxx; ). prepend_path(MINUIT2_HEADERS ""${Minuit2_SOURCE_DIR}/inc/Minuit2"" ${MINUIT2_HEADERS}); prepend_path(MINUIT2_SOURCES ""${CMAKE_CURRENT_SOURCE_DIR}"" ${MINUIT2_SOURCES}). add_library(Minuit2; ${MINUIT2_SOURCES}; ${MINUIT2_HEADERS}; ). # Add alias for direct inclusion with add_subdirectory; add_library(Minuit2::Minuit2 ALIAS Minuit2). target_include_directories(; Minuit2; PUBLIC; $<BUILD_INTERFACE:${Minuit2_SOURCE_DIR}/inc>; $<INSTALL_INTERFACE:include/Minuit2>; ). target_compile_features(Minuit2 PUBLIC cxx_nullptr cxx_nonstatic_member_init); set_target_properties(Minuit2 PROPERTIES CXX_EXTENSIONS OFF). target_link_libraries(Minuit2 PUBLIC Minuit2Math Minuit2Co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt:3473,Simpl,SimplexSeedGenerator,3473,math/minuit2/src/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt,1,['Simpl'],['SimplexSeedGenerator']
Usability,"mirroring our current SVN; repository.; 3. Add the required bots to implement the commit emails, as well as the; umbrella repository update (if the multirepo is selected) or the read-only; Git views for the sub-projects (if the monorepo is selected). Step #2 : Git Move; ------------------. 4. Update the buildbots to pick up updates and commits from the GitHub; repository. Not all bots have to migrate at this point, but it'll help; provide infrastructure testing.; 5. Update Phabricator to pick up commits from the GitHub repository.; 6. LNT and llvmlab have to be updated: they rely on unique monotonically; increasing integer across branch [MatthewsRevNum]_.; 7. Instruct downstream integrators to pick up commits from the GitHub; repository.; 8. Review and prepare an update for the LLVM documentation. Until this point nothing has changed for developers, it will just; boil down to a lot of work for buildbot and other infrastructure; owners. The migration will pause here until all dependencies have cleared, and all; problems have been solved. Step #3: Write Access Move; --------------------------. 9. Collect developers' GitHub account information, and add them to the project.; 10. Switch the SVN repository to read-only and allow pushes to the GitHub repository.; 11. Update the documentation.; 12. Mirror Git to SVN. Step #4 : Post Move; -------------------. 13. Archive the SVN repository.; 14. Update links on the LLVM website pointing to viewvc/klaus/phab etc. to; point to GitHub instead. GitHub Repository Description; =============================. Monorepo; ----------------. The LLVM git repository hosted at https://github.com/llvm/llvm-project contains all; sub-projects in a single source tree. It is often referred to as a monorepo and; mimics an export of the current SVN repository, with each sub-project having its; own top-level directory. Not all sub-projects are used for building toolchains.; For example, www/ and test-suite/ are not part of the monorepo. Putting all",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:7800,pause,pause,7800,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,2,"['clear', 'pause']","['cleared', 'pause']"
Usability,"mized with ""clang -emit-llvm-bc | opt -O3"". //===---------------------------------------------------------------------===//. int f(int i, int j) { return i < j + 1; }; int g(int i, int j) { return j > i - 1; }; Should combine to ""i <= j"" (the add/sub has nsw). Currently not; optimized with ""clang -emit-llvm-bc | opt -O3"". //===---------------------------------------------------------------------===//. unsigned f(unsigned x) { return ((x & 7) + 1) & 15; }; The & 15 part should be optimized away, it doesn't change the result. Currently; not optimized with ""clang -emit-llvm-bc | opt -O3"". //===---------------------------------------------------------------------===//. This was noticed in the entryblock for grokdeclarator in 403.gcc:. %tmp = icmp eq i32 %decl_context, 4 ; %decl_context_addr.0 = select i1 %tmp, i32 3, i32 %decl_context ; %tmp1 = icmp eq i32 %decl_context_addr.0, 1 ; %decl_context_addr.1 = select i1 %tmp1, i32 0, i32 %decl_context_addr.0. tmp1 should be simplified to something like:; (!tmp || decl_context == 1). This allows recursive simplifications, tmp1 is used all over the place in; the function, e.g. by:. %tmp23 = icmp eq i32 %decl_context_addr.1, 0 ; <i1> [#uses=1]; %tmp24 = xor i1 %tmp1, true ; <i1> [#uses=1]; %or.cond8 = and i1 %tmp23, %tmp24 ; <i1> [#uses=1]. later. //===---------------------------------------------------------------------===//. [STORE SINKING]. Store sinking: This code:. void f (int n, int *cond, int *res) {; int i;; *res = 0;; for (i = 0; i < n; i++); if (*cond); *res ^= 234; /* (*) */; }. On this function GVN hoists the fully redundant value of *res, but nothing; moves the store out. This gives us this code:. bb:		; preds = %bb2, %entry; 	%.rle = phi i32 [ 0, %entry ], [ %.rle6, %bb2 ]	; 	%i.05 = phi i32 [ 0, %entry ], [ %indvar.next, %bb2 ]; 	%1 = load i32* %cond, align 4; 	%2 = icmp eq i32 %1, 0; 	br i1 %2, label %bb2, label %bb1. bb1:		; preds = %bb; 	%3 = xor i32 %.rle, 234	; 	store i32 %3, i32* %res, align 4; 	br label %bb2",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:27969,simpl,simplified,27969,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplified']
Usability,"mmandLine library, this is represented like; this:. .. _scalars arguments:; .. _here:. .. code-block:: c++. cl::opt<string> OutputFilename(""o"", cl::desc(""Specify output filename""), cl::value_desc(""filename""));. This declares a global variable ""``OutputFilename``"" that is used to capture the; result of the ""``o``"" argument (first parameter). We specify that this is a; simple scalar option by using the ""``cl::opt``"" template (as opposed to the; ""``cl::list``"" template), and tell the CommandLine library that the data; type that we are parsing is a string. The second and third parameters (which are optional) are used to specify what to; output for the ""``-help``"" option. In this case, we get a line that looks like; this:. ::. USAGE: compiler [options]. OPTIONS:; -h - Alias for -help; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename. Because we specified that the command line option should parse using the; ``string`` data type, the variable declared is automatically usable as a real; string in all contexts that a normal C++ string object may be used. For; example:. .. code-block:: c++. ...; std::ofstream Output(OutputFilename.c_str());; if (Output.good()) ...; ... There are many different options that you can use to customize the command line; option handling library, but the above example shows the general interface to; these options. The options can be specified in any order, and are specified; with helper functions like `cl::desc(...)`_, so there are no positional; dependencies to remember. The available options are discussed in detail in the; `Reference Guide`_. Continuing the example, we would like to have our compiler take an input; filename as well as an output filename, but we do not want the input filename to; be specified with a hyphen (ie, not ``-filename.c``). To support this style of; argument, the CommandLine library allows for `positional`_ arguments to be; specified for the program. These positional argumen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:5942,usab,usable,5942,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['usab'],['usable']
Usability,"mnemonics `Alt+D`, `Alt+E` for their; selection. The letter D and E appear underlined on the screen. All text; buttons should have a unique shortcut key with the exception of OK and; Cancel. These buttons are usually placed within a window to provide fast access; to frequently used or critical commands. They help in situations where a; command is not available through the menu bar. You already know that a; command string can be passed in the text button via the constructor:. ``` {.cpp}; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; ```. A button label can be changed by `SetText(new_label).` There are; important guidelines to be followed about a button label. The text has; to provide a meaningful description of the performed action. The; single-word label should be used whenever possible, only two-three words; for clarity, if necessary. Do not number labels. Always follow all; platform presentation and usage guidelines for standard button; functions. Let's remember a few standard names and definitions of well; known buttons:. ***`OK`*** - any changed information in a window is accepted and the; window is closed;. ***`Cancel`*** - closes window without implementing submitted changes;. ***`Reset `***- resets defaults and cancels any changed information that; has not be submitted;. ***`Apply`*** - any changed information is accepted and again displayed; in the window that remains open;. ***`Close`*** - closes the window;. ***`Help`*** - opens online Help. Below are examples of text buttons. Note the two placement methods. The; first example should be used when there are one to three command; buttons; the second one when there are more than three buttons. ![](pictures/0200020E.jpg). Picture buttons are usually rectangular in shape with an icon or; graphics label. These buttons may appear alone or placed in a group at; the window's top or side. They are most frequently used to quickly; acc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:56681,guid,guidelines,56681,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['guid'],['guidelines']
Usability,"model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:1914,usab,usable,1914,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['usab'],['usable']
Usability,"modest performance improvement to boot, because of; fewer dictionary lookups), e.g.:. .. code-block:: python. import cppyy; std = cppyy.gbl.std; v = std.vector[int](range(10)). But even such rebinding becomes annoying for (brief) interactive sessions. For CPython only (and not with tools such as IPython or in IDEs that replace; the interactive prompt), there is a fix, using; ``from cppyy.interactive import *``.; This makes lookups in the global dictionary of the current frame also; consider everything under ``cppyy.gbl``.; This feature comes with a performance `penalty` and is not meant for; production code.; Example usage:. .. code-block:: python. >>> from cppyy.interactive import *; >>> v = std.vector[int](range(10)); >>> print(list(v)); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; >>> cppdef(""struct SomeStruct {};""); True; >>> s = SomeStruct() # <- dynamically made available; >>> s; <cppyy.gbl.SomeStruct object at 0x7fa9b8624320>; >>>. For PyPy, IPython, etc. ``cppyy.gbl`` is simply rebound as ``g`` and; ``cppyy.gbl.std`` is made available as ``std``.; Not as convenient as full lookup, and missing any other namespaces that may be; available, but still saves some typing in may cases. `Odds and ends`; ---------------. * **namespaces**: Are represented as python classes.; Namespaces are more open-ended than classes, so sometimes initial access may; result in updates as data and functions are looked up and constructed; lazily.; Thus the result of ``dir()`` on a namespace shows the classes and functions; available for binding, even if these may not have been created yet.; Once created, namespaces are registered as modules, to allow importing from; them.; The global namespace is ``cppyy.gbl``. * **NULL**: Is represented as ``cppyy.nullptr``.; Starting C++11, the keyword ``nullptr`` is used to represent ``NULL``.; For clarity of intent, it is recommended to use this instead of ``None``; (or the integer ``0``, which can serve in some cases), as ``None`` is better; understood as ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/misc.rst:5505,simpl,simply,5505,bindings/pyroot/cppyy/cppyy/doc/source/misc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/misc.rst,1,['simpl'],['simply']
Usability,"monly change the program in ways that change the maximal; converged-with relations. This also means that a value that was; previously uniform can become divergent after such a transform.; Uniformity has to be recomputed after such transforms. Divergent Branch inside a Cycle; -------------------------------. .. figure:: convergence-divergent-inside.png; :name: convergence-divergent-inside. The above figure shows a divergent branch ``Q`` inside an irreducible; cyclic region. When two threads diverge at ``Q``, the convergence of; dynamic instances within the cyclic region depends on the cycle; hierarchy chosen:. 1. In an implementation that detects a single cycle ``C`` with header; ``P``, convergence inside the cycle is determined by ``P``. 2. In an implementation that detects two nested cycles with headers; ``R`` and ``S``, convergence inside those cycles is determined by; their respective headers. .. _convergence-diverged-entry:. A conservative approach would be to simply report all nodes inside; irreducible cycles as having divergent outputs. But it is desirable to; recognize m-converged nodes in the CFG in order to maximize; uniformity. This section describes one such pattern of nodes derived; from *closed paths*, which are a property of the CFG and do not depend; on the cycle hierarchy. **Diverged Entry Criterion:**. The dynamic instances of all the nodes in a closed path ``P`` are; m-converged only if for every divergent branch ``B`` and its; join node ``J`` that lie on ``P``, there is no entry to ``P`` which; lies on a diverged path from ``B`` to ``J``. .. figure:: convergence-closed-path.png; :name: convergence-closed-path. Consider the closed path ``P -> Q -> R -> S`` in the above figure.; ``P`` and ``R`` are :ref:`entries to the closed; path<cycle-closed-path>`. ``Q`` is a divergent branch and ``S`` is a; join for that branch, with diverged paths ``Q -> R -> S`` and ``Q ->; S``. - If a diverged entry ``R`` exists, then in some cycle hierarchy,; ``R`` is the h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:21605,simpl,simply,21605,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['simpl'],['simply']
Usability,"mpile these two functions to the same thing:. #include <stdlib.h>; void f(int a, int b, int *P) {; *P = (a-b)>=0?(a-b):(b-a);; }; void g(int a, int b, int *P) {; *P = abs(a-b);; }. Further, they should compile to something better than:. _g:; subf r2, r4, r3; subfic r3, r2, 0; cmpwi cr0, r2, -1; bgt cr0, LBB2_2 ; entry; LBB2_1: ; entry; mr r2, r3; LBB2_2: ; entry; stw r2, 0(r5); blr. GCC produces:. _g:; subf r4,r4,r3; srawi r2,r4,31; xor r0,r2,r4; subf r0,r2,r0; stw r0,0(r5); blr. ... which is much nicer. This theoretically may help improve twolf slightly (used in dimbox.c:142?). ===-------------------------------------------------------------------------===. PR5945: This: ; define i32 @clamp0g(i32 %a) {; entry:; %cmp = icmp slt i32 %a, 0; %sel = select i1 %cmp, i32 0, i32 %a; ret i32 %sel; }. Is compile to this with the PowerPC (32-bit) backend:. _clamp0g:; cmpwi cr0, r3, 0; li r2, 0; blt cr0, LBB1_2; ; %bb.1: ; %entry; mr r2, r3; LBB1_2: ; %entry; mr r3, r2; blr. This could be reduced to the much simpler:. _clamp0g:; srawi r2, r3, 31; andc r3, r3, r2; blr. ===-------------------------------------------------------------------------===. int foo(int N, int ***W, int **TK, int X) {; int t, i;; ; for (t = 0; t < N; ++t); for (i = 0; i < 4; ++i); W[t / X][i][t % X] = TK[i][t];; ; return 5;; }. We generate relatively atrocious code for this loop compared to gcc. We could also strength reduce the rem and the div:; http://www.lcs.mit.edu/pubs/pdf/MIT-LCS-TM-600.pdf. ===-------------------------------------------------------------------------===. We generate ugly code for this:. void func(unsigned int *ret, float dx, float dy, float dz, float dw) {; unsigned code = 0;; if(dx < -dw) code |= 1;; if(dx > dw) code |= 2;; if(dy < -dw) code |= 4;; if(dy > dw) code |= 8;; if(dz < -dw) code |= 16;; if(dz > dw) code |= 32;; *ret = code;; }. ===-------------------------------------------------------------------------===. %struct.B = type { i8, [3 x i8] }. define void @bar(%struct.B* ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt:4330,simpl,simpler,4330,interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,1,['simpl'],['simpler']
Usability,"mpile; cmake -Dr=ON ..; make -j 5; ~~~. ## How does it work ?; There is a class called TRInterface which is located at the header TRInterface.h and uses the namespace `ROOT::R`, it is in charge; of making calls to R to give and obtain data. This class has a series of overcharged operators which ease the passing and obtaining of data; and code from R to C++ and vice versa. To create an object of this class the user must use the static methods `ROOT::R::TRInterface::Instance`; and `ROOT::R::TRInterface::InstancePtr` which return a reference object and a pointer object respectively. ~~~{.cxx}; #include<TRInterface.h>; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; ~~~. ## Running R code and passing/getting variables.; We have different ways to run R code and pass/obtain data to/from R environment: using the methods Execute(code) and; Eval(code). ~~~{.cxx}; #include<TRInterface.h>. //creating an instance; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; //executing simple r commands with the operator <<; r<<""print('hello ROOTR')"";; r<<""vec=c(1,2,3)""<<""print(vec)"";. //executing R's code using the method Execute that doesn't return anything; r.Execute(""print('hello ROOTR')"");. //We execute the code using the method Eval which returns an instance of TRObjectProxy; //which can be converted to a ROOTR supported classes; std::vector<Int_t> v=r.Eval(""c(1,2,3)"");; std::cout<<v[0]<<"" ""<<v[1]<<"" ""<<v[2]<<std::endl;. std::vector<Double_t> vd(3);. //obtaining variables from R environment using the operators [] and >>; r[""seq(0,1,0.5)""]>>vd;; std::cout<<vd[0]<<"" ""<<vd[1]<<"" ""<<vd[2]<<std::endl;. std::vector<Int_t> v1(3);; v1[0]=0;; v1[1]=1;; v1[2]=2;. r[""v1""]<<v1;; r<<""print(v1)"";. TMatrixD m(2,2);. //Creating a matrix inside r environment and converting it into a TMatrixD; r<<""mat<-matrix(c(0.1,0.2,0.3,0.4),nrow=2)"";; r[""mat""]>>m;; m.Print();; ~~~; So, working with ROOTR is like working with flows of data to pass, obtain and process data. ## Passing functions f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:4042,simpl,simple,4042,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,1,['simpl'],['simple']
Usability,"mpiler IR, as an on-disk bitcode representation; (suitable for fast loading by a Just-In-Time compiler), and as a human; readable assembly language representation. This allows LLVM to provide a; powerful intermediate representation for efficient compiler; transformations and analysis, while providing a natural means to debug; and visualize the transformations. The three different forms of LLVM are; all equivalent. This document describes the human readable; representation and notation. The LLVM representation aims to be light-weight and low-level while; being expressive, typed, and extensible at the same time. It aims to be; a ""universal IR"" of sorts, by being at a low enough level that; high-level ideas may be cleanly mapped to it (similar to how; microprocessors are ""universal IR's"", allowing many source languages to; be mapped to them). By providing type information, LLVM can be used as; the target of optimizations: for example, through pointer analysis, it; can be proven that a C automatic variable is never accessed outside of; the current function, allowing it to be promoted to a simple SSA value; instead of a memory location. .. _wellformed:. Well-Formedness; ---------------. It is important to note that this document describes 'well formed' LLVM; assembly language. There is a difference between what the parser accepts; and what is considered 'well formed'. For example, the following; instruction is syntactically okay, but not well formed:. .. code-block:: llvm. %x = add i32 1, %x. because the definition of ``%x`` does not dominate all of its uses. The; LLVM infrastructure provides a verification pass that may be used to; verify that an LLVM module is well formed. This pass is automatically; run by the parser after parsing input assembly and by the optimizer; before it outputs bitcode. The violations pointed out by the verifier; pass indicate bugs in transformation passes or input to the parser. .. _identifiers:. Identifiers; ===========. LLVM identifiers come",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:1744,simpl,simple,1744,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"mplate definition and; instantiation. Matcher<StringLiteral>hasSizeunsigned N; Matches nodes that have the specified size. Given; int a[42];; int b[2 * 21];; int c[41], d[43];; char *s = ""abcd"";; wchar_t *ws = L""abcd"";; char *w = ""a"";; constantArrayType(hasSize(42)); matches ""int a[42]"" and ""int b[2 * 21]""; stringLiteral(hasSize(4)); matches ""abcd"", L""abcd"". Matcher<TagDecl>isClass; Matches TagDecl object that are spelled with ""class."". Example matches C, but not S, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<TagDecl>isEnum; Matches TagDecl object that are spelled with ""enum."". Example matches E, but not C, S or U.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isStruct; Matches TagDecl object that are spelled with ""struct."". Example matches S, but not C, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isUnion; Matches TagDecl object that are spelled with ""union."". Example matches U, but not C, S or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TemplateArgument>equalsIntegralValuestd::string Value; Matches a TemplateArgument of integral type with a given value. Note that 'Value' is a string as the template argument's value is; an arbitrary precision integer. 'Value' must be euqal to the canonical; representation of that integral value in base 10. Given; template<int T> struct C {};; C<42> c;; classTemplateSpecializationDecl(; hasAnyTemplateArgument(equalsIntegralValu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:118019,Usab,Usable,118019,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"mplate parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defining declarations; Unknown. 1029; C++11; Type of a destructor call; Unknown. 1030; C++11; Evaluation order in initializer-lists used in aggregate initialization; Unknown. 1031; C++11; Optional elements in attributes; Unknown. 1032; C++11; Em",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:67134,simpl,simple-declaration,67134,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-declaration']
Usability,"mple:; ``""%plural{%100=0:even hundred|%100=[1,50]:lower half|:everything else}1""``. The parser is very unforgiving. A syntax error, even whitespace, will abort,; as will a failure to match the argument against any expression. **""ordinal"" format**. Example:; ``""ambiguity in %ordinal0 argument""``; Class:; Integers; Description:; This is a formatter which represents the argument number as an ordinal: the; value ``1`` becomes ``1st``, ``3`` becomes ``3rd``, and so on. Values less; than ``1`` are not supported. This formatter is currently hard-coded to use; English ordinals. **""objcclass"" format**. Example:; ``""method %objcclass0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C class method selector. As such, it prints the selector; with a leading ""``+``"". **""objcinstance"" format**. Example:; ``""method %objcinstance0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C instance method selector. As such, it prints the selector; with a leading ""``-``"". **""q"" format**. Example:; ``""candidate found by name lookup is %q0""``; Class:; ``NamedDecl *``; Description:; This formatter indicates that the fully-qualified name of the declaration; should be printed, e.g., ""``std::vector``"" rather than ""``vector``"". **""diff"" format**. Example:; ``""no known conversion %diff{from $ to $|from argument type to parameter type}1,2""``; Class:; ``QualType``; Description:; This formatter takes two ``QualType``\ s and attempts to print a template; difference between the two. If tree printing is off, the text inside the; braces before the pipe is printed, with the formatted text replacing the $.; If tree printing is on, the text after the pipe is printed and a type tree is; printed after the diagnostic message. **""sub"" format**. Example:; Given the following record definition of type ``TextSubstit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:14127,simpl,simple,14127,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"mplemented as Passes that traverse some; portion of a program to either collect information or transform the program.; The table below divides the passes that LLVM provides into three categories.; Analysis passes compute information that other passes can use or for debugging; or program visualization purposes. Transform passes can use (or invalidate); the analysis passes. Transform passes all mutate the program in some way.; Utility passes provides some utility but don't otherwise fit categorization.; For example passes to extract functions to bitcode or write a module to bitcode; are neither analysis nor transform passes. The table of contents above; provides a quick summary of each pass and links to the more complete pass; description later in the document. Analysis Passes; ===============. This section describes the LLVM Analysis Passes. ``aa-eval``: Exhaustive Alias Analysis Precision Evaluator; ----------------------------------------------------------. This is a simple N^2 alias analysis accuracy evaluator. Basically, for each; function in the program, it simply queries to see how the alias analysis; implementation answers alias queries between each pair of pointers in the; function. This is inspired and adapted from code by: Naveen Neelakantam, Francesco; Spadini, and Wojciech Stryjewski. ``basic-aa``: Basic Alias Analysis (stateless AA impl); ------------------------------------------------------. A basic alias analysis pass that implements identities (two different globals; cannot alias, etc), but does no stateful analysis. ``basiccg``: Basic CallGraph Construction; -----------------------------------------. Yet to be written. .. _passes-da:. ``da``: Dependence Analysis; ---------------------------. Dependence analysis framework, which is used to detect dependences in memory; accesses. ``domfrontier``: Dominance Frontier Construction; ------------------------------------------------. This pass is a simple dominator construction algorithm for finding forward",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:1263,simpl,simple,1263,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"mples, is available at *User Guide for AMDGPU Backend* section; :ref:`amdgpu-dwarf-debug-information`. .. note::. Change examples to use ``DW_OP_LLVM_offset`` instead of ``DW_OP_add`` when; acting on a location description. Need to provide examples of new features. .. _amdgpu-dwarf-references:. D. References; =============. .. _amdgpu-dwarf-AMD:. 1. [AMD] `Advanced Micro Devices <https://www.amd.com/>`__. .. _amdgpu-dwarf-AMD-ROCgdb:. 2. [AMD-ROCgdb] `AMD ROCm Debugger (ROCgdb) <https://github.com/ROCm-Developer-Tools/ROCgdb>`__. .. _amdgpu-dwarf-AMD-ROCm:. 3. [AMD-ROCm] `AMD ROCm Platform <https://rocm-documentation.readthedocs.io>`__. .. _amdgpu-dwarf-AMDGPU-DWARF-LOC:. 4. [AMDGPU-DWARF-LOC] `Allow Location Descriptions on the DWARF Expression Stack <https://llvm.org/docs/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack.html>`__. .. _amdgpu-dwarf-AMDGPU-LLVM:. 5. [AMDGPU-LLVM] `User Guide for AMDGPU LLVM Backend <https://llvm.org/docs/AMDGPUUsage.html>`__. .. _amdgpu-dwarf-CUDA:. 6. [CUDA] `Nvidia CUDA Language <https://docs.nvidia.com/cuda/cuda-c-programming-guide/>`__. .. _amdgpu-dwarf-DWARF:. 7. [DWARF] `DWARF Debugging Information Format <http://dwarfstd.org/>`__. .. _amdgpu-dwarf-ELF:. 8. [ELF] `Executable and Linkable Format (ELF) <http://www.sco.com/developers/gabi/>`__. .. _amdgpu-dwarf-GCC:. 9. [GCC] `GCC: The GNU Compiler Collection <https://www.gnu.org/software/gcc/>`__. .. _amdgpu-dwarf-GDB:. 10. [GDB] `GDB: The GNU Project Debugger <https://www.gnu.org/software/gdb/>`__. .. _amdgpu-dwarf-HIP:. 11. [HIP] `HIP Programming Guide <https://rocm-documentation.readthedocs.io/en/latest/Programming_Guides/Programming-Guides.html#hip-programing-guide>`__. .. _amdgpu-dwarf-HSA:. 12. [HSA] `Heterogeneous System Architecture (HSA) Foundation <http://www.hsafoundation.com/>`__. .. _amdgpu-dwarf-LLVM:. 13. [LLVM] `The LLVM Compiler Infrastructure <https://llvm.org/>`__. .. _amd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:235074,Guid,Guide,235074,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['Guid'],['Guide']
Usability,"mpt or; (preferably) humor. It be a curious world and it always beed."". > Basically, my argument for this type construction system is that it is; > VERY simple to use and understand (although it IS different than C, it is; > very simple and straightforward, which C is NOT). In fact, I would assert; > that most programmers TODAY do not understand pointers to member; > functions, and have to look up an example when they have to write them. Again, I don't disagree with this at all. But to some extent this; particular problem is inherently difficult. Your syntax for the above; example may be easier for you to read because this is the way you have been; thinking about it. Honestly, I don't find it much easier than the C syntax.; In either case, I would have to look up an example to write pointers to; member functions. But pointers to member functions are nowhere near as common as arrays. And; the old array syntax:; type [ int, int, ...]; is just much more familiar and clear to people than anything new you; introduce, no matter how logical it is. Introducing a new syntax that may; make function pointers easier but makes arrays much more difficult seems; very risky to me. > In my opinion, it is critically important to have clear and concise type; > specifications, because types are going to be all over the programs. I absolutely agree. But the question is, what is more clear and concise?; The syntax programmers are used to out of years of experience or a new; syntax that they have never seen that has a more logical structure. I think; the answer is the former. Sometimes, you have to give up a better idea; because you can't overcome sociological barriers to it. Qwerty keyboards; and Windows are two classic examples of bad technology that are difficult to; root out. P.S. Also, while I agree that most your syntax is more logical, there is; one part that isn't:. Arrays (without and with size):; type ::= '[' type ']' | '[' INT ',' type ']'. The arrays with size lists the dimens",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt:1801,clear,clear,1801,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,1,['clear'],['clear']
Usability,"ms byte swapping not on the entire 64 bits, but on the individual items within the vector. This means that the register content is the same as it would have been on a little endian system. It may seem that ``LD1`` should suffice to perform vector loads on a big endian machine. However there are pros and cons to the two approaches that make it less than simple which register format to pick. There are two options:. 1. The content of a vector register is the same *as if* it had been loaded with an ``LDR`` instruction.; 2. The content of a vector register is the same *as if* it had been loaded with an ``LD1`` instruction. Because ``LD1 == LDR + REV`` and similarly ``LDR == LD1 + REV`` (on a big endian system), we can simulate either type of load with the other type of load plus a ``REV`` instruction. So we're not deciding which instructions to use, but which format to use (which will then influence which instruction is best to use). .. The 'clearer' container is required to make the following section header come after the floated; images above.; .. container:: clearer. Note that throughout this section we only mention loads. Stores have exactly the same problems as their associated loads, so have been skipped for brevity. Considerations; ==============. LLVM IR Lane ordering; ---------------------. LLVM IR has first class vector types. In LLVM IR, the zero'th element of a vector resides at the lowest memory address. The optimizer relies on this property in certain areas, for example when concatenating vectors together. The intention is for arrays and vectors to have identical memory layouts - ``[4 x i8]`` and ``<4 x i8>`` should be represented the same in memory. Without this property there would be many special cases that the optimizer would have to cleverly handle. Use of ``LDR`` would break this lane ordering property. This doesn't preclude the use of ``LDR``, but we would have to do one of two things:. 1. Insert a ``REV`` instruction to reverse the lane order after e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst:4280,clear,clearer,4280,interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,1,['clear'],['clearer']
Usability,"ms. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the |; | | `rootcling` utility to generate the Cling interface |; | | `EventCint.cxx` |; +-------------------+--------------------------------------------------------+; | `Event.cxx` | Implementation for classes Event and Track |; +-------------------+--------------------------------------------------------+; | `minexam.cxx` | Simple test program for data fitting |; +-------------------+--------------------------------------------------------+; | `tcollex.cxx` | Example usage of the ROOT collection classes |; +-------------------+--------------------------------------------------------+; | `tcollbm.cxx` | Benchmarks of ROOT collection classes |; +-------------------+--------------------------------------------------------+; | ctorture.cxx | Test program for the class **`TComplex`** |; +-------------------+--------------------------------------------------------+; | `tstring.cxx` | Example usage of the ROOT string class |; +-------------------+--------------------------------------------------------+; | `vmatrix.cxx` | Verification program for the **`TMatrix`** class |; +-------------------+--------------------------------------------------------+; | `vvector.cxx` | Verification program for the **`TVector `**class |; +-------------------+--------------------------------------------------------+; | `vlazy.cxx` | Verification program for lazy matrices |; +----------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:2816,Simpl,Simple,2816,documentation/users-guide/TutorialsandTests.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md,1,['Simpl'],['Simple']
Usability,"mt_misc/register; % chmod u+x hello.bc (if needed); % ./hello.bc. This allows you to execute LLVM bitcode files directly. On Debian, you can also; use this command instead of the 'echo' command above:. .. code-block:: console. % sudo update-binfmts --install llvm /path/to/lli --magic 'BC'. .. _Program Layout:; .. _general layout:. Directory Layout; ================. One useful source of information about the LLVM source base is the LLVM `doxygen; <http://www.doxygen.org/>`_ documentation available at; `<https://llvm.org/doxygen/>`_. The following is a brief introduction to code; layout:. ``llvm/cmake``; --------------; Generates system build files. ``llvm/cmake/modules``; Build configuration for llvm user defined options. Checks compiler version and; linker flags. ``llvm/cmake/platforms``; Toolchain configuration for Android NDK, iOS systems and non-Windows hosts to; target MSVC. ``llvm/examples``; -----------------. - Some simple examples showing how to use LLVM as a compiler for a custom; language - including lowering, optimization, and code generation. - Kaleidoscope Tutorial: Kaleidoscope language tutorial run through the; implementation of a nice little compiler for a non-trivial language; including a hand-written lexer, parser, AST, as well as code generation; support using LLVM- both static (ahead of time) and various approaches to; Just In Time (JIT) compilation.; `Kaleidoscope Tutorial for complete beginner; <https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html>`_. - BuildingAJIT: Examples of the `BuildingAJIT tutorial; <https://llvm.org/docs/tutorial/BuildingAJIT1.html>`_ that shows how LLVM’s; ORC JIT APIs interact with other parts of LLVM. It also, teaches how to; recombine them to build a custom JIT that is suited to your use-case. ``llvm/include``; ----------------. Public header files exported from the LLVM library. The three main subdirectories:. ``llvm/include/llvm``. All LLVM-specific header files, and subdirectories for different porti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:34461,simpl,simple,34461,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['simpl'],['simple']
Usability,"much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after code generation. Finally,; clang provides support for building and retaining fully-fledged ASTs, and even; supports writing them out to disk.; Designing the libraries with clean and simple APIs allows these high-level; policy decisions to be determined in the client, instead of forcing ""one true; way"" in the implementation of any of these libraries. Getting this right is; hard, and we don't always get it right the first time, but we fix any problems; when we realize we made a mistake. Integration with IDEs. We believe that Integrated Development Environments (IDE's) are a great way; to pull together various pieces of the development puzzle, and aim to make clang; work well in such an environment. The chief advantage of an IDE is that they; typically have visibility across your entire project and are long-lived; processes, whereas stand-alone compiler tools are typically invoked on each; individual file in the project, and thus have limited scope.; There are many implications of this difference, but a significant one has to; do with efficiency and caching: sharing an address space across different files; in a project, means that you can use intelligent caching and other techniques to; dramatically reduce analysis/compilation ti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:8810,simpl,simple,8810,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['simpl'],['simple']
Usability,"multilib variant; # to be a match.; Flags: [--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16]. # The second section of the file is a list of regular expressions that are; # used to map from flags generated from command line options to custom flags.; # This is optional.; # Each regular expression must match a whole flag string.; # Flags in the ""Flags"" list will be added if any flag generated from command; # line options matches the regular expression.; Mappings:. # Set a ""--target=thumbv7m-none-eabi"" flag if the regular expression matches; # any of the flags generated from the command line options.; # Match is a POSIX extended regular expression string.; - Match: --target=thumbv([7-9]|[1-9][0-9]+).*; # Flags is a list of one or more strings.; Flags: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:9417,usab,usable,9417,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['usab'],['usable']
Usability,"n Clang. This documents describes the LibFormat interface and design as well; as some basic style discussions. If you just want to use `clang-format` as a tool or integrated into an editor,; checkout :doc:`ClangFormat`. Design; ------. FIXME: Write up design. Interface; ---------. The core routine of LibFormat is ``reformat()``:. .. code-block:: c++. tooling::Replacements reformat(const FormatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:1115,guid,guides,1115,interpreter/llvm-project/clang/docs/LibFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst,1,['guid'],['guides']
Usability,"n Coordinate Systems. There are a few utility functions in **`TPad`** to convert from one; system of coordinates to another. In the following table, a point is; defined by `(px,py)` in pixel coordinates, `(ux,uy)` in user; coordinates, `(ndcx,ndcy)` in normalized coordinates, (`apx`, `apy`) are; in absolute pixel coordinates. +-----------------------+----------------------------------+--------------------+; | Conversion | TPad's Methods | Returns |; +-----------------------+----------------------------------+--------------------+; | NDC to Pixel | `UtoPixel(ndcx)` | Int\_t |; | | | |; | | `VtoPixel(ndcy)` | Int\_t |; +-----------------------+----------------------------------+--------------------+; | Pixel to User | `PixeltoX(px)` | Double\_t |; | | | |; | | `PixeltoY(py)` | Double\_t |; | | | |; | | `PixeltoXY(px,py,&ux,&uy)` | Double\_t ux,uy |; +-----------------------+----------------------------------+--------------------+; | User to Pixel | `XtoPixel(ux)` | Int\_t |; | | | |; | | `YtoPixel(uy)` | Int\_t |; | | | |; | | `XYtoPixel(ux,uy,&px,&py)` | Int\_t px,py |; +-----------------------+----------------------------------+--------------------+; | User to absolute | `XtoAbsPixel(ux)` | Int\_t |; | pixel | | |; | | `YtoAbsPixel(uy)` | Int\_t |; | | | |; | | `XYtoAbsPixel(ux,uy,&apx,&apy)` | Int\_t apx,apy |; +-----------------------+----------------------------------+--------------------+; | Absolute pixel to | `AbsPixeltoX(apx)` | Double\_t |; | user | | |; | | `AbsPixeltoY(apy)` | Double\_t |; | | | |; | | `AbsPixeltoXY(apx,apy,&ux,&uy)` | Double\_t ux,uy |; +-----------------------+----------------------------------+--------------------+. Note: all the pixel conversion functions along the Y axis consider that; `py=0` is at the top of the pad except `PixeltoY()` which assume that; the position `py=0` is at the bottom of the pad. To make `PixeltoY()`; converting the same way as the other conversion functions, it should be; used the following way (`p` is a point",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:22457,ux,ux,22457,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,8,['ux'],['ux']
Usability,"n L comprised of one incomplete; composite location description SL is pushed on the stack. An incomplete composite location storage LS is created with a single; part P. P specifies the location description PL and has a bit size of S; scaled by 8 (the byte size). SL specifies LS with a bit offset of 0. * Otherwise, the DWARF expression is ill-formed. *Many compilers store a single variable in sets of registers or store a; variable partially in memory and partially in registers.* ``DW_OP_piece``; *provides a way of describing where a part of a variable is located.*. *If a non-0 byte displacement is required, the* ``DW_OP_LLVM_offset``; *operation can be used to update the location description before using it as; the part location description of a* ``DW_OP_piece`` *operation.*. *The evaluation rules for the* ``DW_OP_piece`` *operation allow it to be; compatible with the DWARF Version 5 definition.*. .. note::. Since these extensions allow location descriptions to be entries on the; stack, a simpler operation to create composite location descriptions could; be defined. For example, just one operation that specifies how many parts,; and pops pairs of stack entries for the part size and location; description. Not only would this be a simpler operation and avoid the; complexities of incomplete composite location descriptions, but it may; also have a smaller encoding in practice. However, the desire for; compatibility with DWARF Version 5 is likely a stronger consideration. 2. ``DW_OP_bit_piece``. ``DW_OP_bit_piece`` has two operands. The first is an unsigned LEB128; integer that represents the part bit size S. The second is an unsigned; LEB128 integer that represents a bit displacement B. The action is the same as for ``DW_OP_piece``, except that any part created; has the bit size S, and the location description PL of any created part is; updated as if the ``DW_OP_constu B; DW_OP_LLVM_bit_offset`` operations were; applied. ``DW_OP_bit_piece`` *is used instead of* ``DW_OP_pi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:135947,simpl,simpler,135947,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simpler']
Usability,"n Musinsky.; - The crosshair type cursor type did not work on MacOS Catalina. This has been fixed by; Timur Pocheptsoff.; - Take into account the Z errors when defining the frame to paint a TGraph2DErrors.; - Implement the of ""F"" in `TPad::RedrawAxis` to allow the plot's frame redrawing when; erased.; - Implement `TCanvas::SetRealAspectRatio` to resize a canvas so that the plot inside is; shown in real aspect.; - New graphics style ""BELLE2"" from Martin Ritter. ## 3D Graphics Libraries. ## Geometry Libraries. ### Geometry drawing in web browser. When ROOT compiled with -Droot7=ON flag, one can enable geometry drawing in web browser.; Just apply --web option when starting root like: `root --web tutorials/geom/rootgeom.C`; Not all features of TGeoPainter are supported - only plain drawing of selected TGeoVolume. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. By default, ROOT now falls back to the built-in version of xrootd if it can't find it in the system.; This means that passing `-Dbuiltin_xrootd=ON` is not necessary anymore to build ROOT with xrootd support.; Note that built-in xrootd requires a working network connection. ### Experimental address sanitizer build configuration; Added a build flag `asan` that switches on address sanitizer. It's experimental, so expect problems. For example, when building with gcc,; manipulations in global variables in llvm will abort the build. Such checks can be disabled using environment variables. Check the address; sanitizer documentation or the link below for details. In clang, which allows to blacklist functions, the build will continue. See [core/sanitizer](https://github.com/root-project/root/tree/master/core/sanitizer) for information. ### Optimization of ROOT header files. Many (but intentionally not all) unused includes were re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:7283,Guid,Guide,7283,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['Guid'],['Guide']
Usability,"n and self-servicing.** A user can restart their; personal PROOF cluster in case of troubles without waiting for a; system administrator's intervention. - **Efficient multiuser scheduling.** PROOF on Demand makes PROOF run on; top of an existing resource management system, moving the problem of; scheduling many concurrent users outside of PROOF. This guide particularly refers to the setup of a static PROOF cluster; running on physical hosts: the recommended setup is in practice the same; as the ready-to-go Virtual Analysis Facility. If you want to use PROOF; on the clouds there is no configuration to go through. Setup a resource management system; ----------------------------------. Although PROOF on Demand can run on a cluster of nodes without using a; resource management system (using `pod-ssh`), it is recommended to setup a; dedicated one to benefit from the scheduling in a multiuser environment, or a; dedicated queue on an existing one. As there's a variety of resource management systems, this guide does not cover; their setup. The RMS preconfigured for the Virtual Analysis Facility is; [HTCondor](http://research.cs.wisc.edu/htcondor/), which we recommend primarily; because it has dynamic addition of workers built in. Configuration steps for all nodes; ---------------------------------. ### Setup CernVM-FS. [CernVM-FS](http://cernvm.cern.ch/portal/filesystem) should be installed; on all machines as the preferred method for software distribution. > Configuration instructions for the latest CernVM-FS can be found; > [here](http://cernvm.cern.ch/portal/filesystem/techinformation). A brief step-by-step procedure to install CernVM-FS is hereby described. - Download and install the latest stable version from; [here](http://cernvm.cern.ch/portal/filesystem): pick one which is; appropriate to your operating system. You need the `cvmfs` package,; you *don't* need the `cvmfs-devel` or `cvmfs-server` ones. - As root user, run:. # cvmfs_config setup. - Start the `autofs` ser",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:1504,guid,guide,1504,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['guid'],['guide']
Usability,"n be compared for pointer equivalence to find out if they are the same symbol.; Note that pointer inequality does not guarantee the labels will end up at; different addresses though. It's perfectly legal to output something like this; to the .s file:. ::. foo:; bar:; .byte 4. In this case, both the foo and bar symbols will have the same address. The ``MCSection`` class; -----------------------. The ``MCSection`` class represents an object-file specific section. It is; subclassed by object file specific implementations (e.g. ``MCSectionMachO``,; ``MCSectionCOFF``, ``MCSectionELF``) and these are created and uniqued by; MCContext. The MCStreamer has a notion of the current section, which can be; changed with the SwitchToSection method (which corresponds to a "".section""; directive in a .s file). .. _MCInst:. The ``MCInst`` class; --------------------. The ``MCInst`` class is a target-independent representation of an instruction.; It is a simple class (much more so than `MachineInstr`_) that holds a; target-specific opcode and a vector of MCOperands. MCOperand, in turn, is a; simple discriminated union of three cases: 1) a simple immediate, 2) a target; register ID, 3) a symbolic expression (e.g. ""``Lfoo-Lbar+42``"") as an MCExpr. MCInst is the common currency used to represent machine instructions at the MC; layer. It is the type used by the instruction encoder, the instruction printer,; and the type generated by the assembly parser and disassembler. .. _ObjectFormats:. Object File Format; ------------------. The MC layer's object writers support a variety of object formats. Because of; target-specific aspects of object formats each target only supports a subset of; the formats supported by the MC layer. Most targets support emitting ELF; objects. Other vendor-specific objects are generally supported only on targets; that are supported by that vendor (i.e. MachO is only supported on targets; supported by Darwin, and XCOFF is only supported on targets that support AIX).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:30593,simpl,simple,30593,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"n by the first static rule about cycles. A first formal argument why we have to do this is that the dynamic rule for; deciding whether two threads execute converged dynamic instances of; ``@convergent.op`` leads to a logical contradiction in this code.; Assume two threads execute converged dynamic instances of the anchor; followed by two iterations of the loop. Thread 1 executes dynamic instances; I1 and I2 of ``@convergent.op``, thread 2 executes dynamic instances J1 and J2.; Using all the rules, we can deduce:. 1. ``I1 != I2`` and ``J1 != J2`` by the basic rules of dynamic instances. 2. ``I1 == J1`` by the first dynamic rule about controlled convergent; operations: both threads execute the same static instruction while using; a convergence token value produced by converged dynamic instances of an; instruction (the anchor). 3. ``I1 == J2`` by the same argument. Also, ``I2 == J1`` and ``I2 == J2``. The fact that one may be *intuitively* tempted to think of ``I1`` and ``J2``; as being executed in different loop iterations is completely irrelevant for; the *formal* argument. There is no mechanism in LLVM IR semantics for; forming associations between loop iterations in different threads, *except*; for the rules defined in this document -- and the rules in this document; require a loop heart intrinsic for talking about loop iterations. 4. By transitivity, we have ``I1 == I2`` and ``J1 == J2``. That is a; contradiction. This problem goes away by inserting a loop heart intrinsic as follows, which; establishes a relationship between loop iterations across threads. .. code-block:: llvm. %anchor = call token @llvm.experimental.convergence.anchor(); for (;;) {; %loop = call token @llvm.experimental.convergence.loop() [ ""convergencectrl""(token %anchor) ]; ...; call void @convergent.op() [ ""convergencectrl""(token %loop) ]; ...; }. In the same scenario of two threads executing converged dynamic instances of the; anchor and then two iterations of the loop, the dynamic rule about",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:40475,intuit,intuitively,40475,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['intuit'],['intuitively']
Usability,"n bytes share a 4-byte origin trace ID. A; 4-byte origin trace ID contains a 4-bit depth and a 28-bit hash ID of a chain. A chain ID is calculated as a hash from a chain structure. A chain structure; contains a stack ID and the previous chain ID. The chain head has a zero; previous chain ID. A stack ID is a hash from a stack trace. The 4-bit depth; limits the maximal length of a path. The environment variable ``origin_history_size``; can set the depth limit. Non-positive values mean unlimited. Its default value; is 16. When reaching the limit, origin tracking ignores following propagation; chains. The first chain of a trace starts by `dfsan_set_label` with non-zero labels. A; new chain is appended at the end of a trace at stores or memory transfers when; ``-dfsan-track-origins`` is 1. Memory transfers include LLVM memory transfer; instructions, glibc memcpy and memmove. When ``-dfsan-track-origins`` is 2, a; new chain is also appended at loads. Other instructions do not create new chains, but simply propagate origin trace; IDs. If an instruction has more than one operands with non-zero labels, the origin; treace ID of the last operand with non-zero label is propagated to the result of; the instruction. Memory layout and label management; ----------------------------------. The following is the memory layout for Linux/x86\_64:. +---------------+---------------+--------------------+; | Start | End | Use |; +===============+===============+====================+; | 0x700000000000|0x800000000000 | application 3 |; +---------------+---------------+--------------------+; | 0x610000000000|0x700000000000 | unused |; +---------------+---------------+--------------------+; | 0x600000000000|0x610000000000 | origin 1 |; +---------------+---------------+--------------------+; | 0x510000000000|0x600000000000 | application 2 |; +---------------+---------------+--------------------+; | 0x500000000000|0x510000000000 | shadow 1 |; +---------------+---------------+--------------------+;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:7453,simpl,simply,7453,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,1,['simpl'],['simply']
Usability,"n control back to the caller if it is not an initial; invocation of the coroutine. The `loop` blocks represents the body of the coroutine. The `coro.suspend`_; intrinsic in combination with the following switch indicates what happens to; control flow when a coroutine is suspended (default case), resumed (case 0) or; destroyed (case 1). Coroutine Transformation; ------------------------. One of the steps of coroutine lowering is building the coroutine frame. The; def-use chains are analyzed to determine which objects need be kept alive across; suspend points. In the coroutine shown in the previous section, use of virtual register; `%inc` is separated from the definition by a suspend point, therefore, it; cannot reside on the stack frame since the latter goes away once the coroutine; is suspended and control is returned back to the caller. An i32 slot is; allocated in the coroutine frame and `%inc` is spilled and reloaded from that; slot as needed. We also store addresses of the resume and destroy functions so that the; `coro.resume` and `coro.destroy` intrinsics can resume and destroy the coroutine; when its identity cannot be determined statically at compile time. For our; example, the coroutine frame will be:. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32 }. After resume and destroy parts are outlined, function `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:14377,resume,resume,14377,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"n either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A single Variable. This is the signature of `TTree::Branch` to create a branch with a list; of variables:. ``` {.cpp}; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); ```. The first parameter is the branch name. The second parameter is the; address from which to read the value. The third parameter is the leaf; list with the name and type of each leaf. In this example, each branch; has only one leaf. In the box below, the branch is named `px` and has; one floating",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:35408,simpl,simple,35408,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,2,['simpl'],['simple']
Usability,"n one TFile and can be replayed again anytime.; Modifications in TRootCanvas menu:; Renamed 'Inspect' menu title to 'Tools'; Added 'Event Recorder' menu entry. Here is a screenshot of TGRecorder (GUI interface of the recorder):. New Class: TGPack; New Container class for vertical and horizontal grouping of frames.; It enforces a predictable resizing behaviour on children.; For an example of how to use it, see tutorials/eve/pack.C. TRootBrowser. Make the default url for the HTML plugin of TRootBrowser configurable via rootrc. TGTab. Added a 'Close Tab' icon in TGTabElement, allowing to close a tab element, and emitting a CloseTab(Int_t id) signal. The icon is active only on the actually activated tab.; Implement CloseTab slot usage in TRootBrowser and in TGRootIDE. TGTextEditor. Allow to execute a macro without having to save it first. TGSplitFrame. Added a new signal method Docked(TGFrame*) to notify when a embedded frame has been docked.; Added a new signal method Undocked(TGFrame*) to notify when a embedded frame has been undocked.; Added a new getter method GetUndocked() returning a pointer on undocked frame, if any. TGToolTip. Added new constructor with global x, y position.; If neither fWindow nor fPad are set use global fX, fY that was passed from outside. TGSplitter. Added option to handle frame resizing externally. TGView. Added a protection against possible negative scroll values. TGTextView. Fix bottom line not being properly updated while scrolling.; Solve a problem with vertical slider (avoid negative value when scrolling). TGTextEdit. Fix blinking cursor on some platforms/compilers. TGTextEntry. Added optional parameter 'Bool_t emit' to TGTextEntry::SetText(const char* text, Bool_t emit = kTRUE);; Made the same extension in sub-class TGNumberEntryField. TGCompositeFrame. Added new method virtual TGFrameElement* FindFrameElement(TGFrame *f) const; and use it in several TGCompositeFrame methods to simplify the code. GUIHTML; TGHtml. Implemented HTML <selec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html:1288,Undo,Undocked,1288,gui/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html,2,"['Undo', 'undo']","['Undocked', 'undocked']"
Usability,"n one instruction to read the series of bytes. Note that in cases where none of the atomic intrinsics are used, this; model places only one restriction on IR transformations on top of what; is required for single-threaded execution: introducing a store to a byte; which might not otherwise be stored is not allowed in general.; (Specifically, in the case where another thread might write to and read; from an address, introducing a store can change a load that may see; exactly one write into a load that may see multiple writes.). .. _ordering:. Atomic Memory Ordering Constraints; ----------------------------------. Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`,; :ref:`atomicrmw <i_atomicrmw>`, :ref:`fence <i_fence>`,; :ref:`atomic load <i_load>`, and :ref:`atomic store <i_store>`) take; ordering parameters that determine which other atomic instructions on; the same address they *synchronize with*. These semantics implement; the Java or C++ memory models; if these descriptions aren't precise; enough, check those specs (see spec references in the; :doc:`atomics guide <Atomics>`). :ref:`fence <i_fence>` instructions; treat these orderings somewhat differently since they don't take an; address. See that instruction's documentation for details. For a simpler introduction to the ordering constraints, see the; :doc:`Atomics`. ``unordered``; The set of values that can be read is governed by the happens-before; partial order. A value cannot be read unless some operation wrote; it. This is intended to provide a guarantee strong enough to model; Java's non-volatile shared variables. This ordering cannot be; specified for read-modify-write operations; it is not strong enough; to make them atomic in any interesting way.; ``monotonic``; In addition to the guarantees of ``unordered``, there is a single; total order for modifications by ``monotonic`` operations on each; address. All modification orders must be compatible with the; happens-before order. There is no guarantee that the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:152735,guid,guide,152735,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['guid'],['guide']
Usability,"n performs alias processing and then does actual; matching. Alias processing is the phase that canonicalizes different lexical forms of the; same instructions down to one representation. There are several different kinds; of alias that are possible to implement and they are listed below in the order; that they are processed (which is in order from simplest/weakest to most; complex/powerful). Generally you want to use the first alias mechanism that; meets the needs of your instruction, because it will allow a more concise; description. Mnemonic Aliases; ^^^^^^^^^^^^^^^^. The first phase of alias processing is simple instruction mnemonic remapping for; classes of instructions which are allowed with two different mnemonics. This; phase is a simple and unconditionally remapping from one input mnemonic to one; output mnemonic. It isn't possible for this form of alias to look at the; operands at all, so the remapping must apply for all forms of a given mnemonic.; Mnemonic aliases are defined simply, for example X86 has:. ::. def : MnemonicAlias<""cbw"", ""cbtw"">;; def : MnemonicAlias<""smovq"", ""movsq"">;; def : MnemonicAlias<""fldcww"", ""fldcw"">;; def : MnemonicAlias<""fucompi"", ""fucomip"">;; def : MnemonicAlias<""ud2a"", ""ud2"">;. ... and many others. With a MnemonicAlias definition, the mnemonic is remapped; simply and directly. Though MnemonicAlias's can't look at any aspect of the; instruction (such as the operands) they can depend on global modes (the same; ones supported by the matcher), through a Requires clause:. ::. def : MnemonicAlias<""pushf"", ""pushfq"">, Requires<[In64BitMode]>;; def : MnemonicAlias<""pushf"", ""pushfl"">, Requires<[In32BitMode]>;. In this example, the mnemonic gets mapped into a different one depending on; the current instruction set. Instruction Aliases; ^^^^^^^^^^^^^^^^^^^. The most general phase of alias processing occurs while matching is happening:; it provides new forms for the matcher to match along with a specific instruction; to generate. An instructi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:82574,simpl,simply,82574,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simply']
Usability,"n that may trigger resumption of a coroutine from the same or; a different thread possibly prior to `async_op` call returning control back; to the coroutine:. .. code-block:: llvm. %save1 = call token @llvm.coro.save(ptr %hdl); call void @async_op1(ptr %hdl); %suspend1 = call i1 @llvm.coro.suspend(token %save1, i1 false); switch i8 %suspend1, label %suspend [i8 0, label %resume1; i8 1, label %cleanup]. .. _coro.suspend.async:. 'llvm.coro.suspend.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare {ptr, ptr, ptr} @llvm.coro.suspend.async(; ptr <resume function>,; ptr <context projection function>,; ... <function to call>; ... <arguments to function>). Overview:; """""""""""""""""". The '``llvm.coro.suspend.async``' intrinsic marks the point where; execution of an async coroutine is suspended and control is passed to a callee. Arguments:; """""""""""""""""""". The first argument should be the result of the `llvm.coro.async.resume` intrinsic.; Lowering will replace this intrinsic with the resume function for this suspend; point. The second argument is the `context projection function`. It should describe; how-to restore the `async context` in the continuation function from the first; argument of the continuation function. Its type is `ptr (ptr)`. The third argument is the function that models transfer to the callee at the; suspend point. It should take 3 arguments. Lowering will `musttail` call this; function. The fourth to six argument are the arguments for the third argument. Semantics:; """""""""""""""""""". The result of the intrinsic are mapped to the arguments of the resume function.; Execution is suspended at this intrinsic and resumed when the resume function is; called. .. _coro.prepare.async:. 'llvm.coro.prepare.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.prepare.async(ptr <coroutine function>). Overview:; """""""""""""""""". The '``llvm.coro.prepare.async``' intrinsic is used to block inlining of the; async coroutine until after ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:53785,resume,resume,53785,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"n the longer TBits that are passed the length; of the shorter TBits are zero (i.e. the default value of each; bits is zero).; Properly handle scripts with line longer than 1024 characters.; Repair the handling of ACLiC options on the command line (for example a.C+g).; In TClass::BuildEmulatedRealData properly handle the case of TNamed member that are not base class.; On the command line:; ; Fix the tab-completion of filenames in the sub-directories.; Prevent the unadvertent replacement of an arrow with a dot when the left side is actually a pointer. More user friendly stacktrace in case of a crash, with hints where; the problem might be. On Linux and MacOS X these stacktraces are generated; by the script $ROOTSYS/etc/gdb-backtrace.sh. Using the Root.StackTraceMessage; resource one can customize the message printed by the script. The entire; script can be replaced using the Root.StacktraceScript resource.; Numerous minor bug fixes... New module editline ; The new module editline enhances the prompt, giving type and syntax feedback using e.g. colors.; Class names are highlighted blue when typed, indicating that it is known to ROOT.; Matching parenthesis pairs are highlighted green when typed, or when the cursor is moved to a bracket. This works for () {} and [] brackets.; Any mismatched brackets (those without a matching partner) will be highlighted red when typed or when the cursor is moved to the bracket.; Tab completion output is colored magenta to differentiate between tab completion output and user input.; All of the colors are configurable in the .rootrc file.; They can be specified as #rgb or #rrggbb or color names:; black, red, green, yellow, blue, magenta, cyan or white.; They can be followed by an optional bold (alias light) or underlined.; Rint.ReverseColor allows to quickly toggle between the default ""light on dark"" (yes) instead of ""dark on light"" (no), depending on the terminal background.; An example configuration would be:. Rint.TypeColor: blue; Rint.B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v526/index.html:1559,feedback,feedback,1559,core/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v526/index.html,1,['feedback'],['feedback']
Usability,"n the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:100043,clear,clearly,100043,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clearly']
Usability,"n this style is virtually possible but; highly not recommended. #### The Structure of Composite Shapes. A composite shape can always be looked as the result of a Boolean; operation between only two shape components. All information identifying; these two components as well as their positions with respect to the; frame of the composite is represented by an object called Boolean node.; A composite shape has a pointer to such a Boolean node. Since the shape; components may also be composites, they will also contain binary Boolean; nodes branching out other two shapes in the hierarchy. Any such branch; ends-up when the final leaves are no longer composite shapes, but basic; primitives. The figure shows the composite shapes structure. ![The composite shapes structure](pictures/080001CA.png). Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do; this only for understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will; ignore for the time being the positioning of components. The definition; of a composite shape takes an expression where the identifiers are shape; names. The expression is parsed and decomposed in 2 sub-expressions and; the top-level Boolean operator. 1. Union: `A+B+C`. Just to illustrate the Boolean expression parsing and the composite; shape structure, let's take a simple example. We will describe the union; of A, B and C. Both union operators are at the same level. Since:. `A+B+C = (A+B)+C = A+(B+C)`. The first` (+)` is taken as separator, hence the expression split in:; `A` and `(B+C)`. A Boolean node of type **`TGeoUnion`**`(""A"",""B+C"")` is; created. This tries to replace the 2 expressions by actual pointers to; corresponding shapes. The first expression (A) contains no operators; therefore is interpreted as representing a shape. The shape named ""A"" is; searched into the list of shapes handled by the man",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:44401,simpl,simple,44401,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"n with this surprisingly long; // comment, so it would be unclear without the braces whether the following; // statement is in the scope of the `if`.; // Because the condition is documented, we can't really hoist this; // comment that applies to the body above the `if`.; handleOtherDecl(D);; }. // Use braces on the outer `if` to avoid a potential dangling `else`; // situation.; if (isa<VarDecl>(D)) {; if (shouldProcessAttr(A)); handleAttr(A);; }. // Use braces for the `if` block to keep it uniform with the `else` block.; if (isa<FunctionDecl>(D)) {; handleFunctionDecl(D);; } else {; // In this `else` case, it is necessary that we explain the situation with; // this surprisingly long comment, so it would be unclear without the braces; // whether the following statement is in the scope of the `if`.; handleOtherDecl(D);; }. // This should also omit braces. The `for` loop contains only a single; // statement, so it shouldn't have braces. The `if` also only contains a; // single simple statement (the `for` loop), so it also should omit braces.; if (isa<FunctionDecl>(D)); for (auto *A : D.attrs()); handleAttr(A);. // Use braces for a `do-while` loop and its enclosing statement.; if (Tok->is(tok::l_brace)) {; do {; Tok = Tok->Next;; } while (Tok);; }. // Use braces for the outer `if` since the nested `for` is braced.; if (isa<FunctionDecl>(D)) {; for (auto *A : D.attrs()) {; // In this `for` loop body, it is necessary that we explain the situation; // with this surprisingly long comment, forcing braces on the `for` block.; handleAttr(A);; }; }. // Use braces on the outer block because there are more than two levels of; // nesting.; if (isa<FunctionDecl>(D)) {; for (auto *A : D.attrs()); for (ssize_t i : llvm::seq<ssize_t>(count)); handleAttrOnDecl(D, A, i);; }. // Use braces on the outer block because of a nested `if`; otherwise the; // compiler would warn: `add explicit braces to avoid dangling else`; if (auto *D = dyn_cast<FunctionDecl>(D)) {; if (shouldProcess(D)); handl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:64203,simpl,simple,64203,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['simpl'],['simple']
Usability,"n, as it; runs just before the pass that we are trying to test:. ``llc -stop-after=machine-cp bug-trigger.ll -o test.mir``. If the same pass is run multiple times, a run index can be included; after the name with a comma. ``llc -stop-after=dead-mi-elimination,1 bug-trigger.ll -o test.mir``. After generating the input MIR file, you'll have to add a run line that uses; the ``-run-pass`` option to it. In order to test the post register allocation; pseudo instruction expansion pass on X86-64, a run line like the one shown; below can be used:. ``# RUN: llc -o - %s -mtriple=x86_64-- -run-pass=postrapseudos | FileCheck %s``. The MIR files are target dependent, so they have to be placed in the target; specific test directories (``lib/CodeGen/TARGETNAME``). They also need to; specify a target triple or a target architecture either in the run line or in; the embedded LLVM IR module. Simplifying MIR files; ^^^^^^^^^^^^^^^^^^^^^. The MIR code coming out of ``-stop-after``/``-stop-before`` is very verbose;; Tests are more accessible and future proof when simplified:. - Use the ``-simplify-mir`` option with llc. - Machine function attributes often have default values or the test works just; as well with default values. Typical candidates for this are: `alignment:`,; `exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing later passes.; The per-block `liveins:` on the other hand are necessary if; `tracksRegLiveness` is true. - Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:3136,simpl,simplified,3136,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['simpl'],['simplified']
Usability,"n, this stream is saved in the emitter class member; named ``OS``, although some ``run`` functions are simple and just use the; stream without saving it. The output can be produced by writing values; directly to the output stream, or by using the ``std::format()`` or; ``llvm::formatv()`` functions. .. code-block:: text. OS << ""#ifndef "" << NodeName << ""\n"";. OS << format(""0x%0*x, "", Digits, Value);. Instances of the following classes can be printed using the ``<<`` operator:; ``RecordKeeper``,; ``Record``,; ``RecTy``,; ``RecordVal``, and; ``Init``. The helper function ``emitSourceFileHeader()`` prints the header comment; that should be included at the top of every output file. A call to it is; included in the skeleton backend file ``TableGenBackendSkeleton.cpp``. Printing Error Messages; =======================. TableGen records are often derived from multiple classes and also often; defined through a sequence of multiclasses. Because of this, it can be; difficult for backends to report clear error messages with accurate source; file locations. To make error reporting easier, five error reporting; functions are provided, each with four overloads. * ``PrintWarning`` prints a message tagged as a warning. * ``PrintError`` prints a message tagged as an error. * ``PrintFatalError`` prints a message tagged as an error and then terminates. * ``PrintNote`` prints a note. It is often used after one of the previous; functions to provide more information. * ``PrintFatalNote`` prints a note and then terminates. Each of these five functions is overloaded four times. * ``PrintError(const Twine &Msg)``:; Prints the message with no source file location. * ``PrintError(ArrayRef<SMLoc> ErrorLoc, const Twine &Msg)``:; Prints the message followed by the specified source line,; along with a pointer to the item in error. The array of; source file locations is typically taken from a ``Record`` instance. * ``PrintError(const Record *Rec, const Twine &Msg)``:; Prints the message followed by",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:23738,clear,clear,23738,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['clear'],['clear']
Usability,"n. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be im",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18198,guid,guide,18198,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['guid'],['guide']
Usability,"n. Implementing a Native Assembler; ===============================. Though you're probably reading this because you want to write or maintain a; compiler backend, LLVM also fully supports building a native assembler.; We've tried hard to automate the generation of the assembler from the .td files; (in particular the instruction syntax and encodings), which means that a large; part of the manual and repetitive data entry can be factored and shared with the; compiler. Instruction Parsing; -------------------. .. note::. To Be Written. Instruction Alias Processing; ----------------------------. Once the instruction is parsed, it enters the MatchInstructionImpl function.; The MatchInstructionImpl function performs alias processing and then does actual; matching. Alias processing is the phase that canonicalizes different lexical forms of the; same instructions down to one representation. There are several different kinds; of alias that are possible to implement and they are listed below in the order; that they are processed (which is in order from simplest/weakest to most; complex/powerful). Generally you want to use the first alias mechanism that; meets the needs of your instruction, because it will allow a more concise; description. Mnemonic Aliases; ^^^^^^^^^^^^^^^^. The first phase of alias processing is simple instruction mnemonic remapping for; classes of instructions which are allowed with two different mnemonics. This; phase is a simple and unconditionally remapping from one input mnemonic to one; output mnemonic. It isn't possible for this form of alias to look at the; operands at all, so the remapping must apply for all forms of a given mnemonic.; Mnemonic aliases are defined simply, for example X86 has:. ::. def : MnemonicAlias<""cbw"", ""cbtw"">;; def : MnemonicAlias<""smovq"", ""movsq"">;; def : MnemonicAlias<""fldcww"", ""fldcw"">;; def : MnemonicAlias<""fucompi"", ""fucomip"">;; def : MnemonicAlias<""ud2a"", ""ud2"">;. ... and many others. With a MnemonicAlias definition, th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:81923,simpl,simplest,81923,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simplest']
Usability,"n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code needs to get executed for different suspend points,; a similar switch will be in the `f.destroy` function. .. note ::. Using suspend index in a coroutine state and having a switch in `f.resume` and; `f.destroy` is one of the possible implementation strategies. We explored; another option where a distinct `f.resume1`, `f.resume2`, etc. are created for; every suspend point, and instead of storing an index, the resume and destroy; function pointers are updated at every suspend. Early testing showed that the; current approach is easier on the optimizer than the latter so it is a; lowering strategy implemented at the moment. Distinct Save and Suspend; -------------------------. In the previous example, setting a resume index (or some other state change that; needs to happen to prepare a coroutine for resumption) happens at the same time as; a suspension of a coroutine. However, in certain cases, it is necessary to control; when coroutine is prepared for resumption and when it is suspended. In the following example, a coroutine represents some activity that is driven; by completions of asynchronous operations `async_op1` and `async_op2` which get; a coroutine handle as a parameter and resume the coroutine once async; operation is finished. .. code-block:: text. void g() {; for (;;); if (cond()) {; async_op1(<coroutine-handle>); // will resume once async_op1 completes; <suspend>; do_one();; }; else {; async_op2(<coroutine-handle>); // will resume once async_op2 completes; <suspend>; do_two();; }; }; }. In this case, coroutine should be ready for resumption prior to a call to; `async_op1` and `async_op2`. The `coro.save`_ intrinsic is used to indicate a; point when coroutine should be ready for resumption (namely, when a resume index; should be stored in th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:20578,resume,resume,20578,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"n.png ""f51""; <a name=""f51""></a>. ![The result of a counting (pseudo) experiment. Only bins corresponding; to integer values are filled given the discrete nature of the poissonian; distribution. \label{f51}][f51]. Using histograms is rather simple. The main differences with respect to; graphs that emerge from the example are:. - line *5*: The histograms have a name and a title right from the; start, no predefined number of entries but a number of bins and a; lower-upper range. - line *15*: An entry is stored in the histogram through the; `TH1F::Fill` method. - line *18* and *21*: The histogram can be drawn also normalised, ROOT; automatically takes cares of the necessary rescaling. - line *24* to *30*: This small snippet shows how easy it is to access; the moments and associated errors of a histogram. ## Add and Divide Histograms ##. Quite a large number of operations can be carried out with histograms.; The most useful are addition and division. In the following macro we; will learn how to manage these procedures within ROOT. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro6.C; ```. The plots that you will obtain are shown in Figures [5.2](#f52) and [5.3](#f53). [f52]: figures/histo_sum.png ""f52""; <a name=""f52""></a>. ![The sum of two histograms.\label{f52}][f52]. [f53]: figures/histo_ratio.png ""f53""; <a name=""f53""></a>. ![The ratio of two histograms.\label{f53}][f53]. Some lines now need a bit of clarification:. - line *3*: Cling, as we know, is also able to interpret more than one; function per file. In this case the function simply sets up some; parameters to conveniently set the line of histograms. - line *19* to *21*: Some `C++` syntax for conditional; statements is used to fill the histograms with different numbers of; entries inside the loop. - line *30*: The sum of two histograms. A weight, which can be negative, can; be assigned to the added histogram. - line *41*: The division of two histograms is rather straightforward. - line *44* to *62*: When yo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:1968,learn,learn,1968,documentation/primer/histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md,1,['learn'],['learn']
Usability,"n3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py merge ${LLVM_PROFDATA} ${CMAKE_CURRENT_BINARY_DIR}/clang.profdata ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_BINARY_DIR}/profiles/; COMMENT ""Merging profdata""; DEPENDS generate-profraw); if (CLANG_PGO_TRAINING_DATA_SOURCE_DIR); llvm_ExternalProject_Add(generate-profraw-external ${CLANG_PGO_TRAINING_DATA_SOURCE_DIR}; USE_TOOLCHAIN EXLUDE_FROM_ALL NO_INSTALL DEPENDS generate-profraw); add_dependencies(generate-profdata generate-profraw-external); endif(); endif(); endif(). find_program(DTRACE dtrace); # TODO: Look into supporting this for the driver build. It will require changing; # the perf-helper.py file to understand to call `llvm` as `llvm clang`.; if(APPLE AND DTRACE AND NOT LLVM_TOOL_LLVM_DRIVER_BUILD); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/order-files.lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/order-files/lit.site.cfg; ). add_lit_testsuite(generate-dtrace-logs ""Generating clang dtrace data""; ${CMAKE_CURRENT_BINARY_DIR}/order-files/; EXCLUDE_FROM_CHECK_ALL; ARGS -j 1; DEPENDS clang clear-dtrace-logs; ). add_custom_target(clear-dtrace-logs; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py clean ${CMAKE_CURRENT_BINARY_DIR} dtrace; COMMENT ""Clearing old dtrace data""). if(NOT CLANG_ORDER_FILE); message(FATAL_ERROR ""Output clang order file is not set""); endif(). add_custom_target(generate-order-file; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py gen-order-file --binary $<TARGET_FILE:clang> --output ${CLANG_ORDER_FILE} ${CMAKE_CURRENT_BINARY_DIR}; COMMENT ""Generating order file""; DEPENDS generate-dtrace-logs); endif(). if(CLANG_BOLT_INSTRUMENT AND NOT LLVM_BUILD_INSTRUMENTED); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/bolt.lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/bolt-fdata/lit.site.cfg; ). add_lit_testsuite(generate-bolt-fdata ""Generating BOLT profile for Clang""; ${CMAKE_CURRENT_BINARY_DIR}/bolt-fdata/; EXCLUDE_FROM_CHECK_ALL; DE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt:2335,clear,clear-dtrace-logs,2335,interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,1,['clear'],['clear-dtrace-logs']
Usability,"n: Combine Rule root is a named pattern. def Foo : GICombineRule<; (defs root:$root),; (match (G_ZEXT $tmp, (i32 0)),; (G_STORE $tmp, $ptr):$root),; (apply (G_STORE (i32 0), $ptr):$root)>;. Combine Rules also allow mixing C++ code with MIR patterns, so that you; may perform additional checks when matching, or run additional code after; rewriting a pattern. The following expansions are available for MIR patterns:. * operand names (``MachineOperand &``); * pattern names (``MachineInstr *`` for ``match``,; ``MachineInstrBuilder &`` for apply). .. code-block:: text; :caption: Example C++ Expansions. def Foo : GICombineRule<; (defs root:$root),; (match (G_ZEXT $root, $src):$mi),; (apply ""foobar(${root}.getReg(), ${src}.getReg(), ${mi}->hasImplicitDef())"")>;. Common Pattern #1: Replace a Register with Another; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The 'apply' pattern must always redefine all operands defined by the match root.; Sometimes, we do not need to create instructions, simply replace a def with; another matched register. The ``GIReplaceReg`` builtin can do just that. .. code-block:: text. def Foo : GICombineRule<; (defs root:$dst),; (match (G_FNEG $tmp, $src), (G_FNEG $dst, $tmp)),; (apply (GIReplaceReg $dst, $src))>;. This also works if the replacement register is a temporary register from the; ``apply`` pattern. .. code-block:: text. def ReplaceTemp : GICombineRule<; (defs root:$a),; (match (G_BUILD_VECTOR $tmp, $x, $y),; (G_UNMERGE_VALUES $a, $b, $tmp)),; (apply (G_UNMERGE_VALUES $a, i32:$new, $y),; (GIReplaceReg $b, $new))>. Common Pattern #2: Erasing a Def-less Root; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If we simply want to erase a def-less match root, we can use the; ``GIEraseRoot`` builtin. .. code-block:: text. def Foo : GICombineRule<; (defs root:$mi),; (match (G_STORE $a, $b):$mi),; (apply (GIEraseRoot))>;. Common Pattern #3: Emitting a Constant Value; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. When an immediate operand appears in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:8361,simpl,simply,8361,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['simpl'],['simply']
Usability,"n; when running ``*-tblgen`` is to print the information in a textual format, but; that's only useful for debugging the TableGen files themselves. The power; in TableGen is, however, to interpret the source files into an internal; representation that can be generated into anything you want. Current usage of TableGen is to create huge include files with tables that you; can either include directly (if the output is in the language you're coding),; or be used in pre-processing via macros surrounding the include of the file. Direct output can be used if the backend already prints a table in C format; or if the output is just a list of strings (for error and warning messages).; Pre-processed output should be used if the same information needs to be used; in different contexts (like Instruction names), so your backend should print; a meta-information list that can be shaped into different compile-time formats. See :doc:`TableGen BackEnds <./BackEnds>` for a list of available; backends, and see the :doc:`TableGen Backend Developer's Guide <./BackGuide>`; for information on how to write and debug a new backend. Tools and Resources; ===================. In addition to this documentation, a list of tools and resources for TableGen; can be found in TableGen's; `README <https://github.com/llvm/llvm-project/blob/main/llvm/utils/TableGen/README.md>`_. TableGen Deficiencies; =====================. Despite being very generic, TableGen has some deficiencies that have been; pointed out numerous times. The common theme is that, while TableGen allows; you to build domain specific languages, the final languages that you create; lack the power of other DSLs, which in turn increase considerably the size; and complexity of TableGen files. At the same time, TableGen allows you to create virtually any meaning of; the basic concepts via custom-made backends, which can pervert the original; design and make it very hard for newcomers to understand the evil TableGen; file. There are some in fav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst:11653,Guid,Guide,11653,interpreter/llvm-project/llvm/docs/TableGen/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst,1,['Guid'],['Guide']
Usability,"n_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note that the compiler does not guarantee that non-temporal loads or stores; will be used. C++ Coroutines support builtins; --------------------------------. .. warning::; This is a work in progress. Compatibility across Clang/LLVM releases is not; guaranteed. Clang provides experimental builtins to support C++ Coroutines as defined by; https://wg21.link/P0057. The following four are intended to be used by the; standard library to implement the ``std::coroutine_handle`` type. **Syntax**:. .. code-block:: c. void __builtin_coro_resume(void *addr);; void __builtin_coro_destroy(void *addr);; bool __builtin_coro_done(void *addr);; void *__builtin_coro_promise(void *addr, int alignment, bool from_promise). **Example of use**:. .. code-block:: c++. template <> struct coroutine_handle<void> {; void resume() const { __builtin_coro_resume(ptr); }; void destroy() const { __builtin_coro_destroy(ptr); }; bool done() const { return __builtin_coro_done(ptr); }; // ...; protected:; void *ptr;; };. template <typename Promise> struct coroutine_handle : coroutine_handle<> {; // ...; Promise &promise() const {; return *reinterpret_cast<Promise *>(; __builtin_coro_promise(ptr, alignof(Promise), /*from-promise=*/false));; }; static coroutine_handle from_promise(Promise &promise) {; coroutine_handle p;; p.ptr = __builtin_coro_promise(&promise, alignof(Promise),; /*from-promise=*/true);; return p;; }; };. Other coroutine builtins are either for internal clang use or for use during; development of the coroutine feature. See `Coroutines in LLVM; <https://llvm.org/docs/Coroutines.html#intrinsics>`_ for; more information on their semantics. Note that builtins matching the intrinsics; that take token as the first parameter (llvm.coro.begin, llvm.coro.alloc,; llvm.coro.free and llvm.coro.suspend) omit the token parameter and fill it to; an appropriate valu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:145904,resume,resume,145904,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['resume'],['resume']
Usability,"nager object, it will also dump the corresponding line in the; source code. (gdb) p E->dump(). To dump AST of a method that the current ExplodedNode belongs; to:. (gdb) p C.getPredecessor()->getCodeDecl().getBody()->dump(). Making Your Checker Better. User facing documentation is important for adoption! Make sure the checker list is updated; at the homepage of the analyzer. Also ensure the description is clear to; non-analyzer-developers in Checkers.td.; Warning and note messages should be clear and easy to understand, even if a bit long. Messages should start with a capital letter (unlike Clang warnings!) and should not; end with ..; Articles are usually omitted, eg. Dereference of a null pointer ->; Dereference of null pointer.; Introduce BugReporterVisitors to emit additional notes that explain the warning; to the user better. There are some existing visitors that might be useful for your check,; e.g. trackNullOrUndefValue. For example, SimpleStreamChecker should highlight; the event of opening the file when reporting a file descriptor leak. If the check tracks anything in the program state, it needs to implement the; checkDeadSymbolscallback to clean the state up.; The check should conservatively assume that the program is correct when a tracked symbol; is passed to a function that is unknown to the analyzer.; checkPointerEscape callback could help you handle that case.; Use safe and convenient APIs!. Always use CheckerContext::generateErrorNode and; CheckerContext::generateNonFatalErrorNode for emitting bug reports.; Most importantly, never emit report against CheckerContext::getPredecessor.; Prefer checkPreCall and checkPostCall to; checkPreStmt<CallExpr> and checkPostStmt<CallExpr>.; Use CallDescription to detect hardcoded API calls in the program.; Simplify C.getState()->getSVal(E, C.getLocationContext()) to C.getSVal(E). Common sources of crashes:. CallEvent::getOriginExpr is nullable - for example, it returns null for an; automatic destructor of a variable",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:23612,Simpl,SimpleStreamChecker,23612,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['Simpl'],['SimpleStreamChecker']
Usability,"nalyse the performance tree.; Add support for selector-by-object processing in PROOF. The; selector object, created and configured locally by the user, is added; to the input list and recuperated from there on the worker machines for; processing. Any input list setting in the selector itself is not; streamed but temporarly moved to then standard input list, so that user; can use the selector input list as container of processing information; if they find convenient to do so. Process(...) methods with the file; name argument replaced by 'TSelector *' have  introduced where; relevant (TProof, TProofPlayer and their derivatives, TDSet).  ; Add the possibility to force submerging at node level, i.e. one; submerger per physical machine. In this way the network traffic can be; minimized, for example when merging large output files. The new feature; is enabled by setting the Int_t parameter 'PROOF_MergersByHost' (or the; directive 'Proof.MergersByHost') to a non-null value.; Simplify enabling of basic feedback. In TProof::Process, add; support for switches ""fb=name1,name2,name3,... "" or; ""feedback=name1,name2,name3,... "" in the option field. This enables; feedback for the specified objects, creating a TDrawFeedback object; attached to the session. Feedback for the specified objects is disabled; at the end of the query and the created TDrawFeedback is destroyed. The; special name 'stats' enables the three feedback histograms required by; a dedicated new class TStatsFeedback, and uses a TStatsFeedback instead; of TDrawFeedback to display the feedback. . Improvements; ; Add to TProofMgr two static functions to upload files. These; functions are both called UploadFiles and differ in the first argument,; which is used to pass the files to be uploaded. These can be given as a; list (of TFileInfo or TObjString), a directory or specified in a text; file.; Add support for paralell dataset verification. This is; implemented via a dedicated TSelector (TSelVerifyDataSet) which is run;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html:1853,Simpl,Simplify,1853,proof/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html,2,"['Simpl', 'feedback']","['Simplify', 'feedback']"
Usability,nalysis/AffineStructures.cpp; mlir/lib/Dialect/Affine/Analysis/LoopAnalysis.cpp; mlir/lib/Dialect/Affine/Analysis/NestedMatcher.cpp; mlir/lib/Dialect/Affine/Analysis/Utils.cpp; mlir/lib/Dialect/Affine/IR/AffineMemoryOpInterfaces.cpp; mlir/lib/Dialect/Affine/IR/AffineValueMap.cpp; mlir/lib/Dialect/Affine/Transforms/AffineDataCopyGeneration.cpp; mlir/lib/Dialect/Affine/Transforms/AffineLoopInvariantCodeMotion.cpp; mlir/lib/Dialect/Affine/Transforms/AffineLoopNormalize.cpp; mlir/lib/Dialect/Affine/Transforms/AffineParallelize.cpp; mlir/lib/Dialect/Affine/Transforms/AffineScalarReplacement.cpp; mlir/lib/Dialect/Affine/Transforms/LoopCoalescing.cpp; mlir/lib/Dialect/Affine/Transforms/LoopFusion.cpp; mlir/lib/Dialect/Affine/Transforms/LoopTiling.cpp; mlir/lib/Dialect/Affine/Transforms/LoopUnroll.cpp; mlir/lib/Dialect/Affine/Transforms/LoopUnrollAndJam.cpp; mlir/lib/Dialect/Affine/Transforms/PassDetail.h; mlir/lib/Dialect/Affine/Transforms/PipelineDataTransfer.cpp; mlir/lib/Dialect/Affine/Transforms/SimplifyAffineStructures.cpp; mlir/lib/Dialect/Affine/Transforms/SuperVectorize.cpp; mlir/lib/Dialect/Affine/Utils/LoopFusionUtils.cpp; mlir/lib/Dialect/Affine/Utils/LoopUtils.cpp; mlir/lib/Dialect/Affine/Utils/Utils.cpp; mlir/lib/Dialect/AMX/IR/AMXDialect.cpp; mlir/lib/Dialect/AMX/Transforms/LegalizeForLLVMExport.cpp; mlir/lib/Dialect/Arithmetic/IR/ArithmeticDialect.cpp; mlir/lib/Dialect/Arithmetic/Transforms/BufferizableOpInterfaceImpl.cpp; mlir/lib/Dialect/Arithmetic/Transforms/Bufferize.cpp; mlir/lib/Dialect/Arithmetic/Transforms/PassDetail.h; mlir/lib/Dialect/Arithmetic/Utils/Utils.cpp; mlir/lib/Dialect/ArmNeon/IR/ArmNeonDialect.cpp; mlir/lib/Dialect/ArmSVE/IR/ArmSVEDialect.cpp; mlir/lib/Dialect/ArmSVE/Transforms/LegalizeForLLVMExport.cpp; mlir/lib/Dialect/Async/IR/Async.cpp; mlir/lib/Dialect/Async/Transforms/AsyncParallelFor.cpp; mlir/lib/Dialect/Async/Transforms/AsyncRuntimeRefCounting.cpp; mlir/lib/Dialect/Async/Transforms/AsyncRuntimeRefCountingOpt.cpp; mlir/lib/Dialect,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:384693,Simpl,SimplifyAffineStructures,384693,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimplifyAffineStructures']
Usability,"name can include printf qualifier to code pad number. Also allows to store all pads in single PDF; or single ROOT file. Significantly improves performance when creating many image files using web graphics. - Introduce `TCanvas::UpdateAsync` method. In case of web-based canvas triggers update of the canvas on the client side,; but does not wait that real update is completed. Avoids blocking of caller thread.; Have to be used if called from other web-based widget to avoid logical dead-locks.; In case of normal canvas just canvas->Update() is performed. - The Delaunay triangles (used by TGraph2D) were computed by the external package `triangle.c`; included in the ROOT distribution. This package had several issues:; - It was not maintained anymore.; - Its license was not compatible with LGPL; This code is now replaced by the [CDT package](https://github.com/artem-ogre/CDT) which is; properly maintained and has a license (MLP) compatible with LGPL. It will appear in 6.03.02. ## Machine Learning integration. - ROOT now offers functionality to extract batches of events out of a dataset for use in common ML training workflows. For example, one can generate PyTorch tensors from a TTree. The functionality is available through the `RBatchGenerator` class and can be seamlessly integrated in user code, for example:; ```python; # Returns two generators that return training and validation batches as PyTorch tensors.; gen_train, gen_validation = ROOT.TMVA.Experimental.CreatePyTorchGenerators(; tree_name, file_name, batch_size, chunk_size, target=target, validation_split=0.3); ```; The functionality is also available for TensorFlow datasets and Python generators of numpy arrays. See more in the `RBatchGenerator*` tutorials under the TMVA folder. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. - The default `TCanvas` and `TBrowser` i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:20663,Learn,Learning,20663,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['Learn'],['Learning']
Usability,"naturally, and the store automagically sees reachable symbols, live; symbols, escapes, invalidations, whatever. > In my view this differs from ghost variables in that (1) this storage does; > actually exist (it is just a library implementation detail where that storage; > lives) and (2) it is perfectly valid for a pointer into that storage to be; > returned and for another part of the program to read or write from that; > storage. (Well, in this case just read since it is allowed to be read-only; > memory). > What I'm not OK with is modeling abstract analysis state (for example, the; > count of a NSMutableArray or the typestate of a file handle) as a value stored; > in some ginned up region in the store.This takes an easy problem that the; > analyzer does well at (modeling typestate) and turns it into a hard one that; > the analyzer is bad at (reasoning about the contents of the heap). Yeah, i tend to agree on that. For simple typestates, this is probably an; overkill, so let's definitely put aside the idea of ""ghost symbolic regions""; that i had earlier. But, to summarize a bit, in our current case, however, the typestate we're; looking for is the contents of the heap. And when we try to model such; typestates (complex in this specific manner, i.e. heap-like) in any checker, we; have a choice between re-doing this modeling in every such checker (which is; something analyzer is indeed good at, but at a price of making checkers heavy); or instead relying on the Store to do exactly what it's designed to do. > I think the key criterion here is: ""is the region accessible from outside; > the library"". That is, does the library expose the region as a pointer that; > can be read to or written from in the client program? If so, then it makes; > sense for this to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:14757,simpl,simple,14757,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['simpl'],['simple']
Usability,"nc-continuation lowering, signaled by the use of `llvm.coro.id.async`,; handling of control-flow must be handled explicitly by the frontend. In this lowering, a coroutine is assumed to take the current `async context` as; one of its arguments (the argument position is determined by; `llvm.coro.id.async`). It is used to marshal arguments and return values of the; coroutine. Therefore an async coroutine returns `void`. .. code-block:: llvm. define swiftcc void @async_coroutine(ptr %async.ctxt, ptr, ptr) {; }. Values live across a suspend point need to be stored in the coroutine frame to; be available in the continuation function. This frame is stored as a tail to the; `async context`. Every suspend point takes an `context projection function` argument which; describes how-to obtain the continuations `async context` and every suspend; point has an associated `resume function` denoted by the; `llvm.coro.async.resume` intrinsic. The coroutine is resumed by calling this; `resume function` passing the `async context` as the one of its arguments; argument. The `resume function` can restore its (the caller's) `async context`; by applying a `context projection function` that is provided by the frontend as; a parameter to the `llvm.coro.suspend.async` intrinsic. .. code-block:: c. // For example:; struct async_context {; struct async_context *caller_context;; ...; }. char *context_projection_function(struct async_context *callee_ctxt) {; return callee_ctxt->caller_context;; }. .. code-block:: llvm. %resume_func_ptr = call ptr @llvm.coro.async.resume(); call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function. The frontend should provide a `async function pointer` struct associated with; each async coroutine by `llvm.coro.id.async`'s argument. The initial size and; alignment of the `async context` must be provided as arguments to the; `llvm.coro.id.async` intrinsic. Lowering will update the size entry with the; corou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:8641,resume,resumed,8641,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,['resume'],"['resume', 'resumed']"
Usability,"ncidents; ==================================. Please email conduct@llvm.org with the following details (if possible):. * Your contact info (so we can get in touch with you). Include email and; optionally a phone number.; * Names or descriptions of anyone who was involved or who witnessed the; incident.; * When and where the incident occurred. Please be as specific as possible.; * Your account of what occurred. If there is a written record (e.g. emails,; forum links, tweets, Slack, or Discord messages) please include screenshots,; as well as any available link.; * Any extra context you believe existed for the incident.; * If you believe this incident is ongoing.; * If you have concerns about retaliation or your personal safety, please note; those concerns in your report.; * Any other information you believe we should have. If you are unable to provide all of this information, please still make the; report and include as much information as you have. When handling a report, we follow our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:3544,Guid,Guide,3544,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst,1,['Guid'],['Guide']
Usability,"nclude <TApplication.h>; #include <TGClient.h>; #include <TCanvas.h>; #include <TF1.h>; #include <TRandom.h>; #include <TGButton.h>; #include <TRootEmbeddedCanvas.h>; #include ""example2b.h"". MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h); : TGMainFrame(p,w,h) {. // Creates widgets of the example; fEcanvas = new TRootEmbeddedCanvas (""Ecanvas"",this,200,200);; AddFrame(fEcanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY, 10,10,10,1));; TGHorizontalFrame *hframe=new TGHorizontalFrame(this, 200,40);; TGTextButton *draw = new TGTextButton(hframe,""&Draw"");; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; hframe->AddFrame(draw, new TGLayoutHints(kLHintsCenterX,; 5,5,3,4));; TGTextButton *exit = new TGTextButton(hframe,""&Exit "",; ""gApplication->Terminate()"");; hframe->AddFrame(exit, new TGLayoutHints(kLHintsCenterX,; 5,5,3,4));; AddFrame(hframe,new TGLayoutHints(kLHintsCenterX,2,2,2,2));. // Sets window name and shows the main frame; SetWindowName(""Simple Example"");; MapSubwindows();; Resize(GetDefaultSize());; MapWindow();; }; ```. ## Widgets Overview. The word widget is a contraction of windows and gadget. Almost all GUI; elements are widgets. A button is a widget, a menu item is a widget, a; scrollbar is a widget, and a complete dialog box is a widget too. Some; widgets may have sub widgets. For example, a dialog box can contain; buttons, text fields, a combo-box, etc. On the screen widgets look like rectangular areas with special; behaviors. In terms of the object-oriented programming we can define a; widget in ROOT as an object of a class deriving from **`TGObject`**. This section presents all currently supported widgets in ROOT and their; most useful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the compl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:19551,Simpl,Simple,19551,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['Simpl'],['Simple']
Usability,nclude/llvm/Transforms/Utils/InstructionNamer.h; llvm/include/llvm/Transforms/Utils/InstructionWorklist.h; llvm/include/llvm/Transforms/Utils/LCSSA.h; llvm/include/llvm/Transforms/Utils/LibCallsShrinkWrap.h; llvm/include/llvm/Transforms/Utils/LoopPeel.h; llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h; llvm/include/llvm/Transforms/Utils/LoopSimplify.h; llvm/include/llvm/Transforms/Utils/LowerSwitch.h; llvm/include/llvm/Transforms/Utils/MatrixUtils.h; llvm/include/llvm/Transforms/Utils/Mem2Reg.h; llvm/include/llvm/Transforms/Utils/MemoryTaggingSupport.h; llvm/include/llvm/Transforms/Utils/MetaRenamer.h; llvm/include/llvm/Transforms/Utils/NameAnonGlobals.h; llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h; llvm/include/llvm/Transforms/Utils/SampleProfileInference.h; llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h; llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h; llvm/include/llvm/Transforms/Utils/SCCPSolver.h; llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h; llvm/include/llvm/Transforms/Utils/SplitModule.h; llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h; llvm/include/llvm/Transforms/Utils/StripGCRelocates.h; llvm/include/llvm/Transforms/Utils/StripNonLineTableDebugInfo.h; llvm/include/llvm/Transforms/Utils/SymbolRewriter.h; llvm/include/llvm/Transforms/Utils/UnifyFunctionExitNodes.h; llvm/include/llvm/Transforms/Utils/UnifyLoopExits.h; llvm/include/llvm/Transforms/Utils/ValueMapper.h; llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h; llvm/include/llvm/WindowsDriver/MSVCSetupApi.h; llvm/include/llvm/WindowsManifest/WindowsManifestMerger.h; llvm/include/llvm/WindowsResource/ResourceScriptToken.h; llvm/include/llvm/XRay/BlockIndexer.h; llvm/include/llvm/XRay/BlockPrinter.h; llvm/include/llvm/XRay/BlockVerifier.h; llvm/include/llvm/XRay/FDRRecordConsumer.h; llvm/include/llvm/XRay/FDRRecordProducer.h; llvm/include/llvm/XRay/FDRRecords.h; llvm/include/llvm/XRay/FDRTraceExpander.h; llvm/include/llvm/XRay/,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:271725,Simpl,SimplifyCFGOptions,271725,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimplifyCFGOptions']
Usability,"nction CFG or a subgraph of it, a *cycle*; is a maximal strongly connected region with at least one internal edge.; (Informational note --- The requirement for at least one internal edge; ensures that a single basic block is a cycle only if there is an edge; that goes back to the same basic block.); 2. A basic block in a cycle that can be reached from the entry of; the function along a path that does not visit any other basic block; in the cycle is called an *entry* of the cycle.; A cycle can have multiple entries.; 3. For a given depth-first search starting from the entry of the function, the; first node of a cycle to be visited is called the *header* of this cycle; with respect to this particular DFS. The header is always an entry node.; 4. In any depth-first search starting from the entry, the set of cycles; found in the CFG is the same. These are the *top-level cycles*; that do not themselves have a parent.; 5. The *child cycles* (or simply cycles) nested inside a cycle C with; header H are the cycles in the subgraph induced on the set of nodes (C - H).; C is said to be the *parent* of these cycles. Thus, cycles form an implementation-defined forest where each cycle C is; the parent of any child cycles nested inside C. The tree closely; follows the nesting of loops in the same function. The unique entry of; a reducible cycle (an LLVM loop) L dominates all its other nodes, and; is always chosen as the header of some cycle C regardless of the DFS; tree used. This cycle C is a superset of the loop L. For an; irreducible cycle, no one entry dominates the nodes of the cycle. One; of the entries is chosen as header of the cycle, in an; implementation-defined way. .. _cycle-irreducible:. A cycle is *irreducible* if it has multiple entries and it is; *reducible* otherwise. .. _cycle-parent-block:. A cycle C is said to be the *parent* of a basic block B if B occurs in; C but not in any child cycle of C. Then B is also said to be a *child*; of cycle C. .. _cycle-toplevel-b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CycleTerminology.rst:1267,simpl,simply,1267,interpreter/llvm-project/llvm/docs/CycleTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CycleTerminology.rst,1,['simpl'],['simply']
Usability,"nction is split; out into some number of ""resume functions"". Any state which must persist; across suspensions is stored in the coroutine frame. The resume functions; must somehow be able to handle either a ""normal"" resumption, which continues; the normal execution of the coroutine, or an ""abnormal"" resumption, which; must unwind the coroutine without attempting to suspend it. Switched-Resume Lowering; ------------------------. In LLVM's standard switched-resume lowering, signaled by the use of; `llvm.coro.id`, the coroutine frame is stored as part of a ""coroutine; object"" which represents a handle to a particular invocation of the; coroutine. All coroutine objects support a common ABI allowing certain; features to be used without knowing anything about the coroutine's; implementation:. - A coroutine object can be queried to see if it has reached completion; with `llvm.coro.done`. - A coroutine object can be resumed normally if it has not already reached; completion with `llvm.coro.resume`. - A coroutine object can be destroyed, invalidating the coroutine object,; with `llvm.coro.destroy`. This must be done separately even if the; coroutine has reached completion normally. - ""Promise"" storage, which is known to have a certain size and alignment,; can be projected out of the coroutine object with `llvm.coro.promise`.; The coroutine implementation must have been compiled to define a promise; of the same size and alignment. In general, interacting with a coroutine object in any of these ways while; it is running has undefined behavior. The coroutine function is split into three functions, representing three; different ways that control can enter the coroutine:. 1. the ramp function that is initially invoked, which takes arbitrary; arguments and returns a pointer to the coroutine object;. 2. a coroutine resume function that is invoked when the coroutine is resumed,; which takes a pointer to the coroutine object and returns `void`;. 3. a coroutine destroy function that is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:3157,resume,resume,3157,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"nction, place your function call in a; scope and after the scope ends, the loop will also end. - `addToCodeBody()` helps add things to the body of the C++ function that; you're creating. It takes whatever string is computed in its arguments and; adds it to the overall function string (which will later be just-in-time; compiled). The `addToCodeBody()` function is important since not everything; can be added in-line and this function helps split the code into multiple; lines. ### Step 3. analyticalIntegral() Use Case. > Besides the `evaluate()` function, this tutorial illustrates how the; `analyticalIntegral()` can be updated. This highly dependent on the class that; is being transformed for AD support, but will be necessary in those specific; instances. Let's consider a fictional class RooFoo, that performs some arbitrary; mathematical operations called 'Foo' (as seen in doFoo() function below). > Note that doFoo is a simplified example, in many cases the mathematical; operations are not limited to a single function, so they need to be spotted; within the `evaluate()` function. ``` {.cpp}; class RooFoo : public RooAbsReal {; int a;; int b;; int doFoo() { return a* b + a + b; }; int integralFoo() { return /* whatever */;}; public:; // Other functions...; double evaluate() override {; // Do some bookkeeping; return doFoo();; };; double analyticalIntegral(Int_t code, const char* rangeName) override {; // Select the right paths for integration using codes or whatever.; return integralFoo();; }; };; ```. \note All RooFit classes are deriving from the RooAbsReal object, but; its details are not relevant to the current example. Note how the `evaluate()` function overrides the `RooAbsReal` for the RooFoo; class. Similarly, the `analyticalIntegral()` function has also been overridden; from the `RooAbsReal` class. The `evaluate()` function includes some bookkeeping steps (commented out in; above example) that are not relevant to AD. The important part is that it; calls a speci",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:19156,simpl,simplified,19156,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simplified']
Usability,"nd SPARC. The backend may also be used to generate code targeted at SPUs; of the Cell processor or GPUs to support the execution of compute kernels. The document focuses on existing examples found in subdirectories of; ``llvm/lib/Target`` in a downloaded LLVM release. In particular, this document; focuses on the example of creating a static compiler (one that emits text; assembly) for a SPARC target, because SPARC has fairly standard; characteristics, such as a RISC instruction set and straightforward calling; conventions. Audience; --------. The audience for this document is anyone who needs to write an LLVM backend to; generate code for a specific hardware or software target. Prerequisite Reading; --------------------. These essential documents must be read before reading this document:. * `LLVM Language Reference Manual <LangRef.html>`_ --- a reference manual for; the LLVM assembly language. * :doc:`CodeGenerator` --- a guide to the components (classes and code; generation algorithms) for translating the LLVM internal representation into; machine code for a specified target. Pay particular attention to the; descriptions of code generation stages: Instruction Selection, Scheduling and; Formation, SSA-based Optimization, Register Allocation, Prolog/Epilog Code; Insertion, Late Machine Code Optimizations, and Code Emission. * :doc:`TableGen/index` --- a document that describes the TableGen; (``tblgen``) application that manages domain-specific information to support; LLVM code generation. TableGen processes input from a target description; file (``.td`` suffix) and generates C++ code that can be used for code; generation. * :doc:`WritingAnLLVMPass` --- The assembly printer is a ``FunctionPass``, as; are several ``SelectionDAG`` processing steps. To follow the SPARC examples in this document, have a copy of `The SPARC; Architecture Manual, Version 8 <http://www.sparc.org/standards/V8.pdf>`_ for; reference. For details about the ARM instruction set, refer to the `ARM; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:1566,guid,guide,1566,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['guid'],['guide']
Usability,"nd easily extended. Tests in; [roottest](https://github.com/root-project/roottest.git) are more involved (e.g., tests requiring custom dictionaries or; data files). When you create a branch in the main ROOT repository (i.e., this repository) and add a test to `roottest`,; make sure to do this under the same branch name (and open a PR for it). Our CI infrastructure automatically picks up the; changes defined in the `roottest` PR based on this branch name, and uses that for testing your PR here. ## Continuous Integration. To prevent bad surprises and make a better first impression, we; strongly encourage new developers to [run the tests](https://root.cern/for_developers/run_the_tests/); _before_ submitting a pull request. ROOT has automated CI tests :cop: that are used for pull requests:; - *Build and test*: a [Jenkins-based CI workflow](https://github.com/phsft-bot/build-configuration/blob/master/README.md); as well as a GitHub Actions CI workflow tests PRs automatically; only a; [project member](https://github.com/orgs/root-project/people) is allowed to initiate this build.; The results are posted to the pull request.; Compared to ROOT's nightly builds, PRs are tested with less tests, on less platforms.; - *Formatting check*: `clang-format` automatically checks that a PR; [follows](https://github.com/root-project/root/blob/master/.clang-format) ROOT's; [coding conventions](https://root.cern/contribute/coding_conventions/).; If coding violations are found, it provides you with a `patch` output that you likely want to apply to your PR.; - *Simple Static Analysis*: PRs are analyzed using [`clang-tidy`](https://clang.llvm.org/extra/clang-tidy/). Typically, PRs must pass all these tests; we will ask you to fix any issues that may arise.; Some tests are run only outside the PR testing system:; we might come back to you with additional reports after your contribution was merged. Thank you for reading this; and even more: thank you :bouquet: for considering to contribute!; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:7547,Simpl,Simple,7547,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['Simpl'],['Simple']
Usability,"nd it much easier than the C syntax.; > In either case, I would have to look up an example to write pointers to; > member functions. I would argue that because the lexical structure of the language is self; consistent, any person who spent a significant amount of time programming; in LLVM directly would understand how to do it without looking it up in a; manual. The reason this does not work for C is because you rarely have to; declare these pointers, and the syntax is inconsistent with the method; declaration and calling syntax. > But pointers to member functions are nowhere near as common as arrays. Very true. If you're implementing an object oriented language, however,; remember that you have to do all the pointer to member function stuff; yourself.... so every time you invoke a virtual method one is involved; (instead of having C++ hide it for you behind ""syntactic sugar""). > And the old array syntax:; > type [ int, int, ...]; > is just much more familiar and clear to people than anything new you; > introduce, no matter how logical it is. . Erm... excuse me but how is this the ""old array syntax""? If you are; arguing for consistency with C, you should be asking for 'type int []',; which is significantly different than the above (beside the above; introduces a new operator and duplicates information; needlessly). Basically what I am suggesting is exactly the above without; the fluff. So instead of:. type [ int, int, ...]. you use:. type [ int ]. > Introducing a new syntax that may; > make function pointers easier but makes arrays much more difficult seems; > very risky to me. This is not about function pointers. This is about consistency in the; type system, and consistency with the rest of the language. The point; above does not make arrays any more difficult to use, and makes the; structure of types much more obvious than the ""c way"". > > In my opinion, it is critically important to have clear and concise type; > > specifications, because types are going to be a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt:2574,clear,clear,2574,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,1,['clear'],['clear']
Usability,"nd leave out the x-points, the diagram will look like this:. ## 3D Graphics Libraries. ## Geometry Libraries. - Support with web geometry viewer image production in batch mode. Just do:; ```; ROOT::Experimental::RGeomViewer viewer(geom);; viewer.SaveImage(""rootgeom.jpeg"", 800, 600);; ```; This runs normal WebGL rendering in headless web browser (Chrome or Firefox) and; creates png or jpeg image out of it. ## Database Libraries. ## Networking Libraries. ### THttpServer. - upgrade civetweb code to version 1.15, supports SSL version 3.0; - resolve problem with symbolic links usage on Windows; - let disable/enable directory files listing via THttpServer (default is off); - enable usage of unix sockets, used by `rootssh` script for tunnel to remote session. ## GUI Libraries. - Provide web-based TTree viewer, integrated with RBrowser; - Support Edge browser on Windows for all kinds of web widgets; - Provide `rootssh` shell script to simplify use of web-based widgets on remote nodes:; ```; [localnode] rootssh user@remotenode; [remotenode] root --web -e 'new TBrowser'; ```; Script automatically configures ssh tunnel between local and remote nodes, one the remote node; unix socket with strict 0700 mode is used. When ROOT running on remote node wants to display; new web widget, script will automatically start web browser on local node with appropriate URL,; accessing widget via configured ssh tunnel. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. - Major JSROOT upgrade to version 7, using ES6 modules and classes. ## Tutorials. - Several new tutorials have been added in both C++ and Python in the `tutorial/tmva` directory.; Tutorials like `TMVA_Higgs_Classification.py` shows the new pythonizations available in TMVA and; new `TMVA_SOFIE_...` tutorials show th eusage of SOFIE in both C++ or Python. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - Building external applications that use ROOT oftentimes fail if ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:32266,simpl,simplify,32266,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['simpl'],['simplify']
Usability,"nd nested tuple) is the experimental evolution of TTree columnar data storage. RNTuple introduces; new interfaces that aim to be more robust. In particular, the new interfaces are type-safe through the use of; templates, and the ownership is well-defined through the use of smart pointers. For instance. tree->Branch(""px"", &Category, ""px/F"");. becomes. auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>. The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on; most modern architectures. Combined with a clear separation of offset/index data and payload data for collections,; uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; -----. RNTuple shall investigate improvements of the TTree I/O in the following ways. 1. More speed; * Improve mapping to vectorized and parallel hardware; * For types known at compile / JIT time: generate optimized code; * Optimized for simple types (float, int, and vectors of them); * Better memory control: work with a fixed budget of pre-defined I/O buffers; * Naturally thread-safe and asynchronous interfaces. 2. More robust interfaces; * Compile-time type safety by default; * Decomposition into layers: logical layer, primitives layer, storage layer; * Separation of data model and live data; * Self-contained I/O code to support creation of a standalone I/O library. Concepts; --------. At the **logical layer**, the user defines a data model using the RNTupleModel class.; The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which represents a memory location; storing a value of the given C++ type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:1052,simpl,simple,1052,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,1,['simpl'],['simple']
Usability,"nd properties of the window used for our plot, and `TLegend` to; add a nice legend. For the moment, ignore the commented include; statements for header files, they will only become important at the end; in section [Interpretation and Compilation](#interpretation-and-compilation). ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro1.C; ```. Let's comment it in detail:. - Line *13*: the name of the principal function (it plays the role of; the ""main"" function in compiled programs) in the macro file. It has; to be the same as the file name without extension. - Line *24-25*: instance of the `TGraphErrors` class. The constructor; takes the number of points and the pointers to the arrays of; x values, y values, x errors (in this case none,; represented by the NULL pointer) and y errors. The second line; defines in one shot the title of the graph and the titles of the two; axes, separated by a "";"". - Line *28-30*: These three lines are rather intuitive right ? To understand; better the enumerators for colours and styles see the reference for; the `TColor` and `TMarker` classes. - Line *33*: the canvas object that will host the drawn objects. The; ""memory leak"" is intentional, to make the object existing also out; of the macro1 scope. - Line *36*: the method *DrawClone* draws a clone of the object on the; canvas. It *has to be* a clone, to survive after the scope of; `macro1`, and be displayed on screen after the end of the macro; execution. The string option ""APE"" stands for:. - *A* imposes the drawing of the Axes. - *P* imposes the drawing of the graph's markers. - *E* imposes the drawing of the graph's error bars. - Line *39*: define a mathematical function. There are several ways to; accomplish this, but in this case the constructor accepts the name; of the function, the formula, and the function range. - Line *41*: maquillage. Try to give a look to the line styles at your; disposal visiting the documentation of the `TLine` class. - Line *43*: fits the *f* function ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:4069,intuit,intuitive,4069,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['intuit'],['intuitive']
Usability,"nd the objects, previously drawn or not; drawn, through the `addEntry` method. Observe how the legend is; drawn at the end: looks familiar now, right ?. - Line *55-57*: defines an arrow with a triangle on the right hand; side, a thickness of 2 and draws it. - Line *60-61*: interpret a Latex string which hast its lower left; corner located in the specified coordinate. The `#splitline{}{}`; construct allows to store multiple lines in the same `TLatex`; object. - Line *63*: save the canvas as image. The format is automatically; inferred from the file extension (it could have been eps, gif, ...). Let's give a look to the obtained plot in Figure [3.1](#f31). Beautiful; outcome for such a small bunch of lines, isn't it ?. [f31]: figures/graf_with_law.png ""f31""; <a name=""f31""></a>. ![Your first plot with data points, a fit of an analytical function, a; legend and some additional information in the form of graphics; primitives and text. A well formatted plot, clear for the reader is; crucial to communicate the relevance of your results to the; reader.\label{f31}][f31]. ## Summary of Visual effects. ### Colours and Graph Markers. We have seen that to specify a colour, some identifiers like kWhite,; kRed or kBlue can be specified for markers, lines, arrows etc. The; complete summary of colours is represented by the ROOT ""[colour; wheel](https://root.cern.ch/doc/master/classTColor.html#C02)"". To know more; about the full story, refer to the online documentation of `TColor`. ROOT provides several [graphics; markers](https://root.cern.ch/doc/master/classTAttMarker.html#M2) types. Select; the most suited symbols for your plot among dots, triangles, crosses or; stars. An alternative set of names for the markers is available. ### Arrows and Lines. The macro line *55* shows how to define an arrow and draw it. The class; representing arrows is `TArrow`, which inherits from `TLine`. The; constructors of lines and arrows always contain the coordinates of the; endpoints. Arrows also fore",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:6861,clear,clear,6861,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['clear'],['clear']
Usability,"nd to interpret and; print the records in a way that is meaningful to the user (normally a C++; include file or a textual list of warnings, options, and error messages). TableGen is used by both LLVM, Clang, and MLIR with very different goals.; LLVM uses it as a way to automate the generation of massive amounts of; information regarding instructions, schedules, cores, and architecture; features. Some backends generate output that is consumed by more than one; source file, so they need to be created in a way that makes it is easy for; preprocessor tricks to be used. Some backends can also print C++ code; structures, so that they can be directly included as-is. Clang, on the other hand, uses it mainly for diagnostic messages (errors,; warnings, tips) and attributes, so more on the textual end of the scale. MLIR uses TableGen to define operations, operation dialects, and operation; traits. See the :doc:`TableGen Programmer's Reference <./ProgRef>` for an in-depth; description of TableGen, and the :doc:`TableGen Backend Developer's Guide; <./BackGuide>` for a guide to writing a new backend. LLVM BackEnds; =============. .. warning::; This portion is incomplete. Each section below needs three subsections:; description of its purpose with a list of users, output generated from; generic input, and finally why it needed a new backend (in case there's; something similar). Overall, each backend will take the same TableGen file type and transform into; similar output for different targets/uses. There is an implicit contract between; the TableGen files, the back-ends and their users. For instance, a global contract is that each back-end produces macro-guarded; sections. Based on whether the file is included by a header or a source file,; or even in which context of each file the include is being used, you have; todefine a macro just before including it, to get the right output:. .. code-block:: c++. #define GET_REGINFO_TARGET_DESC; #include ""ARMGenRegisterInfo.inc"". And just par",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:1355,Guid,Guide,1355,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,1,['Guid'],['Guide']
Usability,"nd; surface removal algorithms, OpenGL viewing\* or ray tracing. The method `TGeoManager::GetGeomPainter()`loads the painting library in; memory. This is generally not needed since it is called automatically by; `TGeoVolume::Draw()` as well as by few other methods setting; visualization attributes. ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ``` {.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ```. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your simple geometry and immediately; noticed a new ROOT canvas popping-up and having some more or less; strange picture inside. Here are few questions that might come:. ***`Q:`*** ""The picture is strangely rotated; where are the coordinate axes?"". ***`A:`*** If drawn in a new canvas, any view has some default; viewpoint, center of view and size. One can then perform mouse/keyboard; actions to change them:. - Mouse left-click and drag will rotate the view;. - Some keys can be pressed when the view canvas is selected: J/K; zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes; display as well as changing top or side viewpoints can be activated from; the **`TView`** context menu: right-click on the picture when no object; is selected;. ***`Q:`*** ""Every line is black! I cannot figure out what is what..."". ***`A:`*** Volumes can have different colors (those known by ROOT of; course). Think at using them after each volume creation:; `myvolume->SetLineColor(Int_t color);` otherwise everything is by; default black.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:137995,simpl,simple,137995,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"nd; visualizing CFGs. For example, the method ``CFG::dump()`` dumps a; pretty-printed version of the CFG to standard error. This is especially useful; when one is using a debugger such as gdb. For example, here is the output of; ``FooCFG->dump()``:. .. code-block:: text. [ B5 (ENTRY) ]; Predecessors (0):; Successors (1): B4. [ B4 ]; 1: x = x + 1; 2: (x > 2); T: if [B4.2]; Predecessors (1): B5; Successors (2): B3 B2. [ B3 ]; 1: x++; Predecessors (1): B4; Successors (1): B1. [ B2 ]; 1: x += 2; 2: x *= 2; Predecessors (1): B4; Successors (1): B1. [ B1 ]; 1: return x;; Predecessors (2): B2 B3; Successors (1): B0. [ B0 (EXIT) ]; Predecessors (1): B1; Successors (0):. For each block, the pretty-printed output displays for each block the number of; *predecessor* blocks (blocks that have outgoing control-flow to the given; block) and *successor* blocks (blocks that have control-flow that have incoming; control-flow from the given block). We can also clearly see the special entry; and exit blocks at the beginning and end of the pretty-printed output. For the; entry block (block B5), the number of predecessor blocks is 0, while for the; exit block (block B0) the number of successor blocks is 0. The most interesting block here is B4, whose outgoing control-flow represents; the branching caused by the sole if-statement in ``foo``. Of particular; interest is the second statement in the block, ``(x > 2)``, and the terminator,; printed as ``if [B4.2]``. The second statement represents the evaluation of; the condition of the if-statement, which occurs before the actual branching of; control-flow. Within the ``CFGBlock`` for B4, the ``Stmt*`` for the second; statement refers to the actual expression in the AST for ``(x > 2)``. Thus; pointers to subclasses of ``Expr`` can appear in the list of statements in a; block, and not just subclasses of ``Stmt`` that refer to proper C statements. The terminator of block B4 is a pointer to the ``IfStmt`` object in the AST.; The pretty-printer o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:116307,clear,clearly,116307,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['clear'],['clearly']
Usability,"ndamental assumptions about the; underlying architecture other than the ability to do branchless conditional; data updates and a lack of value prediction.; * It does not require programmers to identify all possible secret data using; static source code annotations or code vulnerable to a variant #1 style; attack. Limitations of this approach:; * It requires re-compiling source code to insert hardening instruction; sequences. Only software compiled in this mode is protected.; * The performance is heavily dependent on a particular architecture's; implementation strategy. We outline a potential x86 implementation below and; characterize its performance.; * It does not defend against secret data already loaded from memory and; residing in registers or leaked through other side-channels in; non-speculative execution. Code dealing with this, e.g cryptographic; routines, already uses constant-time algorithms and code to prevent; side-channels. Such code should also scrub registers of secret data following; [these; guidelines](https://github.com/HACS-workshop/spectre-mitigations/blob/master/crypto_guidelines.md).; * To achieve reasonable performance, many loads may not be checked, such as; those with compile-time fixed addresses. This primarily consists of accesses; at compile-time constant offsets of global and local variables. Code which; needs this protection and intentionally stores secret data must ensure the; memory regions used for secret data are necessarily dynamic mappings or heap; allocations. This is an area which can be tuned to provide more comprehensive; protection at the cost of performance.; * [Hardened loads](#hardening-the-address-of-the-load) may still load data from; _valid_ addresses if not _attacker-controlled_ addresses. To prevent these; from reading secret data, the low 2gb of the address space and 2gb above and; below any executable pages should be protected. Credit:; * The core idea of tracing misspeculation through data and marking pointers to; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:7074,guid,guidelines,7074,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['guid'],['guidelines']
Usability,"nder `clang/tools/clang-format/clang-format.py`. This can be integrated by adding the following to your `.vimrc`:. .. code-block:: vim. if has('python'); map <C-K> :pyf <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; elseif has('python3'); map <C-K> :py3f <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; endif. The first line enables :program:`clang-format` for NORMAL and VISUAL mode, the; second line adds support for INSERT mode. Change ""C-K"" to another binding if; you need :program:`clang-format` on a different key (C-K stands for Ctrl+k). With this integration you can press the bound key and clang-format will; format the current line in NORMAL and INSERT mode or the selected region in; VISUAL mode. The line or region is extended to the next bigger syntactic; entity. It operates on the current, potentially unsaved buffer and does not create; or save any files. To revert a formatting, just undo. An alternative option is to format changes when saving a file and thus to; have a zero-effort integration into the coding workflow. To do this, add this to; your `.vimrc`:. .. code-block:: vim. function! Formatonsave(); let l:formatdiff = 1; pyf <path-to-this-file>/clang-format.py; endfunction; autocmd BufWritePre *.h,*.cc,*.cpp call Formatonsave(). Emacs Integration; =================. Similar to the integration for :program:`vim`, there is an integration for; :program:`emacs`. It can be found at `clang/tools/clang-format/clang-format.el`; and used by adding this to your `.emacs`:. .. code-block:: common-lisp. (load ""<path-to-clang>/tools/clang-format/clang-format.el""); (global-set-key [C-M-tab] 'clang-format-region). This binds the function `clang-format-region` to C-M-tab, which then formats the; current line or selected region. BBEdit Integration; ==================. :program:`clang-format` cannot be used as a text filter with BBEdit, but works; well via a script.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:7604,undo,undo,7604,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['undo'],['undo']
Usability,"nderlying data itself. A requirement is that if data is loaded and then saved again (called a ""round trip""), the memory contents should be the same after the store as before the load. If a vector is loaded and is then bitconverted to a different vector type before storing, the round trip will currently be broken. Take for example this code sequence::. %0 = load <4 x i32> %x; %1 = bitcast <4 x i32> %0 to <2 x i64>; store <2 x i64> %1, <2 x i64>* %y. This would produce a code sequence such as that in the figure on the right. The mismatched ``LD1`` and ``ST1`` cause the stored data to differ from the loaded data. .. container:: clearer. When we see a bitcast from type ``X`` to type ``Y``, what we need to do is to change the in-register representation of the data to be *as if* it had just been loaded by a ``LD1`` of type ``Y``. .. image:: ARM-BE-bitcastsuccess.png; :align: right. Conceptually this is simple - we can insert a ``REV`` undoing the ``LD1`` of type ``X`` (converting the in-register representation to the same as if it had been loaded by ``LDR``) and then insert another ``REV`` to change the representation to be as if it had been loaded by an ``LD1`` of type ``Y``. For the previous example, this would be::. LD1 v0.4s, [x]. REV64 v0.4s, v0.4s // There is no REV128 instruction, so it must be synthesizedcd; EXT v0.16b, v0.16b, v0.16b, #8 // with a REV64 then an EXT to swap the two 64-bit elements. REV64 v0.2d, v0.2d; EXT v0.16b, v0.16b, v0.16b, #8. ST1 v0.2d, [y]. It turns out that these ``REV`` pairs can, in almost all cases, be squashed together into a single ``REV``. For the example above, a ``REV128 4s`` + ``REV128 2d`` is actually a ``REV64 4s``, as shown in the figure on the right. .. [1] One lane vectors may seem useless as a concept but they serve to distinguish between values held in general purpose registers and values held in NEON/VFP registers. For example, an ``i64`` would live in an ``x`` register, but ``<1 x i64>`` would live in a ``d`` register.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst:10944,simpl,simple,10944,interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,2,"['simpl', 'undo']","['simple', 'undoing']"
Usability,"nding, enhancing, or bug fixing already implemented code,; use the style that is already being used so that the source is uniform and; easy to follow.**. Note that some code bases (e.g. ``libc++``) have special reasons to deviate; from the coding standards. For example, in the case of ``libc++``, this is; because the naming and other conventions are dictated by the C++ standard. There are some conventions that are not uniformly followed in the code base; (e.g. the naming convention). This is because they are relatively new, and a; lot of code was written before they were put in place. Our long term goal is; for the entire codebase to follow the convention, but we explicitly *do not*; want patches that do large-scale reformatting of existing code. On the other; hand, it is reasonable to rename the methods of a class if you're about to; change it in some other way. Please commit such changes separately to; make code review easier. The ultimate goal of these guidelines is to increase the readability and; maintainability of our common source base. Languages, Libraries, and Standards; ===================================. Most source code in LLVM and other LLVM projects using these coding standards; is C++ code. There are some places where C code is used either due to; environment restrictions, historical restrictions, or due to third-party source; code imported into the tree. Generally, our preference is for standards; conforming, modern, and portable C++ code as the implementation language of; choice. For automation, build-systems and utility scripts Python is preferred and; is widely used in the LLVM repository already. C++ Standard Versions; ---------------------. Unless otherwise documented, LLVM subprojects are written using standard C++17; code and avoid unnecessary vendor-specific extensions. Nevertheless, we restrict ourselves to features which are available in the; major toolchains supported as host compilers (see :doc:`GettingStarted` page,; section `Software`).",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:1620,guid,guidelines,1620,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['guid'],['guidelines']
Usability,"nding, so the `RooAbsRootFinder` is removed. In the rare case where you; might have used it, please ROOT's other functionalities: RooFit is not for; root finding.; 4. The `RooFormula` class, which was not meant as a user-facing class, but as a; shared implementation detail of `RooFormulaVar` and `RooGenericPdf`.; 5. The `RooIntegratorBinding`, which was an implementation detail of the; `RooIntegrator2D` and `RooSegmentedIntegrator2D` classes.; 6. The `RooRealAnalytic`, which was an implementation detail of the; `RooRealIntegral` class. ### Consistent default for `Extended()` command in RooAbsPdf::fitTo() and RooAbsPdf::chi2FitTo(). If no `RooFit::Extended()` command argument is passed, `RooAbsPdf::chi2FitTo()`; method now does an extended fit by default if the pdf is extendible. This makes; the behavior consistent with `RooAbsPdf::fitTo()`. Same applies to; `RooAbsPdf::createChi2()`. ## TMVA; ### SOFIE : Code generation for fast inference of Deep Learning models; TMVA SOFIE now supports parsing and further inference of Graph Neural Networks based on DeepMind's [graph_nets](https://github.com/google-deepmind/graph_nets). The list of all operators supported in the `RModel` class is the one provided below for the ONNX parser. #### SOFIE-GNN; 1. The SOFIE-GNN implementation brought a major change in SOFIE's architecture. Instead of having only the RModel class to store model information, now SOFIE has RModel, RModel_GNN and RModel_GraphIndependent classes which are inherited from RModel_Base.; 2. **RModel_GNN** is used to store a GNN model having nodes, edges, and globals with functions for their update and aggregate(for inter-relationships).; 3. **RModel_GraphIndependent** is used to store an independent Graph model with nodes, edges and globals with their individual update functions.; 4. **RFunctions** are used to declare update/aggregate operations over graph components. Currently supported RFunctions include:; - **Update Functions**; - RFunction_MLP; - **Aggregate Fu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:16804,Learn,Learning,16804,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['Learn'],['Learning']
Usability,"ndows for all kinds of web widgets; - Provide `rootssh` shell script to simplify use of web-based widgets on remote nodes:; ```; [localnode] rootssh user@remotenode; [remotenode] root --web -e 'new TBrowser'; ```; Script automatically configures ssh tunnel between local and remote nodes, one the remote node; unix socket with strict 0700 mode is used. When ROOT running on remote node wants to display; new web widget, script will automatically start web browser on local node with appropriate URL,; accessing widget via configured ssh tunnel. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. - Major JSROOT upgrade to version 7, using ES6 modules and classes. ## Tutorials. - Several new tutorials have been added in both C++ and Python in the `tutorial/tmva` directory.; Tutorials like `TMVA_Higgs_Classification.py` shows the new pythonizations available in TMVA and; new `TMVA_SOFIE_...` tutorials show th eusage of SOFIE in both C++ or Python. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - Building external applications that use ROOT oftentimes fail if there is a mismatch in the C++ standard between ROOT and the application. As of v6.28, suchs builds will issue a warning if the C++ standard does not match ROOT's, i.e. if there is a mismatch in the value of the `__cplusplus` preprocessor macro w.r.t. when ROOT was configured. ## PyROOT. - A `.rootlogon.py` file will be searched both in the current working directory and in the user's home directory. This; file is the Python equivalent of `rootlogon.C` and can be used to tweak ROOT settings when using PyROOT.; - A new pythonization for `TFile` now enables its usage as a Python context manager:; ```python; from ROOT import TFile; with TFile(""file1.root"", ""recreate"") as outfile:; hout = ROOT.TH1F(...); outfile.WriteObject(hout, ""myhisto""); ```; - A new pythonization for `TDirectory::TContext` now enables its usage as a Python context manager:; ```python; with",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:33201,Guid,Guide,33201,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['Guid'],['Guide']
Usability,"ndows for querying debug information from; PDBs even without the user understanding the internals of the file format, a; large ecosystem of tools has been built for Windows to consume this format. In; order for Clang to be able to generate programs that can interoperate with these; tools, it is necessary for us to generate PDB files ourselves. At the same time, LLVM has a long history of being able to cross-compile from; any platform to any platform, and we wish for the same to be true here. So it; is necessary for us to understand the PDB file format at the byte-level so that; we can generate PDB files entirely on our own. This manual describes what we know about the PDB file format today. The layout; of the file, the various streams contained within, the format of individual; records within, and more. We would like to extend our heartfelt gratitude to Microsoft, without whom we; would not be where we are today. Much of the knowledge contained within this; manual was learned through reading code published by Microsoft on their `GitHub; repo <https://github.com/Microsoft/microsoft-pdb>`__. .. _pdb_layout:. File Layout; ===========. .. important::; Unless otherwise specified, all numeric values are encoded in little endian.; If you see a type such as ``uint16_t`` or ``uint64_t`` going forward, always; assume it is little endian!. .. toctree::; :hidden:. MsfFile; PdbStream; TpiStream; DbiStream; ModiStream; PublicStream; GlobalStream; HashTable; CodeViewSymbols; CodeViewTypes. .. _msf:. The MSF Container; -----------------; A PDB file is an MSF (Multi-Stream Format) file. An MSF file is a ""file system; within a file"". It contains multiple streams (aka files) which can represent; arbitrary data, and these streams are divided into blocks which may not; necessarily be contiguously laid out within the MSF container file.; Additionally, the MSF contains a stream directory (aka MFT) which describes how; the streams (files) are laid out within the MSF. For more information a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/index.rst:1345,learn,learned,1345,interpreter/llvm-project/llvm/docs/PDB/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/index.rst,1,['learn'],['learned']
Usability,"nds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Inside the for-loop, ``0 <= i < count``, hence ``1 <= i + 1 <= count``.; * Pointer arithmetic ``p + count`` in the if-condition doesn’t wrap.; * ``-fbounds-safety`` treats pointer arithmetic overflow as deterministically; two’s complement computation, not an undefined behavior. Therefore,; getelementptr does not typically have inbounds keyword. However, the compiler; does emit inbounds for ``p + count`` in this case because; ``__counted_by(count)`` has the invariant that p has at least as many as; elements as count. Using this information, ``ConstraintElimination`` is able; to determine ``p + count`` doesn’t wrap.; * Accordingly, ``p + i`` and ``p + i + 1`` also don’t wrap.; * Therefore, ``p <= p + i`` and ``p + i + 1 <= p + count``.; * The if-condition simplifies to false and becomes dead code that the subsequent; optimization passes can remove. ``OptRemarks`` can be utilized to provide insights into performance tuning. It; has the capability to report on checks that it cannot eliminate, possibly with; reasons, allowing programmers to adjust their code to unlock further; optimizations. Debugging; =========. Internal bounds annotations; ---------------------------. Internal bounds annotations change a pointer into a wide pointer. The debugger; needs to understand that wide pointers are essentially pointers with a struct; layout. To handle this, a wide pointer is described as a record type in the; debug info. The type name has a special name prefix (e.g.,; ``__bounds_safety$bidi_indexable``) which can be recognized by a debug info; consumer to provide support that goes beyond showing the internal structure of; the wide pointer. There are no DWARF extensions needed to support wide pointers.; In our implementation, LLDB recognizes wide pointer types by name and; reconstruct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:7860,simpl,simplifies,7860,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['simpl'],['simplifies']
Usability,"ne that has more than one suspend point:. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend>; print(-n);; <suspend>; }; }. Matching LLVM code would look like (with the rest of the code remaining the same; as the code in the previous section):. .. code-block:: llvm. loop:; %n.addr = phi i32 [ %n, %entry ], [ %inc, %loop.resume ]; call void @print(i32 %n.addr) #4; %2 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %2, label %suspend [i8 0, label %loop.resume; i8 1, label %cleanup]; loop.resume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; loop:; %inc = add nsw i32 %n, 1; store i32 %inc, ptr %n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code needs to get executed for different suspend points,; a similar switch will be in the `f.destroy` function. .. note ::. Using suspend index in a coroutine state and having a switch in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:18996,resume,resume,18996,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ne to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2039,simpl,simplified,2039,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['simpl'],['simplified']
Usability,"ne. Matcher<CXXMethodDecl>isOverride; Matches if the given method declaration overrides another method. Given; class A {; public:; virtual void x();; };; class B : public A {; public:; virtual void x();; };; matches B::x. Matcher<CXXMethodDecl>isPure; Matches if the given method declaration is pure. Given; class A {; public:; virtual void x() = 0;; };; matches A::x. Matcher<CXXMethodDecl>isUserProvided; Matches method declarations that are user-provided. Given; struct S {; S(); // #1; S(const S &) = default; // #2; S(S &&) = delete; // #3; };; cxxConstructorDecl(isUserProvided()) will match #1, but not #2 or #3. Matcher<CXXMethodDecl>isVirtual; Matches declarations of virtual methods and C++ base specifers that specify; virtual inheritance. Example:; class A {; public:; virtual void x(); // matches x; };. Example:; class Base {};; class DirectlyDerived : virtual Base {}; // matches Base; class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base. Usable as: Matcher<CXXMethodDecl>, Matcher<CXXBaseSpecifier>. Matcher<CXXMethodDecl>isVirtualAsWritten; Matches if the given method declaration has an explicit ""virtual"". Given; class A {; public:; virtual void x();; };; class B : public A {; public:; void x();; };; matches A::x but not B::x. Matcher<CXXNewExpr>isArray; Matches array new expressions. Given:; MyClass *p1 = new MyClass[10];; cxxNewExpr(isArray()); matches the expression 'new MyClass[10]'. Matcher<CXXOperatorCallExpr>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator expressions (binary or unary) that have any of the; specified names. hasAnyOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOperatorName(""+""), hasOperatorName(""-"")). Matcher<CXXOperatorCallExpr>hasAnyOverloadedOperatorNameStringRef, ..., StringRef; Matches overloaded operator names. Matches overloaded operator names specified in strings without the; ""operator"" prefix: e.g. ""<<"". hasAnyOverloadedOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOverloadedOperatorName(""+""), ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:70273,Usab,Usable,70273,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,ne/Orc/Layer.cpp; llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp; llvm/lib/ExecutionEngine/Orc/LookupAndRecordAddrs.cpp; llvm/lib/ExecutionEngine/Orc/Mangling.cpp; llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp; llvm/lib/ExecutionEngine/Orc/ObjectTransformLayer.cpp; llvm/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp; llvm/lib/ExecutionEngine/Orc/Speculation.cpp; llvm/lib/ExecutionEngine/Orc/TaskDispatch.cpp; llvm/lib/ExecutionEngine/Orc/Shared/AllocationActions.cpp; llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp; llvm/lib/ExecutionEngine/Orc/Shared/OrcRTBridge.cpp; llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/OrcRTBootstrap.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/OrcRTBootstrap.h; llvm/lib/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorDylibManager.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/TargetExecutionUtils.cpp; llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldCOFF.h; llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h; llvm/lib/FileCheck/FileCheckImpl.h; llvm/lib/Frontend/OpenACC/ACC.cpp; llvm/lib/Frontend/OpenMP/OMP.cpp; llvm/lib/Frontend/OpenMP/OMPContext.cpp; llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp; llvm/lib/FuzzMutate/OpDescriptor.cpp; llvm/lib/FuzzMutate/RandomIRBuilder.cpp; llvm/lib/InterfaceStub/ELFObjHandler.cpp; llvm/lib/InterfaceStub/IFSHandler.cpp; llvm/lib/InterfaceStub/IFSStub.cpp; llvm/lib/IR/Assumptions.cpp; llvm/lib/IR/Comdat.cpp; llvm/lib/IR/DebugInfoMetadata.cpp; llvm/lib/IR/DebugLoc.cpp; llvm/lib/IR/DIBuilder.cpp; llvm/lib/IR/FPEnv.cpp; llvm/lib/IR/GCStrategy.cpp; llvm/lib/IR/GVMaterializer.cpp; llvm/lib/IR/LLVMContextImpl.h; llvm/lib/IR/MetadataImpl.h; llvm/lib/IR/OptBisect.cpp; llvm/lib/IR/PassInstrumentation.cpp; llvm/lib/IR/PassManager.cpp; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:288467,Simpl,SimpleExecutorMemoryManager,288467,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimpleExecutorMemoryManager']
Usability,"ne`. - A coroutine object can be resumed normally if it has not already reached; completion with `llvm.coro.resume`. - A coroutine object can be destroyed, invalidating the coroutine object,; with `llvm.coro.destroy`. This must be done separately even if the; coroutine has reached completion normally. - ""Promise"" storage, which is known to have a certain size and alignment,; can be projected out of the coroutine object with `llvm.coro.promise`.; The coroutine implementation must have been compiled to define a promise; of the same size and alignment. In general, interacting with a coroutine object in any of these ways while; it is running has undefined behavior. The coroutine function is split into three functions, representing three; different ways that control can enter the coroutine:. 1. the ramp function that is initially invoked, which takes arbitrary; arguments and returns a pointer to the coroutine object;. 2. a coroutine resume function that is invoked when the coroutine is resumed,; which takes a pointer to the coroutine object and returns `void`;. 3. a coroutine destroy function that is invoked when the coroutine is; destroyed, which takes a pointer to the coroutine object and returns; `void`. Because the resume and destroy functions are shared across all suspend; points, suspend points must store the index of the active suspend in; the coroutine object, and the resume/destroy functions must switch over; that index to get back to the correct point. Hence the name of this; lowering. Pointers to the resume and destroy functions are stored in the coroutine; object at known offsets which are fixed for all coroutines. A completed; coroutine is represented with a null resume function. There is a somewhat complex protocol of intrinsics for allocating and; deallocating the coroutine object. It is complex in order to allow the; allocation to be elided due to inlining. This protocol is discussed; in further detail below. The frontend may generate code to call the coro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:3991,resume,resume,3991,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,['resume'],"['resume', 'resumed']"
Usability,"ned int. Float16 = 0x0046, // 16 bit real; Float32 = 0x0040, // 32 bit real; Float32PartialPrecision = 0x0045, // 32 bit PP real; Float48 = 0x0044, // 48 bit real; Float64 = 0x0041, // 64 bit real; Float80 = 0x0042, // 80 bit real; Float128 = 0x0043, // 128 bit real. Complex16 = 0x0056, // 16 bit complex; Complex32 = 0x0050, // 32 bit complex; Complex32PartialPrecision = 0x0055, // 32 bit PP complex; Complex48 = 0x0054, // 48 bit complex; Complex64 = 0x0051, // 64 bit complex; Complex80 = 0x0052, // 80 bit complex; Complex128 = 0x0053, // 128 bit complex. Boolean8 = 0x0030, // 8 bit boolean; Boolean16 = 0x0031, // 16 bit boolean; Boolean32 = 0x0032, // 32 bit boolean; Boolean64 = 0x0033, // 64 bit boolean; Boolean128 = 0x0034, // 128 bit boolean; };. - **Mode** - A value from the following enum:. .. code-block:: c++. enum class SimpleTypeMode : uint32_t {; Direct = 0, // Not a pointer; NearPointer = 1, // Near pointer; FarPointer = 2, // Far pointer; HugePointer = 3, // Huge pointer; NearPointer32 = 4, // 32 bit near pointer; FarPointer32 = 5, // 32 bit far pointer; NearPointer64 = 6, // 64 bit near pointer; NearPointer128 = 7 // 128 bit near pointer; };. Note that for pointers, the bitness is represented in the mode. So a ``void*``; would have a type index with ``Mode=NearPointer32, Kind=Void`` if built for; 32-bits but a type index with ``Mode=NearPointer64, Kind=Void`` if built for; 64-bits. By convention, the type index for ``std::nullptr_t`` is constructed the same; way as the type index for ``void*``, but using the bitless enumeration value; ``NearPointer``. .. _tpi_header:. Stream Header; =============; At offset 0 of the TPI Stream is a header with the following layout:. .. code-block:: c++. struct TpiStreamHeader {; uint32_t Version;; uint32_t HeaderSize;; uint32_t TypeIndexBegin;; uint32_t TypeIndexEnd;; uint32_t TypeRecordBytes;. uint16_t HashStreamIndex;; uint16_t HashAuxStreamIndex;; uint32_t HashKeySize;; uint32_t NumHashBuckets;. int32_t HashValueBuffe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst:6615,Simpl,SimpleTypeMode,6615,interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst,1,['Simpl'],['SimpleTypeMode']
Usability,"need anymore for the special version we had up to now. The; modifications we needed have been introduced in the official version.; This version also fixes the color problem on BigEndian machines.; On these machines (Mac and Solaris for instance) the color of the jpeg; and png images saved from the ""File"" menu in a TCanvas were; completely wrong.; Addition for image pixelization and color to alpha functionality.; Fixed bunch of compilation bugs showing up on old systems. Graphical Output; PDF. Text rotated at 270 degrees was not correct. The PDF rotation matrix; contained very small values close to 0 instead of 0. Acrobat reader; produced a wrong output and also printed result was wrong.; ""gv"" worked. PostScript. The character ""@"" could not be printed in PostScript files.; Change the Page numbering to make it appear nicer in postcript viewers; like ""gv"". It is compliant with the Adobe Postscript Document; Structuring Conventions (easily found on the web).; The fonts encoding has been simplified (use ISOLatin1Encoding). The new; way allows to print any character with accent etc.. like on the screen.; The new encoding was done by Pierre Juillot. TPad. In batch mode it was not possible to generate a bitmap file (gif,; jpeg etc..) with a filename containing "")"",; ""("", ""]"" or ""["".; The Tickx and Tixky attributes were not saved properly by SavePrimitive.; PaintPolyLineNDC was not working in case of PS output.; In ExecuteEvent. A problem was found Mathieu de Naurois; <denauroi@in2p3.fr>.; It can be reproduced by the following sequence:; ; do TCanvas c; do c->Divide(2,2); show the toolbar; click L to enter text; click on a pad to enter text; move the mouse without releasing the button.; entex text; hit Enter.; ; Before this bug fix, the canvas position changed on ""hit Enter"".; On a Windows dual core machine, the WaitPrimitive call returned; immediately. Miscellaneous; TView3D. Protection was missing in ctors in case gPad does not exits.; Allow interactive zooming on histogram",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html:2748,simpl,simplified,2748,graf2d/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html,1,['simpl'],['simplified']
Usability,"need to add code to your node's case statement in ``LegalizeOp``; to Promote your node's operands to a larger size, and perform the correct; operation. You will also need to add code to ``PromoteOp`` to do this as; well. For a good example, see ``ISD::BSWAP``, which promotes its operand to; a wider size, performs the byteswap, and then shifts the correct bytes right; to emulate the narrower byteswap in the wider type. #. ``lib/CodeGen/SelectionDAG/LegalizeDAG.cpp``:. Add a case for your node in ``ExpandOp`` to teach the legalizer how to; perform the action represented by the new node on a value that has been split; into high and low halves. This case will be used to support your node with a; 64 bit operand on a 32 bit target. #. ``lib/CodeGen/SelectionDAG/DAGCombiner.cpp``:. If your node can be combined with itself, or other existing nodes in a; peephole-like fashion, add a visit function for it, and call that function; from. There are several good examples for simple combines you can do;; ``visitFABS`` and ``visitSRL`` are good starting places. #. ``lib/Target/PowerPC/PPCISelLowering.cpp``:. Each target has an implementation of the ``TargetLowering`` class, usually in; its own file (although some targets include it in the same file as the; DAGToDAGISel). The default behavior for a target is to assume that your new; node is legal for all types that are legal for that target. If this target; does not natively support your node, then tell the target to either Promote; it (if it is supported at a larger type) or Expand it. This will cause the; code you wrote in ``LegalizeOp`` above to decompose your new node into other; legal nodes for this target. #. ``include/llvm/Target/TargetSelectionDAG.td``:. Most current targets supported by LLVM generate code using the DAGToDAG; method, where SelectionDAG nodes are pattern matched to target-specific; nodes, which represent individual instructions. In order for the targets to; match an instruction to your new node, you must add ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst:6345,simpl,simple,6345,interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst,1,['simpl'],['simple']
Usability,"new TGLayoutHints(kLHintsCenterX,2,2,2,2));. // Sets window name and shows the main frame; SetWindowName(""Simple Example"");; MapSubwindows();; Resize(GetDefaultSize());; MapWindow();; }; ```. ## Widgets Overview. The word widget is a contraction of windows and gadget. Almost all GUI; elements are widgets. A button is a widget, a menu item is a widget, a; scrollbar is a widget, and a complete dialog box is a widget too. Some; widgets may have sub widgets. For example, a dialog box can contain; buttons, text fields, a combo-box, etc. On the screen widgets look like rectangular areas with special; behaviors. In terms of the object-oriented programming we can define a; widget in ROOT as an object of a class deriving from **`TGObject`**. This section presents all currently supported widgets in ROOT and their; most useful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub classing existing widgets. To; achieve a better understanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:20449,guid,guidelines,20449,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['guid'],['guidelines']
Usability,"new value to hold the initial value of the array; access for the first iteration, and then creating a new GEP instruction in the; loop to increment the value by the appropriate amount. .. _passes-loop-rotate:. ``loop-rotate``: Rotate Loops; -----------------------------. A simple loop rotation transformation. A summary of it can be found in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. This pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize generated code. This pass obviously modifies the CFG, but updates loop information and; dominator information. ``loop-unroll``: Unroll loops; -----------------------------. This pass implements a simple loop unroller. It works best when loops have; been canonicalized by the :ref:`indvars <passes-indvars>` pass, allowing it to; determine the trip counts of loops easily. ``loop-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:27114,simpl,simplifies,27114,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplifies']
Usability,"nfrastructure. LLVM Reference; --------------. ======================; Command Line Utilities; ======================. :doc:`LLVM Command Guide <CommandGuide/index>`; A reference manual for the LLVM command line utilities (""man"" pages for LLVM; tools). :doc:`Bugpoint`; Automatic bug finder and test-case reducer description and usage; information. :doc:`OptBisect`; A command line option for debugging optimization-induced failures. :doc:`SymbolizerMarkupFormat`; A reference for the log symbolizer markup accepted by ``llvm-symbolizer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection support. =========; LibFuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describes the file format and encoding used for LLVM ""bc"" files. :doc:`Machine IR (MIR) Format Reference Manual <MIRLangRef>`; A reference manual for the MIR serialization format, which is used to test; LLVM's code generation passes. :doc:`GlobalISel/index`; This describes the prototype instruction selection replacement, GlobalISel. :doc:`ConvergentOperations`; Description of ``convergent`` operation semantics and related intrinsics. =====================; Testing and Debugging; =====================. :doc:`LLVM Testing Infrastructure Guide <TestingGuide>`; A reference manual for using the LLVM testing infrast",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:2093,guid,guided,2093,interpreter/llvm-project/llvm/docs/Reference.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst,1,['guid'],['guided']
Usability,"ng -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compatibility. GCC is currently the defacto-standard open source compiler today, and it; routinely compiles a huge volume of code. GCC supports a huge number of; extensions and features (many of which are undocumented) and a lot of; code and header files depend on these features in order to build.; While it would be nice to be able to ignore these extensions and focus on; implementing the language standards to the letter, pragmatics force us to; support the GCC extensions that see the most use. Many users just want their; code to compile, they don't care to argue about whether it is pedantically C99; or not.; As mentioned above, all; extensions are explicitly recognized as such and marked with extension; diagnostics, which can be mapped to warnings, errors, or just ignored. Utility and Applications. Library Based Architecture. A major design concept for clang is its use of a library-based; architecture. In this design, various parts of the front-end can be cleanly; divided into separate libraries which can then be mixed up for different needs; and uses. In addition, the library-based approach encourages good interfaces; and makes it easier for new developers to get involved (because they only ne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:3217,undo,undocumented,3217,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['undo'],['undocumented']
Usability,"ng ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation un",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:23328,simpl,simply,23328,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simply']
Usability,"ng a primary operator, we eat the operator as a; prefix and parse the remaining piece as another unary operator. This; allows us to handle multiple unary operators (e.g. ""!!x""). Note that; unary operators can't have ambiguous parses like binary operators can,; so there is no need for precedence information. The problem with this function, is that we need to call ParseUnary from; somewhere. To do this, we change previous callers of ParsePrimary to; call ParseUnary instead:. .. code-block:: c++. /// binoprhs; /// ::= ('+' unary)*; static std::unique_ptr<ExprAST> ParseBinOpRHS(int ExprPrec,; std::unique_ptr<ExprAST> LHS) {; ...; // Parse the unary expression after the binary operator.; auto RHS = ParseUnary();; if (!RHS); return nullptr;; ...; }; /// expression; /// ::= unary binoprhs; ///; static std::unique_ptr<ExprAST> ParseExpression() {; auto LHS = ParseUnary();; if (!LHS); return nullptr;. return ParseBinOpRHS(0, std::move(LHS));; }. With these two simple changes, we are now able to parse unary operators; and build the AST for them. Next up, we need to add parser support for; prototypes, to parse the unary operator prototype. We extend the binary; operator code above with:. .. code-block:: c++. /// prototype; /// ::= id '(' id* ')'; /// ::= binary LETTER number? (id, id); /// ::= unary LETTER (id); static std::unique_ptr<PrototypeAST> ParsePrototype() {; std::string FnName;. unsigned Kind = 0; // 0 = identifier, 1 = unary, 2 = binary.; unsigned BinaryPrecedence = 30;. switch (CurTok) {; default:; return LogErrorP(""Expected function name in prototype"");; case tok_identifier:; FnName = IdentifierStr;; Kind = 0;; getNextToken();; break;; case tok_unary:; getNextToken();; if (!isascii(CurTok)); return LogErrorP(""Expected unary operator"");; FnName = ""unary"";; FnName += (char)CurTok;; Kind = 1;; getNextToken();; break;; case tok_binary:; ... As with binary operators, we name unary operators with a name that; includes the operator character. This assists us at code gener",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:12724,simpl,simple,12724,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"ng column of the first mapping region in this function. |; +----------+-------------------------------------------------------------------------------------------------------------------------+; | ``0x02`` | The ending line of the first mapping region in this function. |; +----------+-------------------------------------------------------------------------------------------------------------------------+; | ``0x02`` | The ending column of the first mapping region in this function. |; +----------+-------------------------------------------------------------------------------------------------------------------------+. * The length of the substring that contains the encoded coverage mapping data; for the second function record is also 9. It's structured like the mapping data; for the first function record. * The two trailing bytes are zeroes and are used to pad the coverage mapping; data to give it the 8 byte alignment. Encoding; ========. The per-function coverage mapping data is encoded as a stream of bytes,; with a simple structure. The structure consists of the encoding; `types <cvmtypes_>`_ like variable-length unsigned integers, that; are used to encode `File ID Mapping`_, `Counter Expressions`_ and; the `Mapping Regions`_. The format of the structure follows:. ``[file id mapping, counter expressions, mapping regions]``. The translation unit filenames are encoded using the same encoding; `types <cvmtypes_>`_ as the per-function coverage mapping data, with the; following structure:. ``[numFilenames : LEB128, filename0 : string, filename1 : string, ...]``. .. _cvmtypes:. Types; -----. This section describes the basic types that are used by the encoding format; and can appear after ``:`` in the ``[foo : type]`` description. .. _LEB128:. LEB128; ^^^^^^. LEB128 is an unsigned integer value that is encoded using DWARF's LEB128; encoding, optimizing for the case where values are small; (1 byte for values less than 128). .. _CoverageStrings:. Strings; ^^^^^^^. ``[length",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst:22228,simpl,simple,22228,interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,1,['simpl'],['simple']
Usability,ng for deduction from a type; Not resolved. 2426; C++20; Reference to destructor that cannot be invoked; Unknown. 2427; C++20; Deprecation of volatile operands and unevaluated contexts; Unknown. 2428; C++23; Deprecating a concept; Unknown. 2429; C++20; Initialization of thread_local variables referenced by lambdas; Unknown. 2430; C++20; Completeness of return and parameter types of member functions; Unknown. 2431; C++20; Full-expressions and temporaries bound to references; Unknown. 2432; C++20; Return types for defaulted <=>; Unknown. 2433; C++20; Variable templates in the ODR; Unknown. 2434; open; Mandatory copy elision vs non-class objects; Not resolved. 2435; open; Alias template specializations; Not resolved. 2436; C++20; Copy semantics of coroutine parameters; Unknown. 2437; C++20; Conversion of std::strong_ordering in a defaulted operator<=>; Unknown. 2438; open; Problems in the specification of qualification conversions; Not resolved. 2439; C++20; Undefined term in definition of “usable in constant expressions”; Unknown. 2440; C++23; Allocation in core constant expressions; Unknown. 2441; C++20; Inline function parameters; Unknown. 2442; C++20; Incorrect requirement for default arguments; Unknown. 2443; C++23; Meaningless template exports; Unknown. 2444; drafting; Constant expressions in initialization odr-use; Not resolved. 2445; C++20; Partial ordering with rewritten candidates; Unknown. 2446; C++20; Questionable type-dependency of concept-ids; Unknown. 2447; C++20; Unintended description of abbreviated function templates; Unknown. 2448; CD6; Cv-qualification of arithmetic types and deprecation of volatile; Unknown. 2449; extension; Thunks as an implementation technique for pointers to virtual functions; Extension. 2450; review; braced-init-list as a template-argument; Clang 18. 2451; C++23; promise.unhandled_exception() and final suspend point; Unknown. 2452; CD6; Flowing off the end of a coroutine; Unknown. 2453; NAD; Deduced return types and coroutine l,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:166984,usab,usable,166984,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['usab'],['usable']
Usability,"ng is a code snippet from `RooPoisson` *after* it has AD support. ### Step 1. Refactor the `RooPoisson::evaluate()` Function. ``` {.cpp}; /// Implementation in terms of the TMath::Poisson() function. double RooPoisson::evaluate() const; {; double k = _noRounding ? x : floor(x);; if(_protectNegative && mean<0) {; RooNaNPacker np;; np.setPayload(-mean);; return np._payload;; }; return RooFit::Detail::MathFuncs::poisson(k, mean);; }; ```. Note that the `evaluate()` function was refactored in such a way that the; mathematical parts were moved to an inline function in a separate header file; named `MathFuncs`, so that Clad could see and differentiate that function.; The rest of the contents of the function remain unchanged. > All contents of the `evaluate()` function don't always need to be pulled; out, only the required parts (mathematical logic) should be moved to; `MathFuncs`. **What is MathFuncs?**. Moving away from the class-based hierarchy design, `MathFuncs.h` a simply; a flat file of function implementations. This file is required since Clad will not be able to see anything that is not; inlined and explicitly available to it during compilation (since it has to be; in the same translation). So other than of generating these functions on the; fly, your only other option is to place these functions in a separate header; file and make them inline. Theoretically, multiple header files can also be used and then mashed; together. > Directory path: [roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h](https://github.com/root-project/root/blob/master/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h). ### Step 2. Override RooAbsArg::translate(). **translate() Example 1:** Continuing our RooPoisson example:. To translate the `RooPoisson` class, create a translate function and in it; include a call to the updated function. ``` {.cpp}; void RooPoisson::translate(RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const; {; std::string xName = ctx.getResult(x);; if (!_noRounding",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:11350,simpl,simply,11350,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simply']
Usability,"ng the approach (2) - it should be possible to avoid; performance overhead, and clarity seems nice. **Gabor:**. At this point, I am a bit wondering about two questions. * When should something belong to a checker and when should something belong to the engine?; Sometimes we model library aspects in the engine and model language constructs in checkers. * What is the checker programming model that we are aiming for? Maximum freedom or more easy checker development?. I think if we aim for maximum freedom, we do not need to worry about the; potential stress on checkers, and we can introduce abstractions to mitigate that; later on.; If we want to simplify the API, then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:5499,guid,guideline,5499,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['guid'],['guideline']
Usability,ng-tidy/readability/RedundantDeclarationCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantDeclarationCheck.h; clang-tools-extra/clang-tidy/readability/RedundantMemberInitCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantMemberInitCheck.h; clang-tools-extra/clang-tidy/readability/RedundantPreprocessorCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantPreprocessorCheck.h; clang-tools-extra/clang-tidy/readability/RedundantSmartptrGetCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantSmartptrGetCheck.h; clang-tools-extra/clang-tidy/readability/RedundantStringCStrCheck.h; clang-tools-extra/clang-tidy/readability/RedundantStringInitCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantStringInitCheck.h; clang-tools-extra/clang-tidy/readability/SimplifyBooleanExprCheck.cpp; clang-tools-extra/clang-tidy/readability/SimplifyBooleanExprCheck.h; clang-tools-extra/clang-tidy/readability/SimplifyBooleanExprMatchers.h; clang-tools-extra/clang-tidy/readability/SimplifySubscriptExprCheck.cpp; clang-tools-extra/clang-tidy/readability/StaticAccessedThroughInstanceCheck.cpp; clang-tools-extra/clang-tidy/readability/StaticAccessedThroughInstanceCheck.h; clang-tools-extra/clang-tidy/readability/StaticDefinitionInAnonymousNamespaceCheck.cpp; clang-tools-extra/clang-tidy/readability/StaticDefinitionInAnonymousNamespaceCheck.h; clang-tools-extra/clang-tidy/readability/StringCompareCheck.cpp; clang-tools-extra/clang-tidy/readability/StringCompareCheck.h; clang-tools-extra/clang-tidy/readability/SuspiciousCallArgumentCheck.cpp; clang-tools-extra/clang-tidy/readability/SuspiciousCallArgumentCheck.h; clang-tools-extra/clang-tidy/readability/UniqueptrDeleteReleaseCheck.cpp; clang-tools-extra/clang-tidy/readability/UniqueptrDeleteReleaseCheck.h; clang-tools-extra/clang-tidy/readability/UppercaseLiteralSuffixCheck.cpp; clang-tools-extra/clang-tidy/readability/UppercaseLiteralSuffixCheck.h; clang-tools-extra/clang-tidy/readability/UseAnyOfAllOfCheck.,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:70938,Simpl,SimplifySubscriptExprCheck,70938,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimplifySubscriptExprCheck']
Usability,ng.h; clang/include/clang/Parse/LoopHint.h; clang/include/clang/Parse/ParseDiagnostic.h; clang/include/clang/Sema/CleanupInfo.h; clang/include/clang/Sema/SemaDiagnostic.h; clang/include/clang/Sema/TemplateInstCallback.h; clang/include/clang/Serialization/ASTBitCodes.h; clang/include/clang/Serialization/InMemoryModuleCache.h; clang/include/clang/Serialization/SerializationDiagnostic.h; clang/include/clang/StaticAnalyzer/Core/CheckerRegistryData.h; clang/include/clang/StaticAnalyzer/Core/BugReporter/CommonBugCategories.h; clang/include/clang/StaticAnalyzer/Core/PathSensitive/DynamicCastInfo.h; clang/include/clang/StaticAnalyzer/Core/PathSensitive/DynamicExtent.h; clang/include/clang/StaticAnalyzer/Core/PathSensitive/DynamicType.h; clang/include/clang/StaticAnalyzer/Core/PathSensitive/DynamicTypeInfo.h; clang/include/clang/StaticAnalyzer/Core/PathSensitive/LoopWidening.h; clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h; clang/include/clang/StaticAnalyzer/Core/PathSensitive/SimpleConstraintManager.h; clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConstraintManager.h; clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h; clang/include/clang/StaticAnalyzer/Core/PathSensitive/StoreRef.h; clang/include/clang/StaticAnalyzer/Frontend/AnalyzerHelpFlags.h; clang/include/clang/StaticAnalyzer/Frontend/FrontendActions.h; clang/include/clang/Testing/CommandLineArgs.h; clang/include/clang/Testing/TestClangConfig.h; clang/include/clang/Tooling/AllTUsExecution.h; clang/include/clang/Tooling/ArgumentsAdjusters.h; clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h; clang/include/clang/Tooling/DiagnosticsYaml.h; clang/include/clang/Tooling/Execution.h; clang/include/clang/Tooling/JSONCompilationDatabase.h; clang/include/clang/Tooling/NodeIntrospection.h; clang/include/clang/Tooling/Refactoring.h; clang/include/clang/Tooling/StandaloneExecution.h; clang/include/clang/Tooling/ToolExecutorPluginRegistry.h; clang/include/clang/,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:11123,Simpl,SimpleConstraintManager,11123,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimpleConstraintManager']
Usability,"ng:. .. code-block:: bat. c:\llvm> python ..\build\Release\bin\llvm-lit.py llvm\test. This example assumes that Python is in your PATH variable, which would be; after **Add Python to the PATH** was selected during Python installation.; If you had opened a command window prior to Python installation, you would; have to close and reopen it to get the updated PATH. A specific test or test directory can be run with:. .. code-block:: bat. c:\llvm> python ..\build\Release\bin\llvm-lit.py llvm\test\Transforms\Util. Build the LLVM Suite:; ---------------------; * The projects may still be built individually, but to build them all do; not just select all of them in batch build (as some are meant as; configuration projects), but rather select and build just the; ``ALL_BUILD`` project to build everything, or the ``INSTALL`` project,; which first builds the ``ALL_BUILD`` project, then installs the LLVM; headers, libs, and other useful things to the directory set by the; ``CMAKE_INSTALL_PREFIX`` setting when you first configured CMake.; * The Fibonacci project is a sample program that uses the JIT. Modify the; project's debugging properties to provide a numeric command line argument; or run it from the command line. The program will print the; corresponding fibonacci value. Links; =====; This document is just an **introduction** to how to use LLVM to do some simple; things... there are many more interesting and complicated things that you can; do that aren't documented here (but we'll gladly accept a patch if you want to; write something up!). For more information about LLVM, check out:. * `LLVM homepage <https://llvm.org/>`_; * `LLVM doxygen tree <https://llvm.org/doxygen/>`_; * Additional information about the LLVM directory structure and tool chain; can be found on the main :doc:`GettingStarted` page.; * If you are having problems building or using LLVM, or if you have any other; general questions about LLVM, please consult the; :doc:`Frequently Asked Questions <FAQ>` page.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:10400,simpl,simple,10400,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['simpl'],['simple']
Usability,"ngCommentHTMLNamedCharacterReferences; ----------------------------------------. Generate function to translate named character references to UTF-8 sequences. ClangCommentCommandInfo; -----------------------. Generate command properties for commands that are used in documentation comments. ClangCommentCommandList; -----------------------. Generate list of commands that are used in documentation comments. ArmNeon; -------. Generate arm_neon.h for clang. ArmNeonSema; -----------. Generate ARM NEON sema support for clang. ArmNeonTest; -----------. Generate ARM NEON tests for clang. AttrDocs; --------. **Purpose**: Creates ``AttributeReference.rst`` from ``AttrDocs.td``, and is; used for documenting user-facing attributes. General BackEnds; ================. Print Records; -------------. The TableGen command option ``--print-records`` invokes a simple backend; that prints all the classes and records defined in the source files. This is; the default backend option. See the :doc:`TableGen Backend Developer's Guide; <./BackGuide>` for more information. Print Detailed Records; ----------------------. The TableGen command option ``--print-detailed-records`` invokes a backend; that prints all the global variables, classes, and records defined in the; source files, with more detail than the default record printer. See the; :doc:`TableGen Backend Developer's Guide <./BackGuide>` for more; information. JSON Reference; --------------. **Purpose**: Output all the values in every ``def``, as a JSON data; structure that can be easily parsed by a variety of languages. Useful; for writing custom backends without having to modify TableGen itself,; or for performing auxiliary analysis on the same TableGen data passed; to a built-in backend. **Output**:. The root of the output file is a JSON object (i.e. dictionary),; containing the following fixed keys:. * ``!tablegen_json_version``: a numeric version field that will; increase if an incompatible change is ever made to the structure of; t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:14424,Guid,Guide,14424,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,1,['Guid'],['Guide']
Usability,"nge tracking based; solver to model symbolic execution.; Consult the GitHub Issues; to get some ideas for new checkers and consider starting with improving/fixing; bugs in the existing checkers. Once an idea for a checker has been chosen, there are two key decisions that; need to be made:; ; Which events the checker should be tracking. This is discussed in more; detail in the section Events, Callbacks, and; Checker Class Structure.; What checker-specific data needs to be stored as part of the program; state (if any). This should be minimized as much as possible. More detail about; implementing custom program state is given in section Custom Program States.; ; Checker Registration; All checker implementation files are located in; clang/lib/StaticAnalyzer/Checkers folder. The steps below describe; how the checker SimpleStreamChecker, which checks for misuses of; stream APIs, was registered with the analyzer.; Similar steps should be followed for a new checker. A new checker implementation file, SimpleStreamChecker.cpp, was; created in the directory lib/StaticAnalyzer/Checkers.; The following registration code was added to the implementation file:. void ento::registerSimpleStreamChecker(CheckerManager &mgr) {; mgr.registerChecker<SimpleStreamChecker>();; }. A package was selected for the checker and the checker was defined in the; table of checkers at include/clang/StaticAnalyzer/Checkers/Checkers.td.; Since all checkers should first be developed as ""alpha"", and the SimpleStreamChecker; performs UNIX API checks, the correct package is ""alpha.unix"", and the following; was added to the corresponding UnixAlpha section of Checkers.td:. let ParentPackage = UnixAlpha in {; ...; def SimpleStreamChecker : Checker<""SimpleStream"">,; HelpText<""Check for misuses of stream APIs"">,; DescFile<""SimpleStreamChecker.cpp"">;; ...; } // end ""alpha.unix"". The source code file was made visible to CMake by adding it to; lib/StaticAnalyzer/Checkers/CMakeLists.txt. After adding a new checker to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:8903,Simpl,SimpleStreamChecker,8903,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['Simpl'],['SimpleStreamChecker']
Usability,"nge?. * Remember, it is normal and healthy to have patches reverted. Having a patch; reverted does not necessarily mean you did anything wrong.; * We encourage explicitly thanking the person who reverted the patch for doing; the task on your behalf.; * If you need more information to address the problem, please follow up in the; original commit thread with the reverting patch author. When should you revert your own change?. * Any time you learn of a serious problem with a change, you should revert it.; We strongly encourage ""revert to green"" as opposed to ""fixing forward"". We; encourage reverting first, investigating offline, and then reapplying the; fixed patch - possibly after another round of review if warranted.; * If you break a buildbot in a way which can't be quickly fixed, please revert.; * If a test case that demonstrates a problem is reported in the commit thread,; please revert and investigate offline.; * If you receive substantial :ref:`post-commit review <post_commit_review>`; feedback, please revert and address said feedback before recommitting.; (Possibly after another round of review.); * If you are asked to revert by another contributor, please revert and discuss; the merits of the request offline (unless doing so would further destabilize; tip of tree). When should you revert someone else's change?. * In general, if the author themselves would revert the change per these; guidelines, we encourage other contributors to do so as a courtesy to the; author. This is one of the major cases where our norms differ from others;; we generally consider reverting a normal part of development. We don't; expect contributors to be always available, and the assurance that a; problematic patch will be reverted and we can return to it at our next; opportunity enables this. What are the expectations around a revert?. * Use your best judgment. If you're uncertain, please start an email on; the commit thread asking for assistance. We aren't trying to enumerate; every ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:19842,feedback,feedback,19842,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,2,['feedback'],['feedback']
Usability,"nged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost any GUI-application in; ROOT and it is important to understand how it is constructed. The; example program is written as a named script. See ""Cling the C++; Interpreter"". Remember that the named script can be executed via. ``` {.cpp}; root[] .x example.C; ```. only if the filename (without extension) and the function entry point; are both the same. ![](pictures/02000202.jpg). We need to say a few words about the parent-children relationship; between the widgets before going through the real code. The widgets'; behaviors are based on this relationship. Every parent widget is; responsible for where the children are and it ensures all properties and; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2739,simpl,simple,2739,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"nguished between unsigned and signed; integer types and ran into similar issues of no-op casts. The transition from; manifesting signedness in types to instructions happened early on in LLVM's; timeline to make LLVM easier to work with. Opaque Pointers Mode; ====================. During the transition phase, LLVM can be used in two modes: In typed pointer; mode all pointer types have a pointee type and opaque pointers cannot be used.; In opaque pointers mode (the default), all pointers are opaque. The opaque; pointer mode can be disabled using ``-opaque-pointers=0`` in; LLVM tools like ``opt``, or ``-Xclang -no-opaque-pointers`` in clang.; Additionally, opaque pointer mode is automatically disabled for IR and bitcode; files that explicitly mention ``i8*`` style typed pointers. In opaque pointer mode, all typed pointers used in IR, bitcode, or created; using ``PointerType::get()`` and similar APIs are automatically converted into; opaque pointers. This simplifies migration and allows testing existing IR with; opaque pointers. .. code-block:: llvm. define i8* @test(i8* %p) {; %p2 = getelementptr i8, i8* %p, i64 1; ret i8* %p2; }. ; Is automatically converted into the following if -opaque-pointers; ; is enabled:. define ptr @test(ptr %p) {; %p2 = getelementptr i8, ptr %p, i64 1; ret ptr %p2; }. Migration Instructions; ======================. In order to support opaque pointers, two types of changes tend to be necessary.; The first is the removal of all calls to ``PointerType::getElementType()`` and; ``Type::getPointerElementType()``. In the LLVM middle-end and backend, this is usually accomplished by inspecting; the type of relevant operations instead. For example, memory access related; analyses and optimizations should use the types encoded in the load and store; instructions instead of querying the pointer type. Here are some common ways to avoid pointer element type accesses:. * For loads, use ``getType()``.; * For stores, use ``getValueOperand()->getType()``.; * U",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:5875,simpl,simplifies,5875,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['simpl'],['simplifies']
Usability,"nice way to look; at the LLVM IR for simple functions. For example:. ::. ready> 4+5;; Read top-level expression:; define double @0() {; entry:; ret double 9.000000e+00; }. Note how the parser turns the top-level expression into anonymous; functions for us. This will be handy when we add `JIT; support <LangImpl04.html#adding-a-jit-compiler>`_ in the next chapter. Also note that the; code is very literally transcribed, no optimizations are being performed; except simple constant folding done by IRBuilder. We will `add; optimizations <LangImpl04.html#trivial-constant-folding>`_ explicitly in the next; chapter. ::. ready> def foo(a b) a*a + 2*a*b + b*b;; Read function definition:; define double @foo(double %a, double %b) {; entry:; %multmp = fmul double %a, %a; %multmp1 = fmul double 2.000000e+00, %a; %multmp2 = fmul double %multmp1, %b; %addtmp = fadd double %multmp, %multmp2; %multmp3 = fmul double %b, %b; %addtmp4 = fadd double %addtmp, %multmp3; ret double %addtmp4; }. This shows some simple arithmetic. Notice the striking similarity to the; LLVM builder calls that we use to create the instructions. ::. ready> def bar(a) foo(a, 4.0) + bar(31337);; Read function definition:; define double @bar(double %a) {; entry:; %calltmp = call double @foo(double %a, double 4.000000e+00); %calltmp1 = call double @bar(double 3.133700e+04); %addtmp = fadd double %calltmp, %calltmp1; ret double %addtmp; }. This shows some function calls. Note that this function will take a long; time to execute if you call it. In the future we'll add conditional; control flow to actually make recursion useful :). ::. ready> extern cos(x);; Read extern:; declare double @cos(double). ready> cos(1.234);; Read top-level expression:; define double @1() {; entry:; %calltmp = call double @cos(double 1.234000e+00); ret double %calltmp; }. This shows an extern for the libm ""cos"" function, and a call to it. .. TODO:: Abandon Pygments' horrible `llvm` lexer. It just totally gives up; on highlighting this due to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:18798,simpl,simple,18798,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability,ninitializedObject/UninitializedPointee.cpp; clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.cpp; clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h; clang/lib/StaticAnalyzer/Checkers/WebKit/DiagOutputUtils.h; clang/lib/StaticAnalyzer/Checkers/WebKit/PtrTypesSemantics.cpp; clang/lib/StaticAnalyzer/Checkers/WebKit/PtrTypesSemantics.h; clang/lib/StaticAnalyzer/Checkers/WebKit/RefCntblBaseVirtualDtorChecker.cpp; clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLambdaCapturesChecker.cpp; clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp; clang/lib/StaticAnalyzer/Core/CallDescription.cpp; clang/lib/StaticAnalyzer/Core/CheckerHelpers.cpp; clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp; clang/lib/StaticAnalyzer/Core/CommonBugCategories.cpp; clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp; clang/lib/StaticAnalyzer/Core/DynamicExtent.cpp; clang/lib/StaticAnalyzer/Core/DynamicType.cpp; clang/lib/StaticAnalyzer/Core/FunctionSummary.cpp; clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp; clang/lib/StaticAnalyzer/Core/SMTConstraintManager.cpp; clang/lib/StaticAnalyzer/Frontend/CreateCheckerManager.cpp; clang/lib/StaticAnalyzer/Frontend/FrontendActions.cpp; clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp; clang/lib/Testing/CommandLineArgs.cpp; clang/lib/Tooling/ArgumentsAdjusters.cpp; clang/lib/Tooling/Execution.cpp; clang/lib/Tooling/ExpandResponseFilesCompilationDatabase.cpp; clang/lib/Tooling/FixIt.cpp; clang/lib/Tooling/GuessTargetAndModeCompilationDatabase.cpp; clang/lib/Tooling/NodeIntrospection.cpp; clang/lib/Tooling/StandaloneExecution.cpp; clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp; clang/lib/Tooling/DependencyScanning/DependencyScanningService.cpp; clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp; clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp; clang/lib/Tooling/DumpTool/APIData.h; clang/lib/Tooling/DumpTool/ASTSrcLocProcessor.h; clang/lib/Tooling/DumpTool/ClangSrcLocDu,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:25181,Simpl,SimpleConstraintManager,25181,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimpleConstraintManager']
Usability,"nking) them into the `test-suite/test-suite-externals/xxx` directory (example: `test-suite/test-suite-externals/speccpu2000`); - using a configuration option such as `-D TEST_SUITE_SPEC2000_ROOT=path/to/speccpu2000`. You can find further information in the respective README files such as; `test-suite/External/SPEC/README`. For the SPEC benchmarks you can switch between the `test`, `train` and; `ref` input datasets via the `TEST_SUITE_RUN_TYPE` configuration option.; The `train` dataset is used by default. Custom Suites; -------------. You can build custom suites using the test-suite infrastructure. A custom suite; has a `CMakeLists.txt` file at the top directory. The `CMakeLists.txt` will be; picked up automatically if placed into a subdirectory of the test-suite or when; setting the `TEST_SUITE_SUBDIRS` variable:. ```bash; % cmake -DTEST_SUITE_SUBDIRS=path/to/my/benchmark-suite ../test-suite; ```. Profile Guided Optimization; ---------------------------. Profile guided optimization requires to compile and run twice. First the; benchmark should be compiled with profile generation instrumentation enabled; and setup for training data. The lit runner will merge the profile files; using `llvm-profdata` so they can be used by the second compilation run. Example:; ```bash; # Profile generation run using LLVM IR PGO:; % cmake -DTEST_SUITE_PROFILE_GENERATE=ON \; -DTEST_SUITE_USE_IR_PGO=ON \; -DTEST_SUITE_RUN_TYPE=train \; ../test-suite; % make; % llvm-lit .; # Use the profile data for compilation and actual benchmark run:; % cmake -DTEST_SUITE_PROFILE_GENERATE=OFF \; -DTEST_SUITE_PROFILE_USE=ON \; -DTEST_SUITE_RUN_TYPE=ref \; .; % make; % llvm-lit -o result.json .; ```. To use Clang frontend's PGO instead of LLVM IR PGO, set `-DTEST_SUITE_USE_IR_PGO=OFF`. The `TEST_SUITE_RUN_TYPE` setting only affects the SPEC benchmark suites. Cross Compilation and External Devices; --------------------------------------. ### Compilation. CMake allows to cross compile to a different target ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:9998,guid,guided,9998,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['guid'],['guided']
Usability,"nner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<ComplexType>hasElementTypeMatcher<Type>; Matches arrays and C99 complex types that have a specific element; type. Given; struct A {};; A a[7];; int b[7];; arrayType(hasElementType(builtinType())); matches ""int b[7]"". Usable as: Matcher<ArrayType>, Matcher<ComplexType>. Matcher<CompoundLiteralExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CompoundStmt>hasAnySubstatementMatcher<Stmt> InnerMatcher; Matches compound statements where at least",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:181078,Usab,Usable,181078,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"nning pass (2) SROA on function (g); BISECT: running pass (3) Early CSE on function (g); BISECT: running pass (4) Infer set function attributes on module (test.ll); BISECT: running pass (5) Interprocedural Sparse Conditional Constant Propagation on module (test.ll); BISECT: running pass (6) Global Variable Optimizer on module (test.ll); BISECT: running pass (7) Promote Memory to Register on function (g); BISECT: running pass (8) Dead Argument Elimination on module (test.ll); BISECT: running pass (9) Combine redundant instructions on function (g); BISECT: running pass (10) Simplify the CFG on function (g); BISECT: running pass (11) Remove unused exception handling info on SCC (<<null function>>); BISECT: running pass (12) Function Integration/Inlining on SCC (<<null function>>); BISECT: running pass (13) Deduce function attributes on SCC (<<null function>>); BISECT: running pass (14) Remove unused exception handling info on SCC (f); BISECT: running pass (15) Function Integration/Inlining on SCC (f); BISECT: running pass (16) Deduce function attributes on SCC (f); BISECT: NOT running pass (17) Remove unused exception handling info on SCC (g); BISECT: NOT running pass (18) Function Integration/Inlining on SCC (g); BISECT: NOT running pass (19) Deduce function attributes on SCC (g); BISECT: NOT running pass (20) SROA on function (g); BISECT: NOT running pass (21) Early CSE on function (g); BISECT: NOT running pass (22) Speculatively execute instructions if target has divergent branches on function (g); ... etc. ... Pass Skipping Implementation; ============================. The -opt-bisect-limit implementation depends on individual passes opting in to; the opt-bisect process. The OptBisect object that manages the process is; entirely passive and has no knowledge of how any pass is implemented. When a; pass is run if the pass may be skipped, it should call the OptBisect object to; see if it should be skipped. The OptBisect object is intended to be accessed through LLVMCo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst:5848,Simpl,Simplify,5848,interpreter/llvm-project/llvm/docs/OptBisect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst,1,['Simpl'],['Simplify']
Usability,"none. define void @test(i32 %n) {; entry:; %guard_cond = icmp slt i32 0, %n; br i1 %guard_cond, label %loop.preheader, label %exit. loop.preheader:; br label %body. body:; %i2 = phi i32 [ 0, %loop.preheader ], [ %i.next, %latch ]; br label %latch. latch:; %i.next = add nsw i32 %i2, 1; %cond = icmp slt i32 %i.next, %n; br i1 %cond, label %body, label %loop.exit. loop.exit:; br label %exit. exit:; ret void; }. .. image:: ./loop-terminology-guarded-loop.png; :width: 500 px. The result is a little bit more complicated than we may expect; because LoopRotate ensures that the loop is in; :ref:`Loop Simplify Form <loop-terminology-loop-simplify>`; after rotation.; In this case, it inserted the %loop.preheader basic block so; that the loop has a preheader and it introduced the %loop.exit; basic block so that the loop has dedicated exits; (otherwise, %exit would be jumped from both %latch and %entry,; but %entry is not contained in the loop).; Note that a loop has to be in Loop Simplify Form beforehand; too for LoopRotate to be applied successfully. The main advantage of this form is that it allows hoisting; invariant instructions, especially loads, into the preheader.; That could be done in non-rotated loops as well but with; some disadvantages. Let's illustrate them with an example:. .. code-block:: C. for (int i = 0; i < n; ++i) {; auto v = *p;; use(v);; }. We assume that loading from p is invariant and use(v) is some; statement that uses v.; If we wanted to execute the load only once we could move it; ""out"" of the loop body, resulting in this:. .. code-block:: C. auto v = *p;; for (int i = 0; i < n; ++i) {; use(v);; }. However, now, in the case that n <= 0, in the initial form,; the loop body would never execute, and so, the load would; never execute. This is a problem mainly for semantic reasons.; Consider the case in which n <= 0 and loading from p is invalid.; In the initial program there would be no error. However, with this; transformation we would introduce one, effe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:22089,Simpl,Simplify,22089,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['Simpl'],['Simplify']
Usability,"not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or range; constraint manager as checkers (though it's probably not worth it to transform; them - just a mood). The main thing to avoid here would be the situation when; the checker overwrites stuff written by the core because it thinks it has a; better idea what's going on, so the core should provide a good default behavior. * Yeah, i totally care about performance as well, and if i try to implement; approach, i'd make sure it's good. **Artem:**. > Approach (2): We could teach the Store to scan itself for bindings to; > metadata-symbolic-based regions during scanReachableSymbols() whenever; > a region turns out to be reachable. This requires no work on checker side,; > but it sounds performance-heavy. Nope, this approach is wrong. Metadata symbols may become out-of-date: when the; object changes, metadata symbols attached to it aren't changing (because symbols; simply don't change). The same metadata may have different symbols to denote its; value in different moments of time, but at most one of them represents the; actual metadata value. So we'd be escaping more stuff than necessary. If only we had ""ghost fields""; (https://lists.llvm.org/pipermail/cfe-dev/2016-May/049000.html), it would have; been much easier, because the ghost field would only contain the actual; metadata, and the Store would always know about it. This example adds to my; belief that ghost fields are exactly what we need for most C++ checkers. **Devin:**. In this case, I would be fine with some sort of; AbstractStorageMemoryRegion that meant ""here is a memory region and somewhere; reachable from here exists another region of type T"". Or even multiple regions; with different identifiers. This wouldn't specify how the memory is reachable,; but it would allow for transfer functions to get at those regions and it would; al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:7779,simpl,simply,7779,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['simpl'],['simply']
Usability,"nown to be the backing storage for a variable is considered to represent an; assignment to that variable. This gives us a safe fall-back in cases where `llvm.dbg.assign` intrinsics have; been deleted, the `DIAssignID` attachment on the store has been dropped, or the; optimiser has made a once-indirect store (not tracked with Assignment Tracking); direct. ### Middle-end: Considerations for pass-writers. #### Non-debug instruction updates. **Cloning** an instruction: nothing new to do. Cloning automatically clones a; `DIAssignID` attachment. Multiple instructions may have the same `DIAssignID`; instruction. In this case, the assignment is considered to take place in; multiple positions in the program. **Moving** a non-debug instruction: nothing new to do. Instructions linked to an; `llvm.dbg.assign` have their initial IR position marked by the position of the; `llvm.dbg.assign`. **Deleting** a non-debug instruction: nothing new to do. Simple DSE does not; require any change; it’s safe to delete an instruction with a `DIAssignID`; attachment. An `llvm.dbg.assign` that uses a `DIAssignID` that is not attached; to any instruction indicates that the memory location isn’t valid. **Merging** stores: In many cases no change is required as `DIAssignID`; attachments are automatically merged if `combineMetadata` is called. One way or; another, the `DIAssignID` attachments must be merged such that new store; becomes linked to all the `llvm.dbg.assign` intrinsics that the merged stores; were linked to. This can be achieved simply by calling a helper function; `Instruction::mergeDIAssignID`. **Inlining** stores: As stores are inlined we generate `llvm.dbg.assign`; intrinsics and `DIAssignID` attachments as if the stores represent source; assignments, just like the in frontend. This isn’t perfect, as stores may have; been moved, modified or deleted before inlining, but it does at least keep the; information about the variable correct within the non-inlined scope. **Splitting** store",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:6249,Simpl,Simple,6249,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['Simpl'],['Simple']
Usability,"nrelated source locations rather than just a line away, making the; confusion of showing the return site rather the call site quite severe. Often the first frame in a backtrace (""frame zero"") identifies the precise; code location of a fault, trap, or asynchronous interrupt rather than a return; address. At other times, even the first frame is actually a return address; (for example, backtraces collected at the time of an object allocation and; reported later when the allocated object is used or misused). When a system; supports in-thread trap handling, there may also be frames after the first; that represent a precise interrupted code location rather than a return; address, presented as the ""caller"" of a trap handler function (for example,; signal handlers in POSIX systems). Return address frames are identified by the ``:ra`` suffix. Precise code; location frames are identified by the ``:pc`` suffix. Traditional practice has often been to collect backtraces as simple address; lists, losing the distinction between return address code locations and; precise code locations. Some such code applies the ""subtract one"" adjustment; described above to the address values before reporting them, and it's not; always clear or consistent whether this adjustment has been applied or not.; These ambiguous cases are supported by the ``bt`` and ``pc`` forms with no; ``:ra`` or ``:pc`` suffix, which indicate it's unclear which sort of code; location this is. However, it's highly recommended that all emitters use the; suffixed forms and deliver address values with no adjustments applied. When; traditional practice has been ambiguous, the majority of cases seem to have; been of printing addresses that are return address code locations and printing; them without adjustment. So the symbolizing filter will usually apply the; ""subtract one byte"" adjustment to an address printed without a disambiguating; suffix. Assuming that a call instruction is longer than one byte on all; supported machin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:12159,simpl,simple,12159,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['simpl'],['simple']
Usability,"ns &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. Finally, you can specify the argument on the command line:; ``clang -fpass-plugin=a -fpass-plugin=b`` and use the new member variable as; desired. .. code-block:: diff. void EmitAssemblyHelper::EmitAssemblyWithNewPassManager(/*...*/) {; // ...; + for (auto &PluginFN : CodeGenOpts.PassPlugins); + if (auto PassPlugin = PassPlugin::Load(PluginFN)); + PassPlugin->registerPassBuilderCallbacks(PB);; }. .. _OptionMarshalling:. Option Marshalling Infrastructure; ---------------------------------. The option marshalling infrastructure automates the parsing of the Clang; ``-cc1`` frontend command line arguments into ``CompilerInvocation`` and their; generation from ``CompilerInvocation``. The system replaces lots of repetitive; C++ code with simple, declarative tablegen annotations and it's being used for; the majority of the ``-cc1`` command line interface. This section provides an; overview of the system. **Note:** The marshalling infrastructure is not intended for driver-only; options. Only options of the ``-cc1`` frontend need to be marshalled to/from; ``CompilerInvocation`` instance. To read and modify contents of ``CompilerInvocation``, the marshalling system; uses key paths, which are declared in two steps. First, a tablegen definition; for the ``CompilerInvocation`` member is created by inheriting from; ``KeyPathAndMacro``:. .. code-block:: text. // Options.td. class LangOpts<string field> : KeyPathAndMacro<""LangOpts->"", field, ""LANG_""> {}; // CompilerInvocation member ^^^^^^^^^^; // OPTION_WITH_MARSHALLING prefix ^^^^^. The first argument to the parent class is the beginning of the key path that; references the ``CompilerInvocation`` member. This argument ends with ``->`` if; the member is a pointer type or with ``.`` if it's a value type. The c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:34283,simpl,simple,34283,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"ns about the LLVM instruction set.; We should discuss some now, but can discuss many of them later, when we; revisit synchronization, type inference, and other issues.; (We have discussed some of the comments already.). o We should consider eliminating the type annotation in cases where it is; essentially obvious from the instruction type, e.g., in br, it is obvious; that the first arg. should be a bool and the other args should be labels:. 	br bool <cond>, label <iftrue>, label <iffalse>. I think your point was that making all types explicit improves clarity; and readability. I agree to some extent, but it also comes at the cost; of verbosity. And when the types are obvious from people's experience; (e.g., in the br instruction), it doesn't seem to help as much. o On reflection, I really like your idea of having the two different switch; types (even though they encode implementation techniques rather than; semantics). It should simplify building the CFG and my guess is it could; enable some significant optimizations, though we should think about which. o In the lookup-indirect form of the switch, is there a reason not to make; the val-type uint? Most HLL switch statements (including Java and C++); require that anyway. And it would also make the val-type uniform ; in the two forms of the switch. I did see the switch-on-bool examples and, while cute, we can just use; the branch instructions in that particular case. o I agree with your comment that we don't need 'neg'. o There's a trade-off with the cast instruction:; + it avoids having to define all the upcasts and downcasts that are; valid for the operands of each instruction (you probably have thought; of other benefits also); - it could make the bytecode significantly larger because there could; be a lot of cast operations. o Making the second arg. to 'shl' a ubyte seems good enough to me.; 255 positions seems adequate for several generations of machines; and is more compact than uint. o I still have some major con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt:981,simpl,simplify,981,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,1,['simpl'],['simplify']
Usability,"ns should be in an unnamed namespace ideally. If we treat; these collisions liberally then CTU analysis can find more results. Note, the; feature be able to choose between name conflict handling strategies is still an; ongoing work. .. _CFG:. The ``CFG`` class; -----------------. The ``CFG`` class is designed to represent a source-level control-flow graph; for a single statement (``Stmt*``). Typically instances of ``CFG`` are; constructed for function bodies (usually an instance of ``CompoundStmt``), but; can also be instantiated to represent the control-flow of any class that; subclasses ``Stmt``, which includes simple expressions. Control-flow graphs; are especially useful for performing `flow- or path-sensitive; <https://en.wikipedia.org/wiki/Data_flow_analysis#Sensitivities>`_ program; analyses on a given function. Basic Blocks; ^^^^^^^^^^^^. Concretely, an instance of ``CFG`` is a collection of basic blocks. Each basic; block is an instance of ``CFGBlock``, which simply contains an ordered sequence; of ``Stmt*`` (each referring to statements in the AST). The ordering of; statements within a block indicates unconditional flow of control from one; statement to the next. :ref:`Conditional control-flow; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no assumptions should be made on how; ``CFGBlocks`` are numbered other than their numbers are unique and that they; are numbered from 0..N-1 (where N is the number of basic blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (access",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:112577,simpl,simply,112577,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability,"ns that a large; part of the manual and repetitive data entry can be factored and shared with the; compiler. Instruction Parsing; -------------------. .. note::. To Be Written. Instruction Alias Processing; ----------------------------. Once the instruction is parsed, it enters the MatchInstructionImpl function.; The MatchInstructionImpl function performs alias processing and then does actual; matching. Alias processing is the phase that canonicalizes different lexical forms of the; same instructions down to one representation. There are several different kinds; of alias that are possible to implement and they are listed below in the order; that they are processed (which is in order from simplest/weakest to most; complex/powerful). Generally you want to use the first alias mechanism that; meets the needs of your instruction, because it will allow a more concise; description. Mnemonic Aliases; ^^^^^^^^^^^^^^^^. The first phase of alias processing is simple instruction mnemonic remapping for; classes of instructions which are allowed with two different mnemonics. This; phase is a simple and unconditionally remapping from one input mnemonic to one; output mnemonic. It isn't possible for this form of alias to look at the; operands at all, so the remapping must apply for all forms of a given mnemonic.; Mnemonic aliases are defined simply, for example X86 has:. ::. def : MnemonicAlias<""cbw"", ""cbtw"">;; def : MnemonicAlias<""smovq"", ""movsq"">;; def : MnemonicAlias<""fldcww"", ""fldcw"">;; def : MnemonicAlias<""fucompi"", ""fucomip"">;; def : MnemonicAlias<""ud2a"", ""ud2"">;. ... and many others. With a MnemonicAlias definition, the mnemonic is remapped; simply and directly. Though MnemonicAlias's can't look at any aspect of the; instruction (such as the operands) they can depend on global modes (the same; ones supported by the matcher), through a Requires clause:. ::. def : MnemonicAlias<""pushf"", ""pushfq"">, Requires<[In64BitMode]>;; def : MnemonicAlias<""pushf"", ""pushfl"">, Requires<[In32",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:82189,simpl,simple,82189,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"ns=2 --margin=30 -rf8.0 %f; Print.Printer: 32-rb20-hp; Print.Directory: .; Print.FileType: pdf; ```. Default histogram binnings used by `TTree::Draw()` method. ``` {.cpp}; Hist.Binning.1D.x: 100; Hist.Binning.2D.x: 40; Hist.Binning.2D.y: 40; Hist.Binning.2D.Prof: 100; Hist.Binning.3D.x: 20; Hist.Binning.3D.y: 20; Hist.Binning.3D.z: 20; Hist.Binning.3D.Profx: 100; Hist.Binning.3D.Profy: 100; ```. Default statistics names used for parameters in **`TPaveStats`**:. ``` {.cpp}; Hist.Stats.Entries Entries; Hist.Stats.Mean Mean; Hist.Stats.MeanX Mean x; Hist.Stats.MeanY Mean y; Hist.Stats.RMS RMS; Hist.Stats.RMSX RMS x; Hist.Stats.RMSY RMS y; Hist.Stats.Underflow Underflow; Hist.Stats.Overflow Overflow; Hist.Stats.Integral Integral; Hist.Stats.Skewness Skewness; Hist.Stats.SkewnessX Skewness x; Hist.Stats.SkewnessY Skewness y; Hist.Stats.Kurtosis Kurtosis; Hist.Stats.KurtosisX Kurtosis x; Hist.Stats.KurtosisY Kurtosis y; ```. ### THtml Specific Settings. See the reference guide documentation of **`THtml`** class at; <https://root.cern/doc/master/classTHtml.html> for more details. XHTML content charset (see; <http://www.w3.org/TR/2002/REC-xhtml1-20020801>, default: ISO-8859-1) is; set by:. ``` {.cpp}; Root.Html.Charset:; ```. Stem of a search engine for the documentation, where `%s` is replaced by; the term entered in the search text box (example:; `http://www.google.com/search?q=%s+site%3Aroot.cern.ch%2Froot%2Fhtml`,; default is `""""`). ``` {.cpp}; Root.Html.Search:; ```. Link to the site's search engine (default: `""""`, example:; `http://root.cern.ch/root/Search.phtml`). ``` {.cpp}; Root.Html.SearchEngine:; ```. String to prepend to `TClass::GetImplFileName()` names containing; directories when looking for source files (default: `""""`, `e`xample:; `../root`). ``` {.cpp}; Root.Html.SourcePrefix:; ```. Link stem to `ViewCVS` entry for classes, where a class name is assumed; to match a file name (default: `""""`, example:; `http://root.cern.ch/viewcvs`). ``` {.cpp}; Root.Html.Vie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:7311,guid,guide,7311,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['guid'],['guide']
Usability,"ns` class. Steering options for the; minimiser, such as the convergence tolerance or the maximum number of; function calls, can also be set using the methods of this class. All; currently implemented minimisers are documented in the reference; documentation of ROOT: have a look for example to the; `ROOT::Math::Minimizer` class documentation.; \newpage; The complication level of the code below is intentionally a little; higher than in the previous examples. The graphical output of the macro; is shown in Figure [6.1](#f61):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro8.C; ```. Some step by step explanation is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Gaussian; (the ""signal"") plus a parabolic function, the ""background"". - Lines *10-12*: Some make-up for the Canvas. In particular we want; that the parameters of the fit appear very clearly and nicely on the; plot. - Lines *20-25*: Define and initialise an instance of `TF1`. - Lines *27-31*: Define and fill a histogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:2979,clear,clearly,2979,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,1,['clear'],['clearly']
Usability,"nside a ``multiclass``; statement. See the ``multiclass`` section below for details. A record can inherit from one or more classes by specifying the; :token:`ParentClassList` clause at the beginning of its record body. All of; the fields in the parent classes are added to the record. If two or more; parent classes provide the same field, the record ends up with the field value; of the last parent class. As a special case, the name of a record can be passed as a template argument; to that record's parent classes. For example:. .. code-block:: text. class A <dag d> {; dag the_dag = d;; }. def rec1 : A<(ops rec1)>;. The DAG ``(ops rec1)`` is passed as a template argument to class ``A``. Notice; that the DAG includes ``rec1``, the record being defined. The steps taken to create a new record are somewhat complex. See `How; records are built`_. See `Examples: classes and records`_ for examples. Examples: classes and records; -----------------------------. Here is a simple TableGen file with one class and two record definitions. .. code-block:: text. class C {; bit V = true;; }. def X : C;; def Y : C {; let V = false;; string Greeting = ""Hello!"";; }. First, the abstract class ``C`` is defined. It has one field named ``V``; that is a bit initialized to true. Next, two records are defined, derived from class ``C``; that is, with ``C``; as their parent class. Thus they both inherit the ``V`` field. Record ``Y``; also defines another string field, ``Greeting``, which is initialized to; ``""Hello!""``. In addition, ``Y`` overrides the inherited ``V`` field,; setting it to false. A class is useful for isolating the common features of multiple records in; one place. A class can initialize common fields to default values, but; records inheriting from that class can override the defaults. TableGen supports the definition of parameterized classes as well as; nonparameterized ones. Parameterized classes specify a list of variable; declarations, which may optionally have defaults, that ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:29120,simpl,simple,29120,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"nsider the following example function:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %b = sext i16 %a to i32; %c = and i32 %b, 15; call void @llvm.dbg.value(metadata i32 %c, ...); %d = trunc i32 %c to i16; ret i16 %d; }. Now, here's what happens after the unnecessary truncation instruction ``%d`` is; replaced with a simplified instruction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; call void @llvm.dbg.value(metadata i32 undef, ...); %simplified = and i16 %a, 15; ret i16 %simplified; }. Note that after deleting ``%d``, all uses of its operand ``%c`` become; trivially dead. The debug use which used to point to ``%c`` is now ``undef``,; and debug info is needlessly lost. To solve this problem, do:. .. code-block:: cpp. llvm::replaceAllDbgUsesWith(%c, theSimplifiedAndInstruction, ...). This results in better debug info because the debug use of ``%c`` is preserved:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %simplified = and i16 %a, 15; call void @llvm.dbg.value(metadata i16 %simplified, ...); ret i16 %simplified; }. You may have noticed that ``%simplified`` is narrower than ``%c``: this is not; a problem, because ``llvm::replaceAllDbgUsesWith`` takes care of inserting the; necessary conversion operations into the DIExpressions of updated debug uses. Deleting a MIR-level MachineInstr; ---------------------------------. TODO. Rules for updating ``DIAssignID`` Attachments; =============================================. ``DIAssignID`` metadata attachments are used by Assignment Tracking, which is; currently an experimental debug mode. See :doc:`AssignmentTracking` for how to update them and for more info on; Assignment Tracking. How to automatically convert tests into debug info tests; ========================================================. .. _IRDebugify:. Mutation testing for IR-level transformations; ---------------------------------------------. An IR test case for a transformation can, in many cases, be automatically; mutated to test debug info handl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:8490,simpl,simplified,8490,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simplified']
Usability,"nsidered compatible for a; target, if:. * Their processor is same.; * Their feature set is compatible as defined above. There are two forms of target ID:. *Non-Canonical Form*; The non-canonical form is used as the input to user commands to allow the user; greater convenience. It allows both the primary and alternative processor name; to be used and the target features may be specified in any order. *Canonical Form*; The canonical form is used for all generated output to allow greater; convenience for tools that consume the information. It is also used for; internal passing of information between tools. Only the primary and not; alternative processor name is used and the target features are specified in; alphabetic order. Command line tools convert non-canonical form to canonical; form. Target Specific information; ===========================. Target specific information is available for the following:. *AMD GPU*; AMD GPU supports target ID and target features. See `User Guide for AMDGPU Backend; <https://llvm.org/docs/AMDGPUUsage.html>`_ which defines the `processors; <https://llvm.org/docs/AMDGPUUsage.html#amdgpu-processors>`_ and `target; features <https://llvm.org/docs/AMDGPUUsage.html#amdgpu-target-features>`_; supported. Most other targets do not support target IDs. Archive Unbundling; ==================. Unbundling of a heterogeneous device archive (HDA) is done to create device specific; archives. HDA is in a format compatible with GNU ``ar`` utility and contains a; collection of bundled device binaries where each bundle file will contain; device binaries for a host and one or more targets. The output device-specific; archive is in a format compatible with GNU ``ar`` utility and contains a; collection of device binaries for a specific target. ::. Heterogeneous Device Archive, HDA = {F1.X, F2.X, ..., FN.Y}; where, Fi = Bundle{Host-DeviceBinary, T1-DeviceBinary, T2-DeviceBinary, ...,; Tm-DeviceBinary},; Ti = {Target i, qualified using Bundle Entry ID},; X/Y = \",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:13711,Guid,Guide,13711,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,1,['Guid'],['Guide']
Usability,"nsient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attached to, since these will be destroyed together. \image html geometry021.png ""Editors for shapes, materials, media, matrices"" width=600px. For most editors, the functionalities Apply and Undo are provided. For shapes, changing any of the shape parameters will activate the; ""Apply"" button only if the check button ""Delayed draw"" is checked,; otherwise the changes are immediately applied. Once the apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""Undo"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""Undo"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. \anchor GP08d; ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:131125,undo,undoable,131125,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['undo'],['undoable']
Usability,"nst FCNBase&, const MnUserParameterState&,\; const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes; minimization of the $\mbox{FCN}$ and returns the result in form of a; FunctionMinimum. Minimization terminates either when the function has; been called (approximately) $\mbox{maxfcn}$ times, or when the; estimated vertical distance to minimum ($\mbox{EDM}$) is less than; $\mbox{tolerance*up}$. The default value of $\mbox{tolerance}$; is $\mbox{0.1}$. (see [howto:errordef]). ### Parameter interaction ###. MnSimplex retains the result after each minimization; (MnUserParameterStae, see [api:state]) and forwards the interface for; parameter interaction. ### SimplexMinimizer() ###. The SimplexMinimizer() is instantiated using default constructor. ### minimize(const FCNBase&, ...) ###. The SimplexMinimizer provides several overloaded methods minimize with; return value FunctionMinimum. Together with the user $\mbox{FCN}$; (either an implementation of FCNBase or FCNGradientBase) the user has to; give as input the parameters with starting values in one of the defined; formats (std::vector$<$double$>$, MnUserParameters or; MnUserParameterState). ## MnStrategy ##. [api:strategy] Sets the strategy to be used in calculating first and; second derivatives and in certain minimization methods. In general, low; values of $\mbox{level}$ mean fewer function calls and high values; mean more reliable minimization. Currently allowed values are 0 (low), 1; (default), and 2 (high). ### MnStrategy() ###. Default constructor, sets all settings according to; $\mbox{level}$$ = 1.$. ### MnStrategy(unsigned int level) ###. Explicit constructor for predefined settings of desired; $\mbox{level}$ 0 (low), 1 (default), or 2 (high). ### setLowStrategy(), setMediumStrategy(), setHighStrategy() ###. Methods to set specific strategy level. ### Oth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:50537,Simpl,SimplexMinimizer,50537,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['Simpl'],['SimplexMinimizer']
Usability,"nst MnUserParameters&,\; unsigned int) ###. Constructor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameterState&,\; const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes; minimization of the $\mbox{FCN}$ and returns the result in form of a; FunctionMinimum. Minimization terminates either when the function has; been called (approximately) $\mbox{maxfcn}$ times, or when the; estimated vertical distance to minimum ($\mbox{EDM}$) is less than; $\mbox{tolerance*up}$. The default value of $\mbox{tolerance}$; is $\mbox{0.1}$. (see [howto:errordef]). ### Parameter interaction ###. MnSimplex retains the result after each minimization; (MnUserParameterStae, see [api:state]) and forwards the interface for; parameter interaction. ### SimplexMinimizer() ###. The SimplexMinimizer() is instantiated using default constructor. ### minimize(const FCNBase&, ...) ###. The SimplexMinimizer provides several overloaded methods minimize with; return value FunctionMinimum. Together with the user $\mbox{FCN}$; (either an implementation of FCNBase or FCNGradientBase) the user has to; give as input the parameters with starting values in one of the defined; formats (std::vector$<$double$>$, MnUserParameters or; MnUserParameterState). ## MnStrategy ##. [api:strategy] Sets the strategy to be used in calculating first and; second derivatives and in certain minimization methods. In general, low; values of $\mbox{level}$ mean fewer function calls and high values; mean more reliable minimization. Currently allowed values are 0 (low), 1; (default), and 2 (high). ### MnStrategy() ###. Default constructor, sets all settings according to; $\mbox{level}$$ = 1.$. ### MnStrategy(unsigned int level) ###. Explicit constructor for predefined settings of de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:50404,Simpl,SimplexMinimizer,50404,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['Simpl'],['SimplexMinimizer']
Usability,"nst; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we can do is matching more than we; would like to allow, and punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr()))). Furthermore, we can restrict our matcher to only match if the; incremented variable is an integer:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(varDecl(hasType(isInteger()))))))). And the last step will be to attach an identifier to this variable, so; that we can retrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:12231,simpl,simply,12231,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simply']
Usability,"nst`` copies of other; variables, and variables marked ``__block``. In Objective-C, variables may; additionally be objects. When a ``Block`` literal expression is used as the initial value of a global; or ``static`` local variable, it is initialized as follows:. .. code-block:: c. struct __block_literal_1 __block_literal_1 = {; &_NSConcreteGlobalBlock,; (1<<28)|(1<<29), <uninitialized>,; __block_invoke_1,; &__block_descriptor_1; };. that is, a different address is provided as the first value and a particular; (1<<28) bit is set in the ``flags`` field, and otherwise it is the same as for; stack based ``Block`` literals. This is an optimization that can be used for; any ``Block`` literal that imports no ``const`` or ``__block`` storage; variables. Imported Variables; ==================. Variables of ``auto`` storage class are imported as ``const`` copies. Variables; of ``__block`` storage class are imported as a pointer to an enclosing data; structure. Global variables are simply referenced and not considered as; imported. Imported ``const`` copy variables; ---------------------------------. Automatic storage variables not marked with ``__block`` are imported as; ``const`` copies. The simplest example is that of importing a variable of type ``int``:. .. code-block:: c. int x = 10;; void (^vv)(void) = ^{ printf(""x is %d\n"", x); }; x = 11;; vv();. which would be compiled to:. .. code-block:: c. struct __block_literal_2 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_2 *);; struct __block_descriptor_2 *descriptor;; const int x;; };. void __block_invoke_2(struct __block_literal_2 *_block) {; printf(""x is %d\n"", _block->x);; }. static struct __block_descriptor_2 {; unsigned long int reserved;; unsigned long int Block_size;; } __block_descriptor_2 = { 0, sizeof(struct __block_literal_2) };. and:. .. code-block:: c. struct __block_literal_2 __block_literal_2 = {; &_NSConcreteStackBlock,; (1<<29), <uninitialized>,; __block_invoke_2,; &__block_d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:6845,simpl,simply,6845,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['simpl'],['simply']
Usability,"nstances"" or ""Coros contains 3 coroutine; objects."". In this document, we follow the common practice of using `coroutine` to refer; to an individual `coroutine instance`, since the terms `coroutine instance` and; `coroutine object` aren't sufficiently defined in this case. coroutine frame; ---------------. The C++ Standard uses `coroutine state` to describe the allocated storage. In; the compiler, we use `coroutine frame` to describe the generated data structure; that contains the necessary information. The structure of coroutine frames; =================================. The structure of coroutine frames is defined as:. .. code-block:: c++. struct {; void (*__r)(); // function pointer to the `resume` function; void (*__d)(); // function pointer to the `destroy` function; promise_type; // the corresponding `promise_type`; ... // Any other needed information; }. In the debugger, the function's name is obtainable from the address of the; function. And the name of `resume` function is equal to the name of the; coroutine function. So the name of the coroutine is obtainable once the; address of the coroutine is known. Print promise_type; ==================. Every coroutine has a `promise_type`, which defines the behavior; for the corresponding coroutine. In other words, if two coroutines have the; same `promise_type`, they should behave in the same way.; To print a `promise_type` in a debugger when stopped at a breakpoint inside a; coroutine, printing the `promise_type` can be done by:. .. parsed-literal::. print __promise. It is also possible to print the `promise_type` of a coroutine from the address; of the coroutine frame. For example, if the address of a coroutine frame is; 0x416eb0, and the type of the `promise_type` is `task::promise_type`, printing; the `promise_type` can be done by:. .. parsed-literal::. print (task::promise_type)*(0x416eb0+0x10). This is possible because the `promise_type` is guaranteed by the ABI to be at a; 16 bit offset from the coroutine fra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:3143,resume,resume,3143,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability,nstead of ``DW_OP_add`` when; acting on a location description. Need to provide examples of new features. .. _amdgpu-dwarf-references:. D. References; =============. .. _amdgpu-dwarf-AMD:. 1. [AMD] `Advanced Micro Devices <https://www.amd.com/>`__. .. _amdgpu-dwarf-AMD-ROCgdb:. 2. [AMD-ROCgdb] `AMD ROCm Debugger (ROCgdb) <https://github.com/ROCm-Developer-Tools/ROCgdb>`__. .. _amdgpu-dwarf-AMD-ROCm:. 3. [AMD-ROCm] `AMD ROCm Platform <https://rocm-documentation.readthedocs.io>`__. .. _amdgpu-dwarf-AMDGPU-DWARF-LOC:. 4. [AMDGPU-DWARF-LOC] `Allow Location Descriptions on the DWARF Expression Stack <https://llvm.org/docs/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack.html>`__. .. _amdgpu-dwarf-AMDGPU-LLVM:. 5. [AMDGPU-LLVM] `User Guide for AMDGPU LLVM Backend <https://llvm.org/docs/AMDGPUUsage.html>`__. .. _amdgpu-dwarf-CUDA:. 6. [CUDA] `Nvidia CUDA Language <https://docs.nvidia.com/cuda/cuda-c-programming-guide/>`__. .. _amdgpu-dwarf-DWARF:. 7. [DWARF] `DWARF Debugging Information Format <http://dwarfstd.org/>`__. .. _amdgpu-dwarf-ELF:. 8. [ELF] `Executable and Linkable Format (ELF) <http://www.sco.com/developers/gabi/>`__. .. _amdgpu-dwarf-GCC:. 9. [GCC] `GCC: The GNU Compiler Collection <https://www.gnu.org/software/gcc/>`__. .. _amdgpu-dwarf-GDB:. 10. [GDB] `GDB: The GNU Project Debugger <https://www.gnu.org/software/gdb/>`__. .. _amdgpu-dwarf-HIP:. 11. [HIP] `HIP Programming Guide <https://rocm-documentation.readthedocs.io/en/latest/Programming_Guides/Programming-Guides.html#hip-programing-guide>`__. .. _amdgpu-dwarf-HSA:. 12. [HSA] `Heterogeneous System Architecture (HSA) Foundation <http://www.hsafoundation.com/>`__. .. _amdgpu-dwarf-LLVM:. 13. [LLVM] `The LLVM Compiler Infrastructure <https://llvm.org/>`__. .. _amdgpu-dwarf-OpenCL:. 14. [OpenCL] `The OpenCL Specification Version 2.0 <http://www.khronos.org/registry/cl/specs/opencl-2.0.pdf>`__. .. _amdgpu-dwarf-Perforce-To,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:235254,guid,guide,235254,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['guid'],['guide']
Usability,"nstructExpr(requiresZeroInitialization())); will match the implicit array filler for pt[1]. Matcher<CXXConstructorDecl>isCopyConstructor; Matches constructor declarations that are copy constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isCopyConstructor()) will match #2, but not #1 or #3. Matcher<CXXConstructorDecl>isDefaultConstructor; Matches constructor declarations that are default constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isDefaultConstructor()) will match #1, but not #2 or #3. Matcher<CXXConstructorDecl>isDelegatingConstructor; Matches constructors that delegate to another constructor. Given; struct S {; S(); // #1; S(int) {} // #2; S(S &&) : S() {} // #3; };; S::S() : S(0) {} // #4; cxxConstructorDecl(isDelegatingConstructor()) will match #3 and #4, but not; #1 or #2. Matcher<CXXConstructorDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXConstructorDecl>isInheritingConstructor. Matcher<CXXConstructorDecl>isMoveConstructor; Matches constructor declarations that are move constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isMoveConstructor()) will match #3, but not #1 or #2. Matcher<CXXConversionDecl>isExplicit; Matches constructor, conversion function, and deduction guide declar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:61238,guid,guide,61238,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['guid'],['guide']
Usability,"nstrumented. Use these flags together with ``trace-pc-guard`` or ``trace-pc``,; like this: ``-fsanitize-coverage=func,trace-pc-guard``. When ``edge`` or ``bb`` is used, some of the edges/blocks may still be left; uninstrumented (pruned) if such instrumentation is considered redundant.; Use ``no-prune`` (e.g. ``-fsanitize-coverage=bb,no-prune,trace-pc-guard``); to disable pruning. This could be useful for better coverage visualization. Edge coverage; -------------. Consider this code:. .. code-block:: c++. void foo(int *a) {; if (a); *a = 0;; }. It contains 3 basic blocks, let's name them A, B, C:. .. code-block:: none. A; |\; | \; | B; | /; |/; C. If blocks A, B, and C are all covered we know for certain that the edges A=>B; and B=>C were executed, but we still don't know if the edge A=>C was executed.; Such edges of control flow graph are called; `critical <https://en.wikipedia.org/wiki/Control_flow_graph#Special_edges>`_.; The edge-level coverage simply splits all critical edges by introducing new; dummy blocks and then instruments those blocks:. .. code-block:: none. A; |\; | \; D B; | /; |/; C. Tracing data flow; =================. Support for data-flow-guided fuzzing.; With ``-fsanitize-coverage=trace-cmp`` the compiler will insert extra instrumentation; around comparison instructions and switch statements.; Similarly, with ``-fsanitize-coverage=trace-div`` the compiler will instrument; integer division instructions (to capture the right argument of division); and with ``-fsanitize-coverage=trace-gep`` --; the `LLVM GEP instructions <https://llvm.org/docs/GetElementPtr.html>`_; (to capture array indices).; Similarly, with ``-fsanitize-coverage=trace-loads`` and ``-fsanitize-coverage=trace-stores``; the compiler will instrument loads and stores, respectively. Currently, these flags do not work by themselves - they require one; of ``-fsanitize-coverage={trace-pc,inline-8bit-counters,inline-bool}``; flags to work. Unless ``no-prune`` option is provided, some of the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:8583,simpl,simply,8583,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['simpl'],['simply']
Usability,"nt of a ``multiclass``, such as the use of ``Bar`` in::. multiclass Foo <int Bar> {; def : SomeClass<Bar>;; }. * A variable defined with the ``defvar`` or ``defset`` statements. * The iteration variable of a ``foreach``, such as the use of ``i`` in::. foreach i = 0...5 in; def Foo#i;. .. productionlist::; SimpleValue8: `ClassID` ""<"" `ArgValueList` "">"". This form creates a new anonymous record definition (as would be created by an; unnamed ``def`` inheriting from the given class with the given template; arguments; see `def`_) and the value is that record. A field of the record can be; obtained using a suffix; see `Suffixed Values`_. Invoking a class in this manner can provide a simple subroutine facility.; See `Using Classes as Subroutines`_ for more information. .. productionlist::; SimpleValue9: `BangOperator` [""<"" `Type` "">""] ""("" `ValueListNE` "")""; :| `CondOperator` ""("" `CondClause` ("","" `CondClause`)* "")""; CondClause: `Value` "":"" `Value`. The bang operators provide functions that are not available with the other; simple values. Except in the case of ``!cond``, a bang operator takes a list; of arguments enclosed in parentheses and performs some function on those; arguments, producing a value for that bang operator. The ``!cond`` operator; takes a list of pairs of arguments separated by colons. See `Appendix A:; Bang Operators`_ for a description of each bang operator. Suffixed values; ---------------. The :token:`SimpleValue` values described above can be specified with; certain suffixes. The purpose of a suffix is to obtain a subvalue of the; primary value. Here are the possible suffixes for some primary *value*. *value*\ ``{17}``; The final value is bit 17 of the integer *value* (note the braces). *value*\ ``{8...15}``; The final value is bits 8--15 of the integer *value*. The order of the; bits can be reversed by specifying ``{15...8}``. *value*\ ``[i]``; The final value is element `i` of the list *value* (note the brackets).; In other words, the brackets act as",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:18288,simpl,simple,18288,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"nt to describe. The instance variables for an ARC-compiled class will be destroyed at some; point after control enters the ``dealloc`` method for the root class of the; class. The ordering of the destruction of instance variables is unspecified,; both within a single class and between subclasses and superclasses. .. admonition:: Rationale. The traditional, non-ARC pattern for destroying instance variables is to; destroy them immediately before calling ``[super dealloc]``. Unfortunately,; message sends from the superclass are quite capable of reaching methods in; the subclass, and those methods may well read or write to those instance; variables. Making such message sends from dealloc is generally discouraged,; since the subclass may well rely on other invariants that were broken during; ``dealloc``, but it's not so inescapably dangerous that we felt comfortable; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; deallocation will trigger a side-effect which must be carefully ordered with; respect to the destruction of the super class. Such code violates the design; principle that semantically important behavior should be explicit. A simple; fix is to clear the instance variable manually during ``dealloc``; a more; holistic solution is to move semantically important side-effects out of; ``dealloc`` and into a separate teardown phase which can rely on working with; well-formed objects. .. _arc.misc.autoreleasepool:. ``@autoreleasepool``; --------------------. To simplify the use of autorelease pools, and to bring them under the control; of the compiler, a new kind of statement is available in Objective-C. It is; written ``@autoreleasepool`` followed by a *c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:89713,clear,clearly,89713,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['clear'],['clearly']
Usability,"nt with new TWebCanvas - interactivity, attributes/position updates; 12. Provide initial WebVR support (#176), thanks to Diego Marcos (@dmarcos); 13. Upgrade three.js 86 -> 102, use SoftwareRenderer instead of CanvasRenderer; 14. Upgrade d3.js 4.4.4 -> 5.7.0; 15. Use d3.js and three.js from npm when running with node.js; 16. Fix - support clipping for tracks and points in geo painter; 17. Fix - drawing of TGeoNode with finder; 18. Fix - key press events processed only in active pad (ROOT-9128); 19. Fix - use X0/Y0 in xtru shape (#182), thanks to @altavir; 20. Move most of ui5-specific code into ROOT repository, where it will be maintained; 21. Provide special widget for object inspector. ## Changes in 5.6.4; 1. Fix - try workaround corrupted data in TTree; 2. Fix - support min0 draw option like ROOT does; 3. Fix - correctly handle TH2Poly draw options; 4. Fix - seldom error in JSROOT.cleanup; 5. Fix - repair TTree player UI; 6. Fix - error in TH3 filling; 7. Fix - correctly access top element in simple layout; 8. Fix - exclude duplicated points when drawing TH2 with SURF3 options. ## Changes in 5.6.3; 1. Fix - support clipping for tracks and points in geo painter; 2. Fix - geometry with TGeoNodeOffset was not correctly drawn; 3. Fix - use proper formatting for entries and integral (#179); 4. Fix - TTree::Draw for 3d histogram was not properly performed. ## Changes in 5.6.2; 1. Fix - correctly handle negative parameter values in TF1/TF2. ## Changes in 5.6.1; 1. Add TMath.BreitWigner function; 2. Support custom streamers for TMaterial and TMixture (very old examples); 3. Fix Y-scale drawing of THStack (https://root-forum.cern.ch/t/31266); 4. Fix - select palette from colz element; 5. Fix - LZ4 uncompression of large buffers. ## Changes in 5.6.0; 1. By drawing outline speed up (factor 10) canvas with many small sub-pads; 2. Let configure user click and double-click handlers, extend tooltip.htm example; 3. Implement workaround for standard THREE.SVGRenderer - no need fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:31452,simpl,simple,31452,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,"ntal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg3->SetFillType(TGProgressBar::kBlockFill);. vframe->AddFrame(fHProg1,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg2,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg3,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->Resize(200, 200);; ```. ### Static Widgets. The classes **`TGLabel`** and **`TGIcon`** show some information - text; or graphics. The line below creates a label object. The syntax is very; simple: you specify the parent widget and a string object holding the; desired text. ``` {.cpp}; TGLabel *label = new TGLabel(parentWidget, ""Label's string"");; ```. Next sample creates an icon object. First we create an object of type; **`TGPicture`**. The **`TGPicture`** objects are never created directly; by the application code. We call **`TGClient`** telling it the pixmap's; file name to create a **`TGPicture`** object and, in turn, it will; return a pointer to the created object. If the pixmap file cannot be; found the returned pointer will be `NULL`. As usual, the first parameter; of a **`TGIcon`** constructor is the parent frame. The second one is the; **`TGPicture`** object holding the pixmap we want to show. Last two; parameters define the width and height of pixmap in pixels. In the end; we add the created icon object to its parent. ``` {.cpp}; // icon widget; const TGPicture *ipic=(TGPicture *)gClient->GetPicture(""leaf.xpm"");; TGIcon *icon = new TGIcon(parent,ipic,40,40);; parent->AddFrame(icon,new TGLayou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:89860,simpl,simple,89860,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"nter as an argument (which it; then propagates). This can sometimes be useful, allowing you to combine; several null checks into one. These five templates can be used with any classes, whether they have a v-table; or not. If you want to add support for these templates, see the document; :doc:`How to set up LLVM-style RTTI for your class hierarchy; <HowToSetUpLLVMStyleRTTI>`. .. _string_apis:. Passing strings (the ``StringRef`` and ``Twine`` classes); ---------------------------------------------------------. Although LLVM generally does not do much string manipulation, we do have several; important APIs which take strings. Two important examples are the Value class; -- which has names for instructions, functions, etc. -- and the ``StringMap``; class which is used extensively in LLVM and Clang. These are generic classes, and they need to be able to accept strings which may; have embedded null characters. Therefore, they cannot simply take a ``const; char *``, and taking a ``const std::string&`` requires clients to perform a heap; allocation which is usually unnecessary. Instead, many LLVM APIs use a; ``StringRef`` or a ``const Twine&`` for passing strings efficiently. .. _StringRef:. The ``StringRef`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``StringRef`` data type represents a reference to a constant string (a; character array and a length) and supports the common operations available on; ``std::string``, but does not require heap allocation. It can be implicitly constructed using a C style null-terminated string, an; ``std::string``, or explicitly with a character pointer and length. For; example, the ``StringMap`` find function is declared as:. .. code-block:: c++. iterator find(StringRef Key);. and clients can call it using any one of:. .. code-block:: c++. Map.find(""foo""); // Lookup ""foo""; Map.find(std::string(""bar"")); // Lookup ""bar""; Map.find(StringRef(""\0baz"", 4)); // Lookup ""\0baz"". Similarly, APIs which need to return a string may return a ``StringRef``; ins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:8114,simpl,simply,8114,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability,"nto categories represented; by top-level list tree items for: boxes, tubes, translations, rotations,; etc. ![Selection dialogs for different TGeo objects](pictures/030001EF.png). Once a selection is made and the dialog is closed, the selected item; name will appear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attached to, since these will be destroyed together. ![Editors for shapes, materials, media, matrices](pictures/020001F0.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F1.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F2.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F3.jpg); ![Editors for shapes, materials, media, matrices](pictures/030001F4.png). For most editors, the functionalities Apply and Undo are provided. For shapes, changing any of the shape parameters will activate the; ""*Apply*"" button only if the check button ""*Delayed draw*"" is checked,; otherwise the changes are immediately applied. Once the apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""*Undo*"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:170519,Undo,Undo,170519,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['Undo'],['Undo']
Usability,"nts to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:58403,simpl,simple,58403,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,nuit2/MnFcn.h; Minuit2/MnFumiliMinimize.h; Minuit2/MnFunctionCross.h; Minuit2/MnGlobalCorrelationCoeff.h; Minuit2/MnHesse.h; Minuit2/MnLineSearch.h; Minuit2/MnMachinePrecision.h; Minuit2/MnMatrix.h; Minuit2/MnMatrixfwd.h; Minuit2/MnMigrad.h; Minuit2/MnMinimize.h; Minuit2/MnMinos.h; Minuit2/MnParabola.h; Minuit2/MnParabolaFactory.h; Minuit2/MnParabolaPoint.h; Minuit2/MnParameterScan.h; Minuit2/MnPlot.h; Minuit2/MnPosDef.h; Minuit2/MnPrint.h; Minuit2/MnScan.h; Minuit2/MnSeedGenerator.h; Minuit2/MnSimplex.h; Minuit2/MnStrategy.h; Minuit2/MnTiny.h; Minuit2/MnTraceObject.h; Minuit2/MnUserCovariance.h; Minuit2/MnUserFcn.h; Minuit2/MnUserParameterState.h; Minuit2/MnUserParameters.h; Minuit2/MnUserTransformation.h; Minuit2/MnVectorTransform.h; Minuit2/ModularFunctionMinimizer.h; Minuit2/NegativeG2LineSearch.h; Minuit2/Numerical2PGradientCalculator.h; Minuit2/NumericalDerivator.h; Minuit2/ParametricFunction.h; Minuit2/ScanBuilder.h; Minuit2/ScanMinimizer.h; Minuit2/SimplexBuilder.h; Minuit2/SimplexMinimizer.h; Minuit2/SimplexParameters.h; Minuit2/SimplexSeedGenerator.h; Minuit2/SinParameterTransformation.h; Minuit2/SqrtLowParameterTransformation.h; Minuit2/SqrtUpParameterTransformation.h; Minuit2/StackAllocator.h; Minuit2/VariableMetricBuilder.h; Minuit2/VariableMetricEDMEstimator.h; Minuit2/VariableMetricMinimizer.h; Minuit2/VectorOuterProduct.h; TMinuit2TraceObject.h; SOURCES; src/AnalyticalGradientCalculator.cxx; src/BFGSErrorUpdator.cxx; src/CMakeLists.txt; src/CombinedMinimumBuilder.cxx; src/DavidonErrorUpdator.cxx; src/ExternalInternalGradientCalculator.cxx; src/FumiliBuilder.cxx; src/FumiliErrorUpdator.cxx; src/FumiliGradientCalculator.cxx; src/FumiliMinimizer.cxx; src/FumiliStandardChi2FCN.cxx; src/FumiliStandardMaximumLikelihoodFCN.cxx; src/HessianGradientCalculator.cxx; src/InitialGradientCalculator.cxx; src/LaEigenValues.cxx; src/LaInnerProduct.cxx; src/LaInverse.cxx; src/LaOuterProduct.cxx; src/LaSumOfElements.cxx; src/LaVtMVSimilarity.cxx; src/MPIProcess.cxx; sr,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt:3088,Simpl,SimplexMinimizer,3088,math/minuit2/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt,1,['Simpl'],['SimplexMinimizer']
Usability,"number of code blocks or edges covered by executing the current corpus.; ``ft:``; libFuzzer uses different signals to evaluate the code coverage:; edge coverage, edge counters, value profiles, indirect caller/callee pairs, etc.; These signals combined are called *features* (`ft:`).; ``corp:``; Number of entries in the current in-memory test corpus and its size in bytes.; ``lim:``; Current limit on the length of new entries in the corpus. Increases over time; until the max length (``-max_len``) is reached.; ``exec/s:``; Number of fuzzer iterations per second.; ``rss:``; Current memory consumption. For ``NEW`` and ``REDUCE`` events, the output line also includes information; about the mutation operation that produced the new input:. ``L:``; Size of the new input in bytes.; ``MS: <n> <operations>``; Count and list of the mutation operations used to generate the input. Examples; ========; .. contents::; :local:; :depth: 1. Toy example; -----------. A simple function that does something interesting if it receives the input; ""HI!""::. cat << EOF > test_fuzzer.cc; #include <stdint.h>; #include <stddef.h>; extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {; if (size > 0 && data[0] == 'H'); if (size > 1 && data[1] == 'I'); if (size > 2 && data[2] == '!'); __builtin_trap();; return 0;; }; EOF; # Build test_fuzzer.cc with asan and link against libFuzzer.; clang++ -fsanitize=address,fuzzer test_fuzzer.cc; # Run the fuzzer with no corpus.; ./a.out. You should get an error pretty quickly::. INFO: Seed: 1523017872; INFO: Loaded 1 modules (16 guards): [0x744e60, 0x744ea0),; INFO: -max_len is not provided, using 64; INFO: A corpus is not provided, starting from an empty corpus; #0	READ units: 1; #1	INITED cov: 3 ft: 2 corp: 1/1b exec/s: 0 rss: 24Mb; #3811	NEW cov: 4 ft: 3 corp: 2/2b exec/s: 0 rss: 25Mb L: 1 MS: 5 ChangeBit-ChangeByte-ChangeBit-ShuffleBytes-ChangeByte-; #3827	NEW cov: 5 ft: 4 corp: 3/4b exec/s: 0 rss: 25Mb L: 2 MS: 1 CopyPart-; #3963	NEW cov: 6 f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:17682,simpl,simple,17682,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['simpl'],['simple']
Usability,"nusual circumstances. .. _SymbolTable:. The ``ValueSymbolTable`` class; ------------------------------. The ``ValueSymbolTable`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html>`__) class provides; a symbol table that the :ref:`Function <c_Function>` and Module_ classes use for; naming value definitions. The symbol table can provide a name for any Value_. Note that the ``SymbolTable`` class should not be directly accessed by most; clients. It should only be used when iteration over the symbol table names; themselves are required, which is very special purpose. Note that not all LLVM; Value_\ s have names, and those without names (i.e. they have an empty name) do; not exist in the symbol table. Symbol tables support iteration over the values in the symbol table with; ``begin/end/iterator`` and supports querying to see if a specific name is in the; symbol table (with ``lookup``). The ``ValueSymbolTable`` class exposes no; public mutator methods, instead, simply call ``setName`` on a value, which will; autoinsert it into the appropriate symbol table. .. _UserLayout:. The ``User`` and owned ``Use`` classes' memory layout; -----------------------------------------------------. The ``User`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1User.html>`__); class provides a basis for expressing the ownership of ``User`` towards other; `Value instance <https://llvm.org/doxygen/classllvm_1_1Value.html>`_\ s. The; ``Use`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1Use.html>`__) helper; class is employed to do the bookkeeping and to facilitate *O(1)* addition and; removal. .. _Use2User:. Interaction and relationship between ``User`` and ``Use`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A subclass of ``User`` can choose between incorporating its ``Use`` objects or; refer to them out-of-line by means of a pointer. A mixed variant (some ``Use``; s inline others hung off) is impractical and breaks the invariant that the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:126478,simpl,simply,126478,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability,nverse.cxx; src/LaOuterProduct.cxx; src/LaSumOfElements.cxx; src/LaVtMVSimilarity.cxx; src/MPIProcess.cxx; src/MinimumBuilder.cxx; src/Minuit2Minimizer.cxx; src/MnApplication.cxx; src/MnContours.cxx; src/MnCovarianceSqueeze.cxx; src/MnEigen.cxx; src/MnFcn.cxx; src/MnFumiliMinimize.cxx; src/MnFunctionCross.cxx; src/MnGlobalCorrelationCoeff.cxx; src/MnHesse.cxx; src/MnLineSearch.cxx; src/MnMachinePrecision.cxx; src/MnMinos.cxx; src/MnParabolaFactory.cxx; src/MnParameterScan.cxx; src/MnPlot.cxx; src/MnPosDef.cxx; src/MnPrint.cxx; src/MnPrintImpl.cxx; src/MnScan.cxx; src/MnSeedGenerator.cxx; src/MnStrategy.cxx; src/MnTiny.cxx; src/MnTraceObject.cxx; src/MnUserFcn.cxx; src/MnUserParameterState.cxx; src/MnUserParameters.cxx; src/MnUserTransformation.cxx; src/ModularFunctionMinimizer.cxx; src/NegativeG2LineSearch.cxx; src/Numerical2PGradientCalculator.cxx; src/NumericalDerivator.cxx; src/ParametricFunction.cxx; src/ScanBuilder.cxx; src/SimplexBuilder.cxx; src/SimplexParameters.cxx; src/SimplexSeedGenerator.cxx; src/SinParameterTransformation.cxx; src/SqrtLowParameterTransformation.cxx; src/SqrtUpParameterTransformation.cxx; src/TMinuit2TraceObject.cxx; src/VariableMetricBuilder.cxx; src/VariableMetricEDMEstimator.cxx; src/mnbins.cxx; src/mndasum.cxx; src/mndaxpy.cxx; src/mnddot.cxx; src/mndscal.cxx; src/mndspmv.cxx; src/mndspr.cxx; src/mnlsame.cxx; src/mnteigen.cxx; src/mntplot.cxx; src/mnvert.cxx; src/mnxerbla.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; MathCore; Hist; ); endif(). if(minuit2_omp); find_package(OpenMP REQUIRED); find_package(Threads REQUIRED). if(NOT TARGET OpenMP::OpenMP_CXX); add_library(OpenMP::OpenMP_CXX IMPORTED INTERFACE); set_property(TARGET OpenMP::OpenMP_CXX PROPERTY INTERFACE_COMPILE_DEFINITIONS -D_GLIBCXX_PARALLEL); set_property(TARGET OpenMP::OpenMP_CXX PROPERTY INTERFACE_COMPILE_OPTIONS ${OpenMP_CXX_FLAGS}); set_property(TARGET OpenMP::OpenMP_CXX PROPERTY INTERFACE_LINK_LIBRARIES ${OpenMP_CXX_LIBRARIES}); endif(). if(CMAKE_PROJE,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt:4976,Simpl,SimplexSeedGenerator,4976,math/minuit2/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt,1,['Simpl'],['SimplexSeedGenerator']
Usability,"ny '``indirect``' blocks(s). The only use of this today is to implement the ""goto"" feature of gcc inline; assembly where additional labels can be provided as locations for the inline; assembly to jump to. Example:; """""""""""""""". .. code-block:: llvm. ; ""asm goto"" without output constraints.; callbr void asm """", ""r,!i""(i32 %x); to label %fallthrough [label %indirect]. ; ""asm goto"" with output constraints.; <result> = callbr i32 asm """", ""=r,r,!i""(i32 %x); to label %fallthrough [label %indirect]. .. _i_resume:. '``resume``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. resume <type> <value>. Overview:; """""""""""""""""". The '``resume``' instruction is a terminator instruction that has no; successors. Arguments:; """""""""""""""""""". The '``resume``' instruction requires one argument, which must have the; same type as the result of any '``landingpad``' instruction in the same; function. Semantics:; """""""""""""""""""". The '``resume``' instruction resumes propagation of an existing; (in-flight) exception whose unwinding was interrupted with a; :ref:`landingpad <i_landingpad>` instruction. Example:; """""""""""""""". .. code-block:: llvm. resume { ptr, i32 } %exn. .. _i_catchswitch:. '``catchswitch``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind to caller; <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind label <default>. Overview:; """""""""""""""""". The '``catchswitch``' instruction is used by `LLVM's exception handling system; <ExceptionHandling.html#overview>`_ to describe the set of possible catch handlers; that may be executed by the :ref:`EH personality routine <personalityfn>`. Arguments:; """""""""""""""""""". The ``parent`` argument is the token of the funclet that contains the; ``catchswitch`` instruction. If the ``catchswitch`` is not inside a funclet,; this operand may be the token ``none``. The ``default`` argument is the label of another basi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:370117,resume,resume,370117,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['resume'],"['resume', 'resumes']"
Usability,"o (and update) the list of files in the file browser (left panel) when opening a ROOT file from the ""Open File"" menu. TGListView. Keyboard navigation is now fully working in the list view. TGMainFrame. Allow to save a snapshot of the GUI in a picture file. The supported formats are gif, jpg, png, tiff, and xpm. TGFileDialog. Allow to change directory by typing its name in the text entry field of the dialog. TProofProgressDialog. Added a speedometer widget (TGSpeedo) to display the processing rate; Added a check button to enable/disable smooth update of the speedometer (enabled by default). This could be useful in the case of slow displays (e.g. when using it via ssh); Several layout improvements. TRecorder. Improvements and consolidation of the cross-platform interoperability, allowing to record and replay sessions between different platforms with less side effects. NB: Using different OS/WM (Window Managers) and using different ROOT GUI settings (via e.g. system.rootrc) between recording and replaying may still produce a wrong behavior of the recorder.; New tutorial guitest_playback.C replaying a recorded session showing and validating the GUI (using guitest.C). GUI Builder; New features, new user interface; Several important features have been added to the builder, and its user interface has been redesigned.; Editing modes are now clearly distinguished with enabled and disabled layout mode. Possibility to enable automatic layout fasten the interface development, as the positioning doesn't have to be done manually anymore; Major changes in the user interface:. Added a list tree displaying the complete structure of the GUI; The name of every element of the GUI is now editable; New, more intuitive interface for padding and layout hints; Color settings option was added to the widget editor; Extended commands in the top menu (open project, save project...); Added important warning dialogs, such as ""Save project"" dialog when closing the window; Added several tool tips. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v526/index.html:1925,clear,clearly,1925,gui/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v526/index.html,2,"['clear', 'intuit']","['clearly', 'intuitive']"
Usability,"o 0 allows to remove the end-caps both on the graph and the legend.; It was requested [here](https://sft.its.cern.ch/jira/browse/ROOT-9184); - New color palette ""cividis"" implemented by Sven Augustin.; This colormap aims to solve problems that people with color vision deficiency have; with the common colormaps. For more details see:; Nuñez J, Anderton C, and Renslow R. Optimizing colormaps with consideration; for color vision deficiency to enable accurate interpretation of scientific data.; See the article [here](https://arxiv.org/abs/1712.01662); - New graphics style ""ATLAS"" from M.Sutton.; - In `TGraphPainter` the fit parameters were painted too early. [In some cases graph's; error bars overlapped the stat box](https://root-forum.cern.ch/t/hide-error-bars-behind-tpavestats/27996).; - Implement the possibility to generate high definition bitmap pictures in `TImageDump`.; This done via `gStyle->SetImageScaling(x);` `x` being a multiplication factor.; This new feature is now used to generate the reference guide with `x=3`.; Pictures in the reference guide are now much shaper and in particular the text. ## 3D Graphics Libraries; - When a LEGO plot was drawn with Theta=90, the X and Y axis were misplaced. ## Geometry Libraries. ## Database Libraries; - Fix issue related to time stamps manipulation done by `TPgSQLStatement` as suggested [here](https://root-forum.cern.ch/t/please-correct-bug-reading-date-time-from-postgresql-tpgsqlstatement). ## Networking Libraries; - New THttpWSHandler class should be used to work with websockets. It includes all necessary methods to handle multiple connections correctly. See in tutorials/http/ws.C how it can be used.; - Interface of THttpWSEngine class was changed, all its instances handled internally in THttpWSHandler. ## GUI Libraries. ## Montecarlo Libraries. ## Parallelism; - `TTree::GetEntry`: if IMT is enabled, run work in tasks if we have at least more than one top level branch.; - Make EnableImplicitMT no-op if IMT is already ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:13933,guid,guide,13933,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['guid'],['guide']
Usability,"o be any digit-only value specified; by the user, which permits testing the compiler against existing OpenACC; workloads in order to evaluate implementation progress. Target Specific Changes; -----------------------. AMDGPU Support; ^^^^^^^^^^^^^^; - Use pass-by-reference (byref) in stead of pass-by-value (byval) for struct; arguments in C ABI. Callee is responsible for allocating stack memory and; copying the value of the struct if modified. Note that AMDGPU backend still; supports byval for struct arguments.; - The default value for ``-mcode-object-version`` is now 5.; See `AMDHSA Code Object V5 Metadata <https://llvm.org/docs/AMDGPUUsage.html#code-object-v5-metadata>`_; for more details. X86 Support; ^^^^^^^^^^^. - Added option ``-m[no-]evex512`` to disable ZMM and 64-bit mask instructions; for AVX512 features.; - Support ISA of ``USER_MSR``.; * Support intrinsic of ``_urdmsr``.; * Support intrinsic of ``_uwrmsr``.; - Support ISA of ``AVX10.1``.; - ``-march=pantherlake`` and ``-march=clearwaterforest`` are now supported.; - Added ABI handling for ``__float128`` to match with GCC.; - Emit warnings for options to enable knl/knm specific ISAs: AVX512PF, AVX512ER; and PREFETCHWT1. From next version (LLVM 19), these ISAs' intrinsic supports; will be deprecated:; * intrinsic series of *_exp2a23_*; * intrinsic series of *_rsqrt28_*; * intrinsic series of *_rcp28_*; * intrinsic series of *_prefetch_i[3|6][2|4]gather_*; * intrinsic series of *_prefetch_i[3|6][2|4]scatter_*. Arm and AArch64 Support; ^^^^^^^^^^^^^^^^^^^^^^^. - C++ function name mangling has been changed to align with the specification; (https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst).; This affects C++ functions with SVE ACLE parameters. Clang will use the old; manglings if ``-fclang-abi-compat=17`` or lower is specified. - New AArch64 asm constraints have been added for r8-r11(Uci) and r12-r15(Ucj). - Support has been added for the following processors (-mcpu identifiers in parenthesis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:59955,clear,clearwaterforest,59955,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['clear'],['clearwaterforest']
Usability,"o do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open the file and lists its contents. ``` {.cpp}; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; ```. We can see the **`TTree `**""`T`"" in the file. We will use it to; experiment with the **`TTree::Draw`** method, so let's create a pointer to it:. ``` {.cpp}; root[] TTree *MyTree = T; ```. Cling allows us to get simply the object by using it. Here we define a; pointer to a **`TTree`** object and assign it the value of ""`T`"", the; **`TTree`** in the file. Cling looks for an object named ""`T`"" in the; current ROOT file and returns it (this assumes that ""T"" has not; previously been used to declare a variable or function). In contrast, in compiled code, you can use:. ``` {.cpp}; TTree *MyTree;f.GetObject(""T"",MyTree);; ```. To show the different `Draw` options, we create a canvas with four; sub-pads. We will use one sub-pad for each `Draw` command. ``` {.cpp}; root[] TCanvas *myCanvas = new TCanvas(); root[] myCanvas->Divide(2,2); ```. We activate the first pad with the `TCanvas::cd` statement:. ``` {.cpp}; root[] myCanvas->cd(1); ```. We then draw the variable `Cost`:. ``` {.cpp}; root[] MyTree->Draw(""C; ```. As you can see, the last call `TTree::Draw` has only one parameter. It; is a string containing the leaf name. A histogram is automatically; created as a result of a `TTree::Draw`. The style of t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:69116,simpl,simply,69116,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simply']
Usability,"o know the current direction `(nx,ny,nz)`. This; direction is stored as `Double_t fCurrentDirection[3]` by the navigator; and it represents a direction in the global frame. It can be retrieved; with:. ``` {.cpp}; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; ```. The direction can be initialized in a similar manner as the current; point:. ``` {.cpp}; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; ```. ### Initializing the State. Setting the initial point and direction is not enough for initializing; tracking. The modeller needs to find out where the initial point is; located in the geometrical hierarchy. Due to the containment based; architecture of the model, this is the deepest positioned object; containing the point. For illustrating this, imagine that we have a; simple structure with a top volume `A` and another one `B `positioned; inside. Since `A `is a top volume, its associated node `A_1` will define; `MARS` and our simple hierarchy of nodes (positioned volumes) will be:; `/A_1/B_1`. Suppose now that the initial point is contained by `B_1`.; This implies by default that the point is also contained by `A_1`, since; `B_1` have to be fully contained by this. After searching the point; location, the modeller will consider that the point is located inside; `B_1`, which will be considered as the representative object (node) for; the current state. This is stored as: **`TGeoNode`**; \*`TGeoManager::fCurrentNode `and can be asked from the manager class; only after the `'Where am I?'` was completed:. ``` {.cpp}; TGeoNode *current = gGeoManager->GetCurrentNode();; ```. In order to find the location of the current point inside the hierarchy; of nodes, after setting this point it is mandatory to call the; `‘Where am I?'` method:. ``` {.cpp}; gGeoManager->FindNode();; ```. In order to have more flexibility, there are in fact several alternative; ways of initializing a modeller state:. ``` {.cpp}; // Set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:105621,simpl,simple,105621,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"o not access or only read non-local memory, and marking them; ``readnone``/``readonly``. In addition, it marks function arguments (of; pointer type) ""``nocapture``"" if a call to the function does not create any; copies of the pointer value that outlive the call. This more or less means; that the pointer is only dereferenced, and not returned from the function or; stored in a global. This pass is implemented as a bottom-up traversal of the; call-graph. ``globaldce``: Dead Global Elimination; --------------------------------------. This transform is designed to eliminate unreachable internal globals from the; program. It uses an aggressive algorithm, searching out globals that are known; to be alive. After it finds all of the globals which are needed, it deletes; whatever is left over. This allows it to delete recursive chunks of the; program which are unreachable. ``globalopt``: Global Variable Optimizer; ----------------------------------------. This pass transforms simple global variables that never have their address; taken. If obviously true, it marks read/write globals as constant, deletes; variables only stored to, etc. ``gvn``: Global Value Numbering; -------------------------------. This pass performs global value numbering to eliminate fully and partially; redundant instructions. It also performs redundant load elimination. .. _passes-indvars:. ``indvars``: Canonicalize Induction Variables; ---------------------------------------------. This transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:17143,simpl,simple,17143,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"o open; a pull-request on GitHub. Review process; --------------. When you open a pull-request, some automation will add a comment and; notify different member of the projects depending on the component you; changed.; Within a few days, someone should start the review. They may add; themselves as a reviewer, or simply start leaving comments. You'll get; another email any time the review is updated. The details are in the; `https://llvm.org/docs/CodeReview/ <https://llvm.org/docs/CodeReview.html>`__. Comments; ~~~~~~~~. The reviewer can leave comments on the change, and you can reply. Some; comments are attached to specific lines, and appear interleaved with the; code. You can either reply to these, or address them and mark them as; ""done"". Note that in-line replies are **not** sent straight away! They; become ""draft"" comments and you must click ""Submit"" at the bottom of the; page. Updating your change; ~~~~~~~~~~~~~~~~~~~~. If you make changes in response to a reviewer's comments, simply update; your branch with more commits and push to your fork. It may be a good; idea to answer the comments from the reviewer explicitly. Accepting a revision; ~~~~~~~~~~~~~~~~~~~~. When the reviewer is happy with the change, they will **Accept** the; revision. They may leave some more minor comments that you should; address, but at this point the review is complete. It's time to get it; merged!. Commit by proxy; ---------------. As this is your first change, you won't have access to merge it; yourself yet. The reviewer **doesn't know this**, so you need to tell; them! Leave a message on the review like:. Thanks @somellvmdev. I don't have commit access, can you land this; patch for me?. The pull-request will be closed and you will be notified by GitHub. Review expectations; -------------------. In order to make LLVM a long-term sustainable effort, code needs to be; maintainable and well tested. Code reviews help to achieve that goal.; Especially for new contributors, that often means",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:10781,simpl,simply,10781,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['simpl'],['simply']
Usability,"o parse is not well-formed, the; parser should output an error message and return true. Otherwise it should; return false and set '``Val``' to the parsed value. In our example, we; implement ``parse`` as:. .. code-block:: c++. bool FileSizeParser::parse(cl::Option &O, StringRef ArgName,; const std::string &Arg, unsigned &Val) {; const char *ArgStart = Arg.c_str();; char *End;. // Parse integer part, leaving 'End' pointing to the first non-integer char; Val = (unsigned)strtol(ArgStart, &End, 0);. while (1) {; switch (*End++) {; case 0: return false; // No error; case 'i': // Ignore the 'i' in KiB if people use that; case 'b': case 'B': // Ignore B suffix; break;. case 'g': case 'G': Val *= 1024*1024*1024; break;; case 'm': case 'M': Val *= 1024*1024; break;; case 'k': case 'K': Val *= 1024; break;. default:; // Print an error message if unrecognized character!; return O.error(""'"" + Arg + ""' value invalid for file size argument!"");; }; }; }. This function implements a very simple parser for the kinds of strings we are; interested in. Although it has some holes (it allows ""``123KKK``"" for example),; it is good enough for this example. Note that we use the option itself to print; out the error message (the ``error`` method always returns true) in order to get; a nice error message (shown below). Now that we have our parser class, we can; use it like this:. .. code-block:: c++. static cl::opt<unsigned, false, FileSizeParser>; MFS(""max-file-size"", cl::desc(""Maximum file size to accept""),; cl::value_desc(""size""));. Which adds this to the output of our program:. ::. OPTIONS:; -help - display available options (-help-hidden for more); ...; -max-file-size=<size> - Maximum file size to accept. And we can test that our parse works correctly now (the test program just prints; out the max-file-size argument value):. ::. $ ./test; MFS: 0; $ ./test -max-file-size=123MB; MFS: 128974848; $ ./test -max-file-size=3G; MFS: 3221225472; $ ./test -max-file-size=dog; -max-file-size option: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:65209,simpl,simple,65209,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"o relies on additional C89-specific behavior that cannot; be changed. All of this only applies to C code; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4417,simpl,simple,4417,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['simpl'],['simple']
Usability,"o replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. #### Volume Families. A volume family is represented by the class **`TGeoVolumeMulti`**. It; represents a class of volumes having the same shape type and each member; will be identified by the same name and volume ID. Any operation applied; to a **`TGeoVolumeMulti`** equally affects all volumes in that family.; The creation of a family is generally not a user task, but can be forced; in particular cases:. ``` {.cpp}; TGeoManager::Volume(const char *vname,const char *shape,; Int_t nmed);; ```. Where: `vname` is the family name, `nmed` is the medium number and; `shap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:80672,simpl,simple,80672,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"o replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. \anchor GP01bh; #### Volume Families. A volume family is represented by the class TGeoVolumeMulti. It; represents a class of volumes having the same shape type and each member; will be identified by the same name and volume ID. Any operation applied; to a TGeoVolumeMulti equally affects all volumes in that family.; The creation of a family is generally not a user task, but can be forced; in particular cases:. ~~~{.cpp}; TGeoManager::Volume(const char *vname,const char *shape, Int_t nmed);; ~~~. Where: `vname` is the family name, `nmed` is the medium number and; `sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:41115,simpl,simple,41115,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"o share the bulk of the architecture specific; code (especially relocations) for each supported architecture. * Refactor ELF link graph construction. ELF's link graph construction is currently implemented in the `ELF_x86_64.cpp`; file, and tied to the x86-64 relocation parsing code. The bulk of the code is; generic and should be split into an ELFLinkGraphBuilder base class along the; same lines as the existing generic MachOLinkGraphBuilder. * Implement support for arm32. * Implement support for other new architectures. JITLink Availability and Feature Status; ---------------------------------------. The following table describes the status of the JITlink backends for various; format / architecture combinations (as of July 2023). Support levels:. * None: No backend. JITLink will return an ""architecture not supported"" error.; Represented by empty cells in the table below.; * Skeleton: A backend exists, but does not support commonly used relocations.; Even simple programs are likely to trigger an ""unsupported relocation"" error.; Backends in this state may be easy to improve by implementing new relocations.; Consider getting involved!; * Basic: The backend supports simple programs, isn't ready for general use yet.; * Usable: The backend is useable for general use for at least one code and; relocation model.; * Good: The backend supports almost all relocations. Advanced features like; native thread local storage may not be available yet.; * Complete: The backend supports all relocations and object format features. .. list-table:: Availability and Status; :widths: 10 30 30 30; :header-rows: 1; :stub-columns: 1. * - Architecture; - ELF; - COFF; - MachO; * - arm32; - Skeleton; -; -; * - arm64; - Usable; -; - Good; * - LoongArch; - Good; -; -; * - PowerPC 64; - Usable; -; -; * - RISC-V; - Good; -; -; * - x86-32; - Basic; -; -; * - x86-64; - Good; - Usable; - Good. .. [1] See ``llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin`` for; a full worked example. .. [2] I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:45669,simpl,simple,45669,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['simpl'],['simple']
Usability,"o, we will just need to; replicate the ones that we have already created. ~~~{.cpp}; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; ~~~. The 2 nodes that we have created inside chamber will both point to a; `wire_co` object, but will be completely distinct: `WIRE_CO_1` and; `WIRE_CO_2`. We will want now to place symmetrically 1000 chambers on a; pad, following a pattern of 20 rows and 50 columns. One way to do this; will be to replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. \anchor GP01bh; #### Volume Families. A volume family is represented b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:40532,simpl,simple,40532,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"o.suspend``' marks the point where execution of a; switched-resume coroutine is suspended and control is returned back; to the caller. Conditional branches consuming the result of this; intrinsic lead to basic blocks where coroutine should proceed when; suspended (-1), resumed (0) or destroyed (1). Arguments:; """""""""""""""""""". The first argument refers to a token of `coro.save` intrinsic that marks the; point when coroutine state is prepared for suspension. If `none` token is passed,; the intrinsic behaves as if there were a `coro.save` immediately preceding; the `coro.suspend` intrinsic. The second argument indicates whether this suspension point is `final`_.; The second argument only accepts constants. If more than one suspend point is; designated as final, the resume and destroy branches should lead to the same; basic blocks. Example (normal suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %resume; i8 1, label %cleanup]. Example (final suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. while.end:; %s.final = call i8 @llvm.coro.suspend(token none, i1 true); switch i8 %s.final, label %suspend [i8 0, label %trap; i8 1, label %cleanup]; trap:; call void @llvm.trap(); unreachable. Semantics:; """""""""""""""""""". If a coroutine that was suspended at the suspend point marked by this intrinsic; is resumed via `coro.resume`_ the control will transfer to the basic block; of the 0-case. If it is resumed via `coro.destroy`_, it will proceed to the; basic block indicated by the 1-case. To suspend, coroutine proceed to the; default label. If suspend intrinsic is marked as final, it can consider the `true` branch; unreachable and can perform optimizations that can take advantage of that fact. .. _coro.save:. 'llvm.coro.save' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.save(ptr <handle>). Overview:; """""""""""""""""". The '``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:50828,resume,resume,50828,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"o:. .. code-block:: c++. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());. LoopPrinter Printer;; MatchFinder Finder;; Finder.addMatcher(LoopMatcher, &Printer);. return Tool.run(newFrontendActionFactory(&Finder).get());; }. Now, you should be able to recompile and run the code to discover for; loops. Create a new file with a few examples, and test out our new; handiwork:. .. code-block:: console. cd ~/clang-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:10567,simpl,simple,10567,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simple']
Usability,"o:. define i32 @foo(i8 zeroext %i) nounwind readnone ssp noredzone {; entry:; %conv = zext i8 %i to i32; %shl = shl i32 %conv, 8; %shl5 = shl i32 %conv, 16; %shl9 = shl i32 %conv, 24; %or = or i32 %shl9, %conv; %or6 = or i32 %or, %shl5; %or10 = or i32 %or6, %shl; ret i32 %or10; }. it would be better as:. unsigned int bar(unsigned char i) {; unsigned int j=i | (i << 8); ; return j | (j<<16);; }. aka:. define i32 @bar(i8 zeroext %i) nounwind readnone ssp noredzone {; entry:; %conv = zext i8 %i to i32; %shl = shl i32 %conv, 8; %or = or i32 %shl, %conv; %shl5 = shl i32 %or, 16; %or6 = or i32 %shl5, %or; ret i32 %or6; }. or even i*0x01010101, depending on the speed of the multiplier. The best way to; handle this is to canonicalize it to a multiply in IR and have codegen handle; lowering multiplies to shifts on cpus where shifts are faster. //===---------------------------------------------------------------------===//. We do a number of simplifications in simplify libcalls to strength reduce; standard library functions, but we don't currently merge them together. For; example, it is useful to merge memcpy(a,b,strlen(b)) -> strcpy. This can only; be done safely if ""b"" isn't modified between the strlen and memcpy of course. //===---------------------------------------------------------------------===//. We compile this program: (from GCC PR11680); http://gcc.gnu.org/bugzilla/attachment.cgi?id=4487. Into code that runs the same speed in fast/slow modes, but both modes run 2x; slower than when compile with GCC (either 4.0 or 4.2):. $ llvm-g++ perf.cpp -O3 -fno-exceptions; $ time ./a.out fast; 1.821u 0.003s 0:01.82 100.0%	0+0k 0+0io 0pf+0w. $ g++ perf.cpp -O3 -fno-exceptions; $ time ./a.out fast; 0.821u 0.001s 0:00.82 100.0%	0+0k 0+0io 0pf+0w. It looks like we are making the same inlining decisions, so this may be raw; codegen badness or something else (haven't investigated). //===---------------------------------------------------------------------===//. Divisibility by const",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:18461,simpl,simplifications,18461,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,2,['simpl'],"['simplifications', 'simplify']"
Usability,"o; come up with a precise partitioning in all cases without variables to; represent every pair of possible aliases. Thus, partitioning; precisely may require introducing at least N^2 new virtual variables,; phi nodes, etc. Each of these variables may be clobbered at multiple def sites. To give an example, if you were to split up struct fields into; individual variables, all aliasing operations that may-def multiple struct; fields, will may-def more than one of them. This is pretty common (calls,; copies, field stores, etc). Experience with SSA forms for memory in other compilers has shown that; it is simply not possible to do this precisely, and in fact, doing it; precisely is not worth it, because now all the optimizations have to; walk tons and tons of virtual variables and phi nodes. So we partition. At the point at which you partition, again,; experience has shown us there is no point in partitioning to more than; one variable. It simply generates more IR, and optimizations still; have to query something to disambiguate further anyway. As a result, LLVM partitions to one variable. Precision in practice; ^^^^^^^^^^^^^^^^^^^^^. In practice, there are implementation details in LLVM that also affect the; results' precision provided by ``MemorySSA``. For example, AliasAnalysis has various; caps, or restrictions on looking through phis which can affect what ``MemorySSA``; can infer. Changes made by different passes may make MemorySSA either ""overly; optimized"" (it can provide a more accurate result than if it were recomputed; from scratch), or ""under optimized"" (it could infer more if it were recomputed).; This can lead to challenges to reproduced results in isolation with a single pass; when the result relies on the state acquired by ``MemorySSA`` due to being updated by; multiple subsequent passes.; Passes that use and update ``MemorySSA`` should do so through the APIs provided by the; ``MemorySSAUpdater``, or through calls on the Walker.; Direct optimizations to ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:18302,simpl,simply,18302,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['simpl'],['simply']
Usability,"o; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin, this implies that the Clang driver also subsumes the gcc; driver-driver, which is used to implement support for building universal; images (binaries and object files). This also implies that the driver; should be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:2112,simpl,simple,2112,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simple']
Usability,"oAbsArg have RooAbsReal as an; intermediate base class, which is the base class for all RooAbsArg that; represent real-valued nodes in the computation graph.; As such RooFit objects are so prevalent in practice, the names RooAbsArg and; RooAbsReal are used interchangeably in this guide. Users take these classes to build a computational graph that represents the; PDF (also called ""model"") that they want to use for fitting the data.; The user then passes his final PDF and a RooAbsData object to the; RooAbsPdf::fitTo() method, which implicitly creates a negative-log likelihood; (NLL) that RooFit minimizes for parameter estimation.; The NLL object, internally created by RooAbsPdf::createNLL(), is a RooAbsArg; itself.; In technical terms, it's another larger computation graph that encompasses the; computation graph representing the PDF. To enable source code transformation AD for RooFit NLLs with Clad, RooFit has a; routine that can traverse a computation graph made of RooAbsArg objects and; transform it to much simpler C++ code that mathematically represents the same; computation, but without any overhead that is hard to digest by the AD tool. On a high level, this *code generation* is implemented as follows:. 1. The computation graph is visited recursively by a; RooFit::Detail::CodeSquashContext object, via the virtual; RooAbsArg::translate() function that implements the translation of a; given RooFit class to minimal C++ code. This is an example of the visitor; pattern. 2. The generated code is processed by a RooFuncWrapper object, which takes care; of just-in-time compiling it with the ROOT interpreter, generating the; gradient code with Clad, and compiling that as well. 3. Since the RooFuncWrapper is implementing a RooAbsArg itself, it can now be; used as a drop-in replacement for the RooAbsArg that was the top node of the; original computation graph, with the added benefit that it can be queried for; the gradient. In summary, the important ingredient to enable AD i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:4210,simpl,simpler,4210,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simpler']
Usability,"oFix; ==============. .. contents::; :local:. Introduction; ============. This tutorial will guide you through the process of making a change to; LLVM, and contributing it back to the LLVM project. We'll be making a; change to Clang, but the steps for other parts of LLVM are the same.; Even though the change we'll be making is simple, we're going to cover; steps like building LLVM, running the tests, and code review. This is; good practice, and you'll be prepared for making larger changes. We'll assume you:. - know how to use an editor,. - have basic C++ knowledge,. - know how to install software on your system,. - are comfortable with the command line,. - have basic knowledge of git. The change we're making; -----------------------. Clang has a warning for infinite recursion:. .. code:: console. $ echo ""void foo() { foo(); }"" > ~/test.cc; $ clang -c -Wall ~/test.cc; input.cc:1:14: warning: all paths through this function will call; itself [-Winfinite-recursion]. This is clear enough, but not exactly catchy. Let's improve the wording; a little:. .. code:: console. input.cc:1:14: warning: to understand recursion, you must first; understand recursion [-Winfinite-recursion]. Dependencies; ------------. We're going to need some tools:. - git: to check out the LLVM source code,. - a C++ compiler: to compile LLVM source code. You'll want `a recent; version <https://llvm.org/docs/GettingStarted.html#host-c-toolchain-both-compiler-and-standard-library>`__; of Clang, GCC, or Visual Studio. - CMake: used to configure how LLVM should be built on your system,. - ninja: runs the C++ compiler to (re)build specific parts of LLVM,. - python: to run the LLVM tests,. As an example, on Ubuntu:. .. code:: console. $ sudo apt-get install git clang cmake ninja-build python arcanist. Building LLVM; =============. Checkout; --------. The source code is stored `on; Github <https://github.com/llvm/llvm-project>`__ in one large repository; (""the monorepo""). It may take a while to download!. .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:1012,clear,clear,1012,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['clear'],['clear']
Usability,"oads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf).; On AMD systems `lfence` is currently a no-op, but can be made; dispatch-serializing by setting an MSR, and thus preclude misspeculation of the; code path ([mitigation G-2 +; V1-1](https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf)). However, this relies on finding and enumerating all possible points in code; which could be attacked to leak information. While in some cases static; analysis is effective at doing this at scale, in many cases it still relies on; human judgement to evaluate whether code might be vulnerable. Especially for; software systems which receive less detailed scrutiny but remain sensitive to; these attacks, this seems like an impractical security model. We need an; automatic and systematic mitigation strategy. ### Automatic `lfence` on Conditional Edges. A natural way to scale up the existing hand-coded mitigations is simply to; inject an `lfence` instruction into both the target and fallthrough; destinations of every conditional branch. This ensures that no predicate or; bounds check can be bypassed speculatively. However, the performance overhead; of this approach is, simply put, catastrophic. Yet it remains the only truly; ""secure by default"" approach known prior to this effort and serves as the; baseline for performance. One attempt to address the performance overhead of this and make it more; realistic to deploy is [MSVC's /Qspectre; switch](https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/).; Their technique is to use static analysis within the compiler to only insert; `lfence` instructions into conditional edges at risk of attack. However,; [initial](https://arstechnica.com/gadgets/2018/02/microsofts-compiler-level-spectre-fix-shows-how-hard-this-problem-will-be-to-solve/); [analysis](https://www.paulkocher.com/doc/MicrosoftCompilerSpectreMitigation.html); has shown that this approach is in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:45170,simpl,simply,45170,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simply']
Usability,"obably not; prevented M from finding the right minimum. On the other hand, if one or; more parameters is near its limit at the minimum, this may be because; the true minimum is indeed at a limit, or it may be because the; minimizer has become ""blocked"" at a limit. This may normally happen only; if the parameter is so close to a limit (internal value at an odd; multiple of $\pm \frac{ \pi}{ 2}$ that M prints a warning to this effect; when it prints the parameter values. The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer; $\partial F / \partial P_{\mathrm{int}}$ is zero no matter what the real; derivative $\partial F / \partial P_{\mathrm{ext}}$ is. $$\frac{\partial F}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}}; \frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}} = 0$$. For a stepping method (like $\mbox{SIMPLEX}$) this seldom poses any; problem, but a method based on derivatives ($\mbox{MIGRAD}$) may; become blocked at such a value. If this happens, it may be necessary to; move the value of the parameter in question a significant distance from; the limit (e.g. with MnMigrad::setValue(...)) and restart the; minimization, perhaps with that parameter fixed temporarily. ### Getting the right parameter errors with limits ###. [answer:right-errors]. In the best case, where the minimum is far from any limits, M will; correctly transform the error matrix, and the parameter errors it; reports should be accurate and very close to those you would have got; without limits. In other cases (which should be more common, since; otherwise you wouldn't need limits), the very meaning of parameter; errors becomes problematic. Mathematically, since the limit is an; absolute constraint on the parameter, a parameter at its limit has no; error, at least in one direction. The error matrix, which can assign; only symmetric errors, then becomes essentially m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:64977,SIMPL,SIMPLEX,64977,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['SIMPL'],['SIMPLEX']
Usability,"objects that; keep the coroutine state when a coroutine is suspended. This region of storage; is called the **coroutine frame**. It is created when a coroutine is called; and destroyed when a coroutine either runs to completion or is destroyed; while suspended. LLVM currently supports two styles of coroutine lowering. These styles; support substantially different sets of features, have substantially; different ABIs, and expect substantially different patterns of frontend; code generation. However, the styles also have a great deal in common. In all cases, an LLVM coroutine is initially represented as an ordinary LLVM; function that has calls to `coroutine intrinsics`_ defining the structure of; the coroutine. The coroutine function is then, in the most general case,; rewritten by the coroutine lowering passes to become the ""ramp function"",; the initial entrypoint of the coroutine, which executes until a suspend point; is first reached. The remainder of the original coroutine function is split; out into some number of ""resume functions"". Any state which must persist; across suspensions is stored in the coroutine frame. The resume functions; must somehow be able to handle either a ""normal"" resumption, which continues; the normal execution of the coroutine, or an ""abnormal"" resumption, which; must unwind the coroutine without attempting to suspend it. Switched-Resume Lowering; ------------------------. In LLVM's standard switched-resume lowering, signaled by the use of; `llvm.coro.id`, the coroutine frame is stored as part of a ""coroutine; object"" which represents a handle to a particular invocation of the; coroutine. All coroutine objects support a common ABI allowing certain; features to be used without knowing anything about the coroutine's; implementation:. - A coroutine object can be queried to see if it has reached completion; with `llvm.coro.done`. - A coroutine object can be resumed normally if it has not already reached; completion with `llvm.coro.resume`. - A ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:2203,resume,resume,2203,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"oc:`CMake` or :doc:`CMakePrimer`; documentation useful. Some of the things covered in this document are the inner; workings of the builds described in the :doc:`AdvancedBuilds` document. General Distribution Guidance; =============================. When building a distribution of a compiler it is generally advised to perform a; bootstrap build of the compiler. That means building a ""stage 1"" compiler with; your host toolchain, then building the ""stage 2"" compiler using the ""stage 1""; compiler. This is done so that the compiler you distribute benefits from all the; bug fixes, performance optimizations and general improvements provided by the; new compiler. In deciding how to build your distribution there are a few trade-offs that you; will need to evaluate. The big two are:. #. Compile time of the distribution against performance of the built compiler. #. Binary size of the distribution against performance of the built compiler. The guidance for maximizing performance of the generated compiler is to use LTO,; PGO, and statically link everything. This will result in an overall larger; distribution, and it will take longer to generate, but it provides the most; opportunity for the compiler to optimize. The guidance for minimizing distribution size is to dynamically link LLVM and; Clang libraries into the tools to reduce code duplication. This will come at a; substantial performance penalty to the generated binary both because it reduces; optimization opportunity, and because dynamic linking requires resolving symbols; at process launch time, which can be very slow for C++ code. .. _shared_libs:. .. warning::; One very important note: Distributions should never be built using the; *BUILD_SHARED_LIBS* CMake option. That option exists for optimizing developer; workflow only. Due to design and implementation decisions, LLVM relies on; global data which can end up being duplicated across shared libraries; resulting in bugs. As such this is not a safe way to distribute LLVM o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:1414,guid,guidance,1414,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['guid'],['guidance']
Usability,"ocal variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'su",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8146,clear,clear,8146,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['clear'],['clear']
Usability,"ock:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using the output from stage*n-1*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:3832,simpl,simplify,3832,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['simpl'],['simplify']
Usability,"ock`` is so common that the ``Instruction``; class and ``Instruction``-derived classes provide constructors which take a; pointer to a ``BasicBlock`` to be appended to. For example code that looked; like:. .. code-block:: c++. BasicBlock *pb = ...;; auto *newInst = new Instruction(...);. newInst->insertInto(pb, pb->end()); // Appends newInst to pb. becomes:. .. code-block:: c++. BasicBlock *pb = ...;; auto *newInst = new Instruction(..., pb);. which is much cleaner, especially if you are creating long instruction; streams. * Insertion using an instance of ``IRBuilder``. Inserting several ``Instruction``\ s can be quite laborious using the previous; methods. The ``IRBuilder`` is a convenience class that can be used to add; several instructions to the end of a ``BasicBlock`` or before a particular; ``Instruction``. It also supports constant folding and renaming named; registers (see ``IRBuilder``'s template arguments). The example below demonstrates a very simple use of the ``IRBuilder`` where; three instructions are inserted before the instruction ``pi``. The first two; instructions are Call instructions and third instruction multiplies the return; value of the two calls. .. code-block:: c++. Instruction *pi = ...;; IRBuilder<> Builder(pi);; CallInst* callOne = Builder.CreateCall(...);; CallInst* callTwo = Builder.CreateCall(...);; Value* result = Builder.CreateMul(callOne, callTwo);. The example below is similar to the above example except that the created; ``IRBuilder`` inserts instructions at the end of the ``BasicBlock`` ``pb``. .. code-block:: c++. BasicBlock *pb = ...;; IRBuilder<> Builder(pb);; CallInst* callOne = Builder.CreateCall(...);; CallInst* callTwo = Builder.CreateCall(...);; Value* result = Builder.CreateMul(callOne, callTwo);. See :doc:`tutorial/LangImpl03` for a practical use of the ``IRBuilder``. .. _schanges_deleting:. Deleting Instructions; ^^^^^^^^^^^^^^^^^^^^^. Deleting an instruction from an existing sequence of instructions that form a; Basi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:117052,simpl,simple,117052,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"ocs/gcc/_005f_005fsync-Builtins.html>`_). * Other scenarios with atomic semantics, including ``static`` variables with; non-trivial constructors in C++. Atomic and volatile in the IR are orthogonal; ""volatile"" is the C/C++ volatile,; which ensures that every volatile load and store happens and is performed in the; stated order. A couple examples: if a SequentiallyConsistent store is; immediately followed by another SequentiallyConsistent store to the same; address, the first store can be erased. This transformation is not allowed for a; pair of volatile stores. On the other hand, a non-volatile non-atomic load can; be moved across a volatile load freely, but not an Acquire load. This document is intended to provide a guide to anyone either writing a frontend; for LLVM or working on optimization passes for LLVM with a guide for how to deal; with instructions with special semantics in the presence of concurrency. This; is not intended to be a precise guide to the semantics; the details can get; extremely complicated and unreadable, and are not usually necessary. .. _Optimization outside atomic:. Optimization outside atomic; ===========================. The basic ``'load'`` and ``'store'`` allow a variety of optimizations, but can; lead to undefined results in a concurrent environment; see `NotAtomic`_. This; section specifically goes into the one optimizer restriction which applies in; concurrent environments, which gets a bit more of an extended description; because any optimization dealing with stores needs to be aware of it. From the optimizer's point of view, the rule is that if there are not any; instructions with atomic ordering involved, concurrency does not matter, with; one exception: if a variable might be visible to another thread or signal; handler, a store cannot be inserted along a path where it might not execute; otherwise. Take the following example:. .. code-block:: c. /* C code, for readability; run through clang -O2 -S -emit-llvm to get; equivalent ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:2256,guid,guide,2256,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['guid'],['guide']
Usability,"ode-block:: c++. // Foo is non-trivial.; struct Foo { int a; Foo(); Foo(const &Foo); ~Foo(); };; Foo bar(Foo b);; int main() {; bar(bar(Foo()));; }. In this case, we want to be able to elide copies into ``bar``'s argument; slots. That means we need to have more than one set of argument frames; active at the same time. First, we need to allocate the frame for the; outer call so we can pass it in as the hidden struct return pointer to; the middle call. Then we do the same for the middle call, allocating a; frame and passing its address to ``Foo``'s default constructor. By; wrapping the evaluation of the inner ``bar`` with stack save and; restore, we can have multiple overlapping active call frames. Callee-cleanup Calling Conventions; ----------------------------------. Another wrinkle is the existence of callee-cleanup conventions. On; Windows, all methods and many other functions adjust the stack to clear; the memory used to pass their arguments. In some sense, this means that; the allocas are automatically cleared by the call. However, LLVM; instead models this as a write of undef to all of the inalloca values; passed to the call instead of a stack adjustment. Frontends should; still restore the stack pointer to avoid a stack leak. Exceptions; ----------. There is also the possibility of an exception. If argument evaluation; or copy construction throws an exception, the landing pad must do; cleanup, which includes adjusting the stack pointer to avoid a stack; leak. This means the cleanup of the stack memory cannot be tied to the; call itself. There needs to be a separate IR-level instruction that can; perform independent cleanup of arguments. Efficiency; ----------. Eventually, it should be possible to generate efficient code for this; construct. In particular, using inalloca should not require a base; pointer. If the backend can prove that all points in the CFG only have; one possible stack level, then it can address the stack directly from; the stack pointer. While",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst:5169,clear,cleared,5169,interpreter/llvm-project/llvm/docs/InAlloca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst,1,['clear'],['cleared']
Usability,"ode-block:: text. typeTestAssumeConstVCalls: (ConstVCall[, ConstVCall]*). Where each ConstVCall has the format:. .. code-block:: text. (VFuncId, args: (Arg[, Arg]*)). and where each VFuncId has the format described for ``TypeTestAssumeVCalls``,; and each Arg is an integer argument number. TypeCheckedLoadConstVCalls; """""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: text. typeCheckedLoadConstVCalls: (ConstVCall[, ConstVCall]*). Where each ConstVCall has the format described for; ``TypeTestAssumeConstVCalls``. .. _typeid_summary:. Type ID Summary Entry; ---------------------. Each type id summary entry corresponds to a type identifier resolution; which is generated during the LTO link portion of the compile when building; with `Control Flow Integrity <https://clang.llvm.org/docs/ControlFlowIntegrity.html>`_,; so these are only present in a combined summary index. Example:. .. code-block:: text. ^4 = typeid: (name: ""_ZTS1A"", summary: (typeTestRes: (kind: allOnes, sizeM1BitWidth: 7[, alignLog2: 0]?[, sizeM1: 0]?[, bitMask: 0]?[, inlineBits: 0]?)[, WpdResolutions]?)) ; guid = 7004155349499253778. The ``typeTestRes`` gives the type test resolution ``kind`` (which may; be ``unsat``, ``byteArray``, ``inline``, ``single``, or ``allOnes``), and; the ``size-1`` bit width. It is followed by optional flags, which default to 0,; and an optional WpdResolutions (whole program devirtualization resolution); field that looks like:. .. code-block:: text. wpdResolutions: ((offset: 0, WpdRes)[, (offset: 1, WpdRes)]*. where each entry is a mapping from the given byte offset to the whole-program; devirtualization resolution WpdRes, that has one of the following formats:. .. code-block:: text. wpdRes: (kind: branchFunnel); wpdRes: (kind: singleImpl, singleImplName: ""_ZN1A1nEi""); wpdRes: (kind: indir). Additionally, each wpdRes has an optional ``resByArg`` field, which; describes the resolutions for calls with all constant integer arguments:. .. code-block:: text. resByArg: (ResByArg[, ResByArg]*).",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:348897,guid,guid,348897,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['guid'],['guid']
Usability,"ode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:77587,simpl,simple,77587,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,"odeView Type Records <CodeViewTypes>`. .. _type_indices:. Type Indices; ============. A type index is a 32-bit integer that uniquely identifies a type inside of an; object file's ``.debug$T`` section or a PDB file's TPI or IPI stream. The; value of the type index for the first type record from the TPI stream is given; by the ``TypeIndexBegin`` member of the :ref:`TPI Stream Header <tpi_header>`; although in practice this value is always equal to 0x1000 (4096). Any type index with a high bit set is considered to come from the IPI stream,; although this appears to be more of a hack, and LLVM does not generate type; indices of this nature. They can, however, be observed in Microsoft PDBs; occasionally, so one should be prepared to handle them. Note that having the; high bit set is not a necessary condition to determine whether a type index; comes from the IPI stream, it is only sufficient. Once the high bit is cleared, any type index >= ``TypeIndexBegin`` is presumed; to come from the appropriate stream, and any type index less than this is a; bitmask which can be decomposed as follows:. .. code-block:: none. .---------------------------.------.----------.; | Unused | Mode | Kind |; '---------------------------'------'----------'; |+32 |+12 |+8 |+0. - **Kind** - A value from the following enum:. .. code-block:: c++. enum class SimpleTypeKind : uint32_t {; None = 0x0000, // uncharacterized type (no type); Void = 0x0003, // void; NotTranslated = 0x0007, // type not translated by cvpack; HResult = 0x0008, // OLE/COM HRESULT. SignedCharacter = 0x0010, // 8 bit signed; UnsignedCharacter = 0x0020, // 8 bit unsigned; NarrowCharacter = 0x0070, // really a char; WideCharacter = 0x0071, // wide char; Character16 = 0x007a, // char16_t; Character32 = 0x007b, // char32_t; Character8 = 0x007c, // char8_t. SByte = 0x0068, // 8 bit signed int; Byte = 0x0069, // 8 bit unsigned int; Int16Short = 0x0011, // 16 bit signed; UInt16Short = 0x0021, // 16 bit unsigned; Int16 = 0x0072, // 16 bi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst:4162,clear,cleared,4162,interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst,1,['clear'],['cleared']
Usability,"odule); and stores it in the target ``JITDylib``, arranging for it to be passed back; to the layer's emit method when any symbol defined by that module is requested.; Each layer can complete its own work by calling the ``emit`` method of its base; layer. For example, in this tutorial our IRTransformLayer calls through to; our IRCompileLayer to compile the transformed IR, and our IRCompileLayer in; turn calls our ObjectLayer to link the object file produced by our compiler. So far we have learned how to optimize and compile our LLVM IR, but we have; not focused on when compilation happens. Our current REPL optimizes and; compiles each function as soon as it is referenced by any other code,; regardless of whether it is ever called at runtime. In the next chapter we; will introduce a fully lazy compilation, in which functions are not compiled; until they are first called at run-time. At this point the trade-offs get much; more interesting: the lazier we are, the quicker we can start executing the; first function, but the more often we will have to pause to compile newly; encountered functions. If we only code-gen lazily, but optimize eagerly, we; will have a longer startup time (as everything is optimized at that time) but; relatively short pauses as each function just passes through code-gen. If we; both optimize and code-gen lazily we can start executing the first function; more quickly, but we will have longer pauses as each function has to be both; optimized and code-gen'd when it is first executed. Things become even more; interesting if we consider interprocedural optimizations like inlining, which; must be performed eagerly. These are complex trade-offs, and there is no; one-size-fits all solution to them, but by providing composable layers we leave; the decisions to the person implementing the JIT, and make it easy for them to; experiment with different configurations. `Next: Adding Per-function Lazy Compilation <BuildingAJIT3.html>`_. Full Code Listing; ======",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:10939,pause,pause,10939,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['pause'],['pause']
Usability,"oes not not all of the callers. This includes functions; with normal external linkage as well as templates, C99 inline functions etc.; Specifically, it does nothing to:. define i32 @test(i32 %x, i32 %y, i32 %z) nounwind {; entry:; %0 = add nsw i32 %y, %z ; %1 = mul i32 %0, %x ; %2 = mul i32 %y, %z ; %3 = add nsw i32 %1, %2 ; ret i32 %3; }. define i32 @test2() nounwind {; entry:; %0 = call i32 @test(i32 1, i32 2, i32 4) nounwind; ret i32 %0; }. It would be interesting extend IPSCCP to be able to handle simple cases like; this, where all of the arguments to a call are constant. Because IPSCCP runs; before inlining, trivial templates and inline functions are not yet inlined.; The results for a function + set of constant arguments should be memoized in a; map. //===---------------------------------------------------------------------===//. The libcall constant folding stuff should be moved out of SimplifyLibcalls into; libanalysis' constantfolding logic. This would allow IPSCCP to be able to; handle simple things like this:. static int foo(const char *X) { return strlen(X); }; int bar() { return foo(""abcd""); }. //===---------------------------------------------------------------------===//. function-attrs doesn't know much about memcpy/memset. This function should be; marked readnone rather than readonly, since it only twiddles local memory, but; function-attrs doesn't handle memset/memcpy/memmove aggressively:. struct X { int *p; int *q; };; int foo() {; int i = 0, j = 1;; struct X x, y;; int **p;; y.p = &i;; x.q = &j;; p = __builtin_memcpy (&x, &y, sizeof (int *));; return **p;; }. This can be seen at:; $ clang t.c -S -o - -mkernel -O0 -emit-llvm | opt -function-attrs -S. //===---------------------------------------------------------------------===//. Missed instcombine transformation:; define i1 @a(i32 %x) nounwind readnone {; entry:; %cmp = icmp eq i32 %x, 30; %sub = add i32 %x, -30; %cmp2 = icmp ugt i32 %sub, 9; %or = or i1 %cmp, %cmp2; ret i1 %or; }; This should b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:46687,simpl,simple,46687,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simple']
Usability,"oexcept {}. struct FinalSuspend {; std::coroutine_handle<> continuation;; auto await_ready() noexcept { return false; }; auto await_suspend(std::coroutine_handle<> handle) noexcept {; return continuation;; }; void await_resume() noexcept {}; };; FinalSuspend final_suspend() noexcept { return {continuation}; }. void return_value(int res) { result = res; }. std::coroutine_handle<> continuation = std::noop_coroutine();; int result = 0;; };. task(std::coroutine_handle<promise_type> handle) : handle(handle) {}; ~task() {; if (handle); handle.destroy();; }. auto operator co_await() {; struct Awaiter {; std::coroutine_handle<promise_type> handle;; auto await_ready() { return false; }; auto await_suspend(std::coroutine_handle<> continuation) {; handle.promise().continuation = continuation;; return handle;; }; int await_resume() {; int ret = handle.promise().result;; handle.destroy();; return ret;; }; };; return Awaiter{std::exchange(handle, nullptr)};; }. int syncStart() {; handle.resume();; return handle.promise().result;; }. private:; std::coroutine_handle<promise_type> handle;; };. task task::promise_type::get_return_object() {; return std::coroutine_handle<promise_type>::from_promise(*this);; }. namespace detail {; template <int N>; task chain_fn() {; co_return N + co_await chain_fn<N - 1>();; }. template <>; task chain_fn<0>() {; // This is the default breakpoint.; __builtin_debugtrap();; co_return 0;; }; } // namespace detail. task chain() {; co_return co_await detail::chain_fn<30>();; }. int main() {; std::cout << chain().syncStart() << ""\n"";; return 0;; }. In the example, the ``task`` coroutine holds a ``continuation`` field,; which would be resumed once the ``task`` completes.; In another word, the ``continuation`` is the asynchronous caller for the ``task``.; Just like the normal function returns to its caller when the function completes. So we can use the ``continuation`` field to construct the asynchronous stack:. .. code-block:: python. # debugging-helper.py; im",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:13932,resume,resume,13932,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability,"of a; packet containing various information about the performance related to; that file only.; Added support also for performance monitoring when writing. RGLITE: A ROOT GRID interface. RGLite plug-in - a ROOT plug-in module, which implements the ROOT Grid; interface and offers to ROOT users possibilities to perform a number of; operations using gLite middleware from within ROOT. Supported features:. Workload Management System operations:; ; job submission – normal, DAG and parametric; jobs (gLite; WMProxy API), ; smart look-up algorithm for WMP-Endpoints, ; job status querying (gLite LB API), ; job output retrieving (Globus GridFTP). . File Catalog operations (gLite/LCG LFC API):; ; smart session manager, ; set/query the current working catalog directory, ; list files, directories and their stats, ; add/remove files in a catalog namespace, ; add/remove directories, ; add/remove replicas from a given file. . An executive logging. ; Support of an external XML configuration file with; according XML; schema. . Usage examples:. Job operations. // loading RGLite plug-in. TGrid::Connect(""glite"");; // submitting Grid job. TGridJob *job = gGrid->Submit(""JDLs/simple.jdl"");; // getting status object. TGridJobStatus *status = job->GetJobStatus();; // getting status of the job. TGridJobStatus::EGridJobStatus st( status->GetStatus() );; // when the st is; TGridJobStatus::kDONE you can; retrieve job's output. job->GetOutputSandbox(""/tmp"");. File Catalog operations. // loading RGLite plug-in. TGrid::Connect(""glite"");; // changing the current directory to; ""/grid/dech"". gGrid->Cd(""/grid/dech"");; // using Mkdir to create a new; directory. Bool_t b = gGrid->Mkdir(""root_test2"");; // listing the current directory. TGridResult* result = gGrid->Ls();; // full file information. result->Print(""all"");; // removing the directory . b = gGrid->Rmdir(""root_test2"");. Documentation: ; http://www-linux.gsi.de/%7Emanafov/D-Grid/docz/RGLite/html/. and; http://www-linux.gsi.de/~manafov/D-Grid/docz/; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v520/index.html:4048,simpl,simple,4048,net/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v520/index.html,1,['simpl'],['simple']
Usability,"of the *axis* line is shown; in dark color, the positive in bright. The *axis* name and minimum /; maximum values are labeled in the same color. There are three options; for *axes* drawing - selected by radio buttons:. - None - not drawn (default). - Edge - draw axes on the (minimum) edge of the scene extents box. - Origin - drawn axes through the origin. For *edge axes*, the zero value for each axis is marked on the axis line; with a colored sphere. For *origin axes,* a single white sphere is shown; at the origin. *Edge axes* are depth clipped - i.e. are obscured by 3D objects in front; of them. *Origin axes* (which generally pass through the middle of the; 3D scene) are not depth clipped - so always visible. A single orange sphere of fixed view port (window) size can be shown at; any arbitrary position. Enable / disable the drawing with ‘*Show'*; checkbox. Enter X/Y/Z position in the edit boxes to set position.; Initial position is at the center of the scene. Set the guides using `TGLViewer::SetGuideState` e.g. to enable edge; axes, and enable a reference marker at world position 50, 60, 100:. ``` {.cpp}; Double_t refPos[3] = {50.0,60.0,100.0};; v->SetGuideState(TGLUtil::kAxesEdge, kTRUE, refPos);; ```. #### Selecting Scene Shapes. You can select a single shape from your scene by pressing ‘Shift' key,; pointing and left clicking anywhere on the shape in the viewer.; Selection is currently shown by drawing the shape-bounding box (not; depth clipped) in white (polygon or wire frame render styles) or red; (outline render style). Manipulators supported by the shape are drawn in; red, green and blue while the non-supported ones are drawn in grey. To; deselect a shape, either select another, or shift/click anywhere on the; background (empty space) in the viewer. You cannot select Manipulators; or Guides (Axes / Reference Marker). #### Editing Shapes. When a shape is selected, the viewer's control pane shows the user; interface that allows you to review and adjust the col",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:118207,guid,guides,118207,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['guid'],['guides']
Usability,"of the backedges is taken before the loop. It is one less than; the trip count for executions that enter the header. .. _loopinfo:. LoopInfo; ========. LoopInfo is the core analysis for obtaining information about loops.; There are few key implications of the definitions given above which; are important for working successfully with this interface. * LoopInfo does not contain information about non-loop cycles. As a; result, it is not suitable for any algorithm which requires complete; cycle detection for correctness. * LoopInfo provides an interface for enumerating all top level loops; (e.g. those not contained in any other loop). From there, you may; walk the tree of sub-loops rooted in that top level loop. * Loops which become statically unreachable during optimization *must*; be removed from LoopInfo. If this can not be done for some reason,; then the optimization is *required* to preserve the static; reachability of the loop. .. _loop-terminology-loop-simplify:. Loop Simplify Form; ==================. The Loop Simplify Form is a canonical form that makes; several analyses and transformations simpler and more effective.; It is ensured by the LoopSimplify; (:ref:`-loop-simplify <passes-loop-simplify>`) pass and is automatically; added by the pass managers when scheduling a LoopPass.; This pass is implemented in; `LoopSimplify.h <https://llvm.org/doxygen/LoopSimplify_8h_source.html>`_.; When it is successful, the loop has:. * A preheader.; * A single backedge (which implies that there is a single latch).; * Dedicated exits. That is, no exit block for the loop; has a predecessor that is outside the loop. This implies; that all exit blocks are dominated by the loop header. .. _loop-terminology-lcssa:. Loop Closed SSA (LCSSA); =======================. A program is in Loop Closed SSA Form if it is in SSA form; and all values that are defined in a loop are used only inside; this loop. Programs written in LLVM IR are always in SSA form but not necessarily; in LCSSA. To a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:9944,Simpl,Simplify,9944,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['Simpl'],['Simplify']
Usability,"of the compiler exist. Passes; perform the transformations and optimizations that make up the compiler, they; build the analysis results that are used by these transformations, and they; are, above all, a structuring technique for compiler code. Unlike passes under the legacy pass manager where the pass interface is; defined via inheritance, passes under the new pass manager rely on; concept-based polymorphism, meaning there is no explicit interface (see; comments in ``PassManager.h`` for more details). All LLVM passes inherit from; the CRTP mix-in ``PassInfoMixin<PassT>``. The pass should have a ``run()``; method which returns a ``PreservedAnalyses`` and takes in some unit of IR; along with an analysis manager. For example, a function pass would have a; ``PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);`` method. We start by showing you how to construct a pass, from setting up the build,; creating the pass, to executing and testing it. Looking at existing passes is; always a great way to learn details. .. warning::; This document deals with the new pass manager. LLVM uses the legacy pass; manager for the codegen pipeline. For more details, see; :doc:`WritingAnLLVMPass` and :doc:`NewPassManager`. Quick Start --- Writing hello world; ===================================. Here we describe how to write the ""hello world"" of passes. The ""HelloWorld""; pass is designed to simply print out the name of non-external functions that; exist in the program being compiled. It does not modify the program at all,; it just inspects it. The code below already exists; feel free to create a pass with a different; name alongside the HelloWorld source files. .. _writing-an-llvm-npm-pass-build:. Setting up the build; --------------------. First, configure and build LLVM as described in :doc:`GettingStarted`. Next, we will reuse an existing directory (creating a new directory involves; messing around with more CMake files than we want). For this example, we'll use; ``llvm/lib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:1322,learn,learn,1322,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,1,['learn'],['learn']
Usability,"of the minimization is transformed into the user; representable format by M . For more explanations see [api:state]. ## Input to M ##. The following input combinations to M are possible:. - $\mbox{FCN}$ + parameters + uncertainties. - $\mbox{FCN}$ with gradient + parameters + uncertainties. - $\mbox{FCN}$ + parameters + covariance. - $\mbox{FCN}$ with gradient + parameters + covariance. For each of these combinations the user can chose between a minimal; required interface (using std::vector containers) for the parameters and; uncertainties or a more functional one provided by M . If the user wants; to interact with the parameters before minimization (fixing,; adding/removing limits), the minimal required interface cannot be used. ### What the user must supply ###. The user must supply to M. - a valid implementation of the FCNBase base class. - parameters with their starting values. - expected uncertainties on the parameters. The input parameters can be simply defined via an; std::vector$<$double$>$, which means that all parameters are variables.; If the user wants fix a parameter or put limits on it before; minimization, they have to instantiate a MnUserParameters object and then; add parameters one by one, giving them a name, value, uncertainty. Once; all parameters are added to MnUserParameters, they can fix a parameter or; put limits on another one before handing them over to Minuit for; minimization. ### What the user can supply ###. Optionally the user can supply their own gradient calculator by; implementing the FCNGradientBase interface or supply a full covariance; matrix for input if one is available. The covariance matrix can be; supplied in form of a std::vector$<$double$>$ in packed storage format; (upper triangular), or in a more user-friendly way by using the; interface provided by the MnUserCovariance. ## Running a M minimization ##. Two use cases are addressed for minimization:. - The user just wants the function to be minimized in one go. - The user ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:32560,simpl,simply,32560,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['simpl'],['simply']
Usability,"of your script. The default behavior of `rootcling` is to; not link in (i.e. generate the dictionary for) any of the symbols. In; particular, this means that the following lines are, in the; general case, unnecessary. ``` {.cpp}; #pragma link off all globals;; #pragma link off all classes;; #pragma link off all functions;; ```. This also means that linking the instantiation of a class template:. ``` {.cpp}; #pragma link C++ class mytemplate<int>;; ```. ONLY links this specific class. You need to; request the generation of the iterators explicitly. See the documentation of `rootcling` for details how `pragma` can be; used. NOTE: You should not call ACLiC with a script that has a function; called `main()`. ### Intermediate Steps and Files. ACLiC executes two steps and a third one if needed. These are:. - Calling `rootcling` to create a dictionary using `rootcling`.; - Calling the compiler to build the shared library from the script.; - If there are errors, it calls the compiler to build a dummy; executable to clearly report unresolved symbols. ACLiC makes a shared library with a dictionary containing the; classes and functions declared in the script. It also adds the; classes and functions declared in included files with the same name; as the script file and any of the following extensions: `.h`, `.hh`,; `.hpp`, `.hxx`, `.hPP`, `.hXX`. This means that, by default, you; cannot combine scripts from different files into one library by using; `#include` statements; you will need to compile each script; separately. In a future release, we plan to add the global variables; declared in the script to the dictionary also. If you are curious; about the specific calls, you can raise the ROOT debug level: gDebug=3; and ACLiC will print these steps. If you need to keep the intermediate; files around, for example when debugging the script using gdb, use; gDebug=7. ### Moving between Interpreter and Compiler. The best way to develop portable scripts is to make sure you can; always ru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:20291,clear,clearly,20291,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['clear'],['clearly']
Usability,"ofConfig.h; RooStats/ProposalFunction.h; RooStats/ProposalHelper.h; RooStats/RatioOfProfiledLikelihoodsTestStat.h; RooStats/RooStatsUtils.h; RooStats/SamplingDistPlot.h; RooStats/SamplingDistribution.h; RooStats/SequentialProposal.h; RooStats/SimpleInterval.h; RooStats/SimpleLikelihoodRatioTestStat.h; RooStats/SPlot.h; RooStats/TestStatistic.h; RooStats/TestStatSampler.h; RooStats/ToyMCImportanceSampler.h; RooStats/ToyMCSampler.h; RooStats/ToyMCStudy.h; RooStats/UniformProposal.h; RooStats/UpperLimitMCSModule.h; SOURCES; src/AsymptoticCalculator.cxx; src/BayesianCalculator.cxx; src/BernsteinCorrection.cxx; src/ConfidenceBelt.cxx; src/DetailedOutputAggregator.cxx; src/FeldmanCousins.cxx; src/FrequentistCalculator.cxx; src/Heaviside.cxx; src/HLFactory.cxx; src/HybridCalculator.cxx; src/HybridPlot.cxx; src/HybridResult.cxx; src/HypoTestCalculatorGeneric.cxx; src/HypoTestInverter.cxx; src/HypoTestInverterPlot.cxx; src/HypoTestInverterResult.cxx; src/HypoTestPlot.cxx; src/HypoTestResult.cxx; src/LikelihoodInterval.cxx; src/LikelihoodIntervalPlot.cxx; src/MarkovChain.cxx; src/MCMCCalculator.cxx; src/MCMCInterval.cxx; src/MCMCIntervalPlot.cxx; src/MetropolisHastings.cxx; src/NeymanConstruction.cxx; src/NumberCountingPdfFactory.cxx; src/NumberCountingUtils.cxx; src/PdfProposal.cxx; src/PointSetInterval.cxx; src/ProfileInspector.cxx; src/ProfileLikelihoodCalculator.cxx; src/ProfileLikelihoodTestStat.cxx; src/ProposalHelper.cxx; src/RatioOfProfiledLikelihoodsTestStat.cxx; src/RooStatsUtils.cxx; src/SamplingDistPlot.cxx; src/SamplingDistribution.cxx; src/SequentialProposal.cxx; src/SimpleInterval.cxx; src/SimpleLikelihoodRatioTestStat.cxx; src/SPlot.cxx; src/ToyMCImportanceSampler.cxx; src/ToyMCSampler.cxx; src/ToyMCStudy.cxx; src/UniformProposal.cxx; src/UpperLimitMCSModule.cxx; DICTIONARY_OPTIONS; ""-writeEmptyRootPCM""; DEPENDENCIES; Core; RooFit; RooFitCore; Tree; RIO; Hist; Matrix; MathCore; Minuit; Foam; Graf; Gpad; ${EXTRA_DICT_OPTS}; ). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/CMakeLists.txt:3489,Simpl,SimpleInterval,3489,roofit/roostats/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/CMakeLists.txt,2,['Simpl'],"['SimpleInterval', 'SimpleLikelihoodRatioTestStat']"
Usability,"ogic can resume unwinding. In a yield-once; coroutine, reaching a non-unwind ``llvm.coro.end`` without having first; reached a ``llvm.coro.suspend.retcon`` has undefined behavior. The remainder of this section describes the behavior under switched-resume; lowering. This intrinsic is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePart, label %eh.resume, label %cleanup.cont. cleanup.cont:; ; rest of the cleanup. eh.resume:; %exn = load ptr, ptr %exn.slot, align 8; %sel = load i32, ptr %ehselector.slot, align 4; %lpad.val = insertvalue { ptr, i32 } undef, ptr %exn, 0; %lpad.val29 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1; resume { ptr, i32 } %lpad.val29. The `CoroSpit` pass replaces `coro.end` with ``True`` in the resume functions,; thus leading to immediate unwind to the caller, whereas in start function it; is replaced with ``False``, thus allowing to proceed to the rest of the cleanup; code that is only needed during initial invocation of the coroutine. For Windows Exception handling model, a frontend should attach a funclet bundle; referring to an enclosing cleanuppad as follows:. .. code-block:: llvm. ehcleanup:; %tok = cleanuppad within none []; %unused = call i1 @llvm.coro.end(ptr null, i1 true, token none) [ ""funclet""(token %tok) ]; cleanupret from %tok unwind label %RestOfTheCleanup. The `CoroSplit` pass, if the funclet bun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:44887,resume,resume,44887,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ogonal:. ``` {.cpp}; const TMatrixD haar = THaarMatrixD(order);; TVectorD colj(1<<order);; TVectorD coll(1<<order);; for (Int_t j = haar.GetColLwb(); j <= haar.GetColUpb(); j++) {; colj = TMatrixDColumn_const(haar,j);; Assert(TMath::Abs(colj*colj-1.0) <= 1.0e-15);. for (Int_t l = j+1; l <= haar.GetColUpb(); l++) {; coll = TMatrixDColumn_const(haar,l);; Assert(TMath::Abs(colj*coll) <= 1.0e-15);; }; }; ```. Multiplying part of a matrix with another part of that matrix (they can overlap). ``` {.cpp}; TMatrixDSub(m,1,3,1,3) *= m.GetSub(5,7,5,7);; ```. ## Matrix Decompositions. The linear algebra package offers several classes to assist in matrix; decompositions. Each of the decomposition methods performs a set of; matrix transformations to facilitate solving a system of linear; equations, the formation of inverses as well as the estimation of; determinants and condition numbers. More specifically the classes; **`TDecompLU`**, **`TDecompBK`**, **`TDecompChol`**, **`TDecompQRH`** and; **`TDecompSVD`** give a simple and consistent interface to the LU,; Bunch-Kaufman, Cholesky, QR and SVD decompositions. All of these classes; are derived from the base class **`TDecompBase`** of which the important; methods are listed in next table:. +-----------------------------------------------------+--------------------------------------+; | Method | Action |; +-----------------------------------------------------+--------------------------------------+; | `Bool_t Decompose()` | perform the matrix decomposition |; +-----------------------------------------------------+--------------------------------------+; | `Double_t Condition()` | calculate ||*A*||1 ||*A*-1||1, |; | | see ""Condition number"" |; +-----------------------------------------------------+--------------------------------------+; | `void Det(Double_t &d1,Double_t &d2)` | the determinant is `d1` $2^{d_{2}}$. |; | | Expressing the determinant this |; | | way makes under/over-flow very |; | | unlikely |; +----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:33806,simpl,simple,33806,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['simpl'],['simple']
Usability,"ointer is null.; for (unsigned e = R->Map->NumRoots; i != e; ++i); Visitor(&R->Roots[i], NULL);; }; }. The 'Erlang' and 'Ocaml' GCs; -----------------------------. LLVM ships with two example collectors which leverage the ``gcroot``; mechanisms. To our knowledge, these are not actually used by any language; runtime, but they do provide a reasonable starting point for someone interested; in writing an ``gcroot`` compatible GC plugin. In particular, these are the; only in tree examples of how to produce a custom binary stack map format using; a ``gcroot`` strategy. As there names imply, the binary format produced is intended to model that; used by the Erlang and OCaml compilers respectively. .. _statepoint_example_gc:. The Statepoint Example GC; -------------------------. .. code-block:: c++. F.setGC(""statepoint-example"");. This GC provides an example of how one might use the infrastructure provided; by ``gc.statepoint``. This example GC is compatible with the; :ref:`PlaceSafepoints` and :ref:`RewriteStatepointsForGC` utility passes; which simplify ``gc.statepoint`` sequence insertion. If you need to build a; custom GC strategy around the ``gc.statepoints`` mechanisms, it is recommended; that you use this one as a starting point. This GC strategy does not support read or write barriers. As a result, these; intrinsics are lowered to normal loads and stores. The stack map format generated by this GC strategy can be found in the; :ref:`stackmap-section` using a format documented :ref:`here; <statepoint-stackmap-format>`. This format is intended to be the standard; format supported by LLVM going forward. The CoreCLR GC; -------------------------. .. code-block:: c++. F.setGC(""coreclr"");. This GC leverages the ``gc.statepoint`` mechanism to support the; `CoreCLR <https://github.com/dotnet/coreclr>`__ runtime. Support for this GC strategy is a work in progress. This strategy will; differ from; :ref:`statepoint-example GC<statepoint_example_gc>` strategy in; certain aspects l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:20312,simpl,simplify,20312,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['simpl'],['simplify']
Usability,"ointers to member; > functions, and have to look up an example when they have to write them. Again, I don't disagree with this at all. But to some extent this; particular problem is inherently difficult. Your syntax for the above; example may be easier for you to read because this is the way you have been; thinking about it. Honestly, I don't find it much easier than the C syntax.; In either case, I would have to look up an example to write pointers to; member functions. But pointers to member functions are nowhere near as common as arrays. And; the old array syntax:; type [ int, int, ...]; is just much more familiar and clear to people than anything new you; introduce, no matter how logical it is. Introducing a new syntax that may; make function pointers easier but makes arrays much more difficult seems; very risky to me. > In my opinion, it is critically important to have clear and concise type; > specifications, because types are going to be all over the programs. I absolutely agree. But the question is, what is more clear and concise?; The syntax programmers are used to out of years of experience or a new; syntax that they have never seen that has a more logical structure. I think; the answer is the former. Sometimes, you have to give up a better idea; because you can't overcome sociological barriers to it. Qwerty keyboards; and Windows are two classic examples of bad technology that are difficult to; root out. P.S. Also, while I agree that most your syntax is more logical, there is; one part that isn't:. Arrays (without and with size):; type ::= '[' type ']' | '[' INT ',' type ']'. The arrays with size lists the dimensions and the type in a single list.; That is just too confusing:; [10, 40, int]; This seems to be a 3-D array where the third dimension is something strange.; It is too confusing to have a list of 3 things, some of which are dimensions; and one is a type. Either of the following would be better:. array [10, 40] of int; or; int [10, 40]. --Vikram. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt:2208,clear,clear,2208,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,1,['clear'],['clear']
Usability,"ollow the function; pointer and trigger the compile callback instead. The compile callback will; compile the function, update the function pointer for the stub, then execute; the function. On all subsequent calls to the function, the function pointer; will point at the already-compiled function, so there is no further overhead; from the compiler. We will look at this process in more detail in the next; chapter of this tutorial, but for now we'll trust the CompileOnDemandLayer to; set all the stubs and callbacks up for us. All we need to do is to add the; CompileOnDemandLayer to the top of our stack and we'll get the benefits of; lazy compilation. We just need a few changes to the source:. .. code-block:: c++. ...; #include ""llvm/ExecutionEngine/SectionMemoryManager.h""; #include ""llvm/ExecutionEngine/Orc/CompileOnDemandLayer.h""; #include ""llvm/ExecutionEngine/Orc/CompileUtils.h""; ... ...; class KaleidoscopeJIT {; private:; std::unique_ptr<TargetMachine> TM;; const DataLayout DL;; RTDyldObjectLinkingLayer ObjectLayer;; IRCompileLayer<decltype(ObjectLayer), SimpleCompiler> CompileLayer;. using OptimizeFunction =; std::function<std::shared_ptr<Module>(std::shared_ptr<Module>)>;. IRTransformLayer<decltype(CompileLayer), OptimizeFunction> OptimizeLayer;. std::unique_ptr<JITCompileCallbackManager> CompileCallbackManager;; CompileOnDemandLayer<decltype(OptimizeLayer)> CODLayer;. public:; using ModuleHandle = decltype(CODLayer)::ModuleHandleT;. First we need to include the CompileOnDemandLayer.h header, then add two new; members: a std::unique_ptr<JITCompileCallbackManager> and a CompileOnDemandLayer,; to our class. The CompileCallbackManager member is used by the CompileOnDemandLayer; to create the compile callback needed for each function. .. code-block:: c++. KaleidoscopeJIT(); : TM(EngineBuilder().selectTarget()), DL(TM->createDataLayout()),; ObjectLayer([]() { return std::make_shared<SectionMemoryManager>(); }),; CompileLayer(ObjectLayer, SimpleCompiler(*TM)),; Optimize",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:4184,Simpl,SimpleCompiler,4184,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,1,['Simpl'],['SimpleCompiler']
Usability,"ollows:. ``` {.json}; ""<C++ class name>"": {; ""type"": ""<json-key>"",; ""proxies"": {; ""<name of proxy>"": ""<json-key of this element>"",; ""<name of proxy>"": ""<json-key of this element>"",; ...; }; }; ```. If you don't want to edit the central `json` files containing the; factory expressions or export keys, you can also put your custom; export keys or factory expressions into a different json file and load; that using `RooFit::JSONIO::loadExportKeys(const std::string; &fname)` and `RooFit::JSONIO::loadFactoryExpressions(const; std::string &fname)`. If either the importer or the exporter cannot be created with factory; expressions and export keys, you can instead write a custom `C++`; class to perform the import and export for you. ### Writing your own importers and exporters: Custom `C++` code. In order to implement your own importer or exporter, you can inherit; from the corresponding base classes `RooFit::JSONIO::Importer`; or `RooFit::JSONIO::Exporter`, respectively. You can find; [simple examples](https://github.com/root-project/root/blob/master/roofit/hs3/src/JSONFactories_RooFitCore.cxx); as well as; [more complicated ones](https://github.com/root-project/root/blob/master/roofit/hs3/src/JSONFactories_HistFactory.cxx); in `ROOT`. Any importer should take the following form:. ``` {.cpp}; class MyClassFactory : public RooFit::JSONIO::Importer {; public:; bool importFunction(RooJSONFactoryWSTool *tool, const JSONNode &p) const override; {; std::string name(RooJSONFactoryWSTool::name(p));. // check if the required keys are available in the JSON; if (!p.has_child(""<class member key #1>"")) {; RooJSONFactoryWSTool::error(""missing key '<class member key #1>' of '"" + name + ""'"");; }; if (!p.has_child(""<class member key #2>"")) {; RooJSONFactoryWSTool::error(""missing key '<class member key #2>' of '"" + name + ""'"");; }. std::string member1(p[""<class member key #1>""].val());; int member2(p[""<class member key #2>""].val_int());. MyClass theobj(name.c_str(), member1, member2);; tool->",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_hs3.md:5019,simpl,simple,5019,roofit/doc/developers/roofit_hs3.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_hs3.md,1,['simpl'],['simple']
Usability,"ols for neural; networks studies. ### The MLP. The multilayer perceptron is a simple feed-forward network with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output neurons or a sigmoid for hidden layers. Such a structure is very useful because of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:71417,learn,learning,71417,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['learn'],['learning']
Usability,"om in/out pad's contents; has ""selection"" mode - with single tap user can select different objects inside pad - axes, histograms, pavestats etc.; 3D objects can be rotated.; has a simple editor to modify pad's parameters : fill color, logarithmic scale, grid, ticks, etc. ""RootBrowser"" app; This application is a simplified version of TBrowser and TCanvas; for iOS. User can open ROOT's file (application uses TWebFile) and; browse file's contents.; RootBrower registers *.root file extension in a system, so for; example, attached root files from a mail client can be opened by; RootBrowser.; Application has several views. In a top level view, user can see; opened files, open new files, close files (long press gesture on; a file icon):. Tap gesture on a file's icon will open ""File contents"" view. This; view shows objects and nested directories. For objects small; previews are generated. Tapping on a directory's icon will open; new view with directory's contents. Simple search is supported; (in the current TDirectoryFile). Tap on a object's preview will open detailed view for this object.; Using pinch gesture or double tap, you can zoom in/zoom out pad's; contents.; If you have several objects in a file or directory, you can; navigate through directory contents by using swipe gesture,; scrolling your objects. It's possible to modify properties of objects the same way you; can do it in TCanvas - RootBrowser has an editor. After you; press ""Edit"" button, you can pick histogram, axis, frame,; pavestats, etc. in a pad and modify its properties in the; editor (selected object is highlihgted in a pad).; At the moment, there are editors for:. TH1 objects; TGraph objects; Objects derived from TAttLine (line attributes); Objects derived from TAttFill (filled area attributes); Pad object (fill properties, log scales, ticks, grid); Markers. Using pan gesture along the selected axis, you can change the; axis range - ""zoom"".; Modified object can be saved locally (in application's direct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v532/index.html:3064,Simpl,Simple,3064,graf2d/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v532/index.html,1,['Simpl'],['Simple']
Usability,"om the public interface. The `RooAbsMinimizerFcn` class and its implementation `RooMinimizerFcn` were removed from the public interface.; These classes are implementation details of the RooMinimizer and should not be used in your code.; In the unlikely case that this causes any problem for you, please open a GitHub issue requesting to extend the RooMinimizer by the needed functionality. ### Vectorize `RooAbsBinning` interface for bin index lookups. The `RooAbsBinning` interface for bin index lookups was changed to enable vectorized implementations.; Instead of having the override `RooAbsBinning::binNumber()`, the binning implementations now have to override the `RooAbsBinning::binNumbers()` function to evaluate the bin indices of multiple values in one function call. ### Disable relative and absolute epsilon in `RooAbsRealLValue::inRange()`. So far, the `RooAbsRealLValue::inRange()` function used the following; undocumented convention to check whether a value `x` is in the range with; limits `a` and `b`: test if `[x - eps * x, x + eps * x]` overlaps with `[a, b]`, where the; parameter `eps` is defined as `max(epsRel * x, epsAbs)`. The values of the relative and absolute epsilons were inconsistent among the overloads:. * [RooAbsRealLValue::inRange(const char* rangeName)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#ab6050a0c3e5583b9d755a38fd7fb82f7): `epsRel = 1e-8, epsAbs = 0`; * [RooAbsRealLValue::inRange(double value, const char* rangeName, double* clippedValPtr)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#afc2a8818f433a9a4ec0c437cbdad4e8a): `epsRel = 0, epsAbs = 1e-6`; * [RooAbsRealLValue::inRange(std::span<const double> values, std::string const& rangeName, std::vector<bool>& out)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#af9217abd0afe34364562ad0c194f5d2c): `epsRel = 0, epsAbs = 1e-6`. With this release, the default absolute and relative epsilon is zero to avoid confusion.; You can change them with `RooNumber::setRangeEps",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:25114,undo,undocumented,25114,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['undo'],['undocumented']
Usability,"om/WebAssembly/design/blob/main/Semantics.md; * https://github.com/WebAssembly/design/blob/main/BinaryEncoding.md. Some notes on ways that the generated code could be improved follow:. //===---------------------------------------------------------------------===//. Br, br_if, and br_table instructions can support having a value on the value; stack across the jump (sometimes). We should (a) model this, and (b) extend; the stackifier to utilize it. //===---------------------------------------------------------------------===//. The min/max instructions aren't exactly a<b?a:b because of NaN and negative zero; behavior. The ARM target has the same kind of min/max instructions and has; implemented optimizations for them; we should do similar optimizations for; WebAssembly. //===---------------------------------------------------------------------===//. AArch64 runs SeparateConstOffsetFromGEPPass, followed by EarlyCSE and LICM.; Would these be useful to run for WebAssembly too? Also, it has an option to; run SimplifyCFG after running the AtomicExpand pass. Would this be useful for; us too?. //===---------------------------------------------------------------------===//. Register stackification uses the VALUE_STACK physical register to impose; ordering dependencies on instructions with stack operands. This is pessimistic;; we should consider alternate ways to model stack dependencies. //===---------------------------------------------------------------------===//. Lots of things could be done in WebAssemblyTargetTransformInfo.cpp. Similarly,; there are numerous optimization-related hooks that can be overridden in; WebAssemblyTargetLowering. //===---------------------------------------------------------------------===//. Instead of the OptimizeReturned pass, which should consider preserving the; ""returned"" attribute through to MachineInstrs and extending the; MemIntrinsicResults pass to do this optimization on calls too. That would also; let the WebAssemblyPeephole pass clea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt:2344,Simpl,SimplifyCFG,2344,interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,1,['Simpl'],['SimplifyCFG']
Usability,"om; operator delete[].; See tests cases in handle_constructors_with_new_array.cpp.; . Constructing an array requires invoking multiple (potentially unknown); amount of constructors with the same construct-expression.; Apart from the technical difficulties of juggling program points around; correctly to avoid accidentally merging paths together, we'll have to; be a judge on when to exit the loop and how to widen it.; Given that the constructor is going to be a default constructor,; a nice 95% solution might be to execute exactly one constructor and; then default-bind the resulting LazyCompoundVal to the whole array;; it'll work whenever the default constructor doesn't touch global state; but only initializes the object to various default values.; But if, say, we're making an array of strings,; depending on the implementation you might have to allocate a new buffer; for each string, and in this case default-binding won't cut it.; We might want to come up with an auxiliary analysis in order to perform; widening of these simple loops more precisely.; . Handle constructors that can be elided due to Named Return Value Optimization (NRVO); Local variables which are returned by values on all return statements; may be stored directly at the address for the return value,; eliding the copy or move constructor call.; Such variables can be identified using the AST call VarDecl::isNRVOVariable.; . Handle constructors of lambda captures; Variables which are captured by value into a lambda require a call to; a copy constructor.; This call is not currently modeled.; . Handle constructors for default arguments; Default arguments in C++ are recomputed at every call,; and are therefore local, and not static, variables.; See tests cases in handle_constructors_for_default_arguments.cpp.; . Default arguments are annoying because the initializer expression is; evaluated at the call site but doesn't syntactically belong to the; caller's AST; instead it belongs to the ParmVarDecl for the defa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:3878,simpl,simple,3878,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['simpl'],['simple']
Usability,"omatic storage duration do not have precise; lifetime semantics. Such objects are simply strong references which hold; values of retainable object pointer type, and these values are still fully; subject to the optimizations on values under local control. .. admonition:: Rationale. Applying these precise-lifetime semantics strictly would be prohibitive.; Many useful optimizations that might theoretically decrease the lifetime of; an object would be rendered impossible. Essentially, it promises too much. A local variable of retainable object owner type and automatic storage duration; may be annotated with the ``objc_precise_lifetime`` attribute to indicate that; it should be considered to be an object with precise lifetime semantics. .. admonition:: Rationale. Nonetheless, it is sometimes useful to be able to force an object to be; released at a precise time, even if that object does not appear to be used.; This is likely to be uncommon enough that the syntactic weight of explicitly; requesting these semantics will not be burdensome, and may even make the code; clearer. .. _arc.misc:. Miscellaneous; =============. .. _arc.misc.special_methods:. Special methods; ---------------. .. _arc.misc.special_methods.retain:. Memory management methods; ^^^^^^^^^^^^^^^^^^^^^^^^^. A program is ill-formed if it contains a method definition, message send, or; ``@selector`` expression for any of the following selectors:. * ``autorelease``; * ``release``; * ``retain``; * ``retainCount``. .. admonition:: Rationale. ``retainCount`` is banned because ARC robs it of consistent semantics. The; others were banned after weighing three options for how to deal with message; sends:. **Honoring** them would work out very poorly if a programmer naively or; accidentally tried to incorporate code written for manual retain/release code; into an ARC program. At best, such code would do twice as much work as; necessary; quite frequently, however, ARC and the explicit code would both; try to balance the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:84904,clear,clearer,84904,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['clear'],['clearer']
Usability,"ome tools rely on the package structure. The ``STDCXX`` envar can be used to control the C++ standard version; use; ``MAKE`` to change the ``make`` command; and ``MAKE_NPROCS`` to control the; maximum number of parallel jobs.; Compilation of the backend, which contains a customized version of; Clang/LLVM, can take a long time, so by default the setup script will use all; cores (x2 if hyperthreading is enabled). On MS Windows, some temporary path names may be too long, causing the build to; fail.; To resolve this issue, point the ``TMP`` and ``TEMP`` envars to an existing; directory with a short name before the build:; For example::. > set TMP=C:\TMP; > set TEMP=C:\TMP. The first package to build is ``cppyy-cling``.; It may take a long time, especially on a laptop (Mac ARM being a notable; exception), since Cling comes with a builtin version of LLVM/Clang.; Consider therefore for a moment your reasons for building from source: there; being no pre-built wheel for the platform that you're interested in or simply; needing the latest version from the repository; or perhaps you are planning; to develop/modify the sources. If the former, clone the repository, check out a specific tagged release as; needed, then run the following steps to add Cling and build a wheel.; Once built, install the wheel as appropriate::. $ git clone https://github.com/wlav/cppyy-backend.git; $ cd cppyy-backend/cling; $ python setup.py egg_info; $ python create_src_directory.py; $ python setup.py bdist_wheel; $ python -m pip install dist/cppyy_cling-* --upgrade. .. note::; ``cppyy-cling`` wheels do not depend on the Python interpreter and can; thus be re-used for any version of Python or PyPy. The ``egg_info`` setup command is needed for ``create_src_directory.py`` to; find the right version.; That script in turn downloads the proper release from `upstream`_, trims and; patches it,; and installs the result in the ""src"" directory.; When done, the structure of ``cppyy-cling`` looks again like a PyPA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst:2564,simpl,simply,2564,bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,1,['simpl'],['simply']
Usability,"omeone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:14262,simpl,simplify,14262,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['simpl'],['simplify']
Usability,"ommits that violate these quality standards (e.g. are very broken) may be; reverted. This is necessary when the change blocks other developers from making; progress. The developer is welcome to re-commit the change after the problem has; been fixed. .. _commit messages:. Commit messages; ---------------. Although we don't enforce the format of commit messages, we prefer that; you follow these guidelines to help review, search in logs, email formatting; and so on. These guidelines are very similar to rules used by other open source; projects. Most importantly, the contents of the message should be carefully written to; convey the rationale of the change (without delving too much in detail). It; also should avoid being vague or overly specific. For example, ""bits were not; set right"" will leave the reviewer wondering about which bits, and why they; weren't right, while ""Correctly set overflow bits in TargetInfo"" conveys almost; all there is to the change. Below are some guidelines about the format of the message itself:. * Separate the commit message into title and body separated by a blank line. * If you're not the original author, ensure the 'Author' property of the commit is; set to the original author and the 'Committer' property is set to yourself.; You can use a command similar to; ``git commit --amend --author=""John Doe <jdoe@llvm.org>""`` to correct the; author property if it is incorrect. See `Attribution of Changes`_ for more; information including the method we used for attribution before the project; migrated to git. In the rare situation where there are multiple authors, please use the `git; tag 'Co-authored-by:' to list the additional authors; <https://github.blog/2018-01-29-commit-together-with-co-authors/>`_. * The title should be concise. Because all commits are emailed to the list with; the first line as the subject, long titles are frowned upon. Short titles; also look better in `git log`. * When the changes are restricted to a specific part of the co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:15519,guid,guidelines,15519,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guidelines']
Usability,"ompare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no idea how to support them! It works; as follows:. - To create a **`TIter`** object its constructor must be passed an; object that inherits from **`TCollection`**. The **`TIter`**; constructor calls the `MakeIterator()` method of this collection to; get the appropriate iterator object that inherits from; **`TIterator`**. - The `Next()` and `Reset()` methods of **`TIter`** simply call the; `Next()` and `Reset()` methods of the iterator object. Therefore, **`TIter`** simply acts as a wrapper for an object of a; concrete class inheriting from **`TIterator`**. To see this working in practice, consider the **`TObjArray`**; collection. Its associated iterator is **`TObjArrayIter`**. Suppose; `myarray` is a pointer to a **`TObjArray`** that contains `MyClass`; objects, i.e. ``` {.cpp}; TObjArray *myarray;; ```. To create a **`TIter`** object called `myiter`:. ``` {.cpp}; TIter myiter(myarray);; ```. ![](pictures/020001A4.jpg). As shown in the diagram, this results in several methods being called:. - The **`TIter`** constructor is passed a **`TObjArray`**. - **`TIter`** asks embedded **`TCollection`** to make an iterator. - **`TCollection`** asks **`TObjArray`** to make an iterator. - **`TObjArray`** returns a **`TObjArrayIter`**. Now define a pointer for `MyClass` objects and set it to each member of; the **`TObjArray`**:. ``` {.cpp}; MyClass *myobject;; while ((myobje",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:11115,simpl,simply,11115,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['simpl'],['simply']
Usability,"ompared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3813,learn,learning,3813,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['learn'],['learning']
Usability,"on and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix element:. ~~~ {.cpp}; void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }; ~~~. Validation code `$ROOTSYS/test/vmatrix.cxx` and `vvector.cxx` contain; a few more examples of that kind. #### 6. Lazy matrices:. instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:. ~~~ {.cpp}; TMatrixD haar = THaarMatrixD(5);; ~~~. THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. ### Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md:18616,simpl,simple,18616,math/matrix/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md,1,['simpl'],['simple']
Usability,"on backend; * Lanai backend; * MIPS backend; * NVPTX backend; * PowerPC backend; * RISC-V backend; * Sparc backend; * SystemZ backend; * WebAssembly backend; * X86 backend; * XCore backend; * libLTO; * Debug Information; * Remainder of llvm; * compiler-rt; * libunwind; * openmp; * parallel-libs; * polly; * lldb. #. Remove the old variable name rule from the policy page. #. Repeat many of the steps in the sequence, using a script to expand acronyms. References; ==========. .. [LLDB] LLDB Coding Conventions https://llvm.org/svn/llvm-project/lldb/branches/release_39/www/lldb-coding-conventions.html; .. [Google] Google C++ Style Guide https://google.github.io/styleguide/cppguide.html#Variable_Names; .. [WebKit] WebKit Code Style Guidelines https://webkit.org/code-style-guidelines/#names; .. [Qt] Qt Coding Style https://wiki.qt.io/Qt_Coding_Style#Declaring_variables; .. [Rust] Rust naming conventions https://doc.rust-lang.org/1.0.0/style/style/naming/README.html; .. [Swift] Swift API Design Guidelines https://swift.org/documentation/api-design-guidelines/#general-conventions; .. [Python] Style Guide for Python Code https://www.python.org/dev/peps/pep-0008/#function-and-variable-names; .. [Mozilla] Mozilla Coding style: Prefixes https://firefox-source-docs.mozilla.org/tools/lint/coding-style/coding_style_cpp.html#prefixes; .. [SVE] LLVM with support for SVE https://github.com/ARM-software/LLVM-SVE; .. [AminiInconsistent] Mehdi Amini, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130329.html; .. [ArsenaultAgree] Matt Arsenault, http://lists.llvm.org/pipermail/llvm-dev/2019-February/129934.html; .. [BeylsDistinguish] Kristof Beyls, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130292.html; .. [BradburyConcern] Alex Bradbury, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130266.html; .. [BradburyTransition] Alex Bradbury, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130388.html; .. [CarruthAcronym] Chandler Carruth, http://lists.llvm.org/p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:13827,Guid,Guidelines,13827,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['Guid'],['Guidelines']
Usability,"on of `x` may be very subtle:. ```c++; void F(std::optional<int> &x);. void Example(std::optional<int> &x) {; if (x.has_value()) {; // Flow condition: x.has_value() == true.; unknown_function(x); // may change x.; // Flow condition: true.; use(x.value());; }; }; ```. ## Example: finding dead code behind A/B experiment flags. Finding dead code is a classic application of data flow analysis. Unused flags for A/B experiment hide dead code. However, this flavor of dead; code is invisible to the compiler because the flag can be turned on at any; moment. We could make a tool that deletes experiment flags. The user tells us which flag; they want to delete, and we assume that the it's value is a given constant. For example, the user could use the tool to remove `example_flag` from this; code:. ```c++; DEFINE_FLAG(std::string, example_flag, """", ""A sample flag."");. void Example() {; bool x = GetFlag(FLAGS_example_flag).empty();; f();; if (x) {; g();; } else {; h();; }; }; ```. The tool would simplify the code to:. ```c++; void Example() {; f();; g();; }; ```. We can solve this problem with a classic constant propagation lattice combined; with symbolic evaluation. ## Example: finding inefficient usages of associative containers. Real-world code often accidentally performs repeated lookups in associative; containers:. ```c++; map<int, Employee> xs;; xs[42]->name = ""..."";; xs[42]->title = ""..."";; ```. To find the above inefficiency we can use the available expressions analysis to; understand that `m[42]` is evaluated twice. ```c++; map<int, Employee> xs;; Employee &e = xs[42];; e->name = ""..."";; e->title = ""..."";; ```. We can also track the `m.contains()` check in the flow condition to find; redundant checks, like in the example below. ```c++; std::map<int, Employee> xs;; if (!xs.contains(42)) {; xs.insert({42, someEmployee});; }; ```. ## Example: refactoring types that implicitly convert to each other. Refactoring one strong type to another is difficult, but the compiler can he",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:28582,simpl,simplify,28582,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['simpl'],['simplify']
Usability,"on"");. // Create a hierarchy by adding sub tasks; run->Add(geomInit);; run->Add(matInit);; run->Add(event);; event->Add(tracker);; event->Add(global);; tracker->Add(tpc);; tracker->Add(its);; tracker->Add(muon);; tracker->Add(phos);; tracker->Add(rich);; tracker->Add(trd);. // Add the top level task; gROOT->GetListOfTasks()->Add(run);. // Add the task to the browser; gROOT->GetListOfBrowsables()->Add(run);; new TBrowser;; }; ```. ![Tasks in the ROOT browser](pictures/030000E5.png). Note that the first line loads the class definitions in `MyTasks.cxx`; with ACLiC. ACLiC builds a shared library and adds the classes to the; Cling dictionary. See ""Adding a Class with ACLiC"". To execute a **`TTask`**, you call the `ExecuteTask` method.; `ExecuteTask` will recursively call:. - the `TTask::Exec `method of the derived class;. - the `TTask::ExecuteTasks` to execute for each task the list of its; subtasks;. If the top level task is added to the list of ROOT browsable objects,; the tree of tasks can be seen in the ROOT browser. To add it to the; browser, get the list of browsable objects first and add it to the; collection. ``` {.cpp}; gROOT->GetListOfBrowsables()->Add(run);; ```. The first parameter of the `Add` method is a pointer to a **`TTask`**,; the second parameter is the string to show in the browser. If the string; is left out, the name of the task is used. After executing, the script above the browser will look like in this; figure. ## Execute and Debug Tasks. The browser can be used to start a task, set break points at the; beginning of a task or when the task has completed. At a breakpoint,; data structures generated by the execution up this point may be; inspected asynchronously and then the execution can be resumed by; selecting the ""`Continue`"" function of a task. A task may be active or inactive (controlled by `TTask::SetActive`).; When a task is inactive, its sub tasks are not executed. A task tree may; be made persistent, saving the status of all the tasks.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:10773,resume,resumed,10773,documentation/users-guide/FoldersTasks.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md,1,['resume'],['resumed']
Usability,"on** for an option, you; must specify **cl::location** first, so that when the command-line parser; sees **cl::init**, it knows where to put the initial value. (You will get an; error at runtime if you don't put them in the right order.). .. _cl::location:. * The **cl::location** attribute where to store the value for a parsed command; line option if using external storage. See the section on `Internal vs; External Storage`_ for more information. .. _cl::aliasopt:. * The **cl::aliasopt** attribute specifies which option a `cl::alias`_ option is; an alias for. .. _cl::values:. * The **cl::values** attribute specifies the string-to-value mapping to be used; by the generic parser. It takes a list of (option, value, description); triplets that specify the option name, the value mapped to, and the; description shown in the ``-help`` for the tool. Because the generic parser; is used most frequently with enum values, two macros are often useful:. #. The **clEnumVal** macro is used as a nice simple way to specify a triplet; for an enum. This macro automatically makes the option name be the same as; the enum name. The first option to the macro is the enum, the second is; the description for the command line option. #. The **clEnumValN** macro is used to specify macro options where the option; name doesn't equal the enum name. For this macro, the first argument is; the enum value, the second is the flag name, and the second is the; description. You will get a compile time error if you try to use cl::values with a parser; that does not support it. .. _cl::multi_val:. * The **cl::multi_val** attribute specifies that this option takes has multiple; values (example: ``-sectalign segname sectname sectvalue``). This attribute; takes one unsigned argument - the number of values for the option. This; attribute is valid only on ``cl::list`` options (and will fail with compile; error if you try to use it with other option types). It is allowed to use all; of the usual modifiers on mult",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:37525,simpl,simple,37525,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"on, one could enable monitoring flag in the browser - then objects view will be regularly updated. ## Accessing file system. THttpServer provides partial access to the files from file system.; First of all, JSROOT scripts and files can be accessed via ""jsrootsys/"" path like ""http://localhost:8080/jsrootsys/modules/core.mjs"".; Files from ROOT install directory can be get via ""rootsys/"" path like ""http://localhost:8080/rootsys/icons/about.xpm"".; Also files from current directory where ROOT is running can be accessed via ""currentdir/"" path like ""http://localhost:8080/currentdir/file.txt"". If necessary, one can add custom path as well, using [THttpServer::AddLocation](https://root.cern/doc/master/classTHttpServer.html#a5322c3bbfddb8eb6849297d83ccaf87f) method:. ```cpp; serv->AddLocation(""mydir/"", ""/home/user/specials"");; ```. Then files from that directory could be addressed via URL like ""http://localhost:8080/mydir/myfile.root"". ## Command interface. THttpServer class provide simple interface to invoke command from web browser.; One just register command like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; ```. Element with name `DoSomething` will appear in the web browser and can be clicked.; It will result in `gROOT->ProcessLineSync(""SomeFunction()"")` call. One could configure argument(s) for the command.; For that one should use `%arg1`, `%arg2` and so on identifiers. Like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; ```. User will be requested to enter arguments values, when command element clicked in the browser.; Example of the command which executes arbitrary string in application via ProcessLine looks like:. ```cpp; serv->RegisterCommand(""/Process"", ""%arg1%"");; ```. When registering command, one could specify icon name which will be displayed with the command. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; ```. In example usage of images from `$ROOTSYS/icon",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:4934,simpl,simple,4934,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['simpl'],['simple']
Usability,"on, we should get the numbers sequence and then create the hash number.; So, once again, *total-ordering* could be considered as a milestone for even; faster (in theory) random-access approach. MergeFunctions, main fields and runOnModule; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; There are two main important fields in the class:. ``FnTree`` – the set of all unique functions. It keeps items that couldn't be; merged with each other. It is defined as:. ``std::set<FunctionNode> FnTree;``. Here ``FunctionNode`` is a wrapper for ``llvm::Function`` class, with; implemented “<” operator among the functions set (below we explain how it works; exactly; this is a key point in fast functions comparison). ``Deferred`` – merging process can affect bodies of functions that are in; ``FnTree`` already. Obviously, such functions should be rechecked again. In this; case, we remove them from ``FnTree``, and mark them to be rescanned, namely; put them into ``Deferred`` list. runOnModule; """"""""""""""""""""""; The algorithm is pretty simple:. 1. Put all module's functions into the *worklist*. 2. Scan *worklist*'s functions twice: first enumerate only strong functions and; then only weak ones:. 2.1. Loop body: take a function from *worklist* (call it *FCur*) and try to; insert it into *FnTree*: check whether *FCur* is equal to one of functions; in *FnTree*. If there *is* an equal function in *FnTree*; (call it *FExists*): merge function *FCur* with *FExists*. Otherwise add; the function from the *worklist* to *FnTree*. 3. Once the *worklist* scanning and merging operations are complete, check the; *Deferred* list. If it is not empty: refill the *worklist* contents with; *Deferred* list and redo step 2, if the *Deferred* list is empty, then exit; from method. Comparison and logarithmical search; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Let's recall our task: for every function *F* from module *M*, we have to find; equal functions *F`* in the shortest time possible , and merge them into a; single func",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:8400,simpl,simple,8400,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['simpl'],['simple']
Usability,"on. Even more includes will be ""hidden"" when ROOT configured with `-Ddev=ON` build option.; In that case ROOT uses `#ifdef R__LESS_INCLUDES` to replace unused includes by class forward declarations.; Such `dev` builds can be used to verify that ROOT-based code really includes all necessary ROOT headers. ## RDataFrame. - Starting from this version, when `RSnapshotOptions.fMode` is `""UPDATE""` (i.e. the output file is opened in ""UPDATE""; mode), Snapshot will refuse to write out a TTree if one with the same name is already present in the output file.; Users can set the new flag `RSnapshotOption::fOverwriteIfExists` to `true` to force the deletion of the TTree that is; already present and the writing of a new TTree with the same name. See; [ROOT-10573](https://sft.its.cern.ch/jira/browse/ROOT-10573) for more details.; - RDataFrame changed its error handling strategy in case of unreadable input files. Instead of simply logging an error; and skipping the file, it now throws an exception if any of the input files is unreadable (this could also happen in; the middle of an event loop). See [ROOT-10549](https://sft.its.cern.ch/jira/browse/ROOT-10549) for more details.; - New analysis examples based on the recent ATLAS Open Data release ([`Higgs to two photons`](https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html), [`W boson analysis`](https://root.cern/doc/master/df105__WBosonAnalysis_8py.html), [`Higgs to four leptons`](https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html)); - An exception is now thrown in case the size of ROOT's thread-pool changes between RDataFrame construction time and the time the event loop begins.; - Just-in-time compilation of large portions of the computation graph has been optimized, and it is now much faster. Please report any regressions you might encounter on [our issue tracker](https://sft.its.cern.ch/jira/projects/ROOT).; - `MakeRootDataFrame` is now a safe way to construct RDFs. It used to return RDFs with more limited fu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:9796,simpl,simply,9796,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['simpl'],['simply']
Usability,"on. However, some; clients of the ``ASTImporter`` may require a different, perhaps less; conservative and more liberal error handling strategy. E.g. static analysis clients may benefit if the node is created even if there; is a name conflict. During the CTU analysis of certain projects, we recognized; that there are global declarations which collide with declarations from other; translation units, but they are not referenced outside from their translation; unit. These declarations should be in an unnamed namespace ideally. If we treat; these collisions liberally then CTU analysis can find more results. Note, the; feature be able to choose between name conflict handling strategies is still an; ongoing work. .. _CFG:. The ``CFG`` class; -----------------. The ``CFG`` class is designed to represent a source-level control-flow graph; for a single statement (``Stmt*``). Typically instances of ``CFG`` are; constructed for function bodies (usually an instance of ``CompoundStmt``), but; can also be instantiated to represent the control-flow of any class that; subclasses ``Stmt``, which includes simple expressions. Control-flow graphs; are especially useful for performing `flow- or path-sensitive; <https://en.wikipedia.org/wiki/Data_flow_analysis#Sensitivities>`_ program; analyses on a given function. Basic Blocks; ^^^^^^^^^^^^. Concretely, an instance of ``CFG`` is a collection of basic blocks. Each basic; block is an instance of ``CFGBlock``, which simply contains an ordered sequence; of ``Stmt*`` (each referring to statements in the AST). The ordering of; statements within a block indicates unconditional flow of control from one; statement to the next. :ref:`Conditional control-flow; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:112215,simpl,simple,112215,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"on. In this use case, cross compilation allows expressions compiled; in the debugger process to be executed on the debug target process, which may; be on a different device/architecture. 3. In high-performance JITs (e.g. JVMs, Julia) that want to make use of LLVM's; optimizations within an existing JIT infrastructure. 4. In interpreters and REPLs, e.g. Cling (C++) and the Swift interpreter. By adopting a modular, library-based design we aim to make ORC useful in as many; of these contexts as possible. Features; ========. ORC provides the following features:. **JIT-linking**; ORC provides APIs to link relocatable object files (COFF, ELF, MachO) [1]_; into a target process at runtime. The target process may be the same process; that contains the JIT session object and jit-linker, or may be another process; (even one running on a different machine or architecture) that communicates; with the JIT via RPC. **LLVM IR compilation**; ORC provides off the shelf components (IRCompileLayer, SimpleCompiler,; ConcurrentIRCompiler) that make it easy to add LLVM IR to a JIT'd process. **Eager and lazy compilation**; By default, ORC will compile symbols as soon as they are looked up in the JIT; session object (``ExecutionSession``). Compiling eagerly by default makes it; easy to use ORC as an in-memory compiler for an existing JIT (similar to how; MCJIT is commonly used). However ORC also provides built-in support for lazy; compilation via lazy-reexports (see :ref:`Laziness`). **Support for Custom Compilers and Program Representations**; Clients can supply custom compilers for each symbol that they define in their; JIT session. ORC will run the user-supplied compiler when the a definition of; a symbol is needed. ORC is actually fully language agnostic: LLVM IR is not; treated specially, and is supported via the same wrapper mechanism (the; ``MaterializationUnit`` class) that is used for custom compilers. **Concurrent JIT'd code** and **Concurrent Compilation**; JIT'd code may be ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:1796,Simpl,SimpleCompiler,1796,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['Simpl'],['SimpleCompiler']
Usability,"on:: -code-model=model. Choose the code model from:. .. code-block:: text. default: Target default code model; tiny: Tiny code model; small: Small code model; kernel: Kernel code model; medium: Medium code model; large: Large code model. .. option:: -disable-post-RA-scheduler. Disable scheduling after register allocation. .. option:: -disable-spill-fusing. Disable fusing of spill code into instructions. .. option:: -jit-enable-eh. Exception handling should be enabled in the just-in-time compiler. .. option:: -join-liveintervals. Coalesce copies (default=true). .. option:: -nozero-initialized-in-bss. Don't place zero-initialized symbols into the BSS section. .. option:: -pre-RA-sched=scheduler. Instruction schedulers available (before register allocation):. .. code-block:: text. =default: Best scheduler for the target; =none: No scheduling: breadth first sequencing; =simple: Simple two pass scheduling: minimize critical path and maximize processor utilization; =simple-noitin: Simple two pass scheduling: Same as simple except using generic latency; =list-burr: Bottom-up register reduction list scheduling; =list-tdrr: Top-down register reduction list scheduling; =list-td: Top-down list scheduler. .. option:: -regalloc=allocator. Register allocator to use (default=linearscan). .. code-block:: text. =bigblock: Big-block register allocator; =linearscan: linear scan register allocator; =local: local register allocator; =simple: simple register allocator. .. option:: -relocation-model=model. Choose relocation model from:. .. code-block:: text. =default: Target default relocation model; =static: Non-relocatable code; =pic: Fully relocatable, position independent code; =dynamic-no-pic: Relocatable external references, non-relocatable code. .. option:: -spiller. Spiller to use (default=local). .. code-block:: text. =simple: simple spiller; =local: local spiller. .. option:: -x86-asm-syntax=syntax. Choose style of code to emit from X86 backend:. .. code-block:: text. =att: Emit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst:4443,simpl,simple,4443,interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst,5,"['Simpl', 'simpl']","['Simple', 'simple', 'simple-noitin']"
Usability,"on; from source files that are significantly easier to code than the output files would be, and also easier to maintain and modify over time. The information is coded in a declarative style involving classes and records,; which are then processed by TableGen. ```; class Hello <string _msg> {; string msg = !strconcat(""Hello "", _msg);; }. def HelloWorld: Hello<""world!""> {}; ```; ```; ------------- Classes -----------------; class Hello<string Hello:_msg = ?> {; string msg = !strconcat(""Hello "", Hello:_msg);; }; ------------- Defs -----------------; def HelloWorld { // Hello; string msg = ""Hello world!"";; }; ```; [Try this example on Compiler Explorer.](https://godbolt.org/z/13xo1P5oz). The internalized records are passed on to various backends, which extract; information from a subset of the records and generate one or more output files. These output files are typically .inc files for C++, but may be any type of file; that the backend developer needs. Resources for learning the language:; * [TableGen Overview](https://llvm.org/docs/TableGen/index.html); * [Programmer's reference guide](https://llvm.org/docs/TableGen/ProgRef.html); * [Tutorial](jupyter/tablegen_tutorial_part_1.ipynb); * [Tools for Learning LLVM TableGen](https://blog.llvm.org/posts/2023-12-07-tools-for-learning-llvm-tablegen/); * [Lessons in TableGen](https://www.youtube.com/watch?v=45gmF77JFBY) (video),; [slides](https://archive.fosdem.org/2019/schedule/event/llvm_tablegen/attachments/slides/3304/export/events/attachments/llvm_tablegen/slides/3304/tablegen.pdf); * [Improving Your TableGen Descriptions](https://www.youtube.com/watch?v=dIEVUlsiktQ); (video), [slides](https://llvm.org/devmtg/2019-10/slides/Absar-ImprovingYourTableGenDescription.pdf). Writing TableGen backends:; * [TableGen Backend Developer's Guide](https://llvm.org/docs/TableGen/BackGuide.html); * [How to write a TableGen backend](https://www.youtube.com/watch?v=UP-LBRbvI_U); (video), [slides](https://llvm.org/devmtg/2021-11/slides/2021",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/README.md:1073,learn,learning,1073,interpreter/llvm-project/llvm/utils/TableGen/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/README.md,1,['learn'],['learning']
Usability,"on; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ~~~{.cpp}; root[] gGeoManager->CloseGeometry();; ~~~. Now we are really done with geometry building stage, but we would like; to see our simple world:. ~~~{.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ~~~. \anchor GP00b; ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at rootgeom.C. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just few hints on the building steps in this; example might be useful. The geometry here represents the word %ROOT that; is replicated in some symmetric manner. You might for instance ask some; questions after having a first look:. **Q:** ""OK, I understand the first lines that load the libGeom library and create; a geometry manager object. I also recognize from the previous example the following; lines creating some materials and media, but what about the geometrical transformations below?"". **A:** As explained before, the model that we are trying to create; is a hierarchy of volumes based on ""containment"". This is; accomplished by ""positioning"" some volumes ""inside"" others.; Any volume is an un-positioned object in the sense that it defines only; a ""local frame"" (matching the one of its ""shape""). In order; to fully define the mother-daughter relationship between two volumes one; has to specify how the daughter will be positioned inside. This is; accomplished by defining a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:7501,learn,learn,7501,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['learn'],['learn']
Usability,"onAST::codegen() {; ...; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. if (Value *RetVal = Body->codegen()) {; ... For each argument, we make an alloca, store the input value to the; function into the alloca, and register the alloca as the memory location; for the argument. This method gets invoked by ``FunctionAST::codegen()``; right after it sets up the entry block for the function. The final missing piece is adding the mem2reg pass, which allows us to; get good codegen once again:. .. code-block:: c++. // Promote allocas to registers.; TheFPM->add(createPromoteMemoryToRegisterPass());; // Do simple ""peephole"" optimizations and bit-twiddling optzns.; TheFPM->add(createInstructionCombiningPass());; // Reassociate expressions.; TheFPM->add(createReassociatePass());; ... It is interesting to see what the code looks like before and after the; mem2reg optimization runs. For example, this is the before/after code; for our recursive fib function. Before the optimization:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %x1 = alloca double; store double %x, double* %x1; %x2 = load double, double* %x1; %cmptmp = fcmp ult double %x2, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp one double %booltmp, 0.000000e+00; br i1 %ifcond, label %then, label %else. then: ; preds = %entry; br label %ifcont. else: ; preds = %entry; %x3 = load double, double* %x1; %subtmp = fsub double %x3, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %x4 = load double, double* %x1; %subtmp5 = fsub double %x4, 2.000000e+00; %calltmp6 = call double @fib(double %su",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:16662,simpl,simple,16662,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simple']
Usability,onCross.h; Minuit2/MnGlobalCorrelationCoeff.h; Minuit2/MnHesse.h; Minuit2/MnLineSearch.h; Minuit2/MnMachinePrecision.h; Minuit2/MnMatrix.h; Minuit2/MnMatrixfwd.h; Minuit2/MnMigrad.h; Minuit2/MnMinimize.h; Minuit2/MnMinos.h; Minuit2/MnParabola.h; Minuit2/MnParabolaFactory.h; Minuit2/MnParabolaPoint.h; Minuit2/MnParameterScan.h; Minuit2/MnPlot.h; Minuit2/MnPosDef.h; Minuit2/MnPrint.h; Minuit2/MnScan.h; Minuit2/MnSeedGenerator.h; Minuit2/MnSimplex.h; Minuit2/MnStrategy.h; Minuit2/MnTiny.h; Minuit2/MnTraceObject.h; Minuit2/MnUserCovariance.h; Minuit2/MnUserFcn.h; Minuit2/MnUserParameterState.h; Minuit2/MnUserParameters.h; Minuit2/MnUserTransformation.h; Minuit2/MnVectorTransform.h; Minuit2/ModularFunctionMinimizer.h; Minuit2/NegativeG2LineSearch.h; Minuit2/Numerical2PGradientCalculator.h; Minuit2/NumericalDerivator.h; Minuit2/ParametricFunction.h; Minuit2/ScanBuilder.h; Minuit2/ScanMinimizer.h; Minuit2/SimplexBuilder.h; Minuit2/SimplexMinimizer.h; Minuit2/SimplexParameters.h; Minuit2/SimplexSeedGenerator.h; Minuit2/SinParameterTransformation.h; Minuit2/SqrtLowParameterTransformation.h; Minuit2/SqrtUpParameterTransformation.h; Minuit2/StackAllocator.h; Minuit2/VariableMetricBuilder.h; Minuit2/VariableMetricEDMEstimator.h; Minuit2/VariableMetricMinimizer.h; Minuit2/VectorOuterProduct.h; TMinuit2TraceObject.h; SOURCES; src/AnalyticalGradientCalculator.cxx; src/BFGSErrorUpdator.cxx; src/CMakeLists.txt; src/CombinedMinimumBuilder.cxx; src/DavidonErrorUpdator.cxx; src/ExternalInternalGradientCalculator.cxx; src/FumiliBuilder.cxx; src/FumiliErrorUpdator.cxx; src/FumiliGradientCalculator.cxx; src/FumiliMinimizer.cxx; src/FumiliStandardChi2FCN.cxx; src/FumiliStandardMaximumLikelihoodFCN.cxx; src/HessianGradientCalculator.cxx; src/InitialGradientCalculator.cxx; src/LaEigenValues.cxx; src/LaInnerProduct.cxx; src/LaInverse.cxx; src/LaOuterProduct.cxx; src/LaSumOfElements.cxx; src/LaVtMVSimilarity.cxx; src/MPIProcess.cxx; src/MinimumBuilder.cxx; src/Minuit2Minimizer.cxx; src/MnAppli,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt:3145,Simpl,SimplexSeedGenerator,3145,math/minuit2/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt,1,['Simpl'],['SimplexSeedGenerator']
Usability,"on`_ (v1), transpiling; Python code into C++ and interpreting the result with CINT.; In early 2003, I ported this code to boost.python v2, then recently released.; In practice, however, re-interpreting the transpiled code was unusably slow,; thus I modified the code to make direct use of CINT's internal reflection; system, gaining about 25x in performance.; I presented this work as `PyROOT` at the ROOT Users' Workshop in early 2004,; and, after removing the boost.python dependency by using the C-API directly; (gaining another factor 7 in speedup!), it was included in ROOT.; PyROOT was presented at the SciPy'06 conference, but was otherwise not; advocated outside of High Energy Physics (HEP). In 2010, the PyPy core developers and I held a `sprint at CERN`_ to use; `Reflex`, a standalone alternative to CINT's reflection of C++, to add; automatic C++ bindings, PyROOT-style, to `PyPy`_.; This is where the name ""cppyy"" originated.; Coined by Carl Friedrich Bolz, if you want to understand the meaning, just; pronounce it slowly: cpp-y-y. After the ROOT team replaced CINT with `Cling`_, PyROOT soon followed.; As part of Google's Summer of Code '16, Aditi Dutta moved PyPy/cppyy to Cling; as well, and packaged the code for use through `PyPI`_.; I continued this integration with the Python eco-system by forking PyROOT,; reducing its dependencies, and repackaging it as CPython/cppyy.; The combined result is the current cppyy project.; Mid 2018, version 1.0 was released. .. _`CERN`: https://cern.ch/; .. _`PyROOT`: https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html#python-interface; .. _`CINT`: https://en.wikipedia.org/wiki/CINT; .. _`ROOT`: https://root.cern.ch; .. _`boost.python`: https://wiki.python.org/moin/boost.python/GettingStarted; .. _`sprint at CERN`: https://morepypy.blogspot.com/2010/07/cern-sprint-report-wrapping-c-libraries.html; .. _`PyPy`: https://www.pypy.org/; .. _`Cling`: https://github.com/vgvassilev/cling; .. _`PyPI`: https://pypi.org/; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/history.rst:2037,guid,guides,2037,bindings/pyroot/cppyy/cppyy/doc/source/history.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/history.rst,2,['guid'],"['guide', 'guides']"
Usability,"on``\ s from the current ``Module``.; #. Add or remove global variables from the current ``Module``.; #. Maintain state across invocations of :ref:`runOnFunction; <writing-an-llvm-pass-runOnFunction>` (including global data). Implementing a ``FunctionPass`` is usually straightforward (See the :ref:`Hello; World <writing-an-llvm-pass-basiccode>` pass for example).; ``FunctionPass``\ es may override three virtual methods to do their work. All; of these methods should return ``true`` if they modified the program, or; ``false`` if they didn't. .. _writing-an-llvm-pass-doInitialization-mod:. The ``doInitialization(Module &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Module &M);. The ``doInitialization`` method is allowed to do most of the things that; ``FunctionPass``\ es are not allowed to do. They can add and remove functions,; get pointers to functions, etc. The ``doInitialization`` method is designed to; do simple initialization type of stuff that does not depend on the functions; being processed. The ``doInitialization`` method call is not scheduled to; overlap with any other pass executions (thus it should be very fast). A good example of how this method should be used is the `LowerAllocations; <https://llvm.org/doxygen/LowerAllocations_8cpp-source.html>`_ pass. This pass; converts ``malloc`` and ``free`` instructions into platform dependent; ``malloc()`` and ``free()`` function calls. It uses the ``doInitialization``; method to get a reference to the ``malloc`` and ``free`` functions that it; needs, adding prototypes to the module if necessary. .. _writing-an-llvm-pass-runOnFunction:. The ``runOnFunction`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnFunction(Function &F) = 0;. The ``runOnFunction`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a ``true`` value; should be returned if the function is modified. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:18738,simpl,simple,18738,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"onally identifying; information (""doxing"").; * Personal insults, especially those using racist or sexist terms.; * Unwelcome sexual attention.; * Advocating for, or encouraging, any of the above behavior. In general, if someone asks you to stop, then stop. Persisting in such; behavior after being asked to stop is considered harassment. .. _when we disagree, try to understand why:. * **When we disagree, try to understand why.** Disagreements, both social and; technical, happen all the time and LLVM is no exception. It is important that; we resolve disagreements and differing views constructively. Remember that; we're different. The strength of LLVM comes from its varied community, people; from a wide range of backgrounds. Different people have different; perspectives on issues. Being unable to understand why someone holds; a viewpoint doesn't mean that they're wrong. Don't forget that it is human to; err and blaming each other doesn't get us anywhere. Instead, focus on helping; to resolve issues and learning from mistakes. Reporting; =========. If you believe someone is violating the code of conduct you can always report; it to the LLVM Foundation Code of Conduct Committee by emailing; conduct@llvm.org. All reports will be kept confidential. This isn't a public; list and only members of the advisory committee will receive the report. For; details on what to include in the report, please see the :doc:`Reporting Guide; <ReportingGuide>`. If you believe anyone is in physical danger, please notify appropriate law; enforcement first. If you are unsure what law enforcement agency is; appropriate, please include this in your report and we will attempt to notify; them. If the violation occurs at an event such as a Developer Meeting and requires; immediate attention, you can also reach out to any of the event organizers or; staff. Event organizers and staff will be prepared to handle the incident and; able to help. If you cannot find one of the organizers, the venue staff can;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:5402,learn,learning,5402,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['learn'],['learning']
Usability,"onfiguration.; Like server binding to specific host `root --notebook --ip=hostname`; - Remove `c.NotebookApp.ip = '*'` from default jupyter config. One has to provide ip address for server; binding using `root --notebook --ip=<hostaddr>` arguments; - Now Jupyter Notebooks will use JSROOT provided with ROOT installation. This allows to use notebooks; without internet connection (offline). ## JavaScript ROOT; - Provide monitoring capabilities for TGeoManager object. Now geomtry with some tracks can be displayed and; updated in web browser, using THttpServer monitoring capability like histogram objects. ## Tutorials; - Add the ""Legacy"" category collecting the old tutorials which do not represent any more best practices. ## Class Reference Guide; - Images in tutorials can now be displayed à JavaScript thanks to the (js) option; added next to the directive `\macro_image`; - As the tutorial `palettes.C` is often hit when searching the keyword `palette`; in the reference guide, a direct link from this example to the full list of; predefined palettes given in `TColor` has been added.; - Revisited the TSpectrum2 documentation. All the static images have been replaced; by macros generating images at reference guide build time. These macros have; been added in the tutorial section of the reference guide.; - The Reference Guide can now be accessed directly from the ROOT prompt thanks to; a great extension (implemented by Desislava Kalaydjieva) of the `.help` command.; For example to access the Reference Guide for `TTree` it is enough to type:; ~~~ {.cpp}; root[0] .help TTree; ~~~; To open the reference guide for a function/member:; ~~~ {.cpp}; root[0] .help TTree::Draw; ~~~. ## Build, Configuration and Testing Infrastructure. - Make MLP optional via the `-Dmlp={OFF,ON}` switch for CMake; - Make Spectrum optional via the `-Dspectrum={OFF,ON}` switch for CMake; - ROOT now fails to configure when any package is missing; when `-Dfail-on-missing=ON` is passed to CMake; - The `-Dall=",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:7093,guid,guide,7093,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['guid'],['guide']
Usability,"online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:2123,clear,clear,2123,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['clear'],['clear']
Usability,"only valid; operands for a named metadata. #. Named metadata are represented as a string of characters with the; metadata prefix. The rules for metadata names are the same as for; identifiers, but quoted names are not allowed. ``""\xx""`` type escapes; are still valid, which allows any character to be part of a name. Syntax::. ; Some unnamed metadata nodes, which are referenced by the named metadata.; !0 = !{!""zero""}; !1 = !{!""one""}; !2 = !{!""two""}; ; A named metadata.; !name = !{!0, !1, !2}. .. _paramattrs:. Parameter Attributes; --------------------. The return type and each parameter of a function type may have a set of; *parameter attributes* associated with them. Parameter attributes are; used to communicate additional information about the result or; parameters of a function. Parameter attributes are considered to be part; of the function, not of the function type, so functions with different; parameter attributes can have the same function type. Parameter attributes are simple keywords that follow the type specified.; If multiple parameter attributes are needed, they are space separated.; For example:. .. code-block:: llvm. declare i32 @printf(ptr noalias nocapture, ...); declare i32 @atoi(i8 zeroext); declare signext i8 @returns_signed_char(). Note that any attributes for the function result (``nonnull``,; ``signext``) come before the result type. Currently, only the following parameter attributes are defined:. ``zeroext``; This indicates to the code generator that the parameter or return; value should be zero-extended to the extent required by the target's; ABI by the caller (for a parameter) or the callee (for a return value).; ``signext``; This indicates to the code generator that the parameter or return; value should be sign-extended to the extent required by the target's; ABI (which is usually 32-bits) by the caller (for a parameter) or; the callee (for a return value).; ``inreg``; This indicates that this parameter or return value should be treated; in a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:50107,simpl,simple,50107,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"only* loop; in a given function, it is not touched. This is a pass most useful for; debugging via bugpoint. ``loop-reduce``: Loop Strength Reduction; ----------------------------------------. This pass performs a strength reduction on array references inside loops that; have as one or more of their components the loop induction variable. This is; accomplished by creating a new value to hold the initial value of the array; access for the first iteration, and then creating a new GEP instruction in the; loop to increment the value by the appropriate amount. .. _passes-loop-rotate:. ``loop-rotate``: Rotate Loops; -----------------------------. A simple loop rotation transformation. A summary of it can be found in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. This pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize gene",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:26772,simpl,simpler,26772,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,2,['simpl'],['simpler']
Usability,"onse Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Reporter(s); =============================. Once a report is filed, the Code of Conduct committee will handle the review; and follow up according to the procedures in the :doc:`Response Guide; <ResponseGuide>`. . Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Carpentries Response Guide: https://docs.carpentries.org/topic_folders/policies/enforcement-guidelines.html; .. _Write The Docs Response Guide: https://www.writethedocs.org/code-of-conduct/#guidelines-for-reporting-incidents; .. _Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/licenses/by/3.0/. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:4586,Guid,Guide,4586,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst,9,"['Guid', 'guid']","['Guide', 'guide', 'guidelines', 'guidelines-for-reporting-incidents']"
Usability,"ontainers are now instances of ilist (intrusive; linked list class), which use the next and previous fields to chain them; together. The advantage of this implementation is that iterators can be; formed directly from pointers to the LLVM value, and invalidation is much; easier to handle. * As part of the above change, dereferencing an iterator (for example:; BasicBlock::iterator) now produces a reference to the underlying type (same; example: Instruction&) instead of a pointer to the underlying object. This; makes it much easier to write nested loops that iterator over things, changing; this:. for (Function::iterator BI = Func->begin(); BI != Func->end(); ++BI); for (BasicBlock::iterator II = (*BI)->begin(); II != (*BI)->end(); ++II); (*II)->dump();. into:. for (Function::iterator BI = Func->begin(); BI != Func->end(); ++BI); for (BasicBlock::iterator II = BI->begin(); II != BI->end(); ++II); II->dump();. which is much more natural and what users expect. * Simplification of #include's: Before, it was necessary for a .cpp file to; include every .h file that it used. Now things are batched a little bit more; to make it easier to use. Specifically, the include graph now includes these; edges:; Module.h -> Function.h, GlobalVariable.h; Function.h -> BasicBlock.h, Argument.h; BasicBlock.h -> Instruction.h. Which means that #including Function.h is usually sufficient for getting the; lower level #includes. * Printing out a Value* has now changed: Printing a Value* will soon print out; the address of the value instead of the contents of the Value. To print out; the contents, you must convert it to a reference with (for example); 'cout << *I' instead of 'cout << I;'. This conversion is not yet complete,; but will be eventually. In the mean time, both forms print out the contents. * References are used much more throughout the code base. In general, if a; pointer is known to never be null, it is passed in as a reference instead of a; pointer. For example, the instruction visi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-06-25-MegaPatchInfo.txt:1891,Simpl,Simplification,1891,interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-06-25-MegaPatchInfo.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-06-25-MegaPatchInfo.txt,1,['Simpl'],['Simplification']
Usability,"ontents::; :local:. Description; ===========. ``bugpoint`` narrows down the source of problems in LLVM tools and passes. It; can be used to debug three types of failures: optimizer crashes, miscompilations; by optimizers, or bad native code generation (including problems in the static; and JIT compilers). It aims to reduce large test cases to small, useful ones.; For example, if ``opt`` crashes while optimizing a file, it will identify the; optimization (or combination of optimizations) that causes the crash, and reduce; the file down to a small example which triggers the crash. For detailed case scenarios, such as debugging ``opt``, or one of the LLVM code; generators, see :doc:`HowToSubmitABug`. Design Philosophy; =================. ``bugpoint`` is designed to be a useful tool without requiring any hooks into; the LLVM infrastructure at all. It works with any and all LLVM passes and code; generators, and does not need to ""know"" how they work. Because of this, it may; appear to do stupid things or miss obvious simplifications. ``bugpoint`` is; also designed to trade off programmer time for computer time in the; compiler-debugging process; consequently, it may take a long period of; (unattended) time to reduce a test case, but we feel it is still worth it. Note; that ``bugpoint`` is generally very quick unless debugging a miscompilation; where each test of the program (which requires executing it) takes a long time. Automatic Debugger Selection; ----------------------------. ``bugpoint`` reads each ``.bc`` or ``.ll`` file specified on the command line; and links them together into a single module, called the test program. If any; LLVM passes are specified on the command line, it runs these passes on the test; program. If any of the passes crash, or if they produce malformed output (which; causes the verifier to abort), ``bugpoint`` starts the `crash debugger`_. Otherwise, if the ``-output`` option was not specified, ``bugpoint`` runs the; test program with the ""safe""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:1145,simpl,simplifications,1145,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['simpl'],['simplifications']
Usability,"onvertGeometry()`; . After the conversion is done, all existing TGeo functionality is available as for; a native geometry, only that most of the converted solids provide better navigation ; performance, despite the overhead introduced by the new adapter shape. Prerequisites: installation of VecGeom. ; The installation instructions are available at <http://geant.web.cern.ch/content/installation>; Due to the fact that VecGeom provides for the moment static libraries ; and depends on ROOT, is is advised to compile first ROOT without VecGeom support, ; then compile VecGeom against this ROOT version, then re-configure ROOT to enable ; VecGeom and Vc support, using the flags -Dvc=ON -Dvecgeom=on; ; This has been implemented by Mihaela Gheata <Mihaela.Gheata@cern.ch>. ## Database Libraries. * Fix `TPgSQLStatement::SetBinary` to actually handle binary data (previous limited to ascii). ## Networking Libraries. * When seeing too many requested ranges, Apache 2.4 now simply sends the whole file; (MaxRanges configuration parameter). TWebFile can handle this case now, but this can; trigger multiple transmissions of the full file. TWebFile warns when Apache reacts by; sending the full file. ## GUI Libraries. * A new `Browser.ExpandDirectories` option (the default is `yes`) has been added, allowing to prevent expanding the parent directory tree in the ROOT Browser (for example on nfs). ## Language Bindings. ### PyROOT. * Added a new configuration option to disable processing of the rootlogon[.py|C] macro in addition; ro the -n option in the command arguments. To disable processing the rootlogon do the following; before any other command that will trigger initialization:; ```; >>> import ROOT; >>> ROOT.PyConfig.DisableRootLogon = True; >>> ...; ```. ### Notebook integration. * Refactoring of the Jupyter integration layer into the new package JupyROOT.; * Added ROOT [Jupyter Kernel for ROOT](https://root.cern.ch/root-has-its-jupyter-kernel); * Magics are now invoked with standard syn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:24775,simpl,simply,24775,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['simpl'],['simply']
Usability,"oo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<Decl>hasDeclContextMatcher<Decl> InnerMatcher; Matches declarations whose declaration context, interpreted as a; Decl, matches InnerMatcher. Given; namespace N {; namespace M {; class D {};; }; }. cxxRcordDecl(hasDeclContext(namedDecl(hasName(""M"")))) matches the; declaration of class D. Matcher<DecltypeType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<DecompositionDecl>hasAnyBindingMatcher<BindingDecl> InnerMatcher; Matches any binding of a DecompositionDecl. For example, in:; void foo(); {; int arr[3];; auto &[f, s, t] = arr;. f = 42;; }; The matcher:; decompositionDecl(hasAnyBinding(bindingDecl(hasName(""f"").bind(""fBinding"")))); matches the decomposition decl with 'f' bound to ""fBinding"". Matcher<DecompositionDecl>hasBindingunsigned N, Matcher<BindingDecl> InnerMatcher; Matches the Nth binding of a DecompositionDecl. For example, in:; void foo(); {; int arr[3];; auto &[f, s, t] = arr;. f = 42;; }; The matcher:; decompositionDecl(hasBinding(0,; bindingDecl(hasName(""f"").bind(""fBinding"")))); matches the decomposition decl with 'f' bound to ""fBinding"". Matcher<DoStmt>hasBodyMatcher<Stmt> InnerMatcher; Matches a 'for', 'while', 'while' statement or a function or coroutine; definition that has a given body. Note that in case of functions or; coroutines this matcher only matches the definition itself an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:187848,Usab,Usable,187848,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ooFoo; example above only contains one integral function (`integralFoo()`). Similar to `doFoo()`, comment out `integralFoo()' in the original file and; move it to 'MathFuncs.h'. As with `doFoo()`. add the relevant inputs (a,b) as parameters, instead of; just class members. ``` {.cpp}; ///// The MathFuncs.h file; int integralFoo(int a, int b) { return /* whatever */;}; ```. > Directory path: [hist/hist/src/MathFuncs.h](https://github.com/root-project/root/blob/master/hist/hist/src/MathFuncs.h). Next, in the original RooFoo class, update all references to the; `integralFoo()` function with its new fully qualified path (; `EvaluateFunc::integralFoo`) and include the input parameters as well (; `EvaluateFunc::integralFoo(a, b)`). ``` {.cpp}; double analyticalIntegral(Int_t code, const char* rangeName) override {; // Select the right paths for integration using codes or whatever.; return EvaluateFunc::integralFoo(a, b);; }; ```. Next, in the `RooAbsReal::buildCallToAnalyticIntegral()` function, simply; return the output using the `buildCall()` function. ``` {.cpp}; std::string; buildCallToAnalyticIntegral(Int_t code, const char *rangeName, RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const override {; return ctx.buildCall(""EvaluateFunc::integralFoo"", a, b);; }; ```. \note The implementation of the `RooAbsReal::buildCallToAnalyticIntegral()`; function is quite similar to the `translate()` function, except that in; `translate()`, you have to add to the result (using `addResult()`), while for; `buildCallToAnalyticIntegral()`, you only have to return the string (using; `buildCall()`). **Consolidated Code changes in RooFoo example**. Final RooFoo code:. ``` {.cpp}; class RooFoo : public RooAbsReal {; int a;; int b;; // int doFoo() { return a* b + a + b; }; // int integralFoo() { return /* whatever */;}; public:; // Other functions...; double evaluate() override {; // Do some bookkeeping; return EvaluateFunc::doFoo(a, b);; };; double analyticalIntegral(Int_t code, co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:23733,simpl,simply,23733,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simply']
Usability,"ool to clone and customize p.d.f.s into a RooSimultaneous p.d.f has been added. This new; tool succeeds the original RooSimPdfBuilder tool which had a similar functionality but; has a much cleaner interface, partly thanks to its use of the RooWorkspace class for both input; of prototype p.d.fs and output of built p.d.f.s. The simplest use case to to take a workspace p.d.f as prototype and 'split' a parameter of that p.d.f ; into two specialized parameters depending on a category in the dataset. ; For example, given a Gaussian p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'.; Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. . SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax {State1;State2} where State1; and State2 are the state names of the two spitting categories. Additional; functionality exists to work with multiple prototype p.d.f.s simultane",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:12366,simpl,simple,12366,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['simpl'],['simple']
Usability,"opAnalysisManager>();; TheFAM = std::make_unique<FunctionAnalysisManager>();; TheCGAM = std::make_unique<CGSCCAnalysisManager>();; TheMAM = std::make_unique<ModuleAnalysisManager>();; ThePIC = std::make_unique<PassInstrumentationCallbacks>();; TheSI = std::make_unique<StandardInstrumentations>(*TheContext,; /*DebugLogging*/ true);; TheSI->registerCallbacks(*ThePIC, TheMAM.get());; ... After initializing the global module ``TheModule`` and the FunctionPassManager,; we need to initialize other parts of the framework. The four AnalysisManagers; allow us to add analysis passes that run across the four levels of the IR; hierarchy. PassInstrumentationCallbacks and StandardInstrumentations are; required for the pass instrumentation framework, which allows developers to; customize what happens between passes. Once these managers are set up, we use a series of ""addPass"" calls to add a; bunch of LLVM transform passes:. .. code-block:: c++. // Add transform passes.; // Do simple ""peephole"" optimizations and bit-twiddling optzns.; TheFPM->addPass(InstCombinePass());; // Reassociate expressions.; TheFPM->addPass(ReassociatePass());; // Eliminate Common SubExpressions.; TheFPM->addPass(GVNPass());; // Simplify the control flow graph (deleting unreachable blocks, etc).; TheFPM->addPass(SimplifyCFGPass());. In this case, we choose to add four optimization passes.; The passes we choose here are a pretty standard set; of ""cleanup"" optimizations that are useful for a wide variety of code. I won't; delve into what they do but, believe me, they are a good starting place :). Next, we register the analysis passes used by the transform passes. .. code-block:: c++. // Register analysis passes used in these transform passes.; PassBuilder PB;; PB.registerModuleAnalyses(*TheMAM);; PB.registerFunctionAnalyses(*TheFAM);; PB.crossRegisterProxies(*TheLAM, *TheFAM, *TheCGAM, *TheMAM);; }. Once the PassManager is set up, we need to make use of it. We do this by; running it after our newly created fun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:7054,simpl,simple,7054,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simple']
Usability,"ope, functions are typed with just a count of their; arguments. Since all values are double precision floating point, the; type of each argument doesn't need to be stored anywhere. In a more; aggressive and realistic language, the ""ExprAST"" class would probably; have a type field. With this scaffolding, we can now talk about parsing expressions and; function bodies in Kaleidoscope. Parser Basics; =============. Now that we have an AST to build, we need to define the parser code to; build it. The idea here is that we want to parse something like ""x+y""; (which is returned as three tokens by the lexer) into an AST that could; be generated with calls like this:. .. code-block:: c++. auto LHS = std::make_unique<VariableExprAST>(""x"");; auto RHS = std::make_unique<VariableExprAST>(""y"");; auto Result = std::make_unique<BinaryExprAST>('+', std::move(LHS),; std::move(RHS));. In order to do this, we'll start by defining some basic helper routines:. .. code-block:: c++. /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.; static int CurTok;; static int getNextToken() {; return CurTok = gettok();; }. This implements a simple token buffer around the lexer. This allows us; to look one token ahead at what the lexer is returning. Every function; in our parser will assume that CurTok is the current token that needs to; be parsed. .. code-block:: c++. /// LogError* - These are little helper functions for error handling.; std::unique_ptr<ExprAST> LogError(const char *Str) {; fprintf(stderr, ""Error: %s\n"", Str);; return nullptr;; }; std::unique_ptr<PrototypeAST> LogErrorP(const char *Str) {; LogError(Str);; return nullptr;; }. The ``LogError`` routines are simple helper routines that our parser will; use to handle errors. The error recovery in our parser will not be the; best and is not particular user-friendly, but it will be enough fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:5837,simpl,simple,5837,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability,"operty, which specifies the; mapping information. The most common use of this parser is for parsing enum; values, which allows you to use the CommandLine library for all of the error; checking to make sure that only valid enum values are specified (as opposed to; accepting arbitrary strings). Despite this, however, the generic parser class; can be used for any data type. .. _boolean flags:; .. _bool parser:. * The **parser<bool> specialization** is used to convert boolean strings to a; boolean value. Currently accepted strings are ""``true``"", ""``TRUE``"",; ""``True``"", ""``1``"", ""``false``"", ""``FALSE``"", ""``False``"", and ""``0``"". * The **parser<boolOrDefault> specialization** is used for cases where the value; is boolean, but we also need to know whether the option was specified at all.; boolOrDefault is an enum with 3 values, BOU_UNSET, BOU_TRUE and BOU_FALSE.; This parser accepts the same strings as **``parser<bool>``**. .. _strings:. * The **parser<string> specialization** simply stores the parsed string into the; string value specified. No conversion or modification of the data is; performed. .. _integers:; .. _int:. * The **parser<int> specialization** uses the C ``strtol`` function to parse the; string input. As such, it will accept a decimal number (with an optional '+'; or '-' prefix) which must start with a non-zero digit. It accepts octal; numbers, which are identified with a '``0``' prefix digit, and hexadecimal; numbers with a prefix of '``0x``' or '``0X``'. .. _doubles:; .. _float:; .. _double:. * The **parser<double>** and **parser<float> specializations** use the standard; C ``strtod`` function to convert floating point strings into floating point; values. As such, a broad range of string formats is supported, including; exponential notation (ex: ``1.7e15``) and properly supports locales. .. _Extension Guide:; .. _extending the library:. Extension Guide; ===============. Although the CommandLine library has a lot of functionality built into it; already (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:60501,simpl,simply,60501,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simply']
Usability,"optimization runs. For example, this is the before/after code; for our recursive fib function. Before the optimization:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %x1 = alloca double; store double %x, double* %x1; %x2 = load double, double* %x1; %cmptmp = fcmp ult double %x2, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp one double %booltmp, 0.000000e+00; br i1 %ifcond, label %then, label %else. then: ; preds = %entry; br label %ifcont. else: ; preds = %entry; %x3 = load double, double* %x1; %subtmp = fsub double %x3, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %x4 = load double, double* %x1; %subtmp5 = fsub double %x4, 2.000000e+00; %calltmp6 = call double @fib(double %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; br label %ifcont. ifcont: ; preds = %else, %then; %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ]; ret double %iftmp; }. Here there is only one variable (x, the input argument) but you can; still see the extremely simple-minded code generation strategy we are; using. In the entry block, an alloca is created, and the initial input; value is stored into it. Each reference to the variable does a reload; from the stack. Also, note that we didn't modify the if/then/else; expression, so it still inserts a PHI node. While we could make an; alloca for it, it is actually easier to create a PHI node for it, so we; still just make the PHI. Here is the code after the mem2reg pass runs:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %cmptmp = fcmp ult double %x, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp one double %booltmp, 0.000000e+00; br i1 %ifcond, label %then, label %else. then:; br label %ifcont. else:; %subtmp = fsub double %x, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %subtmp5 = fsub double %x, 2.000000e+00; %calltmp6 = call double @fib(double %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; br label %ifcont. ifcont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:17942,simpl,simple-minded,17942,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simple-minded']
Usability,"opy is deleted also. When a pad is deleted or cleared, all objects in the pad with the; `kCanDelete` bit set are deleted automatically. Currently the objects; created by the `DrawCopy` methods, have the `kCanDelete` bit set and; are therefore owned by the pad. ## Ownership by the User. The user owns all objects not described in one of the above cases.; **`TObject`** has two bits, `kCanDelete` and `kMustCleanup`, that; influence how an object is managed (in `TObject::fBits)`. These are in; an enumeration in `TObject.h.` To set these bits do:. ``` {.cpp}; MyObject->SetBit(kCanDelete); MyObject->SetBit(kMustCleanup); ```. The bits can be reset and tested with the `TObject::ResetBit` and; **`TObject::TestBit` methods.**. ### The kCanDelete Bit. The ***`gROOT`*** collections (see above) own their members and will; delete them regardless of the `kCanDelete` bit. In all other; collections, when the collection `Clear` method is called (i.e.; **`TList::Clear())`**, members with the `kCanDelete` bit set, are; deleted and removed from the collection. If the `kCanDelete` bit is; not set, the object is only removed from the collection but not; deleted. If a collection `Delete` (`TList::Delete()`) method is called, all; objects in the collection are deleted without considering the; `kCanDelete` bit. It is important to realize that deleting the; collection (i.e. delete `MyCollection`), DOES NOT delete the members; of the collection. If the user specified `MyCollection->SetOwner()` the collection owns; the objects and delete `MyCollection` will delete all its members.; Otherwise, you need to:. ``` {.cpp}; // delete all member objects in the collection; MyCollection->Delete();. // and delete the collection object; delete MyCollection;; ```. Note that `kCanDelete` is automatically set by the `DrawCopy` method; and the user can set it for any object. For example, the user must; manage all graphics primitives. If you want **`TCanvas`** to delete; the primitive you created you have to se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md:5855,Clear,Clear,5855,documentation/users-guide/ObjectOwnership.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md,1,['Clear'],['Clear']
Usability,"or build systems that invokes the clang-scan-deps scanner per file, repeatedly; calculating the resource directory may be inefficient. In such cases, the build; system can cache the resource directory by itself and pass ``-resource-dir <resource-dir>``; explicitly in the command line options:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 -resource-dir <resource-dir> mod.cppm -c -o mod.o. Possible Questions; ==================. How modules speed up compilation; --------------------------------. A classic theory for the reason why modules speed up the compilation is:; if there are ``n`` headers and ``m`` source files and each header is included by each source file,; then the complexity of the compilation is ``O(n*m)``;; But if there are ``n`` module interfaces and ``m`` source files, the complexity of the compilation is; ``O(n+m)``. So, using modules would be a big win when scaling.; In a simpler word, we could get rid of many redundant compilations by using modules. Roughly, this theory is correct. But the problem is that it is too rough.; The behavior depends on the optimization level, as we will illustrate below. First is ``O0``. The compilation process is described in the following graph. .. code-block:: none. ├-------------frontend----------┼-------------middle end----------------┼----backend----┤; │ │ │ │; └---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘. ┌---------------------------------------------------------------------------------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:40035,simpl,simpler,40035,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['simpl'],['simpler']
Usability,"or each function:. .. code-block:: c++. KSDbgInfo.LexicalBlocks.push_back(SP);. Also, we may not forget to pop the scope back off of the scope stack at the; end of the code generation for the function:. .. code-block:: c++. // Pop off the lexical block for the function since we added it; // unconditionally.; KSDbgInfo.LexicalBlocks.pop_back();. Then we make sure to emit the location every time we start to generate code; for a new AST object:. .. code-block:: c++. KSDbgInfo.emitLocation(this);. Variables; =========. Now that we have functions, we need to be able to print out the variables; we have in scope. Let's get our function arguments set up so we can get; decent backtraces and see how our functions are being called. It isn't; a lot of code, and we generally handle it when we're creating the; argument allocas in ``FunctionAST::codegen``. .. code-block:: c++. // Record the function arguments in the NamedValues map.; NamedValues.clear();; unsigned ArgIdx = 0;; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Create a debug descriptor for the variable.; DILocalVariable *D = DBuilder->createParameterVariable(; SP, Arg.getName(), ++ArgIdx, Unit, LineNo, KSDbgInfo.getDoubleTy(),; true);. DBuilder->insertDeclare(Alloca, D, DBuilder->createExpression(),; DILocation::get(SP->getContext(), LineNo, 0, SP),; Builder->GetInsertBlock());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. Here we're first creating the variable, giving it the scope (``SP``),; the name, source location, type, and since it's an argument, the argument; index. Next, we create an ``lvm.dbg.declare`` call to indicate at the IR; level that we've got a variable in an alloca (and it gives a starting; location for the variable), and setting a source location for the; beg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:13346,clear,clear,13346,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['clear'],['clear']
Usability,"or executions that enter the header. .. _loopinfo:. LoopInfo; ========. LoopInfo is the core analysis for obtaining information about loops.; There are few key implications of the definitions given above which; are important for working successfully with this interface. * LoopInfo does not contain information about non-loop cycles. As a; result, it is not suitable for any algorithm which requires complete; cycle detection for correctness. * LoopInfo provides an interface for enumerating all top level loops; (e.g. those not contained in any other loop). From there, you may; walk the tree of sub-loops rooted in that top level loop. * Loops which become statically unreachable during optimization *must*; be removed from LoopInfo. If this can not be done for some reason,; then the optimization is *required* to preserve the static; reachability of the loop. .. _loop-terminology-loop-simplify:. Loop Simplify Form; ==================. The Loop Simplify Form is a canonical form that makes; several analyses and transformations simpler and more effective.; It is ensured by the LoopSimplify; (:ref:`-loop-simplify <passes-loop-simplify>`) pass and is automatically; added by the pass managers when scheduling a LoopPass.; This pass is implemented in; `LoopSimplify.h <https://llvm.org/doxygen/LoopSimplify_8h_source.html>`_.; When it is successful, the loop has:. * A preheader.; * A single backedge (which implies that there is a single latch).; * Dedicated exits. That is, no exit block for the loop; has a predecessor that is outside the loop. This implies; that all exit blocks are dominated by the loop header. .. _loop-terminology-lcssa:. Loop Closed SSA (LCSSA); =======================. A program is in Loop Closed SSA Form if it is in SSA form; and all values that are defined in a loop are used only inside; this loop. Programs written in LLVM IR are always in SSA form but not necessarily; in LCSSA. To achieve the latter, for each value that is live across the; loop boundary, single",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:9988,Simpl,Simplify,9988,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,2,"['Simpl', 'simpl']","['Simplify', 'simpler']"
Usability,"or lanes:. * ``sN`` for scalars; * ``pN`` for pointers; * ``<N x sM>`` for vectors. ``LLT`` is intended to replace the usage of ``EVT`` in SelectionDAG. Here are some LLT examples and their ``EVT`` and ``Type`` equivalents:. ============= ========= ======================================; LLT EVT IR Type; ============= ========= ======================================; ``s1`` ``i1`` ``i1``; ``s8`` ``i8`` ``i8``; ``s32`` ``i32`` ``i32``; ``s32`` ``f32`` ``float``; ``s17`` ``i17`` ``i17``; ``s16`` N/A ``{i8, i8}`` [#abi-dependent]_; ``s32`` N/A ``[4 x i8]`` [#abi-dependent]_; ``p0`` ``iPTR`` ``i8*``, ``i32*``, ``%opaque*``; ``p2`` ``iPTR`` ``i8 addrspace(2)*``; ``<4 x s32>`` ``v4f32`` ``<4 x float>``; ``s64`` ``v1f64`` ``<1 x double>``; ``<3 x s32>`` ``v3i32`` ``<3 x i32>``; ============= ========= ======================================. Rationale: instructions already encode a specific interpretation of types; (e.g., ``add`` vs. ``fadd``, or ``sdiv`` vs. ``udiv``). Also encoding that; information in the type system requires introducing bitcast with no real; advantage for the selector. Pointer types are distinguished by address space. This matches IR, as opposed; to SelectionDAG where address space is an attribute on operations.; This representation better supports pointers having different sizes depending; on their addressspace. .. note::. .. caution::. Is this still true? I thought we'd removed the 1-element vector concept.; Hypothetically, it could be distinct from a scalar but I think we failed to; find a real occurrence. Currently, LLT requires at least 2 elements in vectors, but some targets have; the concept of a '1-element vector'. Representing them as their underlying; scalar type is a nice simplification. .. rubric:: Footnotes. .. [#abi-dependent] This mapping is ABI dependent. Here we've assumed no additional padding is required. Generic Opcode Reference; ------------------------. The Generic Opcodes that are available are described at :doc:`GenericOpcode`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst:8900,simpl,simplification,8900,interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,1,['simpl'],['simplification']
Usability,"orarly moved to then standard input list, so that user; can use the selector input list as container of processing information; if they find convenient to do so. Process(...) methods with the file; name argument replaced by 'TSelector *' have  introduced where; relevant (TProof, TProofPlayer and their derivatives, TDSet).  ; Add the possibility to force submerging at node level, i.e. one; submerger per physical machine. In this way the network traffic can be; minimized, for example when merging large output files. The new feature; is enabled by setting the Int_t parameter 'PROOF_MergersByHost' (or the; directive 'Proof.MergersByHost') to a non-null value.; Simplify enabling of basic feedback. In TProof::Process, add; support for switches ""fb=name1,name2,name3,... "" or; ""feedback=name1,name2,name3,... "" in the option field. This enables; feedback for the specified objects, creating a TDrawFeedback object; attached to the session. Feedback for the specified objects is disabled; at the end of the query and the created TDrawFeedback is destroyed. The; special name 'stats' enables the three feedback histograms required by; a dedicated new class TStatsFeedback, and uses a TStatsFeedback instead; of TDrawFeedback to display the feedback. . Improvements; ; Add to TProofMgr two static functions to upload files. These; functions are both called UploadFiles and differ in the first argument,; which is used to pass the files to be uploaded. These can be given as a; list (of TFileInfo or TObjString), a directory or specified in a text; file.; Add support for paralell dataset verification. This is; implemented via a dedicated TSelector (TSelVerifyDataSet) which is run; over the list of files in the dataset via TPacketizerFile. The file; order is preserved using the recently introduced index in TFileInfo.; In TProofOutputFile, add switch to control the way histograms; are merged by TFileMerger, i.e. one-by-one or all-in-one-go. The; default is one-by-one which requires much less me",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html:2131,Feedback,Feedback,2131,proof/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html,1,['Feedback'],['Feedback']
Usability,"ord definitions in; one place. A multiclass is a sort of macro that can be ""invoked"" to define; multiple concrete records all at once. A multiclass can inherit from other; multiclasses, which means that the multiclass inherits all the definitions; from its parent multiclasses. `Appendix C: Sample Record`_ illustrates a complex record in the Intel X86; target and the simple way in which it is defined. Source Files; ============. TableGen source files are plain ASCII text files. The files can contain; statements, comments, and blank lines (see `Lexical Analysis`_). The standard file; extension for TableGen files is ``.td``. TableGen files can grow quite large, so there is an include mechanism that; allows one file to include the content of another file (see `Include; Files`_). This allows large files to be broken up into smaller ones, and; also provides a simple library mechanism where multiple source files can; include the same library file. TableGen supports a simple preprocessor that can be used to conditionalize; portions of ``.td`` files. See `Preprocessing Facilities`_ for more; information. Lexical Analysis; ================. The lexical and syntax notation used here is intended to imitate; `Python's`_ notation. In particular, for lexical definitions, the productions; operate at the character level and there is no implied whitespace between; elements. The syntax definitions operate at the token level, so there is; implied whitespace between tokens. .. _`Python's`: http://docs.python.org/py3k/reference/introduction.html#notation. TableGen supports BCPL-style comments (``// ...``) and nestable C-style; comments (``/* ... */``).; TableGen also provides simple `Preprocessing Facilities`_. Formfeed characters may be used freely in files to produce page breaks when; the file is printed for review. The following are the basic punctuation tokens::. - + [ ] { } ( ) < > : ; . ... = ? #. Literals; --------. Numeric literals take one of the following forms:. .. productionl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:6264,simpl,simple,6264,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"ore detail: rf509_wsinteractive.C.; writeToFile -- A new utility method RooWorkspace::writeToFile() has been added; to simplify the process of saving a workspace to file; Named sets and parameter snapshots -- It is now possible to define and retrieve; named RooArgSets of objects that live in the workspace through methods; defineSet() and set(). While named sets merely group objects logically, methods loadSnapshot and; saveSnapshot allow to make copies of the values, errors and 'constant' status of; sets of variable objects that live in the workspace. A newly added tutorial macro rf510_namedsets.C illustrates the functionality of both; of these features.; Improved printing of contents -- Many operator p.d.f. and function components now show; a more intuitive natural representation of their contents (these changes are mostly in the; respective p.d.f.s, but are most relevant in the context of a workspace). New object factory interface to workspace to facilitate script driven model definition; A object factory has been added to RooFit to simplify the process of creating p.d.f.; and function expressions consisting of multiple objects. The factory has two goals:; the first is to provide a back-end for higher level factories and tools to process; the creation of objects. The second is to provide a simple end-user language to; populate a RooWorkspace with function and p.d.f. objects. For the latter purpose the object creation language is executed through the factory() method; of a workspace object. RooWorkspace w(""w"") ;; RooAbsArg* arg = w.factory(""expression_goes_here"") ;. Basic Syntax; The rules at its simplest level are as follows. Expressions with square brackets create variables (discrete and continuous). ""m[-10,10]"" - Creates a RooRealVar named 'm' with range [-10,10]; ""m[5,-10,10]"" - Idem, but with initial value 5; ""m[5]"" - Creates a constant RooRealVar with name 'm' and value 5. ""tagCat[Lep,Kao,NT1,NT2]"" -- Creates a RooCategory with name tagCat and labeled states Le",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:18194,simpl,simplify,18194,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['simpl'],['simplify']
Usability,"ore information on `Xeus Cling's Read the Docs; <https://xeus-cling.readthedocs.io/en/latest/>`_ webpage. 2. **Interactive CUDA C++ with Cling:**. `CUDA <https://blogs.nvidia.com/blog/2012/09/10/what-is-cuda-2/>`_ is a platform; and Application Programming Interface (API) created by `NVIDIA; <https://www.nvidia.com/en-us/>`_. It controls `GPU; <https://en.wikipedia.org/wiki/Graphics_processing_unit>`_ (Graphical Processing; Unit) for parallel programming, enabling developers to harness the power of; graphic processing units (GPUs) to speed up applications. As an example,; `PIConGPU <https://github.com/ComputationalRadiationPhysics/picongpu>`_ is a; CUDA-based plasma physics application to solve the dynamics of a plasma by; computing the motion of electrons and ions in the plasma field. Interactive GPU; programming was made possible by extending Cling functionality to compile CUDA; C++ code. The new Cling-CUDA C++ can be used on Jupyter Notebook platform, and; enables big, interactive simulation with GPUs, easy GPU development and; debugging, and effective GPU programming learning. 3. **Clad:**. `Clad <https://compiler-research.org/clad/>`_ enables automatic differentiation; (AD) for C++. It was first developed as a plugin for Cling, and is now a plugin; for Clang compiler. Clad is based on source code transformation. Given C++; source code of a mathematical function, it can automatically generate C++ code; for computing derivatives of the function. It supports both forward-mode and; reverse-mode AD. 4. **Cling for live coding music and musical instruments:**. The artistic live coding community has been growing steadily since around the; year 2000. The Temporary Organisation for the Permanence of Live Art Programming; (TOPLAP) has been around since 2004, Algorave (algorithmic rave parties); recently celebrated its tenth birthday, and six editions of the International; Conference on Live Coding (ICLC) have been held. A great many live coding; systems have been develop",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst:1896,learn,learning,1896,interpreter/cling/docs/chapters/applications.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst,1,['learn'],['learning']
Usability,"ore likely a large project will have a pre-existing functional; decomposition that can be followed, with a dictionary per functional unit. Generation; ^^^^^^^^^^. There are two interfaces onto the same underlying dictionary generator:; ``rootcling`` and ``genreflex``.; The reason for having two is historic and they are not complete duplicates,; so one or the other may suit your preference better.; It is foreseen that both will be replaced once C++ modules become more; mainstream, as that will allow simplification and improved robustness. rootcling; """""""""""""""""". The first interface is called ``rootcling``::. $ rootcling; Usage: rootcling [-v][-v0-4] [-f] [out.cxx] [opts] file1.h[+][-][!] file2.h[+][-][!] ...[Linkdef.h]; For more extensive help type: /usr/local/lib/python2.7/dist-packages/cppyy_backend/bin/rootcling -h. Rather than providing command line options, the main steering of; ``rootcling`` behavior is done through; `#pragmas in a Linkdef.h <https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file>`_; file, with most pragmas dedicated to selecting/excluding (parts of) classes; and functions.; Additionally, the Linkdef.h file may contain preprocessor macros. The output consists of a dictionary file (to be compiled into a shared; library), a C++ module, and an optional mapping file, as described above. genreflex; """""""""""""""""". The second interface is called ``genreflex``::. $ genreflex; Generates dictionary sources and related ROOT pcm starting from an header.; Usage: genreflex headerfile.h [opts] [preproc. opts]; ... ``genreflex`` has a richer command line interface than ``rootcling`` as can; be seen from the full help message. .. _selection-files:. Selection/exclusion is driven through a `selection file`_ using an XML format; that allows both exact and pattern matching to namespace, class, enum,; function, and variable names. .. _`selection file`: https://linux.die.net/man/1/genreflex. Example; """""""""""""". Consider the following basic exam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:4247,guid,guides,4247,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,2,['guid'],"['guide', 'guides']"
Usability,"ore the; function and do not draw it. ### Advances Options. The advance option button is enabled only after having performed the fit and provides; additional drawing options that can be used after having done the fit. These new drawing tools,; which can be selected by the ""Advanced Drawing Tool"" panel that pops up when clicking the ""Advanced"" button, are:. * *Contour*: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour; (more points might require more time to compute it), the parameters and the desired confidence level . * *Scan* : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter. * *Conf Interval* : to plot the confidence interval of the fitted function as a filled coloured band around its central value.; One can select the desired confidence level for the band to be plotted. ### Print Options. This set of options specifies the amount of feedback printed on the; root command line after performed fits. *‘Verbose'* - prints fit results after each iteration. *‘Quiet'* - no fit information is printed. *‘Default'* - between Verbose and Quiet. ### Command Buttons. *Fit button* - performs a fit taking different option settings via the; Fit Panel interface. *Reset* - sets the GUI elements and related fit settings to the; default ones. *Close* - closes the Fit panel window. ### Minimization Options. With this tab one can select specific options for minimization. These include. * The minimizer library ( *Minuit*, *Minuit2*, *Fumili*, *GSL*, *Genetics* ); * The method (algorithm) for minimization. For example for Minuit one can choose between (*Migrad*, *Simplex* or *Scan*); * Error definition; * Minimization tolerance; * Number of iterations/function calls; * Print Level: (*Default*, *Verbose* or *Quiet*). ## New ROOT::Fit classes. The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes,; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:25427,feedback,feedback,25427,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['feedback'],['feedback']
Usability,"ore you use it. For; example, the C function:. .. code-block:: c. int X() { int i; return i; }. Is compiled to ""``ret i32 undef``"" because ""``i``"" never has a value specified; for it. Why does instcombine + simplifycfg turn a call to a function with a mismatched calling convention into ""unreachable""? Why not make the verifier reject it?; ----------------------------------------------------------------------------------------------------------------------------------------------------------; This is a common problem run into by authors of front-ends that are using; custom calling conventions: you need to make sure to set the right calling; convention on both the function and on each call to the function. For; example, this code:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define void @bar() {; call void @foo(); ret void; }. Is optimized to:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define void @bar() {; unreachable; }. ... with ""``opt -instcombine -simplifycfg``"". This often bites people because; ""all their code disappears"". Setting the calling convention on the caller and; callee is required for indirect calls to work, so people often ask why not; make the verifier reject this sort of thing. The answer is that this code has undefined behavior, but it is not illegal.; If we made it illegal, then every transformation that could potentially create; this would have to ensure that it doesn't, and there is valid code that can; create this sort of construct (in dead code). The sorts of things that can; cause this to happen are fairly contrived, but we still need to accept them.; Here's an example:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define internal void @bar(void()* %FP, i1 %cond) {; br i1 %cond, label %T, label %F; T:; call void %FP(); ret void; F:; call fastcc void %FP(); ret void; }; define void @test() {; %X = or i1 false, false; call void @bar(void()* @foo, i1 %X); ret void; }. In this example, """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:9845,simpl,simplifycfg,9845,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,1,['simpl'],['simplifycfg']
Usability,"ore; information about what your pass does, and how it can be combined with other; passes. One of the main features of the LLVM Pass Framework is that it; schedules passes to run in an efficient way based on the constraints that your; pass meets (which are indicated by which class they derive from). We start by showing you how to construct a pass, everything from setting up the; code, to compiling, loading, and executing it. After the basics are down, more; advanced features are discussed. .. warning::; This document deals with the legacy pass manager. LLVM uses the new pass; manager for the optimization pipeline (the codegen pipeline; still uses the legacy pass manager), which has its own way of defining; passes. For more details, see :doc:`WritingAnLLVMNewPMPass` and; :doc:`NewPassManager`. Quick Start --- Writing hello world; ===================================. Here we describe how to write the ""hello world"" of passes. The ""Hello"" pass is; designed to simply print out the name of non-external functions that exist in; the program being compiled. It does not modify the program at all, it just; inspects it. The source code and files for this pass are available in the LLVM; source tree in the ``lib/Transforms/Hello`` directory. .. _writing-an-llvm-pass-makefile:. Setting up the build environment; --------------------------------. First, configure and build LLVM. Next, you need to create a new directory; somewhere in the LLVM source base. For this example, we'll assume that you; made ``lib/Transforms/Hello``. Finally, you must set up a build script; that will compile the source code for the new pass. To do this,; copy the following into ``CMakeLists.txt``:. .. code-block:: cmake. add_llvm_library( LLVMHello MODULE; Hello.cpp. PLUGIN_TOOL; opt; ). and the following line into ``lib/Transforms/CMakeLists.txt``:. .. code-block:: cmake. add_subdirectory(Hello). (Note that there is already a directory named ``Hello`` with a sample ""Hello""; pass; you may play with it -- in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:2093,simpl,simply,2093,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simply']
Usability,"orial. In chapters 1 through 8, we've built a; decent little programming language with functions and variables.; What happens if something goes wrong though, how do you debug your; program?. Source level debugging uses formatted data that helps a debugger; translate from binary and the state of the machine back to the; source that the programmer wrote. In LLVM we generally use a format; called `DWARF <http://dwarfstd.org>`_. DWARF is a compact encoding; that represents types, source locations, and variable locations. The short summary of this chapter is that we'll go through the; various things you have to add to a programming language to; support debug info, and how you translate that into DWARF. Caveat: For now we can't debug via the JIT, so we'll need to compile; our program down to something small and standalone. As part of this; we'll make a few modifications to the running of the language and; how programs are compiled. This means that we'll have a source file; with a simple program written in Kaleidoscope rather than the; interactive JIT. It does involve a limitation that we can only; have one ""top level"" command at a time to reduce the number of; changes necessary. Here's the sample program we'll be compiling:. .. code-block:: python. def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2);. fib(10). Why is this a hard problem?; ===========================. Debug information is a hard problem for a few different reasons - mostly; centered around optimized code. First, optimization makes keeping source; locations more difficult. In LLVM IR we keep the original source location; for each IR level instruction on the instruction. Optimization passes; should keep the source locations for newly created instructions, but merged; instructions only get to keep a single location - this can cause jumping; around when stepping through optimized programs. Secondly, optimization; can move variables in ways that are either optimized out, shared in memory; with other variables",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:1265,simpl,simple,1265,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['simpl'],['simple']
Usability,"orial_ProofEvent ProofEvent; \ingroup tutorial_proof; \brief Selector for generic processing with Event. Example of TSelector implementation to do generic; processing with the test 'Event' structure.; See tutorials/proof/runProof.C, option ""event"", for an; example of how to run this selector. \defgroup tutorial_ProofEventProc ProofEventProc; \ingroup tutorial_proof; \brief Selector to process trees containing Event structures. Example of TSelector implementation to process trees; containing 'Event' structures, e.g. the files under; http://root.cern/files/data .; See tutorials/proof/runProof.C, option ""eventproc"", for; an example of how to run this selector. \defgroup tutorial_ProofFriends ProofFriends; \ingroup tutorial_proof; \brief Selector to process tree friends. Example of TSelector implementation to process tree friends in PROOF.; See tutorials/proof/runProof.C, option ""eventproc"", for; an example of how to run this selector. \defgroup tutorial_ProofNtuple ProofNtuple; \ingroup tutorial_proof; \brief Selector to fill a simple ntuple. Example of TSelector implementation to do generic processing; (filling a simple ntuple, in this case).; See tutorials/proof/runProof.C, option ""ntuple"", for an; example of how to run this selector. \defgroup tutorial_ProofPythia ProofPythia; \ingroup tutorial_proof; \brief Selector to generate Monte Carlo events with Pythia8. Example of TSelector implementation to do a Monte Carlo; generation using Pythia8.; See tutorials/proof/runProof.C, option ""pythia8"", for an; example of how to run this selector. \defgroup tutorial_ProofSimple ProofSimple; \ingroup tutorial_proof; \brief Selector to fill a set of histograms. Example of TSelector implementation to do generic processing (filling a; set of histograms in this case).; See tutorials/proof/runProof.C, option ""simple"", for an; example of how to run this selector. \defgroup tutorial_ProofSimpleFile ProofSimpleFile; \ingroup tutorial_proof; \brief Selector to fill a set of histograms a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/index.md:1354,simpl,simple,1354,tutorials/proof/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/index.md,1,['simpl'],['simple']
Usability,"orithm. This pass guarantees that the following canonicalizations are performed on the; program:. #. If a binary operator has a constant operand, it is moved to the right-hand; side.; #. Bitwise operators with constant operands are always grouped so that shifts; are performed first, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant power-of-two argument are transformed into; shifts.; #. … etc. This pass can also simplify calls to specific well-known function calls (e.g.; runtime library functions). For example, a call ``exit(3)`` that occurs within; the ``main()`` function can be transformed into simply ``return 3``. Whether or; not library calls are simplified is controlled by the; :ref:`-function-attrs <passes-function-attrs>` pass and LLVM's knowledge of; library calls on different targets. .. _passes-aggressive-instcombine:. ``aggressive-instcombine``: Combine expression patterns; --------------------------------------------------------. Combine expression patterns to form expressions with fewer, simple instructions. For example, this pass reduce width of expressions post-dominated by TruncInst; into smaller width when applicable. It differs from instcombine pass in that it can modify CFG and contains pattern; optimization that requires higher complexity than the O(1), thus, it should run fewer; times than instcombine pass. ``internalize``: Internalize Global Symbols; -------------------------------------------. This pass loops over all of the functions in the input module, looking for a; main function. If a main function is found, all other functions and all global; variables with initializers are marked as internal. ``ipsccp``: Interprocedural Sparse Conditional Constant Propagat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:20661,simpl,simplified,20661,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplified']
Usability,"ork we built for other operators. Adding unary; operators is a bit more challenging, because we don't have any framework; for it yet - let's see what it takes. User-defined Unary Operators; ============================. Since we don't currently support unary operators in the Kaleidoscope; language, we'll need to add everything to support them. Above, we added; simple support for the 'unary' keyword to the lexer. In addition to; that, we need an AST node:. .. code-block:: c++. /// UnaryExprAST - Expression class for a unary operator.; class UnaryExprAST : public ExprAST {; char Opcode;; std::unique_ptr<ExprAST> Operand;. public:; UnaryExprAST(char Opcode, std::unique_ptr<ExprAST> Operand); : Opcode(Opcode), Operand(std::move(Operand)) {}. Value *codegen() override;; };. This AST node is very simple and obvious by now. It directly mirrors the; binary operator AST node, except that it only has one child. With this,; we need to add the parsing logic. Parsing a unary operator is pretty; simple: we'll add a new function to do it:. .. code-block:: c++. /// unary; /// ::= primary; /// ::= '!' unary; static std::unique_ptr<ExprAST> ParseUnary() {; // If the current token is not an operator, it must be a primary expr.; if (!isascii(CurTok) || CurTok == '(' || CurTok == ','); return ParsePrimary();. // If this is a unary operator, read it.; int Opc = CurTok;; getNextToken();; if (auto Operand = ParseUnary()); return std::make_unique<UnaryExprAST>(Opc, std::move(Operand));; return nullptr;; }. The grammar we add is pretty straightforward here. If we see a unary; operator when parsing a primary operator, we eat the operator as a; prefix and parse the remaining piece as another unary operator. This; allows us to handle multiple unary operators (e.g. ""!!x""). Note that; unary operators can't have ambiguous parses like binary operators can,; so there is no need for precedence information. The problem with this function, is that we need to call ParseUnary from; somewhere. To do this,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:11159,simpl,simple,11159,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"ork):. .. code-block:: console. $ opt -load lib/LLVMHello.so -hello < hello.bc > /dev/null; Hello: __main; Hello: puts; Hello: main. The :option:`-load` option specifies that :program:`opt` should load your pass; as a shared object, which makes ""``-hello``"" a valid command line argument; (which is one reason you need to :ref:`register your pass; <writing-an-llvm-pass-registration>`). Because the Hello pass does not modify; the program in any interesting way, we just throw away the result of; :program:`opt` (sending it to ``/dev/null``). To see what happened to the other string you registered, try running; :program:`opt` with the :option:`-help` option:. .. code-block:: console. $ opt -load lib/LLVMHello.so -help; OVERVIEW: llvm .bc -> .bc modular optimizer and analysis printer. USAGE: opt [subcommand] [options] <input bitcode file>. OPTIONS:; Optimizations available:; ...; -guard-widening - Widen guards; -gvn - Global Value Numbering; -gvn-hoist - Early GVN Hoisting of Expressions; -hello - Hello World Pass; -indvars - Induction Variable Simplification; -inferattrs - Infer set function attributes; ... The pass name gets added as the information string for your pass, giving some; documentation to users of :program:`opt`. Now that you have a working pass,; you would go ahead and make it do the cool transformations you want. Once you; get it all working and tested, it may become useful to find out how fast your; pass is. The :ref:`PassManager <writing-an-llvm-pass-passmanager>` provides a; nice command line option (:option:`-time-passes`) that allows you to get; information about the execution time of your pass along with the other passes; you queue up. For example:. .. code-block:: console. $ opt -load lib/LLVMHello.so -hello -time-passes < hello.bc > /dev/null; Hello: __main; Hello: puts; Hello: main; ===-------------------------------------------------------------------------===; ... Pass execution timing report ...; ===----------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:9264,Simpl,Simplification,9264,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['Simpl'],['Simplification']
Usability,"orking on a fully-general operator precedence parser, this is all; we need to do to ""extend the grammar"". Now we have useful user-defined binary operators. This builds a lot on; the previous framework we built for other operators. Adding unary; operators is a bit more challenging, because we don't have any framework; for it yet - let's see what it takes. User-defined Unary Operators; ============================. Since we don't currently support unary operators in the Kaleidoscope; language, we'll need to add everything to support them. Above, we added; simple support for the 'unary' keyword to the lexer. In addition to; that, we need an AST node:. .. code-block:: c++. /// UnaryExprAST - Expression class for a unary operator.; class UnaryExprAST : public ExprAST {; char Opcode;; std::unique_ptr<ExprAST> Operand;. public:; UnaryExprAST(char Opcode, std::unique_ptr<ExprAST> Operand); : Opcode(Opcode), Operand(std::move(Operand)) {}. Value *codegen() override;; };. This AST node is very simple and obvious by now. It directly mirrors the; binary operator AST node, except that it only has one child. With this,; we need to add the parsing logic. Parsing a unary operator is pretty; simple: we'll add a new function to do it:. .. code-block:: c++. /// unary; /// ::= primary; /// ::= '!' unary; static std::unique_ptr<ExprAST> ParseUnary() {; // If the current token is not an operator, it must be a primary expr.; if (!isascii(CurTok) || CurTok == '(' || CurTok == ','); return ParsePrimary();. // If this is a unary operator, read it.; int Opc = CurTok;; getNextToken();; if (auto Operand = ParseUnary()); return std::make_unique<UnaryExprAST>(Opc, std::move(Operand));; return nullptr;; }. The grammar we add is pretty straightforward here. If we see a unary; operator when parsing a primary operator, we eat the operator as a; prefix and parse the remaining piece as another unary operator. This; allows us to handle multiple unary operators (e.g. ""!!x""). Note that; unary operators can",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:10964,simpl,simple,10964,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"ormationalMessage(...);; ... ... which is a real pain! Instead of defining two values for the same; condition, we can use the ""`cl::alias`_"" class to make the ""``-q``"" option an; **alias** for the ""``-quiet``"" option, instead of providing a value itself:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Overwrite output files""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::alias QuietA(""q"", cl::desc(""Alias for -quiet""), cl::aliasopt(Quiet));. The third line (which is the only one we modified from above) defines a ""``-q``""; alias that updates the ""``Quiet``"" variable (as specified by the `cl::aliasopt`_; modifier) whenever it is specified. Because aliases do not hold state, the only; thing the program has to query is the ``Quiet`` variable now. Another nice; feature of aliases is that they automatically hide themselves from the ``-help``; output (although, again, they are still visible in the ``-help-hidden output``). Now the application code can simply use:. .. code-block:: c++. ...; if (!Quiet) printInformationalMessage(...);; ... ... which is much nicer! The ""`cl::alias`_"" can be used to specify an; alternative name for any variable type, and has many uses. .. _unnamed alternatives using the generic parser:. Selecting an alternative from a set of possibilities; ----------------------------------------------------. So far we have seen how the CommandLine library handles builtin types like; ``std::string``, ``bool`` and ``int``, but how does it handle things it doesn't; know about, like enums or '``int*``'s?. The answer is that it uses a table-driven generic parser (unless you specify; your own parser, as described in the `Extension Guide`_). This parser maps; literal strings to whatever type is required, and requires you to tell it what; this mapping should be. Let's say that we would like to add four optimization levels to our optimizer,; using the standard flags ""``-g``"", ""``-O0``"", ""``-O1``"", and ""``-O2``"". We; co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:12973,simpl,simply,12973,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simply']
Usability,"oroutine from the corresponding suspend point should be done at the point; of `coro.save` intrinsic. Example:; """""""""""""""". Separate save and suspend points are necessary when a coroutine is used to; represent an asynchronous control flow driven by callbacks representing; completions of asynchronous operations. In such a case, a coroutine should be ready for resumption prior to a call to; `async_op` function that may trigger resumption of a coroutine from the same or; a different thread possibly prior to `async_op` call returning control back; to the coroutine:. .. code-block:: llvm. %save1 = call token @llvm.coro.save(ptr %hdl); call void @async_op1(ptr %hdl); %suspend1 = call i1 @llvm.coro.suspend(token %save1, i1 false); switch i8 %suspend1, label %suspend [i8 0, label %resume1; i8 1, label %cleanup]. .. _coro.suspend.async:. 'llvm.coro.suspend.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare {ptr, ptr, ptr} @llvm.coro.suspend.async(; ptr <resume function>,; ptr <context projection function>,; ... <function to call>; ... <arguments to function>). Overview:; """""""""""""""""". The '``llvm.coro.suspend.async``' intrinsic marks the point where; execution of an async coroutine is suspended and control is passed to a callee. Arguments:; """""""""""""""""""". The first argument should be the result of the `llvm.coro.async.resume` intrinsic.; Lowering will replace this intrinsic with the resume function for this suspend; point. The second argument is the `context projection function`. It should describe; how-to restore the `async context` in the continuation function from the first; argument of the continuation function. Its type is `ptr (ptr)`. The third argument is the function that models transfer to the callee at the; suspend point. It should take 3 arguments. Lowering will `musttail` call this; function. The fourth to six argument are the arguments for the third argument. Semantics:; """""""""""""""""""". The result of the intrinsic are mapped to the arguments of the resu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:53353,resume,resume,53353,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"orpus.; ./a.out. You should get an error pretty quickly::. INFO: Seed: 1523017872; INFO: Loaded 1 modules (16 guards): [0x744e60, 0x744ea0),; INFO: -max_len is not provided, using 64; INFO: A corpus is not provided, starting from an empty corpus; #0	READ units: 1; #1	INITED cov: 3 ft: 2 corp: 1/1b exec/s: 0 rss: 24Mb; #3811	NEW cov: 4 ft: 3 corp: 2/2b exec/s: 0 rss: 25Mb L: 1 MS: 5 ChangeBit-ChangeByte-ChangeBit-ShuffleBytes-ChangeByte-; #3827	NEW cov: 5 ft: 4 corp: 3/4b exec/s: 0 rss: 25Mb L: 2 MS: 1 CopyPart-; #3963	NEW cov: 6 ft: 5 corp: 4/6b exec/s: 0 rss: 25Mb L: 2 MS: 2 ShuffleBytes-ChangeBit-; #4167	NEW cov: 7 ft: 6 corp: 5/9b exec/s: 0 rss: 25Mb L: 3 MS: 1 InsertByte-; ==31511== ERROR: libFuzzer: deadly signal; ...; artifact_prefix='./'; Test unit written to ./crash-b13e8756b13a00cf168300179061fb4b91fefbed. More examples; -------------. Examples of real-life fuzz targets and the bugs they find can be found; at http://tutorial.libfuzzer.info. Among other things you can learn how; to detect Heartbleed_ in one second. Advanced features; =================; .. contents::; :local:; :depth: 1. Dictionaries; ------------; LibFuzzer supports user-supplied dictionaries with input language keywords; or other interesting byte sequences (e.g. multi-byte magic values).; Use ``-dict=DICTIONARY_FILE``. For some input languages using a dictionary; may significantly improve the search speed.; The dictionary syntax is similar to that used by AFL_ for its ``-x`` option::. # Lines starting with '#' and empty lines are ignored. # Adds ""blah"" (w/o quotes) to the dictionary.; kw1=""blah""; # Use \\ for backslash and \"" for quotes.; kw2=""\""ac\\dc\""""; # Use \xAB for hex values; kw3=""\xF7\xF8""; # the name of the keyword followed by '=' may be omitted:; ""foo\x0Abar"". Tracing CMP instructions; ------------------------. With an additional compiler flag ``-fsanitize-coverage=trace-cmp``; (on by default as part of ``-fsanitize=fuzzer``, see SanitizerCoverageTraceDataFlow_); libFuzzer will int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:19177,learn,learn,19177,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['learn'],['learn']
Usability,"ory contains a large array of small tests that exercise; various features of LLVM and to ensure that regressions do not occur.; The directory is broken into several sub-directories, each focused on a; particular area of LLVM. Writing new regression tests; ----------------------------. The regression test structure is very simple, but does require some; information to be set. This information is gathered via ``cmake``; and is written to a file, ``test/lit.site.cfg.py`` in the build directory.; The ``llvm/test`` Makefile does this work for you. In order for the regression tests to work, each directory of tests must; have a ``lit.local.cfg`` file. :program:`lit` looks for this file to determine; how to run the tests. This file is just Python code and thus is very; flexible, but we've standardized it for the LLVM regression tests. If; you're adding a directory of tests, just copy ``lit.local.cfg`` from; another directory to get running. The standard ``lit.local.cfg`` simply; specifies which files to look in for tests. Any directory that contains; only directories does not need the ``lit.local.cfg`` file. Read the :doc:`Lit; documentation <CommandGuide/lit>` for more information. Each test file must contain lines starting with ""RUN:"" that tell :program:`lit`; how to run it. If there are no RUN lines, :program:`lit` will issue an error; while running a test. RUN lines are specified in the comments of the test program using the; keyword ``RUN`` followed by a colon, and lastly the command (pipeline); to execute. Together, these lines form the ""script"" that :program:`lit`; executes to run the test case. The syntax of the RUN lines is similar to a; shell's syntax for pipelines including I/O redirection and variable; substitution. However, even though these lines may *look* like a shell; script, they are not. RUN lines are interpreted by :program:`lit`.; Consequently, the syntax differs from shell in a few ways. You can specify; as many RUN lines as needed. :program:`lit` perfo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:8051,simpl,simply,8051,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['simpl'],['simply']
Usability,"ory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. And that's it! You can compile our new tool by running ninja from the; ``build`` directory. .. code-block:: console. cd ~/clang-llvm/build; ninja. You should now be able to run the syntax checker, which is located in; ``~/clang-llvm/build/bin``, on any source file. Try it!. .. code-block:: console. echo ""int main() { return 0; }"" > test.cpp; bin/loop-convert test.cpp --. Note the two dashes after we specify the source file. The additional; options for the compiler are passed after the dashes rather than loading; them from a compilation database - there just aren't any options needed; right now. Intermezzo: Learn AST matcher basics; ====================================. Clang recently introduced the :doc:`ASTMatcher; library <LibASTMatchers>` to provide a simple, powerful, and; concise way to describe specific patterns in the AST. Implemented as a; DSL powered by macros and templates (see; `ASTMatchers.h <../doxygen/ASTMatchers_8h_source.html>`_ if you're; curious), matchers offer the feel of algebraic data types common to; functional programming languages. For example, suppose you wanted to examine only binary operators. There; is a matcher to do exactly that, conveniently named ``binaryOperator``.; I'll give you one guess what this matcher does:. .. code-block:: c++. binaryOperator(hasOperatorName(""+""), hasLHS(integerLiteral(equals(0)))). Shockingly, it will match against addition expressions whose left hand; side is exactly the literal 0. It will not match against other forms of; 0, such as ``'\0'`` or ``NULL``, but it will match against macros that; expand to 0. The matcher will also not match against calls t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:5641,Learn,Learn,5641,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['Learn'],['Learn']
Usability,"os; - Use `gStyle` attributes to draw histogram title; - Enable projections drawing also with `TH2` lego plots; - Many adjustment with new `TWebCanvas` - interactivity, attributes/position updates, context menus; - Upgrade three.js 86 -> 102, use `SoftwareRenderer` instead of `CanvasRenderer`; - Upgrade d3.js 4.4.4 -> 5.7.0; - Fix - support clipping for tracks and points in geo painter; - Fix - drawing of TGeoNode with finder; - Fix - key press events processed only in active pad (ROOT-9128); - Fix - use X0/Y0 in xtru shape, thanks to @altavir. ### New files location. JSROOT sources were moved from `etc/http/` into `js/` subfolder in ROOT sources tree.; OpenUI5 files were moved to `ui5/` subfolder. After ROOT compilation they can be found in; `$ROOTSYS/js/` and `$ROOTSYS/ui5/` subfolders respectively. ## Tutorials; - Add `RSqliteDS` examples.; - Make RCsvDS and RLazyDS tutorials standalone, i.e. downloading input csv directly using `TFile::Cp` rather than relying on CMake. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. ### CMake build system requirements and updates. The minimum required version of CMake has been updated to 3.9 or newer to be; able to take advantage of new features such as native support for the CUDA; language, among other things. Please refer to CMake's release notes for further; information. The method to select the C++ standard has changed. Now the recommended way; to select the C++ standard is via the option `-DCMAKE_CXX_STANDARD=XX`, which; is the idiomatic way to do it in CMake. The old options still work, but have; been deprecated and will be removed in a future release. Build option descriptions have been updated to indicate which builtins require; an active network connection during the build. You can inspect the list of; options and their descriptions by running `cmake -LH $PWD` in the build; directory. The build system has been updated to remove most file globbing to improve; the reliability of incremental b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:21909,Guid,Guide,21909,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['Guid'],['Guide']
Usability,"ossible from the coroutine address,; printing the details of the coroutine frame from an address is also possible:. ::. (gdb) # Get the address of coroutine frame; (gdb) print/x *0x418eb0; $1 = 0x4019e0; (gdb) # Get the linkage name for the coroutine; (gdb) x 0x4019e0; 0x4019e0 <_ZL9coro_taski>: 0xe5894855; (gdb) # Turn off the demangler temporarily to avoid the debugger misunderstanding the name.; (gdb) set demangle-style none; (gdb) # The coroutine frame type is 'linkage_name.coro_frame_ty'; (gdb) print ('_ZL9coro_taski.coro_frame_ty')*(0x418eb0); $2 = {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {...}, ...}. The above is possible because:. (1) The name of the debug type of the coroutine frame is the `linkage_name`,; plus the `.coro_frame_ty` suffix because each coroutine function shares the; same coroutine type. (2) The coroutine function name is accessible from the address of the coroutine; frame. The above commands can be simplified by placing them in debug scripts. Examples to print coroutine frames; ----------------------------------. The print examples below use the following definition:. .. code-block:: c++. #include <coroutine>; #include <iostream>. struct task{; struct promise_type {; task get_return_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:5869,simpl,simplified,5869,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['simpl'],['simplified']
Usability,"ost's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system for all; widgets. ### TGWidget. The widgets base class **`TGWidget`** is typically used as a mix-in; class via multiple inheritances. Its properties are available for all; deriving widgets: **`TGButton`**, **`TGComboBox`**, **`TGTab`**,; **`TGColorPalette`**, **`TGColorPick`**, **`TGDoubleSlider`**,; **`TGListTree`**, **`TGNumberEntry`**, **`TGScrollBar`**,; **`TGShutterItem`**, **`TGTextEntry`**, **`TGSlider`**, **`TGListBox`**,; **`TGView.`**. This class has four data members keeping information about the widget id; - important for event processing, the window which handles the widget's; events, the widget status flags and the assigned command (if there is; any). The general properties of **`TGWidget`** are specified by; `SetFlags(Int_t flags)` and `ClearFlags(Int_t flags)` methods. The; status flags are: `kWidgetWantFocus`, `kWidgetHasFocus`, and; `kWidgetIsEnabled`. The method `Associate(const TGWindow* w)` - sets the; window which handles the widget events.; `SetCommand(const char* command)` - sets the command to be executed. The; command string can be gathering via `GetCommand()` method. For example,; the third parameter in **`TGTextButton`** constructor can be omitted and; set later in your program, i.e. instead of:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate()"");; ```. You will have the following the two lines:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"");; exit->SetCommand(""gApplication->Terminate()"");; ```. The method `IsEnabled()` - returns `kTRUE` if the widget has flag; `kWidgetIsEnabled` and it accepts user events. This method is very; important for creating a good user interface because it allows you to; disable or enabl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:22206,Clear,ClearFlags,22206,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['Clear'],['ClearFlags']
Usability,"ot match if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<Decl>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were expanded within files whose name is; partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<Decl>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Decl>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Decl>isImplicit; Matches an entity that has been implicitly added by the compiler (e.g.; implicit default/copy constructors). Matcher<Decl>isInAnonymousNamespace; Matches declarations in an anonymous namespace. Given; class vector {};; namespace foo {; class vector {};; namespace {; class vector {}; // #1; }; }; namespace {; class vector {}; // #2; namespace foo {; class vector{}; // #3; }; }; cxxRecordDecl(hasName(""vector""), isInAnonymousNamespace()) will match; #1, #2 and #3. Matcher<Decl>isInStdNamespace; Matches declarations in the namespace `std`, but not in nested namespaces. Given; class vector {};; namespace foo {; class vector ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:82967,Usab,Usable,82967,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ot match if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<Stmt>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were expanded within files whose name is; partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<Stmt>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Stmt>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Stmt>isInTemplateInstantiation; Matches statements inside of a template instantiation. Given; int j;; template<typename T> void A(T t) { T i; j += 42;}; A(0);; A(0U);; declStmt(isInTemplateInstantiation()); matches 'int i;' and 'unsigned i'.; unless(stmt(isInTemplateInstantiation())); will NOT match j += 42; as it's shared between the template definition and; instantiation. Matcher<StringLiteral>hasSizeunsigned N; Matches nodes that have the specified size. Given; int a[42];; int b[2 * 21];; int c[41], d[43];; char *s = ""abcd"";; wchar_t *ws = L""abcd"";; char *w = ""a"";; constantArrayType(hasSize(42)); matches ""int a[42]"" and ""int b[2 * 21",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:116342,Usab,Usable,116342,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ot support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit usually doesn't need to be set by hand, as the key ArgList; accessors will set it automatically. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Toolchains**. The gcc driver has no direct understanding of tool chains. Each gcc; bi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:15339,simpl,simply,15339,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simply']
Usability,"ot,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back operations, supports efficient random access to its elements,; etc. The main advantage of SmallVector is that it allocates space for some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This is good for vectors that are ""usually small"" (e.g. the number of; predecessors/successors of a block is usually less than 8). On the other hand,; this makes the size of the SmallVector itself large, so you don't want to; allocate lots of them (doing so will waste a lot of space). As such,; SmallVectors are most useful when on the stack. In the absence of a well-motivated choice for the number of; inlined elements ``N``, it is recommended to use ``SmallVector<T>`` (that is,; omittin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:59450,simpl,simple,59450,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,ot.h; RooStats/HypoTestInverterResult.h; RooStats/HypoTestPlot.h; RooStats/HypoTestResult.h; RooStats/IntervalCalculator.h; RooStats/LikelihoodInterval.h; RooStats/LikelihoodIntervalPlot.h; RooStats/MarkovChain.h; RooStats/MaxLikelihoodEstimateTestStat.h; RooStats/MCMCCalculator.h; RooStats/MCMCInterval.h; RooStats/MCMCIntervalPlot.h; RooStats/MetropolisHastings.h; RooStats/MinNLLTestStat.h; RooStats/ModelConfig.h; RooStats/NeymanConstruction.h; RooStats/NumberCountingPdfFactory.h; RooStats/NumberCountingUtils.h; RooStats/NumEventsTestStat.h; RooStats/PdfProposal.h; RooStats/PointSetInterval.h; RooStats/ProfileInspector.h; RooStats/ProfileLikelihoodCalculator.h; RooStats/ProfileLikelihoodTestStat.h; RooStats/ProofConfig.h; RooStats/ProposalFunction.h; RooStats/ProposalHelper.h; RooStats/RatioOfProfiledLikelihoodsTestStat.h; RooStats/RooStatsUtils.h; RooStats/SamplingDistPlot.h; RooStats/SamplingDistribution.h; RooStats/SequentialProposal.h; RooStats/SimpleInterval.h; RooStats/SimpleLikelihoodRatioTestStat.h; RooStats/SPlot.h; RooStats/TestStatistic.h; RooStats/TestStatSampler.h; RooStats/ToyMCImportanceSampler.h; RooStats/ToyMCSampler.h; RooStats/ToyMCStudy.h; RooStats/UniformProposal.h; RooStats/UpperLimitMCSModule.h; SOURCES; src/AsymptoticCalculator.cxx; src/BayesianCalculator.cxx; src/BernsteinCorrection.cxx; src/ConfidenceBelt.cxx; src/DetailedOutputAggregator.cxx; src/FeldmanCousins.cxx; src/FrequentistCalculator.cxx; src/Heaviside.cxx; src/HLFactory.cxx; src/HybridCalculator.cxx; src/HybridPlot.cxx; src/HybridResult.cxx; src/HypoTestCalculatorGeneric.cxx; src/HypoTestInverter.cxx; src/HypoTestInverterPlot.cxx; src/HypoTestInverterResult.cxx; src/HypoTestPlot.cxx; src/HypoTestResult.cxx; src/LikelihoodInterval.cxx; src/LikelihoodIntervalPlot.cxx; src/MarkovChain.cxx; src/MCMCCalculator.cxx; src/MCMCInterval.cxx; src/MCMCIntervalPlot.cxx; src/MetropolisHastings.cxx; src/NeymanConstruction.cxx; src/NumberCountingPdfFactory.cxx; src/NumberCountingUtils.cxx; src/P,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/CMakeLists.txt:2161,Simpl,SimpleLikelihoodRatioTestStat,2161,roofit/roostats/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/CMakeLists.txt,1,['Simpl'],['SimpleLikelihoodRatioTestStat']
Usability,"ot[] myCanvas->cd(1); ```. We then draw the variable `Cost`:. ``` {.cpp}; root[] MyTree->Draw(""C; ```. As you can see, the last call `TTree::Draw` has only one parameter. It; is a string containing the leaf name. A histogram is automatically; created as a result of a `TTree::Draw`. The style of the histogram is; inherited from the **`TTree`** attributes and the current style; (***`gStyle`***) is ignored. The **`TTree`** gets its attributes from; the current **`TStyle`** at the time it was created. You can call the; method `TTree::UseCurrentStyle` to change to the current style rather; than the **`TTree`** style. (See ***`gStyle`***; see also ""Graphics and; the Graphical User Interface"" ). In the next segment, we activate the second pad and draw a scatter plot; variables:. ``` {.cpp}; root[] myCanvas->cd(2); root[] MyTree->Draw(""Cost:Age""); ```. This signature still only has one parameter, but it now has two; dimensions separated by a colon `(""x:y"")`. The item to be plotted can be; an expression not just a simple variable. In general, this parameter is; a string that contains up to three expressions, one for each dimension,; separated by a colon (""`e1:e2:e3`""). A list of examples follows this; introduction. ### Using Selection with TTree:Draw. Change the active pad to 3, and add a selection to the list of; parameters of the draw command. ``` {.cpp}; root[] myCanvas->cd(3); root[] MyTree->Draw(""Cost:Age"",""Nation == ""FR""""); ```. This will draw the `Cost `vs. `Age` for the entries where the nation is; equal to ""`FR`"". You can use any C++ operator, and some functions; defined in **`TFormula`**, in the selection parameter. The value of the; selection is used as a weight when filling the histogram. If the; expression includes only Boolean operations as in the example above, the; result is 0 or 1. If the result is 0, the histogram is not filled. In; general, the expression is:. ``` {.cpp}; Selection = ""weight *(boolean expression)""; ```. If the Boolean expression evaluates t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:70843,simpl,simple,70843,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"otebook' command option to start a local notebook server customised with all the ROOT features. New tutorials and code examples have been provided. The simplest example showing the integration of ROOT with the notebook technology can be found [here](https://root.cern.ch/notebooks/HowTos/HowTo_ROOT-Notebooks.html) and many more snippets [here](https://root.cern.ch/code-examples#notebooks). Support for capturing large outputs (stderr/stdout) coming from C++ libraries has been added. ## JavaScript ROOT. - support registered in THttpServer commands with arguments.; - provide workaround for websites using require.js and older jquery-ui; - support custom requests to remote objects, demonstrated in httptextlog.C tutorial; - rewrite draw.htm (page for individual object drawing) to support all custom features as main gui does; - See also the [JSRoot 3.9 examples page](https://root.cern.ch/js/3.9/) and the [JSRoot 3.9 release notes](https://github.com/linev/jsroot/releases/tag/3.9). ## Class Reference Guide. The ROOT [reference guide](https://root.cern.ch/doc/master/index.html) is moving; to the Doxygen system. Doxygen is the de-facto standard for code documentation. It offers; many nice features we are now exploring and trying to get the best of them. Having; [MathJax rendered math formula](https://root.cern.ch/doc/master/classTSpectrum2.html#a482a7f144b9cc1b0405d0ac0d8cc9bbb); is one of them. The documentation can be structured in a more logical way; [using groups](https://root.cern.ch/doc/master/modules.html). Still there is a lot; to do but big progresses have been done. We developed also a Doxygen filter allowing; to execute macros given as examples in the documentation and show the; [resulting picture directly in the documentation](https://root.cern.ch/doc/master/classTHistPainter.html#HP16). ## Tutorials. [The tutorials](https://root.cern.ch/doc/master/group__Tutorials.html) in; `$ROOTSYS/tutorials` are also presented on the web thanks to Doxygen. They; are now part of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:23550,Guid,Guide,23550,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['Guid'],['Guide']
Usability,"otect your rights, we need to make restrictions that forbid; distributors to deny you these rights or to ask you to surrender these; rights. These restrictions translate to certain responsibilities for; you if you distribute copies of the library or if you modify it. For example, if you distribute copies of the library, whether gratis; or for a fee, you must give the recipients all the rights that we gave; you. You must make sure that they, too, receive or can get the source; code. If you link other code with the library, you must provide; complete object files to the recipients, so that they can relink them; with the library after making changes to the library and recompiling; it. And you must show them these terms so they know their rights. We protect your rights with a two-step method: (1) we copyright the; library, and (2) we offer you this license, which gives you legal; permission to copy, distribute and/or modify the library. To protect each distributor, we want to make it very clear that; there is no warranty for the free library. Also, if the library is; modified by someone else and passed on, the recipients should know; that what they have is not the original version, so that the original; author's reputation will not be affected by problems that might be; introduced by others. Finally, software patents pose a constant threat to the existence of; any free program. We wish to make sure that a company cannot; effectively restrict the users of a free program by obtaining a; restrictive license from a patent holder. Therefore, we insist that; any patent license obtained for a version of the library must be; consistent with the full freedom of use specified in this license. Most GNU software, including some libraries, is covered by the; ordinary GNU General Public License. This license, the GNU Lesser; General Public License, applies to certain designated libraries, and; is quite different from the ordinary General Public License. We use; this license for certa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT:4889,clear,clear,4889,interpreter/cling/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT,1,['clear'],['clear']
Usability,"otect your rights, we need to make restrictions that forbid; distributors to deny you these rights or to ask you to surrender these; rights. These restrictions translate to certain responsibilities for; you if you distribute copies of the library or if you modify it. For example, if you distribute copies of the library, whether gratis; or for a fee, you must give the recipients all the rights that we gave; you. You must make sure that they, too, receive or can get the source; code. If you link other code with the library, you must provide; complete object files to the recipients, so that they can relink them; with the library after making changes to the library and recompiling; it. And you must show them these terms so they know their rights. We protect your rights with a two-step method: (1) we copyright the; library, and (2) we offer you this license, which gives you legal; permission to copy, distribute and/or modify the library. To protect each distributor, we want to make it very clear that; there is no warranty for the free library. Also, if the library is; modified by someone else and passed on, the recipients should know; that what they have is not the original version, so that the original; author's reputation will not be affected by problems that might be; introduced by others.; ; Finally, software patents pose a constant threat to the existence of; any free program. We wish to make sure that a company cannot; effectively restrict the users of a free program by obtaining a; restrictive license from a patent holder. Therefore, we insist that; any patent license obtained for a version of the library must be; consistent with the full freedom of use specified in this license. Most GNU software, including some libraries, is covered by the; ordinary GNU General Public License. This license, the GNU Lesser; General Public License, applies to certain designated libraries, and; is quite different from the ordinary General Public License. We use; this license for c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:2602,clear,clear,2602,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,1,['clear'],['clear']
Usability,"otes that explain the warning; to the user better. There are some existing visitors that might be useful for your check,; e.g. trackNullOrUndefValue. For example, SimpleStreamChecker should highlight; the event of opening the file when reporting a file descriptor leak. If the check tracks anything in the program state, it needs to implement the; checkDeadSymbolscallback to clean the state up.; The check should conservatively assume that the program is correct when a tracked symbol; is passed to a function that is unknown to the analyzer.; checkPointerEscape callback could help you handle that case.; Use safe and convenient APIs!. Always use CheckerContext::generateErrorNode and; CheckerContext::generateNonFatalErrorNode for emitting bug reports.; Most importantly, never emit report against CheckerContext::getPredecessor.; Prefer checkPreCall and checkPostCall to; checkPreStmt<CallExpr> and checkPostStmt<CallExpr>.; Use CallDescription to detect hardcoded API calls in the program.; Simplify C.getState()->getSVal(E, C.getLocationContext()) to C.getSVal(E). Common sources of crashes:. CallEvent::getOriginExpr is nullable - for example, it returns null for an; automatic destructor of a variable. The same applies to some values generated while the; call was modeled, eg. SymbolConjured::getStmt is nullable.; CallEvent::getDecl is nullable - for example, it returns null for a; call of symbolic function pointer.; addTransition, generateSink, generateNonFatalErrorNode,; generateErrorNode are nullable because you can transition to a node that you have already visited.; Methods of CallExpr/FunctionDecl/CallEvent that; return arguments crash when the argument is out-of-bounds. If you checked the function name,; it doesn't mean that the function has the expected number of arguments!; Which is why you should use CallDescription.; Nullability of different entities within different kinds of symbols and regions is usually; documented via assertions in their constructors.; NamedDecl::",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:24445,Simpl,Simplify,24445,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['Simpl'],['Simplify']
Usability,"other things, it has the ROOT::iOS::Pad class, which is a version; of TPad for iOS (pad with TF2 example below). Two applications, based on this module, were developed for iOS (currently,; for iPad only): ""Tutorials"" and ""RootBrowser"".; They can be found in $ROOTSYS/test/ios. ""Tutorials"" app; Small application with several demos, ""iOS version"" of the $ROOTSYS/tutorlas/demos.C. ""Tutorials"" application:. supports portrait and landscape orientation; has several demos (can be selected by tapping on table's cells); supports different gestures (pinch, single and double tap, pan, etc. - active gestures are shown by hint icons); has ""zoom"" mode - pinch or double tap gesture will zoom in/out pad's contents; has ""selection"" mode - with single tap user can select different objects inside pad - axes, histograms, pavestats etc.; 3D objects can be rotated.; has a simple editor to modify pad's parameters : fill color, logarithmic scale, grid, ticks, etc. ""RootBrowser"" app; This application is a simplified version of TBrowser and TCanvas; for iOS. User can open ROOT's file (application uses TWebFile) and; browse file's contents.; RootBrower registers *.root file extension in a system, so for; example, attached root files from a mail client can be opened by; RootBrowser.; Application has several views. In a top level view, user can see; opened files, open new files, close files (long press gesture on; a file icon):. Tap gesture on a file's icon will open ""File contents"" view. This; view shows objects and nested directories. For objects small; previews are generated. Tapping on a directory's icon will open; new view with directory's contents. Simple search is supported; (in the current TDirectoryFile). Tap on a object's preview will open detailed view for this object.; Using pinch gesture or double tap, you can zoom in/zoom out pad's; contents.; If you have several objects in a file or directory, you can; navigate through directory contents by using swipe gesture,; scrolling your obj",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v532/index.html:2406,simpl,simplified,2406,graf2d/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v532/index.html,1,['simpl'],['simplified']
Usability,"ots mechanism in; a standalone executable program on `linux` platform with the `gcc`; compiler. `tst.C `. ``` {.cpp}; #include <TQObject.h>; #include <RQ_OBJECT.h>. class A {; RQ_OBJECT(""A""); private:; Int_t fValue;; public:; A() : fValue(0) { }; ~A() { }; void SetValue(Int_t value); // *SIGNAL*; void PrintValue() const { printf(""value = %d\n"", fValue); }; };; void A::SetValue(Int_t value) { // Set new value; // Emit signal ""SetValue(Int_t)"" with a single parameter; if (value != fValue) {; fValue = value;; Emit(""SetValue(Int_t)"", fValue);; }; }; // Main program; #ifdef STANDALONE; int main(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ```. ACLiC simplifies this procedure and allows the dictionary generation by:. ``` {.cpp}; root[] .L tst.C++; ```. It will create the shared library `tst_C.so.`. The next line will create an executable:. **`` g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE ``**. The library `tst_C.so` is a dynamically loaded library and should be; located in `$LD_LIBRARY_PATH`. The current working directory should be; added to `$LD_LIBRARY_PATH` via:. **`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./`**. To run it, you just do:. **`./tst`**. ## Widgets in Detail. ### Buttons. Buttons are a popular group of widgets designed to provide specific; interfaces for user interaction. **`TGButton`** is an abstract class; defining the general button behavior: width, height, state, its group,; tool tip text, etc. There are two main groups of buttons: command buttons with a text or; graphics inside that indicate the action to be accomplished and option; buttons well known as radio and check buttons that select or change; properties. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:53396,simpl,simplifies,53396,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simplifies']
Usability,"ot}.getReg(), ${src}.getReg(), ${mi}->hasImplicitDef())"")>;. Common Pattern #1: Replace a Register with Another; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The 'apply' pattern must always redefine all operands defined by the match root.; Sometimes, we do not need to create instructions, simply replace a def with; another matched register. The ``GIReplaceReg`` builtin can do just that. .. code-block:: text. def Foo : GICombineRule<; (defs root:$dst),; (match (G_FNEG $tmp, $src), (G_FNEG $dst, $tmp)),; (apply (GIReplaceReg $dst, $src))>;. This also works if the replacement register is a temporary register from the; ``apply`` pattern. .. code-block:: text. def ReplaceTemp : GICombineRule<; (defs root:$a),; (match (G_BUILD_VECTOR $tmp, $x, $y),; (G_UNMERGE_VALUES $a, $b, $tmp)),; (apply (G_UNMERGE_VALUES $a, i32:$new, $y),; (GIReplaceReg $b, $new))>. Common Pattern #2: Erasing a Def-less Root; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If we simply want to erase a def-less match root, we can use the; ``GIEraseRoot`` builtin. .. code-block:: text. def Foo : GICombineRule<; (defs root:$mi),; (match (G_STORE $a, $b):$mi),; (apply (GIEraseRoot))>;. Common Pattern #3: Emitting a Constant Value; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. When an immediate operand appears in an 'apply' pattern, the behavior; depends on whether it's typed or not. * If the immediate is typed, ``MachineIRBuilder::buildConstant`` is used; to create a ``G_CONSTANT``. A ``G_BUILD_VECTOR`` will be used for vectors.; * If the immediate is untyped, a simple immediate is added; (``MachineInstrBuilder::addImm``). There is of course a special case for ``G_CONSTANT``. Immediates for; ``G_CONSTANT`` must always be typed, and a CImm is added; (``MachineInstrBuilder::addCImm``). .. code-block:: text; :caption: Constant Emission Examples:. // Example output:; // %0 = G_CONSTANT i32 0; // %dst = COPY %0; def Foo : GICombineRule<; (defs root:$dst),; (match (G_FOO $dst, $src)),; (apply (COPY $dst, (i3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:9026,simpl,simply,9026,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['simpl'],['simply']
Usability,"ou can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compatibility. GCC is currently the defacto-standard open source compiler today, and it; routinely compiles a huge volume of code. GCC supports a huge number of; extensi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:2155,simpl,simple,2155,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['simpl'],['simple']
Usability,"ouble @foo(double %x) {; entry:; %calltmp = call double @sin(double %x); %multmp = fmul double %calltmp, %calltmp; %calltmp2 = call double @cos(double %x); %multmp4 = fmul double %calltmp2, %calltmp2; %addtmp = fadd double %multmp, %multmp4; ret double %addtmp; }. ready> foo(4.0);; Read top-level expression:; define double @3() {; entry:; %calltmp = call double @foo(double 4.000000e+00); ret double %calltmp; }. Evaluated to 1.000000. Whoa, how does the JIT know about sin and cos? The answer is surprisingly; simple: The KaleidoscopeJIT has a straightforward symbol resolution rule that; it uses to find symbols that aren't available in any given module: First; it searches all the modules that have already been added to the JIT, from the; most recent to the oldest, to find the newest definition. If no definition is; found inside the JIT, it falls back to calling ""``dlsym(""sin"")``"" on the; Kaleidoscope process itself. Since ""``sin``"" is defined within the JIT's; address space, it simply patches up calls in the module to call the libm; version of ``sin`` directly. But in some cases this even goes further:; as sin and cos are names of standard math functions, the constant folder; will directly evaluate the function calls to the correct result when called; with constants like in the ""``sin(1.0)``"" above. In the future we'll see how tweaking this symbol resolution rule can be used to; enable all sorts of useful features, from security (restricting the set of; symbols available to JIT'd code), to dynamic code generation based on symbol; names, and even lazy compilation. One immediate benefit of the symbol resolution rule is that we can now extend; the language by writing arbitrary C++ code to implement operations. For example,; if we add:. .. code-block:: c++. #ifdef _WIN32; #define DLLEXPORT __declspec(dllexport); #else; #define DLLEXPORT; #endif. /// putchard - putchar that takes a double and returns 0.; extern ""C"" DLLEXPORT double putchard(double X) {; fputc((char)X, stder",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:23119,simpl,simply,23119,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simply']
Usability,"ould be a; corresponding denormalization step. YAML I/O uses a non-invasive, traits based design. YAML I/O defines some; abstract base templates. You specialize those templates on your data types.; For instance, if you have an enumerated type FooBar you could specialize; ScalarEnumerationTraits on that type and define the enumeration() method:. .. code-block:: c++. using llvm::yaml::ScalarEnumerationTraits;; using llvm::yaml::IO;. template <>; struct ScalarEnumerationTraits<FooBar> {; static void enumeration(IO &io, FooBar &value) {; ...; }; };. As with all YAML I/O template specializations, the ScalarEnumerationTraits is used for; both reading and writing YAML. That is, the mapping between in-memory enum; values and the YAML string representation is only in one place.; This assures that the code for writing and parsing of YAML stays in sync. To specify a YAML mappings, you define a specialization on; llvm::yaml::MappingTraits.; If your native data structure happens to be a struct that is already normalized,; then the specialization is simple. For example:. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. template <>; struct MappingTraits<Person> {; static void mapping(IO &io, Person &info) {; io.mapRequired(""name"", info.name);; io.mapOptional(""hat-size"", info.hatSize);; }; };. A YAML sequence is automatically inferred if you data type has begin()/end(); iterators and a push_back() method. Therefore any of the STL containers; (such as std::vector<>) will automatically translate to YAML sequences. Once you have defined specializations for your data types, you can; programmatically use YAML I/O to write a YAML document:. .. code-block:: c++. using llvm::yaml::Output;. Person tom;; tom.name = ""Tom"";; tom.hatSize = 8;; Person dan;; dan.name = ""Dan"";; dan.hatSize = 7;; std::vector<Person> persons;; persons.push_back(tom);; persons.push_back(dan);. Output yout(llvm::outs());; yout << persons;. This would write the following:. .. code-block:: y",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:3794,simpl,simple,3794,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['simpl'],['simple']
Usability,"ound in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. This pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize generated code. This pass obviously modifies the CFG, but updates loop information and; dominator information. ``loop-unroll``: Unroll loops; -----------------------------. This pass implements a simple loop unroller. It works best when loops have; been canonicalized by the :ref:`indvars <passes-indvars>` pass, allowing it to; determine the trip counts of loops easily. ``loop-unroll-and-jam``: Unroll and Jam loops; ---------------------------------------------. This pass implements a simple unroll and jam classical loop optimisation pass.; It transforms loop from:. .. code-block:: c++. for i.. i+= 1 for i.. i+= 4; for j.. for j..; code(i, j) code(i, j); code(i+1, j); code(i+2, j); code(i+3, j); remainder l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:27456,simpl,simplifies,27456,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplifies']
Usability,"outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher to check if the condition part of the; ``for`` loop compares a variable against the size of the array. There is; only one problem - we don't know which array we're iterating over; without looking at the body of the loop! We are again restricted to; approximating the result we want with matchers, filling in the details; in the callback. So we start with:. .. code-block:: c++. hasCondition(binaryOperator(hasOperatorName(""<""))). It makes sense to ensure that the left-hand side is a reference to a; variable, and that the right-hand side has integer type. .. code-block:: c++. hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(declRefExpr(to(varDecl(hasType(isInteger()))))),; hasRHS(expr(hasType(isInteger()))))). Why? Because it doesn't work. Of the three loops provided in; ``test-files/simple.cpp``, zero of them have a matching condition. A; quick look at the AST dump of the first for loop, produced by the; previous iteration of loop-convert, shows us the answer:. ::. (ForStmt 0x173b240; (DeclStmt 0x173afc8; 0x173af50 ""int i =; (IntegerLiteral 0x173afa8 'int' 0)""); <<>>; (BinaryOperator 0x173b060 '_Bool' '<'; (ImplicitCastExpr 0x173b030 'int'; (DeclRefExpr 0x173afe0 'int' lvalue Var 0x173af50 'i' 'int')); (ImplicitCastExpr 0x173b048 'int'; (DeclRefExpr 0x173b008 'const int' lvalue Var 0x170fa80 'N' 'const int'))); (UnaryOperator 0x173b0b0 'int' lvalue prefix '++'; (DeclRefExpr 0x173b088 'int' lvalue Var 0x173af50 'i' 'int')); (CompoundStatement ... We already know that the declaration and increments both match, or this; loop wouldn't have been dumped. The culprit lies in the implicit cast; applied to the first operand (i.e. the LHS) of the less-than operator,; an L-value to R-value conversion applied to the expression referencing; ``i``. Thankfully",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:14012,simpl,simple,14012,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simple']
Usability,"outine Structure Intrinsics; ------------------------------; Intrinsics described in this section are used within a coroutine to describe; the coroutine structure. They should not be used outside of a coroutine. .. _coro.size:. 'llvm.coro.size' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i32 @llvm.coro.size.i32(); declare i64 @llvm.coro.size.i64(). Overview:; """""""""""""""""". The '``llvm.coro.size``' intrinsic returns the number of bytes; required to store a `coroutine frame`_. This is only supported for; switched-resume coroutines. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The `coro.size` intrinsic is lowered to a constant representing the size of; the coroutine frame. .. _coro.align:. 'llvm.coro.align' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i32 @llvm.coro.align.i32(); declare i64 @llvm.coro.align.i64(). Overview:; """""""""""""""""". The '``llvm.coro.align``' intrinsic returns the alignment of a `coroutine frame`_.; This is only supported for switched-resume coroutines. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The `coro.align` intrinsic is lowered to a constant representing the alignment of; the coroutine frame. .. _coro.begin:. 'llvm.coro.begin' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.begin(token <id>, ptr <mem>). Overview:; """""""""""""""""". The '``llvm.coro.begin``' intrinsic returns an address of the coroutine frame. Arguments:; """""""""""""""""""". The first argument is a token returned by a call to '``llvm.coro.id``'; identifying the coroutine. The second argument is a pointer to a block of memory where coroutine frame; will be stored if it is allocated dynamically. This pointer is ignored; for returned-continuation coroutines. Semantics:; """""""""""""""""""". Depending on the alignment requirements of the objects in the coroutine frame; and/or on the codegen compactness reasons the pointer returned from `coro.begin`; may be at offset to the `%mem` argument. (This could be beneficial if; in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:32136,resume,resume,32136,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"outu.be/C5Y977rLqpw. A good way for new contributors to increase their knowledge of the code base is; to review code. It is perfectly acceptable to review code and explicitly; defer to others for approval decisions. Experts Should Review Code; --------------------------. If you are an expert in an area of the compiler affected by a proposed patch,; then you are highly encouraged to review the code. If you are a relevant code; owner, and no other experts are reviewing a patch, you must either help arrange; for an expert to review the patch or review it yourself. Code Reviews, Speed, and Reciprocity; ------------------------------------. Sometimes code reviews will take longer than you might hope, especially for; larger features. Common ways to speed up review times for your patches are:. * Review other people's patches. If you help out, everybody will be more; willing to do the same for you; goodwill is our currency.; * Ping the patch. If it is urgent, provide reasons why it is important to you to; get this patch landed and ping it every couple of days. If it is; not urgent, the common courtesy ping rate is one week. Remember that you're; asking for valuable time from other professional developers.; * Ask for help on IRC. Developers on IRC will be able to either help you; directly, or tell you who might be a good reviewer.; * Split your patch into multiple smaller patches that build on each other. The; smaller your patch is, the higher the probability that somebody will take a quick; look at it. When doing this, it is helpful to add ""[N/M]"" (for 1 <= N <= M) to; the title of each patch in the series, so it is clear that there is an order; and what that order is. Developers should participate in code reviews as both reviewers and; authors. If someone is kind enough to review your code, you should return the; favor for someone else. Note that anyone is welcome to review and give feedback; on a patch, but approval of patches should be consistent with the policy above.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:12387,clear,clear,12387,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,2,"['clear', 'feedback']","['clear', 'feedback']"
Usability,"ovl	$0x7, -0x4(%rbp)'; [004] {Code} 'jmp	0x6'; [004] 8 {Line}; [004] {Code} 'movl	-0x14(%rbp), %eax'; [003] 4 {TypeAlias} 'INTEGER' -> 'int'; [003] 2 {Line}; [003] {Code} 'pushq	%rbp'; [003] {Code} 'movq	%rsp, %rbp'; [003] {Code} 'movb	%dl, %al'; [003] {Code} 'movq	%rdi, -0x10(%rbp)'; [003] {Code} 'movl	%esi, -0x14(%rbp)'; [003] {Code} 'andb	$0x1, %al'; [003] {Code} 'movb	%al, -0x15(%rbp)'; [003] 3 {Line}; [003] {Code} 'testb	$0x1, -0x15(%rbp)'; [003] {Code} 'je	0x13'; [003] 8 {Line}; [003] {Code} 'movl	%eax, -0x4(%rbp)'; [003] 9 {Line}; [003] {Code} 'movl	-0x4(%rbp), %eax'; [003] {Code} 'popq	%rbp'; [003] {Code} 'retq'; [003] 9 {Line}; [002] 1 {TypeAlias} 'INTPTR' -> '* const int'. On closer inspection, we can see what could be a potential debug issue:. .. code-block:: none. [003] {Block}; [003] 4 {TypeAlias} 'INTEGER' -> 'int'. The **'INTEGER'** definition is at level **[003]**, the same lexical; scope as the anonymous **{Block}** ('true' branch for the 'if' statement); whereas in the original source code the typedef statement is clearly; inside that block, so the **'INTEGER'** definition should also be at; level **[004]** inside the block. SELECT LOGICAL ELEMENTS; """"""""""""""""""""""""""""""""""""""""""""""; The following prints all *instructions*, *symbols* and *types* that; contain **'inte'** or **'movl'** in their names or types, using a tab; layout and given the number of matches. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level; --select-nocase --select-regex; --select=INTe --select=movl; --report=list; --print=symbols,types,instructions,summary; test-dwarf-clang.o. Logical View:; [000] {File} 'test-dwarf-clang.o'. [001] {CompileUnit} 'test.cpp'; [003] {Code} 'movl	$0x7, -0x1c(%rbp)'; [003] {Code} 'movl	$0x7, -0x4(%rbp)'; [003] {Code} 'movl	%eax, -0x4(%rbp)'; [003] {Code} 'movl	%esi, -0x14(%rbp)'; [003] {Code} 'movl	-0x14(%rbp), %eax'; [003] {Code} 'movl	-0x4(%rbp), %eax'; [003] 4 {TypeAlias} 'INTEGER' -> 'int'; [004] 5 {Variable} 'CONSTANT' -> 'const INTEGER'. --",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:26805,clear,clearly,26805,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['clear'],['clearly']
Usability,"owed by appendix; :ref:`amdgpu-dwarf-changes-relative-to-dwarf-version-5` which contains the; textual changes for the extensions relative to the DWARF Version 5 standard.; There are a number of notes included that raise open questions, or provide; alternative approaches that may be worth considering. Then appendix; :ref:`amdgpu-dwarf-further-examples` links to the AMD GPU specific usage of the; extensions that includes an example. Finally, appendix; :ref:`amdgpu-dwarf-references` provides references to further information. .. _amdgpu-dwarf-extensions:. 2. Extensions; =============. The extensions continue to evolve through collaboration with many individuals and; active prototyping within the GDB debugger and LLVM compiler. Input has also; been very much appreciated from the developers working on the Perforce TotalView; HPC Debugger and GCC compiler. The inputs provided and insights gained so far have been incorporated into this; current version. The plan is to participate in upstreaming the work and; addressing any feedback. If there is general interest then some or all of these; extensions could be submitted as future DWARF standard proposals. The general principles in designing the extensions have been:. 1. Be backwards compatible with the DWARF Version 5 [:ref:`DWARF; <amdgpu-dwarf-DWARF>`] standard. 2. Be vendor and architecture neutral. They are intended to apply to other; heterogeneous hardware devices including GPUs, DSPs, FPGAs, and other; specialized hardware. These collectively include similar characteristics and; requirements as AMDGPU devices. 3. Provide improved optimization support for non-GPU code. For example, some; extensions apply to traditional CPU hardware that supports large vector; registers. Compilers can map source languages, and source language; extensions, that describe large scale parallel execution, onto the lanes of; the vector registers. This is common in programming languages used in ML and; HPC. 4. Fully define well-formed DWARF in a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:3632,feedback,feedback,3632,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['feedback'],['feedback']
Usability,"own code to generate hierarchical structure in HTML, replace dtree.js which is; extremely slow for complex hierarchies. Dramatically improve performance for; structures with large (~1000) number of items.; 19. Deliver to the server title of the objects, display it as hint in the browser.; 20. Better handling of special characters in the hierarchies - allows to display; symbols like ' or "" in the file structure. ### July 2014; 1. Migration to d3.v3.js and jQuery v2.1.1; 2. Fix errors in filling of histogram statbox; 3. Possibility of move and resize of statbox, title, color palete; 4. Remove many (not all) global variables; 5. Example with direct usage of JSRootIO graphics; 6. Example of inserting ROOT graphics from THttpServer into `<iframe></iframe>`. ### May 2014; 1. This JSRootIO code together with THttpServer class included; in ROOT repository. ### March 2014; 1. Introduce TBuffer class, which plays similar role; as TBuffer in native ROOT I/O. Simplifies I/O logic,; reduce duplication of code in many places, fix errors.; Main advantage - one could try to keep code synchronous with C++.; 2. Avoid objects cloning when object referenced several times.; 3. Treat special cases (collection, arrays) in one place.; This is major advantage, while any new classes need to be implemented only once.; 4. Object representation, produced by JSRootIO is similar to; objects, produced by TBufferJSON class. By this one can exchange; I/O engine and use same JavaSctript graphic for display.; 5. More clear functions to display different elements of the file.; In the future functions should be fully separated from I/O part; and organized in similar way as online part.; 6. Eliminate usage of gFile pointer in the I/O part.; 7. Provide TBufferJSON::JsonWriteMember method. It allows to stream any; selected data member of the class. Supported are:; basic data types, arrays of basic data types, TString, TArray classes.; Also any object as data member can be streamed.; 8. TRootSniffer do not ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:76949,Simpl,Simplifies,76949,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['Simpl'],['Simplifies']
Usability,"ows example reStructuredText markup constructs; that are meant to be read by you in your text editor after you have copied; this file into a new file for the documentation you are about to write. Example Section; ===============. An article can contain one or more sections (i.e., headings). Sections (like ``Example Section`` above) help give your document its; structure. Use the same kind of adornments (e.g. ``======`` vs. ``------``); as are used in this document. The adornment must be the same length as the; text above it. For Vim users, variations of ``yypVr=`` might be handy. Example Nested Subsection; -------------------------. Subsections can also be nested beneath other subsections. For more information on sections, see Sphinx's `reStructuredText Primer`_. .. _`reStructuredText Primer`: http://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html#sections. Text Formatting; ===============. Text can be *emphasized*, **bold**, or ``monospace``. To create a new paragraph, simply insert a blank line. Links; =====. You can format a link `like this <https://llvm.org/>`_. A more `sophisticated syntax`_ allows you to place the ``.. _`link text`: <URL>`` block; pretty much anywhere else in the document. This is useful when linking to especially long URLs. .. _`sophisticated syntax`: http://en.wikipedia.org/wiki/LLVM. Lists; =====. restructuredText allows you to create ordered lists... #. A list starting with ``#.`` will be automatically numbered. #. This is a second list element. #. Use indentation to create nested lists. ...as well as unordered lists:. * Stuff. + Deeper stuff. * More stuff. Code Blocks; ===========. You can make blocks of code like this:. .. code-block:: c++. int main() {; return 0;; }. For a shell session, use a ``console`` code block (some existing docs use; ``bash``):. .. code-block:: console. $ echo ""Goodbye cruel world!""; $ rm -rf /. If you need to show LLVM IR use the ``llvm`` code block. .. code-block:: llvm. define i32 @test1() {; en",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst:3800,simpl,simply,3800,interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst,1,['simpl'],['simply']
Usability,"ows other language translations to; substitute reasonable words (or entire phrases) based on the semantics of the; diagnostic instead of having to do things textually. The selected string; does undergo formatting. **""plural"" format**. Example:; ``""you have %0 %plural{1:mouse|:mice}0 connected to your computer""``; Class:; Integers; Description:; This is a formatter for complex plural forms. It is designed to handle even; the requirements of languages with very complex plural forms, as many Baltic; languages have. The argument consists of a series of expression/form pairs,; separated by "":"", where the first form whose expression evaluates to true is; the result of the modifier. An expression can be empty, in which case it is always true. See the example; at the top. Otherwise, it is a series of one or more numeric conditions,; separated by "","". If any condition matches, the expression matches. Each; numeric condition can take one of three forms. * number: A simple decimal number matches if the argument is the same as the; number. Example: ``""%plural{1:mouse|:mice}0""``; * range: A range in square brackets matches if the argument is within the; range. Then range is inclusive on both ends. Example:; ``""%plural{0:none|1:one|[2,5]:some|:many}0""``; * modulo: A modulo operator is followed by a number, and equals sign and; either a number or a range. The tests are the same as for plain numbers; and ranges, but the argument is taken modulo the number first. Example:; ``""%plural{%100=0:even hundred|%100=[1,50]:lower half|:everything else}1""``. The parser is very unforgiving. A syntax error, even whitespace, will abort,; as will a failure to match the argument against any expression. **""ordinal"" format**. Example:; ``""ambiguity in %ordinal0 argument""``; Class:; Integers; Description:; This is a formatter which represents the argument number as an ordinal: the; value ``1`` becomes ``1st``, ``3`` becomes ``3rd``, and so on. Values less; than ``1`` are not supported. This formatter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:12627,simpl,simple,12627,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"owto:errordef]) should be $1.0$. If the $\mbox{FCN}$; is a negative-log-likelihood function, then the one-standard-deviation; value for FCNBase::up() to return is $0.5$. If the $\mbox{FCN}$ is a; chisquare, but the user wants two-standard-deviation errors, then; FCNBase::up() should return $= 4.0$, etc. Note that in the usual case where M is being used to perform a fit to; some experimental data, the parameter errors will be proportional to the; uncertainty in the data, and therefore meaningful parameter errors; cannot be obtained unless the measurement errors of the data are known.; In the common case of a least-squares fit, $\mbox{FCN}$ is usually; defined as a chisquare:. $$\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}$$. where $\alpha$ is the vector of free parameters being fitted, and the; $\sigma_i$ are the uncertainties in the individual measurements $m_i$.; If these uncertainties are not known, and are simply left out of the; calculation, then the fit may still have meaning, but not the; quantitative values of the resulting parameter errors. (Only the; relative errors of different parameters with respect to each other may; be meaningful.). If the $\sigma_i$ are all overestimated by a factor $\beta$, then the; resulting parameter errors from the fit will be overestimated by the; same factor $\beta$. ### The error matrix ###. The M processors $\mbox{MIGRAD}$ (MnMigrad, see [api:migrad]) and; HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix.; This matrix is twice the inverse of the matrix of second derivatives of; the $\mbox{FCN}$, transformed if necessary into external coordinate; space[^2], and multiplied by FCNBase::up(). Therefore, errors based on; the M error matrix take account of all the parameter correlations, but; not the non-linearities. That is, from the error matrix alone,; two-standard-deviation errors are always exactly twice as big as; one-standard-deviation errors. When the error matrix has been ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:14963,simpl,simply,14963,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['simpl'],['simply']
Usability,"ozilla.org/en/http_access_control). Alternative - enable CORS requests in the browser. It can be easily done with [CORS Everywhere plugin](https://addons.mozilla.org/de/firefox/addon/cors-everywhere/) for the Firefox browser or [Allow CORS plugin](https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?hl=en) for the Chrome browser. Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to `modules/gui.mjs` script like:. ```javascript; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; ```. In the main `<div>` element one can specify many custom parameters like one do it in URL string:. ```html; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; ```. ## Reading local ROOT files. JSROOT can read files from local file system using HTML5 FileReader functionality.; Main limitation here - user should interactively select files for reading.; There is button __""...""__ on the main JSROOT page, which starts file selection dialog.; If valid ROOT file is selected, JSROOT will be able to normally read content of such file. ## JSROOT with THttpServer. THttpServer provides http access to objects from running ROOT application.; JSROOT is used to implement the user interface in the web browsers. The layout of the main page coming from THttpServer is very similar to normal JSROOT page.; One could browse existing items and display them. A snapshot of running; server can be seen on the [demo page](https://root.cern/js/latest/httpserver.C/). One could also specify similar URL parameters to configure the displayed items and drawing options. It is also possibl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:29267,simpl,simpleGUI,29267,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['simpl'],['simpleGUI']
Usability,"p and therefore must; be saved by the runtime. This is an important optimization when the; patchpoint intrinsic is used with a calling convention that by default; preserves most registers as callee-save. Each entry in the liveout register list contains a DWARF register; number and size in bytes. The stackmap format deliberately omits; specific subregister information. Instead the runtime must interpret; this information conservatively. For example, if the stackmap reports; one byte at ``%rax``, then the value may be in either ``%al`` or; ``%ah``. It doesn't matter in practice, because the runtime will; simply save ``%rax``. However, if the stackmap reports 16 bytes at; ``%ymm0``, then the runtime can safely optimize by saving only; ``%xmm0``. The stack map format is a contract between an LLVM SVN revision and; the runtime. It is currently experimental and may change in the short; term, but minimizing the need to update the runtime is; important. Consequently, the stack map design is motivated by; simplicity and extensibility. Compactness of the representation is; secondary because the runtime is expected to parse the data; immediately after compiling a module and encode the information in its; own format. Since the runtime controls the allocation of sections, it; can reuse the same stack map space for multiple modules. Stackmap support is currently only implemented for 64-bit; platforms. However, a 32-bit implementation should be able to use the; same format with an insignificant amount of wasted space. .. _stackmap-section:. Stack Map Section; ^^^^^^^^^^^^^^^^^. A JIT compiler can easily access this section by providing its own; memory manager via the LLVM C API; ``LLVMCreateSimpleMCJITMemoryManager()``. When creating the memory; manager, the JIT provides a callback:; ``LLVMMemoryManagerAllocateDataSectionCallback()``. When LLVM creates; this section, it invokes the callback and passes the section name. The; JIT can record the in-memory address of the section at th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:15593,simpl,simplicity,15593,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['simpl'],['simplicity']
Usability,"p bitcode; generation and optimization completely disjoint. Bit-for-bit compatibility is not (and never was) a guarantee, and we reserve; the right to change this at any time. Explicitly, users should not rely on; the produced bitcode or object code to match their non-LTO counterparts; precisely. They will exhibit similar performance characteristics, but may; not be bit-for-bit the same. Internally, the ``.llvm.lto`` section is created by running the; ``EmbedBitcodePass`` after the ``ThinLTOPreLinkDefaultPipeline``. This pass is; responsible for emitting the ``.llvm.lto`` section. Afterwards, the; ``ThinLTODefaultPipeline`` runs and the compiler can emit the fat object file. Limitations; ===========. Linkers; -------. Currently, using LTO with LLVM fat lto objects is supported by LLD and by the; GNU linkers via :doc:`GoldPlugin`. This may change in the future, but; extending support to other linkers isn't planned for now. .. NOTE; For standard linking the fat object files should be usable by any; linker capable of using ELF objects, since the ``.llvm.lto`` section is; marked ``SHF_EXCLUDE``. Supported File Formats; ----------------------. The current implementation only supports ELF files. At time of writing, it is; unclear if it will be useful to support other object file formats like ``COFF``; or ``Mach-O``. Usage; =====. Clang users can specify ``-ffat-lto-objects`` with ``-flto`` or ``-flto=thin``.; Without the ``-flto`` option, ``-ffat-lto-objects`` has no effect. Compile an object file using FatLTO:. .. code-block:: console. $ clang -flto -ffat-lto-objects example.c -c -o example.o. Link using the object code from the fat object without LTO. This turns; ``-ffat-lto-objects`` into a no-op, when ``-fno-lto`` is specified:. .. code-block:: console. $ clang -fno-lto -ffat-lto-objects -fuse-ld=lld example.o. Alternatively, you can omit any references to LTO with fat objects and retain standard linker behavior:. .. code-block:: console. $ clang -fuse-ld=lld example.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FatLTO.rst:2590,usab,usable,2590,interpreter/llvm-project/llvm/docs/FatLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FatLTO.rst,1,['usab'],['usable']
Usability,"p bug-trigger.ll -o test.mir``. If the same pass is run multiple times, a run index can be included; after the name with a comma. ``llc -stop-after=dead-mi-elimination,1 bug-trigger.ll -o test.mir``. After generating the input MIR file, you'll have to add a run line that uses; the ``-run-pass`` option to it. In order to test the post register allocation; pseudo instruction expansion pass on X86-64, a run line like the one shown; below can be used:. ``# RUN: llc -o - %s -mtriple=x86_64-- -run-pass=postrapseudos | FileCheck %s``. The MIR files are target dependent, so they have to be placed in the target; specific test directories (``lib/CodeGen/TARGETNAME``). They also need to; specify a target triple or a target architecture either in the run line or in; the embedded LLVM IR module. Simplifying MIR files; ^^^^^^^^^^^^^^^^^^^^^. The MIR code coming out of ``-stop-after``/``-stop-before`` is very verbose;; Tests are more accessible and future proof when simplified:. - Use the ``-simplify-mir`` option with llc. - Machine function attributes often have default values or the test works just; as well with default values. Typical candidates for this are: `alignment:`,; `exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing later passes.; The per-block `liveins:` on the other hand are necessary if; `tracksRegLiveness` is true. - Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, %bb.2`. - MIR code contains a whole IR module. This is necessary because there are; no equiv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:3162,simpl,simplify-mir,3162,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['simpl'],['simplify-mir']
Usability,"p', etc in; # c++xx mode.; set(CMAKE_CXX_EXTENSIONS YES); else(); set(CMAKE_CXX_EXTENSIONS NO); endif(). if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES); message(FATAL_ERROR ""; No build type selected. You need to pass -DCMAKE_BUILD_TYPE=<type> in order to configure LLVM.; Available options are:; * -DCMAKE_BUILD_TYPE=Release - For an optimized build with no assertions or debug info.; * -DCMAKE_BUILD_TYPE=Debug - For an unoptimized build with assertions and debug info.; * -DCMAKE_BUILD_TYPE=RelWithDebInfo - For an optimized build with no assertions but with debug info.; * -DCMAKE_BUILD_TYPE=MinSizeRel - For a build optimized for size instead of speed.; Learn more about these options in our documentation at https://llvm.org/docs/CMake.html#cmake-build-type; ""); endif(). # Set default build type for cmake's try_compile module.; # CMake 3.17 or newer sets CMAKE_DEFAULT_BUILD_TYPE to one of the; # items from CMAKE_CONFIGURATION_TYPES. Logic below can be further; # simplified once LLVM's minimum CMake version is updated to 3.17.; if(CMAKE_DEFAULT_BUILD_TYPE); set(CMAKE_TRY_COMPILE_CONFIGURATION ${CMAKE_DEFAULT_BUILD_TYPE}); else(); if(CMAKE_CONFIGURATION_TYPES); list(GET CMAKE_CONFIGURATION_TYPES 0 CMAKE_TRY_COMPILE_CONFIGURATION); elseif(CMAKE_BUILD_TYPE); set(CMAKE_TRY_COMPILE_CONFIGURATION ${CMAKE_BUILD_TYPE}); endif(); endif(). # Side-by-side subprojects layout: automatically set the; # LLVM_EXTERNAL_${project}_SOURCE_DIR using LLVM_ALL_PROJECTS; # This allows an easy way of setting up a build directory for llvm and another; # one for llvm+clang+... using the same sources.; set(LLVM_ALL_PROJECTS ""bolt;clang;clang-tools-extra;compiler-rt;cross-project-tests;libc;libclc;lld;lldb;mlir;openmp;polly;pstl""); # The flang project is not yet part of ""all"" projects (see C++ requirements); set(LLVM_EXTRA_PROJECTS ""flang""); # List of all known projects in the mono repo; set(LLVM_KNOWN_PROJECTS ""${LLVM_ALL_PROJECTS};${LLVM_EXTRA_PROJECTS}""); set(LLVM_ENABLE_PROJECTS """" ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:4659,simpl,simplified,4659,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['simpl'],['simplified']
Usability,"p; <writing-an-llvm-pass-runOnLoop>` for every loop in the program being compiled. .. _writing-an-llvm-pass-RegionPass:. The ``RegionPass`` class; ------------------------. ``RegionPass`` is similar to :ref:`LoopPass <writing-an-llvm-pass-LoopPass>`,; but executes on each single entry single exit region in the function.; ``RegionPass`` processes regions in nested order such that the outer most; region is processed last. ``RegionPass`` subclasses are allowed to update the region tree by using the; ``RGPassManager`` interface. You may override three virtual methods of; ``RegionPass`` to implement your own region pass. All these methods should; return ``true`` if they modified the program, or ``false`` if they did not. The ``doInitialization(Region *, RGPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Region *, RGPassManager &RGM);. The ``doInitialization`` method is designed to do simple initialization type of; stuff that does not depend on the functions being processed. The; ``doInitialization`` method call is not scheduled to overlap with any other; pass executions (thus it should be very fast). ``RPPassManager`` interface; should be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnRegion:. The ``runOnRegion`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnRegion(Region *, RGPassManager &RGM) = 0;. The ``runOnRegion`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a true value should be; returned if the region is modified. ``RGPassManager`` interface should be used to; update region tree. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnReg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:23550,simpl,simple,23550,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,p; llvm/lib/ExecutionEngine/Orc/IRTransformLayer.cpp; llvm/lib/ExecutionEngine/Orc/Layer.cpp; llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp; llvm/lib/ExecutionEngine/Orc/LookupAndRecordAddrs.cpp; llvm/lib/ExecutionEngine/Orc/Mangling.cpp; llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp; llvm/lib/ExecutionEngine/Orc/ObjectTransformLayer.cpp; llvm/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp; llvm/lib/ExecutionEngine/Orc/Speculation.cpp; llvm/lib/ExecutionEngine/Orc/TaskDispatch.cpp; llvm/lib/ExecutionEngine/Orc/Shared/AllocationActions.cpp; llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp; llvm/lib/ExecutionEngine/Orc/Shared/OrcRTBridge.cpp; llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/OrcRTBootstrap.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/OrcRTBootstrap.h; llvm/lib/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorDylibManager.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/TargetExecutionUtils.cpp; llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldCOFF.h; llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h; llvm/lib/FileCheck/FileCheckImpl.h; llvm/lib/Frontend/OpenACC/ACC.cpp; llvm/lib/Frontend/OpenMP/OMP.cpp; llvm/lib/Frontend/OpenMP/OMPContext.cpp; llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp; llvm/lib/FuzzMutate/OpDescriptor.cpp; llvm/lib/FuzzMutate/RandomIRBuilder.cpp; llvm/lib/InterfaceStub/ELFObjHandler.cpp; llvm/lib/InterfaceStub/IFSHandler.cpp; llvm/lib/InterfaceStub/IFSStub.cpp; llvm/lib/IR/Assumptions.cpp; llvm/lib/IR/Comdat.cpp; llvm/lib/IR/DebugInfoMetadata.cpp; llvm/lib/IR/DebugLoc.cpp; llvm/lib/IR/DIBuilder.cpp; llvm/lib/IR/FPEnv.cpp; llvm/lib/IR/GCStrategy.cpp; llvm/lib/IR/GVMaterializer.cpp; llvm/lib/IR/LLVMContextImpl.h; llvm/lib/IR/MetadataImpl.h; llvm/lib/IR/OptBis,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:288392,Simpl,SimpleExecutorDylibManager,288392,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimpleExecutorDylibManager']
Usability,pLoadElimination.h; llvm/include/llvm/Transforms/Scalar/LoopPredication.h; llvm/include/llvm/Transforms/Scalar/LoopReroll.h; llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h; llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h; llvm/include/llvm/Transforms/Scalar/LoopUnrollAndJamPass.h; llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h; llvm/include/llvm/Transforms/Scalar/LoopVersioningLICM.h; llvm/include/llvm/Transforms/Scalar/LowerMatrixIntrinsics.h; llvm/include/llvm/Transforms/Scalar/MakeGuardsExplicit.h; llvm/include/llvm/Transforms/Scalar/MemCpyOptimizer.h; llvm/include/llvm/Transforms/Scalar/NaryReassociate.h; llvm/include/llvm/Transforms/Scalar/Reassociate.h; llvm/include/llvm/Transforms/Scalar/Reg2Mem.h; llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h; llvm/include/llvm/Transforms/Scalar/ScalarizeMaskedMemIntrin.h; llvm/include/llvm/Transforms/Scalar/SCCP.h; llvm/include/llvm/Transforms/Scalar/SeparateConstOffsetFromGEP.h; llvm/include/llvm/Transforms/Scalar/SimpleLoopUnswitch.h; llvm/include/llvm/Transforms/Scalar/StraightLineStrengthReduce.h; llvm/include/llvm/Transforms/Scalar/StructurizeCFG.h; llvm/include/llvm/Transforms/Scalar/WarnMissedTransforms.h; llvm/include/llvm/Transforms/Utils/AddDiscriminators.h; llvm/include/llvm/Transforms/Utils/AMDGPUEmitPrintf.h; llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h; llvm/include/llvm/Transforms/Utils/BreakCriticalEdges.h; llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h; llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h; llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h; llvm/include/llvm/Transforms/Utils/CanonicalizeAliases.h; llvm/include/llvm/Transforms/Utils/CanonicalizeFreezeInLoops.h; llvm/include/llvm/Transforms/Utils/CodeLayout.h; llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h; llvm/include/llvm/Transforms/Utils/Debugify.h; llvm/include/llvm/Transforms/Utils/EntryExitInstrumenter.h; llvm/include/llvm/Transforms/Utils/FixIrreducible.h; llvm/incl,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:269572,Simpl,SimpleLoopUnswitch,269572,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimpleLoopUnswitch']
Usability,"pSet::kClipPlane, planeEq);; ```. As with cameras, any clip can be configured at any time, but you must; set the clip current to see the effect. #### Manipulators. *Manipulators* are GUI ‘widgets' or controls attached to a 3D object in; the viewer, allowing a direct manipulation of the object's geometry.; There are three manipulators for the three basic geometries; transformations. In each case, the *manipulator* consists of three; components, one for each local axis of the object, shown in standard; colors: red (X), green (Y) and blue (Z). ![GL Viewer object manipulators](pictures/030000DE.png). Activate the *manipulator* by moving the mouse over one of these; components (which turns yellow to indicate active state). Click with; left mouse and drag this active component to perform the manipulation.; Toggle between the *manipulator* types using the ‘x', ‘c', ‘v' keys; while the mouse cursor is above the manipulator. Note: Manipulators; cannot be controlled via the API at present. #### Guides. Guides are visual aids drawn into the viewer world. Controls for these; are under the ""Guides"" tab:. Viewer Controls Pane Guides Tab. Axes show the world (global) frame *coordinate*directions: X (red), Y; (green) and Z (blue). The negative portion of the *axis* line is shown; in dark color, the positive in bright. The *axis* name and minimum /; maximum values are labeled in the same color. There are three options; for *axes* drawing - selected by radio buttons:. - None - not drawn (default). - Edge - draw axes on the (minimum) edge of the scene extents box. - Origin - drawn axes through the origin. For *edge axes*, the zero value for each axis is marked on the axis line; with a colored sphere. For *origin axes,* a single white sphere is shown; at the origin. *Edge axes* are depth clipped - i.e. are obscured by 3D objects in front; of them. *Origin axes* (which generally pass through the middle of the; 3D scene) are not depth clipped - so always visible. A single orange sphere of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:116967,Guid,Guides,116967,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['Guid'],['Guides']
Usability,"pace llvm;; int llvm::foo(const char *s) {; // ...; }. Doing this helps to avoid bugs where the definition does not match the; declaration from the header. For example, the following C++ code defines a new; overload of ``llvm::foo`` instead of providing a definition for the existing; function declared in the header:. .. code-block:: c++. // Foo.cpp; #include ""Foo.h""; namespace llvm {; int foo(char *s) { // Mismatch between ""const char *"" and ""char *""; }; } // namespace llvm. This error will not be caught until the build is nearly complete, when the; linker fails to find a definition for any uses of the original function. If the; function were instead defined with a namespace qualifier, the error would have; been caught immediately when the definition was compiled. Class method implementations must already name the class and new overloads; cannot be introduced out of line, so this recommendation does not apply to them. .. _early exits:. Use Early Exits and ``continue`` to Simplify Code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When reading code, keep in mind how much state and how many previous decisions; have to be remembered by the reader to understand a block of code. Aim to; reduce indentation where possible when it doesn't make it more difficult to; understand the code. One great way to do this is by making use of early exits; and the ``continue`` keyword in long loops. Consider this code that does not; use an early exit:. .. code-block:: c++. Value *doSomething(Instruction *I) {; if (!I->isTerminator() &&; I->hasOneUse() && doOtherThing(I)) {; ... some long code ....; }. return 0;; }. This code has several problems if the body of the ``'if'`` is large. When; you're looking at the top of the function, it isn't immediately clear that this; *only* does interesting things with non-terminator instructions, and only; applies to things with the other predicates. Second, it is relatively difficult; to describe (in comments) why these predicates are important ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:35232,Simpl,Simplify,35232,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['Simpl'],['Simplify']
Usability,"pad in this; picture illustrates the **`THStack`** drawn with the `""nostack""`; option. ``` {.cpp}; hs->Draw(""nostack"");; ```. Next is a simple example, for a more complex one see; `$ROOTSYS/tutorials/hist/hstack.C.`. ``` {.cpp}; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; ```. ## TH2Poly. `TH2Poly` is a 2D Histogram class allowing to define polygonal bins of; arbitrary shape. Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; `TH2PolyBin` is a very simple class containing the vertices and; contents of the polygonal bin as well as several related functions. Bins are defined using one of the `AddBin()` methods. The bin; definition should be done before filling. The following very simple macro shows how to build and fill a; `TH2Poly`:. ``` {.cpp}; {; TH2Poly *h2p = new TH2Poly();; Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};; h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);; h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }; ```. More examples can bin found in `$ROOTSYS/tutorials/hist/th2poly*.C`. ![A TH2Poly histogram example](pictures/th2poly1.png). ## Profile Histograms. Profile histograms are in many cases an elegant replacement of; two-dimensional histograms. The relationship of two quantiti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:60418,simpl,simple,60418,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['simpl'],['simple']
Usability,"pared to its standard deviations.; Therefore it is necessary to pass a parameter of sigma to the peak; searching function. The algorithm is selective to the peaks with a; given sigma. The form of the basic peak searching function is. ```{.cpp}; Int_t Search1(const float *spectrum,; int size,; double sigma);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into structure pointed by; `one_dim_peak` structure pointer. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`p`**: pointer to the `one_dim_peak` structure pointer; - **`size`**: length of the source spectrum; - **`sigma`**: sigma of searched peaks. The `one_dim_peak` structure has the form of. ```{.cpp}; struct one_dim_peak{; int number_of_peaks;; double position[MAX_NUMBER_OF_PEAKS1];; };; ```. An example of simple one-dimensional spectrum with identified peaks is; given in Figure 3.1. ![Simple one-dimensional spectrum with identified peaks](figures/image058.png). An example of 1-dimensional experimental spectrum with many identified; peaks is given in Figure 3.2. ![1-dimensional experimental spectrum with many identified peaks](figures/image060.png). However, when we have noisy data, the number of peaks can be enormous. One; such an example is given in Figure 3.3. ![With noisy data the number of peaks can be enormous](figures/image062.png). Therefore it can be useful to have a possibility to set a threshold value and to consider only the peaks higher than this threshold (see Figure 3.4, only three peaks were identified, threshold=50). The value in the center of the peak (`value[i]`) minus the average value in two symmetrically positioned channels (channels `i-3*sigma`, `i+3*sigma`) must be greater than threshold.; Otherwise the peak is ignored. ![Iwth threshold=50, only three peaks were identified](figures/image064.png). An alternative approach was proposed in [6]. The algorithm generates; new invarian",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:17728,Simpl,Simple,17728,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['Simpl'],['Simple']
Usability,"parent function; address. With the ``list=<arg>`` option, a file containing the subset of basic blocks; that need to placed in unique sections can be specified. The format of the; file is as follows. For example, ``list=spec.txt`` where ``spec.txt`` is the; following:. ::. !foo; !!2; !_Z3barv. will place the machine basic block with ``id 2`` in function ``foo`` in a; unique section. It will also place all basic blocks of functions ``bar``; in unique sections. Further, section clusters can also be specified using the ``list=<arg>``; option. For example, ``list=spec.txt`` where ``spec.txt`` contains:. ::. !foo; !!1 !!3 !!5; !!2 !!4 !!6. will create two unique sections for function ``foo`` with the first; containing the odd numbered basic blocks and the second containing the; even numbered basic blocks. Basic block sections allow the linker to reorder basic blocks and enables; link-time optimizations like whole program inter-procedural basic block; reordering. Profile Guided Optimization; ---------------------------. Profile information enables better optimization. For example, knowing that a; branch is taken very frequently helps the compiler make better decisions when; ordering basic blocks. Knowing that a function ``foo`` is called more; frequently than another function ``bar`` helps the inliner. Optimization; levels ``-O2`` and above are recommended for use of profile guided optimization. Clang supports profile guided optimization with two different kinds of; profiling. A sampling profiler can generate a profile with very low runtime; overhead, or you can build an instrumented version of the code that collects; more detailed profile information. Both kinds of profiles can provide execution; counts for instructions in the code and information on branches taken and; function invocation. Regardless of which kind of profiling you use, be careful to collect profiles; by running your code with inputs that are representative of the typical; behavior. Code that is not exer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:89566,Guid,Guided,89566,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['Guid'],['Guided']
Usability,"partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<Decl>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Decl>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Decl>isImplicit; Matches an entity that has been implicitly added by the compiler (e.g.; implicit default/copy constructors). Matcher<Decl>isInAnonymousNamespace; Matches declarations in an anonymous namespace. Given; class vector {};; namespace foo {; class vector {};; namespace {; class vector {}; // #1; }; }; namespace {; class vector {}; // #2; namespace foo {; class vector{}; // #3; }; }; cxxRecordDecl(hasName(""vector""), isInAnonymousNamespace()) will match; #1, #2 and #3. Matcher<Decl>isInStdNamespace; Matches declarations in the namespace `std`, but not in nested namespaces. Given; class vector {};; namespace foo {; class vector {};; namespace std {; class vector {};; }; }; namespace std {; inline namespace __1 {; class vector {}; // #1; namespace experimental {; class vector {};; }; }; }; cxxRecordDecl(hasName(""vector""), isInStdNamespace()) will match only #1. Matcher<Decl>isInstantiated; Matches declarations that are template instantiation",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:83285,Usab,Usable,83285,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<Stmt>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Stmt>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Stmt>isInTemplateInstantiation; Matches statements inside of a template instantiation. Given; int j;; template<typename T> void A(T t) { T i; j += 42;}; A(0);; A(0U);; declStmt(isInTemplateInstantiation()); matches 'int i;' and 'unsigned i'.; unless(stmt(isInTemplateInstantiation())); will NOT match j += 42; as it's shared between the template definition and; instantiation. Matcher<StringLiteral>hasSizeunsigned N; Matches nodes that have the specified size. Given; int a[42];; int b[2 * 21];; int c[41], d[43];; char *s = ""abcd"";; wchar_t *ws = L""abcd"";; char *w = ""a"";; constantArrayType(hasSize(42)); matches ""int a[42]"" and ""int b[2 * 21]""; stringLiteral(hasSize(4)); matches ""abcd"", L""abcd"". Matcher<TagDecl>isClass; Matches TagDecl object that are spelled with ""class."". Example matches C, but not S, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isDefinition; Matches if a declaration has a body attached. Example matches",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:116660,Usab,Usable,116660,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"pdated in web browser, using THttpServer monitoring capability like histogram objects. ## Tutorials; - Add the ""Legacy"" category collecting the old tutorials which do not represent any more best practices. ## Class Reference Guide; - Images in tutorials can now be displayed à JavaScript thanks to the (js) option; added next to the directive `\macro_image`; - As the tutorial `palettes.C` is often hit when searching the keyword `palette`; in the reference guide, a direct link from this example to the full list of; predefined palettes given in `TColor` has been added.; - Revisited the TSpectrum2 documentation. All the static images have been replaced; by macros generating images at reference guide build time. These macros have; been added in the tutorial section of the reference guide.; - The Reference Guide can now be accessed directly from the ROOT prompt thanks to; a great extension (implemented by Desislava Kalaydjieva) of the `.help` command.; For example to access the Reference Guide for `TTree` it is enough to type:; ~~~ {.cpp}; root[0] .help TTree; ~~~; To open the reference guide for a function/member:; ~~~ {.cpp}; root[0] .help TTree::Draw; ~~~. ## Build, Configuration and Testing Infrastructure. - Make MLP optional via the `-Dmlp={OFF,ON}` switch for CMake; - Make Spectrum optional via the `-Dspectrum={OFF,ON}` switch for CMake; - ROOT now fails to configure when any package is missing; when `-Dfail-on-missing=ON` is passed to CMake; - The `-Dall=ON` now switches the default value of all optional packages to `ON`; - The options `astiff`, `cling`, `pch`, `thread`, and `explicitlink` have been; removed and are now ignored. They either had no effect (their value was not; being used in the build system), or could not be disabled (like `cling` and; `explicitlink`).; - ROOT library targets now export which C++ standard they were built with via; the target compile features `cxx_std_11`, `cxx_std_14`, and `cxx_std_17`.; - The file `RootNewMacros.cmake` has been renam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:7631,Guid,Guide,7631,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['Guid'],['Guide']
Usability,"pe= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; i= 4, fNcells type= 3, offset= 60, len=1, method=0; i= 5, fXaxis type= 61, offset= 64, len=1, method=1081287424; i= 6, fYaxis type= 61, offset=192, len=1, method=1081287548; i= 7, fZaxis type= 61, offset=320, len=1, method=1081287676; i= 8, fBarOffset type= 22, offset=448, len=2, method=0; i= 9, fEntries type= 28, offset=452, len=8, method=0; i=10, fContour type= 62, offset=516, len=1, method=1081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; ```. ### Optimized StreamerInfo. The entries starting with ""`i = 0`"" is the optimized format of the; `StreamerInfo`. Consecutive data members of the same simple type and; size are collapsed and read at once into an array for performance; optimization. ``` {.cpp}; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; ```. For example, the five data members beginning with `fEnties `and the; three data members beginning with `fMaximum`, are put into an array; called `fEntries` (`i = 9`) with the length 8. ``` {.cpp}; i= 9, fEntries type= 28, offset=452, len=8, method=0; ```. Only simple type data members are combined, object data members are not; combined. For example the three axis data members remain separate. The; ""method"" is a handle to the method that reads the object. ### Automatic Schema Evolution. When a class is defined in ROOT, it must include the `ClassDef` macro as; the last line in the header file inside the class definition. The syntax; is:. ``` {.cpp}; ClassDef(<ClassName>,<V",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:74969,simpl,simple,74969,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"peMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<CXXBaseSpecifier>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<CXXConstructExpr>forEachArgumentWithParamMatcher<Expr> ArgMatcher, Matcher<ParmVarDecl> ParamMatcher; Matches all arguments and their respective ParmVarDecl. Given; void f(int i);; int y;; f(y);; callExpr(; forEachArgumentWithParam(; declRefExpr(to(varDecl(hasName(""y"")))),; parmVarDecl(hasType(isInteger())); )); matches f(y);; with declRefExpr(...); mat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:146446,Usab,Usable,146446,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"peMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<Expr>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<Expr>ignoringElidableConstructorCallast_matchers::Matcher<Expr> InnerMatcher; Matches expressions that match InnerMatcher that are possibly wrapped in an; elidable constructor and other corresponding bookkeeping nodes. In C++17, elidable copy constructors are no longer being generated in the; AST as it is not permitted by the standard. They are, however, part of th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:194041,Usab,Usable,194041,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"peMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<FriendDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<FunctionDecl>forEachTemplateArgumentclang::ast_matchers::Matcher<TemplateArgument> InnerMatcher; Matches classTemplateSpecialization, templateSpecializationType and; functionDecl nodes where the template argument matches the inner matcher.; This matcher may produce multiple matches. Given; template <typename T, unsigned N, unsigned M>; struct Matrix {};. cons",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:200735,Usab,Usable,200735,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"peMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<ValueDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<VarDecl>hasInitializerMatcher<Expr> InnerMatcher; Matches a variable declaration that has an initializer expression; that matches the given matcher. Example matches x (matcher = varDecl(hasInitializer(callExpr()))); bool y() { return true; }; bool x = y();. Matcher<VariableArrayType>hasSizeExprMatcher<Expr> InnerMatcher; Matches VariableArrayType nodes that ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:252955,Usab,Usable,252955,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"pecific address; space and a generic type value to produce an updated memory location; description. This allows them to continue to be used to offset an address. To generalize offsetting to any location description, including location; descriptions that describe when bytes are in registers, are implicit, or a; composite of these, the ``DW_OP_LLVM_offset``, ``DW_OP_LLVM_offset_uconst``, and; ``DW_OP_LLVM_bit_offset`` offset operations are added. The offset operations can operate on location storage of any size. For example,; implicit location storage could be any number of bits in size. It is simpler to; define offsets that exceed the size of the location storage as being an; evaluation error, than having to force an implementation to support potentially; infinite precision offsets to allow it to correctly track a series of positive; and negative offsets that may transiently overflow or underflow, but end up in; range. This is simple for the arithmetic operations as they are defined in terms; of two's complement arithmetic on a base type of a fixed size. Therefore, the; offset operation define that integer overflow is ill-formed. This is in contrast; to the ``DW_OP_plus``, ``DW_OP_plus_uconst``, and ``DW_OP_minus`` arithmetic; operations which define that it causes wrap-around. Having the offset operations allows ``DW_OP_push_object_address`` to push a; location description that may be in a register, or be an implicit value. The; DWARF expression of ``DW_TAG_ptr_to_member_type`` can use the offset operations; without regard to what kind of location description was pushed. Since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack` has; generalized location storage to be bit indexable, ``DW_OP_LLVM_bit_offset``; generalizes DWARF to work with bit fields. This is generally not possible in; DWARF Version 5. The ``DW_OP_*piece`` operations only allow literal indices. A way to use a; computed offset of an arbitrary location description (such as a v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:11906,simpl,simple,11906,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simple']
Usability,"pedefName1; typedef typedefName2; ...; header headerName1; header headerName2; ... ```. ### TROOT. The list returned by `GetListOfTypes` is no longer filled when the dictionary; are loaded but instead are filled on demand, when the user explicitly (directly; or indirectly) request each typedef. In particular this means that. ``` {.cpp}; gROOT->GetListOfTypes()->ls(); // or Print(); ```. no longer prints the list of all available typedef but instead list only the; typedefs that have been previously accessed throught the list (plus the builtins; types). ### ACliC. ACLiC has the following backward incompatibilities:. - Since rootcling no longer re-\#defines the private and protected; keyword to public, the code compiled by ACLIC no longer has access; to protected and private members of a class (except where allowed by; the C++ standard). ### Collection. New collection `TListOfTypes` that implements on demand creation; of the `TDataType` describing a typedef. ### TUnixSystem. - Simplify `Setenv` coding.; - Implement `Unsetenv` using the system function `unsetenv`. ### TMacOSXSystem. - The file descriptors' management improved/fixed. ### TColor. - 5 new predefined palettes with 255 colors are available vis; `gStyle->SetPalette(n)`:. - n = 51 a Deep Sea palette is used.; - n = 52 a Grey Scale palette is used.; - n = 53 a Dark Body Radiator palette is used.; - n = 54 a two-color hue palette palette is used.(dark blue; through neutral gray to bright yellow); - n = 55 a Rain Bow palette is used. ![New 255 colors palettes](pal255.png). - Add the optional parameter ""alpha"" to `TColor::SetPalette` and; `TStyle::SetPalette`. The default value is 1. (opaque palette). Any; value between 0. and 1 define the level of transparency. 0. being; fully transparent and 1. fully opaque. - In `SaveAS` implement the possibility to save an object as C code; independant from ROOT. It is enough to save the object in a file; with the extension "".cc"". The code as to save each objet should be; impl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:11538,Simpl,Simplify,11538,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,1,['Simpl'],['Simplify']
Usability,"perator NSComparisonResult (^)(id, id)() const;. This conversion function returns a new block that simply forwards the two; parameters to the lambda object (which it captures by copy), then returns the; result. The returned block is first copied (with ``Block_copy``) and then; autoreleased. As an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having user provided backing getter and setter methods.; ``__has_feature(objc_default_synthesize_properties)`` checks for availability; of this feature in version of clang being used. .. _langext-objc-retain-release:. Objective-C retaining behavior attributes; ----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:77066,simpl,simplifies,77066,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['simpl'],['simplifies']
Usability,pers.cpp; mlir/tools/mlir-tblgen/OpGenHelpers.h; mlir/tools/mlir-tblgen/OpInterfacesGen.cpp; mlir/tools/mlir-tblgen/OpPythonBindingGen.cpp; mlir/tools/mlir-tblgen/PassCAPIGen.cpp; mlir/tools/mlir-tblgen/PassDocGen.cpp; mlir/tools/mlir-tblgen/PassGen.cpp; mlir/tools/mlir-tblgen/RewriterGen.cpp; mlir/tools/mlir-tblgen/SPIRVUtilsGen.cpp; mlir/tools/mlir-tblgen/StructsGen.cpp; mlir/tools/mlir-translate/mlir-translate.cpp; mlir/tools/mlir-vulkan-runner/mlir-vulkan-runner.cpp; mlir/tools/mlir-vulkan-runner/vulkan-runtime-wrappers.cpp; mlir/tools/mlir-vulkan-runner/VulkanRuntime.cpp; mlir/tools/mlir-vulkan-runner/VulkanRuntime.h; mlir/unittests/Analysis/Presburger/IntegerPolyhedronTest.cpp; mlir/unittests/Analysis/Presburger/LinearTransformTest.cpp; mlir/unittests/Analysis/Presburger/MatrixTest.cpp; mlir/unittests/Analysis/Presburger/PresburgerSetTest.cpp; mlir/unittests/Analysis/Presburger/PresburgerSpaceTest.cpp; mlir/unittests/Analysis/Presburger/PWMAFunctionTest.cpp; mlir/unittests/Analysis/Presburger/SimplexTest.cpp; mlir/unittests/Analysis/Presburger/Utils.h; mlir/unittests/Conversion/PDLToPDLInterp/RootOrderingTest.cpp; mlir/unittests/Dialect/BroadcastShapeTest.cpp; mlir/unittests/Dialect/Affine/Analysis/AffineStructuresParser.cpp; mlir/unittests/Dialect/Affine/Analysis/AffineStructuresParser.h; mlir/unittests/Dialect/Affine/Analysis/AffineStructuresParserTest.cpp; mlir/unittests/Dialect/Quant/QuantizationUtilsTest.cpp; mlir/unittests/Dialect/SparseTensor/MergerTest.cpp; mlir/unittests/Dialect/SPIRV/DeserializationTest.cpp; mlir/unittests/Dialect/SPIRV/SerializationTest.cpp; mlir/unittests/Dialect/Utils/StructuredOpsUtilsTest.cpp; mlir/unittests/ExecutionEngine/Invoke.cpp; mlir/unittests/Interfaces/ControlFlowInterfacesTest.cpp; mlir/unittests/Interfaces/DataLayoutInterfacesTest.cpp; mlir/unittests/Interfaces/InferTypeOpInterfaceTest.cpp; mlir/unittests/IR/AttributeTest.cpp; mlir/unittests/IR/DialectTest.cpp; mlir/unittests/IR/InterfaceAttachmentTest.cpp; mlir/unitt,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:403643,Simpl,SimplexTest,403643,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimplexTest']
Usability,"piler-rt`` --- to the public.; It is the Release Manager's responsibility to ensure that a high quality build; of LLVM is released. If you're looking for the document on how to test the release candidates and; create the binary packages, please refer to the :doc:`ReleaseProcess` instead. .. _timeline:. Release Timeline; ================. LLVM is released on a time based schedule --- with major releases roughly; every 6 months. In between major releases there may be dot releases.; The release manager will determine if and when to make a dot release based; on feedback from the community. Typically, dot releases should be made if; there are large number of bug-fixes in the stable branch or a critical bug; has been discovered that affects a large number of users. Unless otherwise stated, dot releases will follow the same procedure as; major releases. Annual Release Schedule; -----------------------. Here is the annual release schedule for LLVM. This is meant to be a; guide, and release managers are not required to follow this exactly.; Releases should be tagged on Tuesdays. =============================== =========================; Release Approx. Date; =============================== =========================; *release branch: even releases* *4th Tue in January*; *release branch: odd releases* *4th Tue in July*; X.1.0-rc1 3 days after branch.; X.1.0-rc2 2 weeks after branch.; X.1.0-rc3 4 weeks after branch; **X.1.0-final** **6 weeks after branch**; **X.1.1** **8 weeks after branch**; **X.1.2** **10 weeks after branch**; **X.1.3** **12 weeks after branch**; **X.1.4** **14 weeks after branch**; **X.1.5** **16 weeks after branch**; **X.1.6 (if necessary)** **18 weeks after branch**; =============================== =========================. Release Process Summary; -----------------------. * Announce release schedule to the LLVM community and update the website. Do; this at least 3 weeks before the -rc1 release. * Create release branch and begin release process. * Send ou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:1234,guid,guide,1234,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['guid'],['guide']
Usability,"plements an LLVM target. This will permit the target name to be used with; the :option:`-march` option so that code can be generated for that target. .. option:: -meabi=[default|gnu|4|5]. Specify which EABI version should conform to. Valid EABI versions are *gnu*,; *4* and *5*. Default value (*default*) depends on the triple. .. option:: -stack-size-section. Emit the .stack_sizes section which contains stack size metadata. The section; contains an array of pairs of function symbol values (pointer size) and stack; sizes (unsigned LEB128). The stack size values only include the space allocated; in the function prologue. Functions with dynamic stack allocations are not; included. .. option:: -remarks-section. Emit the __remarks (MachO) section which contains metadata about remark; diagnostics. Tuning/Configuration Options; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. option:: --print-after-isel. Print generated machine code after instruction selection (useful for debugging). .. option:: --regalloc=<allocator>. Specify the register allocator to use.; Valid register allocators are:. *basic*. Basic register allocator. *fast*. Fast register allocator. It is the default for unoptimized code. *greedy*. Greedy register allocator. It is the default for optimized code. *pbqp*. Register allocator based on 'Partitioned Boolean Quadratic Programming'. .. option:: --spiller=<spiller>. Specify the spiller to use for register allocators that support it. Currently; this option is used only by the linear scan register allocator. The default; ``spiller`` is *local*. Valid spillers are:. *simple*. Simple spiller. *local*. Local spiller. Intel IA-32-specific Options; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. option:: --x86-asm-syntax=[att|intel]. Specify whether to emit assembly code in AT&T syntax (the default) or Intel; syntax. EXIT STATUS; -----------. If :program:`llc` succeeds, it will exit with 0. Otherwise, if an error; occurs, it will exit with a non-zero value. SEE ALSO; --------. :manpage:`lli(1)`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst:5995,simpl,simple,5995,interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,2,"['Simpl', 'simpl']","['Simple', 'simple']"
Usability,ples/toy/Ch7/mlir/MLIRGen.cpp; mlir/examples/toy/Ch7/mlir/ShapeInferencePass.cpp; mlir/examples/toy/Ch7/mlir/ToyCombine.cpp; mlir/include/mlir/InitAllDialects.h; mlir/include/mlir/InitAllPasses.h; mlir/include/mlir/InitAllTranslations.h; mlir/include/mlir/Parser/Parser.h; mlir/include/mlir/Translation.h; mlir/include/mlir/Analysis/BufferViewFlowAnalysis.h; mlir/include/mlir/Analysis/DataFlowAnalysis.h; mlir/include/mlir/Analysis/DataLayoutAnalysis.h; mlir/include/mlir/Analysis/Liveness.h; mlir/include/mlir/Analysis/SliceAnalysis.h; mlir/include/mlir/Analysis/AliasAnalysis/LocalAliasAnalysis.h; mlir/include/mlir/Analysis/Presburger/Fraction.h; mlir/include/mlir/Analysis/Presburger/IntegerRelation.h; mlir/include/mlir/Analysis/Presburger/LinearTransform.h; mlir/include/mlir/Analysis/Presburger/Matrix.h; mlir/include/mlir/Analysis/Presburger/PresburgerSet.h; mlir/include/mlir/Analysis/Presburger/PresburgerSpace.h; mlir/include/mlir/Analysis/Presburger/PWMAFunction.h; mlir/include/mlir/Analysis/Presburger/Simplex.h; mlir/include/mlir/Analysis/Presburger/Utils.h; mlir/include/mlir/CAPI/AffineExpr.h; mlir/include/mlir/CAPI/AffineMap.h; mlir/include/mlir/CAPI/Diagnostics.h; mlir/include/mlir/CAPI/ExecutionEngine.h; mlir/include/mlir/CAPI/IntegerSet.h; mlir/include/mlir/CAPI/Interfaces.h; mlir/include/mlir/CAPI/IR.h; mlir/include/mlir/CAPI/Pass.h; mlir/include/mlir/CAPI/Registration.h; mlir/include/mlir/CAPI/Support.h; mlir/include/mlir/CAPI/Utils.h; mlir/include/mlir/CAPI/Wrap.h; mlir/include/mlir/Conversion/Passes.h; mlir/include/mlir/Conversion/AffineToStandard/AffineToStandard.h; mlir/include/mlir/Conversion/ArithmeticToLLVM/ArithmeticToLLVM.h; mlir/include/mlir/Conversion/ArithmeticToSPIRV/ArithmeticToSPIRV.h; mlir/include/mlir/Conversion/ArmNeon2dToIntr/ArmNeon2dToIntr.h; mlir/include/mlir/Conversion/AsyncToLLVM/AsyncToLLVM.h; mlir/include/mlir/Conversion/BufferizationToMemRef/BufferizationToMemRef.h; mlir/include/mlir/Conversion/ComplexToLLVM/ComplexToLLVM.h; mlir/inc,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:358199,Simpl,Simplex,358199,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['Simplex']
Usability,"plete code listing for our running example. To build this; example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../examples/Kaleidoscope/BuildingAJIT/Chapter1/KaleidoscopeJIT.h; :language: c++. .. [1] Actually we use a cut-down version of KaleidoscopeJIT that makes a; simplifying assumption: symbols cannot be re-defined. This will make it; impossible to re-define symbols in the REPL, but will make our symbol; lookup logic simpler. Re-introducing support for symbol redefinition is; left as an exercise for the reader. (The KaleidoscopeJIT.h used in the; original tutorials will be a helpful reference). .. [2] +-----------------------------+-----------------------------------------------+; | File | Reason for inclusion |; +=============================+===============================================+; | CompileUtils.h | Provides the SimpleCompiler class. |; +-----------------------------+-----------------------------------------------+; | Core.h | Core utilities such as ExecutionSession and |; | | JITDylib. |; +-----------------------------+-----------------------------------------------+; | ExecutionUtils.h | Provides the DynamicLibrarySearchGenerator |; | | class. |; +-----------------------------+-----------------------------------------------+; | IRCompileLayer.h | Provides the IRCompileLayer class. |; +-----------------------------+-----------------------------------------------+; | JITTargetMachineBuilder.h | Provides the JITTargetMachineBuilder class. |; +-----------------------------+-----------------------------------------------+; | RTDyldObjectLinkingLayer.h | Provides the RTDyldObjectLinkingLayer class. |; +-----------------------------+-----------------------------------------------+; | SectionMemoryManager.h | Provides the SectionMemoryManager class. |; +-----------------------------+------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:13905,Simpl,SimpleCompiler,13905,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['Simpl'],['SimpleCompiler']
Usability,"pletion (`Foo<std::vector<float>>` -> `Foo<std::vector<float, std::allocator<float>>>`). ### Experimental PyROOT; - Added pythonisations for `TTree` and its subclasses (e.g. `TChain`, `TNtuple`); - Pythonic iterator (`for event in tree:`); - Access tree branches as attributes (`mytree.mybranch`); - `TTree::Branch` pythonisation; - `TTree::SetBranchAddress` pythonisation; - Added pythonisations for `TDirectory` and its subclasses (e.g `TFile`, `TDirectoryFile`); - Access directories/objects in `TDirectory`/`TDirectoryFile`/`TFile` as attributes; (`mydir1.mydir2.myhist`, `myfile.myhist`, `myfile.mydir.myhist`); - `TDirectory::Get` pythonisation; - `TDirectory::WriteObject` pythonisation; - `TFile::Open` pythonisation; - Added pretty printing generic pythonisation for all classes; - Added interoperability with NumPy arrays for STL vectors and `RVec`s (zero-copy wrapping of; vectors and `RVec`s into NumPy arrays). ### Jupyter Notebook Integration; - Make sure the ROOT C++ Jupyter kernel runs with the same Python version (major and minor) that ROOT; was built with.; - Make the Jupyter server started with `root --notebook` listen on all interfaces. This can be useful; if the user wants to connect to the server remotely. It also fixes an issue observed when starting; the Jupyter server inside a Docker container. ## JavaScript ROOT; - Support of TWebCanvas functionality. Code for ROOT 6.16 will; be maintained in v6-16-00-patches branch of JSROOT repository. ; - Singificant speed up (factor 10) when drawing canvas with many subpads; - Many small improvements and bug fixes, see JSROOT release notes for v5.4.2 - v5.6.2 . ## Tutorials; - Refurbish text in the `RDataFrame` tutorials category. ## Command line tools; - Fixed `rooteventselector` when both applying a cut (based on branch values) and selecting only; a subset of the branches. Previously, the size of the output file was bigger than expected. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:21456,Guid,Guide,21456,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['Guid'],['Guide']
Usability,"plicit instantiation of C in C<42>; with isIntegral() matching 42. Matcher<TemplateSpecializationType>templateArgumentCountIsunsigned N; Matches if the number of template arguments equals N. Given; template<typename T> struct C {};; C<int> c;; classTemplateSpecializationDecl(templateArgumentCountIs(1)); matches C<int>. Matcher<TypeLoc>isExpandedFromMacrostd::string MacroName; Matches statements that are (transitively) expanded from the named macro.; Does not match if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<TypeLoc>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were expanded within files whose name is; partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<TypeLoc>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<TypeLoc>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Type>booleanType; Matches type bool. Given; struct S { bool func(); };; functionDecl(returns(booleanType())); matches ""bool func();"". Matcher<Type>equalsBoundNodestd::string I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:120324,Usab,Usable,120324,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"point, double low, double high) ###. Scans the value of the user function by varying parameter number; $\mbox{par}$, leaving all other parameters fixed at the current; value. If $\mbox{par}$ is not specified, all variable parameters are; scanned in sequence. The number of points $\mbox{npoints}$ in the; scan is 40 by default, and cannot exceed 100. The range of the scan is; by default 2 standard deviations on each side of the current best value,; but can be specified as from $\mbox{low}$ to $\mbox{high}$.; After each scan, if a new minimum is found, the best parameter values; are retained as start values for future scans or minimizations. The; curve resulting from each scan can be plotted on the output terminal; using MnPlot [api:plot] in order to show the approximate behaviour of; the function. ### ScanMinimizer ###. Although the $\mbox{SCAN}$ method is not intended for minimization; it can be used as a minimizer in its most primitive form. ## MnSimplex and SimplexMinimizer ##. [api:simplex]. $\mbox{SIMPLEX}$ is a function minimization method using the simplex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; parameters interaction. It also retains the result from the last; minimization in case the user may want to do subsequent minimization; steps with parameter interactions in between the minimization requests.; The minimization is done by the SimplexMinimizer. Minimization of the; function can be done by directly using the SimplexMinimizer if no; parameters interaction is required. As $\mbox{SIMPLEX}$ is a; stepping method it does not produce a covariance matrix. ### MnSimplex(const FCNBase&, const std::vector$<$double$>$&,\; const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:48406,simpl,simplex,48406,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['simpl'],['simplex']
Usability,"port for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides information about Branch Prediction Information. :doc:`GetElementPtr`; Answers to some very frequent questions about LLVM's most frequently; misunderstood instruction. :doc:`ScudoHardenedAllocator`; A library that implements a security-hardened `malloc()`. :doc:`MemTagSanitizer`; Security hardening for production code aiming to mitigate memory; related vulnerabilities. Based on the Armv8.5-A Memory Tagging Extension. :doc:`Dependence Graphs <DependenceGraphs/index>`; A description of the design of the various dependence graphs such as; the DDG (Data Dependence Graph). :doc:`SpeculativeLoadHardening`; A description of the Speculative Load Hardening mitigation for Spectre v1. :doc:`SegmentedStacks`; This document describes segmented stacks and how they are used in LLVM. :doc:`MarkedUpDisassembly`; This document describes the optional rich disassembly output syntax. :doc:`StackMaps`; LLVM support for mapping instruction addresses to the location of; values and allowing code to be patched. :doc:`Coroutines`; LLVM support for coroutines. :doc:`PointerAuth`; A description of pointer authentication, its LLVM IR representation, and its; support in the backend. :doc:`YamlIO`; A reference guide for using LLVM's YAML I/O library. :doc:`ConvergenceAndUniformity`; A description of uniformity analysis in the presence of irreducible; control flow, and its implementation.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:5316,guid,guide,5316,interpreter/llvm-project/llvm/docs/Reference.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst,1,['guid'],['guide']
Usability,"ports a; limited number of ARM architectures. It does not yet fully support; ARMv5, for example. PowerPC; ^^^^^^^. The support for PowerPC (especially PowerPC64) is considered stable; on Linux and FreeBSD: it has been tested to correctly compile many; large C and C++ codebases. PowerPC (32bit) is still missing certain; features (e.g. PIC code on ELF platforms). Other platforms; ^^^^^^^^^^^^^^^. clang currently contains some support for other architectures (e.g. Sparc);; however, significant pieces of code generation are still missing, and they; haven't undergone significant testing. clang contains limited support for the MSP430 embedded processor, but; both the clang support and the LLVM backend support are highly; experimental. Other platforms are completely unsupported at the moment. Adding the; minimal support needed for parsing and semantic analysis on a new; platform is quite easy; see ``lib/Basic/Targets.cpp`` in the clang source; tree. This level of support is also sufficient for conversion to LLVM IR; for simple programs. Proper support for conversion to LLVM IR requires; adding code to ``lib/CodeGen/CGCall.cpp`` at the moment; this is likely to; change soon, though. Generating assembly requires a suitable LLVM; backend. Operating System Features and Limitations; -----------------------------------------. Windows; ^^^^^^^. Clang has experimental support for targeting ""Cygming"" (Cygwin / MinGW); platforms. See also :ref:`Microsoft Extensions <c_ms>`. Cygwin; """""""""""". Clang works on Cygwin-1.7. MinGW32; """""""""""""". Clang works on some mingw32 distributions. Clang assumes directories as; below;. - ``C:/mingw/include``; - ``C:/mingw/lib``; - ``C:/mingw/lib/gcc/mingw32/4.[3-5].0/include/c++``. On MSYS, a few tests might fail. MinGW-w64; """""""""""""""""". For 32-bit (i686-w64-mingw32), and 64-bit (x86\_64-w64-mingw32), Clang; assumes as below;. - ``GCC versions 4.5.0 to 4.5.3, 4.6.0 to 4.6.2, or 4.7.0 (for the C++ header search path)``; - ``some_directory/bin/gcc.exe``; - ``s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:162673,simpl,simple,162673,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simple']
Usability,"posite.C - Composite p.d.f with signal and background component; rf202_extendedmlfit.C - Setting up an extended maximum likelihood fit; rf203_ranges.C - Fitting and plotting in sub ranges; rf204_extrangefit.C - Extended maximum likelihood fit with alternate range definition; rf205_compplot.C - Options for plotting components of composite p.d.f.s.; rf206_treevistools.C - Tools for visualization of RooAbsArg expression trees; rf207_comptools.C - Tools and utilities for manipulation of composite objects; rf208_convolution.C - One-dimensional numeric convolution; rf209_anaconv.C - Decay function p.d.fs with optional B physics. ; MULTIDIMENSIONAL MODELS. rf301_composition.C - Multi-dimensional p.d.f.s through composition, e.g. substituting a p.d.f parameter with a function that depends on other observables; rf302_utilfuncs.C - Utility functions classes available for use in tailoring; rf303_conditional.C - Use of tailored p.d.f as conditional p.d.fs.s; rf304_uncorrprod.C - Simple uncorrelated multi-dimensional p.d.f.s; rf305_condcorrprod.C - Multi-dimensional p.d.f.s with conditional p.d.fs in product; rf306_condpereventerrors.C - Complete example with use of conditional p.d.f. with per-event errors; rf307_fullpereventerrors.C -Complete example with use of full p.d.f. with per-event errors; rf308_normintegration2d.C - Examples on normalization of p.d.f.s in more than one dimension; rf309_ndimplot.C - Making 2 and 3 dimensional plots of p.d.f.s and datasets; rf310_sliceplot.C -Projecting p.d.f and data slices in discrete observables; rf311_rangeplot.C -Projecting p.d.f and data ranges in continuous observables; rf312_multirangefit.C - Performing fits in multiple (disjoint) ranges in one or more dimensions; rf313_paramranges.C - Working with parameterized ranges to define non-rectangular regions; rf314_paramfitrange.C - Working with parameterized ranges in a fit.; rf315_projectpdf.C - Marginizalization of multi-dimensional p.d.f.s through integration; rf316_llratioplot.C - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:2410,Simpl,Simple,2410,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['Simpl'],['Simple']
Usability,"pport is experimental::. clang -g -O1 -fsanitize=fuzzer mytarget.c # Builds the fuzz target w/o sanitizers; clang -g -O1 -fsanitize=fuzzer,address mytarget.c # Builds the fuzz target with ASAN; clang -g -O1 -fsanitize=fuzzer,signed-integer-overflow mytarget.c # Builds the fuzz target with a part of UBSAN; clang -g -O1 -fsanitize=fuzzer,memory mytarget.c # Builds the fuzz target with MSAN. This will perform the necessary instrumentation, as well as linking with the libFuzzer library.; Note that ``-fsanitize=fuzzer`` links in the libFuzzer's ``main()`` symbol. If modifying ``CFLAGS`` of a large project, which also compiles executables; requiring their own ``main`` symbol, it may be desirable to request just the; instrumentation without linking::. clang -fsanitize=fuzzer-no-link mytarget.c. Then libFuzzer can be linked to the desired driver by passing in; ``-fsanitize=fuzzer`` during the linking stage. .. _libfuzzer-corpus:. Corpus; ------. Coverage-guided fuzzers like libFuzzer rely on a corpus of sample inputs for the; code under test. This corpus should ideally be seeded with a varied collection; of valid and invalid inputs for the code under test; for example, for a graphics; library the initial corpus might hold a variety of different small PNG/JPG/GIF; files. The fuzzer generates random mutations based around the sample inputs in; the current corpus. If a mutation triggers execution of a previously-uncovered; path in the code under test, then that mutation is saved to the corpus for; future variations. LibFuzzer will work without any initial seeds, but will be less; efficient if the library under test accepts complex,; structured inputs. The corpus can also act as a sanity/regression check, to confirm that the; fuzzing entrypoint still works and that all of the sample inputs run through; the code under test without problems. If you have a large corpus (either generated by fuzzing or acquired by other means); you may want to minimize it while still preserving the f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:4066,guid,guided,4066,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['guid'],['guided']
Usability,"pport the gcc extension for forward-declaring; function parameters; this has not shown up in any real-world code; yet, though, so it might never be implemented. This is not a complete list; if you find an unsupported extension; missing from this list, please send an e-mail to cfe-dev. This list; currently excludes C++; see :ref:`C++ Language Features <cxx>`. Also, this; list does not include bugs in mostly-implemented features; please see; the `bug; tracker <https://bugs.llvm.org/buglist.cgi?quicksearch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Clang.; - clang does not support ``__builtin_apply`` and friends; this extension; is extremely obscure and difficult to implement reliably. .. _c_ms:. Microsoft extensions; --------------------. clang has support for many extensions from Microsoft Visual C++. To enable these; extensions, use the ``-fms-extensions`` command-line option. This is the default; for Windows targets. Clan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:135737,undo,undocumented,135737,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['undo'],['undocumented']
Usability,"pproach is to use an std::vector (or other sequential container) with; std::sort+std::unique to remove duplicates. This approach works really well if; your usage pattern has these two distinct phases (insert then query), and can be; coupled with a good choice of :ref:`sequential container <ds_sequential>`. This combination provides the several nice properties: the result data is; contiguous in memory (good for cache locality), has few allocations, is easy to; address (iterators in the final vector are just indices or pointers), and can be; efficiently queried with a standard binary search (e.g.; ``std::lower_bound``; if you want the whole range of elements comparing; equal, use ``std::equal_range``). .. _dss_smallset:. llvm/ADT/SmallSet.h; ^^^^^^^^^^^^^^^^^^^. If you have a set-like data structure that is usually small and whose elements; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:78230,simpl,simple,78230,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"ppyy header for Windows/MSVC. 2020-10-31: 1.8.5; -----------------. * Fix leaks when using vector iterators on Py3/Linux. 2020-10-10: 1.8.4; -----------------. * ``std::string`` globals/data members no longer automatically converted to ``str``; * New methods for std::string to allow ``str`` interchangability; * Added a ``decode`` method to ``std::string``; * Add pythonized ``__contains__`` to ``std::set``; * Fix constructor generation for aggregates with static data; * Fix performance bug when using implicit conversions; * Fix memory overwrite when parsing during sorting of methods; * PyPy pip install again falls back to setup.py install. 2020-09-21: 1.8.3; -----------------. * Add initializer constructors for PODs and aggregates; * Use actual underlying type for enums, where possible; * Enum values remain instances of their type; * Expose enum underlying type name as ``__underlying`` and ``__ctype__``; * Strictly follow C++ enum scoping rules; * Same enum in transparent scope refers to same type; * More detailed enum ``repr()`` printing, where possible; * Fix for (extern) explicit template instantiations in namespaces; * Throw objects from an std::tuple a life line; * Global pythonizors now always run on all classes; * Simplified iteraton over STL-like containers defining ``begin()``/``end()``. 2020-09-08: 1.8.2; -----------------. * Add ``cppyy.set_debug()`` to enable debug output for fixing template errors; * Cover more partial template instantiation use cases; * Force template instantiation if necessary for type deduction (i.e. ``auto``). 2020-09-01: 1.8.1; -----------------. * Setup build dependencies with pyproject.toml; * Simplified flow of pointer types for callbacks and cross-derivation; * Pointer-comparing objects performs auto-cast as needed; * Add main dimension for ptr-ptr to builtin returns; * Transparant handling of ptr-ptr to instance returns; * Stricter handling of bool type in overload with int types; * Fix uint64_t template instantiation regressio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:10766,Simpl,Simplified,10766,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['Simpl'],['Simplified']
Usability,"present a total of *n* bits. .. productionlist::; SimpleValue5: ""["" `ValueList` ""]"" [""<"" `Type` "">""]. This value is a list initializer (note the brackets). The values in brackets; are the elements of the list. The optional :token:`Type` can be used to; indicate a specific element type; otherwise the element type is inferred; from the given values. TableGen can usually infer the type, although; sometimes not when the value is the empty list (``[]``). .. productionlist::; SimpleValue6: ""("" `DagArg` [`DagArgList`] "")""; DagArgList: `DagArg` ("","" `DagArg`)*; DagArg: `Value` ["":"" `TokVarName`] | `TokVarName`. This represents a DAG initializer (note the parentheses). The first; :token:`DagArg` is called the ""operator"" of the DAG and must be a record.; See `Directed acyclic graphs (DAGs)`_ for more details. .. productionlist::; SimpleValue7: `TokIdentifier`. The resulting value is the value of the entity named by the identifier. The; possible identifiers are described here, but the descriptions will make more; sense after reading the remainder of this guide. .. The code for this is exceptionally abstruse. These examples are a; best-effort attempt. * A template argument of a ``class``, such as the use of ``Bar`` in::. class Foo <int Bar> {; int Baz = Bar;; }. * The implicit template argument ``NAME`` in a ``class`` or ``multiclass``; definition (see `NAME`_). * A field local to a ``class``, such as the use of ``Bar`` in::. class Foo {; int Bar = 5;; int Baz = Bar;; }. * The name of a record definition, such as the use of ``Bar`` in the; definition of ``Foo``::. def Bar : SomeClass {; int X = 5;; }. def Foo {; SomeClass Baz = Bar;; }. * A field local to a record definition, such as the use of ``Bar`` in::. def Foo {; int Bar = 5;; int Baz = Bar;; }. Fields inherited from the record's parent classes can be accessed the same way. * A template argument of a ``multiclass``, such as the use of ``Bar`` in::. multiclass Foo <int Bar> {; def : SomeClass<Bar>;; }. * A variable defined",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:16447,guid,guide,16447,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['guid'],['guide']
Usability,"procedure`` debugging information entry. Then the; ``DW_AT_location`` attribute expression is always executed separately; and pushes a location description (that may have multiple single; location descriptions), and the ``DW_AT_LLVM_proc`` attribute expression; is always executed on the same stack and can leave anything on the; stack. The ``DW_AT_LLVM_proc`` attribute could have the new classes; ``exprproc``, ``loclistproc``, and ``loclistsptrproc`` to indicate that; the expression is executed on the same stack. ``exprproc`` is the same; encoding as ``exprloc``. ``loclistproc`` and ``loclistsptrproc`` are the; same encoding as their non-\ ``proc`` counterparts, except the DWARF is; ill-formed if the location list does not match exactly one location list; entry and a default entry is required. These forms indicate explicitly; that the matched single operation expression must be executed on the; same stack. This is better than ad hoc special rules for ``loclistproc``; and ``loclistsptrproc`` which are currently clearly defined to always; return a location description. The producer then explicitly indicates; the intent through the attribute classes. Such a change would be a breaking change for how GDB implements; ``DW_OP_call*``. However, are the breaking cases actually occurring in; practice? GDB could implement the current approach for DWARF Version 5,; and the new semantics for DWARF Version 6 which has been done for some; other features. Another option is to limit the execution to be on the same stack only to; the evaluation of an expression E that is the value of a; ``DW_AT_location`` attribute of a ``DW_TAG_dwarf_procedure`` debugging; information entry. The DWARF would be ill-formed if E is a location list; expression that does not match exactly one location list entry. In all; other cases the evaluation of an expression E that is the value of a; ``DW_AT_location`` attribute would evaluate E with the current context,; except the result kind is a location descrip",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:79135,clear,clearly,79135,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['clear'],['clearly']
Usability,"produced when all the tree events are plotted.](pictures/para3.png). If the 24000 events are plotted as solid lines and no special techniques; are used to clarify the picture, the result is the previous picture; which is very cluttered and useless. To improve the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a palette; according to the bin contents) or as bar charts. Both representations; can be cumulated on the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:99044,clear,clearly,99044,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clearly']
Usability,"program(LLVM_LIT; NAMES llvm-lit lit.py lit; PATHS ""${ROOT_LLVM_MAIN_SRC_DIR}/utils/lit""; DOC ""Path to lit.py""); endif(). if(LLVM_LIT); # Define the default arguments to use with 'lit', and an option for the user; # to override.; set(LIT_ARGS_DEFAULT ""-sv""); if (MSVC OR XCODE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --no-progress-bar""); endif(); set(LLVM_LIT_ARGS ""${LIT_ARGS_DEFAULT}"" CACHE STRING ""Default options for lit""); set(LIT_COMMAND ""${LLVM_LIT}"" CACHE STRING ""Path to the LLVM LIT.""). # On Win32 hosts, provide an option to specify the path to the GnuWin32 tools.; if( WIN32 AND NOT CYGWIN ); set(LLVM_LIT_TOOLS_DIR """" CACHE PATH ""Path to GnuWin32 tools""); endif(); else(); set(LLVM_INCLUDE_TESTS OFF); endif(); endif(). set(LLVM_INCLUDE_DIRS ${LLVM_MAIN_INCLUDE_DIR}; CACHE STRING ""System LLVM include directories.""; ). # We checked above that LLVM_VERSION is what we require in ROOT_LLVM_VERSION_REQUIRED_MAJOR.; # To simplify code, just forward that requirement to the rest of ROOT, for example to; # construct the resource directory in core/clingutils.; set(LLVM_VERSION_MAJOR ${ROOT_LLVM_VERSION_REQUIRED_MAJOR} PARENT_SCOPE). # We are in the case of NOT builtin_llvm; if (builtin_clang); # remove clang-cpp from CLANG_LINKS_TO_CREATE to avoid clashes with; # install-clang-cpp target defined by LLVM's cmake module; set(CLANG_LINKS_TO_CREATE clang++ clang-cl). # Disable linking against shared LLVM; set(LLVM_LINK_LLVM_DYLIB OFF). add_subdirectory(llvm-project/clang EXCLUDE_FROM_ALL); endif(builtin_clang). set( CLANG_BUILT_STANDALONE 1 ); set(BACKEND_PACKAGE_STRING ""LLVM ${LLVM_PACKAGE_VERSION}""); endif(builtin_llvm). if (builtin_clang); if (builtin_llvm); # For builtin LLVM this is set in interpreter/llvm-project/llvm/CMakeLists.txt; set(Clang_DIR ""${LLVM_BINARY_DIR}/tools/clang/""); else(); set(Clang_DIR ""${CMAKE_BINARY_DIR}/interpreter/llvm-project/clang/""); set(Clang_Config_ExtraPathHints ""${Clang_DIR}cmake/modules/CMakeFiles""); endif(); set(CLANG_INCLUDE_DIRS; ${CM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:19084,simpl,simplify,19084,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['simpl'],['simplify']
Usability,"prove the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a palette; according to the bin contents) or as bar charts. Both representations; can be cumulated on the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to defi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:99362,clear,clearly,99362,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clearly']
Usability,"ps://root.cern.ch/js/3.9/) and the [JSRoot 3.9 release notes](https://github.com/linev/jsroot/releases/tag/3.9). ## Class Reference Guide. The ROOT [reference guide](https://root.cern.ch/doc/master/index.html) is moving; to the Doxygen system. Doxygen is the de-facto standard for code documentation. It offers; many nice features we are now exploring and trying to get the best of them. Having; [MathJax rendered math formula](https://root.cern.ch/doc/master/classTSpectrum2.html#a482a7f144b9cc1b0405d0ac0d8cc9bbb); is one of them. The documentation can be structured in a more logical way; [using groups](https://root.cern.ch/doc/master/modules.html). Still there is a lot; to do but big progresses have been done. We developed also a Doxygen filter allowing; to execute macros given as examples in the documentation and show the; [resulting picture directly in the documentation](https://root.cern.ch/doc/master/classTHistPainter.html#HP16). ## Tutorials. [The tutorials](https://root.cern.ch/doc/master/group__Tutorials.html) in; `$ROOTSYS/tutorials` are also presented on the web thanks to Doxygen. They; are now part of the reference guide allowing nice cross-referencing with the; classes documentation. Here also a filter has been developed to generate; [the resulting picture](https://root.cern.ch/doc/master/ContourList_8C.html). ## Build, Configuration and Testing Infrastructure. ROOT uses the CMake cross-platform build-generator tool as a primary build system. CMake does not build the project, it generates the files needed by your build tool (GNU make, Ninja, Visual Studio, etc) for building ROOT. The classic build with configure/make is is still available but it will not be evolving with the new features of ROOT. We added full support for C++14. Minor changes in the build system:. - Renamed build option POSTGRESQL_LIBRARIES to POSTGRESQL_LIBRARY; - Added build option `builtin_openssl` to build OpenSSL internally. This is specially needed for the latest Mac OSX (El Capitan); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:24558,guid,guide,24558,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['guid'],['guide']
Usability,"ques; are used to clarify the picture, the result is the previous picture; which is very cluttered and useless. To improve the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a palette; according to the bin contents) or as bar charts. Both representations; can be cumulated on the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:99177,simpl,simple,99177,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"quest will be closed and you will be notified by GitHub. Review expectations; -------------------. In order to make LLVM a long-term sustainable effort, code needs to be; maintainable and well tested. Code reviews help to achieve that goal.; Especially for new contributors, that often means many rounds of reviews; and push-back on design decisions that do not fit well within the; overall architecture of the project. For your first patches, this means:. - be kind, and expect reviewers to be kind in return - LLVM has a `Code; of Conduct <https://llvm.org/docs/CodeOfConduct.html>`__;. - be patient - understanding how a new feature fits into the; architecture of the project is often a time consuming effort, and; people have to juggle this with other responsibilities in their; lives; **ping the review once a week** when there is no response;. - if you can't agree, generally the best way is to do what the reviewer; asks; we optimize for readability of the code, which the reviewer is; in a better position to judge; if this feels like it's not the right; option, you can contact the cfe-dev mailing list to get more feedback; on the direction;. Commit access; =============. Once you've contributed a handful of patches to LLVM, start to think; about getting commit access yourself. It's probably a good idea if:. - you've landed 3-5 patches of larger scope than ""fix a typo"". - you'd be willing to review changes that are closely related to yours. - you'd like to keep contributing to LLVM. Getting commit access; ---------------------. LLVM uses Git for committing changes. The details are in the `developer; policy; document <https://llvm.org/docs/DeveloperPolicy.html#obtaining-commit-access>`__. With great power; ----------------. Actually, this would be a great time to read the rest of the `developer; policy <https://llvm.org/docs/DeveloperPolicy.html>`__, too. At minimum,; you need to be subscribed to the relevant commits list before landing; changes (e.g. llvm-commits@lists.llvm.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:12618,feedback,feedback,12618,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['feedback'],['feedback']
Usability,"r (GUI interface of the recorder):. New Class: TGPack; New Container class for vertical and horizontal grouping of frames.; It enforces a predictable resizing behaviour on children.; For an example of how to use it, see tutorials/eve/pack.C. TRootBrowser. Make the default url for the HTML plugin of TRootBrowser configurable via rootrc. TGTab. Added a 'Close Tab' icon in TGTabElement, allowing to close a tab element, and emitting a CloseTab(Int_t id) signal. The icon is active only on the actually activated tab.; Implement CloseTab slot usage in TRootBrowser and in TGRootIDE. TGTextEditor. Allow to execute a macro without having to save it first. TGSplitFrame. Added a new signal method Docked(TGFrame*) to notify when a embedded frame has been docked.; Added a new signal method Undocked(TGFrame*) to notify when a embedded frame has been undocked.; Added a new getter method GetUndocked() returning a pointer on undocked frame, if any. TGToolTip. Added new constructor with global x, y position.; If neither fWindow nor fPad are set use global fX, fY that was passed from outside. TGSplitter. Added option to handle frame resizing externally. TGView. Added a protection against possible negative scroll values. TGTextView. Fix bottom line not being properly updated while scrolling.; Solve a problem with vertical slider (avoid negative value when scrolling). TGTextEdit. Fix blinking cursor on some platforms/compilers. TGTextEntry. Added optional parameter 'Bool_t emit' to TGTextEntry::SetText(const char* text, Bool_t emit = kTRUE);; Made the same extension in sub-class TGNumberEntryField. TGCompositeFrame. Added new method virtual TGFrameElement* FindFrameElement(TGFrame *f) const; and use it in several TGCompositeFrame methods to simplify the code. GUIHTML; TGHtml. Implemented HTML <select> with TGListBox/TGCombobox and emit InputSelected(const char *name, const char *val) when changing selection. TGHtmlBrowser. Added the possibility to save current html page in a local file. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html:2250,simpl,simplify,2250,gui/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html,1,['simpl'],['simplify']
Usability,"r a range switch case instead of multiple, resulting in performance improvements.; Now requires OS X 10.7 or later.; 	; checker-276; built: February 19, 2014; download: checker-276.tar.bz2; highlights:. Includes about 9 months of change to Clang itself (improved C++11/14 support, etc.); More precise modeling of Objective-C properties, which enables the analyzer to find more bugs.; Includes a new ""missing call to super"" warning, which looks for common pattern in iOS/OSX APIs that require chaining a call to a super class's implementation of a method.; Accepts -arch arm64 (which may be passed by Xcode 5.0), but for the time being analyzes code in such cases as -arch armv7s.; Many sundry fixes, improvements to C++ support, etc. checker-275; built: May 23, 2013; download: checker-275.tar.bz2; highlights:. Xcode: Includes a new arrow layout algorithm for issue presentation within Xcode. The goal is for interprocedural bug reports to look cleaner and less busy (and easier to read). Feedback appreciated.; Xcode: Bugs that occur within header code (e.g., C++) are now reported within the callers in the main source file. For example, if you misuse a C++ function declared in a header the primary diagnostic will be in the caller (in the main source file). The full expanded path, however, will show the bug in the header code as well. These kind of cross-file issues are currently only support by Xcode, not the HTML output.; This build is built with LLVM's Link-Time Optimization (LTO), which should make it slightly faster.; LTO also reduces the download size (about 19% smaller than checker-274).; Many sundry fixes. checker-274; built: April 23, 2013; download: checker-274.tar.bz2; highlights:. Improved use-after-free and mismatched deallocator checking.; Diagnostic polish.; Fixes crashes found in checker-273. checker-273; built: April 8, 2013; download: checker-273.tar.bz2; highlights:. Additional checks for misuse of Foundation collection APIs.; New C++ checker for attempting to c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:3770,Feedback,Feedback,3770,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,1,['Feedback'],['Feedback']
Usability,"r are available on Mac; OS X. These are built to run on OS X 10.7 and later.; Builds are released frequently. Often the differences between build; numbers being a few bug fixes or minor feature improvements. When using; the analyzer, we recommend that you check back here occasionally for new; builds, especially if the build you are using is more than a couple; weeks old.; The latest build is:; . Packaged builds for other platforms may eventually be provided, but; we need volunteers who are willing to help provide such regular builds.; If you wish to help contribute regular builds of the analyzer on other; platforms, please email the Clang; Developers' mailing list.; Using Packaged Builds; To use a package build, simply unpack it anywhere. If the build; archive has the name checker-XXX.tar.bz2 then the; archive will expand to a directory called checker-XXX.; You do not need to place this directory or the contents of this; directory in any special place. Uninstalling the analyzer is as simple; as deleting this directory.; Most of the files in the checker-XXX directory will; be supporting files for the analyzer that you can simply ignore. Most; users will only care about two files, which are located at the top of; the checker-XXX directory:. scan-build: scan-build is the high-level command line utility for running the analyzer; scan-view: scan-view a companion command line; utility to scan-build, scan-view is used to view; analysis results generated by scan-build. There is an option; that one can pass to scan-build to cause scan-view to; run as soon as it the analysis of a build completes. Running scan-build; For specific details on using scan-build, please see; scan-build's documentation.; To run scan-build, either add the; checker-XXX directory to your path or specify a complete; path for scan-build when running it. It is also possible to use; a symbolic link to scan-build, such one located in a directory; in your path. When scan-build runs it will automatically; det",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/installation.html:1314,simpl,simple,1314,interpreter/llvm-project/clang/www/analyzer/installation.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/installation.html,1,['simpl'],['simple']
Usability,"r bindings generation, lower memory; footprint, and isolation from preprocessor macros and compiler flags.; The use of modules is transparent, other than the requirement that they; need to be co-located with the compiled dictionary shared library. Optionally, the dictionary generation process also produces a mapping file,; which lists the libraries needed to load C++ classes on request (for details,; see the section on the class loader below). Structurally, you could have a single dictionary for a project as a whole,; but more likely a large project will have a pre-existing functional; decomposition that can be followed, with a dictionary per functional unit. Generation; ^^^^^^^^^^. There are two interfaces onto the same underlying dictionary generator:; ``rootcling`` and ``genreflex``.; The reason for having two is historic and they are not complete duplicates,; so one or the other may suit your preference better.; It is foreseen that both will be replaced once C++ modules become more; mainstream, as that will allow simplification and improved robustness. rootcling; """""""""""""""""". The first interface is called ``rootcling``::. $ rootcling; Usage: rootcling [-v][-v0-4] [-f] [out.cxx] [opts] file1.h[+][-][!] file2.h[+][-][!] ...[Linkdef.h]; For more extensive help type: /usr/local/lib/python2.7/dist-packages/cppyy_backend/bin/rootcling -h. Rather than providing command line options, the main steering of; ``rootcling`` behavior is done through; `#pragmas in a Linkdef.h <https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file>`_; file, with most pragmas dedicated to selecting/excluding (parts of) classes; and functions.; Additionally, the Linkdef.h file may contain preprocessor macros. The output consists of a dictionary file (to be compiled into a shared; library), a C++ module, and an optional mapping file, as described above. genreflex; """""""""""""""""". The second interface is called ``genreflex``::. $ genreflex; Generates dictionary sources and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:3760,simpl,simplification,3760,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,1,['simpl'],['simplification']
Usability,"r class: PDF. Option Array Default value Predefined values Description. NSmooth No 0 − Number of smoothing iterations for the input histograms. MinNSmooth No -1 − Min number of smoothing iterations, for bins with most data. MaxNSmooth No -1 − Max number of smoothing iterations, for bins with least data. NAvEvtPerBin No 50 − Average number of events per PDF bin. Nbins No 0 − Defined number of bins for the histogram from which the PDF is created. CheckHist No False − Whether or not to check the source histogram of the PDF. PDFInterpol No Spline2 Spline0, Spline1, Spline2, Spline3, Spline5, KDE Interpolation method for reference histograms (e.g. Spline2 or KDE). KDEtype No Gauss Gauss KDE kernel type (1=Gauss). KDEiter No Nonadaptive Nonadaptive, Adaptive Number of iterations (1=non-adaptive, 2=adaptive). KDEFineFactor No 1 − Fine tuning factor for Adaptive KDE: Factor to multyply the width of the kernel. KDEborder No None None, Renorm, Mirror Border effects treatment (1=no treatment , 2=kernel renormalization, 3=sample mirroring). Configuration options for Factory running :. Configuration options reference for class: Factory. Option Array Default value Predefined values Description. V No False − Verbose flag. Color No True − Flag for coloured screen output (default: True, if in batch mode: False). Transformations No − List of transformations to test; formatting example: Transformations=I;D;P;U;G,D, for identity, decorrelation, PCA, Uniform and Gaussianisation followed by decorrelation transformations. Silent No False − Batch mode: boolean silent flag inhibiting any output from TMVA after the creation of the factory class object (default: False). DrawProgressBar No True − Draw progress bar to display training, testing and evaluation schedule (default: True). AnalysisType No Auto Classification, Regression, Multiclass, Auto Set the analysis type (Classification, Regression, Multiclass, Auto) (default: Auto). Page created on Mon Jul 29 00:06:19 2013 (© TMVA, 2006−2009). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:35212,progress bar,progress bar,35212,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['progress bar'],['progress bar']
Usability,"r document usage of multi-thread RDataFrame: edge cases in which processing of an event could start; before processing of another event finished have been removed, making it easier for user to write safe parallel RDF operations.; See the [relevant documentation](https://root.cern.ch/doc/master/classROOT_1_1RDataFrame.html#parallel-execution) for more information. ### TTreeProcessorMT; - Parallelise search of cluster boundaries for input datasets with no friends or TEntryLists. The net effect is a faster initialization time in this common case.; - Handle gracefully the presence of chains the files associated to which are corrupted.; - Reduce number of expensive `TChain::LoadTree` calls by spawning nested TBB tasks to ensure clusters of a given file will be most likely processed by the same thread. ### TTree; - TTrees can be forced to only create new baskets at event cluster boundaries.; This simplifies file layout and I/O at the cost of memory. Recommended for; simple file formats such as ntuples but not more complex data types. To; enable, invoke `tree->SetBit(TTree::kOnlyFlushAtCluster)`. ## Histogram Libraries. ## Math Libraries. ### [Clad](https://github.com/vgvassilev/clad); - Enable experimental automatic differentiation techniques to compute; derivatives and gradients of functions. Automatic differentiation is; superior to the slow symbolic or often inaccurate numerical differentiation.; It uses the fact that every computer program can be divided into a set of; elementary operations (-,+,*,/) and functions (sin, cos, log, etc). By; applying the chain rule repeatedly to these operations, derivatives of; arbitrary order can be computed.; - Implement experimental `TFormula::GradientPar` derivative engine which; employs clad. ### VecOps; - Add `All` helper: return true if all of the elements equate to true, return false otherwise.; - Add `Any` helper: return true if any of the elements equates to true, return false otherwise.; - Add `ArgSort` helper: return an RVe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:10726,simpl,simple,10726,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['simpl'],['simple']
Usability,"r example in this section is compiled, result of the compilation will be:. .. code-block:: llvm. define i32 @main() {; entry:; tail call void @print(i32 4); tail call void @print(i32 5); tail call void @print(i32 6); ret i32 0; }. .. _final:; .. _final suspend:. Final Suspend; -------------. A coroutine author or a frontend may designate a particular suspend to be final,; by setting the second argument of the `coro.suspend`_ intrinsic to `true`.; Such a suspend point has two properties:. * it is possible to check whether a suspended coroutine is at the final suspend; point via `coro.done`_ intrinsic;. * a resumption of a coroutine stopped at the final suspend point leads to; undefined behavior. The only possible action for a coroutine at a final; suspend point is destroying it via `coro.destroy`_ intrinsic. From the user perspective, the final suspend point represents an idea of a; coroutine reaching the end. From the compiler perspective, it is an optimization; opportunity for reducing number of resume points (and therefore switch cases) in; the resume function. The following is an example of a function that keeps resuming the coroutine; until the final suspend point is reached after which point the coroutine is; destroyed:. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); br label %while; while:; call void @llvm.coro.resume(ptr %hdl); %done = call i1 @llvm.coro.done(ptr %hdl); br i1 %done, label %end, label %while; end:; call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. Usually, final suspend point is a frontend injected suspend point that does not; correspond to any explicitly authored suspend point of the high level language.; For example, for a Python generator that has only one suspend point:. .. code-block:: python. def coroutine(n):; for i in range(n):; yield i. Python frontend would inject two more suspend points, so that the actual code; looks like this:. .. code-block:: c. void* coroutine(int n) {; int current_value;; <des",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:25228,resume,resume,25228,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,['resume'],['resume']
Usability,"r example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediately available. There are two problems; with this: first, various semantic checks need to make judgements about the; *actual structure* of a type, ignoring typedefs. Second, we need an efficient; way to query whether two types are structurally identical to each other,; ignoring typedefs. The solution to both of these problems is the idea of; canonical types. .. _CanonicalType:. Canonical Types; ^^^^^^^^^^^^^^^. Every instance of the ``Type`` class contains a canonical type pointer. For; simple types with no typedefs involved (e.g., ""``int``"", ""``int*``"",; ""``int**``""), the type just points to itself. For types that have a typedef; somewhere in their structure (e.g., ""``foo``"", ""``foo*``"", ""``foo**``"",; ""``bar``""), the canonical type pointer points to their structurally equivalent; type without any typedefs (e.g., ""``int``"", ""``int*``"", ""``int**``"", and; ""``int*``"" respectively). This design provides a constant time operation (dereferencing the canonical type; pointer) that gives us access to the structure of types. For example, we can; trivially tell that ""``bar``"" and ""``foo*``"" are the same type by dereferencing; their canonical type pointers and doing a pointer comparison (they both point; to the single ""``int*``"" type). Canonical types and typedef types bring up some complexities that must be; carefully managed. Specifically, the ``isa``/``cast``/``dyn_cast`` operators; generally shouldn't be used in code that is inspecting the AST. For example,; when type checking the indirection ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:63703,simpl,simple,63703,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"r filesystem is called a *docker image*.; One can start a container from a prebuilt docker image. Docker images are built from a so-called *Dockerfile*, a source file written in; a specialized language that defines instructions to be used when build; the docker image (see `official; documentation <https://docs.docker.com/engine/reference/builder/>`_ for more; details). A minimal Dockerfile typically contains a base image and a number; of RUN commands that have to be executed to build the image. When building a new; image, docker will first download your base image, mount its filesystem as; read-only and then add a writable overlay on top of it to keep track of all; filesystem modifications, performed while building your image. When the build; process is finished, a diff between your image's final filesystem state and the; base image's filesystem is stored in the resulting image. Overview; ========; The ``llvm/utils/docker`` folder contains Dockerfiles and simple bash scripts to; serve as a basis for anyone who wants to create their own Docker image with; LLVM components, compiled from sources. The sources are checked out from the; upstream git repository when building the image. The resulting image contains only the requested LLVM components and a few extra; packages to make the image minimally useful for C++ development, e.g. libstdc++; and binutils. The interface to run the build is ``build_docker_image.sh`` script. It accepts a; list of LLVM repositories to checkout and arguments for CMake invocation. If you want to write your own docker image, start with an ``example/`` subfolder.; It provides an incomplete Dockerfile with (very few) FIXMEs explaining the steps; you need to take in order to make your Dockerfiles functional. Usage; =====; The ``llvm/utils/build_docker_image.sh`` script provides a rather high degree of; control on how to run the build. It allows you to specify the projects to; checkout from git and provide a list of CMake arguments to use during wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst:2482,simpl,simple,2482,interpreter/llvm-project/llvm/docs/Docker.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst,1,['simpl'],['simple']
Usability,"r for **`TClonesArray`** is called. The collection itself; cannot be a **`TClonesArray`**. If `name` is given, all branch names; will be prefixed with `name_`. *IMPORTANT NOTE1:* This function should not be called if `splitlevel<1`.; *IMPORTANT NOTE2:* The branches created by this function will have names; corresponding to the collection or object names. It is important to give; names to collections to avoid misleading branch names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33499,simpl,simple,33499,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"r is responsible for; accepting both and either forwarding the changing flag or discarding the flag; that would just set the key path to its default. The first argument to ``BoolOption`` is a prefix that is used to construct the; full names of both flags. The positive flag would then be named; ``flegacy-pass-manager`` and the negative ``fno-legacy-pass-manager``.; ``BoolOption`` also implies the ``-`` prefix for both flags. It's also possible; to use ``BoolFOption`` that implies the ``""f""`` prefix and ``Group<f_Group>``.; The ``PosFlag`` and ``NegFlag`` classes hold the associated boolean value,; arrays of elements passed to the ``Flag`` and ``Visibility`` classes and the; help text. The optional ``BothFlags`` class holds arrays of ``Flag`` and; ``Visibility`` elements that are common for both the positive and negative flag; and their common help text suffix. **String**. The key path defaults to the specified string, or an empty one, if omitted. When; the option appears on the command line, the argument value is simply copied. .. code-block:: text. def isysroot : JoinedOrSeparate<[""-""], ""isysroot"">,; Visibility<[ClangOption, CC1Option, FlangOption]>,; MarshallingInfoString<HeaderSearchOpts<""Sysroot"">, [{""/""}]>;. **List of Strings**. The key path defaults to an empty ``std::vector<std::string>``. Values specified; with each appearance of the option on the command line are appended to the; vector. .. code-block:: text. def frewrite_map_file : Separate<[""-""], ""frewrite-map-file"">,; Visibility<[ClangOption, CC1Option]>,; MarshallingInfoStringVector<CodeGenOpts<""RewriteMapFiles"">>;. **Integer**. The key path defaults to the specified integer value, or ``0`` if omitted. When; the option appears on the command line, its value gets parsed by ``llvm::APInt``; and the result is assigned to the key path on success. .. code-block:: text. def mstack_probe_size : Joined<[""-""], ""mstack-probe-size="">,; Visibility<[ClangOption, CC1Option]>,; MarshallingInfoInt<CodeGenOpts<""StackProbe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:40706,simpl,simply,40706,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability,"r markup element.; However, other markup elements may appear between SGR control sequences and the; color/bold state is expected to apply to the symbolic output that replaces the; markup element in the filter's output. The accepted SGR control sequences all have the form ``""\033[%um""`` (expressed here; using C string syntax), where ``%u`` is one of these:. ==== ============================ ===============================================; Code Effect Notes; ==== ============================ ===============================================; 0 Reset to default formatting.; 1 Bold text Combines with color states, doesn't reset them.; 30 Black foreground; 31 Red foreground; 32 Green foreground; 33 Yellow foreground; 34 Blue foreground; 35 Magenta foreground; 36 Cyan foreground; 37 White foreground; ==== ============================ ===============================================. Common markup element syntax; ============================. All the markup elements share a common syntactic structure to facilitate simple; matching and parsing code. Each element has the form::. {{{tag:fields}}}. ``tag`` identifies one of the element types described below, and is always a; short alphabetic string that must be in lower case. The rest of the element; consists of one or more fields. Fields are separated by ``:`` and cannot contain; any ``:`` or ``}`` characters. How many fields must be or may be present and; what they contain is specified for each element type. No markup elements or ANSI SGR control sequences are interpreted inside the; contents of a field. Implementations must ignore markup fields after those expected; this allows; adding new fields to backwards-compatibly extend elements. Implementations need; not ignore them silently, but the element should behave otherwise as if the; fields were removed. In the descriptions of each element type, ``printf``-style placeholders indicate; field contents:. ``%s``; A string of printable characters, not including ``:`` or ``}``. ``%p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:6741,simpl,simple,6741,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['simpl'],['simple']
Usability,"r open a private browser session.*. ## How to use; C++ Modules in ROOT are default since v6.20 (Unix) and v6.22 (OSX). Enjoy. To disable C++ Modules in ROOT use `-Druntime_cxxmodules=Off`. ## Citing ROOT's C++ Modules; ```latex; % Peer-Reviewed Publication; %; % 22nd International Conference on Computing in High Energy and Nuclear Physics (CHEP); % 8-14 October, 2016, San Francisco, USA; %; @inproceedings{Vassilev_ROOTModules,; author = {Vassilev,V.},; title = {{Optimizing ROOT's Performance Using C++ Modules}},; journal = {Journal of Physics: Conference Series},; year = 2017,; month = {oct},; volume = {898},; number = {7},; pages = {072023},; doi = {10.1088/1742-6596/898/7/072023},; url = {https://iopscience.iop.org/article/10.1088/1742-6596/898/7/072023/pdf},; publisher = {{IOP} Publishing}; }; ```; ; # Acknowledgement. We would like to thank the ROOT team. We would like to thank Liz Sexton-Kennedy (FNAL) in particular for supporting; this project. We would like to thank Axel Naumann for early feedback on this document. This work has been supported by an Intel Parallel Computing Center grant, by U.S.; National Science Foundation grants PHY-1450377 and PHY-1624356, and by the U.S.; Department of Energy, Office of Science. # References; (1): [Vassilev, V., 2017, October. Optimizing ROOT's Performance Using C++ Modules. In Journal of Physics: Conference Series (Vol. 898, No. 7, p. 072023). IOP Publishing.][1]. (2): [Clang Modules, Official Documentation][2]. (3): [Manuel Klimek, Deploying C++ Modules to 100s of Millions of Lines of Code, 2016, CppCon][3]. (4): [Precompiled Header and Modules Internals, Official Documentation][4]. (5): [Bloom Filter][5]. (6): [C++ Modules support (based on Clang), GitHub Repo][5]. (7): [Make your third party libraries modular][6]. (8): [Vassilev, V., Shadura, O., Takahashi, Y., IPCC-ROOT Showcase Presentation, Nov, 2018][7]. (9): [ROOT Continuous Performance Monitoring System][8]. [//]: # (Links); [1]: https://www.researchgate.net/prof",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:20329,feedback,feedback,20329,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['feedback'],['feedback']
Usability,"r open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducible, could use a reduced test case,; or otherwise needs some manual interaction. We can always use help with; bug triage and; issue tracker maintenance. Improve build times with Clang: the time it takes Clang to process a; translation unit is very important to our users; the lower the build time, the; better the overall user experience. It would be good to improve Clang's; performance as well as to find ways to proactively alert us when we've; introduced a change that has significant negative impact on build times.; Complete support for the experimental constant expression interpreter; : Clang's production constant expression interpreter computes a constant; expression result by walking over AST nodes, performing calculations as it; goes. This does not have good performance properties, and so we've begun work; on an ; experimental constant expression interpreter that works by converting the; AST into bytecode that is interpreted. This effort has a long tail of work left; to complete because it requires implementing byte code for every kind of; expression and type that can be used in a constant expression for C++ and C. Improve clang-doc: Clang's library-based design allows it to be used; by a variety of tools that reason abou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:3086,user experience,user experience,3086,interpreter/llvm-project/clang/www/OpenProjects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html,1,['user experience'],['user experience']
Usability,r subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype template parameter”; Unknown. 2308; NAD; Structured bindings and lambda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-base pointer conversions; Unknown. 2311; open; Missed case for guaranteed copy elision; Not resolved. 2312; CD6; Structured bindings and mutable; Unknown. 2313; CD5; Redeclaration of structured binding reference variables; Unknown. 2314; dup; Structured bindings and lambda capture; Unknown. 2315; CD5; What is the “corresponding special member” of a variant member?; Unknown. 2316; drafting; Simplifying class conversions in conditional expressions; Not resolved. 2317; CD5; Self-referential default member initializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved.,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:158035,Simpl,Simplifying,158035,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Simpl'],['Simplifying']
Usability,"r weights are those belonging to clusters.; It is possible to paint only the events having a weight above a given; value and the clusters appear. The next example “weight cut” applied on; the right plot is 50. Only the events with a weight greater than 50 are displayed. ![Applying a “weight cut” makes the clusters visible.](pictures/para11.png). In case only a few events are displayed, drawing them as smooth curves; instead of straight lines helps to differentiate them. ![Zoom on a Parallel Coordinates plot detail: curves differentiate better events.](pictures/para12.png). Interactivity and therefore the Graphical User Interface are very important; to manipulate the Parallel Coordinates plots. The ROOT framework allows; to easily implement the direct interactions on the graphical area and the; graphical editor facility provides dedicated GUI. ![Parallel Coordinates graphical editors.](pictures/para13.png). Transparency is very useful with parallel coordinates plots. It allows to; show clearly the clusters.; \index{transparency!parallel coordinates}. ![Parallel Coordinates with transparency.](pictures/para14.png). #### Box (Candle) Plots; \index{candle plot}; \index{candle stick plot}; \index{box-and whisker plot}. A Box Plot (also known as a “box-and whisker” plot or “candle stick” plot); is a convenient way to describe graphically a data distribution (D) with only; the five numbers. It was invented in 1977 by John Tukey. The five numbers are:. 1. The minimum value of the distribution D (Min).; 2. The lower quartile (Q1): 25% of the data points in D are less than Q1.; 3. The median (M): 50% of the data points in D are less than M.; 4. The upper quartile (Q3): 75% of the data points in D are less than Q3.; 5. The maximum value of the distribution D (Max). ![A box plot describes a distribution with only five numbers. ](pictures/bp1.png). In ROOT Box Plots (Candle Plots) can be produced from a TTree using the; “candle” option in TTree::Draw(). ``` {.cpp}; tree->Draw(“px",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:103608,clear,clearly,103608,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clearly']
Usability,"r-config c++-template-inlining=[true | false]``. Currently, template functions are considered for inlining by default. The motivation behind this option is that very generic code can be a source; of false positives, either by considering paths that the caller considers; impossible (by some unstated precondition), or by inlining some but not all; of a deep implementation of a function. c++-stdlib-inlining; ^^^^^^^^^^^^^^^^^^^. This option controls whether functions from the C++ standard library, including; methods of the container classes in the Standard Template Library, should be; considered for inlining. ``-analyzer-config c++-stdlib-inlining=[true | false]``. Currently, C++ standard library functions are considered for inlining by; default. The standard library functions and the STL in particular are used ubiquitously; enough that our tolerance for false positives is even lower here. A false; positive due to poor modeling of the STL leads to a poor user experience, since; most users would not be comfortable adding assertions to system headers in order; to silence analyzer warnings. c++-container-inlining; ^^^^^^^^^^^^^^^^^^^^^^. This option controls whether constructors and destructors of ""container"" types; should be considered for inlining. ``-analyzer-config c++-container-inlining=[true | false]``. Currently, these constructors and destructors are NOT considered for inlining; by default. The current implementation of this setting checks whether a type has a member; named 'iterator' or a member named 'begin'; these names are idiomatic in C++,; with the latter specified in the C++11 standard. The analyzer currently does a; fairly poor job of modeling certain data structure invariants of container-like; objects. For example, these three expressions should be equivalent:. .. code-block:: cpp. std::distance(c.begin(), c.end()) == 0; c.begin() == c.end(); c.empty(). Many of these issues are avoided if containers always have unknown, symbolic; state, which is what hap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:3760,user experience,user experience,3760,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['user experience'],['user experience']
Usability,"r-rt/lib/fuzzer/afl>`__. How good is my fuzzer?; ----------------------. Once you implement your target function ``LLVMFuzzerTestOneInput`` and fuzz it to death,; you will want to know whether the function or the corpus can be improved further.; One easy to use metric is, of course, code coverage. We recommend to use; `Clang Coverage <https://clang.llvm.org/docs/SourceBasedCodeCoverage.html>`_,; to visualize and study your code coverage; (`example <https://github.com/google/fuzzer-test-suite/blob/master/tutorial/libFuzzerTutorial.md#visualizing-coverage>`_). User-supplied mutators; ----------------------. LibFuzzer allows to use custom (user-supplied) mutators, see; `Structure-Aware Fuzzing <https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md>`_; for more details. Startup initialization; ----------------------; If the library being tested needs to be initialized, there are several options. The simplest way is to have a statically initialized global object inside; `LLVMFuzzerTestOneInput` (or in global scope if that works for you):. .. code-block:: c++. extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {; static bool Initialized = DoInitialization();; ... Alternatively, you may define an optional init function and it will receive; the program arguments that you can read and modify. Do this **only** if you; really need to access ``argv``/``argc``. .. code-block:: c++. extern ""C"" int LLVMFuzzerInitialize(int *argc, char ***argv) {; ReadAndMaybeModify(argc, argv);; return 0;; }. Using libFuzzer as a library; ----------------------------; If the code being fuzzed must provide its own `main`, it's possible to; invoke libFuzzer as a library. Be sure to pass ``-fsanitize=fuzzer-no-link``; during compilation, and link your binary against the no-main version of; libFuzzer. On Linux installations, this is typically located at:. .. code-block:: bash. /usr/lib/<llvm-version>/lib/clang/<clang-version>/lib/linux/libclang_rt.fuzzer_no_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:23926,simpl,simplest,23926,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['simpl'],['simplest']
Usability,"r. This overrides the ``ssp`` and ``sspstrong`` function; attributes. Variables that are identified as requiring a protector will be arranged; on the stack such that they are adjacent to the stack protector guard.; The specific layout rules are:. #. Large arrays and structures containing large arrays; (``>= ssp-buffer-size``) are closest to the stack protector.; #. Small arrays and structures containing small arrays; (``< ssp-buffer-size``) are 2nd closest to the protector.; #. Variables that have had their address taken are 3rd closest to the; protector. If a function with an ``sspreq`` attribute is inlined into a calling; function which has an ``ssp`` or ``sspstrong`` attribute, the calling; function's attribute will be upgraded to ``sspreq``. ``strictfp``; This attribute indicates that the function was called from a scope that; requires strict floating-point semantics. LLVM will not attempt any; optimizations that require assumptions about the floating-point rounding; mode or that might alter the state of floating-point status flags that; might otherwise be set or cleared by calling this function. LLVM will; not introduce any new floating-point instructions that may trap. .. _denormal_fp_math:. ``""denormal-fp-math""``; This indicates the denormal (subnormal) handling that may be; assumed for the default floating-point environment. This is a; comma separated pair. The elements may be one of ``""ieee""``,; ``""preserve-sign""``, ``""positive-zero""``, or ``""dynamic""``. The; first entry indicates the flushing mode for the result of floating; point operations. The second indicates the handling of denormal inputs; to floating point instructions. For compatibility with older; bitcode, if the second value is omitted, both input and output; modes will assume the same mode. If this is attribute is not specified, the default is ``""ieee,ieee""``. If the output mode is ``""preserve-sign""``, or ``""positive-zero""``,; denormal outputs may be flushed to zero by standard floating-point; op",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:105921,clear,cleared,105921,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['clear'],['cleared']
Usability,"r. This; implies:. - do not share the layout-hints among GUI components;. - do not delete child widgets in the destructor as this is done; automatically. #### Using Several Tabs. Sometimes you might need to use several tabs to organize properly your; class-editor. Each editor tab is a resource shared among all the; class-editors. Tabs must be created from the constructor of your; editor-class by using the method:. ``` {.cpp}; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; ```. It returns a pointer to a new tab container frame ready for use in your; class. If you need to hide/show this frame depending on the object's; status, you should store it in a data member. See for examples:; **`TH1Editor`**, **`TH2Editor`**. #### Base-Class Editors Control. Full control over base-class editors can be achieved by re-implementing; virtual method void `TGedFrame::ActivateBaseClassEditors(TClass` `*cl)`.; It is called during each compound editor rebuild and the default; implementation simply offers all base-classes to the publishing; mechanism. To prevent inclusion of a base-class into the compound editor, call:. ``` {.cpp}; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); ```. Pointer to the compound GED-editor is available in **`TGedFrame`**‘s; data-member:. ``` {.cpp}; TGedEditor *fGedEditor; ```. Ordering of base-class editor frames follows the order of the classes in; the class hierarchy. This order can be changed by modifying the value of; **`TGedFrame`**'s data member `Int_t fPriority`. The default value is; 50; smaller values move the frame towards to the top. This priority; should be set in the editor constructor. ## Drag and Drop. Drag and Drop support is introduced for Linux (via Xdnd - the drag and; drop protocol for X window system) and for Windows (via Clipboard).; Users can selects something in ROOT with a mouse press, drags it (moves; the mouse while keeping the mouse button pressed) and releases the mouse; button somepl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:106857,simpl,simply,106857,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simply']
Usability,"r2.png). The spider plot graphics editor provides two tabs to interact with; the spider plots’ output: the tab “Style” defining the spider layout; and the tab “Browse” to navigate in the tree. #### Parallel Coordinates Plots; \index{parallel coordinates}. The Parallel Coordinates Plots are a common way of studying and; visualizing multiple variables data sets. They were proposed by in; A.Inselberg in 1981 as a new way to represent multi-dimensional; information. In traditional Cartesian coordinates, axes are mutually; perpendicular. In Parallel coordinates, all axes are parallel which; allows representing data in much more than three dimensions. To show; a set of points in Parallel Coordinates, a set of parallel lines is; drawn, typically vertical and equally spaced. A point in n-dimensional; space is represented as a polyline with vertices on the parallel axes.; The position of the vertex on the i-th axis corresponds to the i-th; coordinate of the point. The three following figures show some very; simple examples:. ![The Parallel Coordinates representation of the six dimensional point `(-5,3,4,2,0,1)`.](pictures/para1.png). ![The line `y = -3x+20` and a circle in Parallel Coordinates.](pictures/para2.png). The Parallel Coordinates technique is good at: spotting irregular; events, seeing the data trend, finding correlations and clusters. Its; main weakness is the cluttering of the output. Because each “point” in; the multidimensional space is represented as a line, the output is very; quickly opaque and therefore it is difficult to see the data clusters.; Most of the work done about Parallel Coordinates is to find techniques; to reduce the output’s cluttering. The Parallel Coordinates plots in; ROOT have been implemented as a new plotting option “PARA” in the; `TTree::Draw()method`. To demonstrate how the Parallel Coordinates; works in ROOT we will use the tree produced by the following; “pseudo C++” code:. ``` {.cpp}; void parallel_example() {; TNtuple *nt = new TN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:96052,simpl,simple,96052,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"r::Restrict() method.; Up to now general read-only flag was applied - either; everything read-only or everything is fully accessible.; Now one could restrict access to different parts of; objects hierarchy or even fully 'hide' them from the client.; Restriction based on user account name, which is applied; when htdigest authentication is configured.; One also able to allow execution of selected methods. Implement multi.bin and multi.json requests.; One could request many items with single HTTP request.; Let optimize communication between server and client. With *SNIFF* tag in ClassDef() comments one could expose different properties,; which than exposed by the TRootSniffer to the client with h.json requests.; Such possibility ease implementation of client-side code for custom classes. Allow to bind http port with loopback address.; This restrict access to http server only from localhost.; One could either specify 'loopback' option in constructor:; new THttpServer(""http:8080?loopback""); or in clear text specify IP address to which http socket should be bind:; new THttpServer(""http:127.0.0.1:8080""); If host has several network interfaces, one could select one for binding:; new THttpServer(""http:192.168.1.17:8080""). ### TNetXNGFileStager; Fixed ROOT-7703. This restores the behavior of Locate() to that found with; TXNetFileStager: Rather than return only the xrootd server's reply, the endpoint; hostname is looked up and Locate() returns the full url, including the path. ### TWebFile; Fixed ROOT-7809. Returns an error for a redirect which does not specify the new; URI, rather than going into a loop. Fixed ROOT-7817. Avoid a crash under some circumstances when trying to open an; invalid path. ## GUI Libraries. ## Montecarlo Libraries. ## Multi-processing. With this version we introduce a new module, core/multiproc, for multi-processing on multi-core machines. This module is based on fork technology and offers an interface inspired from Python multiprocessor module. The new",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:20223,clear,clear,20223,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['clear'],['clear']
Usability,rProduct.h; LaProd.h; LaSum.h; MPIProcess.h; MatrixInverse.h; MinimumBuilder.h; MinimumError.h; MinimumErrorUpdator.h; MinimumParameters.h; MinimumSeed.h; MinimumSeedGenerator.h; MinimumState.h; MinosError.h; Minuit2Minimizer.h; MinuitParameter.h; MnApplication.h; MnConfig.h; MnContours.h; MnCovarianceSqueeze.h; MnCross.h; MnEigen.h; MnFcn.h; MnFumiliMinimize.h; MnFunctionCross.h; MnGlobalCorrelationCoeff.h; MnHesse.h; MnLineSearch.h; MnMachinePrecision.h; MnMatrix.h; MnMatrixfwd.h; MnMigrad.h; MnMinimize.h; MnMinos.h; MnParabola.h; MnParabolaFactory.h; MnParabolaPoint.h; MnParameterScan.h; MnPlot.h; MnPosDef.h; MnPrint.h; MnScan.h; MnSeedGenerator.h; MnSimplex.h; MnStrategy.h; MnTiny.h; MnTraceObject.h; MnUserCovariance.h; MnUserFcn.h; MnUserParameterState.h; MnUserParameters.h; MnUserTransformation.h; MnVectorTransform.h; ModularFunctionMinimizer.h; NegativeG2LineSearch.h; Numerical2PGradientCalculator.h; ParametricFunction.h; ScanBuilder.h; ScanMinimizer.h; SimplexBuilder.h; SimplexMinimizer.h; SimplexParameters.h; SimplexSeedGenerator.h; SinParameterTransformation.h; SqrtLowParameterTransformation.h; SqrtUpParameterTransformation.h; StackAllocator.h; VariableMetricBuilder.h; VariableMetricEDMEstimator.h; VariableMetricMinimizer.h; VectorOuterProduct.h; ). set(MINUIT2_SOURCES; AnalyticalGradientCalculator.cxx; BFGSErrorUpdator.cxx; CombinedMinimumBuilder.cxx; DavidonErrorUpdator.cxx; ExternalInternalGradientCalculator.cxx; FumiliBuilder.cxx; FumiliErrorUpdator.cxx; FumiliGradientCalculator.cxx; FumiliMinimizer.cxx; FumiliStandardChi2FCN.cxx; FumiliStandardMaximumLikelihoodFCN.cxx; HessianGradientCalculator.cxx; InitialGradientCalculator.cxx; LaEigenValues.cxx; LaInnerProduct.cxx; LaInverse.cxx; LaOuterProduct.cxx; LaSumOfElements.cxx; LaVtMVSimilarity.cxx; MPIProcess.cxx; MinimumBuilder.cxx; Minuit2Minimizer.cxx; MnApplication.cxx; MnContours.cxx; MnCovarianceSqueeze.cxx; MnEigen.cxx; MnFcn.cxx; MnFumiliMinimize.cxx; MnFunctionCross.cxx; MnGlobalCorrelationCoeff.,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt:1949,Simpl,SimplexMinimizer,1949,math/minuit2/src/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt,1,['Simpl'],['SimplexMinimizer']
Usability,"rStr``' global whenever it; lexes an identifier. Also, since language keywords are matched by the; same loop, we handle them here inline. Numeric values are similar:. .. code-block:: c++. if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+; std::string NumStr;; do {; NumStr += LastChar;; LastChar = getchar();; } while (isdigit(LastChar) || LastChar == '.');. NumVal = strtod(NumStr.c_str(), 0);; return tok_number;; }. This is all pretty straightforward code for processing input. When; reading a numeric value from input, we use the C ``strtod`` function to; convert it to a numeric value that we store in ``NumVal``. Note that; this isn't doing sufficient error checking: it will incorrectly read; ""1.23.45.67"" and handle it as if you typed in ""1.23"". Feel free to; extend it! Next we handle comments:. .. code-block:: c++. if (LastChar == '#') {; // Comment until end of line.; do; LastChar = getchar();; while (LastChar != EOF && LastChar != '\n' && LastChar != '\r');. if (LastChar != EOF); return gettok();; }. We handle comments by skipping to the end of the line and then return; the next token. Finally, if the input doesn't match one of the above; cases, it is either an operator character like '+' or the end of the; file. These are handled with this code:. .. code-block:: c++. // Check for end of file. Don't eat the EOF.; if (LastChar == EOF); return tok_eof;. // Otherwise, just return the character as its ascii value.; int ThisChar = LastChar;; LastChar = getchar();; return ThisChar;; }. With this, we have the complete lexer for the basic Kaleidoscope; language (the `full code listing <LangImpl02.html#full-code-listing>`_ for the Lexer; is available in the `next chapter <LangImpl02.html>`_ of the tutorial).; Next we'll `build a simple parser that uses this to build an Abstract; Syntax Tree <LangImpl02.html>`_. When we have that, we'll include a; driver so that you can use the lexer and parser together. `Next: Implementing a Parser and AST <LangImpl02.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst:6224,simpl,simple,6224,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,1,['simpl'],['simple']
Usability,"rUpdator.cxx; FumiliGradientCalculator.cxx; FumiliMinimizer.cxx; FumiliStandardChi2FCN.cxx; FumiliStandardMaximumLikelihoodFCN.cxx; HessianGradientCalculator.cxx; InitialGradientCalculator.cxx; LaEigenValues.cxx; LaInnerProduct.cxx; LaInverse.cxx; LaOuterProduct.cxx; LaSumOfElements.cxx; LaVtMVSimilarity.cxx; MPIProcess.cxx; MinimumBuilder.cxx; Minuit2Minimizer.cxx; MnApplication.cxx; MnContours.cxx; MnCovarianceSqueeze.cxx; MnEigen.cxx; MnFcn.cxx; MnFumiliMinimize.cxx; MnFunctionCross.cxx; MnGlobalCorrelationCoeff.cxx; MnHesse.cxx; MnLineSearch.cxx; MnMachinePrecision.cxx; MnMinos.cxx; MnParabolaFactory.cxx; MnParameterScan.cxx; MnPlot.cxx; MnPosDef.cxx; MnPrint.cxx; MnPrintImpl.cxx; MnScan.cxx; MnSeedGenerator.cxx; MnStrategy.cxx; MnTiny.cxx; MnTraceObject.cxx; MnUserFcn.cxx; MnUserParameterState.cxx; MnUserParameters.cxx; MnUserTransformation.cxx; ModularFunctionMinimizer.cxx; NegativeG2LineSearch.cxx; Numerical2PGradientCalculator.cxx; ParametricFunction.cxx; ScanBuilder.cxx; SimplexBuilder.cxx; SimplexParameters.cxx; SimplexSeedGenerator.cxx; SinParameterTransformation.cxx; SqrtLowParameterTransformation.cxx; SqrtUpParameterTransformation.cxx; VariableMetricBuilder.cxx; VariableMetricEDMEstimator.cxx; mnbins.cxx; mndasum.cxx; mndaxpy.cxx; mnddot.cxx; mndscal.cxx; mndspmv.cxx; mndspr.cxx; mnlsame.cxx; mnteigen.cxx; mntplot.cxx; mnvert.cxx; mnxerbla.cxx; ). prepend_path(MINUIT2_HEADERS ""${Minuit2_SOURCE_DIR}/inc/Minuit2"" ${MINUIT2_HEADERS}); prepend_path(MINUIT2_SOURCES ""${CMAKE_CURRENT_SOURCE_DIR}"" ${MINUIT2_SOURCES}). add_library(Minuit2; ${MINUIT2_SOURCES}; ${MINUIT2_HEADERS}; ). # Add alias for direct inclusion with add_subdirectory; add_library(Minuit2::Minuit2 ALIAS Minuit2). target_include_directories(; Minuit2; PUBLIC; $<BUILD_INTERFACE:${Minuit2_SOURCE_DIR}/inc>; $<INSTALL_INTERFACE:include/Minuit2>; ). target_compile_features(Minuit2 PUBLIC cxx_nullptr cxx_nonstatic_member_init); set_target_properties(Minuit2 PROPERTIES CXX_EXTENSIONS OFF). target_link_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt:3430,Simpl,SimplexBuilder,3430,math/minuit2/src/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt,1,['Simpl'],['SimplexBuilder']
Usability,"radientCalculator.cxx; FumiliMinimizer.cxx; FumiliStandardChi2FCN.cxx; FumiliStandardMaximumLikelihoodFCN.cxx; HessianGradientCalculator.cxx; InitialGradientCalculator.cxx; LaEigenValues.cxx; LaInnerProduct.cxx; LaInverse.cxx; LaOuterProduct.cxx; LaSumOfElements.cxx; LaVtMVSimilarity.cxx; MPIProcess.cxx; MinimumBuilder.cxx; Minuit2Minimizer.cxx; MnApplication.cxx; MnContours.cxx; MnCovarianceSqueeze.cxx; MnEigen.cxx; MnFcn.cxx; MnFumiliMinimize.cxx; MnFunctionCross.cxx; MnGlobalCorrelationCoeff.cxx; MnHesse.cxx; MnLineSearch.cxx; MnMachinePrecision.cxx; MnMinos.cxx; MnParabolaFactory.cxx; MnParameterScan.cxx; MnPlot.cxx; MnPosDef.cxx; MnPrint.cxx; MnPrintImpl.cxx; MnScan.cxx; MnSeedGenerator.cxx; MnStrategy.cxx; MnTiny.cxx; MnTraceObject.cxx; MnUserFcn.cxx; MnUserParameterState.cxx; MnUserParameters.cxx; MnUserTransformation.cxx; ModularFunctionMinimizer.cxx; NegativeG2LineSearch.cxx; Numerical2PGradientCalculator.cxx; ParametricFunction.cxx; ScanBuilder.cxx; SimplexBuilder.cxx; SimplexParameters.cxx; SimplexSeedGenerator.cxx; SinParameterTransformation.cxx; SqrtLowParameterTransformation.cxx; SqrtUpParameterTransformation.cxx; VariableMetricBuilder.cxx; VariableMetricEDMEstimator.cxx; mnbins.cxx; mndasum.cxx; mndaxpy.cxx; mnddot.cxx; mndscal.cxx; mndspmv.cxx; mndspr.cxx; mnlsame.cxx; mnteigen.cxx; mntplot.cxx; mnvert.cxx; mnxerbla.cxx; ). prepend_path(MINUIT2_HEADERS ""${Minuit2_SOURCE_DIR}/inc/Minuit2"" ${MINUIT2_HEADERS}); prepend_path(MINUIT2_SOURCES ""${CMAKE_CURRENT_SOURCE_DIR}"" ${MINUIT2_SOURCES}). add_library(Minuit2; ${MINUIT2_SOURCES}; ${MINUIT2_HEADERS}; ). # Add alias for direct inclusion with add_subdirectory; add_library(Minuit2::Minuit2 ALIAS Minuit2). target_include_directories(; Minuit2; PUBLIC; $<BUILD_INTERFACE:${Minuit2_SOURCE_DIR}/inc>; $<INSTALL_INTERFACE:include/Minuit2>; ). target_compile_features(Minuit2 PUBLIC cxx_nullptr cxx_nonstatic_member_init); set_target_properties(Minuit2 PROPERTIES CXX_EXTENSIONS OFF). target_link_libraries(Minuit2 PUBL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt:3450,Simpl,SimplexParameters,3450,math/minuit2/src/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt,1,['Simpl'],['SimplexParameters']
Usability,"ral (like 1.0), ``NumVal`` holds its; value. We use global variables for simplicity, but this is not the; best choice for a real language implementation :). The actual implementation of the lexer is a single function named; ``gettok``. The ``gettok`` function is called to return the next token; from standard input. Its definition starts as:. .. code-block:: c++. /// gettok - Return the next token from standard input.; static int gettok() {; static int LastChar = ' ';. // Skip any whitespace.; while (isspace(LastChar)); LastChar = getchar();. ``gettok`` works by calling the C ``getchar()`` function to read; characters one at a time from standard input. It eats them as it; recognizes them and stores the last character read, but not processed,; in LastChar. The first thing that it has to do is ignore whitespace; between tokens. This is accomplished with the loop above. The next thing ``gettok`` needs to do is recognize identifiers and; specific keywords like ""def"". Kaleidoscope does this with this simple; loop:. .. code-block:: c++. if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]*; IdentifierStr = LastChar;; while (isalnum((LastChar = getchar()))); IdentifierStr += LastChar;. if (IdentifierStr == ""def""); return tok_def;; if (IdentifierStr == ""extern""); return tok_extern;; return tok_identifier;; }. Note that this code sets the '``IdentifierStr``' global whenever it; lexes an identifier. Also, since language keywords are matched by the; same loop, we handle them here inline. Numeric values are similar:. .. code-block:: c++. if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+; std::string NumStr;; do {; NumStr += LastChar;; LastChar = getchar();; } while (isdigit(LastChar) || LastChar == '.');. NumVal = strtod(NumStr.c_str(), 0);; return tok_number;; }. This is all pretty straightforward code for processing input. When; reading a numeric value from input, we use the C ``strtod`` function to; convert it to a numeric value that we store in ``NumVal``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst:4100,simpl,simple,4100,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,1,['simpl'],['simple']
Usability,"ral generations of machines. Okay, that comment is removed. > and is more compact than uint. No, it isn't. Remember that the bytecode encoding saves value slots into; the bytecode instructions themselves, not constant values. This is; another case where we may introduce more cast instructions (but we will; also reduce the number of opcode variants that must be supported by a; virtual machine). Because most shifts are by constant values, I don't; think that we'll have to cast many shifts. :). > I still have some major concerns about including malloc and free in the; > language (either as builtin functions or instructions). Agreed. How about this proposal:. malloc/free are either built in functions or actual opcodes. They provide; all of the type safety that the document would indicate, blah blah; blah. :). Now, because of all of the excellent points that you raised, an; implementation may want to override the default malloc/free behavior of; the program. To do this, they simply implement a ""malloc"" and; ""free"" function. The virtual machine will then be defined to use the user; defined malloc/free function (which return/take void*'s, not type'd; pointers like the builtin function would) if one is available, otherwise; fall back on a system malloc/free. Does this sound like a good compromise? It would give us all of the; typesafety/elegance in the language while still allowing the user to do; all the cool stuff they want to... > 'alloca' on the other hand sounds like a good idea, and the; > implementation seems fairly language-independent so it doesn't have the; > problems with malloc listed above. Okay, once we get the above stuff figured out, I'll put it all in the; spec. > About indirect call:; > Your option #2 sounded good to me. I'm not sure I understand your; > concern about an explicit 'icall' instruction?. I worry too much. :) The other alternative has been removed. 'icall' is; now up in the instruction list next to 'call'. > I believe tail calls are relatively ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:4411,simpl,simply,4411,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['simpl'],['simply']
Usability,"rame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost any GUI-application in; ROOT and it is important to understand how it is constructed. The; example program is written as a named script. See ""Cling the C++; Interpreter"". Remember that the named script can be executed via. ``` {.cpp}; root[] .x example.C; ```. only if the filename (without extension) and the function entry point; are both the same. ![](pictures/02000202.jpg). We need to say a few words about the parent-children relationship; between the widgets before going through the real code. The widgets'; behaviors are based on this relationship. Every parent widget is; res",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2702,Simpl,Simple,2702,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['Simpl'],['Simple']
Usability,"ranch target injection; * GPZ Variant #3 (a.k.a. Meltdown): Rogue data cache load. For more details, see the Google Project Zero blog post and the Spectre research; paper:; * https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html; * https://spectreattack.com/spectre.pdf. The core problem of GPZ Variant #1 is that speculative execution uses branch; prediction to select the path of instructions speculatively executed. This path; is speculatively executed with the available data, and may load from memory and; leak the loaded values through various side channels that survive even when the; speculative execution is unwound due to being incorrect. Mispredicted paths can; cause code to be executed with data inputs that never occur in correct; executions, making checks against malicious inputs ineffective and allowing; attackers to use malicious data inputs to leak secret data. Here is an example,; extracted and simplified from the Project Zero paper:; ```; struct array {; unsigned long length;; unsigned char data[];; };; struct array *arr1 = ...; // small array; struct array *arr2 = ...; // array of size 0x400; unsigned long untrusted_offset_from_caller = ...;; if (untrusted_offset_from_caller < arr1->length) {; unsigned char value = arr1->data[untrusted_offset_from_caller];; unsigned long index2 = ((value&1)*0x100)+0x200;; unsigned char value2 = arr2->data[index2];; }; ```. The key of the attack is to call this with `untrusted_offset_from_caller` that; is far outside of the bounds when the branch predictor will predict that it; will be in-bounds. In that case, the body of the `if` will be executed; speculatively, and may read secret data into `value` and leak it via a; cache-timing side channel when a dependent access is made to populate `value2`. ## High Level Mitigation Approach. While several approaches are being actively pursued to mitigate specific; branches and/or loads inside especially risky software (most notably various OS; kerne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:1471,simpl,simplified,1471,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simplified']
Usability,"range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/SparseSet.h; ^^^^^^^^^^^^^^^^^^^^. SparseSet holds a small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physical registers, virtual registers, or; numbered basic blocks. SparseSet is useful for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet's; desirable attributes. Like SparseSet, it typically uses a lot of memory, but; provides operations that are almost as fast as a vector. Typical keys are; physical registers, virtual registers, or numbered basic blocks. SparseMultiSet is useful for algorithms that need very fast; clear/find/insert/erase of the entire collection, and iteration over sets of; elements sharing a key. It is often a more efficient choice than using composite; data structures (e.g. vector-of-vectors, map-of-vectors). It is not intended for; building composite data structures. .. _dss_FoldingSet:. llvm/ADT/FoldingSet.h; ^^^^^^^^^^^^^^^^^^^^^. FoldingSet is an aggregate class that is really good at uniquing; expensive-to-create or polym",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:80830,clear,clear,80830,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['clear'],['clear']
Usability,"rap 0x00`` Reserved by hardware.; debugger breakpoint ``s_trap 0x01`` *none* *none* Reserved for debugger to use for; breakpoints. Causes wave to be halted; with the PC at the trap instruction.; The debugger is responsible to resume; the wave, including the instruction; that the breakpoint overwrote.; ``llvm.trap`` ``s_trap 0x02`` ``SGPR0-1``: *none* Causes wave to be halted with the PC at; ``queue_ptr`` the trap instruction. The associated; queue is signalled to put it into the; error state. When the queue is put in; the error state, the waves executing; dispatches on the queue will be; terminated.; ``llvm.debugtrap`` ``s_trap 0x03`` *none* *none* - If debugger not enabled then behaves; as a no-operation. The trap handler; is entered and immediately returns to; continue execution of the wavefront.; - If the debugger is enabled, causes; the debug trap to be reported by the; debugger and the wavefront is put in; the halt state with the PC at the; instruction. The debugger must; increment the PC and resume the wave.; reserved ``s_trap 0x04`` Reserved.; reserved ``s_trap 0x05`` Reserved.; reserved ``s_trap 0x06`` Reserved.; reserved ``s_trap 0x07`` Reserved.; reserved ``s_trap 0x08`` Reserved.; reserved ``s_trap 0xfe`` Reserved.; reserved ``s_trap 0xff`` Reserved.; =================== =============== ================ ================= =======================================. .. _amdgpu-amdhsa-function-call-convention:. Call Convention; ~~~~~~~~~~~~~~~. .. note::. This section is currently incomplete and has inaccuracies. It is WIP that will; be updated as information is determined. See :ref:`amdgpu-dwarf-address-space-identifier` for information on swizzled; addresses. Unswizzled addresses are normal linear addresses. .. _amdgpu-amdhsa-function-call-convention-kernel-functions:. Kernel Functions; ++++++++++++++++. This section describes the call convention ABI for the outer kernel function. See :ref:`amdgpu-amdhsa-initial-kernel-execution-state` for the kernel call; con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:385425,resume,resume,385425,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['resume'],['resume']
Usability,"rate over ; the instlist, and access the instructions through the instlist. To add or remove an instruction from a basic block, we need to get an ; iterator to an instruction, which, given just an Instruction*, requires a ; linear search of the basic block the instruction is contained in... just ; to insert an instruction before another instruction, or to delete an ; instruction! This complicates algorithms that should be very simple (like ; simple constant propagation), because they aren't actually sparse anymore,; they have to traverse basic blocks to remove constant propogated ; instructions. Additionally, adding or removing instructions to a basic block ; _invalidates all iterators_ pointing into that block, which is really ; irritating. To fix these problems (and others), I would like to make the ordering of; the instructions be represented with a doubly linked list in the; instructions themselves, instead of an external data structure. This is ; how many other representations do it, and frankly I can't remember why I ; originally implemented it the way I did. Long term, all of the code that depends on the nasty features in the ; instruction list (which can be found by grep'ing for getInstList()) will ; be changed to do nice local transformations. In the short term, I'll ; change the representation, but preserve the interface (including ; getInstList()) so that all of the code doesn't have to change. Iteration over the instructions in a basic block remains the simple:; for (BasicBlock::iterator I = BB->begin(), E = BB->end(); I != E; ++I) ... But we will also support:; for (Instruction *I = BB->front(); I; I = I->getNext()) ... After converting instructions over, I'll convert basic blocks and ; functions to have a similar interface. The only negative aspect of this change that I see is that it increases ; the amount of memory consumed by one pointer per instruction. Given the ; benefits, I think this is a very reasonable tradeoff. . What do you think?. -Chris; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt:2009,simpl,simple,2009,interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt,1,['simpl'],['simple']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ArraySubscriptExpr>hasBaseMatcher<Expr> InnerMatcher; Matches the base expression of an array subscript expression. Given; int i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasBase(implicitCastExpr(; hasSourceExpression(declRefExpr())))); matches i[1] with the declRefExpr() matching i. Matcher<ArraySubscriptExpr>hasIndexMatcher<Expr> InnerMatcher; Matches the index expression of an array subscript expression. Given; int i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasIndex(integerLiteral())); matches i[1] with the integerLiteral() matching 1. Matcher<ArraySubscriptExpr>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<ArraySubscriptExpr>hasRHSMa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:138506,Usab,Usable,138506,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CXXConstructorDecl>forEachConstructorInitializerMatcher<CXXCtorInitializer> InnerMatcher; Matches each constructor initializer in a constructor definition. Given; class A { A() : i(42), j(42) {} int i; int j; };; cxxConstructorDecl(forEachConstructorInitializer(; forField(decl().bind(""x"")); )); will trigger two matches, binding for 'i' and 'j' respectively. Matcher<CXXConstructorDecl>hasAnyConstructorInitializerMatcher<CXXCtorInitializer> InnerMatcher; Matches a constructor initializer. Given; struct Foo {; Foo() : foo_(1) { }; int foo_;; };; cxxRecordDecl(has(cxxConstructorDecl(; hasAnyConstructorInitializer(anything()); ))); record matches Foo, hasAnyConstructorInitializer matches foo_(1). Matcher<CXXCtorInitializer>forFieldMatcher<FieldDecl> InnerMatcher; Matches the field decl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:150053,Usab,Usable,150053,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CXXNewExpr>hasPlacementArgunsigned Index, Matcher<Expr> InnerMatcher; Matches placement new expression arguments. Given:; MyClass *p1 = new (Storage, 16) MyClass();; cxxNewExpr(hasPlacementArg(1, integerLiteral(equals(16)))); matches the expression 'new (Storage, 16) MyClass()'. Matcher<CXXNewExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:163157,Usab,Usable,163157,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CaseStmt>hasCaseConstantMatcher<Expr> InnerMatcher; If the given case statement does not use the GNU case range; extension, matches the constant given in the statement. Given; switch (1) { case 1: case 1+1: case 3 ... 4: ; }; caseStmt(hasCaseConstant(integerLiteral())); matches ""case 1:"". Matcher<CastExpr>hasSourceExpressionMatcher<Expr> InnerMatcher; Matches if the cast's source expression; or opaque value's source expression matches the given matcher. Example 1: matches ""a string""; (matcher = castExpr(hasSourceExpression(cxxConstructExpr()))); class URL { URL(string); };; URL url = ""a string"";. Example 2: matches 'b' (matcher =; opaqueValueExpr(hasSourceExpression(implicitCastExpr(declRefExpr()))); int a = b ?: 1;. Matcher<ClassTemplateSpecializationDecl>forEachTemplateArgumentc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:176352,Usab,Usable,176352,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<DeclRefExpr>hasTemplateArgumentLocunsigned Index, Matcher<TemplateArgumentLoc> InnerMatcher; Matches template specialization `TypeLoc`s where the n'th; `TemplateArgumentLoc` matches the given `InnerMatcher`. Given; template<typename T, typename U> class A {};; A<double, int> b;; A<int, double> c;; varDecl(hasTypeLoc(templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,; hasTypeLoc(loc(asString(""double""))))))); matches `A<double, int> b`, but not `A<int, double> c`. Matcher<DeclRefExpr>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:; namespace a { int f(); }; using a::f;; int x = f();; declRefExpr(throughUsingDecl(anything())); matches f. namespace a { class X{}; }; using a::X;; X x;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:184066,Usab,Usable,184066,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ExplicitCastExpr>hasDestinationTypeMatcher<QualType> InnerMatcher; Matches casts whose destination type matches a given matcher. (Note: Clang's AST refers to other conversions as ""casts"" too, and calls; actual casts ""explicit"" casts.). Matcher<ExplicitCastExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:191564,Usab,Usable,191564,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LabelStmt>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be ach",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:210007,Usab,Usable,210007,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LambdaCapture>capturesVarMatcher<ValueDecl> InnerMatcher; Matches a `LambdaCapture` that refers to the specified `VarDecl`. The; `VarDecl` can be a separate variable that is captured by value or; reference, or a synthesized variable if the capture has an initializer. Given; void foo() {; int x;; auto f = [x](){};; auto g = [x = 1](){};; }; In the matcher; lambdaExpr(hasAnyCapture(lambdaCapture(capturesVar(hasName(""x"")))),; capturesVar(hasName(""x"")) matches `x` and `x = 1`. Matcher<LambdaExpr>forEachLambdaCaptureMatcher<LambdaCapture> InnerMatcher; Matches each lambda capture in a lambda expression. Given; int main() {; int x, y;; float z;; auto f = [=]() { return x + y + z; };; }; lambdaExpr(forEachLambdaCapture(; lambdaCapture(capturesVar(varDecl(hasType(isInteger())))))); will t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:211415,Usab,Usable,211415,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<MemberExpr>hasObjectExpressionMatcher<Expr> InnerMatcher; Matches a member expression where the object expression is matched by a; given matcher. Implicit object expressions are included; that is, it matches; use of implicit `this`. Given; struct X {; int m;; int f(X x) { x.m; return m; }; };; memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName(""X""))))); matches `x.m`, but not `m`; however,; memberExpr(hasObjectExpression(hasType(pointsTo(; cxxRecordDecl(hasName(""X"")))))); matches `m` (aka. `this->m`), but not `x.m`. Matcher<MemberExpr>memberMatcher<ValueDecl> InnerMatcher; Matches a member expression where the member is matched by a; given matcher. Given; struct { int first, second; } first, second;; int i(second.first);; int j(first.second);; memberExpr(member(hasName(""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:214014,Usab,Usable,214014,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<QualType>ignoringParensMatcher<QualType> InnerMatcher; Matches types that match InnerMatcher after any parens are stripped. Given; void (*fp)(void);; The matcher; varDecl(hasType(pointerType(pointee(ignoringParens(functionType()))))); would match the declaration for fp. Matcher<QualType>pointsToMatcher<Decl> InnerMatcher; Overloaded to match the pointee type's declaration. Matcher<QualType>pointsToMatcher<QualType> InnerMatcher; Matches if the matched type is a pointer type and the pointee type; matches the specified matcher. Example matches y->x(); (matcher = cxxMemberCallExpr(on(hasType(pointsTo; cxxRecordDecl(hasName(""Y""))))))); class Y { public: void x(); };; void z() { Y *y; y->x(); }. Matcher<QualType>referencesMatcher<Decl> InnerMatcher; Overloaded to match the referenced t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:227398,Usab,Usable,227398,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ReferenceTypeLoc>hasReferentLocMatcher<TypeLoc> ReferentMatcher; Matches reference `TypeLoc`s that have a referent `TypeLoc` matching; `ReferentMatcher`. Given; int x = 3;; int& xx = x;; referenceTypeLoc(hasReferentLoc(loc(asString(""int"")))); matches `int&`. Matcher<ReferenceType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<ReturnStmt>hasReturnValueMatcher<Expr> InnerMatcher; Matches the return value expression of a return statement. Given; return a + b;; hasReturnV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:230281,Usab,Usable,230281,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TemplateArgumentLoc>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropert",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:236153,Usab,Usable,236153,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TemplateSpecializationType>hasTemplateArgumentunsigned N, Matcher<TemplateArgument> InnerMatcher; Matches classTemplateSpecializations, templateSpecializationType and; functionDecl where the n'th TemplateArgument matches the given InnerMatcher. Given; template<typename T, typename U> class A {};; A<bool, int> b;; A<int, bool> c;. template<typename T> void f() {}; void func() { f<int>(); };; classTemplateSpecializationDecl(hasTemplateArgument(; 1, refersToType(asString(""int"")))); matches the specialization A<bool, int>. functionDecl(hasTemplateArgument(0, refersToType(asString(""int"")))); matches the specialization f<int>. Matcher<TemplateTypeParmType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:242698,Usab,Usable,242698,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<Type>hasUnqualifiedDesugaredTypeMatcher<Type> InnerMatcher; Matches if the matched type matches the unqualified desugared; type of the matched node. For example, in:; class A {};; using B = A;; The matcher type(hasUnqualifiedDesugaredType(recordType())) matches; both B and A. Matcher<UnaryExprOrTypeTraitExpr>hasArgumentOfTypeMatcher<QualType> InnerMatcher; Matches unary expressions that have a specific type of argument. Given; int a, c; float b; int s = sizeof(a) + sizeof(b) + alignof(c);; unaryExprOrTypeTraitExpr(hasArgumentOfType(asString(""int"")); matches sizeof(a) and alignof(c). Matcher<UnaryOperator>hasUnaryOperandMatcher<Expr> InnerMatcher; Matches if the operand of a unary operator matches. Example matches true (matcher = hasUnaryOperand(; cxxBoolLiteral(equals(true)))); !t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:247733,Usab,Usable,247733,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TypeLoc>locMatcher<QualType> InnerMatcher; Matches TypeLocs for which the given inner; QualType-matcher matches. Matcher<TypedefNameDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecial",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:244754,Usab,Usable,244754,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<UsingShadowDecl>hasTargetDeclMatcher<NamedDecl> InnerMatcher; Matches a using shadow declaration where the target declaration is; matched by the given matcher. Given; namespace X { int a; void b(); }; using X::a;; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl()))); matches using X::b but not using X::a ; Matcher<UsingType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<UsingType>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:250505,Usab,Usable,250505,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ration that created L.*. * If D has a ``DW_AT_const_value`` attribute, then an implicit location; storage RLS is created from the ``DW_AT_const_value`` attribute's value; with a size matching the size of the ``DW_AT_const_value`` attribute's; value. RL comprises one implicit location description SRL. SRL specifies; RLS with a bit offset of 0. .. note::. If using ``DW_AT_const_value`` for variables and formal parameters is; deprecated and instead ``DW_AT_location`` is used with an implicit; location description, then this rule would not be required. * Otherwise, it is an evaluation error. The bit offset of RL is updated as if the ``DW_OP_LLVM_offset_uconst B``; operation was applied. If a ``DW_OP_stack_value`` operation pops a value that is the same as IPV,; then it pushes a location description that is the same as L. It is an evaluation error if LS or IPV is accessed in any other manner. *The restrictions on how an implicit pointer location description created; by* ``DW_OP_implicit_pointer`` *and* ``DW_OP_LLVM_aspace_implicit_pointer``; *can be used are to simplify the DWARF consumer. Similarly, for an implicit; pointer value created by* ``DW_OP_deref*`` *and* ``DW_OP_stack_value``\ *.*. 4. ``DW_OP_LLVM_aspace_implicit_pointer`` *New*. ``DW_OP_LLVM_aspace_implicit_pointer`` has two operands that are the same as; for ``DW_OP_implicit_pointer``. It pops one stack entry that must be an integral type value that represents; a target architecture specific address space identifier AS. The location description L that is pushed on the stack is the same as for; ``DW_OP_implicit_pointer``, except that the address space identifier used is; AS. The DWARF expression is ill-formed if AS is not one of the values defined by; the target architecture specific ``DW_ASPACE_LLVM_*`` values. .. note::. This definition of ``DW_OP_LLVM_aspace_implicit_pointer`` may change when; full support for address classes is added as required for languages such; as OpenCL/SyCL. *Typically a* ``DW_OP_imp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:127359,simpl,simplify,127359,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simplify']
Usability,"rator tables that are optimized for very quick lookups will benefit this; type of debugging experience greatly. We would like to generate name lookup tables that can be mapped into memory; from disk, and used as is, with little or no up-front parsing. We would also; be able to control the exact content of these different tables so they contain; exactly what we need. The Name Accelerator Tables were designed to fix these; issues. In order to solve these issues we need to:. * Have a format that can be mapped into memory from disk and used as is; * Lookups should be very fast; * Extensible table format so these tables can be made by many producers; * Contain all of the names needed for typical lookups out of the box; * Strict rules for the contents of tables. Table size is important and the accelerator table format should allow the reuse; of strings from common string tables so the strings for the names are not; duplicated. We also want to make sure the table is ready to be used as-is by; simply mapping the table into memory with minimal header parsing. The name lookups need to be fast and optimized for the kinds of lookups that; debuggers tend to do. Optimally we would like to touch as few parts of the; mapped table as possible when doing a name lookup and be able to quickly find; the name entry we are looking for, or discover there are no matches. In the; case of debuggers we optimized for lookups that fail most of the time. Each table that is defined should have strict rules on exactly what is in the; accelerator tables and documented so clients can rely on the content. Hash Tables; ^^^^^^^^^^^. Standard Hash Tables; """""""""""""""""""""""""""""""""""""""". Typical hash tables have a header, buckets, and each bucket points to the; bucket contents:. .. code-block:: none. .------------.; | HEADER |; |------------|; | BUCKETS |; |------------|; | DATA |; `------------'. The BUCKETS are an array of offsets to DATA for each hash:. .. code-block:: none. .------------.; | 0x00001000 | BUCKET",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:60205,simpl,simply,60205,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['simpl'],['simply']
Usability,"rator())); if (a == b); a += b;. Example 2: matches s1 < s2; (matcher = cxxOperatorCallExpr(isComparisonOperator())); struct S { bool operator<(const S& other); };; void x(S s1, S s2) { bool b1 = s1 < s2; }. Matcher<CXXRecordDecl>hasDefinition; Matches a class declaration that is defined. Example matches x (matcher = cxxRecordDecl(hasDefinition())); class x {};; class y;. Matcher<CXXRecordDecl>isDerivedFromstd::string BaseName; Overloaded method as shortcut for isDerivedFrom(hasName(...)). Matcher<CXXRecordDecl>isDirectlyDerivedFromstd::string BaseName; Overloaded method as shortcut for isDirectlyDerivedFrom(hasName(...)). Matcher<CXXRecordDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<CXXRecordDecl>isFinal; Matches if the given method or class declaration is final. Given:; class A final {};. struct B {; virtual void f();; };. struct C : B {; void f() final;; };; matches A and C::f, but not B, C, or B::f. Matcher<CXXRecordDecl>isLambda; Matches the generated class of lambda expressions. Given:; auto x = []{};. cxxRecordDecl(isLambda()) matches the implicit class declaration of; decltype(x). Matcher<CXXRecordDecl>isSameOrDerivedFromstd::string BaseName; Overloaded method as shortcut for; isSameOrDerivedFrom(hasName(...)). Matcher<CXXRecordDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateIns",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:73759,Usab,Usable,73759,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"raw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:6256,simpl,simple,6256,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['simpl'],['simple']
Usability,"ray Collection. A **`TObjArray`** is a collection which supports traditional array; semantics via the overloading of `operator[]`. Objects can be directly; accessed via an index. The array expands automatically when objects are; added. At creation time one specifies the default array size (default =; 16) and lower bound (default = 0). Resizing involves a re-allocation and; a copy of the old array to the new. This can be costly if done too; often. If possible, set initial size close to expected final size. Index; validity is always checked (if you are 100% sure and maximum performance; is needed you can use `UnCheckedAt()` instead of `At()` or; `operator[]`). If the stored objects are sort able the array can be; sorted using `Sort()`. Once sorted, efficient searching is possible via; the `BinarySearch()` method. The figure shows the internal data; structure of a **`TObjArray`**:. ![The internal data structure of a TObjArray](pictures/020001A7.jpg). Iterating can be done using a **`TIter`** iterator or via a simple for; loop:. ``` {.cpp}; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; ```. Main features of **`TObjArray`** are simple, well-known array semantics.; **Overhead per element**: none, except possible over sizing of `fCont`. ## TClonesArray An Array of Identical Objects. A **`TClonesArray`** is an array of identical (clone) objects. The; memory for the objects stored in the array is allocated only once in the; lifetime of the clones array. All objects must be of the same class. For; the rest this class has the same properties as a **`TObjArray`**. ![The internal data structure of a TClonesArray](pictures/020001A8.jpg). The figure above shows the internal data structure of a; **`TClonesArray`**. The class is specially designed for repetitive data; analysis tasks, where in a loop many times the same objects, are created; and deleted. The only supported way to add objects to a; **`TClonesArray`** is via",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:15784,simpl,simple,15784,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['simpl'],['simple']
Usability,"rbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NCycles No 200 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture (N stands for number of variables; any integers may also be used). ValidationFraction No 0.5 − Fraction of events in training tree used for cross validation. LearningMethod No Stochastic Stochastic, Batch, SteepestDescent, RibierePolak, FletcherReeves, BFGS Learning method. Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: Simulated Annealing (SA). Option Array Default value Predefined values Description. MaxCalls No 100000 − Maximum number of minimisation calls. InitialTemp No 1e+06 − Initial temperature. MinTemp No 1e-06 − Mimimum temperature. Eps No 1e-10 − Epsilon. TempScale No 1 − Temperature scale. AdaptiveSpeed No 1 − Adaptive speed. TempAdaptiveStep No 0.009875 − Step made in each generation temperature adaptive. UseDefaultScale No False − Use default temperature scale for temperature minimisation algorithm. UseDefaultTemp No False − Use default initial temperature. KernelTemp No IncAdaptive IncAdaptive, DecAdaptive, Sqrt, Log, Sin, Homo, Geo Temperature minimisation algorithm. Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: Monte Carlo sampling (MC). Opti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:28989,Learn,LearningMethod,28989,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,2,['Learn'],"['Learning', 'LearningMethod']"
Usability,"rds. Even so, some fields of concrete; records may remain uninitialized. TableGen provides *multiclasses* to collect a group of record definitions in; one place. A multiclass is a sort of macro that can be ""invoked"" to define; multiple concrete records all at once. A multiclass can inherit from other; multiclasses, which means that the multiclass inherits all the definitions; from its parent multiclasses. `Appendix C: Sample Record`_ illustrates a complex record in the Intel X86; target and the simple way in which it is defined. Source Files; ============. TableGen source files are plain ASCII text files. The files can contain; statements, comments, and blank lines (see `Lexical Analysis`_). The standard file; extension for TableGen files is ``.td``. TableGen files can grow quite large, so there is an include mechanism that; allows one file to include the content of another file (see `Include; Files`_). This allows large files to be broken up into smaller ones, and; also provides a simple library mechanism where multiple source files can; include the same library file. TableGen supports a simple preprocessor that can be used to conditionalize; portions of ``.td`` files. See `Preprocessing Facilities`_ for more; information. Lexical Analysis; ================. The lexical and syntax notation used here is intended to imitate; `Python's`_ notation. In particular, for lexical definitions, the productions; operate at the character level and there is no implied whitespace between; elements. The syntax definitions operate at the token level, so there is; implied whitespace between tokens. .. _`Python's`: http://docs.python.org/py3k/reference/introduction.html#notation. TableGen supports BCPL-style comments (``// ...``) and nestable C-style; comments (``/* ... */``).; TableGen also provides simple `Preprocessing Facilities`_. Formfeed characters may be used freely in files to produce page breaks when; the file is printed for review. The following are the basic punctuation to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:6155,simpl,simple,6155,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"rdware; extension that would add native support to use a shadow stack to store/check; return addresses at call/return time. Being a hardware implementation, it; would not suffer from race conditions and would not incur the overhead of; function instrumentation, but it does require operating system support. .. _`Return Flow Guard`: https://xlab.tencent.com/en/2016/11/02/return-flow-guard/; .. _`Control-flow Enforcement Technology`: https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf. Compatibility; -------------. A runtime is not provided in compiler-rt so one must be provided by the; compiled application or the operating system. Integrating the runtime into; the operating system should be preferred since otherwise all thread creation; and destruction would need to be intercepted by the application. The instrumentation makes use of the platform register ``x18`` on AArch64 and; ``x3`` (``gp``) on RISC-V. For simplicity we will refer to this as the; ``SCSReg``. On some platforms, ``SCSReg`` is reserved, and on others, it is; designated as a scratch register. This generally means that any code that may; run on the same thread as code compiled with ShadowCallStack must either target; one of the platforms whose ABI reserves ``SCSReg`` (currently Android, Darwin,; Fuchsia and Windows) or be compiled with a flag to reserve that register (e.g.,; ``-ffixed-x18``). If absolutely necessary, code compiled without reserving the; register may be run on the same thread as code that uses ShadowCallStack by; saving the register value temporarily on the stack (`example in Android`_) but; this should be done with care since it risks leaking the shadow call stack; address. .. _`example in Android`: https://android-review.googlesource.com/c/platform/frameworks/base/+/803717. Because it requires a dedicated register, the ShadowCallStack feature is; incompatible with any other feature that may use ``SCSReg``. However, there is; no inh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:2898,simpl,simplicity,2898,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['simpl'],['simplicity']
Usability,"re deemed too invasive. #. *Before RC2* Patches should be limited to bug fixes or backend specific; improvements that are determined to be very safe. #. *Before RC3/Final Major Release* Patches should be limited to critical; bugs or regressions. #. *Bug fix releases* Patches should be limited to bug fixes or very safe; and critical performance improvements. Patches must maintain both API and; ABI compatibility with the previous major release. Release Final Tasks; -------------------. The final stages of the release process involves tagging the ""final"" release; branch, updating documentation that refers to the release, and updating the; demo page. Update Documentation; ^^^^^^^^^^^^^^^^^^^^. Review the documentation in the release branch and ensure that it is up; to date. The ""Release Notes"" must be updated to reflect new features, bug; fixes, new known issues, and changes in the list of supported platforms.; The ""Getting Started Guide"" should be updated to reflect the new release; version number tag available from Subversion and changes in basic system; requirements. .. _tag:. Tag the LLVM Final Release; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Tag the final release sources:. ::. $ git tag -sa llvmorg-X.Y.Z; $ git push https://github.com/llvm/llvm-project.git llvmorg-X.Y.Z. Update the LLVM Website; ^^^^^^^^^^^^^^^^^^^^^^^. The website must be updated before the release announcement is sent out. Here; is what to do:. #. Check out the ``www-releases`` module from GitHub. #. Create a new sub-directory ``X.Y.Z`` in the releases directory. #. Copy and commit the ``llvm/docs`` and ``LICENSE.txt`` files into this new; directory. #. Update the ``releases/download.html`` file with links to the release; binaries on GitHub. #. Update the ``releases/index.html`` with the new release and link to release; documentation. #. After you push the changes to the www-releases repo, someone with admin; access must login to prereleases-origin.llvm.org and manually pull the new; changes into /data/www-re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:14188,Guid,Guide,14188,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['Guid'],['Guide']
Usability,"re dozens of passes inside the compiler, each of these flags; take a regular expression that identifies the name of the pass which should; emit the associated diagnostic. For example, to get a report from the inliner,; compile the code with:. .. code-block:: console. $ clang -O2 -Rpass=inline code.cc -o code; code.cc:4:25: remark: foo inlined into bar [-Rpass=inline]; int bar(int j) { return foo(j, j - 2); }; ^. Note that remarks from the inliner are identified with `[-Rpass=inline]`.; To request a report from every optimization pass, you should use; `-Rpass=.*` (in fact, you can use any valid POSIX regular; expression). However, do not expect a report from every transformation; made by the compiler. Optimization remarks do not really make sense; outside of the major transformations (e.g., inlining, vectorization,; loop optimizations) and not every optimization pass supports this; feature. Note that when using profile-guided optimization information, profile hotness; information can be included in the remarks (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). Current limitations; ^^^^^^^^^^^^^^^^^^^. 1. Optimization remarks that refer to function names will display the; mangled name of the function. Since these remarks are emitted by the; back end of the compiler, it does not know anything about the input; language, nor its mangling rules. 2. Some source locations are not displayed correctly. The front end has; a more detailed source location tracking than the locations included; in the debug info (e.g., the front end can locate code inside macro; expansions). However, the locations used by `-Rpass` are; translated from debug annotations. That translation can be lossy,; which results in some remarks having no location information. Options to Emit Resource Consumption Reports; --------------------------------------------. These are options that report execution time and consumed memory of different; compilations steps. .. option:: -fproc-stat-r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:25251,guid,guided,25251,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['guid'],['guided']
Usability,"reachable code; 3 . Compute live ranges for CSE; 4 . [t] Jump threading (jumps to jumps with identical or inverse conditions); 5 . [t] CSE; 6 . *** Conversion to SSA ; 7 . [t] SSA Based DCE; 8 . *** Conversion to LLVM; 9 . UnSSA; 10. GCSE; 11. LICM; 12. Strength Reduction; 13. Loop unrolling; 14. [t] CSE; 15. [t] DCE; 16. Instruction combination, register movement, scheduling... etc. I've marked optimizations with a [t] to indicate things that I believe to; be relatively trivial to implement in LLVM itself. The time consuming; things to reimplement would be SSA based PRE, Strength reduction & loop; unrolling... these would be the major things we would miss out on if we; did LLVM creation from tree code [inlining and other high level; optimizations are done on the tree representation]. Given the lack of ""strong"" optimizations that would take a long time to; reimplement, I am leaning a bit more towards creating LLVM from the tree; code. Especially given that SGI has GPL'd their compiler, including many; SSA based optimizations that could be adapted (besides the fact that their; code looks MUCH nicer than GCC :). Even if we choose to do LLVM code emission from RTL, we will almost; certainly want to move LLVM emission from step 8 down until at least CSE; has been rerun... which causes me to wonder if the SSA generation code; will still work (due to global variable dependencies and stuff). I assume; that it can be made to work, but might be a little more involved than we; would like. I'm continuing to look at the Tree -> RTL code. It is pretty gross; because they do some of the translation a statement at a time, and some; of it a function at a time... I'm not quite clear why and how the; distinction is drawn, but it does not appear that there is a wonderful; place to attach extra info. Anyways, I'm proceeding with the RTL -> LLVM conversion phase for now. We; can talk about this more on Monday. Wouldn't it be nice if there were a obvious decision to be made? :). -Chris. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations.txt:2117,clear,clear,2117,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations.txt,1,['clear'],['clear']
Usability,"reated and configured locally by the user, is added; to the input list and recuperated from there on the worker machines for; processing. Any input list setting in the selector itself is not; streamed but temporarly moved to then standard input list, so that user; can use the selector input list as container of processing information; if they find convenient to do so. Process(...) methods with the file; name argument replaced by 'TSelector *' have  introduced where; relevant (TProof, TProofPlayer and their derivatives, TDSet).  ; Add the possibility to force submerging at node level, i.e. one; submerger per physical machine. In this way the network traffic can be; minimized, for example when merging large output files. The new feature; is enabled by setting the Int_t parameter 'PROOF_MergersByHost' (or the; directive 'Proof.MergersByHost') to a non-null value.; Simplify enabling of basic feedback. In TProof::Process, add; support for switches ""fb=name1,name2,name3,... "" or; ""feedback=name1,name2,name3,... "" in the option field. This enables; feedback for the specified objects, creating a TDrawFeedback object; attached to the session. Feedback for the specified objects is disabled; at the end of the query and the created TDrawFeedback is destroyed. The; special name 'stats' enables the three feedback histograms required by; a dedicated new class TStatsFeedback, and uses a TStatsFeedback instead; of TDrawFeedback to display the feedback. . Improvements; ; Add to TProofMgr two static functions to upload files. These; functions are both called UploadFiles and differ in the first argument,; which is used to pass the files to be uploaded. These can be given as a; list (of TFileInfo or TObjString), a directory or specified in a text; file.; Add support for paralell dataset verification. This is; implemented via a dedicated TSelector (TSelVerifyDataSet) which is run; over the list of files in the dataset via TPacketizerFile. The file; order is preserved using the recently i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html:1969,feedback,feedback,1969,proof/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html,1,['feedback'],['feedback']
Usability,"reation of a dictionary; given one (or more) class name(s) and the name(s) of its header files. gInterpreter->GenerateDictionary(""vector<vector<float> >;list<vector<float> >"",""list;vector"");; gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");; This replaces the recommendation of creating a small 'loader.C' script to create the dictionaries. Implement a ShowMembers function for interpreted classes, by querying the interpreter for the data member; information.; In order to fix possible buffer overflow of parent string buffer in TMemberInspector,; the signature of ShowMember() was changed to no longer require (nor request) the; caller to provide a buffer (of length unknown to the callee.); Improve the uniqueness of globally visible symbols to allow for the mixing of; dictionaries with very similar layout. Cont. New functions for TClonesArray:. AbsorbObjects(TClonesArray* otherTCA):; Allows one to directly move the object pointers from otherTCA to the calling; TCA without cloning (copying). The calling TCA takes over ownership of all of; the moved objects. otherTCA is left empty upon return. MultiSort(Int_t nTCs, TClonesArray** tcs):; Sorts multiple TClonesArrays simultaneously using the calling TCA's objects; as the sorting key. New function for TSeqCollection:. QSort(Object **a, Int_t nBs, TObject ***b):; Sort array a of TObject pointers using a quicksort algorithm. Arrays b will; be sorted just like a (a determines the sort; nBs is the number of TObject**; arrays in b). Uses ObjCompare() to compare objects. This function is used by; the new function TClonesArray::MultiSort(). Add a new option ""+"" in TClonesArray::Clear. When the option starts with ""C+"",; eg ""C+xyz"" the objects in the array are in turn cleared with the option ""xyz"".; Since the Collection objects do have a name and the Clone method does allow; for the name to change, TCollection::Clone was added to implement the name change properly. Thread. New static function TThread::IsInitialized. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html:4908,Clear,Clear,4908,core/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html,2,"['Clear', 'clear']","['Clear', 'cleared']"
Usability,"rectories we explored above are available when downloading the; binaries. When downloading the source you also get a directory for; each library with the corresponding header and source files, located; in the `inc` and `src` subdirectories. To see what classes are in a; library, you can check the `<library>/inc` directory for the list of; class definitions. For example, the physics library `libPhysics.so`; contains these class definitions:. ``` {.cpp}; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; ```. ## How to Find More Information. website The ROOT web site has up to date documentation. The ROOT; source code automatically generates this documentation, so each class; is explicitly documented on its own web page, which is always up to; date with the latest official release of ROOT. The ROOT Reference Guide web pages can be found at class index; reference guide <https://root.cern/doc/master/classes.html>. Each; page contains a class description, and an explanation of each method.; It shows the class inheritance tree and lets you jump to the parent; class page by clicking on the class name. If you want more details,; you can even see the source. There is a help page available in the; little box on the upper right hand side of each class documentation; page. You can see on the next page what a typical class documentation; web page looks like. The ROOT web site also contains in addition to; this Reference Guide, ""How To's"", a list of publications and example; applications. ### Class Reference Guide. The top of any class reference page lets you jump to different parts; of the documentation. The first line links to the class index and the; index for the current module (a group of classes, often a library).; The second line links to the ROOT homepage and the class overviews.; The third line links the source informat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:24432,Guid,Guide,24432,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,2,"['Guid', 'guid']","['Guide', 'guide']"
Usability,"ree has one branch for; each data member of `Event`, `Track`, and `EventHeader`. Now we can use; `TTree::MakeClass` on our tree ""`T`"". `MakeClass` takes one parameter, a; string containing the name of the class to be made. In the command; below, the name of our class will be ""`MyClass`"". ``` {.cpp}; root[] T->MakeClass(""MyClass""); Files: MyClass.h and MyClass.C generated from Tree: T; ```. Cling informs us that it has created two files. `MyClass.`h contains the; class definition and `MyClass.C` contains the `MyClass::Loop()` method.; `MyClass` has more methods than just `Loop()`. The other methods are a; constructor, a destructor, `GetEntry()`, `LoadTree()`, `Notify()`,; `Cut()` and `Show()`. The implementations of these methods are in the .h; file. This division of methods was done intentionally. The .C file is; kept as short as possible, and contains only code that is intended for; you to customize. The .h file contains all the other methods. It is; clear that you want to be as independent as possible of the header file; (i.e. `MyClass.h`) generated by `MakeClass`. The solution is to; implement a derived class, for example `MyRealClass` deriving from; `MyClass` such that a change in your `Tree `or regeneration of; `MyClass.h` does not force you to change `MyRealClass.h`. You can; imagine deriving several classes from `MyClass.h`, each with a specific; algorithm. To understand both files, let's start with `MyClass.h` and; the class declaration:. ### MyClass.h. ``` {.cpp}; class MyClass {; public :; // Pointer to the analyzed TTree or TChain; TTree *fChain;; // Current Tree number in a TChain; Int_t fCurrent;; // Declaration of leaves types; UInt_t fUniqueID;; UInt_t fBits;; Char_t fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; Int_t fEvtHdr_fEvtNum;; // List of branches; TBranch *b_fUniqueID;; TBranch *b_fBits;; TBranch *b_fType;; TBranch *b_fNtrack;; TBranch *b_fNseg;; TBranch *b_fNvertex;; TBranch *b_fFlag;; TBran",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:124665,clear,clear,124665,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clear']
Usability,"ref); ...; DW_AT_artificial (true). A Fortran front-end may need to generate a *trampoline* function to call a; function defined in a different compilation unit. In this case, the front-end; can emit the following descriptor for the trampoline function:. .. code-block:: text. !DISubprogram(name: ""sub1_.t0p"", linkageName: ""sub1_.t0p"", scope: !4, file: !4, type: !5, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !7, retainedNodes: !24, targetFuncName: ""sub1_""). The targetFuncName field is the name of the function that the trampoline; calls. This descriptor results in the following DWARF tag:. .. code-block:: text. DW_TAG_subprogram; ...; DW_AT_linkage_name	(""sub1_.t0p""); DW_AT_name	(""sub1_.t0p""); DW_AT_trampoline	(""sub1_""). Debugging information format; ============================. Debugging Information Extension for Objective C Properties; ----------------------------------------------------------. Introduction; ^^^^^^^^^^^^. Objective C provides a simpler way to declare and define accessor methods using; declared properties. The language provides features to declare a property and; to let compiler synthesize accessor methods. The debugger lets developer inspect Objective C interfaces and their instance; variables and class variables. However, the debugger does not know anything; about the properties defined in Objective C interfaces. The debugger consumes; information generated by compiler in DWARF format. The format does not support; encoding of Objective C properties. This proposal describes DWARF extensions to; encode Objective C properties, which the debugger can use to let developers; inspect Objective C properties. Proposal; ^^^^^^^^. Objective C properties exist separately from class members. A property can be; defined only by ""setter"" and ""getter"" selectors, and be calculated anew on each; access. Or a property can just be a direct access to some declared ivar.; Finally it can have an ivar ""automatically synthesized"" for it by the compiler,; in wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:49276,simpl,simpler,49276,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['simpl'],['simpler']
Usability,"ref:`Phabricator <phabricator-reviews>`; instance for the duration of the migration. If you want to contribute to LLVM; now, please use GitHub. For more information about the workflow of using GitHub; Pull Requests see our :ref:`GitHub <github-reviews>` documentation. To make sure the right people see your patch, please select suitable reviewers; and add them to your patch when requesting a review. Suitable reviewers are the; code owner (see CODE_OWNERS.txt) and other people doing work in the area your; patch touches. Github will normally suggest some reviewers based on rules or; people that have worked on the code before. If you are a new contributor, you; will not be able to select reviewers in such a way, in which case you can still; get the attention of potential reviewers by CC'ing them in a comment -- just; @name them. A reviewer may request changes or ask questions during the review. If you are; uncertain on how to provide test cases, documentation, etc., feel free to ask; for guidance during the review. Please address the feedback and re-post an; updated version of your patch. This cycle continues until all requests and comments; have been addressed and a reviewer accepts the patch with a `Looks good to me` or `LGTM`.; Once that is done the change can be committed. If you do not have commit; access, please let people know during the review and someone should commit it; on your behalf. If you have received no comments on your patch for a week, you can request a; review by 'ping'ing the GitHub PR with ""Ping"". The common courtesy 'ping' rate; is once a week. Please remember that you are asking for valuable time from other; professional developers. For more information on LLVM's code-review process, please see :doc:`CodeReview`. .. _commit_from_git:. For developers to commit changes from Git; -----------------------------------------. Once a patch is reviewed, you can select the ""Squash and merge"" button in the; GitHub web interface. You might need to rebase your",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst:4538,guid,guidance,4538,interpreter/llvm-project/llvm/docs/Contributing.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst,1,['guid'],['guidance']
Usability,"relations* and it should be used when a large number of input variables are; provided, otherwise TMVA will spend a long time in setting up the data set before training. ; ; - Build configuration:; - Add new cmake flags, `tmva-cpu` and `tmva-gpu`, which can be used to swicth on/off the CPU and GPU (based on CUDA) implementations of the TMVA Deep Learning module. `tmva-cpu` is enabled by; default if a Blas or CBlas library is found in the system. `tmva-gpu` is enabled when the cmake flag `cuda` is enabled and a compatible Cuda library is found. ; enabled if the corre; - Add possibility to independently configure building of optional pymva part of tmva with flag `-Dpymva=ON|OFF`. - New Cross Validation features:; - Add stratified splitting for cross validation.; - New plotting option in cross validation, average ROC curve. - Bugfixes:; - Fix bug in BDT training with imt=on; - Improved handling of large event numbers in cross validation using deterministic splitting. - Documentation:; - Update TMVA Users' guide. ## 2D Graphics Libraries. - Highlight mode is implemented for `TH1` and for `TGraph` classes. When; highlight mode is on, mouse movement over the bin will be represented; graphically. Histograms bins or graph points will be highlighted. Moreover,; any highlight emits signal `TCanvas::Highlighted()` which allows the user to; react and call their own function. For a better understanding see also; the tutorials `$ROOTSYS/tutorials/hist/hlHisto*.C` and; `$ROOTSYS/tutorials/graphs/hlGraph*.C` .; - Implement fonts embedding for PDF output. The ""EmbedFonts"" option allows to; embed the fonts used in a PDF file inside that file. This option relies on; the ""gs"" command (https://ghostscript.com). Example:. ~~~ {.cpp}; canvas->Print(""example.pdf"",""EmbedFonts"");; ~~~; - In TAttAxis::SaveAttributes` take into account the new default value for `TitleOffset`.; - When the histograms' title's font was set in pixel the position of the; `TPaveText` containing the title was not corr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:16284,guid,guide,16284,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['guid'],['guide']
Usability,"ren't associated with a pull-request **will be deleted**. Pull Requests; =============; The LLVM project is using GitHub Pull Requests for Code Reviews. This document; describes the typical workflow of creating a Pull Request and getting it reviewed; and accepted. This is meant as an overview of the GitHub workflow, for complete; documentation refer to `GitHub's documentation <https://docs.github.com/pull-requests>`_. GitHub Tools; ------------; You can interact with GitHub in several ways: via git command line tools,; the web browser, `GitHub Desktop <https://desktop.github.com/>`_, or the; `GitHub CLI <https://cli.github.com>`_. This guide will cover the git command line; tools and the GitHub CLI. The GitHub CLI (`gh`) will be most like the `arc` workflow and; recommended. Creating Pull Requests; ----------------------; Keep in mind that when creating a pull request, it should generally only contain one; self-contained commit initially.; This makes it easier for reviewers to understand the introduced changes and; provide feedback. It also helps maintain a clear and organized commit history; for the project. If you have multiple changes you want to introduce, it's; recommended to create separate pull requests for each change. Create a local branch per commit you want to submit and then push that branch; to your `fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks>`_; of the llvm-project and; `create a pull request from the fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork>`_.; As GitHub uses the first line of the commit message truncated to 72 characters; as the pull request title, you may have to edit to reword or to undo this; truncation. Creating Pull Requests with GitHub CLI; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; With the CLI it's enough to create the branch locally and then run:. ::. gh pr create. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:1869,feedback,feedback,1869,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['feedback'],['feedback']
Usability,"renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't need any cross-TU information, then the; ``SourceChangeRefactoringRule`` should work for you. #. If you would like to implement a rename-like operation with potential; interactive components, then ``FindSymbolOccurrencesRefactoringRule`` might; work for you. How to Create a Rule; ^^^^^^^^^^^^^^^^^^^^. Once you determine which type of rule is suitable for your needs you can; implement the refactoring by subclassing the rule and implementing its; interface. The subclass should have a constructor that takes the inputs that; are needed to perform the refactoring. For example, if you want to implement a; rule that simply deletes a selection, you should create a subclass of; ``SourceChangeRefactoringRule`` with a constructor that accepts the selection; range:. .. code-block:: c++. class DeleteSelectedRange final : public SourceChangeRefactoringRule {; public:; DeleteSelection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the following code:. .. code-block:: c++. RefactoringActionRules Rules;; Rules.push_back(; createRefactoringActionRule<DeleteSelectedRange>(; SourceRangeSelectionRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:5316,simpl,simply,5316,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['simpl'],['simply']
Usability,"rence page <http://root.cern.ch/root/html/THtml>. The; following will enumerate some of the highlights. ### Referencing Documentation for other Libraries. When **`THtml`** generates documentation for classes it recognizes all; class names known to ROOT. If **`THtml`** does not have sources for a; class it determines the class's library name. This has to be set by; means of `rootmap` files, see Library AutoLoading of this User's Guide.; Given the library name, **`THtml`** searches for an entry in its map of; libraries to documentation URLs. If it finds it, it will create a link; to the documentation at that URL for all occurrences of a given class; name. One can set the URL `../mylib/` for a library name `MyLib` by; setting `Root.Html.MyLib:` `../mylib/` or by calling; `THtml::SetLibURL(""MyLib"", ""../mylib/"")`. Occurrences of class `MyClass`; of `MyLib` will now be referenced as `../mylib/MyClass.html`. ### Search Engine. **`THtml`** can invoke external search engines. The ROOT reference guide; sets `Root.Html.Search` to <http://www.google.com/search?q=%s+site%3A%u>.; Calling **`THtml::SetSearchStemURL()`** will set the same. If this URL stem is; set, `THtml` will create search fields in the index pages. It will; send the words entered in these search fields as %s in the URL; %u will; be replaced by the current document's path, allowing a site- and; directory-specific search. ### ViewCVS. Most code is managed in a version control system like CVS. ViewCVS is a; WWW reader interface to the versioning control system that allows e.g.; tracking a file's changes. **`THtml`** will reference these pages; automatically if the `.rootrc` variable `Root.Html.ViewCVS` is set to; the URL stem of the ViewCVS. installation. Alternatively, one can call; THtml::SetViewCVS(). ### Wiki Pages. In some contexts it might be desirable to let users comment on classes,; e.g. for suggestions of use or alternatives, details of behavior, and; cross references to other relevant classes. A successf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:10538,guid,guide,10538,documentation/users-guide/HTMLDoc.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md,1,['guid'],['guide']
Usability,"replace the null with an appropriate coroutine; handle value. The second argument should be `true` if this coro.end is in the block that is; part of the unwind sequence leaving the coroutine body due to an exception and; `false` otherwise. The third argument if present should specify a function to be called. If the third argument is present, the remaining arguments are the arguments to; the function call. .. code-block:: llvm. call i1 (ptr, i1, ...) @llvm.coro.end.async(; ptr %hdl, i1 0,; ptr @must_tail_call_return,; ptr %ctxt, ptr %task, ptr %actor); unreachable. .. _coro.suspend:; .. _suspend points:. 'llvm.coro.suspend' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i8 @llvm.coro.suspend(token <save>, i1 <final>). Overview:; """""""""""""""""". The '``llvm.coro.suspend``' marks the point where execution of a; switched-resume coroutine is suspended and control is returned back; to the caller. Conditional branches consuming the result of this; intrinsic lead to basic blocks where coroutine should proceed when; suspended (-1), resumed (0) or destroyed (1). Arguments:; """""""""""""""""""". The first argument refers to a token of `coro.save` intrinsic that marks the; point when coroutine state is prepared for suspension. If `none` token is passed,; the intrinsic behaves as if there were a `coro.save` immediately preceding; the `coro.suspend` intrinsic. The second argument indicates whether this suspension point is `final`_.; The second argument only accepts constants. If more than one suspend point is; designated as final, the resume and destroy branches should lead to the same; basic blocks. Example (normal suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %resume; i8 1, label %cleanup]. Example (final suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. while.end:; %s.final = call i8 @llvm.coro.suspend(token none, i1 true); switch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:50076,resume,resumed,50076,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resumed']
Usability,"resentation from M. Slawinska at a ROOT team meeting. define the functions as template functions instead of having the same re-definition for all the various basic types. This is done for TMath::Mean,TMath::GeomMean, TMath::Median, TMath::KOrdStat; Use STL to implement the following algorithms:; ; TMath::Sort is re-implemented using std::sort.; TMath::BinarySearch is re-implemented using the STL algorithm std::lower_bound. The STL algorithms have been found for these cases to be perform better in term of CPU time. For some other algorithms like TMath::LocMin, TMath::LocMax or TMath::Permute the original implementation is faster than STL and has been maintained.; ; Add a generic iterator interface, similar to the STL algorithm interface, to the following TMath functions:; MinElement, MaxElement, LocMin, LocMax, Mean, GeomMean, RMS,; BinarySearch. The iterator interface for sort is called; TMath::SortItr to avoid a compilation ambiguity. For example,; for finding the mean of a std::vector<double> v, one simply needs to call TMath::Mean(v.begin(), v.end() ) .; ; Various changes have been applied to the mathematical functions to remove duplications in the implementation with the special and statistical functions defined in ROOT::Math. The functions which have been changed and thus they can return a sightly different result than before are:; ; TMath::Erf and TMath::Erfc call ROOT::Math::erf and ROOT::math::erfc which are implemented using the Cephes algorithms, which is accurate at the required double precision level.; TMath::Gamma(z) is implemented with ROOT::Math::tgamma, which again uses Cephes.; The incomplete gamma function, TMath::Gamma(a,x) it is implemented using ROOT::Math::inc_gamma based on a corresponding Cephes function.; TMath::Prob (the upper chi2 probability) is implemented also using ROOT::Math::chisquared_cdf_c which uses ROOT::Math::inc_gamma_c based on a corresponding Cephes function. Now the implementation does not suffer anymore from large numerical ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:2471,simpl,simply,2471,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['simpl'],['simply']
Usability,"ressions are enclosed with double braces, they are; visually distinct, and you don't need to use escape characters within the double; braces like you would in C. In the rare case that you want to match double; braces explicitly from the input, you can use something ugly like; ``{{[}][}]}}`` as your pattern. Or if you are using the repetition count; syntax, for example ``[[:xdigit:]]{8}`` to match exactly 8 hex digits, you; would need to add parentheses like this ``{{([[:xdigit:]]{8})}}`` to avoid; confusion with FileCheck's closing double-brace. FileCheck String Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. It is often useful to match a pattern and then verify that it occurs again; later in the file. For codegen tests, this can be useful to allow any; register, but verify that that register is used consistently later. To do; this, :program:`FileCheck` supports string substitution blocks that allow; string variables to be defined and substituted into patterns. Here is a simple; example:. .. code-block:: llvm. ; CHECK: test5:; ; CHECK: notw	[[REGISTER:%[a-z]+]]; ; CHECK: andw	{{.*}}[[REGISTER]]. The first check line matches a regex ``%[a-z]+`` and captures it into the; string variable ``REGISTER``. The second line verifies that whatever is in; ``REGISTER`` occurs later in the file after an ""``andw``"". :program:`FileCheck`; string substitution blocks are always contained in ``[[ ]]`` pairs, and string; variable names can be formed with the regex ``[a-zA-Z_][a-zA-Z0-9_]*``. If a; colon follows the name, then it is a definition of the variable; otherwise, it; is a substitution. :program:`FileCheck` variables can be defined multiple times, and substitutions; always get the latest value. Variables can also be substituted later on the; same line they were defined on. For example:. .. code-block:: llvm. ; CHECK: op [[REG:r[0-9]+]], [[REG]]. Can be useful if you want the operands of ``op`` to be the same register,; and don't care exactly which register it is. If ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:26473,simpl,simple,26473,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['simpl'],['simple']
Usability,"returns kNone, as it does; for successful addition, indicating it does not require further; information about this object. Hence you should not try to make any; assumptions about what the viewer did with the object. The viewer may; decide to force the client to rebuild (republish) the scene, obtaining a; different collection of objects, if the internal viewer state changes; .e.g. significant camera move. It does this presently by forcing a; repaint on the attached **`TPad`** object - hence you should attach you; master geometry object to the pad (via `TObject::Draw()`), and perform; the publishing to the viewer in response to **`TObject::Paint()`**. #### Physical IDs. TVirtualViewer3D provides for two methods of object addition:. ``` {.cpp}; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); ```. If you use the first (simple) case a viewer using logical/physical pairs; will generate sequential IDs for each physical object internally. Scene; rebuilds will require destruction and recreation of all physical; objects. For the second you can specify an identifier from the client; side, which must be unique and stable - i.e. the IDs of a published; object is consistent, regardless of changes in termination of contained; child geometry branches. In this case the viewer can safely cache the; physical objects across scene rebuilds, discarding those no longer of; interest. #### Child Objects. In many geometries there is a rigid containment hierarchy, and so if the; viewer is not interested in a certain object due to limits/size then it; will also not be interest in any of the contained branch of siblings.; Both `TBuffer3D::AddObject()` methods have an `addChildren` return; parameter. The viewer will complete this (if passed) indicating if; children of the object just sent are worth sending. #### Recycling TBuffer3D. Once add `TBuffer3D::AddObject()` has b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:137831,simpl,simple,137831,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,"reventing future redefinition. This code does have a bug, though: If the ``FunctionAST::codegen()`` method; finds an existing IR Function, it does not validate its signature against the; definition's own prototype. This means that an earlier 'extern' declaration will; take precedence over the function definition's signature, which can cause; codegen to fail, for instance if the function arguments are named differently.; There are a number of ways to fix this bug, see what you can come up with! Here; is a testcase:. ::. extern foo(a); # ok, defines foo.; def foo(b) b; # Error: Unknown variable name. (decl using 'a' takes precedence). Driver Changes and Closing Thoughts; ===================================. For now, code generation to LLVM doesn't really get us much, except that; we can look at the pretty IR calls. The sample code inserts calls to; codegen into the ""``HandleDefinition``"", ""``HandleExtern``"" etc; functions, and then dumps out the LLVM IR. This gives a nice way to look; at the LLVM IR for simple functions. For example:. ::. ready> 4+5;; Read top-level expression:; define double @0() {; entry:; ret double 9.000000e+00; }. Note how the parser turns the top-level expression into anonymous; functions for us. This will be handy when we add `JIT; support <LangImpl04.html#adding-a-jit-compiler>`_ in the next chapter. Also note that the; code is very literally transcribed, no optimizations are being performed; except simple constant folding done by IRBuilder. We will `add; optimizations <LangImpl04.html#trivial-constant-folding>`_ explicitly in the next; chapter. ::. ready> def foo(a b) a*a + 2*a*b + b*b;; Read function definition:; define double @foo(double %a, double %b) {; entry:; %multmp = fmul double %a, %a; %multmp1 = fmul double 2.000000e+00, %a; %multmp2 = fmul double %multmp1, %b; %addtmp = fadd double %multmp, %multmp2; %multmp3 = fmul double %b, %b; %addtmp4 = fadd double %addtmp, %multmp3; ret double %addtmp4; }. This shows some simple arithmetic. N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:17835,simpl,simple,17835,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability,"rg));; else; return nullptr;. if (CurTok == ')'); break;. if (CurTok != ','); return LogError(""Expected ')' or ',' in argument list"");; getNextToken();; }; }. // Eat the ')'.; getNextToken();. return std::make_unique<CallExprAST>(IdName, std::move(Args));; }. This routine follows the same style as the other routines. (It expects; to be called if the current token is a ``tok_identifier`` token). It; also has recursion and error handling. One interesting aspect of this is; that it uses *look-ahead* to determine if the current identifier is a; stand alone variable reference or if it is a function call expression.; It handles this by checking to see if the token after the identifier is; a '(' token, constructing either a ``VariableExprAST`` or; ``CallExprAST`` node as appropriate. Now that we have all of our simple expression-parsing logic in place, we; can define a helper function to wrap it together into one entry point.; We call this class of expressions ""primary"" expressions, for reasons; that will become more clear `later in the; tutorial <LangImpl06.html#user-defined-unary-operators>`_. In order to parse an arbitrary; primary expression, we need to determine what sort of expression it is:. .. code-block:: c++. /// primary; /// ::= identifierexpr; /// ::= numberexpr; /// ::= parenexpr; static std::unique_ptr<ExprAST> ParsePrimary() {; switch (CurTok) {; default:; return LogError(""unknown token when expecting an expression"");; case tok_identifier:; return ParseIdentifierExpr();; case tok_number:; return ParseNumberExpr();; case '(':; return ParseParenExpr();; }; }. Now that you see the definition of this function, it is more obvious why; we can assume the state of CurTok in the various functions. This uses; look-ahead to determine which sort of expression is being inspected, and; then parses it with a function call. Now that basic expressions are handled, we need to handle binary; expressions. They are a bit more complex. Binary Expression Parsing; =================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:11120,clear,clear,11120,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['clear'],['clear']
Usability,"riable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<FunctionDecl>isDefaulted; Matches defaulted function declarations. Given:; class A { ~A(); };; class B { ~B() = default; };; functionDecl(isDefaulted()); matches the declaration of ~B, but not ~A. Matcher<FunctionDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<FunctionDecl>isDeleted; Matches deleted function declarations. Given:; void Func();; void DeletedFunc() = delete;; functionDecl(isDeleted()); matches the declaration of DeletedFunc, but not Func. Matcher<FunctionDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:91908,Usab,Usable,91908,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"riable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A sing",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:34930,simpl,simple,34930,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"riate coroutine; handle value. The second argument should be `true` if this coro.end is in the block that is; part of the unwind sequence leaving the coroutine body due to an exception and; `false` otherwise. Non-trivial (non-none) token argument can only be specified for unique-suspend; returned-continuation coroutines where it must be a token value produced by; '``llvm.coro.end.results``' intrinsic. Only none token is allowed for coro.end calls in unwind sections. Semantics:; """"""""""""""""""""; The purpose of this intrinsic is to allow frontends to mark the cleanup and; other code that is only relevant during the initial invocation of the coroutine; and should not be present in resume and destroy parts. In returned-continuation lowering, ``llvm.coro.end`` fully destroys the; coroutine frame. If the second argument is `false`, it also returns from; the coroutine with a null continuation pointer, and the next instruction; will be unreachable. If the second argument is `true`, it falls through; so that the following logic can resume unwinding. In a yield-once; coroutine, reaching a non-unwind ``llvm.coro.end`` without having first; reached a ``llvm.coro.suspend.retcon`` has undefined behavior. The remainder of this section describes the behavior under switched-resume; lowering. This intrinsic is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:43907,resume,resume,43907,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ribe how to *register* a register allocator machine; pass. Implement your register allocator machine pass. In your register allocator; ``.cpp`` file add the following include:. .. code-block:: c++. #include ""llvm/CodeGen/RegAllocRegistry.h"". Also in your register allocator ``.cpp`` file, define a creator function in the; form:. .. code-block:: c++. FunctionPass *createMyRegisterAllocator() {; return new MyRegisterAllocator();; }. Note that the signature of this function should match the type of; ``RegisterRegAlloc::FunctionPassCtor``. In the same file add the ""installing""; declaration, in the form:. .. code-block:: c++. static RegisterRegAlloc myRegAlloc(""myregalloc"",; ""my register allocator help string"",; createMyRegisterAllocator);. Note the two spaces prior to the help string produces a tidy result on the; :option:`-help` query. .. code-block:: console. $ llc -help; ...; -regalloc - Register allocator to use (default=linearscan); =linearscan - linear scan register allocator; =local - local register allocator; =simple - simple register allocator; =myregalloc - my register allocator help string; ... And that's it. The user is now free to use ``-regalloc=myregalloc`` as an; option. Registering instruction schedulers is similar except use the; ``RegisterScheduler`` class. Note that the; ``RegisterScheduler::FunctionPassCtor`` is significantly different from; ``RegisterRegAlloc::FunctionPassCtor``. To force the load/linking of your register allocator into the; :program:`llc`/:program:`lli` tools, add your creator function's global; declaration to ``Passes.h`` and add a ""pseudo"" call line to; ``llvm/Codegen/LinkAllCodegenComponents.h``. Creating new registries; -----------------------. The easiest way to get started is to clone one of the existing registries; we; recommend ``llvm/CodeGen/RegAllocRegistry.h``. The key things to modify are; the class name and the ``FunctionPassCtor`` type. Then you need to declare the registry. Example: if your pass registry is; ``Regist",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:50514,simpl,simple,50514,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,2,['simpl'],['simple']
Usability,"ribed in this document can be used to; precisely determine the location of values at a specific position in; the code. LLVM does not maintain any mapping between those values and; any higher-level entity. The runtime must be able to interpret the; stack map record given only the ID, offset, and the order of the; locations, records, and functions, which LLVM preserves. Note that this is quite different from the goal of debug information,; which is a best-effort attempt to track the location of named; variables at every instruction. An important motivation for this design is to allow a runtime to; commandeer a stack frame when execution reaches an instruction address; associated with a stack map. The runtime must be able to rebuild a; stack frame and resume program execution using the information; provided by the stack map. For example, execution may resume in an; interpreter or a recompiled version of the same function. This usage restricts LLVM optimization. Clearly, LLVM must not move; stores across a stack map. However, loads must also be handled; conservatively. If the load may trigger an exception, hoisting it; above a stack map could be invalid. For example, the runtime may; determine that a load is safe to execute without a type check given; the current state of the type system. If the type system changes while; some activation of the load's function exists on the stack, the load; becomes unsafe. The runtime can prevent subsequent execution of that; load by immediately patching any stack map location that lies between; the current call site and the load (typically, the runtime would; simply patch all stack map locations to invalidate the function). If; the compiler had hoisted the load above the stack map, then the; program could crash before the runtime could take back control. To enforce these semantics, stackmap and patchpoint intrinsics are; considered to potentially read and write all memory. This may limit; optimization more than some clients desire. Thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:17907,Clear,Clearly,17907,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['Clear'],['Clearly']
Usability,"ribute to the computation of; the function's return value. .. _passes-loop-extract:. ``loop-extract``: Extract loops into new functions; --------------------------------------------------. A pass wrapper around the ``ExtractLoop()`` scalar transformation to extract; each top-level loop into its own new function. If the loop is the *only* loop; in a given function, it is not touched. This is a pass most useful for; debugging via bugpoint. ``loop-reduce``: Loop Strength Reduction; ----------------------------------------. This pass performs a strength reduction on array references inside loops that; have as one or more of their components the loop induction variable. This is; accomplished by creating a new value to hold the initial value of the array; access for the first iteration, and then creating a new GEP instruction in the; loop to increment the value by the appropriate amount. .. _passes-loop-rotate:. ``loop-rotate``: Rotate Loops; -----------------------------. A simple loop rotation transformation. A summary of it can be found in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. This pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; head",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:26429,simpl,simple,26429,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"riding the Translate Function*: The `RooAbsArg::translate()` function; needs to be overridden to specify how the class is translating to C++ code; that is using the aforementioned free function. **Sample Steps**: To add Code Generation support to an existing RooFit class,; following is a sample set of steps (using the aforementioned approach of; extracting free functions in a separate file.). **1. Extract logic into a separate file** Implement what your class is; supposed to do as a free function in [MathFuncs].; This implementation must be compatible with the syntax supported by Clad. **2. Refactor evaluate():** Refactor the existing `RooAbsReal::evaluate()`; function to use the `MathFuncs.h` implementation. This is optional, but; can reduce code duplication and potential for bugs. This may require some; effort if an extensive caching infrastructure is used in your model. **3. Add translate():** RooFit classes are extended using a (typically) simple; `translate()` function that extracts the mathematically differentiable; properties out of the RooFit classes that make up the statistical model. The `translate()` function helps implement the Code Squashing logic that is; used to optimize numerical evaluations. It accomplishes this by using a small; subset of helper functions that are available in the; `RooFit::Detail::CodeSquashContext` and `RooFuncWrapper` classes; (see Appendix B). It converts a RooFit expression into a form that can be; efficiently evaluated by Clad. The `translate()` function returns an `std::string` representing the; underlying mathematical notation of the class as code, that can later be; concatenated into a single string representing the entire model. This string; of code is then just-in-time compiled by Cling (a C++ interpreter for Root). **4. analyticalIntegral() Use Case:** If your class includes (or should; include) the `analyticalIntegral()` function, then a simple; `buildCallToAnalyticIntegral()` function needs to be created to help call ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:8182,simpl,simple,8182,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simple']
Usability,"ries during session startup, as they may significantly slowdown; the startup process is the medium is busy. In such a case, admins; are responsible to create the directories in advance; the session; releated part fo the path is created by the session once up.; In XrdProofd, move the check for the username after authentication.; This is because authentication may run some credentials-to-user mapping; which can modify the requested username. This way we really check the; final username and not the one requested by the client, which may even; not exist on the machines. Side modification: when the mapping function; returns more usernames, the username specified by the client is used to; help choosing the effective username among the available choices; if not; match is found the handshake does any longer fail, the first mapped; username is chosen instead.; In XrdProofd, allow 'xpd.allowedgroups' to control also PROOF; groups, not only UNIX ones.In XrdProofd, simplify error; messages in case of login failure because of non-authorization.; Remove hardcoded additions of dirname(COMPILER) and of; '/bin:/usr/bin:/usr/local/bin' in front of PATH. These uncontrolled; additions could hide specific settings in PATH and be the source of; weird problems appearing in PROOF only.; Add more flexibility to the definition of the library path seen by; proofserv. So far to avoid ambiguites in some cases, $ROOTSYS/lib was; removed and the one of the ROOT version chosen was added later on in; front, which proved to be to aggressive in some cases.; All changes (and fixes) needed to build against the version of Xrootd,; now always installed as external.; Fixes. Fix GetSessionLogs in PROOF-Lite; Restore correct parsing of ""workers=N"" in PROOF-Lite; In Proof-Bench, make sure that it can be run from any directory; and no matter how ROOT was installed; Fix issue in TProofPlayer::HandleHistogram preventing proper; histogram cleaning right after merging when using TH1::Add; histogram; were still des",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html:2923,simpl,simplify,2923,proof/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html,1,['simpl'],['simplify']
Usability,"ries, it must derive from; ``std::exception``.; If preserving the exception (or its type) is not possible, generic exceptions; are used to propagate the exception: ``Exception`` in Python or; ``CPyCppyy::PyException`` in C++. In the most common case of an instance of a C++ exception class derived from; ``std::exception`` that is thrown from a compiled library and which is; copyable, the exception can be caught and handled like any other bound C++; object (or with ``Exception`` on the Python and ``std::exception`` on the; C++ side).; If the exception is not copyable, but derived from ``std::exception``, the; result of its ``what()`` reported with an instance of Python's ``Exception``.; In all other cases, including exceptions thrown from interpreted code (due to; limitations of the Clang JIT), the exception will turn into an instance of; ``Exception`` with a generic message. The standard C++ exceptions are explicitly not mapped onto standard Python; exceptions, since other than a few simple cases, the mapping is too crude to; be useful as the typical usage in each standard library is too different.; Thus, for example, a thrown ``std::runtime_error`` instance will become a; ``cppyy.gbl.std.runtime_error`` instance on the Python side (with Python's; ``Exception`` as its base class), not a ``RuntimeError`` instance. The C++ code used for the examples below can be found; :doc:`here <cppyy_features_header>`, and it is assumed that that code is; loaded at the start of any session.; Download it, save it under the name ``features.h``, and load it:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('features.h'); >>>. In addition, the examples require the ``throw`` to be in compiled code.; Save the following and build it into a shared library ``libfeatures.so`` (or; ``libfeatures.dll`` on MS Windows):. .. code-block:: C++. #include ""features.h"". void throw_an_error(int i) {; if (i) throw SomeError{""this is an error""};; throw SomeOtherError{""this is another error""};;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/exceptions.rst:1369,simpl,simple,1369,bindings/pyroot/cppyy/cppyy/doc/source/exceptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/exceptions.rst,1,['simpl'],['simple']
Usability,"rip Symbols"")));. This defines a variable that is conceptually of the type; ""``std::vector<enum Opts>``"". Thus, you can access it with standard vector; methods:. .. code-block:: c++. for (unsigned i = 0; i != OptimizationList.size(); ++i); switch (OptimizationList[i]); ... ... to iterate through the list of options specified. Note that the ""``cl::list``"" template is completely general and may be used with; any data types or other arguments that you can use with the ""``cl::opt``""; template. One especially useful way to use a list is to capture all of the; positional arguments together if there may be more than one specified. In the; case of a linker, for example, the linker takes several '``.o``' files, and; needs to capture them into a list. This is naturally specified as:. .. code-block:: c++. ...; cl::list<std::string> InputFilenames(cl::Positional, cl::desc(""<Input files>""), cl::OneOrMore);; ... This variable works just like a ""``vector<string>``"" object. As such, accessing; the list is simple, just like above. In this example, we used the; `cl::OneOrMore`_ modifier to inform the CommandLine library that it is an error; if the user does not specify any ``.o`` files on our command line. Again, this; just reduces the amount of checking we have to do. Collecting options as a set of flags; ------------------------------------. Instead of collecting sets of options in a list, it is also possible to gather; information for enum values in a **bit vector**. The representation used by the; `cl::bits`_ class is an ``unsigned`` integer. An enum value is represented by a; 0/1 in the enum's ordinal value bit position. 1 indicating that the enum was; specified, 0 otherwise. As each specified value is parsed, the resulting enum's; bit is set in the option's bit vector:. .. code-block:: c++. bits |= 1 << (unsigned)enum;. Options that are specified multiple times are redundant. Any instances after; the first are discarded. Reworking the above list example, we could replace `cl::li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:21120,simpl,simple,21120,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"ription. Others always require a; tessellation description based on **`TBuffer3D`**'s `kRaw` /; `kRawSizes` points/lines/segments sections. - Some need the 3D object positions in the master (world) frame,; others can cope with local frames and a translation matrix to place; the object. - Some require bounding boxes for objects - others do not. Similarly some viewer clients are only capable of providing positions in; master frame, cannot provide bounding boxes etc. Additionally we do not; want to incur the cost of expensive tessellation operations if the; viewer does not require them. To cope with these variations the; **`TBuffer3D`** objects are filled by negotiation with the viewer. ![TBuffer3D class hierarchy](pictures/030000E0.png). **`TBuffer3D`** classes are conceptually divided into enumerated; sections: `kCore`, `kBoundingBox`, `kRaw` - see the class diagram and; the file `TBuffer3D.h` for more details. The **`TBuffer3D`** methods; `SectionsValid()`, `SetSectionsValid()`, `ClearSectionsValid()` are used; to test, set, clear these section validity flags e.g. ``` {.cpp}; buffer.SetSectionsValid(TBuffer3D::kShapeSpecific);; ...; if (buffer.SectionsValid(TBuffer3D:: kShapeSpecific)) {; ...; }; ```. The sections found in the base **`TBuffer3D`**; (`kCore/kBoundingBox/kRawSizes/kRaw`) are sufficient to describe any; tessellated shape in a generic fashion. An additional `kShapeSpecific`; section is added in **`TBuffer3D`** derived classes, allowing a more; abstract shape description (""a sphere of inner radius x, outer radius; y""). This enables a viewer, which knows how to draw (tessellate) the; shape itself to do so, while providing a generic fallback suitable for; all viewers. The rules for client negotiation with the viewer are:. - If suitable specialized **`TBuffer3D`** class exists, use it,; otherwise use **`TBuffer3D`**. - Complete the mandatory `kCore` section. - Complete the `kShapeSpecific` section if applicable. - Complete the `kBoundingBox` if you can. - Pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:127447,Clear,ClearSectionsValid,127447,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,2,"['Clear', 'clear']","['ClearSectionsValid', 'clear']"
Usability,"rit from multiple classes. In that case the order that that happens in matches the order you write the class names after the `:`. ```tablegen; class C {; int a = 1;; }; class D {; int a = 2;; }; class E : C, D {}; ```. ------------- Classes -----------------; class C {; int a = 1;; }; class D {; int a = 2;; }; class E {	// C D; int a = 2;; }; ------------- Defs -----------------. Class `E` first inherits from class `C`. This gives `E` a member `a` with value `1`. Then it inherits from class `D` which also has a member `a` but with a value of `2`. Meaning the final value of `E`'s `a` is `2`. When a member has the same name this is handled on a ""last one in wins"" basis. Assuming the types match. ```tablegen; class C {; string a = """";; }; class D {; int a = 2;; }; class E : C, D {}; ```. <stdin>:7:14: error: New definition of 'a' of type 'int' is incompatible with previous definition of type 'string'; class E : C, D {}; ^. When they don't match, we get an error. Luckily for us, we're about to learn all about types. ## Types. TableGen is statically typed with error checking to prevent you from assigning things with mismatched types. ```tablegen; class C {; int a;; bit b = 0;; string s = ""Hello"";; }; ```. ------------- Classes -----------------; class C {; int a = ?;; bit b = 0;; string s = ""Hello"";; }; ------------- Defs -----------------. Here we've created a class C with integer, bit (1 or 0) and string members. See [here](https://llvm.org/docs/TableGen/ProgRef.html#types) for a full list of types. Note that you do not have to give a member a default value, it can be left uninitialised. ```tablegen; %noreset. def X: C {}; ```. ------------- Classes -----------------; class C {; int a = ?;; bit b = 0;; string s = ""Hello"";; }; ------------- Defs -----------------; def X {	// C; int a = ?;; bit b = 0;; string s = ""Hello"";; }. When you make an instance of a class using `def`, that instance gets all the members of the class. Their values will be as set in the class, unless",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md:4746,learn,learn,4746,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,1,['learn'],['learn']
Usability,"rk on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on Discourse,; Discord,; or for advice. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5950,simpl,simple,5950,interpreter/llvm-project/clang/www/OpenProjects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html,2,['simpl'],['simple']
Usability,"rks/tree/master/SSCA2v2.2. Kokkos; ------; https://github.com/kokkos/kokkos-kernels/tree/master/perf_test; https://github.com/kokkos/kokkos/tree/master/benchmarks. PolyMage; --------; https://github.com/bondhugula/polymage-benchmarks. PolyBench; ---------; https://sourceforge.net/projects/polybench/. A modified version of Polybench 3.2 is already presented in; SingleSource/Benchmarks/Polybench. A newer version 4.2.1 is available. High Performance Geometric Multigrid; ------------------------------------; https://crd.lbl.gov/departments/computer-science/PAR/research/hpgmg/. RAJA Performance Suite; ----------------------; https://github.com/LLNL/RAJAPerf. CORAL-2 Benchmarks; ------------------; https://asc.llnl.gov/coral-2-benchmarks/. Many of its programs have already been integrated in; MultiSource/Benchmarks/DOE-ProxyApps-C and; MultiSource/Benchmarks/DOE-ProxyApps-C++. * Nekbone; * QMCPack; * LAMMPS; * Kripke; * Quicksilver; * PENNANT; * Big Data Analytic Suite; * Deep Learning Suite; * Stream; * Stride; * ML/DL micro-benchmark; * Pynamic; * ACME; * VPIC; * Laghos; * Parallel Integer Sort; * Havoq. NWChem; ------; http://www.nwchem-sw.org/index.php/Benchmarks. TVM; ----; https://github.com/dmlc/tvm/tree/main/apps/benchmark. HydroBench; ----------; https://github.com/HydroBench/Hydro. ParRes; ------; https://github.com/ParRes/Kernels/tree/default/Cxx11. Applications/Libraries; ======================. GnuPG; -----; https://gnupg.org/. Blitz++; -------; https://sourceforge.net/projects/blitz/. FFmpeg; ------; https://ffmpeg.org/. FreePOOMA; ---------; http://www.nongnu.org/freepooma/. FTensors; --------; http://www.wlandry.net/Projects/FTensor. rawspeed; --------; https://github.com/darktable-org/rawspeed. Its test dataset is 756 MB in size, which is too large to be included; into the test-suite repository. C++ Performance Benchmarks; --------------------------; https://gitlab.com/chriscox/CppPerformanceBenchmarks. Generic Algorithms; ==================. Image proces",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst:4804,Learn,Learning,4804,interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst,1,['Learn'],['Learning']
Usability,"rlying integer computation implied, there is no; difference. I'm writing a backend for a target which needs custom lowering for GEP. How do I do this?; -----------------------------------------------------------------------------------------. You don't. The integer computation implied by a GEP is target-independent.; Typically what you'll need to do is make your backend pattern-match expressions; trees involving ADD, MUL, etc., which are what GEP is lowered into. This has the; advantage of letting your code work correctly in more cases. GEP does use target-dependent parameters for the size and layout of data types,; which targets can customize. If you require support for addressing units which are not 8 bits, you'll need to; fix a lot of code in the backend, with GEP lowering being only a small piece of; the overall picture. How does VLA addressing work with GEPs?; ---------------------------------------. GEPs don't natively support VLAs. LLVM's type system is entirely static, and GEP; address computations are guided by an LLVM type. VLA indices can be implemented as linearized indices. For example, an expression; like ``X[a][b][c]``, must be effectively lowered into a form like; ``X[a*m+b*n+c]``, so that it appears to the GEP as a single-dimensional array; reference. This means if you want to write an analysis which understands array indices and; you want to support VLAs, your code will have to be prepared to reverse-engineer; the linearization. One way to solve this problem is to use the ScalarEvolution; library, which always presents VLA and non-VLA indexing in the same manner. .. _Rules:. Rules; =====. What happens if an array index is out of bounds?; ------------------------------------------------. There are two senses in which an array index can be out of bounds. First, there's the array type which comes from the (static) type of the first; operand to the GEP. Indices greater than the number of elements in the; corresponding static array type are valid. There ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:11739,guid,guided,11739,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['guid'],['guided']
Usability,"rm to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after code generation. Finally,; clang provides support for building and retaining fully-fledged ASTs, and even; supports writing them out to disk.; Designing the libraries with clean and simple APIs allows these high-level; policy decisions to be determined in the client, instead of forcing ""one true; way"" in the implementation of any of these libraries. Getting this right is; hard, and we don't always get it right the first time, but we fix any problems; when we ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:8123,simpl,simply,8123,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,2,['simpl'],"['simple', 'simply']"
Usability,"rmat on`` or; ``/* clang-format on */`` will not be formatted. The comments themselves will be; formatted (aligned) normally. Also, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; =========================. When using ``clang::format::reformat(...)`` functions, the format is specified; by supplying the `clang::format::FormatStyle; <https://clang.llvm.org/doxygen/structclang_1_1format_1_1FormatStyle.html>`_; structure. Configurable Format Style Options; =================================. This section lists the supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:4998,usab,usable,4998,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['usab'],['usable']
Usability,"rmatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/; FormatStyle getWebkitStyle();. /// Returns a format style complying with Microsoft's style guide:; /// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference; FormatStyle getMicrosoftStyle();. These options are also exposed in the :doc:`standalone tools <ClangFormat>`; through the `-style` option. In the future, we plan on making this configurable.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:1536,guid,guide,1536,interpreter/llvm-project/clang/docs/LibFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst,5,['guid'],"['guide', 'guidelines']"
Usability,"rmations within; instcombine are firing by selecting out lines with ""``IC``"" in them. At this point, you have a decision to make. Is the number of transformations; small enough to step through them using a debugger? If so, then try that. If there are too many transformations, then a source modification approach may; be helpful. In this approach, you can modify the source code of instcombine to; disable just those transformations that are being performed on your test input; and perform a binary search over the set of transformations. One set of places; to modify are the ""``visit*``"" methods of ``InstCombiner`` (*e.g.*; ``visitICmpInst``) by adding a ""``return false``"" as the first line of the; method. If that still doesn't remove enough, then change the caller of; ``InstCombiner::DoOneIteration``, ``InstCombiner::runOnFunction`` to limit the; number of iterations. You may also find it useful to use ""``-stats``"" now to see what parts of; instcombine are firing. This can guide where to put additional reporting code. At this point, if the amount of transformations is still too large, then; inserting code to limit whether or not to execute the body of the code in the; visit function can be helpful. Add a static counter which is incremented on; every invocation of the function. Then add code which simply returns false on; desired ranges. For example:. .. code-block:: c++. static int calledCount = 0;; calledCount++;; LLVM_DEBUG(if (calledCount < 212) return false);; LLVM_DEBUG(if (calledCount > 217) return false);; LLVM_DEBUG(if (calledCount == 213) return false);; LLVM_DEBUG(if (calledCount == 214) return false);; LLVM_DEBUG(if (calledCount == 215) return false);; LLVM_DEBUG(if (calledCount == 216) return false);; LLVM_DEBUG(dbgs() << ""visitXOR calledCount: "" << calledCount << ""\n"");; LLVM_DEBUG(dbgs() << ""I: ""; I->dump());. could be added to ``visitXOR`` to limit ``visitXor`` to being applied only to; calls 212 and 217. This is from an actual test case and raises an impor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:9684,guid,guide,9684,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['guid'],['guide']
Usability,"rn LogErrorP(""Expected function name in prototype"");; case tok_identifier:; FnName = IdentifierStr;; Kind = 0;; getNextToken();; break;; case tok_unary:; getNextToken();; if (!isascii(CurTok)); return LogErrorP(""Expected unary operator"");; FnName = ""unary"";; FnName += (char)CurTok;; Kind = 1;; getNextToken();; break;; case tok_binary:; ... As with binary operators, we name unary operators with a name that; includes the operator character. This assists us at code generation; time. Speaking of, the final piece we need to add is codegen support for; unary operators. It looks like this:. .. code-block:: c++. Value *UnaryExprAST::codegen() {; Value *OperandV = Operand->codegen();; if (!OperandV); return nullptr;. Function *F = getFunction(std::string(""unary"") + Opcode);; if (!F); return LogErrorV(""Unknown unary operator"");. return Builder->CreateCall(F, OperandV, ""unop"");; }. This code is similar to, but simpler than, the code for binary; operators. It is simpler primarily because it doesn't need to handle any; predefined operators. Kicking the Tires; =================. It is somewhat hard to believe, but with a few simple extensions we've; covered in the last chapters, we have grown a real-ish language. With; this, we can do a lot of interesting things, including I/O, math, and a; bunch of other things. For example, we can now add a nice sequencing; operator (printd is defined to print out the specified value and a; newline):. ::. ready> extern printd(x);; Read extern:; declare double @printd(double). ready> def binary : 1 (x y) 0; # Low-precedence operator that ignores operands.; ...; ready> printd(123) : printd(456) : printd(789);; 123.000000; 456.000000; 789.000000; Evaluated to 0.000000. We can also define a bunch of other ""primitive"" operations, such as:. ::. # Logical unary not.; def unary!(v); if v then; 0; else; 1;. # Unary negate.; def unary-(v); 0-v;. # Define > with the same precedence as <.; def binary> 10 (LHS RHS); RHS < LHS;. # Binary logical or, which doe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:14252,simpl,simpler,14252,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simpler']
Usability,"rn PreservedAnalyses::none();. // We've specifically updated the dominator tree alongside any transformations, but other analysis results may be invalid.; PreservedAnalyses PA;; PA.preserve<DominatorAnalysis>();; return PA;. // We haven't made any control flow changes, any analyses that only care about the control flow are still valid.; PreservedAnalyses PA;; PA.preserveSet<CFGAnalyses>();; return PA;. The pass manager will call the analysis manager's ``invalidate()`` method; with the pass's returned ``PreservedAnalyses``. This can be also done; manually within the pass:. .. code-block:: c++. FooModulePass::run(Module& M, ModuleAnalysisManager& AM) {; auto &FAM = AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();. // Invalidate all analysis results for function F1.; FAM.invalidate(F1, PreservedAnalyses::none());. // Invalidate all analysis results across the entire module.; AM.invalidate(M, PreservedAnalyses::none());. // Clear the entry in the analysis manager for function F2 if we've completely removed it from the module.; FAM.clear(F2);. ...; }. One thing to note when accessing inner level IR analyses is cached results for; deleted IR. If a function is deleted in a module pass, its address is still used; as the key for cached analyses. Take care in the pass to either clear the; results for that function or not use inner analyses at all. ``AM.invalidate(M, PreservedAnalyses::none());`` will invalidate the inner; analysis manager proxy which will clear all cached analyses, conservatively; assuming that there are invalid addresses used as keys for cached analyses.; However, if you'd like to be more selective about which analyses are; cached/invalidated, you can mark the analysis manager proxy as preserved,; essentially saying that all deleted entries have been taken care of manually.; This should only be done with measurable compile time gains as it can be tricky; to make sure all the right analyses are invalidated. Implementing Analysis Invalidation; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:13892,Clear,Clear,13892,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['Clear'],['Clear']
Usability,"rns of frontend; code generation. However, the styles also have a great deal in common. In all cases, an LLVM coroutine is initially represented as an ordinary LLVM; function that has calls to `coroutine intrinsics`_ defining the structure of; the coroutine. The coroutine function is then, in the most general case,; rewritten by the coroutine lowering passes to become the ""ramp function"",; the initial entrypoint of the coroutine, which executes until a suspend point; is first reached. The remainder of the original coroutine function is split; out into some number of ""resume functions"". Any state which must persist; across suspensions is stored in the coroutine frame. The resume functions; must somehow be able to handle either a ""normal"" resumption, which continues; the normal execution of the coroutine, or an ""abnormal"" resumption, which; must unwind the coroutine without attempting to suspend it. Switched-Resume Lowering; ------------------------. In LLVM's standard switched-resume lowering, signaled by the use of; `llvm.coro.id`, the coroutine frame is stored as part of a ""coroutine; object"" which represents a handle to a particular invocation of the; coroutine. All coroutine objects support a common ABI allowing certain; features to be used without knowing anything about the coroutine's; implementation:. - A coroutine object can be queried to see if it has reached completion; with `llvm.coro.done`. - A coroutine object can be resumed normally if it has not already reached; completion with `llvm.coro.resume`. - A coroutine object can be destroyed, invalidating the coroutine object,; with `llvm.coro.destroy`. This must be done separately even if the; coroutine has reached completion normally. - ""Promise"" storage, which is known to have a certain size and alignment,; can be projected out of the coroutine object with `llvm.coro.promise`.; The coroutine implementation must have been compiled to define a promise; of the same size and alignment. In general, interacting ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:2620,resume,resume,2620,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,ro Devices <https://www.amd.com/>`__. .. _amdgpu-dwarf-AMD-ROCgdb:. 2. [AMD-ROCgdb] `AMD ROCm Debugger (ROCgdb) <https://github.com/ROCm-Developer-Tools/ROCgdb>`__. .. _amdgpu-dwarf-AMD-ROCm:. 3. [AMD-ROCm] `AMD ROCm Platform <https://rocm-documentation.readthedocs.io>`__. .. _amdgpu-dwarf-AMDGPU-DWARF-LOC:. 4. [AMDGPU-DWARF-LOC] `Allow Location Descriptions on the DWARF Expression Stack <https://llvm.org/docs/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack.html>`__. .. _amdgpu-dwarf-AMDGPU-LLVM:. 5. [AMDGPU-LLVM] `User Guide for AMDGPU LLVM Backend <https://llvm.org/docs/AMDGPUUsage.html>`__. .. _amdgpu-dwarf-CUDA:. 6. [CUDA] `Nvidia CUDA Language <https://docs.nvidia.com/cuda/cuda-c-programming-guide/>`__. .. _amdgpu-dwarf-DWARF:. 7. [DWARF] `DWARF Debugging Information Format <http://dwarfstd.org/>`__. .. _amdgpu-dwarf-ELF:. 8. [ELF] `Executable and Linkable Format (ELF) <http://www.sco.com/developers/gabi/>`__. .. _amdgpu-dwarf-GCC:. 9. [GCC] `GCC: The GNU Compiler Collection <https://www.gnu.org/software/gcc/>`__. .. _amdgpu-dwarf-GDB:. 10. [GDB] `GDB: The GNU Project Debugger <https://www.gnu.org/software/gdb/>`__. .. _amdgpu-dwarf-HIP:. 11. [HIP] `HIP Programming Guide <https://rocm-documentation.readthedocs.io/en/latest/Programming_Guides/Programming-Guides.html#hip-programing-guide>`__. .. _amdgpu-dwarf-HSA:. 12. [HSA] `Heterogeneous System Architecture (HSA) Foundation <http://www.hsafoundation.com/>`__. .. _amdgpu-dwarf-LLVM:. 13. [LLVM] `The LLVM Compiler Infrastructure <https://llvm.org/>`__. .. _amdgpu-dwarf-OpenCL:. 14. [OpenCL] `The OpenCL Specification Version 2.0 <http://www.khronos.org/registry/cl/specs/opencl-2.0.pdf>`__. .. _amdgpu-dwarf-Perforce-TotalView:. 15. [Perforce-TotalView] `Perforce TotalView HPC Debugging Software <https://totalview.io/products/totalview>`__. .. _amdgpu-dwarf-SEMVER:. 16. [SEMVER] `Semantic Versioning <https://semver.org/>`__; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:235737,Guid,Guide,235737,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,3,"['Guid', 'guid']","['Guide', 'Guides', 'guide']"
Usability,"robability.i1(i1 <val>, i1 <expected_val>, double <prob>); declare i32 @llvm.expect.with.probability.i32(i32 <val>, i32 <expected_val>, double <prob>); declare i64 @llvm.expect.with.probability.i64(i64 <val>, i64 <expected_val>, double <prob>). Overview:; """""""""""""""""". The ``llvm.expect.with.probability`` intrinsic provides information about; expected value of ``val`` with probability(or confidence) ``prob``, which can; be used by optimizers. Arguments:; """""""""""""""""""". The ``llvm.expect.with.probability`` intrinsic takes three arguments. The first; argument is a value. The second argument is an expected value. The third; argument is a probability. Semantics:; """""""""""""""""""". This intrinsic is lowered to the ``val``. .. _int_assume:. '``llvm.assume``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.assume(i1 %cond). Overview:; """""""""""""""""". The ``llvm.assume`` allows the optimizer to assume that the provided; condition is true. This information can then be used in simplifying other parts; of the code. More complex assumptions can be encoded as; :ref:`assume operand bundles <assume_opbundles>`. Arguments:; """""""""""""""""""". The argument of the call is the condition which the optimizer may assume is; always true. Semantics:; """""""""""""""""""". The intrinsic allows the optimizer to assume that the provided condition is; always true whenever the control flow reaches the intrinsic call. No code is; generated for this intrinsic, and instructions that contribute only to the; provided condition are not used for code generation. If the condition is; violated during execution, the behavior is undefined. Note that the optimizer might limit the transformations performed on values; used by the ``llvm.assume`` intrinsic in order to preserve the instructions; only used to form the intrinsic's input argument. This might prove undesirable; if the extra information provided by the ``llvm.assume`` intrinsic does not cause; sufficient overall improvement in code quality. For th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:935304,simpl,simplifying,935304,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simplifying']
Usability,"rocess get.json request, which returns object in JSON form.; It can be used directly is script without special I/O of Bertrand.; - Use get.json on browser side to simplify logic. No need for extra; requests for streamer infos.; - Process get.xml request, provide full object streaming via TBufferXML.; It is complete object data, but with many custom-streamer data.; - Significant redesign of I/O part of JSRootIO code. Main change -; introduce JSROOTIO.TBuffer class which has similar functionality as; original TBufferFile class. Eliminate many places with duplicated code; - In JSRootIO avoid objects cloning when object referenced several times; - Treat special cases (collection, arrays) in one place.; This is major advantage, while any new classes should be implemented once.; - Object representation, produced by JSRootIO is similar to; objects, produced by TBufferJSON class. By this one can exchange; I/O engine and use same JavaSctript graphic for display.; - More clear functions to display different elements of the file.; In the future functions should be fully separated from I/O part; and organized in similar way as online part.; - Eliminate usage of gFile pointer in the I/O part.; - Provide TBufferJSON::JsonWriteMember method. It allows to stream any; selected data member of the class. Supported are: basic data types,; arrays of basic data types, TString, TArray classes. Also any object; as data member can be streamed.; - TRootSniffer do not creates sublevels for base classes; - When streaming data member, TBufferJSON produces array with all dimensions; only when fCompact==0. By default, THttpServer uses compact=1 for member; - Support both get.json and root.json requests, they have similar meaning. January 2014; - Make THttpServer::CreateEngine as factory method. One could; create http, fastcgi and dabc engines to access data from server.; Syntax allows to provide arbitrary arguments. Examples:; THttpServer* serv = new THttpServer();; serv->CreateEngine(""http:8080"")",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt:3382,clear,clear,3382,net/http/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt,1,['clear'],['clear']
Usability,"roject`` build directory where you; configured CMake to use Ninja. You have a file ``repro.c`` in the current; directory that makes clang crash at trunk, but it worked fine at revision; ``f00ba``. .. code-block:: bash. # Build clang. If the build fails, `exit 125` causes this; # revision to be skipped; ninja -C ../llvm-build-project clang || exit 125. ../llvm-build-project/bin/clang repro.c. To make sure your run script works, it's a good idea to run ``./run.sh`` by; hand and tweak the script until it works, then run ``git bisect good`` or; ``git bisect bad`` manually once based on the result of the script; (check ``echo $?`` after your script ran), and only then run ``git bisect run; ./run.sh``. Don't forget to mark your run script as executable -- ``git bisect; run`` doesn't check for that, it just assumes the run script failed each time. Once your run script works, run ``git bisect run ./run.sh`` and a few hours; later you'll know which commit caused the regression. (This is a very simple run script. Often, you want to use just-built clang; to build a different project and then run a built executable of that project; in the run script.). Bisecting across multiple roots; ===============================. Here's how LLVM's history currently looks:. .. code-block:: none. A-o-o-......-o-D-o-o-HEAD; /; B-o-...-o-C-. ``A`` is the first commit in LLVM ever, ``97724f18c79c``. ``B`` is the first commit in MLIR, ``aed0d21a62db``. ``D`` is the merge commit that merged MLIR into the main LLVM repository,; ``0f0d0ed1c78f``. ``C`` is the last commit in MLIR before it got merged, ``0f0d0ed1c78f^2``. (The; ``^n`` modifier selects the n'th parent of a merge commit.). ``git bisect`` goes through all parent revisions. Due to the way MLIR was; merged, at every revision at ``C`` or earlier, *only* the ``mlir/`` directory; exists, and nothing else does. As of early 2020, there is no flag to ``git bisect`` to tell it to not; descend into all reachable commits. Ideally, we'd want to tell ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitBisecting.rst:2956,simpl,simple,2956,interpreter/llvm-project/llvm/docs/GitBisecting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitBisecting.rst,1,['simpl'],['simple']
Usability,"rontend. The suspend point takes a function and its arguments. The function is intended; to model the transfer to the callee function. It will be tail called by; lowering and therefore must have the same signature and calling convention as; the async coroutine. .. code-block:: llvm. call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function,; ptr %suspend_function,; ptr %arg1, ptr %arg2, i8 %arg3). Coroutines by Example; =====================. The examples below are all of switched-resume coroutines. Coroutine Representation; ------------------------. Let's look at an example of an LLVM coroutine with the behavior sketched; by the following pseudo-code. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend> // returns a coroutine handle on first suspend; }; }. This coroutine calls some function `print` with value `n` as an argument and; suspends execution. Every time this coroutine resumes, it calls `print` again with an argument one bigger than the last time. This coroutine never completes by itself and must be destroyed explicitly. If we use this coroutine with; a `main` shown in the previous section. It will call `print` with values 4, 5; and 6 after which the coroutine will be destroyed. The LLVM IR for this coroutine looks like this:. .. code-block:: llvm. define ptr @f(i32 %n) presplitcoroutine {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %size = call i32 @llvm.coro.size.i32(); %alloc = call ptr @malloc(i32 %size); %hdl = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); br label %loop; loop:; %n.val = phi i32 [ %n, %entry ], [ %inc, %loop ]; %inc = add nsw i32 %n.val, 1; call void @print(i32 %n.val); %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %loop; i8 1, label %cleanup]; cleanup:; %mem = call ptr @llvm.coro.free(token %id, ptr %hdl); call void @free(ptr %mem); br label %suspend; suspen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:11186,resume,resumes,11186,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resumes']
Usability,"root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; ```. Here the default location `https://root.cern/js/latest/` is specified. One always can install JSROOT on private web server.; When JSROOT is used with THttpServer, the address looks like:. ```javascript; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; ```. Loading main module is enough to get public JSROOT functionality - reading files and drawing objects.; One also can load some special components directly like:. ```javascript; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; ```. After script loading one can configure different parameters in `gStyle` object.; It is instance of the `TStyle` object and behaves like `gStyle` variable in ROOT. For instance,; to change stat format using to display value in stats box:. ```javascript; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; ```. There is also `settings` object which contains all other JSROOT settings. For instance,; one can configure custom format for different axes:. ```javascript; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; ```. One also can use `build/jsroot.js` bundle to load all functionality at one and access it via `JSROOT` global h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:35308,simpl,simple,35308,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['simpl'],['simple']
Usability,"root-project/root/issues/14277)] - Cling triggers a huge number of `openat` calls when loading libraries; * [[#14263](https://github.com/root-project/root/issues/14263)] - [tmva] When using DNN_USE_CBLAS, CMakeLists should link publicly to gsl instead of privately; * [[#14256](https://github.com/root-project/root/issues/14256)] - TAxis::GetTicks and TAxis::SetTicks are inconsistent. Significantly so.; * [[#14244](https://github.com/root-project/root/issues/14244)] - String comparison operators defined in TString.h should be defined as constexpr; * [[#14229](https://github.com/root-project/root/issues/14229)] - [6.30] root-config --git-revision broken; * [[#14225](https://github.com/root-project/root/issues/14225)] - [RF] Segmentation fault in ROOT 6.30 workspace creation; * [[#14223](https://github.com/root-project/root/issues/14223)] - Extremely long startup time when loading dictionaries with pyroot; * [[#14219](https://github.com/root-project/root/issues/14219)] - [cling] Use deduction guides for llvm::ArrayRef; * [[#14211](https://github.com/root-project/root/issues/14211)] - Implement value printing for `std::source_location`; * [[#14205](https://github.com/root-project/root/issues/14205)] - [cling] Replace llvm::Optional and llvm::None with std::optional; * [[#14199](https://github.com/root-project/root/issues/14199)] - Memory hoarding triggered by the TPluginManager; * [[#14188](https://github.com/root-project/root/issues/14188)] - cmake find_package ROOT 6.30 broken: it requires nlohmann-json; * [[#14163](https://github.com/root-project/root/issues/14163)] - cmake find_package ROOT broken with 6.30, nlohmann and vdt are builtin but not found; * [[#14162](https://github.com/root-project/root/issues/14162)] - `RooFFTConvPdf` is not working for ROOT 6.30/02; * [[#14157](https://github.com/root-project/root/issues/14157)] - Minuit2 standalone build: StandAlone.cmake looks for the wrong path for VERSION_FILE; * [[#14113](https://github.com/root-project/root/issues",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:34557,guid,guides,34557,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['guid'],['guides']
Usability,"root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This class includes functions to set some of the following; object attributes. - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles; - etc ... - **[gSystem](https://root.cern.ch/doc/master/classTSystem.html)**: An; instance of a base class defining a generic interface to the; underlying Operating System, in our case `TUnixSystem`. - **[gInterpreter](http://root.cern.ch/htmldoc/html/TInterpreter.html)**: The; entry point for the ROOT interpreter. Technically an abstraction level; over a singleton instance of `TCling`. At this point you have already learnt quite a bit about some basic; features of ROOT. ***Please move on to become an expert!***. [^2]: All ROOT classes' names start with the letter T. A notable exception is; RooFit. In this context all classes' names are of the form Roo*. Starting with; ROOT7, all names start with and R.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:21304,learn,learnt,21304,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['learn'],['learnt']
Usability,"ropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<ComplexType>hasElementTypeMatcher<Type>; Matches arrays and C99 complex types that have a specific element; type. Given; struct A {};; A a[7];; int b[7];; arrayType(hasElementType(builtinType())); matches ""int b[7]"". Usable as: Matcher<ArrayType>, Matcher<ComplexType>. Matcher<CompoundLiteralExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CompoundStmt>hasAnySubstatementMatcher<Stmt> InnerMatcher; Matches compound statements where at least one substatement matches; a given matcher. Also matches StmtExprs that have CompoundStmt as children. Given; { {}; 1+2; }; hasAnySubstatement(compoundStmt()); matches '{ {}; 1+2; }'; with compoundStmt(); matching '{}'. Matcher<CoroutineBodyStmt>hasBodyMatcher<Stmt> InnerMatcher; Matches a 'for', 'while', 'while' statement or a function or coroutine; definition that has a given body. Note that in case of functions or; coroutines this matcher only matches the definition itself and not the; other declarations of the same function or coroutine. Given; for (;;) {}; forStmt(hasBody(compoundStmt())); matches 'for (;;) {}'; with compoundStmt(); matching '{}'. Given; void f();;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:181571,Usab,Usable,181571,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ror. .. _recursiveExpansionLimit:. **recursiveExpansionLimit:**. As described in the previous section, when expanding substitutions in a ``RUN:``; line, lit makes only one pass through the substitution list by default. Thus,; if substitutions are not defined in the proper order, some will remain in the; ``RUN:`` line unexpanded. For example, the following directives refer to; ``%{inner}`` within ``%{outer}`` but do not define ``%{inner}`` until after; ``%{outer}``:. .. code-block:: llvm. ; By default, this definition order does not enable full expansion. ; DEFINE: %{outer} = %{inner}; ; DEFINE: %{inner} = expanded. ; RUN: echo '%{outer}'. ``DEFINE:`` inserts substitutions at the start of the substitution list, so; ``%{inner}`` expands first but has no effect because the original ``RUN:`` line; does not contain ``%{inner}``. Next, ``%{outer}`` expands, and the output of; the ``echo`` command becomes:. .. code-block:: shell. %{inner}. Of course, one way to fix this simple case is to reverse the definitions of; ``%{outer}`` and ``%{inner}``. However, if a test has a complex set of; substitutions that can all reference each other, there might not exist a; sufficient substitution order. To address such use cases, lit configuration files support; ``config.recursiveExpansionLimit``, which can be set to a non-negative integer; to specify the maximum number of passes through the substitution list. Thus, in; the above example, setting the limit to 2 would cause lit to make a second pass; that expands ``%{inner}`` in the ``RUN:`` line, and the output from the ``echo``; command when then be:. .. code-block:: shell. expanded. To improve performance, lit will stop making passes when it notices the ``RUN:``; line has stopped changing. In the above example, setting the limit higher than; 2 is thus harmless. To facilitate debugging, after reaching the limit, lit will make one extra pass; and report an error if the ``RUN:`` line changes again. In the above example,; setting the limit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:36585,simpl,simple,36585,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['simpl'],['simple']
Usability,"rors`**, **`TGraphAsymmErrors`**, and; **`TMultiGraph`**. ## TGraph. The **`TGraph`** class supports the general case with non-equidistant; points, and the special case with equidistant points. Graphs are; created with the **`TGraph`** constructor. First, we define the arrays; of coordinates and then create the graph. The coordinates can be; arrays of doubles or floats. ``` {.cpp}; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0; i<n; i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; TGraph *gr1 = new TGraph (n, x, y);; ```. An alternative constructor takes only the number of points `n`. It is; expected that the coordinates will be set later. ``` {.cpp}; TGraph *gr2 = new TGraph(n);; ```. The default constructor can also be used. Further calls to; `SetPoint()` will extend the internal vectors. ``` {.cpp}; TGraph *gr3 = new TGraph();; ```. ### Graph Draw Options. The various drawing options for a graph are explained in; `TGraph::PaintGraph`. They are:. - ""`L`"" A simple poly-line between every points is drawn. - ""`F`"" A fill area is drawn. - ""`F1`"" Idem as ""`F`"" but fill area is no more repartee around; X=0 or Y=0. - ""`F2`"" draw a fill area poly line connecting the center of bins. - ""`A`"" Axis are drawn around the graph. - ""`C`"" A smooth curve is drawn. - ""`*`"" A star is plotted at each point. - ""`P`"" The current marker of the graph is plotted at each point. - ""`B`"" A bar chart is drawn at each point. - ""`[]` "" Only the end vertical/horizontal lines of the error bars; are drawn. This option only applies to the; **`TGraphAsymmErrors`**. - ""`1`"" `ylow` `=` `rwymin`. The options are not case sensitive and they can be concatenated in; most cases. Let us look at some examples. #### Continuous Line, Axis and Stars (AC\*). ![A graph drawn with axis, \* markers and continuous line (option AC\*)](pictures/0300004B.png). ``` {.cpp}; {; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }. // create graph; TGraph *gr = ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:1161,simpl,simple,1161,documentation/users-guide/Graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md,1,['simpl'],['simple']
Usability,"rrent direction `(nx,ny,nz)`. This; direction is stored as `Double_t fCurrentDirection[3]` by the navigator; and it represents a direction in the global frame. It can be retrieved; with:. ~~~{.cpp}; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; ~~~. The direction can be initialized in a similar manner as the current; point:. ~~~{.cpp}; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; ~~~. \anchor GP02d; ### Initializing the State. Setting the initial point and direction is not enough for initializing; tracking. The modeller needs to find out where the initial point is; located in the geometrical hierarchy. Due to the containment based; architecture of the model, this is the deepest positioned object; containing the point. For illustrating this, imagine that we have a; simple structure with a top volume `A` and another one `B `positioned; inside. Since `A `is a top volume, its associated node `A_1` will define; `MARS` and our simple hierarchy of nodes (positioned volumes) will be:; `/A_1/B_1`. Suppose now that the initial point is contained by `B_1`.; This implies by default that the point is also contained by `A_1`, since; `B_1` have to be fully contained by this. After searching the point; location, the modeller will consider that the point is located inside; `B_1`, which will be considered as the representative object (node) for; the current state. This is stored as: `TGeoNode *TGeoNavigator::%fCurrentNode`; and can be asked from the manager class; only after the `'Where am I?'` was completed:. ~~~{.cpp}; TGeoNode *current = gGeoManager->GetCurrentNode();; ~~~. In order to find the location of the current point inside the hierarchy; of nodes, after setting this point it is mandatory to call the; `‘Where am I?'` method:. ~~~{.cpp}; gGeoManager->FindNode();; ~~~. In order to have more flexibility, there are in fact several alternative; ways of initializing a modeller state:. ~~~{.cpp}; // Setting th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:66034,simpl,simple,66034,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"rresponding to the lucky first header. Any other headers that have copy-and-pasted versions of this pattern will *not* have a definition of ``size_t``. Importing the submodule corresponding to one of those headers will therefore not yield ``size_t`` as part of the API, because it wasn't there when the header was parsed. The fix for this problem is either to pull the copied declarations into a common header that gets included everywhere ``size_t`` is part of the API, or to eliminate the ``#ifndef`` and redefine the ``size_t`` type. The latter works for C++ headers and C11, but will cause an error for non-modules C90/C99, where redefinition of ``typedefs`` is not permitted. **Conflicting definitions**; Different system headers may provide conflicting definitions for various macros, functions, or types. These conflicting definitions don't tend to cause problems in a pre-modules world unless someone happens to include both headers in one translation unit. Since the fix is often simply ""don't do that"", such problems persist. Modules requires that the conflicting definitions be eliminated or that they be placed in separate modules (the former is generally the better answer). **Missing includes**; Headers are often missing ``#include`` directives for headers that they actually depend on. As with the problem of conflicting definitions, this only affects unlucky users who don't happen to include headers in the right order. With modules, the headers of a particular module will be parsed in isolation, so the module may fail to build if there are missing includes. **Headers that vend multiple APIs at different times**; Some systems have headers that contain a number of different kinds of API definitions, only some of which are made available with a given include. For example, the header may vend ``size_t`` only when the macro ``__need_size_t`` is defined before that header is included, and also vend ``wchar_t`` only when the macro ``__need_wchar_t`` is defined. Such headers are",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:54391,simpl,simply,54391,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simply']
Usability,"rse.llvm.org</td></tr>; <tr><td>Community - Women in Compilers and Tools</td><td>wict@discourse.llvm.org</td></tr>; <tr><td>Community - Job Postings</td><td>community-jobs@discourse.llvm.org</td></tr>; <tr><td>Community - US LLVM Developers' Meeting</td><td>devmtg-US@discourse.llvm.org</td></tr>; <tr><td>Community - EuroLLVM</td><td>devmtg-euro@discourse.llvm.org</td></tr>; <tr><td>Community - GSOC</td><td>gsoc@discourse.llvm.org</td></tr>; <tr><td>Community - Community.o</td><td>community-dot-o@discourse.llvm.org</td></tr>; <tr><td>Community - LLVM Foundation</td><td>foundation@discourse.llvm.org</td></tr>; <tr><td>Community - Newsletters</td><td>newsletters@discourse.llvm.org</td></tr>; <tr><td>Incubator</td><td>incubator@discourse.llvm.org</td></tr>; <tr><td>Incubator - CIRCT</td><td>circt@discourse.llvm.org</td></tr>; <tr><td>Incubator - Torch-MLIR</td><td>torch-mlir@discourse.llvm.org</td></tr>; <tr><td>Incubator - Enzyme</td><td>enzyme@discourse.llvm.org</td></tr>; <tr><td>Feedback</td><td>feedback@discourse.llvm.org</td></tr>; </table>. ## Mapping of mailing lists to categories. This table explains the mapping from mailing lists to categories in Discourse.; The email addresses of these categories will remain the same, after the; migration. Obsolete lists will become read-only as part of the Discourse; migration. <table border=1>; <tr><th>Mailing lists</th><th>Category in Discourse</th></tr>. <tr><td>All-commits</td><td>no migration at the moment</td></tr>; <tr><td>Bugs-admin</td><td>no migration at the moment</td></tr>; <tr><td>cfe-commits</td><td>no migration at the moment</td></tr>; <tr><td>cfe-dev</td><td>Clang Frontend</td></tr>; <tr><td>cfe-users</td><td>Clang Frontend/Using Clang</td></tr>; <tr><td>clangd-dev</td><td>Clang Frontend/clangd</td></tr>; <tr><td>devmtg-organizers</td><td>Obsolete</td></tr>; <tr><td>Docs</td><td>Obsolete</td></tr>; <tr><td>eurollvm-organizers</td><td>Obsolete</td></tr>; <tr><td>flang-commits</td><td>no migration at the moment<",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md:7168,Feedback,Feedback,7168,interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,2,"['Feedback', 'feedback']","['Feedback', 'feedback']"
Usability,rser/MILexer.h; llvm/lib/CodeGen/SelectionDAG/SelectionDAGTargetInfo.cpp; llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h; llvm/lib/DebugInfo/CodeView/CodeViewError.cpp; llvm/lib/DebugInfo/CodeView/CodeViewRecordIO.cpp; llvm/lib/DebugInfo/CodeView/CVSymbolVisitor.cpp; llvm/lib/DebugInfo/CodeView/DebugCrossExSubsection.cpp; llvm/lib/DebugInfo/CodeView/DebugFrameDataSubsection.cpp; llvm/lib/DebugInfo/CodeView/DebugLinesSubsection.cpp; llvm/lib/DebugInfo/CodeView/DebugStringTableSubsection.cpp; llvm/lib/DebugInfo/CodeView/DebugSubsection.cpp; llvm/lib/DebugInfo/CodeView/DebugSubsectionRecord.cpp; llvm/lib/DebugInfo/CodeView/DebugSubsectionVisitor.cpp; llvm/lib/DebugInfo/CodeView/DebugSymbolRVASubsection.cpp; llvm/lib/DebugInfo/CodeView/DebugSymbolsSubsection.cpp; llvm/lib/DebugInfo/CodeView/GlobalTypeTableBuilder.cpp; llvm/lib/DebugInfo/CodeView/Line.cpp; llvm/lib/DebugInfo/CodeView/MergingTypeTableBuilder.cpp; llvm/lib/DebugInfo/CodeView/RecordSerialization.cpp; llvm/lib/DebugInfo/CodeView/SimpleTypeSerializer.cpp; llvm/lib/DebugInfo/CodeView/StringsAndChecksums.cpp; llvm/lib/DebugInfo/CodeView/SymbolRecordHelpers.cpp; llvm/lib/DebugInfo/CodeView/SymbolSerializer.cpp; llvm/lib/DebugInfo/CodeView/TypeHashing.cpp; llvm/lib/DebugInfo/CodeView/TypeIndex.cpp; llvm/lib/DebugInfo/CodeView/TypeTableCollection.cpp; llvm/lib/DebugInfo/DWARF/DWARFAddressRange.cpp; llvm/lib/DebugInfo/DWARF/DWARFCompileUnit.cpp; llvm/lib/DebugInfo/DWARF/DWARFDataExtractor.cpp; llvm/lib/DebugInfo/DWARF/DWARFDebugInfoEntry.cpp; llvm/lib/DebugInfo/DWARF/DWARFDebugMacro.cpp; llvm/lib/DebugInfo/DWARF/DWARFDebugRnglists.cpp; llvm/lib/DebugInfo/DWARF/DWARFGdbIndex.cpp; llvm/lib/DebugInfo/DWARF/DWARFLocationExpression.cpp; llvm/lib/DebugInfo/DWARF/DWARFTypeUnit.cpp; llvm/lib/DebugInfo/GSYM/GsymCreator.cpp; llvm/lib/DebugInfo/GSYM/LookupResult.cpp; llvm/lib/DebugInfo/MSF/MSFBuilder.cpp; llvm/lib/DebugInfo/MSF/MSFCommon.cpp; llvm/lib/DebugInfo/MSF/MSFError.cpp; llvm/lib/DebugInfo/PDB/GenericError.cpp; ll,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:280116,Simpl,SimpleTypeSerializer,280116,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimpleTypeSerializer']
Usability,"rship are deprecated and replaced by a new constructor that takes ownership via `std::unique_ptr<T>`. They will be removed in ROOT 6.36.; - Several RooFit legacy functions are deprecated and will be removed in ROOT 6.36 (see section ""RooFit libraries""); - Multiple overloads of internal Minuit 2 constructors and functions have been removed. If your code fails to compile, you can easily change to another overload that takes a `MnUserParameterState`, which is a change backwards compatible with older ROOT versions. ## Core Libraries. * The `rootcling` invocation corresponding to a `genreflex` invocation can be obtained with the new `genreflex`; command line argument `--print-rootcling-invocation`. This can be useful when migrating from genreflex to; rootcling.; * The `rootcling` utility now fully supports selection xml files and not only LinkDef files. ## I/O Libraries. ## TTree Libraries. ## RDataFrame. * The `GetColumnNames` function to retrieve the number of available column names in the RDataFrame object is now also; usable from a node of a distributed computation graph. This makes the generation of said computation graph slightly; less lazy than before. Notably, it used to be the case that a distributed computation graph could be defined with; code that was not yet available on the user's local application, but that would only become available in the; distributed worker. Now a call such as `df.Define(""mycol"", ""return run_my_fun();"")` needs to be at least declarable; to the interpreter also locally so that the column can be properly tracked. ## Histogram Libraries. ### Upgrade TUnfold to version 17.9. The [TUnfold package](https://www.desy.de/~sschmitt/tunfold.html) inside ROOT is upgraded from version 17.6 to version 17.9. ## Math Libraries. ### Usage of `std::span<const double>` in Minuit 2 interfaces. To avoid forcing the user to do manual memory allocations via `std::vector`, the interfaces of Minuit 2 function adapter classes like `ROOT::Minuit2::FCNBase` or `R",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:3458,usab,usable,3458,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,1,['usab'],['usable']
Usability,"rstanding of the interface. In several cases, the misunderstanding of the interface caused invalid memory accesses to the already destructed; temporary `TString` returned by `GetString()`, e.g. `objStr->GetString().Data()`. This will be fixed automatically by the; new return type. In rare cases, the caller expected `GetString()` to return a (non-const) reference to the embedded `TString`, e.g.; `objString->GetString().ReplaceAll(""a"", ""b""); // WRONG!` This will now fail to compile, instead of not doing what the author of the; code expected. Please fix that code by using the `TObjString::String()` interface, which returns a non-const `TString&`:; `objString->String().ReplaceAll(""a"", ""b"");`. In extremely rare cases, this change breaks a valid use where the temporary `TString` was modified and then captured in a new `TString`; object before the destruction of the temporary: `TString str = objStr->GetString().ReplaceAll(""a"", ""b"");`. In these rare cases,; please use the new function `CopyString()` which clearly indicates that it involves a temporary. ## Histogram Libraries. - New class `THnChain` was added to provide a `TChain`-like experience when; working with `THnBase`'ed histograms (currently `THn` and `THnSparse`) from; many files, see [here](https://sft.its.cern.ch/jira/browse/ROOT-4515). This; allows to e.g., interactively adjust axis parameters before performing; projections from high-dimensional histograms,. ```{.cpp}; // Create a chain of histograms called `h`.; THnChain chain(""h"");. // Add files containing histograms `h` to `chain`.; chain->AddFile(""file1.root"");. chain->GetXaxis(1)->SetRangeUser(0.1, 0.2);. TH1* projection = chain->Projection(0); ```. ## Math Libraries. * Improve thread friendliness of the TMinuit class. ## RooFit Libraries. - Remove deprecated `RooComplex` superseded by `std::complex`. ## TTree Libraries. - `TTreeReader` now supports `TEntryList`s, `Double32_t` / `Float16_t`.; - `TTreeReader::SetLastEntry()` has been deprecated. Its name is mi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:4164,clear,clearly,4164,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['clear'],['clearly']
Usability,"rt forward declaration of user functions. These; 'extern's are just prototypes with no body:. .. code-block:: c++. /// external ::= 'extern' prototype; static std::unique_ptr<PrototypeAST> ParseExtern() {; getNextToken(); // eat extern.; return ParsePrototype();; }. Finally, we'll also let the user type in arbitrary top-level expressions; and evaluate them on the fly. We will handle this by defining anonymous; nullary (zero argument) functions for them:. .. code-block:: c++. /// toplevelexpr ::= expression; static std::unique_ptr<FunctionAST> ParseTopLevelExpr() {; if (auto E = ParseExpression()) {; // Make an anonymous proto.; auto Proto = std::make_unique<PrototypeAST>("""", std::vector<std::string>());; return std::make_unique<FunctionAST>(std::move(Proto), std::move(E));; }; return nullptr;; }. Now that we have all the pieces, let's build a little driver that will; let us actually *execute* this code we've built!. The Driver; ==========. The driver for this simply invokes all of the parsing pieces with a; top-level dispatch loop. There isn't much interesting here, so I'll just; include the top-level loop. See `below <#full-code-listing>`_ for full code in the; ""Top-Level Parsing"" section. .. code-block:: c++. /// top ::= definition | external | expression | ';'; static void MainLoop() {; while (true) {; fprintf(stderr, ""ready> "");; switch (CurTok) {; case tok_eof:; return;; case ';': // ignore top-level semicolons.; getNextToken();; break;; case tok_def:; HandleDefinition();; break;; case tok_extern:; HandleExtern();; break;; default:; HandleTopLevelExpression();; break;; }; }; }. The most interesting part of this is that we ignore top-level; semicolons. Why is this, you ask? The basic reason is that if you type; ""4 + 5"" at the command line, the parser doesn't know whether that is the; end of what you will type or not. For example, on the next line you; could type ""def foo..."" in which case 4+5 is the end of a top-level; expression. Alternatively you could type ""\",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:23106,simpl,simply,23106,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simply']
Usability,"rtain size and alignment,; can be projected out of the coroutine object with `llvm.coro.promise`.; The coroutine implementation must have been compiled to define a promise; of the same size and alignment. In general, interacting with a coroutine object in any of these ways while; it is running has undefined behavior. The coroutine function is split into three functions, representing three; different ways that control can enter the coroutine:. 1. the ramp function that is initially invoked, which takes arbitrary; arguments and returns a pointer to the coroutine object;. 2. a coroutine resume function that is invoked when the coroutine is resumed,; which takes a pointer to the coroutine object and returns `void`;. 3. a coroutine destroy function that is invoked when the coroutine is; destroyed, which takes a pointer to the coroutine object and returns; `void`. Because the resume and destroy functions are shared across all suspend; points, suspend points must store the index of the active suspend in; the coroutine object, and the resume/destroy functions must switch over; that index to get back to the correct point. Hence the name of this; lowering. Pointers to the resume and destroy functions are stored in the coroutine; object at known offsets which are fixed for all coroutines. A completed; coroutine is represented with a null resume function. There is a somewhat complex protocol of intrinsics for allocating and; deallocating the coroutine object. It is complex in order to allow the; allocation to be elided due to inlining. This protocol is discussed; in further detail below. The frontend may generate code to call the coroutine function directly;; this will become a call to the ramp function and will return a pointer; to the coroutine object. The frontend should always resume or destroy; the coroutine using the corresponding intrinsics. Returned-Continuation Lowering; ------------------------------. In returned-continuation lowering, signaled by the use of; `llvm.co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:4283,resume,resume,4283,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,['resume'],['resume']
Usability,rter.h; RooStats/HypoTestInverterPlot.h; RooStats/HypoTestInverterResult.h; RooStats/HypoTestPlot.h; RooStats/HypoTestResult.h; RooStats/IntervalCalculator.h; RooStats/LikelihoodInterval.h; RooStats/LikelihoodIntervalPlot.h; RooStats/MarkovChain.h; RooStats/MaxLikelihoodEstimateTestStat.h; RooStats/MCMCCalculator.h; RooStats/MCMCInterval.h; RooStats/MCMCIntervalPlot.h; RooStats/MetropolisHastings.h; RooStats/MinNLLTestStat.h; RooStats/ModelConfig.h; RooStats/NeymanConstruction.h; RooStats/NumberCountingPdfFactory.h; RooStats/NumberCountingUtils.h; RooStats/NumEventsTestStat.h; RooStats/PdfProposal.h; RooStats/PointSetInterval.h; RooStats/ProfileInspector.h; RooStats/ProfileLikelihoodCalculator.h; RooStats/ProfileLikelihoodTestStat.h; RooStats/ProofConfig.h; RooStats/ProposalFunction.h; RooStats/ProposalHelper.h; RooStats/RatioOfProfiledLikelihoodsTestStat.h; RooStats/RooStatsUtils.h; RooStats/SamplingDistPlot.h; RooStats/SamplingDistribution.h; RooStats/SequentialProposal.h; RooStats/SimpleInterval.h; RooStats/SimpleLikelihoodRatioTestStat.h; RooStats/SPlot.h; RooStats/TestStatistic.h; RooStats/TestStatSampler.h; RooStats/ToyMCImportanceSampler.h; RooStats/ToyMCSampler.h; RooStats/ToyMCStudy.h; RooStats/UniformProposal.h; RooStats/UpperLimitMCSModule.h; SOURCES; src/AsymptoticCalculator.cxx; src/BayesianCalculator.cxx; src/BernsteinCorrection.cxx; src/ConfidenceBelt.cxx; src/DetailedOutputAggregator.cxx; src/FeldmanCousins.cxx; src/FrequentistCalculator.cxx; src/Heaviside.cxx; src/HLFactory.cxx; src/HybridCalculator.cxx; src/HybridPlot.cxx; src/HybridResult.cxx; src/HypoTestCalculatorGeneric.cxx; src/HypoTestInverter.cxx; src/HypoTestInverterPlot.cxx; src/HypoTestInverterResult.cxx; src/HypoTestPlot.cxx; src/HypoTestResult.cxx; src/LikelihoodInterval.cxx; src/LikelihoodIntervalPlot.cxx; src/MarkovChain.cxx; src/MCMCCalculator.cxx; src/MCMCInterval.cxx; src/MCMCIntervalPlot.cxx; src/MetropolisHastings.cxx; src/NeymanConstruction.cxx; src/NumberCountingPdfFactory.cxx; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/CMakeLists.txt:2134,Simpl,SimpleInterval,2134,roofit/roostats/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/CMakeLists.txt,1,['Simpl'],['SimpleInterval']
Usability,"rticular issue or concern (although no committed patch should leave the; project in a broken state). Moreover, reviewers can accept a patch conditioned on; the author applying some set of minor updates prior to committing, and when; applicable, it is polite for reviewers to do so. Don't Unintentionally Block a Review; ------------------------------------. If you review a patch, but don't intend for the review process to block on your; approval, please state that explicitly. Out of courtesy, we generally wait on; committing a patch until all reviewers are satisfied, and if you don't intend; to look at the patch again in a timely fashion, please communicate that fact in; the review. Who Can/Should Review Code?; ===========================. Non-Experts Should Review Code; ------------------------------. You do not need to be an expert in some area of the code base to review patches;; it's fine to ask questions about what some piece of code is doing. If it's not; clear to you what is going on, you're unlikely to be the only one. Please; remember that it is not in the long-term best interest of the community to have; components that are only understood well by a small number of people. Extra; comments and/or test cases can often help (and asking for comments in the test; cases is fine as well). Moreover, authors are encouraged to interpret questions as a reason to reexamine; the readability of the code in question. Structural changes, or further; comments, may be appropriate. If you're new to the LLVM community, you might also find this presentation helpful:; .. _How to Contribute to LLVM, A 2019 LLVM Developers' Meeting Presentation: https://youtu.be/C5Y977rLqpw. A good way for new contributors to increase their knowledge of the code base is; to review code. It is perfectly acceptable to review code and explicitly; defer to others for approval decisions. Experts Should Review Code; --------------------------. If you are an expert in an area of the compiler affected by a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:10058,clear,clear,10058,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['clear'],['clear']
Usability,"rting this for the driver build. It will require changing; # the perf-helper.py file to understand to call `llvm` as `llvm clang`.; if(APPLE AND DTRACE AND NOT LLVM_TOOL_LLVM_DRIVER_BUILD); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/order-files.lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/order-files/lit.site.cfg; ). add_lit_testsuite(generate-dtrace-logs ""Generating clang dtrace data""; ${CMAKE_CURRENT_BINARY_DIR}/order-files/; EXCLUDE_FROM_CHECK_ALL; ARGS -j 1; DEPENDS clang clear-dtrace-logs; ). add_custom_target(clear-dtrace-logs; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py clean ${CMAKE_CURRENT_BINARY_DIR} dtrace; COMMENT ""Clearing old dtrace data""). if(NOT CLANG_ORDER_FILE); message(FATAL_ERROR ""Output clang order file is not set""); endif(). add_custom_target(generate-order-file; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py gen-order-file --binary $<TARGET_FILE:clang> --output ${CLANG_ORDER_FILE} ${CMAKE_CURRENT_BINARY_DIR}; COMMENT ""Generating order file""; DEPENDS generate-dtrace-logs); endif(). if(CLANG_BOLT_INSTRUMENT AND NOT LLVM_BUILD_INSTRUMENTED); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/bolt.lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/bolt-fdata/lit.site.cfg; ). add_lit_testsuite(generate-bolt-fdata ""Generating BOLT profile for Clang""; ${CMAKE_CURRENT_BINARY_DIR}/bolt-fdata/; EXCLUDE_FROM_CHECK_ALL; DEPENDS clang-instrumented clear-bolt-fdata; ). add_custom_target(clear-bolt-fdata; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py clean ${CMAKE_CURRENT_BINARY_DIR} fdata; COMMENT ""Clearing old BOLT fdata""). # Merge profiles into one using merge-fdata; add_custom_target(clang-bolt-profile; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py merge-fdata $<TARGET_FILE:merge-fdata> ${CMAKE_CURRENT_BINARY_DIR}/prof.fdata ${CMAKE_CURRENT_BINARY_DIR}; COMMENT ""Merging BOLT fdata""; DEPENDS merge-fdata generate-bolt-fdata); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt:3289,clear,clear-bolt-fdata,3289,interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,3,"['Clear', 'clear']","['Clearing', 'clear-bolt-fdata']"
Usability,"ructions such that they are legal. A legal instruction is defined as:. * **selectable** --- the target will later be able to select it to a; target-specific (non-generic) instruction. This doesn't necessarily mean that; :doc:`InstructionSelect` has to handle it though. It just means that; **something** must handle it. * operating on **vregs that can be loaded and stored** -- if necessary, the; target can select a ``G_LOAD``/``G_STORE`` of each gvreg operand. As opposed to SelectionDAG, there are no legalization phases. In particular,; 'type' and 'operation' legalization are not separate. Legalization is iterative, and all state is contained in GMIR. To maintain the; validity of the intermediate code, instructions are introduced:. * ``G_MERGE_VALUES`` --- concatenate multiple registers of the same; size into a single wider register. * ``G_UNMERGE_VALUES`` --- extract multiple registers of the same size; from a single wider register. * ``G_EXTRACT`` --- extract a simple register (as contiguous sequences of bits); from a single wider register. As they are expected to be temporary byproducts of the legalization process,; they are combined at the end of the :ref:`milegalizer` pass.; If any remain, they are expected to always be selectable, using loads and stores; if necessary. The legality of an instruction may only depend on the instruction itself and; must not depend on any context in which the instruction is used. However, after; deciding that an instruction is not legal, using the context of the instruction; to decide how to legalize the instruction is permitted. As an example, if we; have a ``G_FOO`` instruction of the form::. %1:_(s32) = G_CONSTANT i32 1; %2:_(s32) = G_FOO %0:_(s32), %1:_(s32). it's impossible to say that G_FOO is legal iff %1 is a ``G_CONSTANT`` with; value ``1``. However, the following::. %2:_(s32) = G_FOO %0:_(s32), i32 1. can say that it's legal iff operand 2 is an immediate with value ``1`` because; that information is entirely contained within",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/Legalizer.rst:1061,simpl,simple,1061,interpreter/llvm-project/llvm/docs/GlobalISel/Legalizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/Legalizer.rst,1,['simpl'],['simple']
Usability,"ructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70809,simpl,simplified,70809,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplified']
Usability,"ructure in HTML, replace dtree.js which is; extremely slow for complex hierarchies. Dramatically improve performance for; structures with large (~1000) number of items.; 19. Deliver to the server title of the objects, display it as hint in the browser.; 20. Better handling of special characters in the hierarchies - allows to display; symbols like ' or "" in the file structure. ### July 2014; 1. Migration to d3.v3.js and jQuery v2.1.1; 2. Fix errors in filling of histogram statbox; 3. Possibility of move and resize of statbox, title, color palete; 4. Remove many (not all) global variables; 5. Example with direct usage of JSRootIO graphics; 6. Example of inserting ROOT graphics from THttpServer into `<iframe></iframe>`. ### May 2014; 1. This JSRootIO code together with THttpServer class included; in ROOT repository. ### March 2014; 1. Introduce TBuffer class, which plays similar role; as TBuffer in native ROOT I/O. Simplifies I/O logic,; reduce duplication of code in many places, fix errors.; Main advantage - one could try to keep code synchronous with C++.; 2. Avoid objects cloning when object referenced several times.; 3. Treat special cases (collection, arrays) in one place.; This is major advantage, while any new classes need to be implemented only once.; 4. Object representation, produced by JSRootIO is similar to; objects, produced by TBufferJSON class. By this one can exchange; I/O engine and use same JavaSctript graphic for display.; 5. More clear functions to display different elements of the file.; In the future functions should be fully separated from I/O part; and organized in similar way as online part.; 6. Eliminate usage of gFile pointer in the I/O part.; 7. Provide TBufferJSON::JsonWriteMember method. It allows to stream any; selected data member of the class. Supported are:; basic data types, arrays of basic data types, TString, TArray classes.; Also any object as data member can be streamed.; 8. TRootSniffer do not creates sublevels for base classes; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:77494,clear,clear,77494,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['clear'],['clear']
Usability,"ructure_type; DW_AT_name(""REC2""); 27$: DW_TAG_member; DW_AT_name(""N""); DW_AT_type(reference to subtype TEENY at 21$); DW_AT_data_member_location(constant 0); 28$: DW_TAG_array_type; ! No name, default (Ada) order, default stride; ! Default data location; DW_AT_type(reference to INTEGER); 29$: DW_TAG_subrange_type; DW_AT_type(reference to subrange TEENY at 21$); DW_AT_lower_bound(constant 1); DW_AT_upper_bound(reference to member N at 27$); 30$: DW_TAG_member; DW_AT_name(""VEC2""); DW_AT_type(reference to array ""subtype"" at 28$); DW_AT_data_member_location(machine=; DW_OP_lit<n> ! where n == offset(REC2, VEC2); DW_OP_offset); ...; 41$: DW_TAG_variable; DW_AT_name(""OBJ2B""); DW_AT_type(reference to REC2 at 26$); DW_AT_location(...as appropriate...); ----------------------------------------------------------------------------. .. _amdgpu-dwarf-further-examples:. C. Further Examples; ===================. The AMD GPU specific usage of the features in these extensions, including; examples, is available at *User Guide for AMDGPU Backend* section; :ref:`amdgpu-dwarf-debug-information`. .. note::. Change examples to use ``DW_OP_LLVM_offset`` instead of ``DW_OP_add`` when; acting on a location description. Need to provide examples of new features. .. _amdgpu-dwarf-references:. D. References; =============. .. _amdgpu-dwarf-AMD:. 1. [AMD] `Advanced Micro Devices <https://www.amd.com/>`__. .. _amdgpu-dwarf-AMD-ROCgdb:. 2. [AMD-ROCgdb] `AMD ROCm Debugger (ROCgdb) <https://github.com/ROCm-Developer-Tools/ROCgdb>`__. .. _amdgpu-dwarf-AMD-ROCm:. 3. [AMD-ROCm] `AMD ROCm Platform <https://rocm-documentation.readthedocs.io>`__. .. _amdgpu-dwarf-AMDGPU-DWARF-LOC:. 4. [AMDGPU-DWARF-LOC] `Allow Location Descriptions on the DWARF Expression Stack <https://llvm.org/docs/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack.html>`__. .. _amdgpu-dwarf-AMDGPU-LLVM:. 5. [AMDGPU-LLVM] `User Guide for AMDGPU LLVM B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:234114,Guid,Guide,234114,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['Guid'],['Guide']
Usability,"run through clang -O2 -S -emit-llvm to get; equivalent IR */; int x;; void f(int* a) {; for (int i = 0; i < 100; i++) {; if (a[i]); x += 1;; }; }. The following is equivalent in non-concurrent situations:. .. code-block:: c. int x;; void f(int* a) {; int xtemp = x;; for (int i = 0; i < 100; i++) {; if (a[i]); xtemp += 1;; }; x = xtemp;; }. However, LLVM is not allowed to transform the former to the latter: it could; indirectly introduce undefined behavior if another thread can access ``x`` at; the same time. That thread would read `undef` instead of the value it was; expecting, which can lead to undefined behavior down the line. (This example is; particularly of interest because before the concurrency model was implemented,; LLVM would perform this transformation.). Note that speculative loads are allowed; a load which is part of a race returns; ``undef``, but does not have undefined behavior. Atomic instructions; ===================. For cases where simple loads and stores are not sufficient, LLVM provides; various atomic instructions. The exact guarantees provided depend on the; ordering; see `Atomic orderings`_. ``load atomic`` and ``store atomic`` provide the same basic functionality as; non-atomic loads and stores, but provide additional guarantees in situations; where threads and signals are involved. ``cmpxchg`` and ``atomicrmw`` are essentially like an atomic load followed by an; atomic store (where the store is conditional for ``cmpxchg``), but no other; memory operation can happen on any thread between the load and store. A ``fence`` provides Acquire and/or Release ordering which is not part; of another operation; it is normally used along with Monotonic memory; operations. A Monotonic load followed by an Acquire fence is roughly; equivalent to an Acquire load, and a Monotonic store following a; Release fence is roughly equivalent to a Release; store. SequentiallyConsistent fences behave as both an Acquire and a; Release fence, and additionally provide a t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:4203,simpl,simple,4203,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['simpl'],['simple']
Usability,"rwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". Using this intrinsic on a coroutine that does not have a `final suspend`_ point; or on a coroutine that is not suspended leads to undefined behavior. .. _coro.promise:. 'llvm.coro.promise' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare ptr @llvm.coro.promise(ptr <ptr>, i32 <alignment>, i1 <from>). Overview:; """""""""""""""""". The '``llvm.coro.promise``' intrinsic obtains a pointer to a; `coroutine promise`_ given a switched-resume coroutine handle and vice versa. Arguments:; """""""""""""""""""". The first argument is a handle to a coroutine if `from` is false. Otherwise,; it is a pointer to a coroutine promise. The second argument is an alignment requirements of the promise.; If a frontend designated `%promise = alloca i32` as a promise, the alignment; argument to `coro.promise` should be the alignment of `i32` on the target; platform. If a frontend designated `%promise = alloca i32, align 16` as a; promise, the alignment argument should be 16.; This argument only accepts constants. The third argument is a boolean indicating a direction of the transformation.; If `from` is true, the intrinsic returns a coroutine handle given a pointer; to a promise. If `from` is false, the intrinsics return a pointer to a promise; from a coroutine handle. This argument only accepts constants. Semantics:; """""""""""""""""""". Using this intrinsic on a coroutine that does not have a coroutine promise; leads to undefined",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:29187,resume,resume,29187,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ry:; getNextToken();; if (!isascii(CurTok)); return LogErrorP(""Expected unary operator"");; FnName = ""unary"";; FnName += (char)CurTok;; Kind = 1;; getNextToken();; break;; case tok_binary:; ... As with binary operators, we name unary operators with a name that; includes the operator character. This assists us at code generation; time. Speaking of, the final piece we need to add is codegen support for; unary operators. It looks like this:. .. code-block:: c++. Value *UnaryExprAST::codegen() {; Value *OperandV = Operand->codegen();; if (!OperandV); return nullptr;. Function *F = getFunction(std::string(""unary"") + Opcode);; if (!F); return LogErrorV(""Unknown unary operator"");. return Builder->CreateCall(F, OperandV, ""unop"");; }. This code is similar to, but simpler than, the code for binary; operators. It is simpler primarily because it doesn't need to handle any; predefined operators. Kicking the Tires; =================. It is somewhat hard to believe, but with a few simple extensions we've; covered in the last chapters, we have grown a real-ish language. With; this, we can do a lot of interesting things, including I/O, math, and a; bunch of other things. For example, we can now add a nice sequencing; operator (printd is defined to print out the specified value and a; newline):. ::. ready> extern printd(x);; Read extern:; declare double @printd(double). ready> def binary : 1 (x y) 0; # Low-precedence operator that ignores operands.; ...; ready> printd(123) : printd(456) : printd(789);; 123.000000; 456.000000; 789.000000; Evaluated to 0.000000. We can also define a bunch of other ""primitive"" operations, such as:. ::. # Logical unary not.; def unary!(v); if v then; 0; else; 1;. # Unary negate.; def unary-(v); 0-v;. # Define > with the same precedence as <.; def binary> 10 (LHS RHS); RHS < LHS;. # Binary logical or, which does not short circuit.; def binary| 5 (LHS RHS); if LHS then; 1; else if RHS then; 1; else; 0;. # Binary logical and, which does not short circuit.; de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:14416,simpl,simple,14416,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"s 'int a;' and 'int c;' but not 'int b;'. Matcher<FieldDecl>isBitField; Matches non-static data members that are bit-fields. Given; class C {; int a : 2;; int b;; };; fieldDecl(isBitField()); matches 'int a;' but not 'int b;'. Matcher<FloatingLiteral>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); match false; floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2)); match 3.14; integerLiteral(equals(42)); matches 42. Note that you cannot directly match a negative numeric literal because the; minus sign is not part of the literal: It is a unary operator whose operand; is the positive numeric literal. Instead, you must use a unaryOperator(); matcher to match the minus sign:. unaryOperator(hasOperatorName(""-""),; hasUnaryOperand(integerLiteral(equals(13)))). Usable as: Matcher<CharacterLiteral>, Matcher<CXXBoolLiteralExpr>,; Matcher<FloatingLiteral>, Matcher<IntegerLiteral>. Matcher<FloatingLiteral>equalsdouble Value. Matcher<FunctionDecl>hasAnyOverloadedOperatorNameStringRef, ..., StringRef; Matches overloaded operator names. Matches overloaded operator names specified in strings without the; ""operator"" prefix: e.g. ""<<"". hasAnyOverloadedOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOverloadedOperatorName(""+""), hasOverloadedOperatorName(""-"")). Matcher<FunctionDecl>hasDynamicExceptionSpec; Matches functions that have a dynamic exception specification. Given:; void f();; void g() noexcept;; void h() noexcept(true);; void i() noexcept(false);; void j() throw();; void k() throw(int);; void l() throw(...);; functionDecl(hasDynamicExceptionSpec()) and; functionProtoType(hasDynamicExceptionSpec()); match the declarations of j, k, and l, but not f, g, h, or i. Matcher<FunctionDecl>hasOverloadedOperatorNameStringRef Name; Matches overloaded operator names. Matches overloaded operator names specified ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:88831,Usab,Usable,88831,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"s HybridResult and HybridPlot work only; with the HybridCalculatorOriginal and remain for maintaining; a backward compatibility. ; Given a ModelConfig, the tool will attempt to form the posterior pdf ; for the nuisance parameters based on the prior and the constraint terms ; in the pdf. However, this is not yet implemented. In order to keep; logical consistency with other tools, the distribution being used; to smear the nuisance parameters should NOT be considered the prior in ; the model config. Instead, one should use HybridCalculator's; ForcePriorNuisanceNull and ForcePriorNuisanceAlt. HybridCalculatorOriginal. Apply a fix for test statistic = 3 (profile likelihood); Apply a fix for using non-extended pdf. TestStatSampler and TestStatistics. Cleanup of the interfaces.; TestStatistics now have a method PValueIsRightTail to specify the sign conventions for the test statistic. This is used when making plots and calculating p-values.; make clear that TestStatistic::Evaluate should take data and values of the parameters that define the null.; Add method TestStatSampler::SetParametersForTestStat that ; allows for greater control of parameters used for generating toy data; and parameters used for evaluating the test statistic.; ProfileLikelihoodTestStatUsing the raw profile likelihood while reviewing the old algorithm used to provide robustness in situations with local minima.; New test statistic classes:; ; SimpleLikelihoodRatioTestStat : log L_1 / L_0; RatioOfProfiledLikelihoodsTestStat: log L(mu_1, hat(nu_1))/L(mu_0,hat(nu_0)); MaxLikelihoodEstimateTestStat: the MLE of a specified parameter. ToyMCSampler. New version of ToyMCSampler which can smear the nuisance; parameters according to their distributions for use with; HybridCalculator; Updated class structure: ToyMCSampler is a particular implementation of a TestStatSampler and runs with any TestStatistic. It returns the result in an instance of SamplingDistribution.; Supports Importance Sampling: Improves sampling t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html:6653,clear,clear,6653,roofit/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html,1,['clear'],['clear']
Usability,"s Y { class X {}; }; // Matches Y, because Y::X is a class of name X; // inside Y.; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. As opposed to 'has', 'forEach' will cause a match for each result that; matches instead of only on the first one. Usable as: Any Matcher. Matcher<*>hasAncestorMatcher<*>; Matches AST nodes that have an ancestor that matches the provided; matcher. Given; void f() { if (true) { int x = 42; } }; void g() { for (;;) { int x = 43; } }; expr(integerLiteral(hasAncestor(ifStmt()))) matches 42, but not 43. Usable as: Any Matcher. Matcher<*>hasDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, Y, Z; (matcher = cxxRecordDecl(hasDescendant(cxxRecordDecl(hasName(""X""))))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; };. DescendantT must be an AST base type. Usable as: Any Matcher. Matcher<*>hasMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y; (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName(""X""))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. Usable as: Any Matcher; Note that has is direct matcher, so it also matches things like implicit; casts and paren casts. If you are matching with expr then you should; probably consider using ignoringParenImpCasts like:; has(ignoringParenImpCasts(expr())). Matcher<*>hasParentMatcher<*>; Matches AST nodes that have a parent that matches the provided; matcher. Given; void f() { for (;;) { int x = 42; if (true) { int x = 43; } } }; compoundStmt(hasParent(ifStmt())) matches ""{ int x = 43; }"". Usable as: Any Matcher. Matcher<*>invocationMatcher<*>...Matcher<*>; Matches function calls and constructor calls. Becau",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:134177,Usab,Usable,134177,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"s against an installed version of; LLVM regardless of how it was built. Here is a simple example of a CMakeLists.txt file that imports the LLVM libraries; and uses them to build a simple application ``simple-tool``. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(SimpleProject). find_package(LLVM REQUIRED CONFIG). message(STATUS ""Found LLVM ${LLVM_PACKAGE_VERSION}""); message(STATUS ""Using LLVMConfig.cmake in: ${LLVM_DIR}""). # Set your project compile flags.; # E.g. if using the C++ header files; # you will need to enable C++11 support; # for your compiler. include_directories(${LLVM_INCLUDE_DIRS}); separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_definitions(${LLVM_DEFINITIONS_LIST}). # Now build our tools; add_executable(simple-tool tool.cpp). # Find the libraries that correspond to the LLVM components; # that we wish to use; llvm_map_components_to_libnames(llvm_libs support core irreader). # Link against LLVM libraries; target_link_libraries(simple-tool ${llvm_libs}). The ``find_package(...)`` directive when used in CONFIG mode (as in the above; example) will look for the ``LLVMConfig.cmake`` file in various locations (see; cmake manual for details). It creates a ``LLVM_DIR`` cache entry to save the; directory where ``LLVMConfig.cmake`` is found or allows the user to specify the; directory (e.g. by passing ``-DLLVM_DIR=/usr/lib/cmake/llvm`` to; the ``cmake`` command or by setting it directly in ``ccmake`` or ``cmake-gui``). This file is available in two different locations. * ``<LLVM_INSTALL_PACKAGE_DIR>/LLVMConfig.cmake`` where; ``<LLVM_INSTALL_PACKAGE_DIR>`` is the location where LLVM CMake modules are; installed as part of an installed version of LLVM. This is typically; ``cmake/llvm/`` within the lib directory. On Linux, this is typically; ``/usr/lib/cmake/llvm/LLVMConfig.cmake``. * ``<LLVM_BUILD_ROOT>/lib/cmake/llvm/LLVMConfig.cmake`` where; ``<LLVM_BUILD_ROOT>`` is the root of the LLVM build tree. **Not",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:42064,simpl,simple-tool,42064,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['simpl'],['simple-tool']
Usability,"s an instance variable for part of its lifetime, it may; maintain an invariant guaranteeing that the instance variable is always released; before -dealloc. In this case, you can silence a warning about a missing release; by either adding assert(_ivar == nil) or an explicit release; [_ivar release] (which will be a no-op when the variable is nil) in; -dealloc. ; Q: How do I decide whether a method's return type should be _Nullable or _Nonnull?; Depending on the implementation of the method, this puts you in one of five situations:. You actually never return nil.; You do return nil sometimes, and callers are supposed to handle that. This; includes cases where your method is documented to return nil given certain; inputs.; You return nil based on some external condition (such as an out-of-memory; error), but the client can't do anything about it either.; You return nil only when the caller passes input documented to be invalid.; That means it's the client's fault.; You return nil in some totally undocumented case. In (1) you should annotate the method as returning a _Nonnull; object.; In (2) the method should be marked _Nullable.; In (3) you should probably annotate the method _Nonnull. Why?; Because no callers will actually check for nil, given that they can't do; anything about the situation and don't know what went wrong. At this point; things have gone so poorly that there's basically no way to recover.; The least happy case is (4) because the resulting program will almost; certainly either crash or just silently do the wrong thing.; If this is a new method or you control the callers, you can use; NSParameterAssert() (or the equivalent) to check the precondition and; remove the nil return. But if you don't control the callers and they rely on; this behavior, you should return mark the method _Nonnull and return; nil cast to _Nonnull anyway.; (Note that (4) doesn't apply in cases where the caller can't know they passed; bad parameters. For example,; +[NSData dataWith",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html:5378,undo,undocumented,5378,interpreter/llvm-project/clang/www/analyzer/faq.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html,1,['undo'],['undocumented']
Usability,"s and assigned a sub-set of workers to merge. Once each; sub-merger has merged its sub-set of workers, it sends its result to; the master, which merges the partial results into the final; set of results.; The determination of the sub-mergers is always done dynamically, based; on the recent performance of workers. An optimal (i.e. giving the; highest speed-up) number can be calculated analytically under simple; assumptions.; Merging via submergers is by default disabled. To enable it, with the; optimal number of sub-mergers, one should set the integer parameter; 'PROOF_UseMergers' to 0, i.e.                     ; proof->SetParameter(""PROOF_UseMergers"", 0). To force S sub-mergers (regardless of the optimal number) do.                     ; proof->SetParameter(""PROOF_UseMergers"", S). The new functionality can be tested in tutorials by adding the argument; 'submergers' to runProof, e.g. .        ;        ;      root [0] .L; tutorials/proof/runProof.C+ ;        ;        ;      root [1]; runProof(""simple(nhist=10000,submergers)"") . (see the top of tutorials/proof/runProof.C for additional options). A test for the submerger functionality has also been added to; test/stressProof.cxx .; In PROOF-Lite, add the possibility for the administrator; to control the number of workers. This is done using; the rootrc variable ProofLite.MaxWorkers, which is read out of; /etc/system.rootrc and cannot be overwritten by users. Setting the; value to 0 disables PROOF-Lite. Improvements. TFileMerger. A few improvements on the way to make TFileMerger and; hadd totally equivalent:. import from hadd an optimization of key hashing; import from hadd a better way to invoke Merge for; generic objects; add option to merge histograms in one go, instead of; one-by-one as for generic objects (this option is not yet supported by; hadd). TProofOutputFile. Add support for the placeholder <file>; the definition of the outputfile. This allows to have complete URL and; to pass options to TFile::Open. XrdProo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:3065,simpl,simple,3065,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,1,['simpl'],['simple']
Usability,"s and programs external to; LLVM, there are many ways to install and configure these dependencies so you; may need to adapt the instructions here to fit your own local situation. Prerequisites; =============. In this use case we'll be using cmake on a Debian-based Linux system,; cross-compiling from an x86_64 host to a hard-float Armv7-A target. We'll be; using as many of the LLVM tools as we can, but it is possible to use GNU; equivalents. * ``A build of LLVM/clang for the llvm-tools and llvm-config``; * ``A clang executable with support for the ARM target``; * ``compiler-rt sources``; * ``The qemu-arm user mode emulator``; * ``An arm-linux-gnueabihf sysroot``. In this example we will be using ninja. See https://compiler-rt.llvm.org/ for more information about the dependencies; on clang and LLVM. See https://llvm.org/docs/GettingStarted.html for information about obtaining; the source for LLVM and compiler-rt. Note that the getting started guide; places compiler-rt in the projects subdirectory, but this is not essential and; if you are using the BaremetalARM.cmake cache for v6-M, v7-M and v7-EM then; compiler-rt must be placed in the runtimes directory. ``qemu-arm`` should be available as a package for your Linux distribution. The most complicated of the prerequisites to satisfy is the arm-linux-gnueabihf; sysroot. In theory it is possible to use the Linux distributions multiarch; support to fulfill the dependencies for building but unfortunately due to; /usr/local/include being added some host includes are selected. The easiest way; to supply a sysroot is to download the arm-linux-gnueabihf toolchain. This can; be found at:; * https://developer.arm.com/open-source/gnu-toolchain/gnu-a/downloads for gcc 8 and above; * https://releases.linaro.org/components/toolchain/binaries/ for gcc 4.9 to 7.3. Building compiler-rt builtins for Arm; =====================================; We will be doing a standalone build of compiler-rt using the following cmake; options. * ``path",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:1553,guid,guide,1553,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['guid'],['guide']
Usability,"s and vendors of potential disruptions when upgrading to; a newer version of a tool. For example, deprecating a feature that is expected; to be removed in the future, removing an already-deprecated feature, upgrading a; diagnostic from a warning to an error, switching important default behavior, or; any other potentially disruptive situation thought to be worth raising; awareness of. For such changes, the following should be done:. .. warning::. Phabricator is deprecated and will be switched to read-only mode in October; 2023, for new code contributions use :ref:`GitHub Pull Requests <github-reviews>`.; This section contains old information that needs to be updated. * When performing the code review for the change, please add any applicable; ""vendors"" group to the review for their awareness. The purpose of these; groups is to give vendors early notice that potentially disruptive changes; are being considered but have not yet been accepted. Vendors can give early; testing feedback on the changes to alert us to unacceptable breakages. The; current list of vendor groups is:. * `Clang vendors <https://reviews.llvm.org/project/members/113/>`_; * `libc++ vendors <https://reviews.llvm.org/project/members/109/>`_. People interested in joining the vendors group can do so by clicking the; ""Join Project"" link on the vendor's ""Members"" page in Phabricator. * When committing the change to the repository, add appropriate information; about the potentially breaking changes to the ``Potentially Breaking Changes``; section of the project's release notes. The release note should have; information about what the change is, what is potentially disruptive about; it, as well as any code examples, links, and motivation that is appropriate; to share with users. This helps users to learn about potential issues with; upgrading to that release. * After the change has been committed to the repository, the potentially; disruptive changes described in the release notes should be posted to the; `A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:6035,feedback,feedback,6035,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['feedback'],['feedback']
Usability,"s are represented with the; ``ConstantFP`` class, which holds the numeric value in an ``APFloat``; internally (``APFloat`` has the capability of holding floating point; constants of Arbitrary Precision). This code basically just creates; and returns a ``ConstantFP``. Note that in the LLVM IR that constants; are all uniqued together and shared. For this reason, the API uses the; ""foo::get(...)"" idiom instead of ""new foo(..)"" or ""foo::Create(..)"". .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; Value *V = NamedValues[Name];; if (!V); LogErrorV(""Unknown variable name"");; return V;; }. References to variables are also quite simple using LLVM. In the simple; version of Kaleidoscope, we assume that the variable has already been; emitted somewhere and its value is available. In practice, the only; values that can be in the ``NamedValues`` map are function arguments.; This code simply checks to see that the specified name is in the map (if; not, an unknown variable is being referenced) and returns the value for; it. In future chapters, we'll add support for `loop induction; variables <LangImpl05.html#for-loop-expression>`_ in the symbol table, and for `local; variables <LangImpl07.html#user-defined-local-variables>`_. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // Convert bool 0/1 to double 0.0 or 1.0; return Builder->CreateUIToFP(L, Type::getDoubleTy(TheContext),; ""booltmp"");; default:; return LogErrorV(""invalid binary operator"");; }; }. Binary operators start to get more interesting. The basic idea here is; that we recursively emit code for the left-hand side of the expression,; then the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:6026,simpl,simply,6026,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simply']
Usability,"s by calling:. ``` {.cpp}; TH1::LabelsDeflate(axis);; ```. Here `axis` may be X, Y, or Z. This operation is automatic when using; **`TTree`**`::Draw` . Once bin labels have been created, they become; persistent if the histogram is written to a file or when generating; the C++ code via `SavePrimitive` . ## Histogram Stacks. A **`THStack`** is a collection of **`TH1`** (or derived) objects. Use; **`THStack`**`::Add(` **`TH1`** `*h)` to add a histogram to the stack.; The **`THStack`** does not own the objects in the list. ![Stacked histograms](pictures/0300003D.png). By default, **`THStack`**`::Draw` draws the histograms stacked as; shown in the left pad in the picture above. If the option `""nostack""`; is used, the histograms are superimposed as if they were drawn one at; a time using the `""same""` draw option `.` The right pad in this; picture illustrates the **`THStack`** drawn with the `""nostack""`; option. ``` {.cpp}; hs->Draw(""nostack"");; ```. Next is a simple example, for a more complex one see; `$ROOTSYS/tutorials/hist/hstack.C.`. ``` {.cpp}; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; ```. ## TH2Poly. `TH2Poly` is a 2D Histogram class allowing to define polygonal bins of; arbitrary shape. Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; `TH2PolyBin` is a very simple class containing the vertices and; contents of the polygonal bin as well as several related functions. Bins are defined using one of the `AddBin()` methods. The bin; definition should be done before filli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:59596,simpl,simple,59596,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['simpl'],['simple']
Usability,"s clarity; > and readability. I agree to some extent, but it also comes at the; > cost of verbosity. And when the types are obvious from people's; > experience (e.g., in the br instruction), it doesn't seem to help as; > much. Very true. We should discuss this more, but my reasoning is more of a; consistency argument. There are VERY few instructions that can have all; of the types eliminated, and doing so when available unnecessarily makes; the language more difficult to handle. Especially when you see 'int; %this' and 'bool %that' all over the place, I think it would be; disorienting to see:. br %predicate, %iftrue, %iffalse. for branches. Even just typing that once gives me the creeps. ;) Like I; said, we should probably discuss this further in person... > On reflection, I really like your idea of having the two different; > switch types (even though they encode implementation techniques rather; > than semantics). It should simplify building the CFG and my guess is it; > could enable some significant optimizations, though we should think; > about which. Great. I added a note to the switch section commenting on how the VM; should just use the instruction type as a hint, and that the; implementation may choose altermate representations (such as predicated; branches). > In the lookup-indirect form of the switch, is there a reason not to; > make the val-type uint?. No. This was something I was debating for a while, and didn't really feel; strongly about either way. It is common to switch on other types in HLL's; (for example signed int's are particularly common), but in this case, all; that will be added is an additional 'cast' instruction. I removed that; from the spec. > I agree with your comment that we don't need 'neg'. Removed. > There's a trade-off with the cast instruction:; > + it avoids having to define all the upcasts and downcasts that are; > valid for the operands of each instruction (you probably have; > thought of other benefits also); > - it could make ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:1533,simpl,simplify,1533,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['simpl'],['simplify']
Usability,"s described in; `Minimising cost of downstream merges`_).; Also update the project list on the policy page.; 2. Apply ``clang-tidy`` to the project's files, with only the; ``readability-identifier-naming`` rules enabled. ``clang-tidy`` will also; reformat the affected lines according to the rules in ``.clang-format``.; It is anticipated that this will be a good dog-fooding opportunity for; clang-tidy, and bugs should be fixed in the process, likely including:. * `readability-identifier-naming incorrectly fixes lambda capture; <https://bugs.llvm.org/show_bug.cgi?id=41119>`_.; * `readability-identifier-naming incorrectly fixes variables which; become keywords <https://bugs.llvm.org/show_bug.cgi?id=41120>`_.; * `readability-identifier-naming misses fixing member variables in; destructor <https://bugs.llvm.org/show_bug.cgi?id=41122>`_. #. Gather feedback and refine the process as appropriate. #. Apply the process to the following projects, with a suitable delay between; each (at least 4 weeks after the first change, at least 2 weeks subsequently); to allow gathering further feedback.; This list should exclude projects that must adhere to an externally defined; standard e.g. libcxx.; The list is roughly in chronological order of renaming.; Some items may not make sense to rename individually - it is expected that; this list will change following experimentation:. * TableGen; * llvm/tools; * clang-tools-extra; * clang; * ARM backend; * AArch64 backend; * AMDGPU backend; * ARC backend; * AVR backend; * BPF backend; * Hexagon backend; * Lanai backend; * MIPS backend; * NVPTX backend; * PowerPC backend; * RISC-V backend; * Sparc backend; * SystemZ backend; * WebAssembly backend; * X86 backend; * XCore backend; * libLTO; * Debug Information; * Remainder of llvm; * compiler-rt; * libunwind; * openmp; * parallel-libs; * polly; * lldb. #. Remove the old variable name rule from the policy page. #. Repeat many of the steps in the sequence, using a script to expand acronyms. Refere",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:12372,feedback,feedback,12372,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['feedback'],['feedback']
Usability,"s description block, everything until the first; non-commented line is considered as a valid member function description; block. **Data members** are documented by putting a C++ comment behind their; declaration in the header file, e.g. ``` {.cpp}; Int_t fIAmADataMember; // this is a data member; ```. When documenting a class, **`THtml`** creates both a ""beautified""; version of the source file and a web page containing the class; documentation. The documentation also shows the **author** and a; **copyright statement**. This information is extracted from the source; file. The author can be in the format. ``` {.cpp}; // Author: Enrico Fermi; ```. for people that have an entry in CERN's XWho database, and for those who; have not:. ``` {.cpp}; // Author: Enrico Fermi <mailto:enrico@fnal.gov>; ```. The copyright statement is introduced by the string ""`* Copyright`""; inside a comment. You should read the class reference page at; <http://root.cern.ch/root/html/THtml.html> to learn about all of; **`THtml`**'s features. ### Product and Module Documentation. For **`THtml`**, a product like ROOT is a combination of several; modules. It can include user-provided document for both products and; modules. The name of the product can be set by calling; `THtml::SetProductName()`. By default, the documentation is searched for; in the `doc/` subdirectory of the source tree, and in the; `../doc `directory, relative to the directory of first source file of a; module. This can be set by calls to `THtml::SetProductDocDir()` and; `THtml::SetModuleDocPath()`. The documentation is generated as an index page with links to further; files. This index page includes the file `index.txt` converted to HTML; (via `THtml::Convert()`) or the file index.html (without conversion to; HTML, of course), if any of these files exist. The index page will also; contain a list of links to all files in the directory that end on; `.html` or `.txt`. Files ending on `.txt` will be converted to HTML; before they are",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:2758,learn,learn,2758,documentation/users-guide/HTMLDoc.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md,1,['learn'],['learn']
Usability,"s equal to 0x1000 (4096). Any type index with a high bit set is considered to come from the IPI stream,; although this appears to be more of a hack, and LLVM does not generate type; indices of this nature. They can, however, be observed in Microsoft PDBs; occasionally, so one should be prepared to handle them. Note that having the; high bit set is not a necessary condition to determine whether a type index; comes from the IPI stream, it is only sufficient. Once the high bit is cleared, any type index >= ``TypeIndexBegin`` is presumed; to come from the appropriate stream, and any type index less than this is a; bitmask which can be decomposed as follows:. .. code-block:: none. .---------------------------.------.----------.; | Unused | Mode | Kind |; '---------------------------'------'----------'; |+32 |+12 |+8 |+0. - **Kind** - A value from the following enum:. .. code-block:: c++. enum class SimpleTypeKind : uint32_t {; None = 0x0000, // uncharacterized type (no type); Void = 0x0003, // void; NotTranslated = 0x0007, // type not translated by cvpack; HResult = 0x0008, // OLE/COM HRESULT. SignedCharacter = 0x0010, // 8 bit signed; UnsignedCharacter = 0x0020, // 8 bit unsigned; NarrowCharacter = 0x0070, // really a char; WideCharacter = 0x0071, // wide char; Character16 = 0x007a, // char16_t; Character32 = 0x007b, // char32_t; Character8 = 0x007c, // char8_t. SByte = 0x0068, // 8 bit signed int; Byte = 0x0069, // 8 bit unsigned int; Int16Short = 0x0011, // 16 bit signed; UInt16Short = 0x0021, // 16 bit unsigned; Int16 = 0x0072, // 16 bit signed int; UInt16 = 0x0073, // 16 bit unsigned int; Int32Long = 0x0012, // 32 bit signed; UInt32Long = 0x0022, // 32 bit unsigned; Int32 = 0x0074, // 32 bit signed int; UInt32 = 0x0075, // 32 bit unsigned int; Int64Quad = 0x0013, // 64 bit signed; UInt64Quad = 0x0023, // 64 bit unsigned; Int64 = 0x0076, // 64 bit signed int; UInt64 = 0x0077, // 64 bit unsigned int; Int128Oct = 0x0014, // 128 bit signed int; UInt128Oct = 0x0024, // 1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst:4587,Simpl,SimpleTypeKind,4587,interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst,1,['Simpl'],['SimpleTypeKind']
Usability,"s first reached. The remainder of the original coroutine function is split; out into some number of ""resume functions"". Any state which must persist; across suspensions is stored in the coroutine frame. The resume functions; must somehow be able to handle either a ""normal"" resumption, which continues; the normal execution of the coroutine, or an ""abnormal"" resumption, which; must unwind the coroutine without attempting to suspend it. Switched-Resume Lowering; ------------------------. In LLVM's standard switched-resume lowering, signaled by the use of; `llvm.coro.id`, the coroutine frame is stored as part of a ""coroutine; object"" which represents a handle to a particular invocation of the; coroutine. All coroutine objects support a common ABI allowing certain; features to be used without knowing anything about the coroutine's; implementation:. - A coroutine object can be queried to see if it has reached completion; with `llvm.coro.done`. - A coroutine object can be resumed normally if it has not already reached; completion with `llvm.coro.resume`. - A coroutine object can be destroyed, invalidating the coroutine object,; with `llvm.coro.destroy`. This must be done separately even if the; coroutine has reached completion normally. - ""Promise"" storage, which is known to have a certain size and alignment,; can be projected out of the coroutine object with `llvm.coro.promise`.; The coroutine implementation must have been compiled to define a promise; of the same size and alignment. In general, interacting with a coroutine object in any of these ways while; it is running has undefined behavior. The coroutine function is split into three functions, representing three; different ways that control can enter the coroutine:. 1. the ramp function that is initially invoked, which takes arbitrary; arguments and returns a pointer to the coroutine object;. 2. a coroutine resume function that is invoked when the coroutine is resumed,; which takes a pointer to the coroutine object an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:3082,resume,resumed,3082,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resumed']
Usability,"s if the replacement register is a temporary register from the; ``apply`` pattern. .. code-block:: text. def ReplaceTemp : GICombineRule<; (defs root:$a),; (match (G_BUILD_VECTOR $tmp, $x, $y),; (G_UNMERGE_VALUES $a, $b, $tmp)),; (apply (G_UNMERGE_VALUES $a, i32:$new, $y),; (GIReplaceReg $b, $new))>. Common Pattern #2: Erasing a Def-less Root; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If we simply want to erase a def-less match root, we can use the; ``GIEraseRoot`` builtin. .. code-block:: text. def Foo : GICombineRule<; (defs root:$mi),; (match (G_STORE $a, $b):$mi),; (apply (GIEraseRoot))>;. Common Pattern #3: Emitting a Constant Value; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. When an immediate operand appears in an 'apply' pattern, the behavior; depends on whether it's typed or not. * If the immediate is typed, ``MachineIRBuilder::buildConstant`` is used; to create a ``G_CONSTANT``. A ``G_BUILD_VECTOR`` will be used for vectors.; * If the immediate is untyped, a simple immediate is added; (``MachineInstrBuilder::addImm``). There is of course a special case for ``G_CONSTANT``. Immediates for; ``G_CONSTANT`` must always be typed, and a CImm is added; (``MachineInstrBuilder::addCImm``). .. code-block:: text; :caption: Constant Emission Examples:. // Example output:; // %0 = G_CONSTANT i32 0; // %dst = COPY %0; def Foo : GICombineRule<; (defs root:$dst),; (match (G_FOO $dst, $src)),; (apply (COPY $dst, (i32 0)))>;. // Example output:; // %dst = COPY 0; // Note that this would be ill-formed because COPY; // expects a register operand!; def Bar : GICombineRule<; (defs root:$dst),; (match (G_FOO $dst, $src)),; (apply (COPY $dst, (i32 0)))>;. // Example output:; // %dst = G_CONSTANT i32 0; def Bux : GICombineRule<; (defs root:$dst),; (match (G_FOO $dst, $src)),; (apply (G_CONSTANT $dst, (i32 0)))>;. GICombinePatFrag; ----------------. ``GICombinePatFrag`` is an equivalent of ``PatFrags`` for MIR patterns.; They have two main usecases:. * Reduce repetition by creat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:9617,simpl,simple,9617,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['simpl'],['simple']
Usability,"s in the set"". The; choice of constraint is made independently for each constraint in the; constraint list. 2) Use ""``|``"" between constraint code sets, creating alternatives. Every; constraint in the constraint list must have the same number of alternative; sets. With this syntax, the same alternative in *all* of the items in the; constraint list will be chosen together. Putting those together, you might have a two operand constraint string like; ``""rm|r,ri|rm""``. This indicates that if operand 0 is ``r`` or ``m``, then; operand 1 may be one of ``r`` or ``i``. If operand 0 is ``r``, then operand 1; may be one of ``r`` or ``m``. But, operand 0 and 1 cannot both be of type m. However, the use of either of the alternatives features is *NOT* recommended, as; LLVM is not able to make an intelligent choice about which one to use. (At the; point it currently needs to choose, not enough information is available to do so; in a smart way.) Thus, it simply tries to make a choice that's most likely to; compile, not one that will be optimal performance. (e.g., given ""``rm``"", it'll; always choose to use memory, not registers). And, if given multiple registers,; or multiple register classes, it will simply choose the first one. (In fact, it; doesn't currently even ensure explicitly specified physical registers are; unique, so specifying multiple physical registers as alternatives, like; ``{r11}{r12},{r11}{r12}``, will assign r11 to both operands, not at all what was; intended.). Supported Constraint Code List; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The constraint codes are, in general, expected to behave the same way they do in; GCC. LLVM's support is often implemented on an 'as-needed' basis, to support C; inline asm code which was supported by GCC. A mismatch in behavior between LLVM; and GCC likely indicates a bug in LLVM. Some constraint codes are typically supported by all targets:. - ``r``: A register in the target's general purpose register class.; - ``m``: A memory address oper",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:219843,simpl,simply,219843,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"s inclusive on both ends. Example:; ``""%plural{0:none|1:one|[2,5]:some|:many}0""``; * modulo: A modulo operator is followed by a number, and equals sign and; either a number or a range. The tests are the same as for plain numbers; and ranges, but the argument is taken modulo the number first. Example:; ``""%plural{%100=0:even hundred|%100=[1,50]:lower half|:everything else}1""``. The parser is very unforgiving. A syntax error, even whitespace, will abort,; as will a failure to match the argument against any expression. **""ordinal"" format**. Example:; ``""ambiguity in %ordinal0 argument""``; Class:; Integers; Description:; This is a formatter which represents the argument number as an ordinal: the; value ``1`` becomes ``1st``, ``3`` becomes ``3rd``, and so on. Values less; than ``1`` are not supported. This formatter is currently hard-coded to use; English ordinals. **""objcclass"" format**. Example:; ``""method %objcclass0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C class method selector. As such, it prints the selector; with a leading ""``+``"". **""objcinstance"" format**. Example:; ``""method %objcinstance0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C instance method selector. As such, it prints the selector; with a leading ""``-``"". **""q"" format**. Example:; ``""candidate found by name lookup is %q0""``; Class:; ``NamedDecl *``; Description:; This formatter indicates that the fully-qualified name of the declaration; should be printed, e.g., ""``std::vector``"" rather than ""``vector``"". **""diff"" format**. Example:; ``""no known conversion %diff{from $ to $|from argument type to parameter type}1,2""``; Class:; ``QualType``; Description:; This formatter takes two ``QualType``\ s and attempts to print a template; difference between the two. If tree printing is off, the te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:13831,simpl,simple,13831,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"s info using this interface.; For example:. .. code-block:: c++. bool ModuleLevelPass::runOnModule(Module &M) {; //...; DominatorTree &DT = getAnalysis<DominatorTree>(Func);; //...; }. In above example, ``runOnFunction`` for ``DominatorTree`` is called by pass; manager before returning a reference to the desired pass. If your pass is capable of updating analyses if they exist (e.g.,; ``BreakCriticalEdges``, as described above), you can use the; ``getAnalysisIfAvailable`` method, which returns a pointer to the analysis if; it is active. For example:. .. code-block:: c++. if (DominatorSet *DS = getAnalysisIfAvailable<DominatorSet>()) {; // A DominatorSet is active. This code will update it.; }. Implementing Analysis Groups; ----------------------------. Now that we understand the basics of how passes are defined, how they are used,; and how they are required from other passes, it's time to get a little bit; fancier. All of the pass relationships that we have seen so far are very; simple: one pass depends on one other specific pass to be run before it can; run. For many applications, this is great, for others, more flexibility is; required. In particular, some analyses are defined such that there is a single simple; interface to the analysis results, but multiple ways of calculating them.; Consider alias analysis for example. The most trivial alias analysis returns; ""may alias"" for any alias query. The most sophisticated analysis a; flow-sensitive, context-sensitive interprocedural analysis that can take a; significant amount of time to execute (and obviously, there is a lot of room; between these two extremes for other implementations). To cleanly support; situations like this, the LLVM Pass Infrastructure supports the notion of; Analysis Groups. Analysis Group Concepts; ^^^^^^^^^^^^^^^^^^^^^^^. An Analysis Group is a single simple interface that may be implemented by; multiple different passes. Analysis Groups can be given human readable names; just like passes, but u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:34839,simpl,simple,34839,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"s is a ""binary +"").; Many other examples abound. In the following example, not only do we tell you; that there is a problem with the *; and point to it, we say exactly why and tell you what the type is (in case it is; a complicated subexpression, such as a call to an overloaded function). This; sort of attention to detail makes it much easier to understand and fix problems; quickly. $ gcc-4.9 -fsyntax-only t.c; t.c:5:11: error: invalid type argument of unary '*' (have 'int'); return *SomeA.X;; ^; $ clang -fsyntax-only t.c; t.c:5:11: error: indirection requires pointer operand ('int' invalid); int y = *SomeA.X;; ^~~~~~~~. Typedef Preservation and Selective Unwrapping; Many programmers use high-level user defined types, typedefs, and other; syntactic sugar to refer to types in their program. This is useful because they; can abbreviate otherwise very long types and it is useful to preserve the; typename in diagnostics. However, sometimes very simple typedefs can wrap; trivial types and it is important to strip off the typedef to understand what; is going on. Clang aims to handle both cases well.; The following example shows where it is important to preserve; a typedef in C. $ clang -fsyntax-only t.c; t.c:15:11: error: can't convert between vector values of different size ('__m128' and 'int const *'); myvec[1]/P;; ~~~~~~~~^~. The following example shows where it is useful for the compiler to expose; underlying details of a typedef. If the user was somehow confused about how the; system ""pid_t"" typedef is defined, Clang helpfully displays it with ""aka"". $ clang -fsyntax-only t.c; t.c:13:9: error: member reference base type 'pid_t' (aka 'int') is not a structure or union; myvar = myvar.x;; ~~~~~ ^. In C++, type preservation includes retaining any qualification written into type names. For example, if we take a small snippet of code such as:. namespace services {; struct WebService { };; }; namespace myapp {; namespace servers {; struct Server { };; }; }. using namespace m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:4220,simpl,simple,4220,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['simpl'],['simple']
Usability,"s is the top level directory of the LLVM object tree (i.e. the tree where; object files and compiled programs will be placed. It can be the same as; SRC_ROOT). Unpacking the LLVM Archives; ---------------------------. If you have the LLVM distribution, you will need to unpack it before you can; begin to compile it. LLVM is distributed as a number of different; subprojects. Each one has its own download which is a TAR archive that is; compressed with the gzip program. The files are as follows, with *x.y* marking the version number:. ``llvm-x.y.tar.gz``. Source release for the LLVM libraries and tools. ``cfe-x.y.tar.gz``. Source release for the Clang frontend. .. _checkout:. Checkout LLVM from Git; ----------------------. You can also checkout the source code for LLVM from Git. .. note::. Passing ``--config core.autocrlf=false`` should not be required in; the future after we adjust the .gitattribute settings correctly, but; is required for Windows users at the time of this writing. Simply run:. .. code-block:: console. % git clone https://github.com/llvm/llvm-project.git. or on Windows,. .. code-block:: console. % git clone --config core.autocrlf=false https://github.com/llvm/llvm-project.git. This will create an '``llvm-project``' directory in the current directory and; fully populate it with all of the source code, test directories, and local; copies of documentation files for LLVM and all the related subprojects. Note; that unlike the tarballs, which contain each subproject in a separate file, the; git repository contains all of the projects together. If you want to get a specific release (as opposed to the most recent revision),; you can check out a tag after cloning the repository. E.g., `git checkout; llvmorg-6.0.1` inside the ``llvm-project`` directory created by the above; command. Use `git tag -l` to list all of them. Sending patches; ^^^^^^^^^^^^^^^. See :ref:`Contributing <submit_patch>`. Bisecting commits; ^^^^^^^^^^^^^^^^^. See `Bisecting LLVM code <GitBis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:22073,Simpl,Simply,22073,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['Simpl'],['Simply']
Usability,"s like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the induction variable. If the only purpose; of the loop is to compute the exit value of some derived expression, this; transformation will make the loop dead. This transformation should be followed by strength reduction after all of the; desired loop transformations have been performed. Additionally, on targets; where it is profitable, the loop could be transformed to count down to zero; (the ""do loop"" optimization). ``inline``: Function Integration/Inlining; -----------------------------------------. Bottom-up inlining of functions into callees. .. _passes-instcombine:. ``instcombine``: Combine redundant instructions; -----------------------------------------------. Combine instructions to form fewer, simple instructions. This pass does not; modify the CFG. This pass is where algebraic simplification happens. This pass combines things like:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. into:. .. code-block:: llvm. %Z = add i32 %X, 2. This is a simple worklist driven algorithm. This pass guarantees that the following canonicalizations are performed on the; program:. #. If a binary operator has a constant operand, it is moved to the right-hand; side.; #. Bitwise operators with constant operands are always grouped so that shifts; are performed first, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant power-of-two argument are transformed into; shifts.; #. … etc. This pass can also ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:19426,simpl,simple,19426,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"s no explicit interface (see; comments in ``PassManager.h`` for more details). All LLVM passes inherit from; the CRTP mix-in ``PassInfoMixin<PassT>``. The pass should have a ``run()``; method which returns a ``PreservedAnalyses`` and takes in some unit of IR; along with an analysis manager. For example, a function pass would have a; ``PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);`` method. We start by showing you how to construct a pass, from setting up the build,; creating the pass, to executing and testing it. Looking at existing passes is; always a great way to learn details. .. warning::; This document deals with the new pass manager. LLVM uses the legacy pass; manager for the codegen pipeline. For more details, see; :doc:`WritingAnLLVMPass` and :doc:`NewPassManager`. Quick Start --- Writing hello world; ===================================. Here we describe how to write the ""hello world"" of passes. The ""HelloWorld""; pass is designed to simply print out the name of non-external functions that; exist in the program being compiled. It does not modify the program at all,; it just inspects it. The code below already exists; feel free to create a pass with a different; name alongside the HelloWorld source files. .. _writing-an-llvm-npm-pass-build:. Setting up the build; --------------------. First, configure and build LLVM as described in :doc:`GettingStarted`. Next, we will reuse an existing directory (creating a new directory involves; messing around with more CMake files than we want). For this example, we'll use; ``llvm/lib/Transforms/Utils/HelloWorld.cpp``, which has already been created.; If you'd like to create your own pass, add a new source file into; ``llvm/lib/Transforms/Utils/CMakeLists.txt`` (assuming you want your pass in; the ``Transforms/Utils`` directory. Now that we have the build set up for a new pass, we need to write the code; for the pass itself. .. _writing-an-llvm-npm-pass-basiccode:. Basic code required; -------------------. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:1705,simpl,simply,1705,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,1,['simpl'],['simply']
Usability,"s of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does not know whether anything is interested in this information. On; the other side there might be an object waiting for that signal and; ready to react to it. This object disposes of special instruments to; listen to the sent out signals. To have a communication we need a; message transmission between the objects. In this simple example we use; signals and slots. The code of the method **`TGButton::Clicked()`** is:. ``` {.cpp}; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; ```. I.e. any button emits the signal `Clicked()` any time someone clicks on; it. As you can see this method is virtual and could be overridden if you; need to. In our simple example we call the `Connect()` method to connect; the `Clicked()` signal of Draw button with `MyMainFrame::DoDraw():`. ``` {.cpp}; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; ```. In the same way we can connect to the signal `Clicked()` of the Exit; button with the system call `gApplication->Terminate(0).` We declare a; new slot `DoExit(),` implement it to invoke the termination call and; associate this slot with the signal `Clicked()` of the Exit button. The code of `example.C` can be changed as follows:. ``` {.cpp}; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFrame::DoExit() {; gApplication->Terminate(0);; }; MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {; ...; TGTextButton *exit = new TGTextButton(hframe,""&Exit "");; // connects signal Clicked() with slot DoExit(); exit->Connect(""Clicked()"",""MyMainFrame"",this,""DoExit()"");; ...; }; ```. Here is an abstract view of the signal/slots connections in `example.C`:. ![](pictures/0200020C.jpg). To benefit from this mechanism your classes ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:41907,simpl,simple,41907,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"s of constexpr static data members; Not resolved. 2410; C++23; Implicit calls of immediate functions; Unknown. 2411; C++20; Comparison of pointers to members in template non-type arguments; Unknown. 2412; review; SFINAE vs undeduced placeholder type; Not resolved. 2413; CD6; typename in conversion-function-ids; Unknown. 2414; C++20; Unclear results if both member and friend operator<=> are declared; Unknown. 2415; NAD; using-declarations vs copy assignment operators; Unknown. 2416; C++20; Explicit specializations vs constexpr and consteval; Unknown. 2417; open; Explicit instantiation and exception specifications; Not resolved. 2418; CD5; Missing cases in definition of “usable in constant expressions”; Unknown. 2419; C++20; Loss of generality treating pointers to objects as one-element arrays; Unknown. 2420; dup; Exception specifications in explicit instantiation; Unknown. 2421; drafting; Explicit instantiation of constrained member functions; Not resolved. 2422; C++20; Incorrect grammar for deduction-guide; Unknown. 2423; NAD; Typedefs, names, and entities; Unknown. 2424; C++20; constexpr initialization requirements for variant members; Unknown. 2425; open; Confusing wording for deduction from a type; Not resolved. 2426; C++20; Reference to destructor that cannot be invoked; Unknown. 2427; C++20; Deprecation of volatile operands and unevaluated contexts; Unknown. 2428; C++23; Deprecating a concept; Unknown. 2429; C++20; Initialization of thread_local variables referenced by lambdas; Unknown. 2430; C++20; Completeness of return and parameter types of member functions; Unknown. 2431; C++20; Full-expressions and temporaries bound to references; Unknown. 2432; C++20; Return types for defaulted <=>; Unknown. 2433; C++20; Variable templates in the ODR; Unknown. 2434; open; Mandatory copy elision vs non-class objects; Not resolved. 2435; open; Alias template specializations; Not resolved. 2436; C++20; Copy semantics of coroutine parameters; Unknown. 2437; C++20; Conversion ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:165806,guid,guide,165806,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['guid'],['guide']
Usability,"s on our command line. Again, this; just reduces the amount of checking we have to do. Collecting options as a set of flags; ------------------------------------. Instead of collecting sets of options in a list, it is also possible to gather; information for enum values in a **bit vector**. The representation used by the; `cl::bits`_ class is an ``unsigned`` integer. An enum value is represented by a; 0/1 in the enum's ordinal value bit position. 1 indicating that the enum was; specified, 0 otherwise. As each specified value is parsed, the resulting enum's; bit is set in the option's bit vector:. .. code-block:: c++. bits |= 1 << (unsigned)enum;. Options that are specified multiple times are redundant. Any instances after; the first are discarded. Reworking the above list example, we could replace `cl::list`_ with `cl::bits`_:. .. code-block:: c++. cl::bits<Opts> OptimizationBits(cl::desc(""Available Optimizations:""),; cl::values(; clEnumVal(dce , ""Dead Code Elimination""),; clEnumVal(instsimplify , ""Instruction Simplification""),; clEnumValN(inlining, ""inline"", ""Procedure Integration""),; clEnumVal(strip , ""Strip Symbols"")));. To test to see if ``instsimplify`` was specified, we can use the ``cl:bits::isSet``; function:. .. code-block:: c++. if (OptimizationBits.isSet(instsimplify)) {; ...; }. It's also possible to get the raw bit vector using the ``cl::bits::getBits``; function:. .. code-block:: c++. unsigned bits = OptimizationBits.getBits();. Finally, if external storage is used, then the location specified must be of; **type** ``unsigned``. In all other ways a `cl::bits`_ option is equivalent to a; `cl::list`_ option. .. _additional extra text:. Adding freeform text to help output; -----------------------------------. As our program grows and becomes more mature, we may decide to put summary; information about what it does into the help output. The help output is styled; to look similar to a Unix ``man`` page, providing concise information about a; program. Unix ``m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:22326,Simpl,Simplification,22326,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['Simpl'],['Simplification']
Usability,"s or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed. In such cases you'll have to install ROOT from source. ROOT is currently running on the following platforms: supported; platforms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GNU/Hurd (GCC)`. - `HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)`. - `Compaq Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler) `. - `Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC) `. - `MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)`. - `PowerPC with GNU/Linux and GCC, Debian v2`. - `PowerPC64 with GNU/Linux and GCC`. - `ARM with GNU/Linux and GCC`. - `LynxOS`. ## The Organization of the ROOT Framework. Now after we know in abstract terms what the ROOT framework is, let us; look at the physical directories and files that come with the ROOT; installation. You may work on a platform where your system; administrator has already installed ROOT. You will need to follow the; specific development environment for your setup and you may not have; write access to the directories. In any case, you will need an; env",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:9856,UX,UX,9856,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['UX'],['UX']
Usability,"s or values; also for data or choices that are discrete, small; and fixed in number, not easily remembered. With check boxes all; alternatives are visible: it is easy to access and compare choices; because they can all be seen together. Each option acts as a switch and; can be either ""on"" or ""off"". It is never changed in contents. Checkboxes; differ from radio buttons in that they permit selection of more than one; alternative. Each box can be switched on or off independently. These; buttons can be used alone or grouped in sets. It is good practice to; provide default settings for check boxes whenever it is possible. ![](pictures/03000213.png). This can be done by:. ``` {.cpp}; SetState(EButtonState state); ```. The parameter state can be one of `kButtonUp`, `kButtonDown`,; `kButtonEngaged`, `kButtonDisabled`. Check boxes can be used to affect other controls. The contents of a list; can, for example, be filtered by setting a check box. In any case, use a; check box only when both states of a choice are clearly opposite and; unambiguous. If opposite states are not clear, it is better to use two; radio buttons. Choice description, i.e. check box label, must be clear, meaningful,; fully spelled out, and displayed in mixed-type text. Whenever the use of; a given button is inappropriate, for whatever reason, that button should; be disabled:. ``` {.cpp}; button->SetState(kButtonDisabled);; ```. Never make a button appear and disappear. In general, option buttons should not offer more than eight choices. If; the number of choices exceeds this maximum, it is better to use a; multiple selection list box. The method `IsToggleButton()` gives the information whether a radio; button or a check button is selected. An option button can be set or; unset via its method `PSetState(EButtonState state).`. The method `HandleKey(event)` is called when the defined hotkey is hit; for any button. It sets the selected option button or clicks the; selected text button and invokes its defined a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:63138,clear,clearly,63138,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['clear'],['clearly']
Usability,"s passed; in `'filename'`. ``` {.cpp}; {; gROOT->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; ```. If `branchDescriptor` is set to an empty string (the default), it is; assumed that the **`Tree`** descriptor is given in the first line of the; file with a syntax like: `A/D:Table[2]/F:Ntracks/I:astring/C`. Otherwise branchDescriptor must be specified with the above syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** method is a powerful yet simple way to look and draw the; trees contents. It enables you to plot a variable (a leaf) with just one; line of code. However, the Draw method falls short once you want to look; at each entry and design more sophisticated acceptance criteria for your; analysis. For these cases, you can use `TTree::MakeClass`. It creates a; class that loops over the trees entries one by one. You can then expand; it to do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:67714,simpl,simple,67714,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"s reachable objects starting; from the roots, then deallocates unreachable objects in a sweep phase. Copying; As reachability analysis proceeds, the collector copies objects from one heap; area to another, compacting them in the process. Copying collectors enable; highly efficient ""bump pointer"" allocation and can improve locality of; reference. Incremental; (Including generational collectors.) Incremental collectors generally have all; the properties of a copying collector (regardless of whether the mature heap; is compacting), but bring the added complexity of requiring write barriers. Threaded; Denotes a multithreaded mutator; the collector must still stop the mutator; (""stop the world"") before beginning reachability analysis. Stopping a; multithreaded mutator is a complicated problem. It generally requires highly; platform-specific code in the runtime, and the production of carefully; designed machine code at safe points. Concurrent; In this technique, the mutator and the collector run concurrently, with the; goal of eliminating pause times. In a *cooperative* collector, the mutator; further aids with collection should a pause occur, allowing collection to take; advantage of multiprocessor hosts. The ""stop the world"" problem of threaded; collectors is generally still present to a limited extent. Sophisticated; marking algorithms are necessary. Read barriers may be necessary. As the matrix indicates, LLVM's garbage collection infrastructure is already; suitable for a wide variety of collectors, but does not currently extend to; multithreaded programs. This will be added in the future as there is; interest. .. _stack-map:. Computing stack maps; --------------------. LLVM automatically computes a stack map. One of the most important features; of a ``GCStrategy`` is to compile this information into the executable in; the binary representation expected by the runtime library. The stack map consists of the location and identity of each GC root in the; each function in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:31368,pause,pause,31368,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['pause'],['pause']
Usability,"s soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Default initialization of const variable of a class type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken this rule to only; apply when the compiler-supplied default constructor would leave a member; uninitialized. Clang implements the more relaxed rule in version 3.8 onwards. Parameter name lookup. Some versions of GCC allow the redeclaration of function parameter names within a function protot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:19894,simpl,simple,19894,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['simpl'],['simple']
Usability,"s to the end of Chapter 1 of Building a JIT. You now have a basic; but fully functioning JIT stack that you can use to take LLVM IR and make it; executable within the context of your JIT process. In the next chapter we'll; look at how to extend this JIT to produce better quality code, and in the; process take a deeper look at the ORC layer concept. `Next: Extending the KaleidoscopeJIT <BuildingAJIT2.html>`_. Full Code Listing; =================. Here is the complete code listing for our running example. To build this; example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../examples/Kaleidoscope/BuildingAJIT/Chapter1/KaleidoscopeJIT.h; :language: c++. .. [1] Actually we use a cut-down version of KaleidoscopeJIT that makes a; simplifying assumption: symbols cannot be re-defined. This will make it; impossible to re-define symbols in the REPL, but will make our symbol; lookup logic simpler. Re-introducing support for symbol redefinition is; left as an exercise for the reader. (The KaleidoscopeJIT.h used in the; original tutorials will be a helpful reference). .. [2] +-----------------------------+-----------------------------------------------+; | File | Reason for inclusion |; +=============================+===============================================+; | CompileUtils.h | Provides the SimpleCompiler class. |; +-----------------------------+-----------------------------------------------+; | Core.h | Core utilities such as ExecutionSession and |; | | JITDylib. |; +-----------------------------+-----------------------------------------------+; | ExecutionUtils.h | Provides the DynamicLibrarySearchGenerator |; | | class. |; +-----------------------------+-----------------------------------------------+; | IRCompileLayer.h | Provides the IRCompileLayer class. |; +-----------------------------+-----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:13490,simpl,simpler,13490,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['simpl'],['simpler']
Usability,"s to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of AST printing and serialization by; ensuring that the AST produced by clang on an input doesn't change; when it is reparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5288,simpl,simplifies,5288,interpreter/llvm-project/clang/www/OpenProjects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html,1,['simpl'],['simplifies']
Usability,"s use [GitHub issues](https://github.com/civetweb/civetweb/issues). Source releases can be found on GitHub; [https://github.com/civetweb/civetweb/releases](https://github.com/civetweb/civetweb/releases). A very brief overview can be found on GitHub Pages; [http://civetweb.github.io/civetweb/](http://civetweb.github.io/civetweb/). Getting The Source; ------------------; Download the source code by running the following code in your command prompt:. $ git clone https://github.com/civetweb/civetweb.git; or simply grab a copy of the source code as a ZIP or TGZ file. Quick start documentation; --------------------------. - [docs/Installing.md](https://github.com/civetweb/civetweb/blob/master/docs/Installing.md) - Install Guide (for end users using pre-built binaries); - [docs/UserManual.md](https://github.com/civetweb/civetweb/blob/master/docs/UserManual.md) - End User Guide; - [docs/Building.md](https://github.com/civetweb/civetweb/blob/master/docs/Building.md) - Building the Server (quick start guide); - [docs/Embedding.md](https://github.com/civetweb/civetweb/blob/master/docs/Embedding.md) - Embedding (how to add HTTP support to an existing application); - [docs/OpenSSL.md](https://github.com/civetweb/civetweb/blob/master/docs/OpenSSL.md) - Adding HTTPS (SSL/TLS) support using OpenSSL.; - [API documentation](https://github.com/civetweb/civetweb/tree/master/docs/api) - Additional documentation on the civetweb application programming interface ([civetweb.h](https://github.com/civetweb/civetweb/blob/master/include/civetweb.h)).; - [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md) - Release Notes; - [SECURITY.md](https://github.com/civetweb/civetweb/blob/master/SECURITY.md) - Security Policy; - [LICENSE.md](https://github.com/civetweb/civetweb/blob/master/LICENSE.md) - Copyright License. Overview; --------. CivetWeb keeps the balance between functionality and; simplicity by a carefully selected list of features:. - Liberal, commercial-fr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:4306,guid,guide,4306,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['guid'],['guide']
Usability,"s used in; your code), it should work for AD support efforts. Please view Clad; documentation for more details. ---. ## Appendix A - What could go wrong (FAQs). ### Will my analyticalIntegral() function support AD?. Both scenarios are possible:. 1 - where `analyticalIntegral()` will be able to support AD. 2 - where `analyticalIntegral()` will *not* be able to support AD. This requires further research. ### What if my evaluate() function cannot support AD?. In some cases. the `evaluate()` function is written in a piece-wise format; (multiple evaluations based on multiple chunks of code). You can review the; `MathFuncs.h` file to find AD support for several piece-wise (`if code==1; {...} else if code==2 {...}` ) code snippets. However, there may still be some cases where AD support may not be possible; due to the way that `evaluate()` function works in that instance. ### What if my evaluate() function depends heavily on caching?. For simple caching, the caching logic can be separated from the; mathematical code that is being moved to `MathFuncs.h`, so that it can; retained in the original file. For more complicated scenarios, the `code` variable can be used to identify; use cases (parts of the mathematical code in `evaluate()`) that should be; supported, while other parts that are explicitly not be supported (e.g., using; `if code==1 {...} else if code==2 {...}`). ### Can classes using Numerical Integration support AD?. So far, no. This needs further exploration. Hint: classes using Numerical; Integration can be identified with the absence of the `analyticalIntegral()`; function. ### Why is my code falling back to Numeric Differentiation?. If you call in to an external Math library, and you use a function that has a; customized variant with an already defined custom derivative, then you may see; a warning like ""falling back to Numeric Differentiation"". In most such cases,; your derivative should still work, since Numeric Differentiation is already; well-tested in Clad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:26762,simpl,simple,26762,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simple']
Usability,"s used to track the state:; * Rather than inserting a `cmovCC` instruction along every conditional edge in; the original program, we track each set of condition flags we need to capture; prior to entering each basic block and reuse a common `cmovCC` sequence for; those.; * We could further reuse suffixes when there are multiple `cmovCC`; instructions required to capture the set of flags. Currently this is; believed to not be worth the cost as paired flags are relatively rare and; suffixes of them are exceedingly rare.; * A common pattern in x86 is to have multiple conditional jump instructions; that use the same flags but handle different conditions. Naively, we could; consider each fallthrough between them an ""edge"" but this causes a much more; complex control flow graph. Instead, we accumulate the set of conditions; necessary for fallthrough and use a sequence of `cmovCC` instructions in a; single fallthrough edge to track it. Second, we trade register pressure for simpler `cmovCC` instructions by; allocating a register for the ""bad"" state. We could read that value from memory; as part of the conditional move instruction, however, this creates more; micro-ops and requires the load-store unit to be involved. Currently, we place; the value into a virtual register and allow the register allocator to decide; when the register pressure is sufficient to make it worth spilling to memory; and reloading. #### Hardening Loads. Once we have the predicate accumulated into a special value for correct vs.; misspeculated, we need to apply this to loads in a way that ensures they do not; leak secret data. There are two primary techniques for this: we can either; harden the loaded value to prevent observation, or we can harden the address; itself to prevent the load from occurring. These have significantly different; performance tradeoffs. ##### Hardening loaded values. The most appealing way to harden loads is to mask out all of the bits loaded.; The key requirement is that for e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:21835,simpl,simpler,21835,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simpler']
Usability,"s within the vector. This means that the register content is the same as it would have been on a little endian system. It may seem that ``LD1`` should suffice to perform vector loads on a big endian machine. However there are pros and cons to the two approaches that make it less than simple which register format to pick. There are two options:. 1. The content of a vector register is the same *as if* it had been loaded with an ``LDR`` instruction.; 2. The content of a vector register is the same *as if* it had been loaded with an ``LD1`` instruction. Because ``LD1 == LDR + REV`` and similarly ``LDR == LD1 + REV`` (on a big endian system), we can simulate either type of load with the other type of load plus a ``REV`` instruction. So we're not deciding which instructions to use, but which format to use (which will then influence which instruction is best to use). .. The 'clearer' container is required to make the following section header come after the floated; images above.; .. container:: clearer. Note that throughout this section we only mention loads. Stores have exactly the same problems as their associated loads, so have been skipped for brevity. Considerations; ==============. LLVM IR Lane ordering; ---------------------. LLVM IR has first class vector types. In LLVM IR, the zero'th element of a vector resides at the lowest memory address. The optimizer relies on this property in certain areas, for example when concatenating vectors together. The intention is for arrays and vectors to have identical memory layouts - ``[4 x i8]`` and ``<4 x i8>`` should be represented the same in memory. Without this property there would be many special cases that the optimizer would have to cleverly handle. Use of ``LDR`` would break this lane ordering property. This doesn't preclude the use of ``LDR``, but we would have to do one of two things:. 1. Insert a ``REV`` instruction to reverse the lane order after every ``LDR``.; 2. Disable all optimizations that rely on lane layout, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst:4402,clear,clearer,4402,interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,1,['clear'],['clearer']
Usability,"s you out by automatically printing instantiation information and; nested range information for diagnostics as they are instantiated through macros; and also shows how some of the other pieces work in a bigger example. $ clang -fsyntax-only t.c; t.c:80:3: error: invalid operands to binary expression ('typeof(P)' (aka 'struct mystruct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:9962,simpl,simple,9962,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['simpl'],['simple']
Usability,"s |; +-----------------------------------------+----------------------------------+; | `SetSparseIndex` `(Int_t nelems new)` | allocate memory for a sparse map |; | | of `nelems_new` elements and |; | | copy (if exists) at most |; | | `nelems_new` matrix elements |; | | over to the new structure |; +-----------------------------------------+----------------------------------+; | `SetSparseIndex` | copy the sparse map from matrix |; | `(const TMatrixDBase &a)` | `a` Note that this can be a |; | | dense matrix! |; +-----------------------------------------+----------------------------------+; | `SetSparseIndexAB` | set the sparse map to the same |; | `(const TMatrixDSparse &a,` ` | of the map of matrix `a` and `b` |; | const TMatrixDSparse &b)` | |; +-----------------------------------------+----------------------------------+. The second half of the table is only relevant for sparse matrices. These; methods define the sparse structure. It should be clear that a call to; any of these methods has to be followed by a **`SetMatrixArray`** (...); which will supply the matrix data, see the next chapter ""Creating and; Filling a Matrix"". ## Creating and Filling a Matrix. The matrix constructors are listed in the next table. In the simplest; ones, only the number of rows and columns is given. In a slightly more; elaborate version, one can define the row and column index range.; Finally, one can also define the matrix data in the constructor. In; Matrix Operators and Methods we will encounter more fancy constructors; that will allow arithmetic operations. +--------------------------------------------------------------------------+; | `TMatrixD(Int_t nrows,Int_t ncols)` |; | |; | `TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb)` |; | |; | `TMatrixD(Int_t nrows,Int_t ncols,const Double_t *data, Option_t option= |; | """")` |; | |; | `TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,` |; | |; | ` const Double_t *data,Option_t *option="""")` |; +-----",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:9377,clear,clear,9377,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['clear'],['clear']
Usability,"s's returned ``PreservedAnalyses``. This can be also done; manually within the pass:. .. code-block:: c++. FooModulePass::run(Module& M, ModuleAnalysisManager& AM) {; auto &FAM = AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();. // Invalidate all analysis results for function F1.; FAM.invalidate(F1, PreservedAnalyses::none());. // Invalidate all analysis results across the entire module.; AM.invalidate(M, PreservedAnalyses::none());. // Clear the entry in the analysis manager for function F2 if we've completely removed it from the module.; FAM.clear(F2);. ...; }. One thing to note when accessing inner level IR analyses is cached results for; deleted IR. If a function is deleted in a module pass, its address is still used; as the key for cached analyses. Take care in the pass to either clear the; results for that function or not use inner analyses at all. ``AM.invalidate(M, PreservedAnalyses::none());`` will invalidate the inner; analysis manager proxy which will clear all cached analyses, conservatively; assuming that there are invalid addresses used as keys for cached analyses.; However, if you'd like to be more selective about which analyses are; cached/invalidated, you can mark the analysis manager proxy as preserved,; essentially saying that all deleted entries have been taken care of manually.; This should only be done with measurable compile time gains as it can be tricky; to make sure all the right analyses are invalidated. Implementing Analysis Invalidation; ==================================. By default, an analysis is invalidated if ``PreservedAnalyses`` says that; analyses on the IR unit it runs on are not preserved (see; ``AnalysisResultModel::invalidate()``). An analysis can implement; ``invalidate()`` to be more conservative when it comes to invalidation. For; example,. .. code-block:: c++. bool FooAnalysisResult::invalidate(Function &F, const PreservedAnalyses &PA,; FunctionAnalysisManager::Invalidator &) {; auto PAC = PA.getChecker<Fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:14428,clear,clear,14428,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['clear'],['clear']
Usability,"s, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits from **`TObject`**. It is a; simple example of a class with diverse data members. ``` {.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:43289,simpl,simple,43289,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"s, and framework; stability. The changes with respect to ROOT 5.27 / TMVA 4.0.7 are; in detail:. Framework. Multi-class support. The support of multiple; output classes (i.e., more than a single background and signal; class) has been enabled for these methods: MLP (NN), BDTG,; FDA.; The multiclass; functionality can be enabled with the Factory option; ""AnalysisType=multiclass"". Training data is; specified with an additional classname, e.g. via; factory->AddTree(tree,""classname"");. After the; training a genetic algorithm is invoked to determine the best; cuts for selecting a specific class, based on the figure of; merit: purity*efficiency. TMVA comes with two examples in; $ROOTSYS/tmva/test: TMVAMulticlass.C; and TMVAMulticlassApplication.C. New TMVA event vector building. The code; for splitting the input data into training and test samples for; all classes and the mixing of those samples to one training and; one test sample has been rewritten completely. The new code is; more performant and has a clearer structure. This fixes several; bugs which have been reported by some users of TMVA.; Code and performance test framework: A unit; test framework for daily software and method performance; validation has been implemented.; . Methods. BDT Automatic parameter optimisation for building the; tree architecture: The optimisation procedure uses the; performance of the trained classifier on the ""test sample"" for; finding the set of optimal parameters. Two different methods to; traverse the parameter space are available (scanning, genetic; algorithm). Currently parameter optimization is implemented only; for these three parameters that influence the tree architectur:; the maximum depth of a tree, MaxDepth, the minimum; number of events in each node, NodeMinEvents, and; the number of tress, NTrees. Optimization can; is invoked by calling; factory->OptimizeAllMethods(); prior to the call; factory->TrainAllMethods();. Automated and configurable parameter optimization is soon to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html:1316,clear,clearer,1316,tmva/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html,1,['clear'],['clearer']
Usability,"s-entropy loss function. In addition we have :. - New `TMVA::Executor` class to control the multi-thread running of TMVA. By default now MT running will be enabled only when `ROOT::EnabledImplicitMT()` is called. But we can take the control of the threads by using `TMVA::gConfig().EnableMT(...)` and `TMVA::gConfig().DisableMT()`. ### PyMVA; - add support when using the Tensorflow backend in Keras to control the number of threads; - add possibility to control options for configuring GPU running. FOr example we can now set the mode to allocate memory only as needed. This is required when using the new RTX gaming cards from NVIDIA. ## 2D Graphics Libraries. - In the statistics painting for 2D histograms, the central cell of; the underflow/overflow grid was not properly rendered for very large contents.; This problem was reported [here](https://root-forum.cern.ch/t/stat-box-for-th2/).; - The automatic placement of legend now ""sees"" TMultiGraph and THStack.; - Improve and simplify the drawing the 2D histogram's option ""ARR"".; - The option ARR can be combined with the option COL or COLZ.; - `TBox::DistancetoPrimitive` and `TBox::ExecuteEvent` now work in log scales (by Jérémie Dudouet).; - Take the line attributes into account when drawing a histogram with option bar or hbar.; They were ignored until now.; - The new draw option MIN0 makes same effect as gStyle->SetHistMinimumZero(1), but can be specified; individually for each histogram.; - Improve the line clipping when a histogram is drawn with option ""L"". The following; example shows the improvement.; ~~~ {.cpp}; auto h = new TH1F(""h"",""h"",5,0.5,5.5);; h->SetBinContent(1,100000);; h->SetBinContent(2,10000);; h->SetBinContent(3,1000);; h->SetBinContent(4,100);; h->SetBinContent(5,10);; h->SetMinimum(50.);; h->SetMaximum(40000);; h->Draw(""L*"");; gPad->SetLogy();; ~~~; - `ChangeLabel` is now available for alphanumeric axis.; - Implement transparency for lines, texts and markers in the TeX output. ## 3D Graphics Libraries. -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:18808,simpl,simplify,18808,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['simpl'],['simplify']
Usability,"s. //===---------------------------------------------------------------------===//. In this code:. long foo(long x) {; return x > 1 ? x : 1;; }. LLVM emits a comparison with 1 instead of 0. 0 would be equivalent; and cheaper on most targets. LLVM prefers comparisons with zero over non-zero in general, but in this; case it choses instead to keep the max operation obvious. //===---------------------------------------------------------------------===//. define void @a(i32 %x) nounwind {; entry:; switch i32 %x, label %if.end [; i32 0, label %if.then; i32 1, label %if.then; i32 2, label %if.then; i32 3, label %if.then; i32 5, label %if.then; ]; if.then:; tail call void @foo() nounwind; ret void; if.end:; ret void; }; declare void @foo(). Generated code on x86-64 (other platforms give similar results):; a:; 	cmpl	$5, %edi; 	ja	LBB2_2; 	cmpl	$4, %edi; 	jne	LBB2_3; .LBB0_2:; 	ret; .LBB0_3:; 	jmp	foo # TAILCALL. If we wanted to be really clever, we could simplify the whole thing to; something like the following, which eliminates a branch:; 	xorl $1, %edi; 	cmpl	$4, %edi; 	ja	.LBB0_2; 	ret; .LBB0_2:; 	jmp	foo # TAILCALL. //===---------------------------------------------------------------------===//. We compile this:. int foo(int a) { return (a & (~15)) / 16; }. Into:. define i32 @foo(i32 %a) nounwind readnone ssp {; entry:; %and = and i32 %a, -16; %div = sdiv i32 %and, 16; ret i32 %div; }. but this code (X & -A)/A is X >> log2(A) when A is a power of 2, so this case; should be instcombined into just ""a >> 4"". We do get this at the codegen level, so something knows about it, but ; instcombine should catch it earlier:. _foo: ## @foo; ## %bb.0: ## %entry; 	movl	%edi, %eax; 	sarl	$4, %eax; 	ret. //===---------------------------------------------------------------------===//. This code (from GCC PR28685):. int test(int a, int b) {; int lt = a < b;; int eq = a == b;; if (lt); return 1;; return eq;; }. Is compiled to:. define i32 @test(i32 %a, i32 %b) nounwind readnone ssp {; entry",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:52419,simpl,simplify,52419,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplify']
Usability,"s. ; Runtime binding of C++ functions - You can now trivially bind at run time any C++ functions as a RooFit function or p.d.f. objects, e.g. RooAbsReal* erfx = bindFunction(""erfx"",TMath::erf,x). See rf105_funcbinding.C for details; Runtime binding of TFx functions - You can now trivially bind at run time any ROOT TFx function as a RooFit function or p.d.f. objects, e.g. RooAbsReal* myFunc = bindFunction(myTF1,x). See rf105_funcbinding.C for details; RooAbsReal - The handling of -log(L) evaluation errors in plotting is now explicitly controllable, just like in fitting. See rf606_nllerrorhandling.C for details; RooDataHist - Add new named argument constructor that can collate multiple ROOT THn histgrams into a n+1 dimensional RooDataHist; RooDataSet - Add new named argument constructor that can collate multiple input RooDataSets into a n+1 dimensional RooDataSet.Add createHistogram() method for simplified plotting; RooFitResult - Add new method correlationHist() that returns a labeled TH2 with the contents of the fit correlation matrix; RooFFTConvPdf - Automatically put sampling windows of 'resolution model' p.d.f. centered around zero, even if fit range of convolution observable does not bracket zero. Improve internal efficiency; RooAbsData - Add ability to plot efficiency distribution with correct binomial errors given a RooRealVar and a RooCategory category observable encoding distribution and accept/reject state respectively. See rf701_efficiencyfit.C for details ; RooAbsPdf - Included extended ML term by default in fit if p.d.f is extendable. You can still use Extended() to override default behavior. Do not run MINOS by default anymore if no fit options are provided.; RooProfileLL - Add option to always start minimization from global minimimum (takes more time, but improves reproducibility). Can now profile multi-core paralellized likelihoods as well.; RooRealSumPdf - Enable plotting of component p.d.f.s using same scheme as RooAddPdf, i.e. just use the Component",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:7626,simpl,simplified,7626,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['simpl'],['simplified']
Usability,"s. The line above specifies that the slot; `MyMainFrame::DoDraw()` will be executed when the draw button is; clicked. Our slot draws the graphics of `sin(x)/x` in randomly chosen; interval every time the draw button sends a signal ""I am clicked"". The; signal/slot communication mechanism originally featured in Qt by; TrollTech(see <http://doc.trolltech.com/3.1/signalsandslots.html>). ROOT; supports its own version of signals/slots. We will return to that point; in details later. We specified all child widgets of the horizontal frame; (the Draw and Exit buttons in our case). Next, we need to add their; parent frame to the main frame:. ``` {.cpp}; fMain->AddFrame(hframe,new TGLayoutHints(kLHintsCenterX,2,2,2,2));; ```. The last thing to do is to set the main window title and to make all; widgets visible. Commonly in all systems windows are assigned by name to; be identified by users. This name is displayed in the application's; title bar and can be set by:. ``` {.cpp}; fMain->SetWindowName(""Simple Example"");; ```. The next lines make the widgets visible. The first one maps all child; frames of the top-level frame; the last one - the main frame itself,; i.e. makes it appear on the screen. ``` {.cpp}; fMain->MapSubwindows();; fMain->Resize(fMain->GetDefaultSize());; fMain->MapWindow();; ```. The line in between has an important mission - to execute all layout; specifications for the widgets before the top-level window itself is; shown on the screen. We can run the named script via the Cling; interpreter with the command:. ``` {.cpp}; root[].x example.C; ```. The event processing starts. If you change the state of a widget, it; emits a signal and the corresponding slot is executed ensuring the; functionality we want for this small example. The steps we passed can be generalized as follows:. - Opening of the connection to the system. - Definition of main frame (top level window). - Creation of widgets as children of the top-level frame; assign them; desired properties follo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:13963,Simpl,Simple,13963,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['Simpl'],['Simple']
Usability,"s. The sources are checked out from the; upstream git repository when building the image. The resulting image contains only the requested LLVM components and a few extra; packages to make the image minimally useful for C++ development, e.g. libstdc++; and binutils. The interface to run the build is ``build_docker_image.sh`` script. It accepts a; list of LLVM repositories to checkout and arguments for CMake invocation. If you want to write your own docker image, start with an ``example/`` subfolder.; It provides an incomplete Dockerfile with (very few) FIXMEs explaining the steps; you need to take in order to make your Dockerfiles functional. Usage; =====; The ``llvm/utils/build_docker_image.sh`` script provides a rather high degree of; control on how to run the build. It allows you to specify the projects to; checkout from git and provide a list of CMake arguments to use during when; building LLVM inside docker container. Here's a very simple example of getting a docker image with clang binary,; compiled by the system compiler in the debian10 image:. .. code-block:: bash. ./llvm/utils/docker/build_docker_image.sh \; 	--source debian10 \; 	--docker-repository clang-debian10 --docker-tag ""staging"" \; 	-p clang -i install-clang -i install-clang-resource-headers \; 	-- \; 	-DCMAKE_BUILD_TYPE=Release. Note that a build like that doesn't use a 2-stage build process that; you probably want for clang. Running a 2-stage build is a little more intricate,; this command will do that:. .. code-block:: bash. # Run a 2-stage build.; # LLVM_TARGETS_TO_BUILD=Native is to reduce stage1 compile time.; # Options, starting with BOOTSTRAP_* are passed to stage2 cmake invocation.; ./build_docker_image.sh \; 	--source debian10 \; 	--docker-repository clang-debian10 --docker-tag ""staging"" \; 	-p clang -i stage2-install-clang -i stage2-install-clang-resource-headers \; 	-- \; 	-DLLVM_TARGETS_TO_BUILD=Native -DCMAKE_BUILD_TYPE=Release \; 	-DBOOTSTRAP_CMAKE_BUILD_TYPE=Release \; 	-DCLANG_ENABLE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst:3570,simpl,simple,3570,interpreter/llvm-project/llvm/docs/Docker.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst,1,['simpl'],['simple']
Usability,"s.; for ref in $(git -C my-monorepo for-each-ref --format=""%(refname)"" \; refs/remotes/myrepo/release); do; branch=${ref#refs/remotes/myrepo/}; git -C my-monorepo branch --no-track myrepo/${branch} ${ref}; done. # Preserve main.; git -C my-monorepo branch --no-track myrepo/main refs/remotes/myrepo/main. # Merge main.; git -C my-monorepo checkout local/zip/main # Or local/octopus/main; git -C my-monorepo merge myrepo/main. You may want to merge other corresponding branches, for example; ``myrepo`` release branches if they were in lockstep with LLVM project; releases. ``--tag-prefix`` tells ``import-downstream-repo.py`` to rename; annotated tags with the given prefix. Due to limitations with; ``fast_filter_branch.py``, unannotated tags cannot be renamed; (``fast_filter_branch.py`` considers them branches, not tags). Since; the upstream monorepo had its tags rewritten with an ""llvmorg-""; prefix, name conflicts should not be an issue. ``--tag-prefix`` can; be used to more clearly indicate which tags correspond to various; imported repositories. Given this repository history::. R1 - R2 - R3 <- main; ^; |; release/1. The above recipe results in a history like this::. U1 - U2 - U3 <- upstream/main; \ \ \; \ -----\--------------- local/zip--.; \ \ \ |; - Lllvm1 - Llld1 - UM3 - Lclang1 - Lclang2 - Lllvm2 - Llld2 - Lmyproj1 - M1 <-'; /; R1 - R2 - R3 <-.; ^ |; | |; myrepo-release/1 |; |; myrepo/main--'. Commits ``R1``, ``R2`` and ``R3`` have trees that *only* contain blobs; from ``myrepo``. If you require commits from ``myrepo`` to be; interleaved with commits on local project branches (for example,; interleaved with ``llvm1``, ``llvm2``, etc. above) and myrepo doesn't; appear in an umbrella repository, a new tool will need to be; developed. Creating such a tool would involve:. 1. Modifying ``fast_filter_branch.py`` to optionally take a; revlist directly rather than generating it itself. 2. Creating a tool to generate an interleaved ordering of local; commits based on some cri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:36478,clear,clearly,36478,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['clear'],['clearly']
Usability,"s.fInt); 42; >>>. * **C-style cast**: This is the simplest option for builtin types.; The syntax is ""template-style"", example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... void* get_data(int sz) {; ... int* iptr = (int*)malloc(sizeof(int)*sz);; ... for (int i=0; i<sz; ++i) iptr[i] = i;; ... return iptr;; ... }""""""); ...; >>> NDATA = 4; >>> d = cppyy.gbl.get_data(NDATA); >>> print(d); <cppyy.LowLevelView object at 0x1068cba30>; >>> d = cppyy.ll.cast['int*'](d); >>> d.reshape((NDATA,)); >>> print(list(d)); [0, 1, 2, 3]; >>>. * **C++-style casts**: Similar to the C-style cast, there are; ``ll.static_cast`` and ``ll.reinterpret_cast``.; There should never be a reason for a ``dynamic_cast``, since that only; applies to objects, for which auto-casting will work.; The syntax is ""template-style"", just like for the C-style cast above. .. _npcasts:. `NumPy casts`; -------------. The ``cppyy.LowLevelView`` type returned for pointers to basic types,; including for ``void*``, is a simple and light-weight view on memory, given a; pointer, type, and number of elements (or unchecked, if unknown).; It only supports basic operations such as indexing and iterations, but also; the buffer protocol for integration with full-fledged functional arrays such; as NumPy`s ``ndarray``. In addition, specifically when dealing with ``void*`` returns, you can use; NumPy's low-level ``frombuffer`` interface to perform the cast.; Example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... void* create_float_array(int sz) {; ... float* pf = (float*)malloc(sizeof(float)*sz);; ... for (int i = 0; i < sz; ++i) pf[i] = 2*i;; ... return pf;; ... }""""""); ...; >>> import numpy as np; >>> NDATA = 8; >>> arr = cppyy.gbl.create_float_array(NDATA); >>> print(arr); <cppyy.LowLevelView object at 0x109f15230>; >>> arr.reshape((NDATA,)) # adjust the llv's size; >>> v = np.frombuffer(arr, dtype=np.float32, count=NDATA) # cast to float; >>> print(len(v)); 8; >>> print(v); array([ 0., 2., 4., 6., 8., 10., 12., 14.],",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:4598,simpl,simple,4598,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['simpl'],['simple']
Usability,"s0x8000``' gives -32768. Note that hexadecimal integers are sign extended from the number; of active bits, i.e. the bit width minus the number of leading; zeros. So '``s0x0001``' of type '``i16``' will be -1, not 1.; **Floating-point constants**; Floating-point constants use standard decimal notation (e.g.; 123.421), exponential notation (e.g. 1.23421e+2), or a more precise; hexadecimal notation (see below). The assembler requires the exact; decimal value of a floating-point constant. For example, the; assembler accepts 1.25 but rejects 1.3 because 1.3 is a repeating; decimal in binary. Floating-point constants must have a; :ref:`floating-point <t_floating>` type.; **Null pointer constants**; The identifier '``null``' is recognized as a null pointer constant; and must be of :ref:`pointer type <t_pointer>`.; **Token constants**; The identifier '``none``' is recognized as an empty token constant; and must be of :ref:`token type <t_token>`. The one non-intuitive notation for constants is the hexadecimal form of; floating-point constants. For example, the form; '``double 0x432ff973cafa8000``' is equivalent to (but harder to read; than) '``double 4.5e+15``'. The only time hexadecimal floating-point; constants are required (and the only time that they are generated by the; disassembler) is when a floating-point constant must be emitted but it; cannot be represented as a decimal floating-point number in a reasonable; number of digits. For example, NaN's, infinities, and other special; values are represented in their IEEE hexadecimal format so that assembly; and disassembly do not cause any bits to change in the constants. When using the hexadecimal form, constants of types bfloat, half, float, and; double are represented using the 16-digit form shown above (which matches the; IEEE754 representation for double); bfloat, half and float values must, however,; be exactly representable as bfloat, IEEE 754 half, and IEEE 754 single; precision respectively. Hexadecimal format is a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:185815,intuit,intuitive,185815,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['intuit'],['intuitive']
Usability,"s5.root Y 1.40 Gb 8.09s +/- 0.08 (700 entries) . In the case of a data member which is a pointer to a STL container, eg:; std::container<Data> *fDataObjects;; and which is stored member-wise, add support for the schema evolution of the class 'Data'. This requires a change in the on file format used to store this type; of data members (i.e. by adding inline the version number of the class; 'Data'). To read file containing this construct and written with this revision; using an older version of ROOT you will need the following patches:; For v5.22/00, you will need the patch r33174; or v5.22/00k; For v5.26/00, you will need patch r33176; or v5.26/00c. Additionally, we no longer allow the member wise streaming of a class which; has a custom streamer nor of any data members marked with //||. Run time performance. We introduced an optimized infrastructure for reading objects using a StreamerInfo. Rather than driving the streaming using a switch statement inside TStreamerInfo::ReadBuffer,; the streaming is now driven using a simple loop over a sequence of configured StreamerInfo actions. This improves run-time performance by allowing a dramatic reduction in function calls and code; branches at the expense of some code duplication. There are 3 versions of this loop implemented in TBufferFile and overloaded in TBufferXML and TBufferSQL:. virtual Int_t ReadSequence(const TStreamerInfoActions::TActionSequence &sequence, void *object);; virtual Int_t ReadSequence(const TStreamerInfoActions::TActionSequence &sequence,; void *start_collection, void *end_collection);; virtual Int_t ReadSequence(const TStreamerInfoActions::TActionSequence &sequence,; void *start_collection, void *end_collection);. The 1st version is optimized to read a single object. The 2nd version is optimized to read the content of TClonesArrays and vectors of pointers to objects. The 3rd version is used to streamed any collections. TBufferXML and TBufferSQL overload the loops to introduce extra code to help the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:3052,simpl,simple,3052,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,1,['simpl'],['simple']
Usability,"s; Using ccache materially improves average build times. Incremental builds; can be slightly faster, but introduce the risk of build corruption due to; e.g. state changes, etc... At this point, the recommendation is not to; use incremental builds and instead use ccache as the latter captures the; majority of the benefit with less risk of false positives. One of the non-obvious benefits of using ccache is that it makes the; builder less sensitive to which projects are being monitored vs built.; If a change triggers a build request, but doesn't change the build output; (e.g. doc changes, python utility changes, etc..), the build will entirely; hit in cache and the build request will complete in just the testing time. With multiple workers, it is tempting to try to configure a shared cache; between the workers. Experience to date indicates this is difficult to; well, and that having local per-worker caches gets most of the benefit; anyways. We don't currently recommend shared caches. CCache does depend on the builder hardware having sufficient IO to access; the cache with reasonable access times - i.e. a fast disk, or enough memory; for a RAM cache, etc.. For builders without, incremental may be your best; option, but is likely to require higher ongoing involvement from the; sponsor. Enable batch builds; As a last resort, you can configure your builder to batch build requests.; This makes the build failure notifications markedly less actionable, and; should only be done once all other reasonable measures have been taken. Leave it on the staging buildmaster; While most of this section has been biased towards builders intended for; the main buildmaster, it is worth highlighting that builders can run; indefinitely on the staging buildmaster. Such a builder may still be; useful for the sponsoring organization, without concern of negatively; impacting the broader community. The sponsoring organization simply; has to take on the responsibility of all bisection and triage. ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:13009,simpl,simply,13009,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['simpl'],['simply']
Usability,"s; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; bool fix_t;; double b_init // b parameter, see peak shape function; double b_calc;; double b_err;; bool fix_b;; double s_init; // s parameter, see peak shape function; double s_calc;; double s_err;; bool fix_s;; double a0_init; // background is estimated as a0+a1*x+a2*x*x; double a0_calc;; double a0_err;; bool fix_a0;; double a1_init;; double a1_calc;; double a1_err;; bool fix_a1;; double a2_init;; double a2_calc;; double a2_err;; bool fix_a2;; };; ```. As an example we present a simple 1-dimensional synthetic spectrum with 5; peaks. The fit (obtained using above-given awmi fitting function) is given; in Figure 5.1. The chi-square achieved in this fit was 0.76873. The input; value of the fit (positions of peaks and their amplitudes) were; estimated using peak searching function. ![Fit obtained using above given awmi fitting function](figures/image172.png). Let us go to a more complicated fit with a lot of overlapping peaks as in Figure 5.2.; The initial positions of peaks were determined from original data, using; peak searching function. The fit is not very good, as there are some; peaks missing. ![More complicated fit with lot of overlapping peaks](figures/image174.png). However, in order to analyze the spectrum, we can proceed in a completely different way employing the sophisticated functions of background elimination and deconvolution. First, let us remove background from the original raw; data. We get spectrum given in Figure 5.3. ![Removed background from the origina",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:44008,simpl,simple,44008,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,"s; }. unix.MallocSizeof; (C); Check for dubious malloc, calloc or; realloc arguments involving sizeof. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. unix.MismatchedDeallocator; (C, C++, ObjC); Check for mismatched deallocators (e.g. passing a pointer allocating; with new to free()). // C, C++; void test() {; int *p = (int *)malloc(sizeof(int));; delete p; // warn; }. // C, C++; void __attribute((ownership_returns(malloc))) *user_malloc(size_t);. void test() {; int *p = (int *)user_malloc(sizeof(int));; delete p; // warn; }. // C, C++; void test() {; int *p = new int;; free(p); // warn; }. // C, C++; void test() {; int *p = new int[1];; realloc(p, sizeof(long)); // warn; }. // C, C++; template <typename T>; struct SimpleSmartPointer {; T *ptr;. explicit SimpleSmartPointer(T *p = 0) : ptr(p) {}; ~SimpleSmartPointer() {; delete ptr; // warn; }; };. void test() {; SimpleSmartPointer<int> a((int *)malloc(4));; }. // C++; void test() {; int *p = (int *)operator new(0);; delete[] p; // warn; }. // Objective-C, C++; void test(NSUInteger dataLength) {; int *p = new int;; NSData *d = [NSData dataWithBytesNoCopy:p; length:sizeof(int) freeWhenDone:1];; // warn +dataWithBytesNoCopy:length:freeWhenDone: cannot take; // ownership of memory allocated by 'new'; }. unix.Vfork; (C); Check for proper usage of vfork. int test(int x) {; pid_t pid = vfork(); // warn; if (pid != 0); return 0;. switch (x) {; case 0:; pid = 1;; execl("""", """", 0);; _exit(1);; break;; case 1:; x = 0; // warn: this assignment is prohibited; break;; case 2:; foo(); // warn: this function call is prohibited; break;; default:; return 0; // warn: return is prohibited; }. while(1);; }. unix.cstring.BadSizeArg; (C); Check the size argument passed to strncat for common erroneous; patterns. Use -Wno-strncat-size compiler option to mute other; strncat-related compiler warnings. void test() {; char dest[3];; strn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:25754,Simpl,SimpleSmartPointer,25754,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['Simpl'],['SimpleSmartPointer']
Usability,"sals for additional benchmarks/programs for llvm's test-suite. :doc:`Proposals/VariableNames`; Proposal to change the variable names coding standard. :doc:`Proposals/VectorPredication`; Proposal for predicated vector instructions in LLVM. .. _llvm-community-calendar:. LLVM community calendar; -----------------------. We aim to maintain a public calendar view of all events happening in the LLVM; community such as :ref:`online-sync-ups` and :ref:`office-hours`. The calendar; can be found at; https://calendar.google.com/calendar/u/0/embed?src=calendar@llvm.org and can; also be seen inline below:. .. raw:: html. <iframe src=""https://calendar.google.com/calendar/embed?height=600&wkst=1&bgcolor=%23ffffff&ctz=UTC&showCalendars=0&showDate=1&showNav=1&src=Y2FsZW5kYXJAbGx2bS5vcmc&color=%23039BE5"" style=""border:solid 1px #777"" width=""800"" height=""600"" frameborder=""0"" scrolling=""no""></iframe>. .. _llvm-community-calendar-host-guidance:. Guidance on what to put into LLVM community calendar invites; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. To add your event, create a calendar event for it and invite calendar@llvm.org; on it. Your event should then show up on the community calendar. Please put the following pieces of information in your calendar invite:. * Write a single paragraph describing what the event is about. Include things; such as who the event is for and what sort of topics are discussed.; * State explicitly that the :doc:`CodeOfConduct` applies to this event.; * Make it clear who:. * the organizer is. * the person to contact is in case of any code-of-conduct issues. Typically,; this would be the organizer. * If you have meeting minutes for your event, add a pointer to where those live.; A good place for meeting minutes could be as a post on LLVM Discourse. An example invite looks as follows. .. code-block:: none. This event is a meetup for all developers of LLDB. Meeting agendas are posted; on discourse before the event. Attendees are required to ad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:19591,Guid,Guidance,19591,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['Guid'],['Guidance']
Usability,"sary; to execute tail iterations of the loop if the loop trip count is unknown or it; does not evenly divide the vectorization and unroll factors. When the; vectorization and unroll factors are large, it's possible for loops with smaller; trip counts to end up spending most of their time in the scalar (rather than; the vector) code. In order to address this issue, the inner loop vectorizer is; enhanced with a feature that allows it to vectorize epilogue loops with a; vectorization and unroll factor combination that makes it more likely for small; trip count loops to still execute in vectorized code. The diagram below shows; the CFG for a typical epilogue vectorized loop with runtime checks. As; illustrated the control flow is structured in a way that avoids duplicating the; runtime pointer checks and optimizes the path length for loops that have very; small trip counts. .. image:: epilogue-vectorization-cfg.png. Performance; -----------. This section shows the execution time of Clang on a simple benchmark:; `gcc-loops <https://github.com/llvm/llvm-test-suite/tree/main/SingleSource/UnitTests/Vectorizer>`_.; This benchmarks is a collection of loops from the GCC autovectorization; `page <http://gcc.gnu.org/projects/tree-ssa/vectorization.html>`_ by Dorit Nuzman. The chart below compares GCC-4.7, ICC-13, and Clang-SVN with and without loop vectorization at -O3, tuned for ""corei7-avx"", running on a Sandybridge iMac.; The Y-axis shows the time in msec. Lower is better. The last column shows the geomean of all the kernels. .. image:: gcc-loops.png. And Linpack-pc with the same configuration. Result is Mflops, higher is better. .. image:: linpack-pc.png. Ongoing Development Directions; ------------------------------. .. toctree::; :hidden:. VectorizationPlan. :doc:`VectorizationPlan`; Modeling the process and upgrading the infrastructure of LLVM's Loop Vectorizer. .. _slp-vectorizer:. The SLP Vectorizer; ==================. Details; -------. The goal of SLP vectorization (a.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:12336,simpl,simple,12336,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['simpl'],['simple']
Usability,"scope: Kaleidoscope Introduction and the Lexer; =====================================================. .. contents::; :local:. The Kaleidoscope Language; =========================. This tutorial is illustrated with a toy language called; ""`Kaleidoscope <http://en.wikipedia.org/wiki/Kaleidoscope>`_"" (derived; from ""meaning beautiful, form, and view""). Kaleidoscope is a procedural; language that allows you to define functions, use conditionals, math,; etc. Over the course of the tutorial, we'll extend Kaleidoscope to; support the if/then/else construct, a for loop, user defined operators,; JIT compilation with a simple command line interface, debug info, etc. We want to keep things simple, so the only datatype in Kaleidoscope; is a 64-bit floating point type (aka 'double' in C parlance). As such,; all values are implicitly double precision and the language doesn't; require type declarations. This gives the language a very nice and; simple syntax. For example, the following simple example computes; `Fibonacci numbers: <http://en.wikipedia.org/wiki/Fibonacci_number>`_. ::. # Compute the x'th fibonacci number.; def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2). # This expression will compute the 40th number.; fib(40). We also allow Kaleidoscope to call into standard library functions - the; LLVM JIT makes this really easy. This means that you can use the; 'extern' keyword to define a function before you use it (this is also; useful for mutually recursive functions). For example:. ::. extern sin(arg);; extern cos(arg);; extern atan2(arg1 arg2);. atan2(sin(.4), cos(42)). A more interesting example is included in Chapter 6 where we write a; little Kaleidoscope application that `displays a Mandelbrot; Set <LangImpl06.html#kicking-the-tires>`_ at various levels of magnification. Let's dive into the implementation of this language!. The Lexer; =========. When it comes to implementing a language, the first thing needed is the; ability to process a text file and recognize wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst:1048,simpl,simple,1048,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,1,['simpl'],['simple']
Usability,"se errors can occur, the parser needs a way to indicate that; they happened: in our parser, we return null on an error. 2) Another interesting aspect of this function is that it uses recursion; by calling ``ParseExpression`` (we will soon see that; ``ParseExpression`` can call ``ParseParenExpr``). This is powerful; because it allows us to handle recursive grammars, and keeps each; production very simple. Note that parentheses do not cause construction; of AST nodes themselves. While we could do it this way, the most; important role of parentheses are to guide the parser and provide; grouping. Once the parser constructs the AST, parentheses are not; needed. The next simple production is for handling variable references and; function calls:. .. code-block:: c++. /// identifierexpr; /// ::= identifier; /// ::= identifier '(' expression* ')'; static std::unique_ptr<ExprAST> ParseIdentifierExpr() {; std::string IdName = IdentifierStr;. getNextToken(); // eat identifier. if (CurTok != '(') // Simple variable ref.; return std::make_unique<VariableExprAST>(IdName);. // Call.; getNextToken(); // eat (; std::vector<std::unique_ptr<ExprAST>> Args;; if (CurTok != ')') {; while (true) {; if (auto Arg = ParseExpression()); Args.push_back(std::move(Arg));; else; return nullptr;. if (CurTok == ')'); break;. if (CurTok != ','); return LogError(""Expected ')' or ',' in argument list"");; getNextToken();; }; }. // Eat the ')'.; getNextToken();. return std::make_unique<CallExprAST>(IdName, std::move(Args));; }. This routine follows the same style as the other routines. (It expects; to be called if the current token is a ``tok_identifier`` token). It; also has recursion and error handling. One interesting aspect of this is; that it uses *look-ahead* to determine if the current identifier is a; stand alone variable reference or if it is a function call expression.; It handles this by checking to see if the token after the identifier is; a '(' token, constructing either a ``VariableExprAST``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:9841,Simpl,Simple,9841,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['Simpl'],['Simple']
Usability,"se it gives comprehensive information; on every decision made by the analyzer across all analysis paths.; There are more debug checkers available. To see all available debug checkers:. $ clang -cc1 -analyzer-checker-help | grep ""debug"". Debug Prints and Tricks; To view ""half-baked"" ExplodedGraph while debugging, jump to a frame; that has clang::ento::ExprEngine object and execute:. (gdb) p ViewGraph(0). To see the ProgramState while debugging use the following command. (gdb) p State->dump(). To see clang::Expr while debugging use the following command. If you; pass in a SourceManager object, it will also dump the corresponding line in the; source code. (gdb) p E->dump(). To dump AST of a method that the current ExplodedNode belongs; to:. (gdb) p C.getPredecessor()->getCodeDecl().getBody()->dump(). Making Your Checker Better. User facing documentation is important for adoption! Make sure the checker list is updated; at the homepage of the analyzer. Also ensure the description is clear to; non-analyzer-developers in Checkers.td.; Warning and note messages should be clear and easy to understand, even if a bit long. Messages should start with a capital letter (unlike Clang warnings!) and should not; end with ..; Articles are usually omitted, eg. Dereference of a null pointer ->; Dereference of null pointer.; Introduce BugReporterVisitors to emit additional notes that explain the warning; to the user better. There are some existing visitors that might be useful for your check,; e.g. trackNullOrUndefValue. For example, SimpleStreamChecker should highlight; the event of opening the file when reporting a file descriptor leak. If the check tracks anything in the program state, it needs to implement the; checkDeadSymbolscallback to clean the state up.; The check should conservatively assume that the program is correct when a tracked symbol; is passed to a function that is unknown to the analyzer.; checkPointerEscape callback could help you handle that case.; Use safe and conv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:23066,clear,clear,23066,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['clear'],['clear']
Usability,"se of the; use of the ``%free`` anchor intrinsic. In practice, they almost certainly have to be non-converged dynamic; instances. Consider that if an implementation strictly follows the order of; instructions given in the program, the executions of the threads can be; ""aligned"" as follows:. .. code-block:: text. Thread 1: A B C D F B D E F G; Thread 2: A B D E F B C D F G. So then ``@op.2(1)`` physically executes later than ``@op.2(2)`` and there; can be no communication between the threads, which means they execute; non-converged dynamic instances. That said, it is conceivable that there aren't actually any data or other; dependencies that would enforce this execution order. In that case, a highly; out-of-order implementation could potentially allow communication. That's; why the rules defined in this document are silent about whether; ``@op.2(1) == @op.2(2)`` or not. This type of convergence control seems relatively unlikely to appear in real; programs. Its possibility is simply a logical consequence of the model. An equivalent issue arises if the convergent operations are replaced by nested; loops with loop heart intrinsics that directly refer to ``%anchor``, hence; the variants of the static rules about cycles that apply to them:. .. code-block:: llvm. ; WARNING: Example of incorrect convergence control!. %anchor = call token @llvm.experimental.convergence.anchor(); for (;;) {; if (condition1) {; for (;;) {; %loop1 = call token @llvm.experimental.convergence.loop() [ ""convergencectrl""(token %anchor) ]; }; }; if (condition2) {; for (;;) {; %loop2 = call token @llvm.experimental.convergence.loop() [ ""convergencectrl""(token %anchor) ]; }; }; }. There is a cycle (closed walk in the CFG) that goes through both loop heart; intrinsics using ``%anchor`` but not through the definition of ``%anchor``,; so this code is invalid. Examples for the Correctness of Program Transforms; ==================================================. (This section is informative.). As implied ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:46749,simpl,simply,46749,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['simpl'],['simply']
Usability,"se(implicitCastExpr(; hasSourceExpression(declRefExpr())))); matches i[1] with the declRefExpr() matching i. Matcher<ArraySubscriptExpr>hasIndexMatcher<Expr> InnerMatcher; Matches the index expression of an array subscript expression. Given; int i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasIndex(integerLiteral())); matches i[1] with the integerLiteral() matching 1. Matcher<ArraySubscriptExpr>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<ArraySubscriptExpr>hasRHSMatcher<Expr> InnerMatcher; Matches the right hand side of binary operator expressions. Example matches b (matcher = binaryOperator(hasRHS())); a || b. Matcher<ArrayType>hasElementTypeMatcher<Type>; Matches arrays and C99 complex types that have a specific element; type. Given; struct A {};; A a[7];; int b[7];; arrayType(hasElementType(builtinType())); matches ""int b[7]"". Usable as: Matcher<ArrayType>, Matcher<ComplexType>. Matcher<AtomicType>hasValueTypeMatcher<Type>; Matches atomic types with a specific value type. Given; _Atomic(int) i;; _Atomic(float) f;; atomicType(hasValueType(isInteger())); matches ""_Atomic(int) i"". Usable as: Matcher<AtomicType>. Matcher<AutoType>hasDeducedTypeMatcher<Type>; Matches AutoType nodes where the deduced type is a specific type. Note: There is no TypeLoc for the deduced type and thus no; getDeducedLoc() matcher. Given; auto a = 1;; auto b = 2.0;; autoType(hasDeducedType(isInteger())); matches ""auto a"". Usable as: Matcher<AutoType>. Matcher<BaseUsingDecl>hasAnyUsingShadowDeclMatcher<UsingShadowDecl> InnerMatcher; Matches any using shadow declaration. Given; namespace X { void b(); }; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasName(""b"")))); matches using X::b ; Matcher<BinaryOperator>hasEitherOperandMatcher<Expr> InnerMatcher; Matches if either the left hand side or the right hand side of a; binary operator or fold expression matches. Match",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:140078,Usab,Usable,140078,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"se);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54916,guid,guide,54916,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['guid'],['guide']
Usability,"se:** If your class includes (or should; include) the `analyticalIntegral()` function, then a simple; `buildCallToAnalyticIntegral()` function needs to be created to help call the; `analyticalIntegral()` function. # Example for adding Code Generation support to RooFit classes. Let us take the `RooPoisson.cxx` class as an example. > [roofit/roofit/src/RooPoisson.cxx](https://github.com/root-project/root/blob/master/roofit/roofit/src/RooPoisson.cxx). First step is to locate the `RooPoisson::evaluate()` function. Most RooFit; classes implement this function. > RooFit internally calls the `evaluate()` function to evaluate a single node; in a compute graph. ## Before Code Generation Support. Following is a code snippet from `RooPoisson` *before* it had AD support. ``` {.cpp}; double RooPoisson::evaluate() const; {; double k = _noRounding ? x : floor(x);; if(_protectNegative && mean<0) {; RooNaNPacker np;; np.setPayload(-mean);; return np._payload;; }; return TMath::Poisson(k,mean);; }; ```; `TMath::Poisson()` is a simple mathematical function. For this example, the; relevant part is `return TMath::Poisson(k,mean);`. This needs to be extracted; into the `MathFuncs.h` file and the fully qualified name of the function; referencing that file should be used here instead. ## After Code Generation Support. Following is a code snippet from `RooPoisson` *after* it has AD support. ### Step 1. Refactor the `RooPoisson::evaluate()` Function. ``` {.cpp}; /// Implementation in terms of the TMath::Poisson() function. double RooPoisson::evaluate() const; {; double k = _noRounding ? x : floor(x);; if(_protectNegative && mean<0) {; RooNaNPacker np;; np.setPayload(-mean);; return np._payload;; }; return RooFit::Detail::MathFuncs::poisson(k, mean);; }; ```. Note that the `evaluate()` function was refactored in such a way that the; mathematical parts were moved to an inline function in a separate header file; named `MathFuncs`, so that Clad could see and differentiate that function.; The rest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:10073,simpl,simple,10073,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simple']
Usability,"sections. Semantics:; """"""""""""""""""""; The purpose of this intrinsic is to allow frontends to mark the cleanup and; other code that is only relevant during the initial invocation of the coroutine; and should not be present in resume and destroy parts. In returned-continuation lowering, ``llvm.coro.end`` fully destroys the; coroutine frame. If the second argument is `false`, it also returns from; the coroutine with a null continuation pointer, and the next instruction; will be unreachable. If the second argument is `true`, it falls through; so that the following logic can resume unwinding. In a yield-once; coroutine, reaching a non-unwind ``llvm.coro.end`` without having first; reached a ``llvm.coro.suspend.retcon`` has undefined behavior. The remainder of this section describes the behavior under switched-resume; lowering. This intrinsic is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePart, label %eh.resume, label %cleanup.cont. cleanup.cont:; ; rest of the cleanup. eh.resume:; %exn = load ptr, ptr %exn.slot, align 8; %sel = load i32, ptr %ehselector.slot, align 4; %lpad.val = insertvalue { ptr, i32 } undef, ptr %exn, 0; %lpad.val29 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1; resume { ptr, i32 } %lpad.val29. The `CoroSpit` pass replaces `coro.end` with ``True`` in the resume functions,; thus leading to immediate unwind to the caller",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:44297,resume,resume,44297,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"sed to the BugReport constructor; without additional modification. This ExplodedNode will be the one; returned by the most recent call to CheckerContext::addTransition.; If no transition has been performed during the current callback, the checker should call CheckerContext::addTransition(); and use the returned node for bug reporting. If analysis can not continue, then the current state should be transitioned; into a so-called sink node, a node from which no further analysis will be; performed. This is done by calling the ; CheckerContext::generateSink function; this function is the same as the; addTransition function, but marks the state as a sink node. Like; addTransition, this returns an ExplodedNode with the updated; state, which can then be passed to the BugReport constructor. After a BugReport is created, it should be passed to the analyzer core; by calling CheckerContext::emitReport. AST Visitors; Some checks might not require path-sensitivity to be effective. Simple AST walk; might be sufficient. If that is the case, consider implementing a Clang; compiler warning. On the other hand, a check might not be acceptable as a compiler; warning; for example, because of a relatively high false positive rate. In this; situation, AST callbacks checkASTDecl and; checkASTCodeBody are your best friends. Testing; Every patch should be well tested with Clang regression tests. The checker tests; live in clang/test/Analysis folder. To run all of the analyzer tests,; execute the following from the clang build directory:; ; $ bin/llvm-lit -sv ../llvm/tools/clang/test/Analysis; ; Useful Commands/Debugging Hints; Attaching the Debugger; When your command contains the -cc1 flag, you can attach the; debugger to it directly:. $ gdb --args clang -cc1 -analyze -analyzer-checker=core test.c; $ lldb -- clang -cc1 -analyze -analyzer-checker=core test.c. Otherwise, if your command line contains --analyze,; the actual clang instance would be run in a separate process. In; order to debug i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:18210,Simpl,Simple,18210,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['Simpl'],['Simple']
Usability,"seful in conjunction with; the ``list`` type; for example, to constrain the elements of the list to a; common base class (e.g., a ``list<Register>`` can only contain definitions; derived from the ``Register`` class).; The :token:`ClassID` must name a class that has been previously; declared or defined. Values and Expressions; ======================. There are many contexts in TableGen statements where a value is required. A; common example is in the definition of a record, where each field is; specified by a name and an optional value. TableGen allows for a reasonable; number of different forms when building up value expressions. These forms; allow the TableGen file to be written in a syntax that is natural for the; application. Note that all of the values have rules for converting them from one type to; another. For example, these rules allow you to assign a value like ``7``; to an entity of type ``bits<4>``. .. productionlist::; Value: `SimpleValue` `ValueSuffix`*; :| `Value` ""#"" [`Value`]; ValueSuffix: ""{"" `RangeList` ""}""; :| ""["" `SliceElements` ""]""; :| ""."" `TokIdentifier`; RangeList: `RangePiece` ("","" `RangePiece`)*; RangePiece: `TokInteger`; :| `TokInteger` ""..."" `TokInteger`; :| `TokInteger` ""-"" `TokInteger`; :| `TokInteger` `TokInteger`; SliceElements: (`SliceElement` "","")* `SliceElement` "",""?; SliceElement: `Value`; :| `Value` ""..."" `Value`; :| `Value` ""-"" `Value`; :| `Value` `TokInteger`. .. warning::; The peculiar last form of :token:`RangePiece` and :token:`SliceElement` is; due to the fact that the ""``-``"" is included in the :token:`TokInteger`,; hence ``1-5`` gets lexed as two consecutive tokens, with values ``1`` and; ``-5``, instead of ""1"", ""-"", and ""5"".; The use of hyphen as the range punctuation is deprecated. Simple values; -------------. The :token:`SimpleValue` has a number of forms. .. productionlist::; SimpleValue: `TokInteger` | `TokString`+ | `TokCode`. A value can be an integer literal, a string literal, or a code literal.; Multiple adjacent ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:13292,Simpl,SimpleValue,13292,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['Simpl'],['SimpleValue']
Usability,"sembly into `D,E` and `F` will actually position only `A` and; `B `directly into these volumes, taking into account their combined; transformations `A/B` to `C` and `C` to `D/E/F`. This looks much nicer,; is it? In fact, it is and it is not. Of course, we managed to get rid of; the ‘unnecessary' volume `C` in our geometry, but we end-up with a more; flat structure for `D,E` and `F` (more daughters inside). This can get; much worse when extensively used, as in the case: assemblies of; assemblies. For deciding what to choose between using virtual containers or; assemblies for a specific case, one can use for both cases, after the; geometry was closed:. ``` {.cpp}; gGeoManager->SetTopVolume(ptr_D);; gGeoManager->Test();; gGeoManager->RestoreMasterVolume();; ```. The `ptr_D` is a pointer to volume `D` containing the interesting; structure. The test will provide the timing for classifying 1 million; random points inside `D`. #### Examples of Volume Positioning. Now let us make a simple volume representing a copper wire. We suppose; that a medium is already created (see **`TGeoMedium`** class on how to; create media). We will create a `TUBE` shape for our wire, having `Rmin=0cm`,; `Rmax=0.01cm` and a half-length `dZ=1cm`:. ``` {.cpp}; TGeoTube *tube = new TGeoTube(""wire_tube"",0,0.01,1);; ```. One may omit the name for the shape `wire_tube,` if no retrieving by; name is further needed during geometry building. Different volumes; having different names and materials can share the same shape. Now let's make the volume for our wire:. ``` {.cpp}; TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"",tube,; ptrCOPPER); //(*); ```. **(\*)** Do not bother to delete the media, shapes or volumes that you; have created since all will be automatically cleaned on exit by the; manager class. If we would have taken a look inside `TGeoManager::MakeTube()` method,; we would have been able to create our wire with a single line:. ``` {.cpp}; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"",pt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:72978,simpl,simple,72978,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"sequence of convergent; operations where the code does not care about the exact set of threads with; which it is executed, but only that the set of threads is the same for all the; operations within the sequence. (If a subset of the convergent operations in the; sequence have additional, non-uniform control dependencies, then this is not; possible. However, the code may still require that the sets of threads are; logically consistent with the conditions of those control dependencies.) In this; case, :ref:`llvm.experimental.convergence.anchor; <llvm.experimental.convergence.anchor>` can be used to express the desired; semantics. The following example function could be part of a hypothetical ""append buffer""; implementation, where threads conditionally write fixed-sized records; contiguously into a global buffer. The function ``@reserveSpaceInBuffer``; returns the index into the buffer at which the calling thread should store its; data. This could be achieved by using a simple atomic operation in every thread to; bump an allocation counter. However, the following implementation can be more performant on some hardware,; because it uses only a single atomic operation for an entire group of threads.; To do this, it first determines the total size of the group, which will be the; operand to the atomic operation, and then later broadcasts the result of the; atomic operation to all threads of the group, so that each thread can compute; its individual position in the buffer:. .. code-block:: llvm. define i32 @reserveSpaceInBuffer() { ; NOTE: _not_ a convergent function!; entry:; %anchor = call token @llvm.experimental.convergence.anchor(). %ballot = call i64 @subgroupBallot(i1 true) [ ""convergencectrl""(token %anchor) ]; %numThreads.p = call i64 @llvm.ctpop.i64(i64 %ballot); %numThreads = trunc i64 %numThreads.p to i32. %absoluteThreadIdx = call i32 @getSubgroupLocalInvocationId(); %absoluteThreadIdx.ext = zext i32 %absoluteThreadIdx to i64; %mask.p = shl i64 1, %absoluteThrea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:12445,simpl,simple,12445,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['simpl'],['simple']
Usability,"sers are the portion of the CommandLine library; that turns string input from the user into a particular parsed data type,; validating the input in the process. There are two ways to use a new parser:. #. Specialize the `cl::parser`_ template for your custom data type. This approach has the advantage that users of your custom data type will; automatically use your custom parser whenever they define an option with a; value type of your data type. The disadvantage of this approach is that it; doesn't work if your fundamental data type is something that is already; supported. #. Write an independent class, using it explicitly from options that need it. This approach works well in situations where you would line to parse an; option using special syntax for a not-very-special data-type. The drawback; of this approach is that users of your parser have to be aware that they are; using your parser instead of the builtin ones. To guide the discussion, we will discuss a custom parser that accepts file; sizes, specified with an optional unit after the numeric size. For example, we; would like to parse ""102kb"", ""41M"", ""1G"" into the appropriate integer value. In; this case, the underlying data type we want to parse into is '``unsigned``'. We; choose approach #2 above because we don't want to make this the default for all; ``unsigned`` options. To start out, we declare our new ``FileSizeParser`` class:. .. code-block:: c++. struct FileSizeParser : public cl::parser<unsigned> {; // parse - Return true on error.; bool parse(cl::Option &O, StringRef ArgName, const std::string &ArgValue,; unsigned &Val);; };. Our new class inherits from the ``cl::parser`` template class to fill in; the default, boiler plate code for us. We give it the data type that we parse; into, the last argument to the ``parse`` method, so that clients of our custom; parser know what object type to pass in to the parse method. (Here we declare; that we parse into '``unsigned``' variables.). For most purposes, the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:62892,guid,guide,62892,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['guid'],['guide']
Usability,"ses is all that is necessary here.; The reader should be able to understand how to use interfaces without reading; the code itself. Good things to talk about here are what happens when something unexpected; happens, for instance, does the method return null?. Comment Formatting; ^^^^^^^^^^^^^^^^^^. In general, prefer C++-style comments (``//`` for normal comments, ``///`` for; ``doxygen`` documentation comments). There are a few cases when it is; useful to use C-style (``/* */``) comments however:. #. When writing C code to be compatible with C89. #. When writing a header file that may be ``#include``\d by a C source file. #. When writing a source file that is used by a tool that only accepts C-style; comments. #. When documenting the significance of constants used as actual parameters in; a call. This is most helpful for ``bool`` parameters, or passing ``0`` or; ``nullptr``. The comment should contain the parameter name, which ought to be; meaningful. For example, it's not clear what the parameter means in this call:. .. code-block:: c++. Object.emitName(nullptr);. An in-line C-style comment makes the intent obvious:. .. code-block:: c++. Object.emitName(/*Prefix=*/nullptr);. Commenting out large blocks of code is discouraged, but if you really have to do; this (for documentation purposes or as a suggestion for debug printing), use; ``#if 0`` and ``#endif``. These nest properly and are better behaved in general; than C style comments. Doxygen Use in Documentation Comments; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use the ``\file`` command to turn the standard file header into a file-level; comment. Include descriptive paragraphs for all public interfaces (public classes,; member and non-member functions). Avoid restating the information that can; be inferred from the API name. The first sentence (or a paragraph beginning; with ``\brief``) is used as an abstract. Try to use a single sentence as the; ``\brief`` adds visual clutter. Put detailed discussion into separate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:10761,clear,clear,10761,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['clear'],['clear']
Usability,"ses; ================================. At the high-level, LLVM code is translated to a machine specific representation; formed out of :raw-html:`<tt>` `MachineFunction`_ :raw-html:`</tt>`,; :raw-html:`<tt>` `MachineBasicBlock`_ :raw-html:`</tt>`, and :raw-html:`<tt>`; `MachineInstr`_ :raw-html:`</tt>` instances (defined in; ``include/llvm/CodeGen``). This representation is completely target agnostic,; representing instructions in their most abstract form: an opcode and a series of; operands. This representation is designed to support both an SSA representation; for machine code, as well as a register allocated, non-SSA form. .. _MachineInstr:. The ``MachineInstr`` class; --------------------------. Target machine instructions are represented as instances of the ``MachineInstr``; class. This class is an extremely abstract way of representing machine; instructions. In particular, it only keeps track of an opcode number and a set; of operands. The opcode number is a simple unsigned integer that only has meaning to a; specific backend. All of the instructions for a target should be defined in the; ``*InstrInfo.td`` file for the target. The opcode enum values are auto-generated; from this description. The ``MachineInstr`` class does not have any information; about how to interpret the instruction (i.e., what the semantics of the; instruction are); for that you must refer to the :raw-html:`<tt>`; `TargetInstrInfo`_ :raw-html:`</tt>` class. The operands of a machine instruction can be of several different types: a; register reference, a constant integer, a basic block reference, etc. In; addition, a machine operand should be marked as a def or a use of the value; (though only registers are allowed to be defs). By convention, the LLVM code generator orders instruction operands so that all; register definitions come before the register uses, even on architectures that; are normally printed in other orders. For example, the SPARC add instruction:; ""``add %i1, %i2, %i3``"" adds ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:16203,simpl,simple,16203,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"set the format of dashed lines. - `TStyle::SetOptStat`. - `TStyle::SetPalette` to change the colors palette. - `TStyle::SetTitleOffset`. - `TStyle::SetOptDate(Int_t optdate)` to support several date formats.; If `optdate` is non-null, the current date/time will be printed in; the canvas. The position of the date string can be controlled by:; `optdate = 10*format `+` mode`. - `mode = 1` the date is printed in the bottom/left corner. - `mode = 2` date is printed in the bottom/right corner. - `mode = 3` date is printed in the top/right corner. - `format = 0` (default) date format is like: ""Wed Sep 25 17:10:35; 2002"". - `format = 1` date format is: ""2002-09-25"". - `format = 2` date format is: ""2002-09-25 17:10:35"". ## 3D Viewers. ROOT provides several viewers capable of displaying 3D content:. - the Pad - simple line drawing using **`TPad`** and associated; projection class **`TView`**;. - GL Viewer - high quality and performance viewer(See ""The GL; Viewer"");. - X3D viewer - simple legacy viewer (See ""The X3D Viewer"");. - GL-in-pad - combination of basic GL viewer in **`TPad`**, with no; hardware acceleration. The X3D and GL viewers are created as external windows, associated with; a pad, and displaying the same content as it. Only these external; viewers are detailed here - for Pad (**`TPad`**, **`TView`** classes); you should refer to ""Graphical Containers: Canvas and Pad"" and the class; definitions. All viewers use a common architecture to publish 3D objects to the; viewer - described in ""Common 3D Viewer Architecture"" below. In most; cases, you will **not** need to use this, working instead with a; package, such as the ""The Geometry Package"", which provides; comprehensive, high level functionality to create and place objects into; complex 3D scenes, and uses the viewer architecture internally to show; the result in your chosen viewer. ### Invoking a 3D viewer. A 3D viewer can be created in a script by passing the appropriate option; to `Draw() `when attaching the dra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:105316,simpl,simple,105316,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,set(LLVM_LINK_COMPONENTS; AllTargetsAsmParsers; AllTargetsCodeGens; AllTargetsDescs; AllTargetsInfos; Analysis; BitReader; BitWriter; CodeGen; CodeGenTypes; Core; IPO; IRReader; MC; MIRParser; Passes; Support; Target; TargetParser; TransformUtils; ). add_llvm_tool(llvm-reduce; DeltaManager.cpp; ReducerWorkItem.cpp; TestRunner.cpp; deltas/Delta.cpp; deltas/Utils.cpp; deltas/ReduceAliases.cpp; deltas/ReduceArguments.cpp; deltas/ReduceAttributes.cpp; deltas/ReduceBasicBlocks.cpp; deltas/ReduceDIMetadata.cpp; deltas/ReduceDPValues.cpp; deltas/ReduceFunctionBodies.cpp; deltas/ReduceFunctions.cpp; deltas/ReduceGlobalObjects.cpp; deltas/ReduceGlobalValues.cpp; deltas/ReduceGlobalVarInitializers.cpp; deltas/ReduceGlobalVars.cpp; deltas/ReduceInstructions.cpp; deltas/ReduceInstructionFlags.cpp; deltas/ReduceInvokes.cpp; deltas/ReduceMetadata.cpp; deltas/ReduceModuleData.cpp; deltas/ReduceMemoryOperations.cpp; deltas/ReduceOperandBundles.cpp; deltas/ReduceOpcodes.cpp; deltas/ReduceSpecialGlobals.cpp; deltas/ReduceOperands.cpp; deltas/ReduceOperandsSkip.cpp; deltas/ReduceOperandsToArgs.cpp; deltas/ReduceInstructionsMIR.cpp; deltas/ReduceInstructionFlagsMIR.cpp; deltas/ReduceIRReferences.cpp; deltas/ReduceVirtualRegisters.cpp; deltas/ReduceRegisterMasks.cpp; deltas/ReduceRegisterDefs.cpp; deltas/ReduceRegisterUses.cpp; deltas/ReduceUsingSimplifyCFG.cpp; deltas/RunIRPasses.cpp; deltas/SimplifyInstructions.cpp; deltas/StripDebugInfo.cpp; llvm-reduce.cpp. DEPENDS; intrinsics_gen; ); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/CMakeLists.txt:1395,Simpl,SimplifyInstructions,1395,interpreter/llvm-project/llvm/tools/llvm-reduce/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/CMakeLists.txt,1,['Simpl'],['SimplifyInstructions']
Usability,set(LLVM_LINK_COMPONENTS; FrontendOpenMP; Support; ). add_clang_library(clangStaticAnalyzerCore; APSIntType.cpp; AnalysisManager.cpp; AnalyzerOptions.cpp; BasicValueFactory.cpp; BlockCounter.cpp; BugReporter.cpp; BugReporterVisitors.cpp; BugSuppression.cpp; CallDescription.cpp; CallEvent.cpp; Checker.cpp; CheckerContext.cpp; CheckerHelpers.cpp; CheckerManager.cpp; CheckerRegistryData.cpp; CommonBugCategories.cpp; ConstraintManager.cpp; CoreEngine.cpp; DynamicExtent.cpp; DynamicType.cpp; Environment.cpp; ExplodedGraph.cpp; ExprEngine.cpp; ExprEngineC.cpp; ExprEngineCXX.cpp; ExprEngineCallAndReturn.cpp; ExprEngineObjC.cpp; FunctionSummary.cpp; HTMLDiagnostics.cpp; LoopUnrolling.cpp; LoopWidening.cpp; MemRegion.cpp; PlistDiagnostics.cpp; ProgramState.cpp; RangeConstraintManager.cpp; RangedConstraintManager.cpp; RegionStore.cpp; SarifDiagnostics.cpp; SimpleConstraintManager.cpp; SimpleSValBuilder.cpp; SMTConstraintManager.cpp; Store.cpp; SValBuilder.cpp; SVals.cpp; SymbolManager.cpp; TextDiagnostics.cpp; WorkList.cpp. LINK_LIBS; clangAST; clangASTMatchers; clangAnalysis; clangBasic; clangCrossTU; clangFrontend; clangLex; clangRewrite; clangToolingCore. DEPENDS; omp_gen; ). ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CMakeLists.txt:859,Simpl,SimpleConstraintManager,859,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CMakeLists.txt,2,['Simpl'],"['SimpleConstraintManager', 'SimpleSValBuilder']"
Usability,"sg = !strconcat(""Hello "", _msg);; }. def HelloWorld: Hello<""world!""> {}; ```; ```; ------------- Classes -----------------; class Hello<string Hello:_msg = ?> {; string msg = !strconcat(""Hello "", Hello:_msg);; }; ------------- Defs -----------------; def HelloWorld { // Hello; string msg = ""Hello world!"";; }; ```; [Try this example on Compiler Explorer.](https://godbolt.org/z/13xo1P5oz). The internalized records are passed on to various backends, which extract; information from a subset of the records and generate one or more output files. These output files are typically .inc files for C++, but may be any type of file; that the backend developer needs. Resources for learning the language:; * [TableGen Overview](https://llvm.org/docs/TableGen/index.html); * [Programmer's reference guide](https://llvm.org/docs/TableGen/ProgRef.html); * [Tutorial](jupyter/tablegen_tutorial_part_1.ipynb); * [Tools for Learning LLVM TableGen](https://blog.llvm.org/posts/2023-12-07-tools-for-learning-llvm-tablegen/); * [Lessons in TableGen](https://www.youtube.com/watch?v=45gmF77JFBY) (video),; [slides](https://archive.fosdem.org/2019/schedule/event/llvm_tablegen/attachments/slides/3304/export/events/attachments/llvm_tablegen/slides/3304/tablegen.pdf); * [Improving Your TableGen Descriptions](https://www.youtube.com/watch?v=dIEVUlsiktQ); (video), [slides](https://llvm.org/devmtg/2019-10/slides/Absar-ImprovingYourTableGenDescription.pdf). Writing TableGen backends:; * [TableGen Backend Developer's Guide](https://llvm.org/docs/TableGen/BackGuide.html); * [How to write a TableGen backend](https://www.youtube.com/watch?v=UP-LBRbvI_U); (video), [slides](https://llvm.org/devmtg/2021-11/slides/2021-how-to-write-a-tablegen-backend.pdf), also available as a; 	[notebook](jupyter/sql_query_backend.ipynb). TableGen in MLIR:; * [Operation Definition Specification](https://mlir.llvm.org/docs/DefiningDialects/Operations/); * [Defining Dialect Attributes and Types](https://mlir.llvm.org/docs/DefiningDial",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/README.md:1382,learn,learning-llvm-tablegen,1382,interpreter/llvm-project/llvm/utils/TableGen/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/README.md,1,['learn'],['learning-llvm-tablegen']
Usability,"shContext object, via the virtual; RooAbsArg::translate() function that implements the translation of a; given RooFit class to minimal C++ code. This is an example of the visitor; pattern. 2. The generated code is processed by a RooFuncWrapper object, which takes care; of just-in-time compiling it with the ROOT interpreter, generating the; gradient code with Clad, and compiling that as well. 3. Since the RooFuncWrapper is implementing a RooAbsArg itself, it can now be; used as a drop-in replacement for the RooAbsArg that was the top node of the; original computation graph, with the added benefit that it can be queried for; the gradient. In summary, the important ingredient to enable AD in RooFit is to support the; **C++ code generation** from RooFit classes. # Steps to enable Code Generation in RooFit classes. There are multiple code generation approaches that can be followed to add Code; Generation support in RooFit classes. **Approach 1:** For very simple cases like `RooRatio`, it may be preferable to; write the entire code in a single string. **Approach 2:** Another approach could be to extract free functions in a; separate header file.; Since Clad prefers the code for models to be within a single translation unit,; in many classes, this has been implemented by moving the computational; aspects of the RooFit class; to free functions in a single header file named [MathFuncs] (and/or; [MathFuncs], where relevant). This approach enables easier debugging; (e.g., you can standalone-compile the generated code with just a few header; files copied outside ROOT). *Refactoring* It is important to refactor the code such that:. - the footprint of the generated code is minimized by referring to existing; functions with the definition known by interpreter (i.e., they are in public; header files). - to reuse common code, both in the generated code, and in the existing; RooAbsReal::evaluate() method (meaning that the refactoring of `evaluate()` is; optional, but it is recommende",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:5456,simpl,simple,5456,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simple']
Usability,"shows the assigned keyboard mnemonic for its choice. A button that; prompts more information for users has the label generally followed by; ellipsis (...). ![](pictures/0300020D.png). As we saw the hot strings ""&Draw"" and ""&Exit"" define the text labels; ""Draw"" and ""Exit"" and keyboard mnemonics `Alt+D`, `Alt+E` for their; selection. The letter D and E appear underlined on the screen. All text; buttons should have a unique shortcut key with the exception of OK and; Cancel. These buttons are usually placed within a window to provide fast access; to frequently used or critical commands. They help in situations where a; command is not available through the menu bar. You already know that a; command string can be passed in the text button via the constructor:. ``` {.cpp}; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; ```. A button label can be changed by `SetText(new_label).` There are; important guidelines to be followed about a button label. The text has; to provide a meaningful description of the performed action. The; single-word label should be used whenever possible, only two-three words; for clarity, if necessary. Do not number labels. Always follow all; platform presentation and usage guidelines for standard button; functions. Let's remember a few standard names and definitions of well; known buttons:. ***`OK`*** - any changed information in a window is accepted and the; window is closed;. ***`Cancel`*** - closes window without implementing submitted changes;. ***`Reset `***- resets defaults and cancels any changed information that; has not be submitted;. ***`Apply`*** - any changed information is accepted and again displayed; in the window that remains open;. ***`Close`*** - closes the window;. ***`Help`*** - opens online Help. Below are examples of text buttons. Note the two placement methods. The; first example should be used when there are one to three command; buttons; the sec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:56379,guid,guidelines,56379,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['guid'],['guidelines']
Usability,"sible different states of; the modeller corresponds to the number of different objects/paths in; the geometry. This has nothing to do with the number of nodes, since; the same node can be found on different branches. In other words,; the number of states corresponds to the number of nodes in the; `expanded geometry tree`. Since unfortunately this expansion from; logical to physical hierarchy cannot be stored on regular basis due; to the large size of the latter, one cannot directly assign state; numbers. If the size of the expansion proves however to be small; enough (less than about 50 million objects), a parallel structure; storing these state indices is built and stored in memory. In such; case each state automatically gets an index that can be retrieved; after any state initialization. These indices can prove to be quite; useful for being able to keep track of the navigation history and; force certain states. Let's illustrate how this works with a simple; example:; - Suppose we have a simple geometry with a volume B positioned twice; inside a container A. Then A is positioned twice in a top container; T. The complete list of logical nodes is: `T_1`, `A_1`, `A_2`,; `B_1`, `B_2`. On the other hand we will have more states than; logical nodes:; - `/T_1`- 1 state at level = 0; - `/T_1/A_1,/T_1/A_2`- 2 states at level = 1; - `/T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2` - 4 states at; level = 2; - All these states will get automatic numbers, starting with 0; corresponding to the top-level state and ending with an integer; corresponding to Ntotal\_states-1. The mapping from a given logical; node to a state number is generally not possible, as for the node; B\_1 that appears as current node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ``` {.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:110150,simpl,simple,110150,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,2,['simpl'],['simple']
Usability,"sible different states of; the modeller corresponds to the number of different objects/paths in; the geometry. This has nothing to do with the number of nodes, since; the same node can be found on different branches. In other words,; the number of states corresponds to the number of nodes in the; `expanded geometry tree`. Since unfortunately this expansion from; logical to physical hierarchy cannot be stored on regular basis due; to the large size of the latter, one cannot directly assign state; numbers. If the size of the expansion proves however to be small; enough (less than about 50 million objects), a parallel structure; storing these state indices is built and stored in memory. In such; case each state automatically gets an index that can be retrieved; after any state initialization. These indices can prove to be quite; useful for being able to keep track of the navigation history and; force certain states. Let's illustrate how this works with a simple; example:; - Suppose we have a simple geometry with a volume B positioned twice; inside a container A. Then A is positioned twice in a top container; T. The complete list of logical nodes is: `T_1`, `A_1`, `A_2`,; `B_1`, `B_2`. On the other hand we will have more states than; logical nodes:; - `/T_1`- 1 state at level = 0; - `/T_1/A_1,/T_1/A_2`- 2 states at level = 1; - `/T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2` - 4 states at; level = 2; - All these states will get automatic numbers, starting with 0; corresponding to the top-level state and ending with an integer; corresponding to Ntotal\_states-1. The mapping from a given logical; node to a state number is generally not possible, as for the node; B\_1 that appears as current node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ~~~{.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:70553,simpl,simple,70553,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,2,['simpl'],['simple']
Usability,"side of a loop, so how can such a phi ""close""; the value inside the loop since it uses it outside of it ? First of all,; for phi nodes, as; `mentioned in the LangRef <https://llvm.org/docs/LangRef.html#id311>`_:; ""the use of each incoming value is deemed to occur on the edge from the; corresponding predecessor block to the current block"". Now, an; edge to an exit block is considered outside of the loop because; if we take that edge, it leads us clearly out of the loop. However, an edge doesn't actually contain any IR, so in source code,; we have to choose a convention of whether the use happens in; the current block or in the respective predecessor. For LCSSA's purpose,; we consider the use happens in the latter (so as to consider the; use inside) [#point-of-use-phis]_. The major benefit of LCSSA is that it makes many other loop optimizations; simpler. First of all, a simple observation is that if one needs to see all; the outside users, they can just iterate over all the (loop closing); PHI nodes in the exit blocks (the alternative would be to; scan the def-use chain [#def-use-chain]_ of all instructions in the loop). Then, consider for example; :ref:`simple-loop-unswitch <passes-simple-loop-unswitch>` ing the loop above.; Because it is in LCSSA form, we know that any value defined inside of; the loop will be used either only inside the loop or in a loop closing; PHI node. In this case, the only loop closing PHI node is X4.; This means that we can just copy the loop and change the X4; accordingly, like so:. .. code-block:: C. c = ...;; if (c) {; for (...) {; if (true); X1 = ...; else; X2 = ...; X3 = phi(X1, X2);; }; } else {; for (...) {; if (false); X1' = ...; else; X2' = ...; X3' = phi(X1', X2');; }; }; X4 = phi(X3, X3'). Now, all uses of X4 will get the updated value (in general,; if a loop is in LCSSA form, in any loop transformation,; we only need to update the loop closing PHI nodes for the changes; to take effect). If we did not have Loop Closed SSA form, it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:12962,simpl,simple,12962,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['simpl'],['simple']
Usability,"sing different portions of; LLVM. Even in this situation using *BUILD_SHARED_LIBS* is not supported. If you; want to distribute LLVM as a shared library for use in a tool, the recommended; method is using *LLVM_BUILD_LLVM_DYLIB*, and you can use *LLVM_DYLIB_COMPONENTS*; to configure which LLVM components are part of libLLVM.; Note: *LLVM_BUILD_LLVM_DYLIB* is not available on Windows. Options for Optimizing LLVM; ===========================. There are four main build optimizations that our CMake build system supports.; When performing a bootstrap build it is not beneficial to do anything other than; setting *CMAKE_BUILD_TYPE* to ``Release`` for the stage-1 compiler. This is; because the more intensive optimizations are expensive to perform and the; stage-1 compiler is thrown away. All of the further options described should be; set on the stage-2 compiler either using a CMake cache file, or by prefixing the; option with *BOOTSTRAP_*. The first and simplest to use is the compiler optimization level by setting the; *CMAKE_BUILD_TYPE* option. The main values of interest are ``Release`` or; ``RelWithDebInfo``. By default the ``Release`` option uses the ``-O3``; optimization level, and ``RelWithDebInfo`` uses ``-O2``. If you want to generate; debug information and use ``-O3`` you can override the; *CMAKE_<LANG>_FLAGS_RELWITHDEBINFO* option for C and CXX.; DistributionExample.cmake does this. Another easy to use option is Link-Time-Optimization. You can set the; *LLVM_ENABLE_LTO* option on your stage-2 build to ``Thin`` or ``Full`` to enable; building LLVM with LTO. These options will significantly increase link time of; the binaries in the distribution, but it will create much faster binaries. This; option should not be used if your distribution includes static archives, as the; objects inside the archive will be LLVM bitcode, which is not portable. The :doc:`AdvancedBuilds` documentation describes the built-in tooling for; generating LLVM profiling information to drive P",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:8050,simpl,simplest,8050,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['simpl'],['simplest']
Usability,"sing the ""`view`"" parameter. Allowed values are 0, 90,; 180 and 270 degrees. ``` {.cpp}; h2->Draw(""SPEC n(40,40) dm(0,1) a(30,30,0)"");; ```. The operator ""`zs(scale)`"" changes the scale of the Z-axis. The; possible values are:. - 0 = Linear (default),; - 1 = Log,; - 2 = Sqrt. If `gPad->SetLogz()` has been set, the log scale on Z-axis is set; automatically, i.e. there is no need for using the `zs()` operator.; Note that the X and Y axis are always linear. The operator ""`ci(r,g,b`)"" defines the colors increments (`r`, `g`; and `b` are floats). For sophisticated shading (Light, Height and; LightHeight Display Modes Groups) the color palette starts from the; basic pen color (see `pa()` function). There is a predefined number of; color levels (256). Color in every level is calculated by adding the; increments of the `r` , `g` , `b` components to the previous level.; Using this function one can change the color increments between two; neighboring color levels. The function does not apply on the Simple; Display Modes Group. The default values are: (1,1,1). The operator ""`ca(color_algorithm)`"" allows to choose the Color; Algorithm. To define the colors one can use one of the following color; algorithms (RGB, CMY, CIE, YIQ, HVS models). When the level of a; component reaches the limit value one can choose either smooth; transition (by decreasing the limit value) or a sharp modulo; transition (continuing with 0 value). This allows various visual; effects. One can choose from the following set of the algorithms:. - 0 = RGB Smooth,; - 1 = RGB Modulo,; - 2 = CMY Smooth,; - 3 = CMY Modulo,; - 4 = CIE Smooth; - 5 = CIE Modulo,; - 6 = YIQ Smooth,; - 7 = YIQ Modulo,; - 8 = HVS Smooth,; - 9 = HVS Modulo. This function does not apply on Simple display modes group. Default; value is 0. Example choosing CMY Modulo to paint the 2D histogram:. ``` {.cpp}; h2->Draw(""SPEC c1(3) dm(0,1) a(30,30,0)"");; ```. The operator ""`lp(x,y,z)`"" sets the light position. In Light and; LightHeight display ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:38472,Simpl,Simple,38472,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['Simpl'],['Simple']
Usability,"sing the newer, much faster,; gold linker. In addition we added the linker option ""-Wl,--no-undefined"",; so you will get an error if symbols are unresolved.; Explicit linking is required by newer distributions, like Ubuntu 11.10,; that require all dependent shared libs to be specified when linking. They; also have default options set to dead strip shared libs that don't resolve; any symbols (equivalent to the MacOS X build changes described above). Core Libraries; TClonesArray. Introduce TClonesArray::ConstructedAt which; always returns an already constructed object. If the slot is being used for the; first time, it calls the default constructor otherwise it returns the object as; is (unless a string is passed as the 2nd argument to the function in which case,; it also calls Clear(second_argument) on the object).; This allows to replace code like:. for (int i = 0; i < ev->Ntracks; i++) {; new(a[i]) TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete(); // or a.Clear(""C""). with the simpler and more efficient:. for (int i = 0; i < ev->Ntracks; i++) {; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear();. even in case where the TTrack class allocates memory. TClonesArray: update ExpandCreateFast to also reset the non-used slots; so that calling Clear (which does too much) is no longer necessary; when using ExpandCreateFast. New Thread Pool class. A first version of TThreadPool class has been introduced.; This class implements a Thread Pool pattern.; So far it supports only one type of queue - FIFO. Thread library. Reduces risk of internal dead lock by using a private internal lock to protect the internals of TThread, rather than using TThread::Lock. New header TThreadSlots.h to centralize and formalize the use of the TThread local memory slots amongst the ROOT packages. Global Variables. The global values gPad, gVirtualX, gInterpreter, gDirectory and gFile; are now all accessed via a static function of their respective class. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:2039,simpl,simpler,2039,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,1,['simpl'],['simpler']
Usability,"sion being browsed.; A set of scripts for quick interaction with a dataset; manager via PROOF are available under $ROOTSYS/etc/proof/utils/pq2 .; The scripts are prefixed; pq2 (proof; quick query - or; proof-dq2); and allow to {browse, register, remove, verify} datasets on a given; PROOF master. See $ROOTSYS/etc/proof/utils/pq2/README for more; information. Improvements. Enable by default schema evolution in TMessage; can be; disabled setting 'Proof.SchemaEvolution:; 0' .; Extend the functionality of the dataset API to obtaine; information on per-server base; add also two new methods:. TProof::SetDataSetTreeName(<dataset>,<treename>):; set/change the default tree name in the TFileCollection;; TProof::ExistsDataSet(<dataset>):; check; by-name the availability of a given dataset;. In ProofBench, . Load the macro before executing it. This allows to; circumvent a problem recently fixed giving less dependency on the; server version.; In make_dset.C, simplification of the body and of the; signature, eliminating one redundant argument. In TProofOutputFile, improve flexibility in defining the; URL for the local files server. The ""LOCALDATASERVER"" env is tested,; which can defined with placeholders via the xpd.putenv directive in the; xrootd/xproofd config files.; Improving parsing of lines with memory info.; This solves occasional crashes while generating the memory; plots.; In TProofMgr::GetSessionLogs:. add the possibility to postpone the retrieval of the; logs files when the TProofLog object is created. This improved; functionality is exploited in the log window.; add decoding of the session starting time and full; information about the master URL. Enable new xrootd configuration options, including the; possibility to set the compiler and linker; Cleanup of the TProofMgr functions DetachSession and; ShutdownSession, and better handling of the internal list registration,; to fix potential segvs when reopening a PROOF session inside the same; ROOT session.; Optimize the wa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:5599,simpl,simplification,5599,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['simpl'],['simplification']
Usability,sion threads have been at [Google groups](https://groups.google.com/d/forum/civetweb).; Recent questions and discussions use [GitHub issues](https://github.com/civetweb/civetweb/issues). Source releases can be found on GitHub; [https://github.com/civetweb/civetweb/releases](https://github.com/civetweb/civetweb/releases). A very brief overview can be found on GitHub Pages; [http://civetweb.github.io/civetweb/](http://civetweb.github.io/civetweb/). Getting The Source; ------------------; Download the source code by running the following code in your command prompt:. $ git clone https://github.com/civetweb/civetweb.git; or simply grab a copy of the source code as a ZIP or TGZ file. Quick start documentation; --------------------------. - [docs/Installing.md](https://github.com/civetweb/civetweb/blob/master/docs/Installing.md) - Install Guide (for end users using pre-built binaries); - [docs/UserManual.md](https://github.com/civetweb/civetweb/blob/master/docs/UserManual.md) - End User Guide; - [docs/Building.md](https://github.com/civetweb/civetweb/blob/master/docs/Building.md) - Building the Server (quick start guide); - [docs/Embedding.md](https://github.com/civetweb/civetweb/blob/master/docs/Embedding.md) - Embedding (how to add HTTP support to an existing application); - [docs/OpenSSL.md](https://github.com/civetweb/civetweb/blob/master/docs/OpenSSL.md) - Adding HTTPS (SSL/TLS) support using OpenSSL.; - [API documentation](https://github.com/civetweb/civetweb/tree/master/docs/api) - Additional documentation on the civetweb application programming interface ([civetweb.h](https://github.com/civetweb/civetweb/blob/master/include/civetweb.h)).; - [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md) - Release Notes; - [SECURITY.md](https://github.com/civetweb/civetweb/blob/master/SECURITY.md) - Security Policy; - [LICENSE.md](https://github.com/civetweb/civetweb/blob/master/LICENSE.md) - Copyright License. Overview; --------. CivetWeb keep,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:4176,Guid,Guide,4176,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['Guid'],['Guide']
Usability,"sis to provide high-level dependence; information about memory-using instructions. This will tell you which store; feeds into a load, for example. It uses caching and other techniques to be; efficient, and is used by Dead Store Elimination, GVN, and memcpy optimizations. .. _AliasSetTracker:. Using the ``AliasSetTracker`` class; -----------------------------------. Many transformations need information about alias **sets** that are active in; some scope, rather than information about pairwise aliasing. The; `AliasSetTracker <https://llvm.org/doxygen/classllvm_1_1AliasSetTracker.html>`__; class is used to efficiently build these Alias Sets from the pairwise alias; analysis information provided by the ``AliasAnalysis`` interface. First you initialize the AliasSetTracker by using the ""``add``"" methods to add; information about various potentially aliasing instructions in the scope you are; interested in. Once all of the alias sets are completed, your pass should; simply iterate through the constructed alias sets, using the ``AliasSetTracker``; ``begin()``/``end()`` methods. The ``AliasSet``\s formed by the ``AliasSetTracker`` are guaranteed to be; disjoint, calculate mod/ref information and volatility for the set, and keep; track of whether or not all of the pointers in the set are Must aliases. The; AliasSetTracker also makes sure that sets are properly folded due to call; instructions, and can provide a list of pointers in each set. As an example user of this, the `Loop Invariant Code Motion; <doxygen/structLICM.html>`_ pass uses ``AliasSetTracker``\s to calculate alias; sets for each loop nest. If an ``AliasSet`` in a loop is not modified, then all; load instructions from that set may be hoisted out of the loop. If any alias; sets are stored to **and** are must alias sets, then the stores may be sunk; to outside of the loop, promoting the memory location to a register for the; duration of the loop nest. Both of these transformations only apply if the; pointer argumen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:20520,simpl,simply,20520,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['simpl'],['simply']
Usability,"sive; Not resolved. 294; NAD; Can static_cast drop exception specifications?; No. 295; CD1; cv-qualifiers on function types; Clang 3.7. 296; CD1; Can conversion functions be static?; Yes. 297; NAD; Which template does an explicit specialization specialize?; Unknown. 298; CD1; T::x when T is cv-qualified; Clang 3.1. 299; CD1; Conversion on array bound expression in new; Clang 2.8 (C++11 onwards). 300; CD1; References to functions in template argument deduction; Yes. 301; CD1; Syntax for template-name; Clang 3.5. 302; CD1; Value-initialization and generation of default constructor; Clang 3.0. 303; NAD; Integral promotions on bit-fields; N/A. 304; TC1; Value-initialization of a reference; Clang 2.9. 305; CD1; Name lookup in destructor call; No. 306; CD1; Ambiguity by class name injection; Duplicate of 39. 307; NAD; Initialization of a virtual base class subobject; N/A. 308; NAD; Catching exceptions with ambiguous base classes; Clang 3.7. 309; CD1; Linkage of entities whose names are not simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the constructor of A; Superseded by 1310. 319; CD1; Use of names without linkage in declaring entities with linkage; No. 320; CD1; Question on copy constructor elision example; Yes. 321; dup; Associated classes and namespaces for ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:20395,simpl,simply,20395,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simply']
Usability,"so compare them. How to implement cmpValues?; ^^^^^^^^^^^^^^^^^^^^^^^^^^^; *Association* is a case of equality for us. We just treat such values as equal,; but, in general, we need to implement antisymmetric relation. As mentioned; above, to understand what is *less*, we can use order in which we; meet values. If both values have the same order in a function (met at the same; time), we then treat values as *associated*. Otherwise – it depends on who was; first. Every time we run the top-level compare method, we initialize two identical; maps (one for the left side, another one for the right side):. ``map<Value, int> sn_mapL, sn_mapR;``. The key of the map is the *Value* itself, the *value* – is its order (call it; *serial number*). To add value *V* we need to perform the next procedure:. ``sn_map.insert(std::make_pair(V, sn_map.size()));``. For the first *Value*, map will return *0*, for the second *Value* map will; return *1*, and so on. We can then check whether left and right values met at the same time with; a simple comparison:. ``cmpNumbers(sn_mapL[Left], sn_mapR[Right]);``. Of course, we can combine insertion and comparison:. .. code-block:: c++. std::pair<iterator, bool>; LeftRes = sn_mapL.insert(std::make_pair(Left, sn_mapL.size())), RightRes; = sn_mapR.insert(std::make_pair(Right, sn_mapR.size()));; return cmpNumbers(LeftRes.first->second, RightRes.first->second);. Let's look, how whole method could be implemented. 1. We have to start with the bad news. Consider function self and; cross-referencing cases:. .. code-block:: c++. // self-reference unsigned fact0(unsigned n) { return n > 1 ? n; * fact0(n-1) : 1; } unsigned fact1(unsigned n) { return n > 1 ? n *; fact1(n-1) : 1; }. // cross-reference unsigned ping(unsigned n) { return n!= 0 ? pong(n-1) : 0;; } unsigned pong(unsigned n) { return n!= 0 ? ping(n-1) : 0; }. .. This comparison has been implemented in initial *MergeFunctions* pass; version. But, unfortunately, it is not transitive. And this is the onl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:19288,simpl,simple,19288,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['simpl'],['simple']
Usability,"so do not be concerned if a; commit does not immediately appear in the archives. If you have recently been granted commit access, these policies apply:. #. You are granted *commit-after-approval* to all parts of LLVM. For; information on how to get approval for a patch, please see :doc:`CodeReview`.; When approved, you may commit it yourself. #. You are allowed to commit patches without approval which you think are; obvious. This is clearly a subjective decision --- we simply expect you to; use good judgement. Examples include: fixing build breakage, reverting; obviously broken patches, documentation/comment changes, any other minor; changes. Avoid committing formatting- or whitespace-only changes outside of; code you plan to make subsequent changes to. Also, try to separate; formatting or whitespace changes from functional changes, either by; correcting the format first (ideally) or afterward. Such changes should be; highly localized and the commit message should clearly state that the commit; is not intended to change functionality, usually by stating it is; :ref:`NFC <nfc>`. #. You are allowed to commit patches without approval to those portions of LLVM; that you have contributed or maintain (i.e., have been assigned; responsibility for), with the proviso that such commits must not break the; build. This is a ""trust but verify"" policy, and commits of this nature are; reviewed after they are committed. #. Multiple violations of these policies or a single egregious violation may; cause commit access to be revoked. In any case, your changes are still subject to `code review`_ (either before or; after they are committed, depending on the nature of the change). You are; encouraged to review other peoples' patches as well, but you aren't required; to do so. .. _discuss the change/gather consensus:. Making a Major Change; ---------------------. When a developer begins a major new project with the aim of contributing it back; to LLVM, they should inform the community with",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:25048,clear,clearly,25048,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['clear'],['clearly']
Usability,"so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output chec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3458,Guid,Guide,3458,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,1,['Guid'],['Guide']
Usability,"software engineering; principles. For example, the code uses global variables; pervasively, doesn't use; `visitors <http://en.wikipedia.org/wiki/Visitor_pattern>`_, etc... but; instead keeps things simple and focuses on the topics at hand. This tutorial is structured into chapters covering individual topics,; allowing you to skip ahead as you wish:. - `Chapter #1: Kaleidoscope language and Lexer <LangImpl01.html>`_ -; This shows where we are; going and the basic functionality that we want to build. A lexer; is also the first part of building a parser for a language, and we; use a simple C++ lexer which is easy to understand.; - `Chapter #2: Implementing a Parser and AST <LangImpl02.html>`_ -; With the lexer in place, we can talk about parsing techniques and; basic AST construction. This tutorial describes recursive descent; parsing and operator precedence parsing.; - `Chapter #3: Code generation to LLVM IR <LangImpl03.html>`_ - with; the AST ready, we show how easy it is to generate LLVM IR, and show; a simple way to incorporate LLVM into your project.; - `Chapter #4: Adding JIT and Optimizer Support <LangImpl04.html>`_ -; One great thing about LLVM is its support for JIT compilation, so; we'll dive right into it and show you the 3 lines it takes to add JIT; support. Later chapters show how to generate .o files.; - `Chapter #5: Extending the Language: Control Flow <LangImpl05.html>`_ - With; the basic language up and running, we show how to extend; it with control flow operations ('if' statement and a 'for' loop). This; gives us a chance to talk about SSA construction and control; flow.; - `Chapter #6: Extending the Language: User-defined Operators; <LangImpl06.html>`_ - This chapter extends the language to let; users define arbitrary unary and binary operators - with assignable; precedence! This allows us to build a significant piece of the; ""language"" as library routines.; - `Chapter #7: Extending the Language: Mutable Variables; <LangImpl07.html>`_ - This chapter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst:2278,simpl,simple,2278,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,1,['simpl'],['simple']
Usability,"son.gz&layout=3x3>; 18. Also for online server process url options like 'item', 'items', 'layout'; 19. Possibility to generate URL, which reproduces opened page with layout and drawn items. ### August 2014; 1. All communication between server and browser done with JSON format.; 2. Fix small error in dtree.js - one should always set; last sibling (_ls) property while tree can be dynamically changed.; 3. In JSRootCore.js provide central function, which handles different kinds; of XMLHttpRequest. Use only async requests, also when getting file header.; 4. Fully reorganize data management in file/tree/directory/collection hierarchical; display. Now complete description collected in HPainter class and decoupled from; visualization, performed with dTree.js.; 5. Remove all global variables from the code.; 6. Automatic scripts/style loading handled via JSROOT.loadScript() function.; One can specify arbitrary scripts list, which asynchronously loaded by browser.; 7. Method to build simple GUI changed and more simplified :). The example in index.htm.; While loadScript and AssertPrerequisites functions moved to JSROOT, one; can easily build many different kinds of GUIs, reusing provided JSRootCore.js functions.; 8. In example.htm also use AssertPrerequisites to load necessary scripts.; This helps to keep code up-to-date even by big changes in JavaScript code.; 9. Provide monitoring of online THttpServer with similar interface as for ROOT files.; 10. Fix several errors in TKey Streamer, use member names as in ROOT itself.; 11. Keep the only version identifier JSROOT.version for JS code; 12. One can specify in JSROOT.AssertPrerequisites functionality which is required.; One could specify '2d', 'io' (default) or '3d'.; 13. Use new AssertPrerequisites functionality to load only required functionality.; 14. When displaying single element, one could specify draw options and monitor property like:; <http://localhost:8080/Files/job1.root/hpxpy/draw.htm?opt=col&monitor=2000>; Such link ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:74549,simpl,simple,74549,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,2,['simpl'],"['simple', 'simplified']"
Usability,"specialization A<T,T*,I> but not A<int,int,1>. Matcher<Decl>classTemplateSpecializationDeclMatcher<ClassTemplateSpecializationDecl>...; Matches C++ class template specializations. Given; template<typename T> class A {};; template<> class A<double> {};; A<int> a;; classTemplateSpecializationDecl(); matches the specializations A<int> and A<double>. Matcher<Decl>conceptDeclMatcher<ConceptDecl>...; Matches concept declarations. Example matches integral; template<typename T>; concept integral = std::is_integral_v<T>;. Matcher<Decl>cxxConstructorDeclMatcher<CXXConstructorDecl>...; Matches C++ constructor declarations. Example matches Foo::Foo() and Foo::Foo(int); class Foo {; public:; Foo();; Foo(int);; int DoSomething();; };. Matcher<Decl>cxxConversionDeclMatcher<CXXConversionDecl>...; Matches conversion operator declarations. Example matches the operator.; class X { operator int() const; };. Matcher<Decl>cxxDeductionGuideDeclMatcher<CXXDeductionGuideDecl>...; Matches user-defined and implicitly generated deduction guide. Example matches the deduction guide.; template<typename T>; class X { X(int) };; X(int) -> X<int>;. Matcher<Decl>cxxDestructorDeclMatcher<CXXDestructorDecl>...; Matches explicit C++ destructor declarations. Example matches Foo::~Foo(); class Foo {; public:; virtual ~Foo();; };. Matcher<Decl>cxxMethodDeclMatcher<CXXMethodDecl>...; Matches method declarations. Example matches y; class X { void y(); };. Matcher<Decl>cxxRecordDeclMatcher<CXXRecordDecl>...; Matches C++ class declarations. Example matches X, Z; class X;; template<class T> class Z {};. Matcher<Decl>declMatcher<Decl>...; Matches declarations. Examples matches X, C, and the friend declaration inside C;; void X();; class C {; friend X;; };. Matcher<Decl>declaratorDeclMatcher<DeclaratorDecl>...; Matches declarator declarations (field, variable, function; and non-type template parameter declarations). Given; class X { int y; };; declaratorDecl(); matches int y. Matcher<Decl>decompositionDeclMatcher",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:11578,guid,guide,11578,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['guid'],['guide']
Usability,"spend.retcon`` after resuming in any way. Coroutine Transformation Passes; ===============================; CoroEarly; ---------; The pass CoroEarly lowers coroutine intrinsics that hide the details of the; structure of the coroutine frame, but, otherwise not needed to be preserved to; help later coroutine passes. This pass lowers `coro.frame`_, `coro.done`_,; and `coro.promise`_ intrinsics. .. _CoroSplit:. CoroSplit; ---------; The pass CoroSplit builds coroutine frame and outlines resume and destroy parts; into separate functions. CoroElide; ---------; The pass CoroElide examines if the inlined coroutine is eligible for heap; allocation elision optimization. If so, it replaces; `coro.begin` intrinsic with an address of a coroutine frame placed on its caller; and replaces `coro.alloc` and `coro.free` intrinsics with `false` and `null`; respectively to remove the deallocation code.; This pass also replaces `coro.resume` and `coro.destroy` intrinsics with direct; calls to resume and destroy functions for a particular coroutine where possible. CoroCleanup; -----------; This pass runs late to lower all coroutine related intrinsics not replaced by; earlier passes. Attributes; ==========. coro_only_destroy_when_complete; -------------------------------. When the coroutine are marked with coro_only_destroy_when_complete, it indicates; the coroutine must reach the final suspend point when it get destroyed. This attribute only works for switched-resume coroutines now. Metadata; ========. '``coro.outside.frame``' Metadata; ---------------------------------. ``coro.outside.frame`` metadata may be attached to an alloca instruction to; to signify that it shouldn't be promoted to the coroutine frame, useful for; filtering allocas out by the frontend when emitting internal control mechanisms.; Additionally, this metadata is only used as a flag, so the associated; node must be empty. .. code-block:: text. %__coro_gro = alloca %struct.GroType, align 1, !coro.outside.frame !0. ...; !",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:57170,resume,resume,57170,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"sponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later with the method `SetWeight()` of the class; **`TMultiLayerPerceptron`**. Two datasets must be defined before; learning the network: a training dataset that is used when minimizing; the error, and a test dataset that will avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can cont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:75668,learn,learning,75668,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['learn'],['learning']
Usability,src/LaEigenValues.cxx; src/LaInnerProduct.cxx; src/LaInverse.cxx; src/LaOuterProduct.cxx; src/LaSumOfElements.cxx; src/LaVtMVSimilarity.cxx; src/MPIProcess.cxx; src/MinimumBuilder.cxx; src/Minuit2Minimizer.cxx; src/MnApplication.cxx; src/MnContours.cxx; src/MnCovarianceSqueeze.cxx; src/MnEigen.cxx; src/MnFcn.cxx; src/MnFumiliMinimize.cxx; src/MnFunctionCross.cxx; src/MnGlobalCorrelationCoeff.cxx; src/MnHesse.cxx; src/MnLineSearch.cxx; src/MnMachinePrecision.cxx; src/MnMinos.cxx; src/MnParabolaFactory.cxx; src/MnParameterScan.cxx; src/MnPlot.cxx; src/MnPosDef.cxx; src/MnPrint.cxx; src/MnPrintImpl.cxx; src/MnScan.cxx; src/MnSeedGenerator.cxx; src/MnStrategy.cxx; src/MnTiny.cxx; src/MnTraceObject.cxx; src/MnUserFcn.cxx; src/MnUserParameterState.cxx; src/MnUserParameters.cxx; src/MnUserTransformation.cxx; src/ModularFunctionMinimizer.cxx; src/NegativeG2LineSearch.cxx; src/Numerical2PGradientCalculator.cxx; src/NumericalDerivator.cxx; src/ParametricFunction.cxx; src/ScanBuilder.cxx; src/SimplexBuilder.cxx; src/SimplexParameters.cxx; src/SimplexSeedGenerator.cxx; src/SinParameterTransformation.cxx; src/SqrtLowParameterTransformation.cxx; src/SqrtUpParameterTransformation.cxx; src/TMinuit2TraceObject.cxx; src/VariableMetricBuilder.cxx; src/VariableMetricEDMEstimator.cxx; src/mnbins.cxx; src/mndasum.cxx; src/mndaxpy.cxx; src/mnddot.cxx; src/mndscal.cxx; src/mndspmv.cxx; src/mndspr.cxx; src/mnlsame.cxx; src/mnteigen.cxx; src/mntplot.cxx; src/mnvert.cxx; src/mnxerbla.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; MathCore; Hist; ); endif(). if(minuit2_omp); find_package(OpenMP REQUIRED); find_package(Threads REQUIRED). if(NOT TARGET OpenMP::OpenMP_CXX); add_library(OpenMP::OpenMP_CXX IMPORTED INTERFACE); set_property(TARGET OpenMP::OpenMP_CXX PROPERTY INTERFACE_COMPILE_DEFINITIONS -D_GLIBCXX_PARALLEL); set_property(TARGET OpenMP::OpenMP_CXX PROPERTY INTERFACE_COMPILE_OPTIONS ${OpenMP_CXX_FLAGS}); set_property(TARGET OpenMP::OpenMP_CXX PROPERTY INTERFACE_LINK_LIBRA,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt:4925,Simpl,SimplexBuilder,4925,math/minuit2/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt,1,['Simpl'],['SimplexBuilder']
Usability,"ss values and so forth, without the logging code doing any real work to; convert those values to human-readable form. Instead, logging text uses the; markup format defined here to identify pieces of information that should be; converted to human-readable form after the fact. As with other markup formats,; the expectation is that most of the text will be displayed as is, while the; markup elements will be replaced with expanded text, or converted into active UI; elements, that present more details in symbolic form. This means there is no need for symbol tables, DWARF debugging sections, or; similar information to be directly accessible at runtime. There is also no need; at runtime for any logic intended to compute human-readable presentation of; information, such as C++ symbol demangling. Instead, logging must include markup; elements that give the contextual information necessary to make sense of the raw; data, such as memory layout details. This format identifies markup elements with a syntax that is both simple and; distinctive. It's simple enough to be matched and parsed with straightforward; code. It's distinctive enough that character sequences that look like the start; or end of a markup element should rarely if ever appear incidentally in logging; text. It's specifically intended not to require sanitizing plain text, such as; the HTML/XML requirement to replace ``<`` with ``&lt;`` and the like. :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` includes a symbolizing; filter via its ``--filter-markup`` option. Also, LLVM utilites emit stack; traces as markup when the ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` environment; variable is set. Scope and assumptions; =====================. A symbolizing filter implementation will be independent both of the target; operating system and machine architecture where the logs are generated and of; the host operating system and machine architecture where the filter runs. This format assumes that the symbolizing filter processes ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:1320,simpl,simple,1320,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['simpl'],['simple']
Usability,"ss, it works for all projectable classes. TEveVector, TEveVector4 and TEveVector2 are now typedefs to float; specialization of corresponding templates. Double versions use 'D' as; postfix, 'F' postfix is another alias for float versions, e.g.:; typedef TEveVectorT<Float_t> TEveVector;; typedef TEveVectorT<Float_t> TEveVectorF;; typedef TEveVectorT<Double_t> TEveVectorD;. All projectable classes now take into account their transformation; matrix. The projected versions are still stored in global; coordinates.; TEveShape -- a new abstract base-class for 2D/3D shapes that; require fill / outline color, line-width and various flags; controlling the area / outline drawing.; TEveGeoShape and projected classes: subclass from TEveShape. Add; support for TGeoCompositeShapes. In 2D projected class; (TEvePolygonSetProjected) improve detection of duplicate polygons; and add support for detection of minimal-outline (triggered via; Bool_t TEveShape::fMiniOutline).; TEveBox: New class to draw a simple cuboid with minimal memory; usage. It is projectable.; TEveBoxSet: for box-type kBT_FreeBox assure proper face; orientation at registration time and calculate normals when; rendering. TEveJetCone is now projectable.; Several performance improvements when dealing with large; collections of EVE objects. Profiled with simulated heavy-ion; data. In particular, for destruction of self-contained sub-hierarchies of objects; one can use TEveElement::Annihilate() and; TEveElement::AnnihilateElements(). See class docs for constraints. Minor changes. Add support for projecting a new child (all children) of an; element after the element and its old children have already been; projected. This is provided by the following virtual functions in; TEveElement:; void ProjectChild(TEveElement* el, Bool_t sameDepth=kTRUE);; void ProjectAllChildren(Bool_t same_depth=kTRUE);. Several improvements in drawing of TEveCalo axes and labels.; TEveTrackPropagator. Fix some issues with Runge-Kutta track; propagato",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html:5446,simpl,simple,5446,graf3d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html,1,['simpl'],['simple']
Usability,ss.h; Minuit2/MnEigen.h; Minuit2/MnFcn.h; Minuit2/MnFumiliMinimize.h; Minuit2/MnFunctionCross.h; Minuit2/MnGlobalCorrelationCoeff.h; Minuit2/MnHesse.h; Minuit2/MnLineSearch.h; Minuit2/MnMachinePrecision.h; Minuit2/MnMatrix.h; Minuit2/MnMatrixfwd.h; Minuit2/MnMigrad.h; Minuit2/MnMinimize.h; Minuit2/MnMinos.h; Minuit2/MnParabola.h; Minuit2/MnParabolaFactory.h; Minuit2/MnParabolaPoint.h; Minuit2/MnParameterScan.h; Minuit2/MnPlot.h; Minuit2/MnPosDef.h; Minuit2/MnPrint.h; Minuit2/MnScan.h; Minuit2/MnSeedGenerator.h; Minuit2/MnSimplex.h; Minuit2/MnStrategy.h; Minuit2/MnTiny.h; Minuit2/MnTraceObject.h; Minuit2/MnUserCovariance.h; Minuit2/MnUserFcn.h; Minuit2/MnUserParameterState.h; Minuit2/MnUserParameters.h; Minuit2/MnUserTransformation.h; Minuit2/MnVectorTransform.h; Minuit2/ModularFunctionMinimizer.h; Minuit2/NegativeG2LineSearch.h; Minuit2/Numerical2PGradientCalculator.h; Minuit2/NumericalDerivator.h; Minuit2/ParametricFunction.h; Minuit2/ScanBuilder.h; Minuit2/ScanMinimizer.h; Minuit2/SimplexBuilder.h; Minuit2/SimplexMinimizer.h; Minuit2/SimplexParameters.h; Minuit2/SimplexSeedGenerator.h; Minuit2/SinParameterTransformation.h; Minuit2/SqrtLowParameterTransformation.h; Minuit2/SqrtUpParameterTransformation.h; Minuit2/StackAllocator.h; Minuit2/VariableMetricBuilder.h; Minuit2/VariableMetricEDMEstimator.h; Minuit2/VariableMetricMinimizer.h; Minuit2/VectorOuterProduct.h; TMinuit2TraceObject.h; SOURCES; src/AnalyticalGradientCalculator.cxx; src/BFGSErrorUpdator.cxx; src/CMakeLists.txt; src/CombinedMinimumBuilder.cxx; src/DavidonErrorUpdator.cxx; src/ExternalInternalGradientCalculator.cxx; src/FumiliBuilder.cxx; src/FumiliErrorUpdator.cxx; src/FumiliGradientCalculator.cxx; src/FumiliMinimizer.cxx; src/FumiliStandardChi2FCN.cxx; src/FumiliStandardMaximumLikelihoodFCN.cxx; src/HessianGradientCalculator.cxx; src/InitialGradientCalculator.cxx; src/LaEigenValues.cxx; src/LaInnerProduct.cxx; src/LaInverse.cxx; src/LaOuterProduct.cxx; src/LaSumOfElements.cxx; src/LaVtMVSimilarity.,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt:3062,Simpl,SimplexBuilder,3062,math/minuit2/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt,1,['Simpl'],['SimplexBuilder']
Usability,"ssembly Reference <https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/assembler/alangref_kickoff.html>`_. * `IBM AIX/5L for POWER Assembly Reference <http://publibn.boulder.ibm.com/doc_link/en_US/a_doc_lib/aixassem/alangref/alangreftfrm.htm>`_. Embedded PowerPC Processors manuals and docs; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * `Book E: Enhanced PowerPC Architecture <https://www.nxp.com/docs/en/user-guide/BOOK_EUM.pdf>`_. * `EREF: A Programmer's Reference Manual for Freescale Embedded Processors (EREFRM) <https://www.nxp.com/files-static/32bit/doc/ref_manual/EREF_RM.pdf>`_. * `Signal Processing Engine (SPE) Programming Environments Manual: A Supplement to the EREF <https://www.nxp.com/docs/en/reference-manual/SPEPEM.pdf>`_. * `Variable-Length Encoding (VLE) Programming Environments Manual: A Supplement to the EREF <https://www.nxp.com/docs/en/reference-manual/VLEPEM.pdf>`_. Other documents, collections, notes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * `PowerPC Compiler Writer's Guide <http://www.ibm.com/chips/techlib/techlib.nsf/techdocs/852569B20050FF7785256996007558C6>`_; * `Intro to PowerPC Architecture <http://www.ibm.com/developerworks/linux/library/l-powarch/>`_; * `Various IBM specifications and white papers <https://www.power.org/documentation/?document_company=105&document_category=all&publish_year=all&grid_order=DESC&grid_sort=title>`_; * `PowerPC ABI documents <http://penguinppc.org/dev/#library>`_; * `PowerPC64 alignment of long doubles (from GCC) <http://gcc.gnu.org/ml/gcc-patches/2003-09/msg00997.html>`_; * `Long branch stubs for powerpc64-linux (from binutils) <http://sources.redhat.com/ml/binutils/2002-04/msg00573.html>`_. AMDGPU; ------. Refer to :doc:`AMDGPUUsage` for additional documentation. RISC-V; ------; * `RISC-V User-Level ISA Specification <https://riscv.org/specifications/>`_. C-SKY; ------; * `C-SKY Architecture User Guide <https://github.com/c-sky/csky-doc/blob/master/CSKY%20Architecture%20user_guide.pdf>`_; * `C-SKY V2 ABI ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst:3824,Guid,Guide,3824,interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,1,['Guid'],['Guide']
Usability,"ssible to launch ROOT with some command line options, as shown; below:. ```; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without graphics display. This; mode is useful in case one does not want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker execution (i.e. the compiled; speed rather than the interpreted speed). See also ""Cling the C++; Interpreter"". ```; root -b -q myMacro.so > myMacro.log; ```. ROOT has a powerful C/C++ interpreter giving you access to all a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:3780,simpl,simply,3780,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['simpl'],['simply']
Usability,"ssociated iterator class that knows how to; sequentially retrieve each member in turn. The relationship between a; collection and its iterator is very close and may require that the; iterator has full access to the collection (i.e. it is a friend class).; In general iterator will be used via the **`TIter`** wrapper class. For; example:. - **`TList`** **`TListIter`**. - **`TMap`** **`TMapIter`**. ## Foundation Classes. All collections are based on the fundamental classes: **`TCollection`**; and **`TIterator`**. They are so generic that it is not possible to; create objects from them; they are only used as base classes for other; classes (i.e. they are abstract base classes). The **`TCollection`** class provides the basic protocol (i.e. the; minimum set of member functions) that all collection classes have to; implement. These include:. - `Add` `Adds another object to the collection.`. - `GetSize` `Returns the number of objects in the collection.`. - `Clear`; `Clears out the collection, but does not delete the removed objects.`. - `Delete`; `Clears out the collection and deletes the removed objects. This should only `; `be used if the collection owns its objects (which are not normally the case).`. - `FindObject` `Finds an object given either its name or address.`. - `MakeIterator` `Returns an iterator associated with the collection.`. - `Remove` `Removes an object from the collection.`. The code example below shows a class containing three lists, where the; `fTracks` list is the owning collection and the other two lists are used; to store a sub-set of the track objects. In the destructor of the class,; the method `Delete` is called for the owning collection to delete; correctly its entire track objects. To delete the objects in the; container use `fTrack->Delete()`. To delete the container itself, do; '`delete fTracks'.`. ``` {.cpp}; class TEvent : public TObject {; private:; TList *fTracks; //list of all tracks; TList *fVertex1; //subset of tracks part of vertex1; T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:6810,Clear,Clear,6810,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,2,['Clear'],"['Clear', 'Clears']"
Usability,"st MatchFinder::MatchResult &Result) {; if (const ForStmt *FS = Result.Nodes.getNodeAs<clang::ForStmt>(""forLoop"")); FS->dump();; }; };. And change ``main()`` to:. .. code-block:: c++. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());. LoopPrinter Printer;; MatchFinder Finder;; Finder.addMatcher(LoopMatcher, &Printer);. return Tool.run(newFrontendActionFactory(&Finder).get());; }. Now, you should be able to recompile and run the code to discover for; loops. Create a new file with a few examples, and test out our new; handiwork:. .. code-block:: console. cd ~/clang-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a mat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:10472,simpl,simple-loops,10472,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simple-loops']
Usability,"st not suffice, and instead would simply; complicate the picture further because it adds an extra variant in; addition to the one each language provides. Instead, providing a default library version of malloc and free; (and perhaps a malloc_gc with garbage collection instead of free); would make a good implementation available to anyone who wants it. I don't recall all your arguments in favor so let's discuss this again,; and soon. o 'alloca' on the other hand sounds like a good idea, and the; implementation seems fairly language-independent so it doesn't have the; problems with malloc listed above. o About indirect call:; Your option #2 sounded good to me. I'm not sure I understand your; concern about an explicit 'icall' instruction?. o A pair of important synchronization instr'ns to think about:; load-linked; store-conditional. o Other classes of instructions that are valuable for pipeline performance:; conditional-move		 ; predicated instructions. o I believe tail calls are relatively easy to identify; do you know why; .NET has a tailcall instruction?. o I agree that we need a static data space. Otherwise, emulating global; data gets unnecessarily complex. o About explicit parallelism:. We once talked about adding a symbolic thread-id field to each; instruction. (It could be optional so single-threaded codes are; not penalized.) This could map well to multi-threaded architectures; while providing easy ILP for single-threaded onces. But it is probably; too radical an idea to include in a base version of LLVM. Instead, it; could a great topic for a separate study. What is the semantics of the IA64 stop bit?. o And finally, another thought about the syntax for arrays :-). Although this syntax:; 	 array <dimension-list> of <type>; is verbose, it will be used only in the human-readable assembly code so; size should not matter. I think we should consider it because I find it; to be the clearest syntax. It could even make arrays of function; pointers somewhat readable. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt:4453,clear,clearest,4453,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,1,['clear'],['clearest']
Usability,"st; argument to have access to class members of the same instance).; `pthreads` are made for simple C functions and do not know about Thread0; being a member function of a class. Thus, you have to pass this; information by hand, if you want to access all members of the `Myclass`; instance from the Thread0 function. Note: Method Thread0 cannot be a virtual member function, since the cast; of `Thread0` to `void(*)` in the **`TThread`** constructor may raise; problems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libTThreadframe.so` and; `libTMhs3.so`. These are either loaded or executed by the ROOT script; `TMhs3demo.C,` or are linked against an executable: `TMhs3run.cxx`. ### Known Problems. Parts of the ROOT framework, like the interpreter, are not yet; thread-safe. Therefore, you should use this package with caution. If you; restrict your threads to distinct and \`simple' duties, you will able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:16498,simpl,simple,16498,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['simpl'],['simple']
Usability,"stance, running a `migrad` fit:; ``` {.cpp}; m.migrad(); ```. ## Constant term optimization; The `RooAbsTestStatistic` based classes not only combine statistics and calculation, but also constant term optimization routines.; These can be run on PDFs and datasets before starting a fit.; They search the calculation graph for parts that are independent of the fit parameters, precalculates them, and adds them to (a clone of) the dataset so that these values can be used during calculation. In `RooFit::TestStatistics`, we separated this functionality out into the `ConstantTermsOptimizer` class.; In fact, it is not so much a class, as it is a collection of static functions that can be applied to any combination of pdf and dataset.; This class does essentially the same as `constOptimizeTestStatistic` did on a `RooNLLVar`, except that it has been factored out into a separate class. ### Usage example: apply constant term optimization on pdf and dataset inside a likelihood; Applying the default `ConstantTermsOptimizer` optimization routines on the pdf and dataset inside a `RooAbsL` likelihood is as simple as:. ``` {.cpp}; likelihood.constOptimizeTestStatistic();; ```; This applies constant term optimization to the cloned pdf and dataset inside the likelihood object.; It will not modify anything outside of the likelihood. Optimization can also be activated through the minimizer, which may be more familiar to most users.; Given the `RooMinimizer` object `m` as defined in the example above, we can do:; ``` {.cpp}; m.optimizeConst(2);; ```. For the adventurous user, it is also possible to apply constant term optimization to a pdf and dataset directly without needing a likelihood object, e.g. given some `RooArgSet` set of observables `normSet`:; ``` {.cpp}; bool applyTrackingOpt = true;; ConstantTermsOptimizer::enableConstantTermsOptimization(&pdf, &normSet, dataset, applyTrackingOpt);; ```; We refer to RooFit documentation for more about ""tracking optimization"" which can be enabled",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:10500,simpl,simple,10500,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['simpl'],['simple']
Usability,"state change that; needs to happen to prepare a coroutine for resumption) happens at the same time as; a suspension of a coroutine. However, in certain cases, it is necessary to control; when coroutine is prepared for resumption and when it is suspended. In the following example, a coroutine represents some activity that is driven; by completions of asynchronous operations `async_op1` and `async_op2` which get; a coroutine handle as a parameter and resume the coroutine once async; operation is finished. .. code-block:: text. void g() {; for (;;); if (cond()) {; async_op1(<coroutine-handle>); // will resume once async_op1 completes; <suspend>; do_one();; }; else {; async_op2(<coroutine-handle>); // will resume once async_op2 completes; <suspend>; do_two();; }; }; }. In this case, coroutine should be ready for resumption prior to a call to; `async_op1` and `async_op2`. The `coro.save`_ intrinsic is used to indicate a; point when coroutine should be ready for resumption (namely, when a resume index; should be stored in the coroutine frame, so that it can be resumed at the; correct resume point):. .. code-block:: llvm. if.true:; %save1 = call token @llvm.coro.save(ptr %hdl); call void @async_op1(ptr %hdl); %suspend1 = call i1 @llvm.coro.suspend(token %save1, i1 false); switch i8 %suspend1, label %suspend [i8 0, label %resume1; i8 1, label %cleanup]; if.false:; %save2 = call token @llvm.coro.save(ptr %hdl); call void @async_op2(ptr %hdl); %suspend2 = call i1 @llvm.coro.suspend(token %save2, i1 false); switch i8 %suspend2, label %suspend [i8 0, label %resume2; i8 1, label %cleanup]. .. _coroutine promise:. Coroutine Promise; -----------------. A coroutine author or a frontend may designate a distinguished `alloca` that can; be used to communicate with the coroutine. This distinguished alloca is called; **coroutine promise** and is provided as the second parameter to the; `coro.id`_ intrinsic. The following coroutine designates a 32 bit integer `promise` and uses it to; st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:21604,resume,resume,21604,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,3,['resume'],"['resume', 'resumed']"
Usability,"stead,e.g.:. RooDataSet wdata(""wdata"",""wdata"",RooArgSet(x,y,wgt),WeightVar(wgt)) ;. The RooHist class that represents data as a histogram in a RooPlot has been modified; so that it can show approximate Poisson errors for non-integer data. These approximate; errors are calculated from interpolation of the error bars of the nearest integers. NB: A weighted dataset; plotted with RooAbsData::plotOn() will be default show sum-of-weights-squared errors. Only; when Poisson error are forced through a DataError(RooAbsData::Poisson) argument these; approximate Poisson error bars are shown. Miscellaneous improvements other. The RooFit messagee service class RooMsgService has been augmented with a stack that; can store its configurate state information. A call to saveState() will save the; present configuration, which can be restored through a subsequent call to restoreState().; In addition to the method RooAbsArg::printCompactTree() which is mostly intende for; debugging, a new method RooAbsArg::printComponentTree() has been added that prints; the tree structure of a pdf in a more user-friendly content oriented way. The printing ; of the leaf nodes (the variables) is omitted in this method to keep the output compact. RooStats. This release contains significant bug fixes and it is strongly; recommended to update to this version if using older ones. . Major Changes in LimitCalculator and HypoTestCalculator classes: usage of ModelConfig class. The RooStats calculator interfaces have been changed to use the ModelConfig class.; All the setter methods with the parameter lists, pdf instances and name have been removed from the interfaces.; The SetWorkspace(RooWorkspace & ) has also been removed, while a SetModel(const ModelConfig &); function is introduced. Users are supposed to pass all the model information using the; ModelConfig class rather than via the; RooWorkspace or specifying directly the pdf and parameter; objects in the constructors. ; Setter methods using pdf instances an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:11143,user-friendly,user-friendly,11143,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['user-friendly'],['user-friendly']
Usability,"stered object can be requested and displayed in the web browser. There are many benefits of such approach:. * standard http interface to ROOT application; * no any temporary ROOT files to access data; * user interface running in all browsers. ## Starting the HTTP server. To start the http server, at any time, create an instance of the [THttpServer](https://root.cern/doc/master/classTHttpServer.html) class like:. ```cpp; auto serv = new THttpServer(""http:8080"");; ```. This will start a [civetweb](https://github.com/civetweb/civetweb)-based http server on the port 8080. Then one should be able to open the address `http://localhost:8080` in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics. There is a [server snapshot](https://root.cern/js/latest/httpserver.C/?layout=simple&item=Canvases/c1) of running macro [tutorials/http/httpserver.C](https://github.com/root-project/root/blob/master/tutorials/http/httpserver.C) from ROOT tutorials. One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:. ```cpp; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; ```. Following URL parameters are supported:. | Name | Description |; | :-------------------- | :---------------- |; | thrds=N | number of threads used by the civetweb (default is 10) |; | top=name | configure top name, visible in the web browser |; | auth_file=filename | authentication file name, created with htdigets utility |; | auth_domain=domain | authentication domain |; | loopback | bind specified port to loopback 127.0.0.1 address |; | debug | enable debug mode, server returns html page with request info |; | websocket_timeout=tm | set web sockets timeout in seconds (default 300) |; | websocket_disable | disable web sockets handlin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:1130,simpl,simple,1130,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['simpl'],['simple']
Usability,"stomizations, from a custom style; to custom links, to customized java scripts. By default, the style sheet; is taken from `$ROOTSYS/etc/html/ROOT.css` when the documentation is; generated. The path for `ROOT.css` can be changed by calling; `THtml::SetEtcDir()`; it should contain the same CSS classes and entity; IDs as the original `ROOT.css`. This style sheet is an easy means of; customizing the layout and appearance of the documentation pages. Many; of **`THtml`** setting can be customized by calls to **`THtml`** member; functions or by settings in .rootrc, as documented in the **`THtml`**; class reference page <http://root.cern.ch/root/html/THtml>. The; following will enumerate some of the highlights. ### Referencing Documentation for other Libraries. When **`THtml`** generates documentation for classes it recognizes all; class names known to ROOT. If **`THtml`** does not have sources for a; class it determines the class's library name. This has to be set by; means of `rootmap` files, see Library AutoLoading of this User's Guide.; Given the library name, **`THtml`** searches for an entry in its map of; libraries to documentation URLs. If it finds it, it will create a link; to the documentation at that URL for all occurrences of a given class; name. One can set the URL `../mylib/` for a library name `MyLib` by; setting `Root.Html.MyLib:` `../mylib/` or by calling; `THtml::SetLibURL(""MyLib"", ""../mylib/"")`. Occurrences of class `MyClass`; of `MyLib` will now be referenced as `../mylib/MyClass.html`. ### Search Engine. **`THtml`** can invoke external search engines. The ROOT reference guide; sets `Root.Html.Search` to <http://www.google.com/search?q=%s+site%3A%u>.; Calling **`THtml::SetSearchStemURL()`** will set the same. If this URL stem is; set, `THtml` will create search fields in the index pages. It will; send the words entered in these search fields as %s in the URL; %u will; be replaced by the current document's path, allowing a site- and; directory-specific se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:9969,Guid,Guide,9969,documentation/users-guide/HTMLDoc.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md,1,['Guid'],['Guide']
Usability,"stroy_fn = 0x402000 <coro_task(int)>, __promise = {...}, ...}. The above is possible because:. (1) The name of the debug type of the coroutine frame is the `linkage_name`,; plus the `.coro_frame_ty` suffix because each coroutine function shares the; same coroutine type. (2) The coroutine function name is accessible from the address of the coroutine; frame. The above commands can be simplified by placing them in debug scripts. Examples to print coroutine frames; ----------------------------------. The print examples below use the following definition:. .. code-block:: c++. #include <coroutine>; #include <iostream>. struct task{; struct promise_type {; task get_return_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_coun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:6478,resume,resume,6478,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability,"structor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameterState&,\; const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes; minimization of the $\mbox{FCN}$ and returns the result in form of a; FunctionMinimum. Minimization terminates either when the function has; been called (approximately) $\mbox{maxfcn}$ times, or when the; estimated vertical distance to minimum ($\mbox{EDM}$) is less than; $\mbox{tolerance*up}$. The default value of $\mbox{tolerance}$; is $\mbox{0.1}$. (see [howto:errordef]). ### Parameter interaction ###. MnSimplex retains the result after each minimization; (MnUserParameterStae, see [api:state]) and forwards the interface for; parameter interaction. ### SimplexMinimizer() ###. The SimplexMinimizer() is instantiated using default constructor. ### minimize(const FCNBase&, ...) ###. The SimplexMinimizer provides several overloaded methods minimize with; return value FunctionMinimum. Together with the user $\mbox{FCN}$; (either an implementation of FCNBase or FCNGradientBase) the user has to; give as input the parameters with starting values in one of the defined; formats (std::vector$<$double$>$, MnUserParameters or; MnUserParameterState). ## MnStrategy ##. [api:strategy] Sets the strategy to be used in calculating first and; second derivatives and in certain minimization methods. In general, low; values of $\mbox{level}$ mean fewer function calls and high values; mean more reliable minimization. Currently allowed values are 0 (low), 1; (default), and 2 (high). ### MnStrategy() ###. Default constructor, sets all settings according to; $\mbox{level}$$ = 1.$. ### MnStrategy(unsigned int level) ###. Explicit constructor for predefined settings of desired; $\mbox{level}$ 0 (low), 1 (default), or ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:50432,Simpl,SimplexMinimizer,50432,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['Simpl'],['SimplexMinimizer']
Usability,"subdivisions, called pads; c1.cd(1); //change to pad 1 of canvas c1; ```. These parts of a well-written macro are pretty standard, and you should; remember to include pieces of code like in the examples above to make; sure your plots always look as you had intended. Below, in section [Interpretation and Compilation](#interpretation-and-compilation), some more code fragments; will be shown, allowing you to use the system compiler to compile macros for; more efficient execution, or turn macros into stand-alone applications linked; against the ROOT libraries. ## A more complete example ##. Let us now look at a rather complete example of a typical task in data; analysis, a macro that constructs a graph with errors, fits a (linear); model to it and saves it as an image. To run this macro, simply type in; the shell:. ``` {.cpp}; > root macro1.C; ```. The code is built around the ROOT class `TGraphErrors`, which was; already introduced previously. Have a look at it in the class reference; guide, where you will also find further examples. The macro shown below; uses additional classes, `TF1` to define a function, `TCanvas` to define; size and properties of the window used for our plot, and `TLegend` to; add a nice legend. For the moment, ignore the commented include; statements for header files, they will only become important at the end; in section [Interpretation and Compilation](#interpretation-and-compilation). ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro1.C; ```. Let's comment it in detail:. - Line *13*: the name of the principal function (it plays the role of; the ""main"" function in compiled programs) in the macro file. It has; to be the same as the file name without extension. - Line *24-25*: instance of the `TGraphErrors` class. The constructor; takes the number of points and the pointers to the arrays of; x values, y values, x errors (in this case none,; represented by the NULL pointer) and y errors. The second line; defines in one shot the title of the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:2961,guid,guide,2961,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['guid'],['guide']
Usability,"supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdirectories. This is also possible through the command line, e.g.:; ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5808,guid,guide,5808,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['guid'],['guide']
Usability,"system. :doc:`BugLifeCycle`; Describes how bugs are reported, triaged and closed. :doc:`CodingStandards`; Details the LLVM coding standards and provides useful information on writing; efficient C++ code. :doc:`GitHub`; Describes how to use the llvm-project repository and code reviews on GitHub. :doc:`GitBisecting`; Describes how to use ``git bisect`` on LLVM's repository. :doc:`GitRepositoryPolicy`; Collection of policies around the git repositories. .. _development-process:. Development Process; -------------------. Information about LLVM's development process. .. toctree::; :hidden:. Projects; HowToReleaseLLVM; Packaging; ReleaseProcess; HowToAddABuilder; ReleaseNotes. :doc:`Projects`; How-to guide and templates for new projects that *use* the LLVM; infrastructure. The templates (directory organization, Makefiles, and test; tree) allow the project code to be located outside (or inside) the ``llvm/``; tree, while using LLVM header files and libraries. :doc:`HowToReleaseLLVM`; This is a guide to preparing LLVM releases. Most developers can ignore it. :doc:`ReleaseProcess`; This is a guide to validate a new release, during the release process. Most developers can ignore it. :doc:`HowToAddABuilder`; Instructions for adding new builder to LLVM buildbot master. :doc:`Packaging`; Advice on packaging LLVM into a distribution. :doc:`Release notes for the current release <ReleaseNotes>`; This describes new features, known bugs, and other limitations. .. _lists-forums:. Forums & Mailing Lists; ----------------------. If you can't find what you need in these docs, try consulting the; Discourse forums. There are also commit mailing lists for all commits to the LLVM Project.; The :doc:`CodeOfConduct` applies to all these forums and mailing lists. `LLVM Discourse`__; The forums for all things LLVM and related sub-projects. There are categories and subcategories for a wide variety of areas within LLVM. You can also view tags or search for a specific topic. .. __: https://discourse",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:1899,guid,guide,1899,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['guid'],['guide']
Usability,"t LLVM; supports, even emitting C code and compiling that on targets that LLVM; doesn't support natively. You can trivially tell that the Kaleidoscope; compiler generates target-independent code because it never queries for; any target-specific information when generating code. The fact that LLVM provides a compact, target-independent,; representation for code gets a lot of people excited. Unfortunately,; these people are usually thinking about C or a language from the C; family when they are asking questions about language portability. I say; ""unfortunately"", because there is really no way to make (fully general); C code portable, other than shipping the source code around (and of; course, C source code is not actually portable in general either - ever; port a really old application from 32- to 64-bits?). The problem with C (again, in its full generality) is that it is heavily; laden with target specific assumptions. As one simple example, the; preprocessor often destructively removes target-independence from the; code when it processes the input text:. .. code-block:: c. #ifdef __i386__; int X = 1;; #else; int X = 42;; #endif. While it is possible to engineer more and more complex solutions to; problems like this, it cannot be solved in full generality in a way that; is better than shipping the actual source code. That said, there are interesting subsets of C that can be made portable.; If you are willing to fix primitive types to a fixed size (say int =; 32-bits, and long = 64-bits), don't care about ABI compatibility with; existing binaries, and are willing to give up some other minor features,; you can have portable code. This can make sense for specialized domains; such as an in-kernel language. Safety Guarantees; -----------------. Many of the languages above are also ""safe"" languages: it is impossible; for a program written in Java to corrupt its address space and crash the; process (assuming the JVM has no bugs). Safety is an interesting; property that requi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:7056,simpl,simple,7056,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['simpl'],['simple']
Usability,"t conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAnyOfnodeMatcherFunction...; Matches any of the NodeMatchers with InnerMatchers nested within. Given; if (true);; for (; true; );; with the matcher; mapAnyOf(ifStmt, forStmt).with(; hasCondition(cxxBoolLiteralExpr(equals(true))); ).bind(""trueCond""); matches the if and the for. It is equivalent to:; auto trueCond = hasCondition(cxxBoolLiteralExpr(equals(true)));; anyOf(; ifStmt(trueCond).bind(""trueCond""),; forStmt(trueCond).bind(""trueCond""); );. The with() chain-call accepts zero or more matchers which are combined; as-if with allOf() in each of the node matchers.; Usable as: Any Matcher. Matcher<*>unlessMatcher<*>; Matches if the provided matcher does not match. Example matches Y (matcher = cxxRecordDecl(unless(hasName(""X"")))); class X {};; class Y {};. Usable as: Any Matcher. Matcher<Attr>isImplicit; Matches an entity that has been implicitly added by the compiler (e.g.; implicit default/copy constructors). Matcher<BinaryOperator>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator expressions (binary or unary) that have any of the; specified names. hasAnyOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOperatorName(""+""), hasOperatorName(""-"")). Matcher<BinaryOperator>hasOperatorNamestd::string Name; Matches the operator Name of operator expressions and fold expressions; (binary or unary). Example matches a || b (matcher = binaryOperator(hasOperatorName(""||""))); !(a || b). Example matches `(0 + ... + args)`; (matcher = cxxFoldExpr(hasOperatorName(""+""))); template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<BinaryOperator>isAssignmentOperator; Matches all kinds of assignment operators. Example 1: matches a += b (matcher = binaryOperator(isAssignmentOperator())); if (a == b); a += b;. Example 2: ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:55055,Usab,Usable,55055,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"t either using; the standard EBP register or as the first parameter register, depending on the; architecture. The funclet implements the EH action by accessing local variables; in memory through the frame pointer, and returning some appropriate value,; continuing the EH process. No variables live in to or out of the funclet can be; allocated in registers. The C++ personality also uses funclets to contain the code for catch blocks; (i.e. all user code between the braces in ``catch (Type obj) { ... }``). The; runtime must use funclets for catch bodies because the C++ exception object is; allocated in a child stack frame of the function handling the exception. If the; runtime rewound the stack back to frame of the catch, the memory holding the; exception would be overwritten quickly by subsequent function calls. The use of; funclets also allows ``__CxxFrameHandler3`` to implement rethrow without; resorting to TLS. Instead, the runtime throws a special exception, and then uses; SEH (``__try / __except``) to resume execution with new information in the child; frame. In other words, the successive unwinding approach is incompatible with Visual; C++ exceptions and general purpose Windows exception handling. Because the C++; exception object lives in stack memory, LLVM cannot provide a custom personality; function that uses landingpads. Similarly, SEH does not provide any mechanism; to rethrow an exception or continue unwinding. Therefore, LLVM must use the IR; constructs described later in this document to implement compatible exception; handling. SEH filter expressions; -----------------------. The SEH personality functions also use funclets to implement filter expressions,; which allow executing arbitrary user code to decide which exceptions to catch.; Filter expressions should not be confused with the ``filter`` clause of the LLVM; ``landingpad`` instruction. Typically filter expressions are used to determine; if the exception came from a particular DLL or code region, o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:23291,resume,resume,23291,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['resume'],['resume']
Usability,"t in many different ways. In addition; to adding new features (LLVM did not always support exceptions or debug; info), we also extend the IR to capture important information for; optimization (e.g. whether an argument is sign or zero extended,; information about pointers aliasing, etc). Many of the enhancements are; user-driven: people want LLVM to include some specific feature, so they; go ahead and extend it. Third, it is *possible and easy* to add language-specific optimizations,; and you have a number of choices in how to do it. As one trivial; example, it is easy to add language-specific optimization passes that; ""know"" things about code compiled for a language. In the case of the C; family, there is an optimization pass that ""knows"" about the standard C; library functions. If you call ""exit(0)"" in main(), it knows that it is; safe to optimize that into ""return 0;"" because C specifies what the; 'exit' function does. In addition to simple library knowledge, it is possible to embed a; variety of other language-specific information into the LLVM IR. If you; have a specific need and run into a wall, please bring the topic up on; the llvm-dev list. At the very worst, you can always treat LLVM as if it; were a ""dumb code generator"" and implement the high-level optimizations; you desire in your front-end, on the language-specific AST. Tips and Tricks; ===============. There is a variety of useful tips and tricks that you come to know after; working on/with LLVM that aren't obvious at first glance. Instead of; letting everyone rediscover them, this section talks about some of these; issues. Implementing portable offsetof/sizeof; -------------------------------------. One interesting thing that comes up, if you are trying to keep the code; generated by your compiler ""target independent"", is that you often need; to know the size of some LLVM type or the offset of some field in an; llvm structure. For example, you might need to pass the size of a type; into a function that",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:10827,simpl,simple,10827,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['simpl'],['simple']
Usability,"t is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs containing scalable vectors cannot be used in allocas unless all; fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>,; <vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x i32>,; <vscale x 2 x i64>}`` doesn't). Semantics:; """""""""""""""""""". Memory is allocated; a pointer is returned. The allocated memory is; uninitialized, and loading from uninitialized memory produces an undefined; value. The operation itself is undefined if there is insufficient stack; space for the allocation.'``alloca``'d memory is automatically released; when the function returns. The '``alloca``' instruction is commonly used; to represent automatic variables that must have an address available. When; the function returns (either with the ``ret`` or ``resume`` instructions),; the memory is reclaimed. Allocating zero bytes is legal, but the returned; pointer may not be unique. The order in which memory is allocated (ie.,; which way the stack grows) is not specified. Note that '``alloca``' outside of the alloca address space from the; :ref:`datalayout string<langref_datalayout>` is meaningful only if the; target has assigned it a semantics. If the returned pointer is used by :ref:`llvm.lifetime.start <int_lifestart>`,; the returned object is initially dead.; See :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` for the precise semantics of; lifetime-manipulating intrinsics. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; %ptr = alloca i32, i32 4 ; yields ptr; %ptr = alloca i32, i32 4, align 1024 ; yields ptr; %ptr = alloca i32, align 1024 ; yields ptr. .. _i_load:. '``load``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = load [volatile] <ty>, pt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:410932,resume,resume,410932,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability,"t native support for a given type, the specified type; may be promoted to a larger type that is supported. For example, SPARC does; not support a sign-extending load for Boolean values (``i1`` type), so in; ``SparcISelLowering.cpp`` the third parameter below, ``Promote``, changes; ``i1`` type values to a large type before loading. .. code-block:: c++. setLoadExtAction(ISD::SEXTLOAD, MVT::i1, Promote);. Expand; ^^^^^^. For a type without native support, a value may need to be broken down further,; rather than promoted. For an operation without native support, a combination; of other operations may be used to similar effect. In SPARC, the; floating-point sine and cosine trig operations are supported by expansion to; other operations, as indicated by the third parameter, ``Expand``, to; ``setOperationAction``:. .. code-block:: c++. setOperationAction(ISD::FSIN, MVT::f32, Expand);; setOperationAction(ISD::FCOS, MVT::f32, Expand);. Custom; ^^^^^^. For some operations, simple type promotion or operation expansion may be; insufficient. In some cases, a special intrinsic function must be implemented. For example, a constant value may require special treatment, or an operation; may require spilling and restoring registers in the stack and working with; register allocators. As seen in ``SparcISelLowering.cpp`` code below, to perform a type conversion; from a floating point value to a signed integer, first the; ``setOperationAction`` should be called with ``Custom`` as the third parameter:. .. code-block:: c++. setOperationAction(ISD::FP_TO_SINT, MVT::i32, Custom);. In the ``LowerOperation`` method, for each ``Custom`` operation, a case; statement should be added to indicate what function to call. In the following; code, an ``FP_TO_SINT`` opcode will call the ``LowerFP_TO_SINT`` method:. .. code-block:: c++. SDValue SparcTargetLowering::LowerOperation(SDValue Op, SelectionDAG &DAG) {; switch (Op.getOpcode()) {; case ISD::FP_TO_SINT: return LowerFP_TO_SINT(Op, DAG);; ...; }; }.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:59603,simpl,simple,59603,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['simpl'],['simple']
Usability,"t of objects. For; now, we assume that the types we want to cast *to* all provide ``classof``. So; we can use some provided cast traits like so:. .. code-block:: c++. template <typename T>; struct CastInfo<T, SomeValue>; : CastIsPossible<T, SomeValue>, NullableValueCastFailed<T>,; DefaultDoCastIfPossible<T, SomeValue, CastInfo<T, SomeValue>> {; static T doCast(SomeValue v) {; return T(v.getPointer());; }; };. Pointer to value casting; ------------------------; Now given the value above ``SomeValue``, maybe we'd like to be able to cast to; that type from a char pointer type. So what we would do in that case is:. .. code-block:: c++. template <typename T>; struct CastInfo<SomeValue, T *>; : NullableValueCastFailed<SomeValue>,; DefaultDoCastIfPossible<SomeValue, T *, CastInfo<SomeValue, T *>> {; static bool isPossible(const T *t) {; return std::is_same<T, char>::value;; }; static SomeValue doCast(const T *t) {; return SomeValue((void *)t);; }; };. This would enable us to cast from a ``char *`` to a SomeValue, if we wanted to. Optional value casting; ----------------------; When your types are not constructible from ``nullptr`` or there isn't a simple; way to tell when an object is invalid, you may want to use ``std::optional``.; In those cases, you probably want something like this:. .. code-block:: c++. template <typename T>; struct CastInfo<T, SomeValue> : OptionalValueCast<T, SomeValue> {};. That cast trait requires that ``T`` is constructible from ``const SomeValue &``; but it enables casting like so:. .. code-block:: c++. SomeValue someVal = ...;; std::optional<AnotherValue> valOr = dyn_cast<AnotherValue>(someVal);. With the ``_if_present`` variants, you can even do optional chaining like this:. .. code-block:: c++. std::optional<SomeValue> someVal = ...;; std::optional<AnotherValue> valOr = dyn_cast_if_present<AnotherValue>(someVal);. and ``valOr`` will be ``std::nullopt`` if either ``someVal`` cannot be converted *or*; if ``someVal`` was also ``std::nullopt``.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:17255,simpl,simple,17255,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['simpl'],['simple']
Usability,"t off); - no_screen - let ignore kVisOnScreen bits for nodes visibility; - dray - calculate rendering order using raytracing (extensive calculations); - dbox - use distance to nearest point from bounding box for rendering order (default); - dpnt - use distance to shape center as rendering order; - dsize - use volume size as rendering order; - ddflt - let three.js to calculate rendering order; - comp - show left and right components of TGeoCompositeShape; - compx - show all sub-components of TGeoCompositeShape. In the URL string several global settings can be changed:. - geosegm - grads per segment is cylindrical shapes, default is 6; - geocomp - compress results of composite shape production, default is true. It is possible to display only part of geometry model. For instance, one could select sub-item like:. - [file=rootgeom.root&item=simple1/TOP/REPLICA_1](https://root.cern/js/latest/?file=../files/geom/rootgeom.root&item=simple1/TOP/REPLICA_1). Or one can use simple selection syntax (work only with first-level volumes):. - [item=simple1&opt=-bar1-bar2](https://root.cern/js/latest/?file=../files/geom/rootgeom.root&item=simple1;1&opt=-bar1-bar2). Syntax uses '+' sign to enable visibility flag of specified volume and '-' sign to disable visibility.; One could use wildcard symbol like '+TUBE1*'. Another way to configure visibility flags is usage of ROOT macros, which typically looks like:. ```cpp; {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; // gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""HALL"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCC"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCA"")->InvisibleAll();; // ...; gGeoManager->GetVolume(""ALIC"")->Draw(""ogl"");; new TBrowser;; }; ```. Example of such macro can be found in root tutorials. From provided macro only following calls will be executed in JSROOT:. * `gGeoManager->DefaultColors()`; * `gGeoManager->GetVolume(""HALL"")->InvisibleAll()`; * `gGeoManager->Get",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:22737,simpl,simple,22737,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['simpl'],['simple']
Usability,"t search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if they are explicitly specified via ``-fmodule-map-file`` or transitively used by another module map file. ``-fmodules-cache-path=<directory>``; Specify the path to the modules cache. If not provided, Clang will select a system-appropriate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname``; Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don't affect how modules are built, to improve sharing of compiled module files. ``-fmodules-prune-interval=seconds``; Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:15577,clear,clear,15577,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['clear'],['clear']
Usability,"t suitable for; embedding in datastructures in most cases (instead, use an std::string or; something like that). #. For the same reason, StringRef cannot be used as the return value of a; method if the method ""computes"" the result string. Instead, use std::string. #. StringRef's do not allow you to mutate the pointed-to string bytes and it; doesn't allow you to insert or remove bytes from the range. For editing; operations like this, it interoperates with the :ref:`Twine <dss_twine>`; class. Because of its strengths and limitations, it is very common for a function to; take a StringRef and for a method on an object to return a StringRef that points; into some string that it owns. .. _dss_twine:. llvm/ADT/Twine.h; ^^^^^^^^^^^^^^^^. The Twine class is used as an intermediary datatype for APIs that want to take a; string that can be constructed inline with a series of concatenations. Twine; works by forming recursive instances of the Twine datatype (a simple value; object) on the stack as temporary objects, linking them together into a tree; which is then linearized when the Twine is consumed. Twine is only safe to use; as the argument to a function, and should always be a const reference, e.g.:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; foo(X + ""."" + Twine(i));. This example forms a string like ""blarg.42"" by concatenating the values; together, and does not form intermediate strings containing ""blarg"" or ""blarg."". Because Twine is constructed with temporary objects on the stack, and because; these instances are destroyed at the end of the current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient tha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:73806,simpl,simple,73806,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"t the drawn objects. The; ""memory leak"" is intentional, to make the object existing also out; of the macro1 scope. - Line *36*: the method *DrawClone* draws a clone of the object on the; canvas. It *has to be* a clone, to survive after the scope of; `macro1`, and be displayed on screen after the end of the macro; execution. The string option ""APE"" stands for:. - *A* imposes the drawing of the Axes. - *P* imposes the drawing of the graph's markers. - *E* imposes the drawing of the graph's error bars. - Line *39*: define a mathematical function. There are several ways to; accomplish this, but in this case the constructor accepts the name; of the function, the formula, and the function range. - Line *41*: maquillage. Try to give a look to the line styles at your; disposal visiting the documentation of the `TLine` class. - Line *43*: fits the *f* function to the graph, observe that the; pointer is passed. It is more interesting to look at the output on; the screen to see the parameters values and other crucial; information that we will learn to read at the end of this guide. - Line *44*: again draws the clone of the object on the canvas. The; ""Same"" option avoids the cancellation of the already drawn objects,; in our case, the graph. The function *f* will be drawn using the *same* axis; system defined by the previously drawn graph. - Line *47-52*: completes the plot with a legend, represented by a; `TLegend` instance. The constructor takes as parameters the lower; left and upper right corners coordinates with respect to the total; size of the canvas, assumed to be 1, and the legend header string.; You can add to the legend the objects, previously drawn or not; drawn, through the `addEntry` method. Observe how the legend is; drawn at the end: looks familiar now, right ?. - Line *55-57*: defines an arrow with a triangle on the right hand; side, a thickness of 2 and draws it. - Line *60-61*: interpret a Latex string which hast its lower left; corner located in the specified",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:5299,learn,learn,5299,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,2,"['guid', 'learn']","['guide', 'learn']"
Usability,"t the; interactions between various memory operations. Its goal is to replace; ``MemoryDependenceAnalysis`` for most (if not all) use-cases. This is because,; unless you're very careful, use of ``MemoryDependenceAnalysis`` can easily; result in quadratic-time algorithms in LLVM. Additionally, ``MemorySSA`` doesn't; have as many arbitrary limits as ``MemoryDependenceAnalysis``, so you should get; better results, too. One common use of ``MemorySSA`` is to quickly find out; that something definitely cannot happen (for example, reason that a hoist; out of a loop can't happen). At a high level, one of the goals of ``MemorySSA`` is to provide an SSA based; form for memory, complete with def-use and use-def chains, which; enables users to quickly find may-def and may-uses of memory operations.; It can also be thought of as a way to cheaply give versions to the complete; state of memory, and associate memory operations with those versions. This document goes over how ``MemorySSA`` is structured, and some basic; intuition on how ``MemorySSA`` works. A paper on MemorySSA (with notes about how it's implemented in GCC) `can be; found here <http://www.airs.com/dnovillo/Papers/mem-ssa.pdf>`_. Though, it's; relatively out-of-date; the paper references multiple memory partitions, but GCC; eventually swapped to just using one, like we now have in LLVM. Like; GCC's, LLVM's MemorySSA is intraprocedural. MemorySSA Structure; ===================. MemorySSA is a virtual IR. After it's built, ``MemorySSA`` will contain a; structure that maps ``Instruction``\ s to ``MemoryAccess``\ es, which are; ``MemorySSA``'s parallel to LLVM ``Instruction``\ s. Each ``MemoryAccess`` can be one of three types:. - ``MemoryDef``; - ``MemoryPhi``; - ``MemoryUse``. ``MemoryDef``\ s are operations which may either modify memory, or which; introduce some kind of ordering constraints. Examples of ``MemoryDef``\ s; include ``store``\ s, function calls, ``load``\ s with ``acquire`` (or higher); ordering, volatile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:1170,intuit,intuition,1170,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['intuit'],['intuition']
Usability,"t the; output to an area specific to the logged user.; Addition of a new class TProofProgressStatus, which is used to keep; the query progress stauts in all the TProofPlayer objects and in the; TPacketizerAdaptive. It is also send in kPROOF_GETPACKET and; kPROOF_STOPPROCESS messages. ; The class TPacketizerProgressive is removed. . Fixes. Enable; the max number of sessions ('mxsess' parameter in the xpd.schedparam; directive); users are just refused to start a session if this limit is; reached.Make sure to collect consistently input messages when running in asynchronous modeFix; a few problems with TProof::SendFile (used by UploadPackage, Load); appearing when a rapid sequence of these commands was submitted Invalidate the TProofMgr when the physical connection is; closed; avoids; crashing when trying to get the logs after a failure. ; Fix a memory leak in log retrieval (the TProofLog object; was never; deleted); Add protections for the cases the manager cannot be; initialized; Fix a race condition possibly affecting the handling of; workers death; Avoid duplicating worker logs in the master log file; unless; when explicitly needed by the request (Exec(...), Print(...)) or when; an error occuredFix; problem with the determination and transmission of the name of the; object to be processed. The problem appeared when processing files; containing >1 trees in changing order.Fix problem with TProof::Load loading the macro to one worker only per machineFix wrong return code preventing the correct propagation of the full ClearPackage to workersFix a problem causing the whole query to stop even in the case a worker was terminated gently with SIGTERM.; Fix a problem triggering full re-build of a package upon change of a; single file; the version info file was wrongly reset; this should; happen only after a re-build.Make sure that in case multiple TProofOutputFile are present, each get merged correctlyFix problem in TProofServLogHandler::Notify due to bad usage of Form(...). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:7138,Clear,ClearPackage,7138,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['Clear'],['ClearPackage']
Usability,"t this change is not backward compatible.; Add the option to use binned generation (via SetGenerateBinned).; An estimated of the error in the obtained p values is now computed in the HybridResult class thanks to Matthias Wolf. The errors can be obtained with HybridResult::CLbError(), HybridResult::CLsplusbError() or HybridResult::CLsError().; A new tutorial has been added for showing the usage of the hybrid calculator: rs505_HybridCalculator_significance.C. new class HypoTestInverter. New class for performing an hypothesis test inversion by scanning; the hypothesis test results of the HybridCalculator for; various values of the parameter of interest. An upper (or lower) limit can be derived by looking at the; confidence level curve of the result as function of the parameter of; interest, where it intersects the desired confidence level. The class implements the IntervalCalculator interface and returns an HypoTestInverterResult class. The result is a SimpleInterval, which via the method UpperLimit returns to the user the upper limit value. The HypoTestInverter implements various option for performing the scan. HypoTestInverter::RunFixedScan will scan using a fixed grid the parameter of interest. HypoTestInverter::RunAutoScan will perform an automatic scan to find optimally the curve and it will stop when the desired precision is obtained.; The confidence level value at a given point can also be done via HypoTestInverter::RunOnePoint.; The class can scan the CLs+b values (default) or alternatively CLs (if the; method HypoTestInverter::UseCLs has been called).; The estimated error due to the MC toys statistics from the HybridCalculator is propagated into the limits obtained from the HypoTestResult; A new tutorial rs801_HypoTestInverter.C has been added in the tutorials/roostats directory to show the usage of this class. New class BayesianCalculator. New class for calculating Bayesian interval using numerical integration. It implements the IntervalCalculator interface an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:15034,Simpl,SimpleInterval,15034,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['Simpl'],['SimpleInterval']
Usability,"t to emphasize; > portability and safety like the Java VM? Or shall we focus on the; > architecture interface first (i.e., consider the code generation and; > processor issues), since the architecture interface question is also; > important for portable Java-type VMs?. I forsee the architecture looking kinda like this: (which is completely; subject to change). 1. The VM code is NOT guaranteed safe in a java sense. Doing so makes it; basically impossible to support C like languages. Besides that,; certifying a register based language as safe at run time would be a; pretty expensive operation to have to do. Additionally, we would like; to be able to statically eliminate many bounds checks in Java; programs... for example. 2. Instead, we can do the following (eventually): ; * Java bytecode is used as our ""safe"" representation (to avoid; reinventing something that we don't add much value to). When the; user chooses to execute Java bytecodes directly (ie, not; precompiled) the runtime compiler can do some very simple; transformations (JIT style) to convert it into valid input for our; VM. Performance is not wonderful, but it works right.; * The file is scheduled to be compiled (rigorously) at a later; time. This could be done by some background process or by a second; processor in the system during idle time or something...; * To keep things ""safe"" ie to enforce a sandbox on Java/foreign code,; we could sign the generated VM code with a host specific private; key. Then before the code is executed/loaded, we can check to see if; the trusted compiler generated the code. This would be much quicker; than having to validate consistency (especially if bounds checks have; been removed, for example). > This is important because the audiences for these two goals are very; > different. Architects and many compiler people care much more about; > the second question. The Java compiler and OS community care much more; > about the first one. 3. By focusing on a more low level virtual m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:1324,simpl,simple,1324,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,1,['simpl'],['simple']
Usability,"t to see the effect. #### Manipulators. *Manipulators* are GUI ‘widgets' or controls attached to a 3D object in; the viewer, allowing a direct manipulation of the object's geometry.; There are three manipulators for the three basic geometries; transformations. In each case, the *manipulator* consists of three; components, one for each local axis of the object, shown in standard; colors: red (X), green (Y) and blue (Z). ![GL Viewer object manipulators](pictures/030000DE.png). Activate the *manipulator* by moving the mouse over one of these; components (which turns yellow to indicate active state). Click with; left mouse and drag this active component to perform the manipulation.; Toggle between the *manipulator* types using the ‘x', ‘c', ‘v' keys; while the mouse cursor is above the manipulator. Note: Manipulators; cannot be controlled via the API at present. #### Guides. Guides are visual aids drawn into the viewer world. Controls for these; are under the ""Guides"" tab:. Viewer Controls Pane Guides Tab. Axes show the world (global) frame *coordinate*directions: X (red), Y; (green) and Z (blue). The negative portion of the *axis* line is shown; in dark color, the positive in bright. The *axis* name and minimum /; maximum values are labeled in the same color. There are three options; for *axes* drawing - selected by radio buttons:. - None - not drawn (default). - Edge - draw axes on the (minimum) edge of the scene extents box. - Origin - drawn axes through the origin. For *edge axes*, the zero value for each axis is marked on the axis line; with a colored sphere. For *origin axes,* a single white sphere is shown; at the origin. *Edge axes* are depth clipped - i.e. are obscured by 3D objects in front; of them. *Origin axes* (which generally pass through the middle of the; 3D scene) are not depth clipped - so always visible. A single orange sphere of fixed view port (window) size can be shown at; any arbitrary position. Enable / disable the drawing with ‘*Show'*; checkbox",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:117097,Guid,Guides,117097,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['Guid'],['Guides']
Usability,"t type; Int_t type = 111; //portrait ps; // Int_t type = 112; //landscape ps; // Int_t type = 113; //eps. //create a PostScript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a script; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; ```. The next example does the same:. ``` {.cpp}; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. //set x,y of printed page; gStyle->SetPaperSize(16,24);. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1->Print(""test1.ps("", ""Portrait"");; hprof->Draw();; c1->Print(""test1.ps"");; hpx->Draw(""lego1"");; c1->Print(""test1.ps)"");; }; ```. This following example shows two pages. The canvas is divided.; `TPostScript::NewPage` must be called before starting a new picture.; `object->Draw` does not clear the canvas in this case because we clear; only the pads and not the main canvas. Note that `c1->Update` must be; called at the end of the first picture. ``` {.cpp}; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; TPostScript *ps = new TPostScript(""file.ps"",112);. // picture 1; c1->Divide(2,1);; ps->NewPage();; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();. // picture 2; c1->Update();; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();. // invoke PostScript viewer; gSystem->Exec(""gs file.ps"");; }; ```. The next one does the same:. ``` {.cpp}; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; c1->Divide(2,1);. // picture 1; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();; c1->Print(""test2.ps("", ""Landscape"");. // picture 2; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Print(""test2.ps)"");; gSystem->Exec(""gs file.ps""); // invoke PostScript viewer; }; ```; ### The Color Model",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:98199,clear,clear,98199,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,2,['clear'],['clear']
Usability,"t visible.; TEveRGBAPalette - implement additional flag fFixColorRange specifying; how the palette color range gets mapped onto signal values:; true - LowLimit -> HighLimit; false - MinValue -> MaxValue.; Add signal emitting TEveRGBAPalette::MinMaxValChanged(). Ged; editor calls this after setting the min/max range. OpenGL; Major changes. Add support for stereo rendering. This requires quad buffer; support from OpenGL driver and hardware as well as shutter; glasses. See tutorial eve/geom_cms_stereo.C.; Support for rendering into frame-buffer objects (FBO).; Using FBOs, it is now possible to save bitmap image formats at; any resolution and even when the GL window is not on screen.; Add support for global scaling of point-sizes, line-widths and font-sizes.; Generalize secondary-selection handling so that it is possible to; implement various handling schemes. For example see individual; calorimeter tower selection in TEveCalo-classes.; Generalize handling of highlight feedback -- this is now done via; a virtual TGLLogicalShape::DrawHighlight(...) so that it can be; changed by sub-classes.; The stand-alone GL viewer now supports hiding of menu-bar. It; collapses into a narrow band on top of the viewer that expands when; mouse pointer enters its area. This allows for better utilization of; the screen while still providing the controls available from the menu.; Editor for ""gl5d"" option was improved.; TGLTH3Composition class to combine several TH3s in one plot. Minor changes. Use Diagonal() instead of Volume() to determine if a bounding-box; is empty and also for sorting of the scene-elements by size. The; previous implementation caused problems with 2D and 1D objects.; Several improvements in camera configuration and handling.; Improve mouse-button handling. After a button goes down, other; buttons do not interfere with user interaction until the first button; is released.; When initializing TGLClipPlane for the first time, place it in; the center of the scene's bounding-b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html:5539,feedback,feedback,5539,graf3d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html,1,['feedback'],['feedback']
Usability,"t were lost. ### TDirectory::TContext. We added a default constructor to `TDirectory::TContext` which record the current directory; and will restore it at destruction time and does not change the current directory. The constructor for `TDirectory::TContext` that takes a single TDirectory pointer as; an argument was changed to set `gDirectory` to zero when being passed a null pointer;; previously it was interpreting a null pointer as a request to *not* change the current; directory - this behavior is now implement by the default constructor. ### Collections. In THashList and THashTable, GetListForObject now returns a pointer to const as modifying the returned list (in particular adding to it) can break invariant of THashTable so we need to clearly mark the list as not being allowed to be modified. In TSeqCollection::Merge, we no longer delete the object in the case where the original collection is marked as a owner. We resolved a memory leakage occuring as a consequence of repeated calls to `TClonesArray::AbsorbObjects` and `TClonesArray::Clear` [ROOT-6996]. A similar problem was affecting `TClonesArray::operator=`, `TClonesArray::Expand` and `TClonesArray::ExpandCreate` and was also solved. `TClonesArray` reliance on global state during the destruction of the elements was decreased (removing use of `TObject::SetDtorOnly`). ### Global resources. Several tweaks to if and when, resources held by the global ROOT object (TROOT, TApplication) are deleted. When the default TApplication is replaced by a user provide TApplication, do not call EndOfProcessCleanups and co. and thus do not delete TFiles, TSockets or TColors that have already been created. In EndOfProcessCleanups, we now delete the objects held in TROOT's TDirectory part. If the libCling library is unloaded, this now induces an immediate tear down of the ROOT resources; consequently objects might be deleted sooner in the process tear down process on some platforms. TObject instances allocated as part of an array ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:4024,Clear,Clear,4024,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['Clear'],['Clear']
Usability,"t"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<BlockPointerType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<CXXBaseSpecifier>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXBaseSpecifier>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:144488,Usab,Usable,144488,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"t, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant power-of-two argument are transformed into; shifts.; #. … etc. This pass can also simplify calls to specific well-known function calls (e.g.; runtime library functions). For example, a call ``exit(3)`` that occurs within; the ``main()`` function can be transformed into simply ``return 3``. Whether or; not library calls are simplified is controlled by the; :ref:`-function-attrs <passes-function-attrs>` pass and LLVM's knowledge of; library calls on different targets. .. _passes-aggressive-instcombine:. ``aggressive-instcombine``: Combine expression patterns; --------------------------------------------------------. Combine expression patterns to form expressions with fewer, simple instructions. For example, this pass reduce width of expressions post-dominated by TruncInst; into smaller width when applicable. It differs from instcombine pass in that it can modify CFG and contains pattern; optimization that requires higher complexity than the O(1), thus, it should run fewer; times than instcombine pass. ``internalize``: Internalize Global Symbols; -------------------------------------------. This pass loops over all of the functions in the input module, looking for a; main function. If a main function is found, all other functions and all global; variables with initializers are marked as internal. ``ipsccp``: Interprocedural Sparse Conditional Constant Propagation; -------------------------------------------------------------------. An interprocedural variant of :ref:`Sparse Conditional Constant Propagation; <passes-sccp>`. ``jump-threading``: Jump Threading; ----------------------------------. Jump threading tries to find distinct threa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:21018,simpl,simple,21018,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"t.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^. These extra tokens are not strictly conforming, and are usually best; handled by commenting them out. .. option:: -Wambiguous-member-template. Warn about unqualified uses of a member template whose name resolves to; another template at the location of the use. This option, which defaults to on, enables a warning in the; following code:. ::. template<typename T> struct set{};; template<typename T> struct trait { typedef const T& type; };; struct Value {; template<typename T> void set(typename trait<T>::type value) {}; };; void foo() {; Value v;; v.set<double>(3.2);; }. C++ [basic.lookup.classref] requires this to be an error, but,; because it's hard to work around, Clang downgrades it to a warning; as an extension. .. option:: -Wbind-to-temporary-copy. Warn about an unusable copy constructor when binding a reference to a; temporary. This option enables warnings about binding a; reference to a temporary when the temporary doesn't have a usable; copy constructor. For example:. ::. struct NonCopyable {; NonCopyable();; private:; NonCopyable(const NonCopyable&);; };; void foo(const NonCopyable&);; void bar() {; foo(NonCopyable()); // Disallowed in C++98; allowed in C++11.; }. ::. struct NonCopyable2 {; NonCopyable2();; NonCopyable2(NonCopyable2&);; };; void foo(const NonCopyable2&);; void bar() {; foo(NonCopyable2()); // Disallowed in C++98; allowed in C++11.; }. Note that if ``NonCopyable2::NonCopyable2()`` has a default argument; whose instantiation produces a compile error, that error will still; be a hard error in C++98 mode even if this warning is turned off. Options to Control Clang Crash Diagnostics; ------------------------------------------. As unbelievable as it may sound, Clang does crash from time to time.; Generally, this only occurs to those living on the `bleeding; edge <https://llvm.org/releases/download.html#svn>`_. Clang goes to great; lengths to assist you in fil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:20986,usab,usable,20986,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['usab'],['usable']
Usability,t/root/issues/8582)] - TThreadTimer behavior; * [[#8581](https://github.com/root-project/root/issues/8581)] - [ntuple] RNTupleModel columns ownership issue; * [[#8517](https://github.com/root-project/root/issues/8517)] - Add integer support to TVectorT; * [[#8494](https://github.com/root-project/root/issues/8494)] - cling crashes on conditional parameter in template; * [[#8260](https://github.com/root-project/root/issues/8260)] - Build system cannot detect version of oneTBB; * [[#8148](https://github.com/root-project/root/issues/8148)] - Document TMethodCall class limitations; * [[#7950](https://github.com/root-project/root/issues/7950)] - Assertion exception including header file with GaudiPython module; * [[#7900](https://github.com/root-project/root/issues/7900)] - Support spectator variables in RReader; * [[#7872](https://github.com/root-project/root/issues/7872)] - TExecutorCRTP::Map() should support void; * [[#7871](https://github.com/root-project/root/issues/7871)] - Usability of TExecutor::MapReduce; * [[#7845](https://github.com/root-project/root/issues/7845)] - Improve TMatrix reference documentation; * [[#7805](https://github.com/root-project/root/issues/7805)] - Inconsistent and unintuitive behaviour of TFormula::SetParNames and TFormula::SetParameters; * [[#7774](https://github.com/root-project/root/issues/7774)] - Unreasonably slow behaviour of CompileMacro; * [[#7699](https://github.com/root-project/root/issues/7699)] - [VecOps] Make free functions in VecOps better visible; * [[#7686](https://github.com/root-project/root/issues/7686)] - [PyROOT] Segfault when creating proxy to derived class with multiple overloads; * [[#7669](https://github.com/root-project/root/issues/7669)] - Inconsistent behaviour in wildcard import; * [[#7644](https://github.com/root-project/root/issues/7644)] - Provide in the cmake configuration the C++ standard which was used to compile ROOT; * [[#7627](https://github.com/root-project/root/issues/7627)] - Fix TMVA group links; * ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:48060,Usab,Usability,48060,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['Usab'],['Usability']
Usability,"t:. void foo() {; const Container c;; c.cbegin();. for (auto i : c) {; }; }. Replacement of int member; with safe_int:. fieldDecl(; hasType(asString(""int"")); ).bind(""use_safe_int""). given:. struct S {; int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; safe_int m_t;; };. void instantiate() { TemplStruct<int> ti; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. Add prefix to member initializer. cxxCtorInitializer(; forField(fieldDecl()); ).bind(""add_prefix""). given:. struct Simple {};. struct Record {; Record() : i(42) {}; private:; int i;; Simple s;; };. 2 matches found. Replacement produces incorrect output:. struct Simple {};. struct Record {; m_Record() : m_i(42) {}; private:; int i;; Simple s;; };. 1 match found. Replacement produces correct output:. struct Simple {};. struct Record {; Record() : m_i(42) {}; private:; int i;; Simple s;; };. Ignored default arguments. callExpr(; callee(functionDecl(; hasName(""hasDefaultArg""); )),; argumentCountIs(1); ).bind(""add_prefix""). given:. void hasDefaultArg(int i, int j = 0) {}; void callDefaultArg() { hasDefaultArg(42); }. No match. 1 match found. Lambda fields. fieldDecl(; hasType(asString(""int"")); ).bind(""make_safe""). given:. struct S {; int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [safe_a, safe_b = c](int d) { int e = d; };; l(43);; }. 1 match found. Replac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:6024,Simpl,Simple,6024,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Simpl'],['Simple']
Usability,"tEmbeddedCanvas *fEcanvas;; public:; MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h);; virtual ~MyMainFrame();; void DoDraw();; };; MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {; // Create a main frame; fMain = new TGMainFrame(p,w,h);. // Create canvas widget; fEcanvas = new TRootEmbeddedCanvas(""Ecanvas"",fMain,200,200);; fMain->AddFrame(fEcanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY, 10,10,10,1));; // Create a horizontal frame widget with buttons; TGHorizontalFrame *hframe = new TGHorizontalFrame(fMain,200,40);; TGTextButton *draw = new TGTextButton(hframe,""&Draw"");; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; hframe->AddFrame(draw, new TGLayoutHints(kLHintsCenterX,; 5,5,3,4));; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate(0)"");; hframe->AddFrame(exit, new TGLayoutHints(kLHintsCenterX,; 5,5,3,4));; fMain->AddFrame(hframe, new TGLayoutHints(kLHintsCenterX,; 2,2,2,2));. // Set a name to the main frame; fMain->SetWindowName(""Simple Example"");. // Map all subwindows of main frame; fMain->MapSubwindows();. // Initialize the layout algorithm; fMain->Resize(fMain->GetDefaultSize());. // Map main frame; fMain->MapWindow();; }; void MyMainFrame::DoDraw() {; // Draws function graphics in randomly chosen interval; TF1 *f1 = new TF1(""f1"",""sin(x)/x"",0,gRandom->Rndm()*10);; f1->SetLineWidth(3);; f1->Draw();; TCanvas *fCanvas = fEcanvas->GetCanvas();; fCanvas->cd();; fCanvas->Update();; }; MyMainFrame::~MyMainFrame() {; // Clean up used widgets: frames, buttons, layout hints; fMain->Cleanup();; delete fMain;; }; void example() {; // Popup the GUI...; new MyMainFrame(gClient->GetRoot(),200,200);; }; ```. The **`TGMainFrame `**class defines a top level window that interacts; with the system window manager. Its method `CloseWindow()` is invoked; when Alt+F4 are pressed or a window manager close/exit command is used.; To terminate the application when this happens you need to override the; `CloseWindow(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:6839,Simpl,Simple,6839,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['Simpl'],['Simple']
Usability,"tHub's; built-in tool. See the section about landing your fix below. When pushing to your branch, make sure you push to the correct fork. Check your; remotes with:. ::. git remote -v. And make sure you push to the remote that's pointing to your fork. Rebasing Pull Requests and Force Pushes; ---------------------------------------; In general, you should avoid rebasing a Pull Request and force pushing to the; branch that's the root of the Pull Request during the review. This action will; make the context of the old changes and comments harder to find and read. Sometimes, a rebase might be needed to update your branch with a fix for a test; or in some dependent code. After your PR is reviewed and accepted, you want to rebase your branch to ensure; you won't encounter merge conflicts when landing the PR. Landing your change; -------------------; When your PR has been accepted you can use the web interface to land your change.; If you have created multiple commits to address feedback at this point you need; to consolidate those commits into one commit. There are two different ways to; do this:. `Interactive rebase <https://git-scm.com/docs/git-rebase#_interactive_mode>`_; with fixup's. This is the recommended method since you can control the final; commit message and inspect that the final commit looks as you expect. When; your local state is correct, remember to force-push to your branch and press; the merge button afterwards. Use the button `Squash and merge` in GitHub's web interface, if you do this; remember to review the commit message when prompted. Afterwards you can select the option `Delete branch` to delete the branch; from your fork. You can also merge via the CLI by switching to your branch locally and run:. ::. gh pr merge --squash --delete-branch. If you observe an error message from the above informing you that your pull; request is not mergeable, then that is likely because upstream has been; modified since your pull request was authored in a way that no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:4933,feedback,feedback,4933,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['feedback'],['feedback']
Usability,"tMemOperand`` method; should be implemented to generate the proper output. Similarly,; ``printCCOperand`` should be used to print a conditional operand. ``doFinalization`` should be overridden in ``XXXAsmPrinter``, and it should be; called to shut down the assembly printer. During ``doFinalization``, global; variables and constants are printed to output. Subtarget Support; =================. Subtarget support is used to inform the code generation process of instruction; set variations for a given chip set. For example, the LLVM SPARC; implementation provided covers three major versions of the SPARC microprocessor; architecture: Version 8 (V8, which is a 32-bit architecture), Version 9 (V9, a; 64-bit architecture), and the UltraSPARC architecture. V8 has 16; double-precision floating-point registers that are also usable as either 32; single-precision or 8 quad-precision registers. V8 is also purely big-endian.; V9 has 32 double-precision floating-point registers that are also usable as 16; quad-precision registers, but cannot be used as single-precision registers.; The UltraSPARC architecture combines V9 with UltraSPARC Visual Instruction Set; extensions. If subtarget support is needed, you should implement a target-specific; ``XXXSubtarget`` class for your architecture. This class should process the; command-line options ``-mcpu=`` and ``-mattr=``. TableGen uses definitions in the ``Target.td`` and ``Sparc.td`` files to; generate code in ``SparcGenSubtarget.inc``. In ``Target.td``, shown below, the; ``SubtargetFeature`` interface is defined. The first 4 string parameters of; the ``SubtargetFeature`` interface are a feature name, a XXXSubtarget field set; by the feature, the value of the XXXSubtarget field, and a description of the; feature. (The fifth parameter is a list of features whose presence is implied,; and its default value is an empty array.). If the value for the field is the string ""true"" or ""false"", the field; is assumed to be a bool and only one Subtarge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:71855,usab,usable,71855,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['usab'],['usable']
Usability,"tSumName` is; accumulated with the weight variable. Otherwise, if there are multiple; simultaneous PDFs, then it adds a term to the result that scales with the; logarithm of the count of simultaneous PDFs. The rest of the function body; (including the loop scope with NLL computation) has omitted from this example; to keep it brief. Helper functions:. - `makeValidVarName()` helps get a valid name from the name of the respective; RooFit class. It then helps save it to the variable that represents the result; of this class (the squashed code/ C++ function that will be created). - `addToGlobalScope()` helps declare and initialize the results variable, so; that it can be available globally (throughout the function body). For local; variables, the `addToCodeBody()` function can be used to keep the variables in; the respective scope (for example, within a loop). - `beginLoop()` helps build the start and the end of a For loop for your; class. Simply place this function in the scope and place the contents of the; `For` loop below this statement. The code squashing task will automatically; build a loop around the statements that follow it. There's no need to worry; about the index of these loops, because they get propagated. For example, if; you want to iterate over a vector of RooFit objects using a loop, you don't; have to think about indexing them properly because the `beginLoop()` function; takes care of that. Simply call this function, place your function call in a; scope and after the scope ends, the loop will also end. - `addToCodeBody()` helps add things to the body of the C++ function that; you're creating. It takes whatever string is computed in its arguments and; adds it to the overall function string (which will later be just-in-time; compiled). The `addToCodeBody()` function is important since not everything; can be added in-line and this function helps split the code into multiple; lines. ### Step 3. analyticalIntegral() Use Case. > Besides the `evaluate()` func",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:17727,Simpl,Simply,17727,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['Simpl'],['Simply']
Usability,"t[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); ```. ### WaitPrimitive method. When the `TPad::WaitPrimitive()` method is called with no arguments, it; will wait until a double click or any key pressed is executed in the; canvas. A call to `gSystem->Sleep(10)` has been added in the loop to; avoid consuming at all the CPU. This new option is convenient when; executing a macro. By adding statements like:. ``` {.cpp}; canvas->WaitPrimitive();; ```. You can monitor the progress of a running macro, stop it at convenient; places with the possibility to interact with the canvas and resume the; execution with a double click or a key press. ### Locking the Pad. You can make the **`TPad`** non-editable. Then no new objects can be; added, and the existing objects and the pad can not be changed with the; mouse or programmatically. By default the **`TPad`** is editable. ``` {.cpp}; TPad::SetEditable(kFALSE); ```. ## Graphical Objects. In this paragraph, we describe the various simple 2D graphical objects; defined in ROOT. Usually, one defines these objects with their; constructor and draws them with their `Draw()` method. Therefore, the; examples will be very brief. Most graphical objects have line and fill; attributes (color, width) that will be described in ""Graphical objects; attributes"". If the user wants more information, the class names are; given and they may refer to the online developer documentation. This is; especially true for functions and methods that set and get internal; values of the objects described here. By default 2D graphical objects; are created in User Coordinates with (0, 0) in the lower left corner. ### Lines, Arrows and Polylines. The simplest graphical object is a line. It is implemented in the; **`TLine`** class. The line constructor is:. ``` {.cpp}; TLine(Double_t x1,Double_t y1,Double_t x2,Double_t y2); ```. The arguments `x1`, `y1`, `x2`, `y2` are the coordinates of the first; and second point. It can be used:. ``` {.cpp}; root",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:31633,simpl,simple,31633,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,"t\>*. The dialog; interfaces are generally different for different types of objects. The; volume selection dialog offers the possibility to select either a volume; already connected to the geometry hierarchy or non-connected ones.; Selection for shapes and matrices is split into categories represented; by top-level list tree items for: boxes, tubes, translations, rotations,; etc. \image html geometry020.png ""Selection dialogs for different TGeo objects"". Once a selection is made and the dialog is closed, the selected item; name will appear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attached to, since these will be destroyed together. \image html geometry021.png ""Editors for shapes, materials, media, matrices"" width=600px. For most editors, the functionalities Apply and Undo are provided. For shapes, changing any of the shape parameters will activate the; ""Apply"" button only if the check button ""Delayed draw"" is checked,; otherwise the changes are immediately applied. Once the apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""Undo"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""Undo"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:130465,Undo,Undo,130465,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['Undo'],['Undo']
Usability,"tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']. For example: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as options become less discoverable and people have to think about and m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:133142,clear,clear,133142,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['clear'],['clear']
Usability,"table entries, so that addresses taken outside the module will pass; any verification done inside the module. In more concrete terms, suppose we have three functions ``f``, ``g``,; ``h`` which are all of the same type, and a function foo that returns their; addresses:. .. code-block:: none. f:; mov 0, %eax; ret. g:; mov 1, %eax; ret. h:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %ecx; ret. Our jump table will (conceptually) look like this:. .. code-block:: none. f:; jmp .Ltmp0 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. g:; jmp .Ltmp1 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. h:; jmp .Ltmp2 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. .Ltmp0:; mov 0, %eax; ret. .Ltmp1:; mov 1, %eax; ret. .Ltmp2:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %ecx; ret. Because the addresses of ``f``, ``g``, ``h`` are evenly spaced at a power of; 2, and function types do not overlap (unlike class types with base classes),; we can normally apply the `Alignment`_ and `Eliminating Bit Vector Checks; for All-Ones Bit Vectors`_ optimizations thus simplifying the check at each; call site to a range and alignment check. Shared library support; ======================. **EXPERIMENTAL**. The basic CFI mode described above assumes that the application is a; monolithic binary; at least that all possible virtual/indirect call; targets and the entire class hierarchy are known at link time. The; cross-DSO mode, enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes; this requirement by allowing virtual and indirect calls to cross the; DSO boundary. Assuming the following setup: the binary consists of several; instrumented and several uninstrumented DSOs. Some of them may be; dlopen-ed/dlclose-d periodically, even frequently. - Calls made from uninstrumented DSOs are not checked and just work.; - Calls inside any instrumented DSO are fully protected.; - Calls between different instrumented DSOs are also protected, with; a performance pen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:18538,simpl,simplifying,18538,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['simpl'],['simplifying']
Usability,"tainer limits. Suppose we want to position the; same box inside 2 different volumes and we want the Z size to match the; one of each container:. ``` {.cpp}; TGeoVolume *container1 = gGeoManager->MakeBox(""C1"",imed,10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"",imed,10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"",jmed,3,3,-1);; container1->AddNode(pvol,1);; container2->AddNode(pvol,1);; ```. Note that the third parameter of `PVOL` is negative, which does not make; sense as half-length on Z. This is interpreted as: when positioned,; create a box replacing all invalid parameters with the corresponding; dimensions of the container. This is also internally handled by the; **`TGeoVolumeMulti`** class, which does not need to be instantiated by; users. #### Dividing Volumes. Volumes can be divided according a pattern. The simplest division can be; done along one axis that can be: `X,Y,Z,Phi,Rxy or Rxyz`. Let's take a; simple case: we would like to divide a box in N equal slices along X; coordinate, representing a new volume family. Supposing we already have; created the initial box, this can be done like:. ``` {.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; ```. Here `SLICEX` is the name of the new family representing all slices and; 1 is the slicing axis. The meaning of the axis index is the following:; for all volumes having shapes like `box`, `trd1`, `trd2`, `trap`,; `gtra `or` para - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corresponding to the slices is; created. In case all slices can be represented by a single shape, only; one volume",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:83956,simpl,simple,83956,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"tall standard binary operators.; // 1 is lowest precedence.; BinopPrecedence['<'] = 10;; BinopPrecedence['+'] = 20;; BinopPrecedence['-'] = 20;; BinopPrecedence['*'] = 40; // highest. // Prime the first token.; fprintf(stderr, ""ready> "");; getNextToken();. TheJIT = std::make_unique<KaleidoscopeJIT>();. // Run the main ""interpreter loop"" now.; MainLoop();. return 0;; }. We also need to setup the data layout for the JIT:. .. code-block:: c++. void InitializeModuleAndPassManager(void) {; // Open a new context and module.; TheContext = std::make_unique<LLVMContext>();; TheModule = std::make_unique<Module>(""my cool jit"", TheContext);; TheModule->setDataLayout(TheJIT->getDataLayout());. // Create a new builder for the module.; Builder = std::make_unique<IRBuilder<>>(*TheContext);. // Create a new pass manager attached to it.; TheFPM = std::make_unique<legacy::FunctionPassManager>(TheModule.get());; ... The KaleidoscopeJIT class is a simple JIT built specifically for these; tutorials, available inside the LLVM source code; at `llvm-src/examples/Kaleidoscope/include/KaleidoscopeJIT.h; <https://github.com/llvm/llvm-project/blob/main/llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h>`_.; In later chapters we will look at how it works and extend it with; new features, but for now we will take it as given. Its API is very simple:; ``addModule`` adds an LLVM IR module to the JIT, making its functions; available for execution (with its memory managed by a ``ResourceTracker``); and; ``lookup`` allows us to look up pointers to the compiled code. We can take this simple API and change our code that parses top-level expressions to; look like this:. .. code-block:: c++. static ExitOnError ExitOnErr;; ...; static void HandleTopLevelExpression() {; // Evaluate a top-level expression into an anonymous function.; if (auto FnAST = ParseTopLevelExpr()) {; if (FnAST->codegen()) {; // Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:11841,simpl,simple,11841,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simple']
Usability,"tasets are no cloned for fit operations to save time and memory.; This change in procedure should save some time and memory, especially in toy MC; studies where the overhead in setting up the likelihood can dominate the total; time spent in fitting. The data cloning behavior of RooAbsPdf::fitTo(); and RooAbsPdf::createNLL() can be explicitly set through the CloneData(); named argument; It is now possible to construct a RooSimultaneous p.d.f. from other; RooSimultaneous p.d.f.s, provided the constructor form is used that takes; all input p.d.f.s. In this constructor simultaneous-of-simultaneous p.d.f.s are automatically; recast to an equivalent top-level simultaneous p.d.f; Sim of sim now possible; Several improvements were made in the internal handling of datasets that; will speedup certain data intensive operations. RooStats; New Tutorials. Several new tutorials were added for RooStats. rs101_limitexample.C Demonstrates use of Frequentist,; Bayesian, and Likelihood intervals for a simple number counting experiment; with uncertainty on signal and background rates.; rs301_splot.C Demonstrates use of RooStats sPlot; implementation; rs401c_FeldmanCousins.C Demonstrates use of; FeldmanCousins interval calculator with a Poisson problem, reproduces; results from table IV and V of the original; paper�Phys.Rev.D57:3873-3889,1998.; rs401d_FeldmanCousins.C Demonstrates use of; FeldmanCousins interval calculator with the neutrino oscillation toy; example described in the original paper�Phys.Rev.D57:3873-3889,1998.; Reproduces figure 12.; rs_bernsteinCorrection.C Demonstrates use of; BernsteinCorrection class, which corrects a nominal PDF with a polynomial; to agree with observed or simulated data. TestStatistic interface and implementations; We added a new interface class called TestStatistic. It defines the; method Evaluate(data, parameterPoint), which returns a double. �This; class can be used in�conjunction�with the ToyMCSampler class to generate; sampling distributions for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:25078,simpl,simple,25078,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['simpl'],['simple']
Usability,"tationCallbacks>();; TheSI = std::make_unique<StandardInstrumentations>(*TheContext,; /*DebugLogging*/ true);; TheSI->registerCallbacks(*ThePIC, TheMAM.get());; ... After initializing the global module ``TheModule`` and the FunctionPassManager,; we need to initialize other parts of the framework. The four AnalysisManagers; allow us to add analysis passes that run across the four levels of the IR; hierarchy. PassInstrumentationCallbacks and StandardInstrumentations are; required for the pass instrumentation framework, which allows developers to; customize what happens between passes. Once these managers are set up, we use a series of ""addPass"" calls to add a; bunch of LLVM transform passes:. .. code-block:: c++. // Add transform passes.; // Do simple ""peephole"" optimizations and bit-twiddling optzns.; TheFPM->addPass(InstCombinePass());; // Reassociate expressions.; TheFPM->addPass(ReassociatePass());; // Eliminate Common SubExpressions.; TheFPM->addPass(GVNPass());; // Simplify the control flow graph (deleting unreachable blocks, etc).; TheFPM->addPass(SimplifyCFGPass());. In this case, we choose to add four optimization passes.; The passes we choose here are a pretty standard set; of ""cleanup"" optimizations that are useful for a wide variety of code. I won't; delve into what they do but, believe me, they are a good starting place :). Next, we register the analysis passes used by the transform passes. .. code-block:: c++. // Register analysis passes used in these transform passes.; PassBuilder PB;; PB.registerModuleAnalyses(*TheMAM);; PB.registerFunctionAnalyses(*TheFAM);; PB.crossRegisterProxies(*TheLAM, *TheFAM, *TheCGAM, *TheMAM);; }. Once the PassManager is set up, we need to make use of it. We do this by; running it after our newly created function is constructed (in; ``FunctionAST::codegen()``), but before it is returned to the client:. .. code-block:: c++. if (Value *RetVal = Body->codegen()) {; // Finish off the function.; Builder.CreateRet(RetVal);. // Valid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:7285,Simpl,Simplify,7285,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['Simpl'],['Simplify']
Usability,"tch both are typically duplicated. This matcher; removes the need for duplication. Given code; struct ConstructorTakesInt; {; ConstructorTakesInt(int i) {}; };. void callTakesInt(int i); {; }. void doCall(); {; callTakesInt(42);; }. void doConstruct(); {; ConstructorTakesInt cti(42);; }. The matcher; invocation(hasArgument(0, integerLiteral(equals(42)))); matches the expression in both doCall and doConstruct. Matcher<*>optionallyMatcher<*>; Matches any node regardless of the submatcher. However, optionally will retain any bindings generated by the submatcher.; Useful when additional information which may or may not present about a main; matching node is desired. For example, in:; class Foo {; int bar;; }; The matcher:; cxxRecordDecl(; optionally(has(; fieldDecl(hasName(""bar"")).bind(""var""); ))).bind(""record""); will produce a result binding for both ""record"" and ""var"".; The matcher will produce a ""record"" binding for even if there is no data; member named ""bar"" in that class. Usable as: Any Matcher. Matcher<*>traverseTraversalKind TK, Matcher<*> InnerMatcher; Causes all nested matchers to be matched with the specified traversal kind. Given; void foo(); {; int i = 3.0;; }; The matcher; traverse(TK_IgnoreUnlessSpelledInSource,; varDecl(hasInitializer(floatLiteral().bind(""init""))); ); matches the variable declaration with ""init"" bound to the ""3.0"". Matcher<AbstractConditionalOperator>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))); if (true) {}. Matcher<AbstractConditionalOperator>hasFalseExpressionMatcher<Expr> InnerMatcher; Matches the false branch expression of a conditional operator; (binary or ternary). Example matches b; condition ? a : b; condition ?: b. Matcher<AbstractConditionalOperator>hasTrueExpressionMatcher<Expr> InnerMatcher; Matches the true branch expression of a conditional operator",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:136316,Usab,Usable,136316,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"tch found. Replacement produces correct output:. void foo() {; const Container c;; c.cbegin();. for (auto i : c) {; }; }. Replacement of int member; with safe_int:. fieldDecl(; hasType(asString(""int"")); ).bind(""use_safe_int""). given:. struct S {; int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; safe_int m_t;; };. void instantiate() { TemplStruct<int> ti; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. Add prefix to member initializer. cxxCtorInitializer(; forField(fieldDecl()); ).bind(""add_prefix""). given:. struct Simple {};. struct Record {; Record() : i(42) {}; private:; int i;; Simple s;; };. 2 matches found. Replacement produces incorrect output:. struct Simple {};. struct Record {; m_Record() : m_i(42) {}; private:; int i;; Simple s;; };. 1 match found. Replacement produces correct output:. struct Simple {};. struct Record {; Record() : m_i(42) {}; private:; int i;; Simple s;; };. Ignored default arguments. callExpr(; callee(functionDecl(; hasName(""hasDefaultArg""); )),; argumentCountIs(1); ).bind(""add_prefix""). given:. void hasDefaultArg(int i, int j = 0) {}; void callDefaultArg() { hasDefaultArg(42); }. No match. 1 match found. Lambda fields. fieldDecl(; hasType(asString(""int"")); ).bind(""make_safe""). given:. struct S {; int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [safe_a, safe_b = c](int d) { in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:5956,Simpl,Simple,5956,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Simpl'],['Simple']
Usability,"te <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30345,simpl,simplify,30345,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplify']
Usability,"te `presplitcoroutine` for the coroutine. 'llvm.coro.id.retcon.once' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.id.retcon.once(i32 <size>, i32 <align>, ptr <buffer>,; ptr <prototype>,; ptr <alloc>, ptr <dealloc>). Overview:; """""""""""""""""". The '``llvm.coro.id.retcon.once``' intrinsic returns a token identifying a; unique-suspend returned-continuation coroutine. Arguments:; """""""""""""""""""". As for ``llvm.core.id.retcon``, except that the return type of the; continuation prototype must represent the normal return type of the continuation; (instead of matching the coroutine's return type). Semantics:; """""""""""""""""""". A frontend should emit function attribute `presplitcoroutine` for the coroutine. .. _coro.end:. 'llvm.coro.end' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i1 @llvm.coro.end(ptr <handle>, i1 <unwind>, token <result.token>). Overview:; """""""""""""""""". The '``llvm.coro.end``' marks the point where execution of the resume part of; the coroutine should end and control should return to the caller. Arguments:; """""""""""""""""""". The first argument should refer to the coroutine handle of the enclosing; coroutine. A frontend is allowed to supply null as the first parameter, in this; case `coro-early` pass will replace the null with an appropriate coroutine; handle value. The second argument should be `true` if this coro.end is in the block that is; part of the unwind sequence leaving the coroutine body due to an exception and; `false` otherwise. Non-trivial (non-none) token argument can only be specified for unique-suspend; returned-continuation coroutines where it must be a token value produced by; '``llvm.coro.end.results``' intrinsic. Only none token is allowed for coro.end calls in unwind sections. Semantics:; """"""""""""""""""""; The purpose of this intrinsic is to allow frontends to mark the cleanup and; other code that is only relevant during the initial invocation of the coroutine; and should not be present in resume and destr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:42553,resume,resume,42553,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"te information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::services::WebService""):. $ clang -fsyntax-only t.cpp; t.cpp:9:10: error: invalid operands to binary expression ('servers::Server const' and '::services::WebService const *'); server += http;; ~~~~~~ ^ ~~~~. Naturally, type preservation extends to uses of templates, and Clang retains information about how a particular template specialization (like std::vector<Real>) was spelled within the source code. For example:. $ clang -fsyntax-only t.cpp; t.cpp:12:7: error: incompatible type assigning 'vector<Real>', expected 'std::string' (aka 'class std::basic_string<char>'); str = vec;; ^ ~~~. Fix-it Hints; ""Fix-it"" hints provide advice for fixing small, localized problems; in source code. When Clang produces a diagnostic about a particular; problem that it can work around (e.g., non-standard or redundant; syntax, missing keywords, common mistakes, etc.), it may also provide; specific guidance in the form of a code transformation to correct the; problem. In the following example, Clang warns about the use of a GCC; extension that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.cpp:9:3: error: template specialization requires 'template<>'; struct iterator_traits<file",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:6428,guid,guidance,6428,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['guid'],['guidance']
Usability,"teSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<DeclRefExpr>hasTemplateArgumentLocunsigned Index, Matcher<TemplateArgumentLoc> InnerMatcher; Matches template specialization `TypeLoc`s where the n'th; `TemplateArgumentLoc` matches the given `InnerMatcher`. Given; template<typename T, typename U> class A {};; A<double, int> b;; A<int, double> c;; varDecl(hasTypeLoc(templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,; hasTypeLoc(loc(asString(""double""))))))); matches `A<double, int> b`, but not `A<int, double> c`. Matcher<DeclRefExpr>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:; namespace a { int f(); }; using a::f;; int x = f();; declRefExpr(throughUsingDecl(anything())); matches f. namespace a { class X{}; }; using a::X;; X x;; typeLoc(loc(usingType(throughUsingDecl(anything())))); matches X. Usable as: Matcher<DeclRefExpr>, Matcher<UsingType>. Matcher<DeclRefExpr>toMatcher<Decl> InnerMatcher; Matches a DeclRefExpr that refers to a declaration that matches the; specified matcher. Example matches x in if(x); (matcher = declRefExpr(to(varDecl(hasName(""x""))))); bool x;; if (x) {}. Matcher<DeclStmt>containsDeclarationunsigned N, Matcher<Decl> InnerMatcher; Matches the n'th declaration of a declaration statement. Note that this does not work for global declarations because the AST; breaks up multiple-declaration DeclStmt's into multiple single-declaration; DeclStmt's.; Example: Given non-global declarations; int a, b = 0;; int c;; int d = 2, e;; declStmt(containsDeclaration(; 0, varDecl(hasInitializer(anything())))); matches only 'int d = 2, e;', and; declStmt(containsDeclaration(1, varDecl())); matches 'int a, b = 0' as well as 'int d = 2, e;'; but 'int c;' is not matched. Matcher<DeclStmt>hasSingleDeclMatcher<Decl> InnerMatcher; Matches the Decl of a DeclStmt which has a single declaration. Given; int ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:185333,Usab,Usable,185333,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"teSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ExplicitCastExpr>hasDestinationTypeMatcher<QualType> InnerMatcher; Matches casts whose destination type matches a given matcher. (Note: Clang's AST refers to other conversions as ""casts"" too, and calls; actual casts ""explicit"" casts.). Matcher<ExplicitCastExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<Expr>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:192645,Usab,Usable,192645,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"teTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CXXNewExpr>hasPlacementArgunsigned Index, Matcher<Expr> InnerMatcher; Matches placement new expression arguments. Given:; MyClass *p1 = new (Storage, 16) MyClass();; cxxNewExpr(hasPlacementArg(1, integerLiteral(equals(16)))); matches the expression 'new (Storage, 16) MyClass()'. Matcher<CXXNewExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXOperatorCallExpr>hasEitherOperandMatcher<Expr> InnerMatcher; Matches if either the left hand side or the right hand side of a; binary operator or fold expression matches. Matcher<CXXOperatorCallExpr>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<CXXOperatorCallExpr>hasOperandsMatcher<Expr> Matcher1, Matcher<Expr> Matcher2; Matches if both matchers match with opposite sides of the binary operator; or fold expression. Example matcher = binaryOperator(hasOperands(integerLiteral(equals(1),; integerLiteral(equals(2))); 1 + 2 // Match; 2 + 1 // Match; 1 + 1 // No match; 2 + 2 // No match. Matcher<CXXOperatorCallExpr>hasRHSMatcher<Expr> InnerMatcher; Matche",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:164276,Usab,Usable,164276,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"tecture or designing a; :program:`lit` testing implementation should see :ref:`lit-infrastructure`. GENERAL OPTIONS; ---------------. .. option:: -h, --help. Show the :program:`lit` help message. .. option:: -j N, --workers=N. Run ``N`` tests in parallel. By default, this is automatically chosen to; match the number of detected available CPUs. .. option:: --config-prefix=NAME. Search for :file:`{NAME}.cfg` and :file:`{NAME}.site.cfg` when searching for; test suites, instead of :file:`lit.cfg` and :file:`lit.site.cfg`. .. option:: -D NAME[=VALUE], --param NAME[=VALUE]. Add a user defined parameter ``NAME`` with the given ``VALUE`` (or the empty; string if not given). The meaning and use of these parameters is test suite; dependent. .. _output-options:. OUTPUT OPTIONS; --------------. .. option:: -q, --quiet. Suppress any output except for test failures. .. option:: -s, --succinct. Show less output, for example don't show information on tests that pass.; Also show a progress bar, unless ``--no-progress-bar`` is specified. .. option:: -v, --verbose. Show more information on test failures, for example the entire test output; instead of just the test result. Each command is printed before it is executed. This can be valuable for; debugging test failures, as the last printed command is the one that failed.; Moreover, :program:`lit` inserts ``'RUN: at line N'`` before each; command pipeline in the output to help you locate the source line of; the failed command. .. option:: -vv, --echo-all-commands. Deprecated alias for -v. .. option:: -a, --show-all. Enable -v, but for all tests not just failed tests. .. option:: --no-progress-bar. Do not use curses based progress bar. .. option:: --show-unsupported. Show the names of unsupported tests. .. option:: --show-xfail. Show the names of tests that were expected to fail. .. _execution-options:. EXECUTION OPTIONS; -----------------. .. option:: --path=PATH. Specify an additional ``PATH`` to use when searching for executables in te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:3199,progress bar,progress bar,3199,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['progress bar'],['progress bar']
Usability,"ted from memory, the corresponding CINT namespace; is removed as well. Note that this feature is strictly available in interpreted C++ only; A new tutorial macro has been added to illustrate this functionality in more detail: rf509_wsinteractive.C.; writeToFile -- A new utility method RooWorkspace::writeToFile() has been added; to simplify the process of saving a workspace to file; Named sets and parameter snapshots -- It is now possible to define and retrieve; named RooArgSets of objects that live in the workspace through methods; defineSet() and set(). While named sets merely group objects logically, methods loadSnapshot and; saveSnapshot allow to make copies of the values, errors and 'constant' status of; sets of variable objects that live in the workspace. A newly added tutorial macro rf510_namedsets.C illustrates the functionality of both; of these features.; Improved printing of contents -- Many operator p.d.f. and function components now show; a more intuitive natural representation of their contents (these changes are mostly in the; respective p.d.f.s, but are most relevant in the context of a workspace). New object factory interface to workspace to facilitate script driven model definition; A object factory has been added to RooFit to simplify the process of creating p.d.f.; and function expressions consisting of multiple objects. The factory has two goals:; the first is to provide a back-end for higher level factories and tools to process; the creation of objects. The second is to provide a simple end-user language to; populate a RooWorkspace with function and p.d.f. objects. For the latter purpose the object creation language is executed through the factory() method; of a workspace object. RooWorkspace w(""w"") ;; RooAbsArg* arg = w.factory(""expression_goes_here"") ;. Basic Syntax; The rules at its simplest level are as follows. Expressions with square brackets create variables (discrete and continuous). ""m[-10,10]"" - Creates a RooRealVar named 'm' with rang",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:17902,intuit,intuitive,17902,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['intuit'],['intuitive']
Usability,"ted. To prevent this, make sure that the code is actually needed. For example, if; you are computing some expression, return the value from the function instead; of leaving it in a local variable. If you really want to constrain the; optimizer, you can read from and assign to ``volatile`` global variables. What is this ""``undef``"" thing that shows up in my code?; --------------------------------------------------------; ``undef`` is the LLVM way of representing a value that is not defined. You; can get these if you do not initialize a variable before you use it. For; example, the C function:. .. code-block:: c. int X() { int i; return i; }. Is compiled to ""``ret i32 undef``"" because ""``i``"" never has a value specified; for it. Why does instcombine + simplifycfg turn a call to a function with a mismatched calling convention into ""unreachable""? Why not make the verifier reject it?; ----------------------------------------------------------------------------------------------------------------------------------------------------------; This is a common problem run into by authors of front-ends that are using; custom calling conventions: you need to make sure to set the right calling; convention on both the function and on each call to the function. For; example, this code:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define void @bar() {; call void @foo(); ret void; }. Is optimized to:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define void @bar() {; unreachable; }. ... with ""``opt -instcombine -simplifycfg``"". This often bites people because; ""all their code disappears"". Setting the calling convention on the caller and; callee is required for indirect calls to work, so people often ask why not; make the verifier reject this sort of thing. The answer is that this code has undefined behavior, but it is not illegal.; If we made it illegal, then every transformation that could potentially create; this would have to ensure that it do",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:9046,simpl,simplifycfg,9046,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,1,['simpl'],['simplifycfg']
Usability,"template pattern parameterized over the load upper immediate; instruction, add operation, the zero register, and register class.; Here the instantiation of MipsHiLoRelocs in MipsInstrInfo.td is used; to MIPS32 to compute addresses for the static relocation model. // lib/Target/Mips/MipsInstrInfo.td; multiclass MipsHiLoRelocs<Instruction Lui, Instruction Addiu,; Register ZeroReg, RegisterOperand GPROpnd> {; def : MipsPat<(MipsHi tglobaladdr:$in), (Lui tglobaladdr:$in)>;; ...; def : MipsPat<(MipsLo tglobaladdr:$in), (Addiu ZeroReg, tglobaladdr:$in)>;; ...; def : MipsPat<(add GPROpnd:$hi, (MipsLo tglobaladdr:$lo)),; (Addiu GPROpnd:$hi, tglobaladdr:$lo)>;; ...; }; defm : MipsHiLoRelocs<LUi, ADDiu, ZERO, GPR32Opnd>;. // lib/Target/Mips/Mips64InstrInfo.td; defm : MipsHiLoRelocs<LUi64, DADDiu, ZERO_64, GPR64Opnd>, SYM_32;. The instantiation in Mips64InstrInfo.td is used for MIPS64 in ILP32; mode, as guarded by the predicate ""SYM_32"" and also for a submode of; LP64 where symbols are assumed to be 32 bits wide. More details on how multiclasses in TableGen work can be found in the; section ""Multiclass definitions and instances"" in the document; ""TableGen Language Introduction"". 4. Instruction definitions are multiply defined to cover the different; register classes. In some cases, such as LW/LW64, this also accounts; for the difference in the results of instruction execution. On MIPS32,; ""lw"" loads a 32 bit value from memory. On MIPS64, ""lw"" loads a 32 bit; value from memory and sign extends the value to 64 bits. // lib/Target/Mips/MipsInstrInfo.td; def LUi : MMRel, LoadUpper<""lui"", GPR32Opnd, uimm16_relaxed>, LUI_FM;; // lib/Target/Mips/Mips64InstrInfo.td; def LUi64 : LoadUpper<""lui"", GPR64Opnd, uimm16_64_relaxed>, LUI_FM;. defines two names ""LUi"" and ""LUi64"" with two different register; classes, but with the same encoding---""LUI_FM"". These instructions load a; 16-bit immediate into bits 31-16 and clear the lower 15 bits. On MIPS64,; the result is sign-extended to 64 bits.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt:3809,clear,clear,3809,interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt,1,['clear'],['clear']
Usability,"tentially relocated pointer is observably-after a; safepoint which could relocate it. 'observably-after' is this usage; means that an outside observer could observe this sequence of events; in a way which precludes the operation being performed before the; safepoint. To understand why this 'observable-after' property is required,; consider a null comparison performed on the original copy of a; relocated pointer. Assuming that control flow follows the safepoint,; there is no way to observe externally whether the null comparison is; performed before or after the safepoint. (Remember, the original; Value is unmodified by the safepoint.) The compiler is free to make; either scheduling choice. The actual correctness property implemented is slightly stronger than; this. We require that there be no *static path* on which a; potentially relocated pointer is 'observably-after' it may have been; relocated. This is slightly stronger than is strictly necessary (and; thus may disallow some otherwise valid programs), but greatly; simplifies reasoning about correctness of the compiled code. By construction, this property will be upheld by the optimizer if; correctly established in the source IR. This is a key invariant of; the design. The existing IR Verifier pass has been extended to check most of the; local restrictions on the intrinsics mentioned in their respective; documentation. The current implementation in LLVM does not check the; key relocation invariant, but this is ongoing work on developing such; a verifier. Please ask on llvm-dev if you're interested in; experimenting with the current version. .. _statepoint-utilities:. Utility Passes for Safepoint Insertion; ======================================. .. _RewriteStatepointsForGC:. RewriteStatepointsForGC; ^^^^^^^^^^^^^^^^^^^^^^^^. The pass RewriteStatepointsForGC transforms a function's IR to lower from the; abstract machine model described above to the explicit statepoint model of; relocations. To do this, it replaces al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:24578,simpl,simplifies,24578,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['simpl'],['simplifies']
Usability,"terals ill-formed; P1854R4 (DR); Clang 14. Unevaluated strings; P2361R6; Clang 18. Add @, $, and ` to the basic character set; P2558R2; Yes. constexpr cast from void*; P2738R1; Clang 17. On the ignorability of standard attributes; P2552R3 (DR); No. Static storage for braced initializers; P2752R3 (DR); No. User-generated static_assert messages; P2741R3; Clang 17. Placeholder variables with no name; P2169R4; Clang 18. Template parameter initialization; P2308R1 (DR); Clang 18. Pack Indexing; P2662R3; No. Remove Deprecated Arithmetic Conversion on Enumerations; P2864R2; Clang 18. C++23 implementation status. Clang has support for some of the features of the ISO C++ 2023 standard.; You can use Clang in C++23 mode with the -std=c++23 option. List of features and minimum Clang version with support. Language Feature; C++23 Proposal; Available in Clang?. Literal suffix uz, z for size_t, ssize_t; P0330R8; Clang 13. Make () in lambdas optional in all cases; P1102R2; Clang 13. Simpler implicit move; P2266R1; Clang 13. if consteval; P1938R3; Clang 14. Allow duplicate attributes; P2156R1; Clang 13. Narrowing contextual conversions to bool; P1401R5; Clang 14. Trimming whitespaces before line splicing; P2223R2; Yes. Make declaration order layout mandated; P1874R4; Yes. C++ identifier syntax using UAX 31; P1949R7; Clang 14. Mixed string literal concatenation; P2201R1; Yes. Deducing this; P0847R7; Clang 18. P2797R0; No. Change scope of lambda trailing-return-type; P2036R3; Clang 17. P2579R0. Multidimensional subscript operator; P2128R6; Clang 15. Non-literal variables (and labels and gotos) in constexpr functions; P2242R3; Clang 15. Character encoding of diagnostic text; P2246R1; Yes. Character sets and encodings; P2314R4; Yes. Consistent character literal encoding; P2316R2; Yes. Add support for preprocessing directives elifdef and elifndef; P2334R1; Clang 13. Extend init-statement to allow alias-declaration; P2360R0; Clang 14. auto(x): decay-copy in the language; P0849R8; Clang 15. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:2316,Simpl,Simpler,2316,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,1,['Simpl'],['Simpler']
Usability,"terators will check that the collection is not mutated. In a release build, elements might be skipped or be iterated twice. #### Moving away from the slower iterators; The legacy iterators have been flagged with a special deprecation macro that can be used help the user use the recommended ROOT interface. Defining one of the [deprecation macros](#preprocessor-deprecation-macros) (either in a single translation unit or in the build system), and creating a legacy iterator will trigger a compiler warning such as:; ```; <path>/RooChebychev.cxx:66:34: warning: 'createIterator' is deprecated: There is a superior alternative: begin(), end() and range-based for loops. [-Wdeprecated-declarations]; TIterator* coefIter = coefList.createIterator() ;; ^; 1 warning generated.; ```. ## TMVA. This release provides a consolidation and several fixes of the new machine learning tools provided in TMVA such as the Deep Learning module.; The method `TMVA::Types::kDL` should be used now for building Deep Learning architecture in TMVA, while `TMVA::Types::kDNN` is now deprecated. `TMVA::Types::kDL` provides all the functionality of `TMVA::Types::kDNN`, i.e building fully connected dense layer, but in addition supports building convolutional and recurrent neural network architectures.; These release contains improvements in the `MethodDL` such as:; - fix droput support for dense layer; - add protection to avoid returning NaN in the cross-entropy loss function. In addition we have :. - New `TMVA::Executor` class to control the multi-thread running of TMVA. By default now MT running will be enabled only when `ROOT::EnabledImplicitMT()` is called. But we can take the control of the threads by using `TMVA::gConfig().EnableMT(...)` and `TMVA::gConfig().DisableMT()`. ### PyMVA; - add support when using the Tensorflow backend in Keras to control the number of threads; - add possibility to control options for configuring GPU running. FOr example we can now set the mode to allocate memory only as ne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:17388,Learn,Learning,17388,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['Learn'],['Learning']
Usability,terface/extract_interface.h; polly/lib/Plugin/Polly.cpp; polly/lib/Support/DumpFunctionPass.cpp; polly/lib/Support/DumpModulePass.cpp; polly/lib/Support/GICHelper.cpp; polly/lib/Support/ISLTools.cpp; polly/lib/Support/Mainpage.h; polly/lib/Support/RegisterPasses.cpp; polly/lib/Support/SCEVAffinator.cpp; polly/lib/Support/SCEVValidator.cpp; polly/lib/Support/ScopHelper.cpp; polly/lib/Support/ScopLocation.cpp; polly/lib/Support/VirtualInstruction.cpp; polly/lib/Transform/Canonicalization.cpp; polly/lib/Transform/CodePreparation.cpp; polly/lib/Transform/DeadCodeElimination.cpp; polly/lib/Transform/DeLICM.cpp; polly/lib/Transform/FlattenAlgo.cpp; polly/lib/Transform/FlattenSchedule.cpp; polly/lib/Transform/ForwardOpTree.cpp; polly/lib/Transform/ManualOptimizer.cpp; polly/lib/Transform/MatmulOptimizer.cpp; polly/lib/Transform/MaximalStaticExpansion.cpp; polly/lib/Transform/ScheduleOptimizer.cpp; polly/lib/Transform/ScheduleTreeTransform.cpp; polly/lib/Transform/ScopInliner.cpp; polly/lib/Transform/Simplify.cpp; polly/lib/Transform/ZoneAlgo.cpp; polly/tools/GPURuntime/GPUJIT.h; polly/unittests/DeLICM/DeLICMTest.cpp; polly/unittests/Flatten/FlattenTest.cpp; polly/unittests/Isl/IslTest.cpp; polly/unittests/ScheduleOptimizer/ScheduleTreeTransformTest.cpp; polly/unittests/ScopPassManager/PassManagerTest.cpp; polly/unittests/Support/ISLTools.cpp; pstl/include/pstl/internal/algorithm_fwd.h; pstl/include/pstl/internal/execution_defs.h; pstl/include/pstl/internal/execution_impl.h; pstl/include/pstl/internal/glue_algorithm_defs.h; pstl/include/pstl/internal/glue_algorithm_impl.h; pstl/include/pstl/internal/glue_execution_defs.h; pstl/include/pstl/internal/glue_memory_defs.h; pstl/include/pstl/internal/glue_memory_impl.h; pstl/include/pstl/internal/glue_numeric_defs.h; pstl/include/pstl/internal/glue_numeric_impl.h; pstl/include/pstl/internal/numeric_fwd.h; pstl/include/pstl/internal/parallel_backend.h; pstl/include/pstl/internal/parallel_backend_omp.h; pstl/include/pstl/internal/p,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:416209,Simpl,Simplify,416209,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['Simplify']
Usability,"termine the loop depth of; various nodes of the CFG. Note that the loops identified may actually be; several natural loops that share the same header node... not just a single; natural loop. ``memdep``: Memory Dependence Analysis; --------------------------------------. An analysis that determines, for a given memory operation, what preceding; memory operations it depends on. It builds on alias analysis information, and; tries to provide a lazy, caching interface to a common kind of alias; information query. ``module-debuginfo``: Decodes module-level debug info; -----------------------------------------------------. This pass decodes the debug info metadata in a module and prints in a; (sufficiently-prepared-) human-readable form. For example, run this pass from ``opt`` along with the ``-analyze`` option, and; it'll print to standard output. ``postdomtree``: Post-Dominator Tree Construction; -------------------------------------------------. This pass is a simple post-dominator construction algorithm for finding; post-dominators. ``print-alias-sets``: Alias Set Printer; ---------------------------------------. Yet to be written. ``print-callgraph``: Print a call graph; ---------------------------------------. This pass, only available in ``opt``, prints the call graph to standard error; in a human-readable form. ``print-callgraph-sccs``: Print SCCs of the Call Graph; ------------------------------------------------------. This pass, only available in ``opt``, prints the SCCs of the call graph to; standard error in a human-readable form. ``print-cfg-sccs``: Print SCCs of each function CFG; ---------------------------------------------------. This pass, only available in ``opt``, printsthe SCCs of each function CFG to; standard error in a human-readable fom. ``print-function``: Print function to stderr; --------------------------------------------. The ``PrintFunctionPass`` class is designed to be pipelined with other; ``FunctionPasses``, and prints out the functions ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:8781,simpl,simple,8781,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"tes. In previous versions, it could sometime return `kEntryNotFound` even for well-behaved event loops.; - Add `TEntryList::AddSubList` to specifically add a sub-list to the main list of entries. Consequently, add also a new option `""sync""` in `TChain::SetEntryList` to connect the sub-trees of the chain to the sub-lists of the entry list in lockstep (PR [#8660](https://github.com/root-project/root/pull/8660)).; - Add `TEntryList::EnterRange` to add all entries in a certain range `[start, end)` to the entry list (PR [#8740](https://github.com/root-project/root/pull/8740)). ## RNTuple. ROOT's experimental successor of TTree has been upgraded to the version 1 of the binary format specification. Compared to the v0 format, the header is ~40% smaller and the footer ~100% smaller (after zstd compression). More details in PR [#8897](https://github.com/root-project/root/pull/8897).; RNTuple is still experimental and is scheduled to become production grade in 2024. Thus, we appreciate feedback and suggestions for improvement. If you have been trying RNTuple for a while, these are the other important changes that you will notice:. - Support for aligned friends (PR [#6979](https://github.com/root-project/root/pull/6979)). Refer to the `RNTupleReader::OpenFriends()` function.; - Cluster and page sizes in `RNTupleWriteOptions` now refer to their target size in bytes (as opposed to the number of entries). Defaults are 64 kB for the page size and 50 MB for the cluster size (PR [#8703](https://github.com/root-project/root/pull/8703)).; - Storing objects of user-defined classes via `TClass` now also includes members inherited from all the base classes (PR [#8552](https://github.com/root-project/root/pull/8552)).; - Support for RFields whose type is a typedef to some other type. ## RDataFrame. ### New features. - Add [`Redefine`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a4e882a949c8a1022a38ec6936c2ff29c) to the `RDataFrame` interface, which allows to overwrite ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:6338,feedback,feedback,6338,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['feedback'],['feedback']
Usability,"test-suite Guide; ================. Quickstart; ----------. 1. The lit test runner is required to run the tests. You can either use one; from an LLVM build:. ```bash; % <path to llvm build>/bin/llvm-lit --version; lit 0.8.0dev; ```. An alternative is installing it as a python package in a python virtual; environment:. ```bash; % mkdir venv; % virtualenv venv; % . venv/bin/activate; % pip install svn+https://llvm.org/svn/llvm-project/llvm/trunk/utils/lit; % lit --version; lit 0.8.0dev; ```. 2. Check out the `test-suite` module with:. ```bash; % git clone https://github.com/llvm/llvm-test-suite.git test-suite; ```. 3. Create a build directory and use CMake to configure the suite. Use the; `CMAKE_C_COMPILER` option to specify the compiler to test. Use a cache file; to choose a typical build configuration:. ```bash; % mkdir test-suite-build; % cd test-suite-build; % cmake -DCMAKE_C_COMPILER=<path to llvm build>/bin/clang \; -C../test-suite/cmake/caches/O3.cmake \; ../test-suite; ```. **NOTE!** if you are using your built clang, and you want to build and run the; MicroBenchmarks/XRay microbenchmarks, you need to add `compiler-rt` to your; `LLVM_ENABLE_RUNTIMES` cmake flag. 4. Build the benchmarks:. ```text; % make; Scanning dependencies of target timeit-target; [ 0%] Building C object tools/CMakeFiles/timeit-target.dir/timeit.c.o; [ 0%] Linking C executable timeit-target; ...; ```. 5. Run the tests with lit:. ```text; % llvm-lit -v -j 1 -o results.json .; -- Testing: 474 tests, 1 threads --; PASS: test-suite :: MultiSource/Applications/ALAC/decode/alacconvert-decode.test (1 of 474); ********** TEST 'test-suite :: MultiSource/Applications/ALAC/decode/alacconvert-decode.test' RESULTS **********; compile_time: 0.2192; exec_time: 0.0462; hash: ""59620e187c6ac38b36382685ccd2b63b""; size: 83348; **********; PASS: test-suite :: MultiSource/Applications/ALAC/encode/alacconvert-encode.test (2 of 474); ...; ```. 6. Show and compare result files (optional):. ```bash; # Make sure panda",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:11,Guid,Guide,11,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['Guid'],['Guide']
Usability,"text. (inst operand0, operand1, ...). ``inst`` must be a def which inherits from ``Instruction`` (e.g. ``G_FADD``); or ``GICombinePatFrag``. Operands essentially fall into one of two categories:. * immediates. * untyped, unnamed: ``0``; * untyped, named: ``0:$y``; * typed, unnamed: ``(i32 0)``; * typed, named: ``(i32 0):$y``. * machine operands. * untyped: ``$x``; * typed: ``i32:$x``. Semantics:. * A typed operand always adds an operand type check to the matcher.; * There is a trivial type inference system to propagate types. * e.g. You only need to use ``i32:$x`` once in any pattern of a; ``GICombinePatFrag`` alternative or ``GICombineRule``, then all; other patterns in that rule/alternative can simply use ``$x``; (``i32:$x`` is redundant). * A named operand's behavior depends on whether the name has been seen before. * For match patterns, reusing an operand name checks that the operands; are identical (see example 2 below).; * For apply patterns, reusing an operand name simply copies that operand into; the new instruction (see example 2 below). Operands are ordered just like they would be in a MachineInstr: the defs (outs); come first, then the uses (ins). Patterns are generally grouped into another DAG datatype with a dummy operator; such as ``match``, ``apply`` or ``pattern``. Finally, any DAG datatype in TableGen can be named. This also holds for; patterns. e.g. the following is valid: ``(G_FOO $root, (i32 0):$cst):$mypat``.; This may also be helpful to debug issues. Patterns are *always* named, and if; they don't have a name, an ""anonymous"" one is given to them. If you're trying; to debug an error related to a MIR pattern, but the error mentions an anonymous; pattern, you can try naming your patterns to see exactly where the issue is. .. code-block:: text; :caption: Pattern Example 1. // Match; // %imp = G_IMPLICIT_DEF; // %root = G_MUL %x, %imp; (match (G_IMPLICIT_DEF $imp),; (G_MUL $root, $x, $imp)). .. code-block:: text; :caption: Pattern Example 2. // using",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:1615,simpl,simply,1615,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['simpl'],['simply']
Usability,"text;. // Initialize the driver API; cuInit(0);; // Get a handle to the first compute device; cuDeviceGet(&device, 0);; // Create a compute device context; cuCtxCreate(&context, 0, device);. JIT compiling a PTX string to a device binary:. .. code-block:: c++. CUmodule module;; CUfunction function;. // JIT compile a null-terminated PTX string; cuModuleLoadData(&module, (void*)PTXString);. // Get a handle to the ""myfunction"" kernel function; cuModuleGetFunction(&function, module, ""myfunction"");. For full examples of executing PTX assembly, please see the `CUDA Samples; <https://developer.nvidia.com/cuda-downloads>`_ distribution. Common Issues; =============. ptxas complains of undefined function: __nvvm_reflect; -----------------------------------------------------. When linking with libdevice, the ``NVVMReflect`` pass must be used. See; :ref:`libdevice` for more information. Tutorial: A Simple Compute Kernel; =================================. To start, let us take a look at a simple compute kernel written directly in; LLVM IR. The kernel implements vector addition, where each thread computes one; element of the output vector C from the input vectors A and B. To make this; easier, we also assume that only a single CTA (thread block) will be launched,; and that it will be one dimensional. The Kernel; ----------. .. code-block:: llvm. target datalayout = ""e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64""; target triple = ""nvptx64-nvidia-cuda"". ; Intrinsic to read X component of thread ID; declare i32 @llvm.nvvm.read.ptx.sreg.tid.x() readnone nounwind. define void @kernel(float addrspace(1)* %A,; float addrspace(1)* %B,; float addrspace(1)* %C) {; entry:; ; What is my ID?; %id = tail call i32 @llvm.nvvm.read.ptx.sreg.tid.x() readnone nounwind. ; Compute pointers into A, B, and C; %ptrA = getelementptr float, float addrspace(1)* %A, i32 %id; %ptrB = getelementptr float, float addrspace(1)* ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:12522,simpl,simple,12522,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['simpl'],['simple']
Usability,"text;; ...; }. char *context_projection_function(struct async_context *callee_ctxt) {; return callee_ctxt->caller_context;; }. .. code-block:: llvm. %resume_func_ptr = call ptr @llvm.coro.async.resume(); call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function. The frontend should provide a `async function pointer` struct associated with; each async coroutine by `llvm.coro.id.async`'s argument. The initial size and; alignment of the `async context` must be provided as arguments to the; `llvm.coro.id.async` intrinsic. Lowering will update the size entry with the; coroutine frame requirements. The frontend is responsible for allocating the; memory for the `async context` but can use the `async function pointer` struct; to obtain the required size. .. code-block:: c. struct async_function_pointer {; uint32_t relative_function_pointer_to_async_impl;; uint32_t context_size;; }. Lowering will split an async coroutine into a ramp function and one resume; function per suspend point. How control-flow is passed between caller, suspension point, and back to; resume function is left up to the frontend. The suspend point takes a function and its arguments. The function is intended; to model the transfer to the callee function. It will be tail called by; lowering and therefore must have the same signature and calling convention as; the async coroutine. .. code-block:: llvm. call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function,; ptr %suspend_function,; ptr %arg1, ptr %arg2, i8 %arg3). Coroutines by Example; =====================. The examples below are all of switched-resume coroutines. Coroutine Representation; ------------------------. Let's look at an example of an LLVM coroutine with the behavior sketched; by the following pseudo-code. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend> // returns a coroutine handle on first sus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:10067,resume,resume,10067,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"th a coroutine object in any of these ways while; it is running has undefined behavior. The coroutine function is split into three functions, representing three; different ways that control can enter the coroutine:. 1. the ramp function that is initially invoked, which takes arbitrary; arguments and returns a pointer to the coroutine object;. 2. a coroutine resume function that is invoked when the coroutine is resumed,; which takes a pointer to the coroutine object and returns `void`;. 3. a coroutine destroy function that is invoked when the coroutine is; destroyed, which takes a pointer to the coroutine object and returns; `void`. Because the resume and destroy functions are shared across all suspend; points, suspend points must store the index of the active suspend in; the coroutine object, and the resume/destroy functions must switch over; that index to get back to the correct point. Hence the name of this; lowering. Pointers to the resume and destroy functions are stored in the coroutine; object at known offsets which are fixed for all coroutines. A completed; coroutine is represented with a null resume function. There is a somewhat complex protocol of intrinsics for allocating and; deallocating the coroutine object. It is complex in order to allow the; allocation to be elided due to inlining. This protocol is discussed; in further detail below. The frontend may generate code to call the coroutine function directly;; this will become a call to the ramp function and will return a pointer; to the coroutine object. The frontend should always resume or destroy; the coroutine using the corresponding intrinsics. Returned-Continuation Lowering; ------------------------------. In returned-continuation lowering, signaled by the use of; `llvm.coro.id.retcon` or `llvm.coro.id.retcon.once`, some aspects of; the ABI must be handled more explicitly by the frontend. In this lowering, every suspend point takes a list of ""yielded values""; which are returned back to the caller al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:4581,resume,resume,4581,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"th=""560"" height=""315"" src=""https://www.youtube.com/embed/VqCkCDFLSsc?vq=hd720"" frameborder=""0"" allowfullscreen></iframe></center>. `Slides <https://llvm.org/devmtg/2013-04/klimek-slides.pdf>`_. Introduction; ============. Clang's AST is different from ASTs produced by some other compilers in; that it closely resembles both the written C++ code and the C++; standard. For example, parenthesis expressions and compile time; constants are available in an unreduced form in the AST. This makes; Clang's AST a good fit for refactoring tools. Documentation for all Clang AST nodes is available via the generated; `Doxygen <https://clang.llvm.org/doxygen>`_. The doxygen online; documentation is also indexed by your favorite search engine, which will; make a search for clang and the AST node's class name usually turn up; the doxygen of the class you're looking for (for example, search for:; clang ParenExpr). Examining the AST; =================. A good way to familiarize yourself with the Clang AST is to actually look; at it on some simple example code. Clang has a builtin AST-dump mode,; which can be enabled with the flag ``-ast-dump``. Let's look at a simple example AST:. ::. $ cat test.cc; int f(int x) {; int result = (x / 42);; return result;; }. # Clang by default is a frontend for many tools; -Xclang is used to pass; # options directly to the C++ frontend.; $ clang -Xclang -ast-dump -fsyntax-only test.cc; TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>; ... cutting out internal declarations of clang ...; `-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'; |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'; `-CompoundStmt 0x5aead88 <col:14, line:4:1>; |-DeclStmt 0x5aead10 <line:2:3, col:24>; | `-VarDecl 0x5aeac10 <col:3, col:23> result 'int'; | `-ParenExpr 0x5aeacf0 <col:16, col:23> 'int'; | `-BinaryOperator 0x5aeacc8 <col:17, col:21> 'int' '/'; | |-ImplicitCastExpr 0x5aeacb0 <col:17> 'int' <LValueToRValue>; | | `-DeclRefExpr 0x5aeac68 <col:17> 'int' lvalue ParmVa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:1379,simpl,simple,1379,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,1,['simpl'],['simple']
Usability,"that represents the result; of this class (the squashed code/ C++ function that will be created). - `addToGlobalScope()` helps declare and initialize the results variable, so; that it can be available globally (throughout the function body). For local; variables, the `addToCodeBody()` function can be used to keep the variables in; the respective scope (for example, within a loop). - `beginLoop()` helps build the start and the end of a For loop for your; class. Simply place this function in the scope and place the contents of the; `For` loop below this statement. The code squashing task will automatically; build a loop around the statements that follow it. There's no need to worry; about the index of these loops, because they get propagated. For example, if; you want to iterate over a vector of RooFit objects using a loop, you don't; have to think about indexing them properly because the `beginLoop()` function; takes care of that. Simply call this function, place your function call in a; scope and after the scope ends, the loop will also end. - `addToCodeBody()` helps add things to the body of the C++ function that; you're creating. It takes whatever string is computed in its arguments and; adds it to the overall function string (which will later be just-in-time; compiled). The `addToCodeBody()` function is important since not everything; can be added in-line and this function helps split the code into multiple; lines. ### Step 3. analyticalIntegral() Use Case. > Besides the `evaluate()` function, this tutorial illustrates how the; `analyticalIntegral()` can be updated. This highly dependent on the class that; is being transformed for AD support, but will be necessary in those specific; instances. Let's consider a fictional class RooFoo, that performs some arbitrary; mathematical operations called 'Foo' (as seen in doFoo() function below). > Note that doFoo is a simplified example, in many cases the mathematical; operations are not limited to a single function, so th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:18206,Simpl,Simply,18206,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['Simpl'],['Simply']
Usability,"the ""t.c"" input into an object file, two to assemble the; ""t.s"" input, and one to link them together. A rather different compilation pipeline is shown here; in this; example there are two top level actions to compile the input files; into two separate object files, where each object file is built using; ``lipo`` to merge results built for two separate architectures. .. code-block:: console. $ clang -ccc-print-phases -c -arch i386 -arch x86_64 t0.c t1.c; 0: input, ""t0.c"", c; 1: preprocessor, {0}, cpp-output; 2: compiler, {1}, assembler; 3: assembler, {2}, object; 4: bind-arch, ""i386"", {3}, object; 5: bind-arch, ""x86_64"", {3}, object; 6: lipo, {4, 5}, object; 7: input, ""t1.c"", c; 8: preprocessor, {7}, cpp-output; 9: compiler, {8}, assembler; 10: assembler, {9}, object; 11: bind-arch, ""i386"", {10}, object; 12: bind-arch, ""x86_64"", {10}, object; 13: lipo, {11, 12}, object. After this stage is complete the compilation process is divided into; a simple set of actions which need to be performed to produce; intermediate or final outputs (in some cases, like ``-fsyntax-only``,; there is no ""real"" final output). Phases are well known compilation; steps, such as ""preprocess"", ""compile"", ""assemble"", ""link"", etc. #. **Bind: Tool & Filename Selection**. This stage (in conjunction with the Translate stage) turns the tree; of Actions into a list of actual subprocess to run. Conceptually, the; driver performs a top down matching to assign Action(s) to Tools. The; ToolChain is responsible for selecting the tool to perform a; particular action; once selected the driver interacts with the tool; to see if it can match additional actions (for example, by having an; integrated preprocessor). Once Tools have been selected for all actions, the driver determines; how the tools should be connected (for example, using an inprocess; module, pipes, temporary files, or user provided filenames). If an; output file is required, the driver also computes the appropriate; file name (the suffix and fil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:8219,simpl,simple,8219,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simple']
Usability,"the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; ```. The biggest application of the memory-safe interfaces is to spot memory leaks; in RooFit-based frameworks. If you make sure that your framework compiles both; with and without `ROOFIT_MEMORY_SAFE_INTERFACES`, you can get rid of all memory; leaks related to RooFit user error! After making the necessary changes, you can; remove the marco definition again to keep backwards compatibility. Note that the memory-safe interfaces might become the default at some point, so; doing this **backwards-compatible migration early** is strongly encouraged and; appreciated. ### Removal of some memory-unsafe interfaces. * The final `bool takeOwnership` parameter of the **RooAddition** and; **RooStats::HistFactory::PiecewiseInterpolation** constructors was removed.; This is to avoid situations where ownership is not clear to the compiler.; Now, ownership of the input RooAbsArgs is never passed in the constructor. If; you want the pass input ownership to the created object, please use; `addOwnedComponents`. If you want to be extra safe, make sure the inputs are; in an owning collection and then `std::move` the collection, so that the; ownership is always clear. Example:; ```c++; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; ```; should become:; ```c++; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addition{""addition"", ""addition"", sumSet};; addition.addOwnedComponents(std::move(sumSet));; ```. ### Deprecation of legacy iterators. The following methods related to the RooFit legacy iterators are deprecated an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:10851,clear,clear,10851,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['clear'],['clear']
Usability,"the bookkeeping and to facilitate *O(1)* addition and; removal. .. _Use2User:. Interaction and relationship between ``User`` and ``Use`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A subclass of ``User`` can choose between incorporating its ``Use`` objects or; refer to them out-of-line by means of a pointer. A mixed variant (some ``Use``; s inline others hung off) is impractical and breaks the invariant that the; ``Use`` objects belonging to the same ``User`` form a contiguous array. We have 2 different layouts in the ``User`` (sub)classes:. * Layout a). The ``Use`` object(s) are inside (resp. at fixed offset) of the ``User``; object and there are a fixed number of them. * Layout b). The ``Use`` object(s) are referenced by a pointer to an array from the; ``User`` object and there may be a variable number of them. As of v2.4 each layout still possesses a direct pointer to the start of the; array of ``Use``\ s. Though not mandatory for layout a), we stick to this; redundancy for the sake of simplicity. The ``User`` object also stores the; number of ``Use`` objects it has. (Theoretically this information can also be; calculated given the scheme presented below.). Special forms of allocation operators (``operator new``) enforce the following; memory layouts:. * Layout a) is modelled by prepending the ``User`` object by the ``Use[]``; array. .. code-block:: none. ...---.---.---.---.-------...; | P | P | P | P | User; '''---'---'---'---'-------'''. * Layout b) is modelled by pointing at the ``Use[]`` array. .. code-block:: none. .-------...; | User; '-------'''; |; v; .---.---.---.---...; | P | P | P | P |; '---'---'---'---'''. *(In the above figures* '``P``' *stands for the* ``Use**`` *that is stored in; each* ``Use`` *object in the member* ``Use::Prev`` *)*. .. _polymorphism:. Designing Type Hierarchies and Polymorphic Interfaces; -----------------------------------------------------. There are two different design patterns that tend to re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:128076,simpl,simplicity,128076,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplicity']
Usability,"the coroutine handle of the enclosing; coroutine. A frontend is allowed to supply null as the first parameter, in this; case `coro-early` pass will replace the null with an appropriate coroutine; handle value. The second argument should be `true` if this coro.end is in the block that is; part of the unwind sequence leaving the coroutine body due to an exception and; `false` otherwise. The third argument if present should specify a function to be called. If the third argument is present, the remaining arguments are the arguments to; the function call. .. code-block:: llvm. call i1 (ptr, i1, ...) @llvm.coro.end.async(; ptr %hdl, i1 0,; ptr @must_tail_call_return,; ptr %ctxt, ptr %task, ptr %actor); unreachable. .. _coro.suspend:; .. _suspend points:. 'llvm.coro.suspend' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i8 @llvm.coro.suspend(token <save>, i1 <final>). Overview:; """""""""""""""""". The '``llvm.coro.suspend``' marks the point where execution of a; switched-resume coroutine is suspended and control is returned back; to the caller. Conditional branches consuming the result of this; intrinsic lead to basic blocks where coroutine should proceed when; suspended (-1), resumed (0) or destroyed (1). Arguments:; """""""""""""""""""". The first argument refers to a token of `coro.save` intrinsic that marks the; point when coroutine state is prepared for suspension. If `none` token is passed,; the intrinsic behaves as if there were a `coro.save` immediately preceding; the `coro.suspend` intrinsic. The second argument indicates whether this suspension point is `final`_.; The second argument only accepts constants. If more than one suspend point is; designated as final, the resume and destroy branches should lead to the same; basic blocks. Example (normal suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %resume; i8 1, label %cleanup]. Example (final ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:49866,resume,resume,49866,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. Changes to LLVM infrastructure; ------------------------------. * Minimum Clang version to build LLVM in C++20 configuration has been updated to clang-17.0.6. Changes to building LLVM; ------------------------. Changes to TableGen; -------------------. * Added constructs for debugging ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:1608,simpl,simply,1608,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['simpl'],['simply']
Usability,"the function declaration ``f(int x)``. In C++, declaration names can also name; class constructors (""``Class``"" in ``struct Class { Class(); }``), class; destructors (""``~Class``""), overloaded operator names (""``operator+``""), and; conversion functions (""``operator void const *``""). In Objective-C,; declaration names can refer to the names of Objective-C methods, which involve; the method name and the parameters, collectively called a *selector*, e.g.,; ""``setWidth:height:``"". Since all of these kinds of entities --- variables,; functions, Objective-C methods, C++ constructors, destructors, and operators; --- are represented as subclasses of Clang's common ``NamedDecl`` class,; ``DeclarationName`` is designed to efficiently represent any kind of name. Given a ``DeclarationName`` ``N``, ``N.getNameKind()`` will produce a value; that describes what kind of name ``N`` stores. There are 10 options (all of; the names are inside the ``DeclarationName`` class). ``Identifier``. The name is a simple identifier. Use ``N.getAsIdentifierInfo()`` to retrieve; the corresponding ``IdentifierInfo*`` pointing to the actual identifier. ``ObjCZeroArgSelector``, ``ObjCOneArgSelector``, ``ObjCMultiArgSelector``. The name is an Objective-C selector, which can be retrieved as a ``Selector``; instance via ``N.getObjCSelector()``. The three possible name kinds for; Objective-C reflect an optimization within the ``DeclarationName`` class:; both zero- and one-argument selectors are stored as a masked; ``IdentifierInfo`` pointer, and therefore require very little space, since; zero- and one-argument selectors are far more common than multi-argument; selectors (which use a different structure). ``CXXConstructorName``. The name is a C++ constructor name. Use ``N.getCXXNameType()`` to retrieve; the :ref:`type <QualType>` that this constructor is meant to construct. The; type is always the canonical type, since all constructors for a given type; have the same name. ``CXXDestructorName``. The name i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:69392,simpl,simple,69392,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"the header files being bound. This is used to; generate the generic C++ binding code (and some ancillary files) using; a modified C++ compiler. The needed options must be compatible with the; normal build environment of the header files.; - One to compile the generated, generic C++ binding code using a standard; C++ compiler. The resulting library code is ""universal"" in that it is; compatible with both Python2 and Python3.; - One to package the library and ancillary files into standard Python2/3; wheel format. The packaging is done using native Python tooling. +----------------------+---------------------------------------------------------------------------------------------+; |Arguments and options | Description |; +======================+=============================================================================================+; |pkg | The name of the package to generate. This can be either |; | | of the form ""simplename"" (e.g. ""Akonadi""), or of the |; | | form ""namespace.simplename"" (e.g. ""KF5.Akonadi""). |; +----------------------+---------------------------------------------------------------------------------------------+; |pkg_version | The version of the package. |; +----------------------+---------------------------------------------------------------------------------------------+; |author | The name of the library author. |; +----------------------+---------------------------------------------------------------------------------------------+; |author_email | The email address of the library author. |; +----------------------+---------------------------------------------------------------------------------------------+; |URL url | The home page for the library. Default is |; | | ""https://pypi.python.org/pypi/<pkg>"". |; +----------------------+---------------------------------------------------------------------------------------------+; |LICENSE license | The license, default is ""LGPL 2.0"". |; +----------------------+-------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:5869,simpl,simplename,5869,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['simpl'],['simplename']
Usability,"the need to track data associated with a; symbolic expression; a map type is the most logical way to implement this. The; key for this map will be a pointer to a symbolic expression; (SymbolRef). If the data type to be associated with the symbolic; expression is an integer, then the custom category of state information would be; declared as. REGISTER_MAP_WITH_PROGRAMSTATE(ExampleDataType, SymbolRef, int). The data would be accessed with the function. ProgramStateRef state;; SymbolRef Sym;; ...; int currentlValue = state->get<ExampleDataType>(Sym);. and set with the function. ProgramStateRef state;; SymbolRef Sym;; int newValue;; ...; ProgramStateRef newState = state->set<ExampleDataType>(Sym, newValue);. In addition, the macros define a data type used for storing the data of the; new data category; the name of this type is the name of the data category with; ""Ty"" appended. For REGISTER_TRAIT_WITH_PROGRAMSTATE, this will simply; be passed data type; for the other three macros, this will be a specialized; version of the llvm::ImmutableList,; llvm::ImmutableSet,; or llvm::ImmutableMap; templated class. For the ExampleDataType example above, the type; created would be equivalent to writing the declaration:. using ExampleDataTypeTy = llvm::ImmutableMap<SymbolRef, int>;. These macros will cover a majority of use cases; however, they still have a; few limitations. They cannot be used inside namespaces (since they expand to; contain top-level namespace references), and the data types that they define; cannot be referenced from more than one file. Note that ProgramStates are immutable; instead of modifying an existing; one, functions that modify the state will return a copy of the previous state; with the change applied. This updated state must be then provided to the; analyzer core by calling the CheckerContext::addTransition function.; Bug Reports; When a checker detects a mistake in the analyzed code, it needs a way to; report it to the analyzer core so that it can be disp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:14660,simpl,simply,14660,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['simpl'],['simply']
Usability,"the old manglings if ``-fclang-abi-compat=17`` or lower is; specified.; (`#48216 <https://github.com/llvm/llvm-project/issues/48216>`_),; (`#49884 <https://github.com/llvm/llvm-project/issues/49884>`_), and; (`#61273 <https://github.com/llvm/llvm-project/issues/61273>`_). - The `ClassScopeFunctionSpecializationDecl` AST node has been removed.; Dependent class scope explicit function template specializations now use; `DependentFunctionTemplateSpecializationInfo` to store candidate primary; templates and explicit template arguments. This should not impact users of; Clang as a compiler, but it may break assumptions in Clang-based tools; iterating over the AST. - The warning `-Wenum-constexpr-conversion` is now also enabled by default on; system headers and macros. It will be turned into a hard (non-downgradable); error in the next Clang release. - The flag `-fdelayed-template-parsing` won't be enabled by default with C++20; when targetting MSVC to match the behavior of MSVC.; (`MSVC Docs <https://learn.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance?view=msvc-170>`_). - Remove the hardcoded path to the imported modules for C++20 named modules. Now we; require all the dependent modules to specified from the command line.; See (`#62707 <https://github.com/llvm/llvm-project/issues/62707>`_). - Forbid `import XXX;` in C++ to find module `XXX` comes from explicit clang modules.; See (`#64755 <https://github.com/llvm/llvm-project/issues/64755>`_). ABI Changes in This Version; ---------------------------; - Following the SystemV ABI for x86-64, ``__int128`` arguments will no longer; be split between a register and a stack slot. - Fixed Microsoft calling convention for returning certain classes with a; templated constructor. If a class has a templated constructor, it should; be returned indirectly even if it meets all the other requirements for; returning a class in a register. This affects some uses of std::pair.; (#GH86384). AST Dumping Potentially Br",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:6104,learn,learn,6104,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['learn'],['learn']
Usability,"the results one can simply use; operator[] returning a TString. New tutorial regexp_pme.C. Meta. Add a new TClass interface to be able to trigger the ""auto addition of object; to a TDirectory object"". If a class has a member function:; DirectoryAutoAdd(TDirectory*); it will now be accessible (when the dictionary is generated via rootcint; for now) via TClass::GetDirectoryAutoAdd which return a wrapper with the; signature:; void (*)(void *this_obj,TDirectory *where_to_add). Extend #pragma create TClass; to namespaces.; Enable autoloading of the cintdlls.; rlibmap now handles #pragma create TClass; statements. Cont. Support for std algorithms and iterators for ROOT collection classes by Anar.; The background is the following. While working on the PROOF code I found; that enumerating TList is an inconvenient and a long operation, I had to; write the same code all over the place and make duplications. I tried; to use STD algorithms with it, namely std::for_each, and failed.; I therefore decided to enable std::for_each algorithm for ROOT; Containers/Iterators by making as few as possible changes, without rewriting; iterators at all. Now with only two simple lines of code one is able to; iterate through a container:. TIter iter(&list);; for_each(iter.Begin(), TIter::End(), SEnumFunctor());. or. for_each(iter.Begin(), inter_end, SEnumFunctor());. where iter_end could be an iterator to a middle of the container. After I had changed Iterators so that they could be used with std::for_each,; I decided to go further and did some more changes. As a result,. I have updated CINT implementation of some algorithms (they look now; more or less better in terms of the standard),. All collections can be now used with std::for_each, std::find_if,; std::count_if (probably with some more algorithms. I've listed here; only what has been *checked* by me). A test program has been added: $ROOTSYS/test/stressIterators.cxx. A tutorial macro has been added: $ROOTSYS/tutorials/cont/TListAndSTL.C. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html:4093,simpl,simple,4093,core/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html,1,['simpl'],['simple']
Usability,"the set of declaration contexts that are; semantically connected to this declaration context, in source order, including; this context (which will be the only result, for non-namespace contexts) via; ``DeclContext::collectAllContexts``. Note that these functions are used; internally within the lookup and insertion methods of the ``DeclContext``, so; the vast majority of clients can ignore them. Because the same entity can be defined multiple times in different modules,; it is also possible for there to be multiple definitions of (for instance); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84143,simpl,simply,84143,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability,"the steps of coroutine lowering is building the coroutine frame. The; def-use chains are analyzed to determine which objects need be kept alive across; suspend points. In the coroutine shown in the previous section, use of virtual register; `%inc` is separated from the definition by a suspend point, therefore, it; cannot reside on the stack frame since the latter goes away once the coroutine; is suspended and control is returned back to the caller. An i32 slot is; allocated in the coroutine frame and `%inc` is spilled and reloaded from that; slot as needed. We also store addresses of the resume and destroy functions so that the; `coro.resume` and `coro.destroy` intrinsics can resume and destroy the coroutine; when its identity cannot be determined statically at compile time. For our; example, the coroutine frame will be:. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32 }. After resume and destroy parts are outlined, function `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i32 0, i32 2; store i32 %inc, ptr %inc.spill.addr; call void @print(i32 %n). ret ptr %frame; }. Outlined resume part of the coroutine will reside in function `f.resume`:. .. code-block:: llvm. define internal fastcc void @f.resume(ptr %frame.ptr.resume) {; entry:; %inc.spill.addr = getelementptr %f.frame, ptr %frame.ptr.resume, i64 0, i32 2; %inc.spill = load i32, ptr %inc.spill.addr, align ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:14679,resume,resume,14679,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"the type itself, we do not need; to create duplicates of types with different sets of qualifiers (i.e. there is; only a single heap allocated ""``int``"" type: ""``const int``"" and ""``volatile; const int``"" both point to the same heap allocated ""``int``"" type). This; reduces the heap size used to represent bits and also means we do not have to; consider qualifiers when uniquing types (:ref:`Type <Type>` does not even; contain qualifiers). In practice, the two most common type qualifiers (``const`` and ``restrict``); are stored in the low bits of the pointer to the ``Type`` object, together with; a flag indicating whether extended qualifiers are present (which must be; heap-allocated). This means that ``QualType`` is exactly the same size as a; pointer. .. _DeclarationName:. Declaration names; -----------------. The ``DeclarationName`` class represents the name of a declaration in Clang.; Declarations in the C family of languages can take several different forms.; Most declarations are named by simple identifiers, e.g., ""``f``"" and ""``x``"" in; the function declaration ``f(int x)``. In C++, declaration names can also name; class constructors (""``Class``"" in ``struct Class { Class(); }``), class; destructors (""``~Class``""), overloaded operator names (""``operator+``""), and; conversion functions (""``operator void const *``""). In Objective-C,; declaration names can refer to the names of Objective-C methods, which involve; the method name and the parameters, collectively called a *selector*, e.g.,; ""``setWidth:height:``"". Since all of these kinds of entities --- variables,; functions, Objective-C methods, C++ constructors, destructors, and operators; --- are represented as subclasses of Clang's common ``NamedDecl`` class,; ``DeclarationName`` is designed to efficiently represent any kind of name. Given a ``DeclarationName`` ``N``, ``N.getNameKind()`` will produce a value; that describes what kind of name ``N`` stores. There are 10 options (all of; the names are inside the ``De",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:68343,simpl,simple,68343,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"the user function by varying parameter number; $\mbox{par}$, leaving all other parameters fixed at the current; value. If $\mbox{par}$ is not specified, all variable parameters are; scanned in sequence. The number of points $\mbox{npoints}$ in the; scan is 40 by default, and cannot exceed 100. The range of the scan is; by default 2 standard deviations on each side of the current best value,; but can be specified as from $\mbox{low}$ to $\mbox{high}$.; After each scan, if a new minimum is found, the best parameter values; are retained as start values for future scans or minimizations. The; curve resulting from each scan can be plotted on the output terminal; using MnPlot [api:plot] in order to show the approximate behaviour of; the function. ### ScanMinimizer ###. Although the $\mbox{SCAN}$ method is not intended for minimization; it can be used as a minimizer in its most primitive form. ## MnSimplex and SimplexMinimizer ##. [api:simplex]. $\mbox{SIMPLEX}$ is a function minimization method using the simplex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; parameters interaction. It also retains the result from the last; minimization in case the user may want to do subsequent minimization; steps with parameter interactions in between the minimization requests.; The minimization is done by the SimplexMinimizer. Minimization of the; function can be done by directly using the SimplexMinimizer if no; parameters interaction is required. As $\mbox{SIMPLEX}$ is a; stepping method it does not produce a covariance matrix. ### MnSimplex(const FCNBase&, const std::vector$<$double$>$&,\; const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameters&,\; unsigned int) ###. Constru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:48423,SIMPL,SIMPLEX,48423,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,2,"['SIMPL', 'simpl']","['SIMPLEX', 'simplex']"
Usability,"the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/SparseSet.h; ^^^^^^^^^^^^^^^^^^^^. SparseSet holds a small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physical registers, virtual registers, or; numbered basic blocks. SparseSet is useful for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet's; desirable attributes. Like SparseSet, it typically uses a lot of memory, but; provides operations that are almost as fast as a vector. Typical keys are; physical re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:80272,simpl,simple,80272,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any selection or with only a single one, it was not easy to; understand. ![Several selections can be defined each of them having its own color.](pictures/para8.png). Interactive selections on Parallel Coordinates are a powerful tool because; they can be defined graphically on many variables (graphical cuts in ROOT can; be defined on two variables only) which allow a very accurate events; filtering. Selections allow making precise events choices: a single outlying; event is clearly visible when the lines are displayed as “solid” therefore; it is easy to make cuts in order to eliminate one single event from a; selection. Such selection (to filter one single event) on a scatter plot; would be much more difficult. ![Selections allow to easily filter one single event.](pictures/para9.png). Once a selection has been defined, it is possible to use it to generate a; `TEntryList` which is applied on the tree and used at drawing time. In our; example the selection we defined",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:101029,clear,clearly,101029,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clearly']
Usability,"the; `MLPfit` package, which remains one of the fastest tools for neural; networks studies. ### The MLP. The multilayer perceptron is a simple feed-forward network with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output neurons or a sigmoid for hidden layers. Such a structure is very useful because of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:71384,Learn,Learning,71384,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['Learn'],['Learning']
Usability,"the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any selection or with only a single one, it was not easy to; understand. ![Several selections can be defined each of them having its own color.](pictures/para8.png). Interactive selections on Parallel Coordinates are a powerful tool because; they can be defined graphically on many variables (graphical cuts in ROOT can; be defined on two variables only) which allow a very accurate events; filtering. Selections allow making precise events choices: a single outlying; event is clearly visible when the lines are displayed as “solid” therefore; it is easy to make cuts in order to eliminate one single event from a; selection. Such selection (to filter one single event) on a scatter plot; would be much more difficult. ![Selections allow to easily filter one single event.](pictures/para9.png). Once a selection has been defined, it is possible to use it to generate a; `TEntryList` which is applied on the tree and used at drawing time. In our; example the selection we defined allows to select exactly the two; correlated “random spheres”. ![Output of `nt->Draw(“x:y:z”)` and `nt->Draw(“u:v:w”)` after applying the selection.](pictures/para10.png). Another technique has been implemented in order to show clusters when; the picture is cluttered. A weight is assigned to each event. The weight; value is computed as:; $$; weight = \sum_{i=1}^{n} b_i; $$. Where:. - bi is the content of bin crossed by the event on the i-th axis.; - n is the number of axis. The events having the bigger weights are those belongin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:101600,clear,clearly,101600,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clearly']
Usability,"ther passes, it's time to get a little bit; fancier. All of the pass relationships that we have seen so far are very; simple: one pass depends on one other specific pass to be run before it can; run. For many applications, this is great, for others, more flexibility is; required. In particular, some analyses are defined such that there is a single simple; interface to the analysis results, but multiple ways of calculating them.; Consider alias analysis for example. The most trivial alias analysis returns; ""may alias"" for any alias query. The most sophisticated analysis a; flow-sensitive, context-sensitive interprocedural analysis that can take a; significant amount of time to execute (and obviously, there is a lot of room; between these two extremes for other implementations). To cleanly support; situations like this, the LLVM Pass Infrastructure supports the notion of; Analysis Groups. Analysis Group Concepts; ^^^^^^^^^^^^^^^^^^^^^^^. An Analysis Group is a single simple interface that may be implemented by; multiple different passes. Analysis Groups can be given human readable names; just like passes, but unlike passes, they need not derive from the ``Pass``; class. An analysis group may have one or more implementations, one of which is; the ""default"" implementation. Analysis groups are used by client passes just like other passes are: the; ``AnalysisUsage::addRequired()`` and ``Pass::getAnalysis()`` methods. In order; to resolve this requirement, the :ref:`PassManager; <writing-an-llvm-pass-passmanager>` scans the available passes to see if any; implementations of the analysis group are available. If none is available, the; default implementation is created for the pass to use. All standard rules for; :ref:`interaction between passes <writing-an-llvm-pass-interaction>` still; apply. Although :ref:`Pass Registration <writing-an-llvm-pass-registration>` is; optional for normal passes, all analysis group implementations must be; registered, and must use the :ref:`IN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:35701,simpl,simple,35701,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"this article, click **Show Source** on the right sidebar. Authoring Guidelines; ====================. Focus on *content*. It is easy to fix the Sphinx (reStructuredText) syntax; later if necessary, although reStructuredText tries to imitate common; plain-text conventions so it should be quite natural. A basic knowledge of; reStructuredText syntax is useful when writing the document, so the last; ~half of this document (starting with `Example Section`_) gives examples; which should cover 99% of use cases. Let me say that again: focus on *content*. But if you really need to verify; Sphinx's output, see ``docs/README.txt`` for information. Once you have finished with the content, please send the ``.rst`` file to; llvm-commits for review. Creating New Articles; ---------------------. Before creating a new article, consider the following questions:. #. Why would I want to read this document?. #. What should I know to be able to follow along with this document?. #. What will I have learned by the end of this document?. A standard best practice is to make your articles task-oriented. You generally should not be writing documentation that isn't based around ""how to"" do something; unless there's already an existing ""how to"" article for the topic you're documenting. The reason for this is that without a ""how to"" article to read first, it might be difficult for; someone unfamiliar with the topic to understand a more advanced, conceptual article. When creating a task-oriented article, follow existing LLVM articles by giving it a filename that starts with ``HowTo*.rst``. This format is usually the easiest for another person to understand and also the most useful. Focus on content (yes, I had to say it again). The rest of this document shows example reStructuredText markup constructs; that are meant to be read by you in your text editor after you have copied; this file into a new file for the documentation you are about to write. Example Section; ===============. An article can co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst:2036,learn,learned,2036,interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst,1,['learn'],['learned']
Usability,"this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now defaults to detecting use-after-scope bugs. * `SpecialCaseList <https://clang.llvm.org/docs/SanitizerSpecialCaseList.html#format>`_; used by sanitizer ignore lists (e.g. ``*_ignorelist.txt`` in the Clang; resource directory) now uses glob patterns instead of a variant of POSIX; Extended Regular Expression (where ``*`` is translated to ``.*``) by default.; Search for ``|`` to find patterns that may have different meanings now, and; replace ``a|b`` with ``{a,b}``. Changes to the Profile Runtime; ------------------------------. * Public header ``profile/instr_prof_interface.h`` is added to declare four; API functions to fine tune profile collection. Other Changes; -------------. * The ``Flags`` field of ``llvm::opt::Option`` has been split into ``Flags``; and ``Visibility`` to simplify option sharing between various drivers (such; as ``clang``, ``clang-cl``, or ``flang``) that rely on Clang's Options.td.; Overloads of ``llvm::opt::OptTable`` that use ``FlagsToInclude`` have been; deprecated. There is a script and instructions on how to resolve conflicts -; see https://reviews.llvm.org/D157150 and https://reviews.llvm.org/D157151 for; details. * On Linux, FreeBSD, and NetBSD, setting the environment variable; ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` causes tools to print stacktraces using; :doc:`Symbolizer Markup <SymbolizerMarkupFormat>`.; This works even if the tools have no embedded symbol information (i.e. are; fully stripped); :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` can; symbolize the markup afterwards using ``debuginfod``. External Open Source Projects Using LLVM 15; ===========================================. * A project... Additional Information; ======================. A wide variety of additional information is available on the `LLVM web page; <https://l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:18328,simpl,simplify,18328,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['simpl'],['simplify']
Usability,"thod is named ""size"":. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr().bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. We express the pattern with the given AST matcher, which binds the method call's; target to ``s`` [#f1]_. For the edit, we again use ``changeTo``, but this; time we construct the term from multiple parts, which we compose with ``cat``. The; second part of our term is ``node(s)``, which selects the source code; corresponding to the AST node ``s`` that was bound when a match was found in the; AST for our rule's pattern. ``node(s)`` constructs a ``RangeSelector``, which, when; used in ``cat``, indicates that the selected source should be inserted in the; output at that point. Now, we probably don't want to rewrite *all* invocations of ""size"" methods, just; those on ``std::string``\ s. We can achieve this change simply by refining our; matcher. The rest of the rule remains unchanged:. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:6923,simpl,simply,6923,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['simpl'],['simply']
Usability,"thods may well read or write to those instance; variables. Making such message sends from dealloc is generally discouraged,; since the subclass may well rely on other invariants that were broken during; ``dealloc``, but it's not so inescapably dangerous that we felt comfortable; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; deallocation will trigger a side-effect which must be carefully ordered with; respect to the destruction of the super class. Such code violates the design; principle that semantically important behavior should be explicit. A simple; fix is to clear the instance variable manually during ``dealloc``; a more; holistic solution is to move semantically important side-effects out of; ``dealloc`` and into a separate teardown phase which can rely on working with; well-formed objects. .. _arc.misc.autoreleasepool:. ``@autoreleasepool``; --------------------. To simplify the use of autorelease pools, and to bring them under the control; of the compiler, a new kind of statement is available in Objective-C. It is; written ``@autoreleasepool`` followed by a *compound-statement*, i.e. by a new; scope delimited by curly braces. Upon entry to this block, the current state; of the autorelease pool is captured. When the block is exited normally,; whether by fallthrough or directed control flow (such as ``return`` or; ``break``), the autorelease pool is restored to the saved state, releasing all; the objects in it. When the block is exited with an exception, the pool is not; drained. ``@autoreleasepool`` may be used in non-ARC translation units, with equivalent; semantics. A program is ill-formed if it refers to the ``NSAutoreleasePool`` class. .. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:90175,simpl,simple,90175,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"tially; different ABIs, and expect substantially different patterns of frontend; code generation. However, the styles also have a great deal in common. In all cases, an LLVM coroutine is initially represented as an ordinary LLVM; function that has calls to `coroutine intrinsics`_ defining the structure of; the coroutine. The coroutine function is then, in the most general case,; rewritten by the coroutine lowering passes to become the ""ramp function"",; the initial entrypoint of the coroutine, which executes until a suspend point; is first reached. The remainder of the original coroutine function is split; out into some number of ""resume functions"". Any state which must persist; across suspensions is stored in the coroutine frame. The resume functions; must somehow be able to handle either a ""normal"" resumption, which continues; the normal execution of the coroutine, or an ""abnormal"" resumption, which; must unwind the coroutine without attempting to suspend it. Switched-Resume Lowering; ------------------------. In LLVM's standard switched-resume lowering, signaled by the use of; `llvm.coro.id`, the coroutine frame is stored as part of a ""coroutine; object"" which represents a handle to a particular invocation of the; coroutine. All coroutine objects support a common ABI allowing certain; features to be used without knowing anything about the coroutine's; implementation:. - A coroutine object can be queried to see if it has reached completion; with `llvm.coro.done`. - A coroutine object can be resumed normally if it has not already reached; completion with `llvm.coro.resume`. - A coroutine object can be destroyed, invalidating the coroutine object,; with `llvm.coro.destroy`. This must be done separately even if the; coroutine has reached completion normally. - ""Promise"" storage, which is known to have a certain size and alignment,; can be projected out of the coroutine object with `llvm.coro.promise`.; The coroutine implementation must have been compiled to define a p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:2549,Resume,Resume,2549,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['Resume'],['Resume']
Usability,"ties provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://github.com/llvm/llvm-project.git. Note: Some Clang tests are sensitive to the line endings. Ensure; that checking out the files does not convert LF line endings to CR+LF. If; you're using git on Windows, make sure your core.autocrlf setting; is false. Run CMake to generate the Visual Studio solution and project files:; ; cd llvm-project; mkdir build (for building without polluting the source dir); cd build. If you are using Visual Studio 2019:; cmake -DLLVM_ENABLE_PROJECTS=clang -G ""Visual Studio 16 2019"" -A x64 -Thost=x64 ..\llvm; -Thost=x64 is required, since the 32-bit linker will run out of memory.; ; To generate x86 binaries instead of x64, pass -A Win32.; See the LLVM CMake guide for; more information on other configuration options for CMake.; The above, if successful, will have created an LLVM.sln file in the; build directory.; . Build Clang:; ; Open LLVM.sln in Visual Studio.; Build the ""clang"" project for just the compiler driver and front end, or; the ""ALL_BUILD"" project to build everything, including tools. Try it out (assuming you added llvm/debug/bin to your path). (See the; running examples from above.); See ; Hacking on clang - Testing using Visual Studio on Windows for information; on running regression tests on Windows. Using Ninja alongside Visual Studio; We recommend that developers who want the fastest incremental builds use the; Ninja build system. You can use the; generated Visual Studio project files to edit Clang source code and generate a; second build directory next to it for running the tests with these steps:. Check out clang and LLVM as described above; Open a developer command prompt with the appropriate environment.; ; If you open the start menu and sear",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:4968,guid,guide,4968,interpreter/llvm-project/clang/www/get_started.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html,1,['guid'],['guide']
Usability,"time.; Such new versions will be similar in spirit to the present version,; but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library; specifies a version number of this License which applies to it and; ""any later version"", you have the option of following the terms and; conditions either of that version or of any later version published by; the Free Software Foundation. If the Library does not specify a; license version number, you may choose any version ever published by; the Free Software Foundation. 14. If you wish to incorporate parts of the Library into other free; programs whose distribution conditions are incompatible with these,; write to the author to ask for permission. For software which is; copyrighted by the Free Software Foundation, write to the Free; Software Foundation; we sometimes make exceptions for this. Our; decision will be guided by the two goals of preserving the free status; of all derivatives of our free software and of promoting the sharing; and reuse of software generally. NO WARRANTY. 15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO; WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.; EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR; OTHER PARTIES PROVIDE THE LIBRARY ""AS IS"" WITHOUT WARRANTY OF ANY; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR; PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE; LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME; THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN; WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY; AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU; FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR; CONSEQUENTIAL DAMAGES A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT:25075,guid,guided,25075,interpreter/cling/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT,1,['guid'],['guided']
Usability,"tin_va_arg_pack``/``__builtin_va_arg_pack_len``. This is; used rarely, but in some potentially interesting places, like the; glibc headers, so it may be implemented pending user demand. Note; that because clang pretends to be like GCC 4.2, and this extension; was introduced in 4.3, the glibc headers will not try to use this; extension with clang at the moment.; - clang does not support the gcc extension for forward-declaring; function parameters; this has not shown up in any real-world code; yet, though, so it might never be implemented. This is not a complete list; if you find an unsupported extension; missing from this list, please send an e-mail to cfe-dev. This list; currently excludes C++; see :ref:`C++ Language Features <cxx>`. Also, this; list does not include bugs in mostly-implemented features; please see; the `bug; tracker <https://bugs.llvm.org/buglist.cgi?quicksearch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:135442,guid,guidelines,135442,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['guid'],['guidelines']
Usability,"ting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:3168,Simpl,Simply,3168,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['Simpl'],['Simply']
Usability,"ting with exceptions on Windows is significantly more complicated than; on Itanium C++ ABI platforms. The fundamental difference between the two models; is that Itanium EH is designed around the idea of ""successive unwinding,"" while; Windows EH is not. Under Itanium, throwing an exception typically involves allocating thread local; memory to hold the exception, and calling into the EH runtime. The runtime; identifies frames with appropriate exception handling actions, and successively; resets the register context of the current thread to the most recently active; frame with actions to run. In LLVM, execution resumes at a ``landingpad``; instruction, which produces register values provided by the runtime. If a; function is only cleaning up allocated resources, the function is responsible; for calling ``_Unwind_Resume`` to transition to the next most recently active; frame after it is finished cleaning up. Eventually, the frame responsible for; handling the exception calls ``__cxa_end_catch`` to destroy the exception,; release its memory, and resume normal control flow. The Windows EH model does not use these successive register context resets.; Instead, the active exception is typically described by a frame on the stack.; In the case of C++ exceptions, the exception object is allocated in stack memory; and its address is passed to ``__CxxThrowException``. General purpose structured; exceptions (SEH) are more analogous to Linux signals, and they are dispatched by; userspace DLLs provided with Windows. Each frame on the stack has an assigned EH; personality routine, which decides what actions to take to handle the exception.; There are a few major personalities for C and C++ code: the C++ personality; (``__CxxFrameHandler3``) and the SEH personalities (``_except_handler3``,; ``_except_handler4``, and ``__C_specific_handler``). All of them implement; cleanups by calling back into a ""funclet"" contained in the parent function. Funclets, in this context, are regions of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:21149,resume,resume,21149,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['resume'],['resume']
Usability,"tio of two histograms.\label{f53}][f53]. Some lines now need a bit of clarification:. - line *3*: Cling, as we know, is also able to interpret more than one; function per file. In this case the function simply sets up some; parameters to conveniently set the line of histograms. - line *19* to *21*: Some `C++` syntax for conditional; statements is used to fill the histograms with different numbers of; entries inside the loop. - line *30*: The sum of two histograms. A weight, which can be negative, can; be assigned to the added histogram. - line *41*: The division of two histograms is rather straightforward. - line *44* to *62*: When you draw two quantities and their ratios, it; is much better if all the information is condensed in one single; plot. These lines provide a skeleton to perform this operation. ## Two-dimensional Histograms ##. Two-dimensional histograms are a very useful tool, for example to; inspect correlations between variables. You can exploit the; bi-dimensional histogram classes provided by ROOT in a simple way.; Let's see how in this macro:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro7.C; ```. Two kinds of plots are provided within the code, the first one; containing three-dimensional representations (Figure [5.4](#f54)) and the second one; projections and profiles (Figure [5.5](#f55)) of the bi-dimensional histogram. [f54]: figures/th2f.png ""f54""; <a name=""f54""></a>. ![Different ways of representing bi-dimensional; histograms.\label{f54}][f54]. [f55]: figures/proj_and_prof.png ""f55""; <a name=""f55""></a>. ![The projections and profiles of bi-dimensional; histograms.\label{f55}][f55]. When a projection is performed along the x (y) direction, for every bin; along the x (y) axis, all bin contents along the y (x) axis are summed; up (upper the plots of Figure [5.5](#f55)). When a profile is performed along the x (y); direction, for every bin along the x (y) axis, the average of all the; bin contents along the y (x) is calculated together with their RMS ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:3367,simpl,simple,3367,documentation/primer/histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md,1,['simpl'],['simple']
Usability,"tion <https://riscv.org/specifications/>`_. C-SKY; ------; * `C-SKY Architecture User Guide <https://github.com/c-sky/csky-doc/blob/master/CSKY%20Architecture%20user_guide.pdf>`_; * `C-SKY V2 ABI <https://github.com/c-sky/csky-doc/blob/master/C-SKY_V2_CPU_Applications_Binary_Interface_Standards_Manual.pdf>`_. LoongArch; ---------; * `LoongArch Reference Manual - Volume 1: Basic Architecture <https://loongson.github.io/LoongArch-Documentation/LoongArch-Vol1-EN.html>`_; * `LoongArch ELF ABI specification <https://loongson.github.io/LoongArch-Documentation/LoongArch-ELF-ABI-EN.html>`_. SPARC; -----. * `SPARC standards <http://sparc.org/standards>`_; * `SPARC V9 ABI <http://sparc.org/standards/64.psabi.1.35.ps.Z>`_; * `SPARC V8 ABI <http://sparc.org/standards/psABI3rd.pdf>`_. SystemZ; -------. * `z/Architecture Principles of Operation (registration required, free sign-up) <http://www-01.ibm.com/support/docview.wss?uid=isg2b9de5f05a9d57819852571c500428f9a>`_. VE; --. * `NEC SX-Aurora TSUBASA ISA Guide <https://www.hpc.nec/documents/guide/pdfs/Aurora_ISA_guide.pdf>`_; * `NEC SX-Aurora TSUBASA manuals and documentation <https://www.hpc.nec/documentation>`_. X86; ---. * `AMD processor manuals <http://developer.amd.com/resources/developer-guides-manuals/>`_; * `Intel 64 and IA-32 manuals <http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html>`_; * `Intel Itanium documentation <http://www.intel.com/design/itanium/documentation.htm?iid=ipp_srvr_proc_itanium2+techdocs>`_; * `X86 and X86-64 SysV psABI <https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI>`_; * `Calling conventions for different C++ compilers and operating systems <http://www.agner.org/optimize/calling_conventions.pdf>`_. XCore; -----. * `The XMOS XS1 Architecture (ISA) <https://www.xmos.ai/download/The-XMOS-XS1-Architecture%281.0%29.pdf>`_; * `The XMOS XS2 Architecture (ISA) <https://www.xmos.ai/download/xCORE-200:-The-XMOS-XS2-Architecture-%28ISA%29%281.1%29.pdf>`_; * `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst:5628,Guid,Guide,5628,interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,1,['Guid'],['Guide']
Usability,"tion codeid=8 abbrevid=7 op0=4 op1=5 op2=6 op3=11 op4=66/>; </Remark>. ``Standalone``. .. code-block:: none. <BLOCKINFO_BLOCK/>; <Meta BlockID=8 NumWords=15 BlockCodeSize=3>; <Container info codeid=1 abbrevid=4 op0=5 op1=2/>; <Remark version codeid=2 abbrevid=5 op0=30/>; <String table codeid=3 abbrevid=6/> blob data = 'pass\\x00remark\\x00function\\x00path\\x00key\\x00value\\x00argpath\\x00'; </Meta>; <Remark BlockID=9 NumWords=8 BlockCodeSize=4>; <Remark header codeid=5 abbrevid=4 op0=2 op1=1 op2=0 op3=2/>; <Remark debug location codeid=6 abbrevid=5 op0=3 op1=99 op2=55/>; <Remark hotness codeid=7 abbrevid=6 op0=999999999/>; <Argument with debug location codeid=8 abbrevid=7 op0=4 op1=5 op2=6 op3=11 op4=66/>; </Remark>. opt-viewer; ==========. The ``opt-viewer`` directory contains a collection of tools that visualize and; summarize serialized remarks. The tools only support the ``yaml`` format. .. _optviewerpy:. opt-viewer.py; -------------. Output a HTML page which gives visual feedback on compiler interactions with; your program. :Examples:. ::. $ opt-viewer.py my_yaml_file.opt.yaml. ::. $ opt-viewer.py my_build_dir/. opt-stats.py; ------------. Output statistics about the optimization remarks in the input set. :Example:. ::. $ opt-stats.py my_yaml_file.opt.yaml. Total number of remarks 3. Top 10 remarks by pass:; inline 33%; asm-printer 33%; prologepilog 33%. Top 10 remarks:; asm-printer/InstructionCount 33%; inline/NoDefinition 33%; prologepilog/StackSize 33%. opt-diff.py; -----------. Produce a new YAML file which contains all of the changes in optimizations; between two YAML files. Typically, this tool should be used to do diffs between:. * new compiler + fixed source vs old compiler + fixed source; * fixed compiler + new source vs fixed compiler + old source. This diff file can be displayed using :ref:`opt-viewer.py <optviewerpy>`. :Example:. ::. $ opt-diff.py my_opt_yaml1.opt.yaml my_opt_yaml2.opt.yaml -o my_opt_diff.opt.yaml; $ opt-viewer.py my_opt_diff.opt.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:15015,feedback,feedback,15015,interpreter/llvm-project/llvm/docs/Remarks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst,1,['feedback'],['feedback']
Usability,"tion comments. ClangCommentHTMLTagsProperties; ------------------------------. Generate efficient matchers for HTML tag properties. ClangCommentHTMLNamedCharacterReferences; ----------------------------------------. Generate function to translate named character references to UTF-8 sequences. ClangCommentCommandInfo; -----------------------. Generate command properties for commands that are used in documentation comments. ClangCommentCommandList; -----------------------. Generate list of commands that are used in documentation comments. ArmNeon; -------. Generate arm_neon.h for clang. ArmNeonSema; -----------. Generate ARM NEON sema support for clang. ArmNeonTest; -----------. Generate ARM NEON tests for clang. AttrDocs; --------. **Purpose**: Creates ``AttributeReference.rst`` from ``AttrDocs.td``, and is; used for documenting user-facing attributes. General BackEnds; ================. Print Records; -------------. The TableGen command option ``--print-records`` invokes a simple backend; that prints all the classes and records defined in the source files. This is; the default backend option. See the :doc:`TableGen Backend Developer's Guide; <./BackGuide>` for more information. Print Detailed Records; ----------------------. The TableGen command option ``--print-detailed-records`` invokes a backend; that prints all the global variables, classes, and records defined in the; source files, with more detail than the default record printer. See the; :doc:`TableGen Backend Developer's Guide <./BackGuide>` for more; information. JSON Reference; --------------. **Purpose**: Output all the values in every ``def``, as a JSON data; structure that can be easily parsed by a variety of languages. Useful; for writing custom backends without having to modify TableGen itself,; or for performing auxiliary analysis on the same TableGen data passed; to a built-in backend. **Output**:. The root of the output file is a JSON object (i.e. dictionary),; containing the following fixed keys:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:14259,simpl,simple,14259,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,1,['simpl'],['simple']
Usability,"tion of the; API. This implementation change is logically separate from the API; change. If you are interested in making a large change, and this scares you, please make; sure to first `discuss the change/gather consensus`_ then ask about the best way; to go about making the change. Attribution of Changes; ----------------------. When contributors submit a patch to an LLVM project, other developers with; commit access may commit it for the author once appropriate (based on the; progression of code review, etc.). When doing so, it is important to retain; correct attribution of contributions to their contributors. However, we do not; want the source code to be littered with random attributions ""this code written; by J. Random Hacker"" (this is noisy and distracting). In practice, the revision; control system keeps a perfect history of who changed what, and the CREDITS.txt; file describes higher-level contributions. If you commit a patch for someone; else, please follow the attribution of changes in the simple manner as outlined; by the `commit messages`_ section. Overall, please do not add contributor names; to the source code. Also, don't commit patches authored by others unless they have submitted the; patch to the project or you have been authorized to submit them on their behalf; (you work together and your company authorized you to contribute the patches,; etc.). The author should first submit them to the relevant project's commit; list, development list, or LLVM bug tracker component. If someone sends you; a patch privately, encourage them to submit it to the appropriate list first. Our previous version control system (subversion) did not distinguish between the; author and the committer like git does. As such, older commits used a different; attribution mechanism. The previous method was to include ""Patch by John Doe.""; in a separate line of the commit message and there are automated processes that; rely on this format. .. _IR backwards compatibility:. IR Backwar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:30323,simpl,simple,30323,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['simpl'],['simple']
Usability,"tion of the; code path ([mitigation G-2 +; V1-1](https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf)). However, this relies on finding and enumerating all possible points in code; which could be attacked to leak information. While in some cases static; analysis is effective at doing this at scale, in many cases it still relies on; human judgement to evaluate whether code might be vulnerable. Especially for; software systems which receive less detailed scrutiny but remain sensitive to; these attacks, this seems like an impractical security model. We need an; automatic and systematic mitigation strategy. ### Automatic `lfence` on Conditional Edges. A natural way to scale up the existing hand-coded mitigations is simply to; inject an `lfence` instruction into both the target and fallthrough; destinations of every conditional branch. This ensures that no predicate or; bounds check can be bypassed speculatively. However, the performance overhead; of this approach is, simply put, catastrophic. Yet it remains the only truly; ""secure by default"" approach known prior to this effort and serves as the; baseline for performance. One attempt to address the performance overhead of this and make it more; realistic to deploy is [MSVC's /Qspectre; switch](https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/).; Their technique is to use static analysis within the compiler to only insert; `lfence` instructions into conditional edges at risk of attack. However,; [initial](https://arstechnica.com/gadgets/2018/02/microsofts-compiler-level-spectre-fix-shows-how-hard-this-problem-will-be-to-solve/); [analysis](https://www.paulkocher.com/doc/MicrosoftCompilerSpectreMitigation.html); has shown that this approach is incomplete and only catches a small and limited; subset of attackable patterns which happen to resemble very closely the initial; proofs of concept. As such, while its performance is acceptable, it does not; appear ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:45427,simpl,simply,45427,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simply']
Usability,"tion unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality. .. parsed-literal::. *conflict-declaration*:; ``conflict`` *module-id* ',' *string-literal*. The *module-id* of the *conflict-declaration* specifies the module with which the enclosing module conflicts. The specified module shall not have been imported in the translation unit when the enclosing module is imported. The *string-literal* provides a message to be provided as part of the compiler diagnostic when two modules conflict. .. note::. Clang emits a warning (under the control of ``-Wmodule-conflict``); when a module conflict is discovered. **Example:**. .. parsed-literal::. module Conflicts {; explicit module A {; header ""conflict_a.h""; conflict B, ""we just don't like B""; }. module B {; header ""conflict_b.h""; }; }. Attributes; ----------; Attributes are used in a number of places in the grammar to describe specific behavior of other declarations. The format of attributes is fairly simple. .. parsed-literal::. *attributes*:; *attribute* *attributes*:sub:`opt`. *attribute*:; '[' *identifier* ']'. Any *identifier* can be used as an attribute, and each declaration specifies what attributes can be applied to it. Private Module Map Files; ------------------------; Module map files are typically named ``module.modulemap`` and live; either alongside the headers they describe or in a parent directory of; the headers they describe. These module maps typically describe all of; the API for the library. However, in some cases, the presence or absence of particular headers; is used to distinguish between the ""public"" and ""private"" APIs of a; particular library. For example, a library may contain the headers; ``Foo.h`` and ``Foo_Private.h``, providing public and private APIs,; respectively. Additionally, ``Foo_Private.h`` may only be available on; some versions of library, and absent in others. One cannot easily; express this with a single module map file in the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:49368,simpl,simple,49368,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simple']
Usability,"tion, written in C++, of; the popular `MINUIT` minimization package. Compared with the; **`TMinuit`** class, which is a direct conversion from FORTRAN to C++,; `Minuit2` is a complete redesign and re-implementation of the package.; This new version provides all the functionality present in the old; FORTRAN version, with almost equivalent numerical accuracy and; computational performances.; Furthermore, it contains some fixes and small improvements and this new functionality:; * The possibility to set single side parameter limits; * the FUMILI algorithm (see the next paragraph ""FUMILI Minimization Package""),; which is an optimized method for least square and log; likelihood minimizations. Minuit2 has been originally developed by M.; Winkler and F. James in the SEAL project. More information can be found; on the [MINUIT Web Site](MINUIT Web Site) and in particular at the; following documentation page at; <http://www.cern.ch/minuit/doc/doc.html>. A detailed User Guide for Minuit2 exists, describing the API of the internal classes.; ROOT uses `Minuit2` for fitting via the `Minuit2Minimizer` class which implements; the `ROOT::Math::Minimizer` interface. `Minuit2` is also distributed as an independent package of ROOT and can be built; without any other dependency on the ROOT libraries. Examples on how to use the `Minuit2` and `Fumili2` plug-ins are provided; in the tutorials' directory `$ROOTSYS/tutorials/fit`:; `minuit2FitBench.C`, `minuit2FitBench2D.C` and `minuit2GausFit.C`.; More information on the classes and functions present in `Minuit2` is; available at; [online reference documentation](online reference documentation). Useful information on MINUIT and minimization in general is provided in the; following documents:. F. James, *Minuit Tutorial on Function Minimization* (; <http://seal.cern.ch/documents/minuit/mntutorial.pdf>); F. James, *The; Interpretation of Errors in Minuit* (; <http://seal.cern.ch/documents/minuit/mnerror.pdf>);. ## FUMILI Minimization Package.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:65628,Guid,Guide,65628,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['Guid'],['Guide']
Usability,"tion-defined format <ccxx_frontend>` (the C/C++ front-end; currently uses working draft 7 of the `DWARF 3 standard; <http://www.eagercon.com/dwarf/dwarf3std.htm>`_). When a program is being debugged, a debugger interacts with the user and turns; the stored debug information into source-language specific information. As; such, a debugger must be aware of the source-language, and is thus tied to a; specific language or family of languages. Debug information consumers; ---------------------------. The role of debug information is to provide meta information normally stripped; away during the compilation process. This meta information provides an LLVM; user a relationship between generated code and the original program source; code. Currently, there are two backend consumers of debug info: DwarfDebug and; CodeViewDebug. DwarfDebug produces DWARF suitable for use with GDB, LLDB, and; other DWARF-based debuggers. :ref:`CodeViewDebug <codeview>` produces CodeView,; the Microsoft debug info format, which is usable with Microsoft debuggers such; as Visual Studio and WinDBG. LLVM's debug information format is mostly derived; from and inspired by DWARF, but it is feasible to translate into other target; debug info formats such as STABS. It would also be reasonable to use debug information to feed profiling tools; for analysis of generated code, or, tools for reconstructing the original; source from generated code. .. _intro_debugopt:. Debug information and optimizations; -----------------------------------. An extremely high priority of LLVM debugging information is to make it interact; well with optimizations and analysis. In particular, the LLVM debug; information provides the following guarantees:. * LLVM debug information **always provides information to accurately read; the source-level state of the program**, regardless of which LLVM; optimizations have been run. :doc:`HowToUpdateDebugInfo` specifies how debug; info should be updated in various kinds of code transformatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:3164,usab,usable,3164,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['usab'],['usable']
Usability,"tion. In the example above, the LLVM builder class is starting to show its; value. IRBuilder knows where to insert the newly created instruction,; all you have to do is specify what instruction to create (e.g. with; ``CreateFAdd``), which operands to use (``L`` and ``R`` here) and; optionally provide a name for the generated instruction. One nice thing about LLVM is that the name is just a hint. For instance,; if the code above emits multiple ""addtmp"" variables, LLVM will; automatically provide each one with an increasing, unique numeric; suffix. Local value names for instructions are purely optional, but it; makes it much easier to read the IR dumps. `LLVM instructions <../../LangRef.html#instruction-reference>`_ are constrained by strict; rules: for example, the Left and Right operands of an `add; instruction <../../LangRef.html#add-instruction>`_ must have the same type, and the; result type of the add must match the operand types. Because all values; in Kaleidoscope are doubles, this makes for very simple code for add,; sub and mul. On the other hand, LLVM specifies that the `fcmp; instruction <../../LangRef.html#fcmp-instruction>`_ always returns an 'i1' value (a; one bit integer). The problem with this is that Kaleidoscope wants the; value to be a 0.0 or 1.0 value. In order to get these semantics, we; combine the fcmp instruction with a `uitofp; instruction <../../LangRef.html#uitofp-to-instruction>`_. This instruction converts its; input integer into a floating point value by treating the input as an; unsigned value. In contrast, if we used the `sitofp; instruction <../../LangRef.html#sitofp-to-instruction>`_, the Kaleidoscope '<' operator; would return 0.0 and -1.0, depending on the input value. .. code-block:: c++. Value *CallExprAST::codegen() {; // Look up the name in the global module table.; Function *CalleeF = TheModule->getFunction(Callee);; if (!CalleeF); return LogErrorV(""Unknown function referenced"");. // If argument mismatch error.; if (CalleeF->a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:8263,simpl,simple,8263,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability,"tion; equivalent to a call or invoke to 'target'. The 'target' operand is the function actually being called. The operand; must have an :ref:`elementtype <attr_elementtype>` attribute specifying; the function type of the target. The target can be specified as either; a symbolic LLVM function, or as an arbitrary Value of pointer type. Note; that the function type must match the signature of the callee and the; types of the 'call parameters' arguments. The '#call args' operand is the number of arguments to the actual; call. It must exactly match the number of arguments passed in the; 'call parameters' variable length section. The 'flags' operand is used to specify extra information about the; statepoint. This is currently only used to mark certain statepoints; as GC transitions. This operand is a 64-bit integer with the following; layout, where bit 0 is the least significant bit:. +-------+---------------------------------------------------+; | Bit # | Usage |; +=======+===================================================+; | 0 | Set if the statepoint is a GC transition, cleared |; | | otherwise. |; +-------+---------------------------------------------------+; | 1-63 | Reserved for future use; must be cleared. |; +-------+---------------------------------------------------+. The 'call parameters' arguments are simply the arguments which need to; be passed to the call target. They will be lowered according to the; specified calling convention and otherwise handled like a normal call; instruction. The number of arguments must exactly match what is; specified in '# call args'. The types must match the signature of; 'target'. The 'call parameter' attributes must be followed by two 'i64 0' constants.; These were originally the length prefixes for 'gc transition parameter' and; 'deopt parameter' arguments, but the role of these parameter sets have been; entirely replaced with the corresponding operand bundles. In a future; revision, these now redundant arguments will be remo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:502300,clear,cleared,502300,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['clear'],['cleared']
Usability,"tionAction`` should be called with ``Custom`` as the third parameter:. .. code-block:: c++. setOperationAction(ISD::FP_TO_SINT, MVT::i32, Custom);. In the ``LowerOperation`` method, for each ``Custom`` operation, a case; statement should be added to indicate what function to call. In the following; code, an ``FP_TO_SINT`` opcode will call the ``LowerFP_TO_SINT`` method:. .. code-block:: c++. SDValue SparcTargetLowering::LowerOperation(SDValue Op, SelectionDAG &DAG) {; switch (Op.getOpcode()) {; case ISD::FP_TO_SINT: return LowerFP_TO_SINT(Op, DAG);; ...; }; }. Finally, the ``LowerFP_TO_SINT`` method is implemented, using an FP register to; convert the floating-point value to an integer. .. code-block:: c++. static SDValue LowerFP_TO_SINT(SDValue Op, SelectionDAG &DAG) {; assert(Op.getValueType() == MVT::i32);; Op = DAG.getNode(SPISD::FTOI, MVT::f32, Op.getOperand(0));; return DAG.getNode(ISD::BITCAST, MVT::i32, Op);; }. Legal; ^^^^^. The ``Legal`` ``LegalizeAction`` enum value simply indicates that an operation; **is** natively supported. ``Legal`` represents the default condition, so it; is rarely used. In ``SparcISelLowering.cpp``, the action for ``CTPOP`` (an; operation to count the bits set in an integer) is natively supported only for; SPARC v9. The following code enables the ``Expand`` conversion technique for; non-v9 SPARC implementations. .. code-block:: c++. setOperationAction(ISD::CTPOP, MVT::i32, Expand);; ...; if (TM.getSubtarget<SparcSubtarget>().isV9()); setOperationAction(ISD::CTPOP, MVT::i32, Legal);. Calling Conventions; -------------------. To support target-specific calling conventions, ``XXXGenCallingConv.td`` uses; interfaces (such as ``CCIfType`` and ``CCAssignToReg``) that are defined in; ``lib/Target/TargetCallingConv.td``. TableGen can take the target descriptor; file ``XXXGenCallingConv.td`` and generate the header file; ``XXXGenCallingConv.inc``, which is typically included in; ``XXXISelLowering.cpp``. You can use the interfaces in; ``Targe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:61051,simpl,simply,61051,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['simpl'],['simply']
Usability,"tions must already name the class and new overloads; cannot be introduced out of line, so this recommendation does not apply to them. .. _early exits:. Use Early Exits and ``continue`` to Simplify Code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When reading code, keep in mind how much state and how many previous decisions; have to be remembered by the reader to understand a block of code. Aim to; reduce indentation where possible when it doesn't make it more difficult to; understand the code. One great way to do this is by making use of early exits; and the ``continue`` keyword in long loops. Consider this code that does not; use an early exit:. .. code-block:: c++. Value *doSomething(Instruction *I) {; if (!I->isTerminator() &&; I->hasOneUse() && doOtherThing(I)) {; ... some long code ....; }. return 0;; }. This code has several problems if the body of the ``'if'`` is large. When; you're looking at the top of the function, it isn't immediately clear that this; *only* does interesting things with non-terminator instructions, and only; applies to things with the other predicates. Second, it is relatively difficult; to describe (in comments) why these predicates are important because the ``if``; statement makes it difficult to lay out the comments. Third, when you're deep; within the body of the code, it is indented an extra level. Finally, when; reading the top of the function, it isn't clear what the result is if the; predicate isn't true; you have to read to the end of the function to know that; it returns null. It is much preferred to format the code like this:. .. code-block:: c++. Value *doSomething(Instruction *I) {; // Terminators never need 'something' done to them because ...; if (I->isTerminator()); return 0;. // We conservatively avoid transforming instructions with multiple uses; // because goats like cheese.; if (!I->hasOneUse()); return 0;. // This is really just here for example.; if (!doOtherThing(I)); return 0;. ... some long code ....; }. Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:36012,clear,clear,36012,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['clear'],['clear']
Usability,"tisfy both it and this License would be to; refrain entirely from distribution of the Library. If any portion of this section is held invalid or unenforceable under any; particular circumstance, the balance of the section is intended to apply,; and the section as a whole is intended to apply in other circumstances. It is not the purpose of this section to induce you to infringe any; patents or other property right claims or to contest validity of any; such claims; this section has the sole purpose of protecting the; integrity of the free software distribution system which is; implemented by public license practices. Many people have made; generous contributions to the wide range of software distributed; through that system in reliance on consistent application of that; system; it is up to the author/donor to decide if he or she is willing; to distribute software through any other system and a licensee cannot; impose that choice. This section is intended to make thoroughly clear what is believed to; be a consequence of the rest of this License. 12. If the distribution and/or use of the Library is restricted in; certain countries either by patents or by copyrighted interfaces, the; original copyright holder who places the Library under this License may add; an explicit geographical distribution limitation excluding those countries,; so that distribution is permitted only in or among countries not thus; excluded. In such case, this License incorporates the limitation as if; written in the body of this License. 13. The Free Software Foundation may publish revised and/or new; versions of the Lesser General Public License from time to time.; Such new versions will be similar in spirit to the present version,; but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library; specifies a version number of this License which applies to it and; ""any later version"", you have the option of following the terms and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:21216,clear,clear,21216,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,2,['clear'],['clear']
Usability,"tizer reads instruction classes from a target's itineraries and creates; a deterministic finite automaton (DFA) to represent the state of a packet. A DFA; consists of three major elements: inputs, states, and transitions. The set of; inputs for the generated DFA represents the instruction being added to a; packet. The states represent the possible consumption of functional units by; instructions in a packet. In the DFA, transitions from one state to another; occur on the addition of an instruction to an existing packet. If there is a; legal mapping of functional units to instructions, then the DFA contains a; corresponding transition. The absence of a transition indicates that a legal; mapping does not exist and that the instruction cannot be added to the packet. To generate tables for a VLIW target, add *Target*\ GenDFAPacketizer.inc as a; target to the Makefile in the target directory. The exported API provides three; functions: ``DFAPacketizer::clearResources()``,; ``DFAPacketizer::reserveResources(MachineInstr *MI)``, and; ``DFAPacketizer::canReserveResources(MachineInstr *MI)``. These functions allow; a target packetizer to add an instruction to an existing packet and to check; whether an instruction can be added to a packet. See; ``llvm/CodeGen/DFAPacketizer.h`` for more information. Implementing a Native Assembler; ===============================. Though you're probably reading this because you want to write or maintain a; compiler backend, LLVM also fully supports building a native assembler.; We've tried hard to automate the generation of the assembler from the .td files; (in particular the instruction syntax and encodings), which means that a large; part of the manual and repetitive data entry can be factored and shared with the; compiler. Instruction Parsing; -------------------. .. note::. To Be Written. Instruction Alias Processing; ----------------------------. Once the instruction is parsed, it enters the MatchInstructionImpl function.; The MatchInstr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:80517,clear,clearResources,80517,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['clear'],['clearResources']
Usability,"tly if they want to. Now we just need to be able to set; the ``DebugFlag`` boolean when the option is set. To do this, we pass an; additional argument to our command line argument processor, and we specify where; to fill in with the `cl::location`_ attribute:. .. code-block:: c++. bool DebugFlag; // the actual value; static cl::opt<bool, true> // The parser; Debug(""debug"", cl::desc(""Enable debug output""), cl::Hidden, cl::location(DebugFlag));. In the above example, we specify ""``true``"" as the second argument to the; `cl::opt`_ template, indicating that the template should not maintain a copy of; the value itself. In addition to this, we specify the `cl::location`_; attribute, so that ``DebugFlag`` is automatically set. Option Attributes; -----------------. This section describes the basic attributes that you can specify on options. * The option name attribute (which is required for all options, except; `positional options`_) specifies what the option name is. This option is; specified in simple double quotes:. .. code-block:: c++. cl::opt<bool> Quiet(""quiet"");. .. _cl::desc(...):. * The **cl::desc** attribute specifies a description for the option to be; shown in the ``-help`` output for the program. This attribute supports; multi-line descriptions with lines separated by '\n'. .. _cl::value_desc:. * The **cl::value_desc** attribute specifies a string that can be used to; fine tune the ``-help`` output for a command line option. Look `here`_ for an; example. .. _cl::init:. * The **cl::init** attribute specifies an initial value for a `scalar`_; option. If this attribute is not specified then the command line option value; defaults to the value created by the default constructor for the; type. .. warning::. If you specify both **cl::init** and **cl::location** for an option, you; must specify **cl::location** first, so that when the command-line parser; sees **cl::init**, it knows where to put the initial value. (You will get an; error at runtime if you don't put th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:35744,simpl,simple,35744,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"tly. When control; flow :ref:`diverges <convergence-and-uniformity>`, i.e. threads of the same; group follow different; paths through the CFG, not all threads of the group may be available to; participate in this communication. This is the defining characteristic that; distinguishes convergent operations from other inter-thread communication:. A convergent operation involves inter-thread communication or synchronization; that occurs outside of the memory model, where the set of threads which; participate in communication is implicitly affected by control flow. For example, in the following GPU compute kernel, communication during the; convergent operation is expected to occur precisely among those threads of an; implementation-defined execution scope (such as workgroup or subgroup) for; which ``condition`` is true:. .. code-block:: c++. void example_kernel() {; ...; if (condition); convergent_operation();; ...; }. In structured programming languages, there is often an intuitive and; unambiguous way of determining the threads that are expected to communicate.; However, this is not always the case even in structured programming languages,; and the intuition breaks down entirely in unstructured control flow. This; document describes the formal semantics in LLVM, i.e. how to determine the set; of communicating threads for convergent operations. The definitions in this document leave many details open, such as how groups of; threads are formed in the first place. It focuses on the questions that are; relevant for deciding the correctness of generic program transforms and; convergence-related analyses such as :ref:`uniformity analysis; <convergence-and-uniformity>`. .. _convergent_operations:. Convergent Operations; =====================. In LLVM IR, the only way to communicate between threads as described; above is by calling target-defined convergent intrinsics. Hence, only; a call-site in LLVM IR (a :ref:`call <i_call>`, :ref:`invoke; <i_invoke>`, or :ref:`callbr <i_cal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:1426,intuit,intuitive,1426,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['intuit'],['intuitive']
Usability,"to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` class (but specialized for arrays of characters). Because; StringRef carries a length with it, it safely handles strings with embedded nul; characters in it, getting the length does not require a strlen call, and it even; has very convenient APIs for slicing and dicing the character range that it; represents. StringRef is ideal for passing simple strings around that are known to be live,; either because they are C string literals, std::string, a C array, or a; SmallVector. Each of these cases has an efficient implicit conversion to; StringRef, which doesn't result in a dynamic strlen being executed. StringRef has a few major limitations which make more powerful string containers; useful:. #. You cannot directly convert a StringRef to a 'const char*' because there is; no way to add a trailing nul (unlike the .c_str() method on various stronger; classes). #. StringRef doesn't own or keep alive the underlying string bytes.; As such it can easily lead to dangling pointers, and is not suitable for; embedding in datastructures in most cases (instead, use an std::string or; something like that). #. For the same reason, StringRef cannot be used as the return value of a; method if the method ""computes"" the result string. Instead, use std::string. #. StringRef's do not allow you to mutate the pointed-to string bytes and it; doesn't allow you to insert or remove bytes from the range",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:72192,simpl,simple,72192,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"to be writable even without this attribute. The ``writable`` attribute cannot be combined with ``readnone``,; ``readonly`` or a ``memory`` attribute that does not contain; ``argmem: write``. ``dead_on_unwind``; At a high level, this attribute indicates that the pointer argument is dead; if the call unwinds, in the sense that the caller will not depend on the; contents of the memory. Stores that would only be visible on the unwind; path can be elided. More precisely, the behavior is as-if any memory written through the; pointer during the execution of the function is overwritten with a poison; value on unwind. This includes memory written by the implicit write implied; by the ``writable`` attribute. The caller is allowed to access the affected; memory, but all loads that are not preceded by a store will return poison. This attribute cannot be applied to return values. .. _gc:. Garbage Collector Strategy Names; --------------------------------. Each function may specify a garbage collector strategy name, which is simply a; string:. .. code-block:: llvm. define void @f() gc ""name"" { ... }. The supported values of *name* includes those :ref:`built in to LLVM; <builtin-gc-strategies>` and any provided by loaded plugins. Specifying a GC; strategy will cause the compiler to alter its output in order to support the; named garbage collection algorithm. Note that LLVM itself does not contain a; garbage collector, this functionality is restricted to generating machine code; which can interoperate with a collector provided externally. .. _prefixdata:. Prefix Data; -----------. Prefix data is data associated with a function which the code; generator will emit immediately before the function's entrypoint.; The purpose of this feature is to allow frontends to associate; language-specific runtime metadata with specific functions and make it; available through the function pointer while still allowing the; function pointer to be called. To access the data for a given function, a prog",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:71879,simpl,simply,71879,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"to call/access.; For now we will ignore this argument and use a standard optimization; pipeline. To do this we set up a FunctionPassManager, add some passes to it, run; it over every function in the module, and then return the mutated module. The; specific optimizations are the same ones used in `Chapter 4 <LangImpl04.html>`_; of the ""Implementing a language with LLVM"" tutorial series. Readers may visit; that chapter for a more in-depth discussion of these, and of IR optimization in; general. And that's it in terms of changes to KaleidoscopeJIT: When a module is added via; addModule the OptimizeLayer will call our optimizeModule function before passing; the transformed module on to the CompileLayer below. Of course, we could have; called optimizeModule directly in our addModule function and not gone to the; bother of using the IRTransformLayer, but doing so gives us another opportunity; to see how layers compose. It also provides a neat entry point to the *layer*; concept itself, because IRTransformLayer is one of the simplest layers that; can be implemented. .. code-block:: c++. // From IRTransformLayer.h:; class IRTransformLayer : public IRLayer {; public:; using TransformFunction = std::function<Expected<ThreadSafeModule>(; ThreadSafeModule, const MaterializationResponsibility &R)>;. IRTransformLayer(ExecutionSession &ES, IRLayer &BaseLayer,; TransformFunction Transform = identityTransform);. void setTransform(TransformFunction Transform) {; this->Transform = std::move(Transform);; }. static ThreadSafeModule; identityTransform(ThreadSafeModule TSM,; const MaterializationResponsibility &R) {; return TSM;; }. void emit(MaterializationResponsibility R, ThreadSafeModule TSM) override;. private:; IRLayer &BaseLayer;; TransformFunction Transform;; };. // From IRTransformLayer.cpp:. IRTransformLayer::IRTransformLayer(ExecutionSession &ES,; IRLayer &BaseLayer,; TransformFunction Transform); : IRLayer(ES), BaseLayer(BaseLayer), Transform(std::move(Transform)) {}. void IRTr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:6412,simpl,simplest,6412,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['simpl'],['simplest']
Usability,"to emit IR for that AST node along with all; the things it depends on, and they all return an LLVM Value object.; ""Value"" is the class used to represent a ""`Static Single Assignment; (SSA) <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; register"" or ""SSA value"" in LLVM. The most distinct aspect of SSA values; is that their value is computed as the related instruction executes, and; it does not get a new value until (and if) the instruction re-executes.; In other words, there is no way to ""change"" an SSA value. For more; information, please read up on `Static Single; Assignment <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; - the concepts are really quite natural once you grok them. Note that instead of adding virtual methods to the ExprAST class; hierarchy, it could also make sense to use a `visitor; pattern <http://en.wikipedia.org/wiki/Visitor_pattern>`_ or some other; way to model this. Again, this tutorial won't dwell on good software; engineering practices: for our purposes, adding a virtual method is; simplest. The second thing we want is a ""LogError"" method like we used for the; parser, which will be used to report errors found during code generation; (for example, use of an undeclared parameter):. .. code-block:: c++. static std::unique_ptr<LLVMContext> TheContext;; static std::unique_ptr<IRBuilder<>> Builder(TheContext);; static std::unique_ptr<Module> TheModule;; static std::map<std::string, Value *> NamedValues;. Value *LogErrorV(const char *Str) {; LogError(Str);; return nullptr;; }. The static variables will be used during code generation. ``TheContext``; is an opaque object that owns a lot of core LLVM data structures, such as; the type and constant value tables. We don't need to understand it in; detail, we just need a single instance to pass into APIs that require it. The ``Builder`` object is a helper object that makes it easy to generate; LLVM instructions. Instances of the; `IRBuilder <https://llvm.org/doxygen/IRBu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:2655,simpl,simplest,2655,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simplest']
Usability,"to gcc 4.3.1. This version of gcc is much stricker with respect to; implicit header files so in many source files <stdlib.h> and <string.h>; had to be added. TPRegexp. Modularized Match() and Substitute() functions so that the low-level work; is done by MatchInternal() and SubstituteInternal(). Added function TString GetModifiers() that translates from bit-flag; options back to perl-style option characters. For all functions that do actual matching replaced the default value; of 'Int_t nMatchMax' argument from 30 to 10. PCRE internals require; the index buffer to be 3-times the number of allowed matches. This; multiplication is now performed in individual functions and nMatchMax; is really the number of allowed matches. Two function calls in; TString passing this number explicitly have been updated. TPMERegexp. New sub-class of TPRegexp with API closer to PERL.; Supports main Perl operations using regular expressions (Match,; Substitute and Split). To retrieve the results one can simply use; operator[] returning a TString. New tutorial regexp_pme.C. Meta. Add a new TClass interface to be able to trigger the ""auto addition of object; to a TDirectory object"". If a class has a member function:; DirectoryAutoAdd(TDirectory*); it will now be accessible (when the dictionary is generated via rootcint; for now) via TClass::GetDirectoryAutoAdd which return a wrapper with the; signature:; void (*)(void *this_obj,TDirectory *where_to_add). Extend #pragma create TClass; to namespaces.; Enable autoloading of the cintdlls.; rlibmap now handles #pragma create TClass; statements. Cont. Support for std algorithms and iterators for ROOT collection classes by Anar.; The background is the following. While working on the PROOF code I found; that enumerating TList is an inconvenient and a long operation, I had to; write the same code all over the place and make duplications. I tried; to use STD algorithms with it, namely std::for_each, and failed.; I therefore decided to enable std::for_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html:2949,simpl,simply,2949,core/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html,1,['simpl'],['simply']
Usability,"to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-It to add the import. **Improve modularize**; The modularize tool is both extremely important (for deployment) and extremely crude. It needs better UI, better detection of problems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module map for Clang's compiler-specific header files. ``clang/test/Modules/``; Tests specifically related to modules functionality. ``clang/include/clang/Basic/Module.h``; The ``Module`` class in this header describes a module, and is used throughout the compiler to implement modules. ``clang/include/clang/Lex/ModuleMap.h``; The ``ModuleMap`` class in this header describes the full module map, consisting of all of the module map files that have been parsed, and providing facilities for looking up module maps and mapping between modules and headers (in both directions). PCHInternals_; Information about the serialized AST format used for precompiled headers and modules. The actual implementation is in the ``clangSerialization`` library. .. [#] Automatic linking against the libraries of modules requires specific linker support, which is not widely available. .. [#] There are cer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:57077,Learn,Learn,57077,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['Learn'],['Learn']
Usability,"to the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); ```. Although it is not recommended, a simple way of working with `PyROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes will still be bound (and possibly loaded) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to find out which; classes are available). Furthermore, because of this approach,; \<`tab`\>-completion will usually not be available until after the first; use (and hence creation) of a class. Access to class static functions, public data members, enums, etc. is as; expected. Many more example uses of ROOT classes from Python can be; found in the tutorials directory in the ROOT distribution. The recipes; section contains a description on working with your own classes (see; """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:10426,simpl,simple,10426,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['simpl'],['simple']
Usability,"tok_else); return LogError(""expected else"");. getNextToken();. auto Else = ParseExpression();; if (!Else); return nullptr;. return std::make_unique<IfExprAST>(std::move(Cond), std::move(Then),; std::move(Else));; }. Next we hook it up as a primary expression:. .. code-block:: c++. static std::unique_ptr<ExprAST> ParsePrimary() {; switch (CurTok) {; default:; return LogError(""unknown token when expecting an expression"");; case tok_identifier:; return ParseIdentifierExpr();; case tok_number:; return ParseNumberExpr();; case '(':; return ParseParenExpr();; case tok_if:; return ParseIfExpr();; }; }. LLVM IR for If/Then/Else; ------------------------. Now that we have it parsing and building the AST, the final piece is; adding LLVM code generation support. This is the most interesting part; of the if/then/else example, because this is where it starts to; introduce new concepts. All of the code above has been thoroughly; described in previous chapters. To motivate the code we want to produce, let's take a look at a simple; example. Consider:. ::. extern foo();; extern bar();; def baz(x) if x then foo() else bar();. If you disable optimizations, the code you'll (soon) get from; Kaleidoscope looks like this:. .. code-block:: llvm. declare double @foo(). declare double @bar(). define double @baz(double %x) {; entry:; %ifcond = fcmp one double %x, 0.000000e+00; br i1 %ifcond, label %then, label %else. then: ; preds = %entry; %calltmp = call double @foo(); br label %ifcont. else: ; preds = %entry; %calltmp1 = call double @bar(); br label %ifcont. ifcont: ; preds = %else, %then; %iftmp = phi double [ %calltmp, %then ], [ %calltmp1, %else ]; ret double %iftmp; }. To visualize the control flow graph, you can use a nifty feature of the; LLVM '`opt <https://llvm.org/cmds/opt.html>`_' tool. If you put this LLVM; IR into ""t.ll"" and run ""``llvm-as < t.ll | opt -passes=view-cfg``"", `a; window will pop up <../../ProgrammersManual.html#viewing-graphs-while-debugging-code>`_ and you'll; se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:5179,simpl,simple,5179,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['simpl'],['simple']
Usability,"topics that need more documentation.; Please send your comments, corrections, questions, and suggestions to; the `rootdoc` list: <rootdoc@cern.ch>. We attempt to give the user insight into the many capabilities of; ROOT. The book begins with the elementary functionality and progresses; in complexity reaching the specialized topics at the end. The; experienced user looking for special topics may find these chapters; useful: see ""Networking"", ""Writing a Graphical User Interface"",; ""Threads"", and ""PROOF: Parallel Processing"". ## Conventions Used in This Book. We tried to follow a style convention for the sake of clarity. The; styles in used are described below. To show source code in scripts or source files:. ``` {.cpp}; {; cout << "" Hello"" << endl;; float x = 3.;; float y = 5.;; int i = 101;; cout <<"" x = ""<<x<<"" y = ""<<y<<"" i = ""<<i<< endl;; }; ```. To show the ROOT command line, we show the ROOT prompt without numbers.; In the interactive system, the ROOT prompt has a line number; (`root[12]`); for the sake of simplicity, the line numbers are left; off. ``` {.cpp}; root[] TLine l; root[] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; ```. Italic bold monotype font indicates a global variable, for example; ***`gDirectory`***. When a variable term is used, it is shown between angled brackets. In; the example below the variable term \<library\> can be replaced with; any library in the `$ROOTSYS` directory: `$ROOTSYS/<library>/inc.`. ## The Framework. ROOT is an object-oriented framework aimed at solving the data; analysis challenges of high-energy physics. There are two key words in; this definition, object oriented and framework. First, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; serv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:4086,simpl,simplicity,4086,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['simpl'],['simplicity']
Usability,"tor operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist in; the source code. All other expressions are evaluated according to C/C++; semantics. C++ support; ===========. C++ has multiple options to write code in a bounds-safe manner, such as; following the bounds-safety core guidelines and/or using hardened libc++ along; with the `C++ Safe Buffer model; <https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734>`_. However, these; techniques may require ABI changes and may not be applicable to code; interoperating with C. When the ABI of an existing program needs to be preserved; and for headers shared between C and C++, ``-fbounds-safety`` offers a potential; solution. ``-fbounds-safety`` is not currently supported in C++, but we believe the; general approach would be applicable for future efforts. Upstreaming plan; ================. Gradual updates with experimental flag; --------------------------------------. The upstreaming will take place as a series of smaller PRs and we will guard our; implementation with an experimental flag ``-fexperimental-bounds-safety`` until; the usable model is fully upstreamed. Once the model is ready for use, we will; expose the flag ``-fbounds-safety``. Possible patch sets; -------------------. * External bounds annotations and the (late) parsing logic.; * Internal bounds annotations (wide pointers) and their parsing logic.; * Clang code generation for wide pointers with debug information.; * Pointer cast semantics involving bounds annotations (this could be divided; into multiple sub-PRs).; * CFG analysis for pairs of related pointer and count assignments and the likes.; * Bounds check expressions in AST and the Clang code generation (this could also; be divided into multiple sub-PRs). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:11359,usab,usable,11359,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['usab'],['usable']
Usability,"tors on objects; locally if one is thrown by the function. Most functions don't throw; exceptions, so this code is dead [with all the bad effects of dead; code, including icache pollution].; 2. Declaring a function nothrow causes catch blocks to be added to every; call that isnot provably nothrow. This makes them very slow.; 3. Extra extraneous exception edges reduce the opportunity for code; motion.; 4. EH is typically implemented with large lookup tables. Ours is going to; be much smaller (than the ""standard"" way of doing it) to start with,; but eliminating it entirely would be nice. :); 5. It is physically impossible to correctly put (accurate, correct); exception specifications on generic, templated code. But it is trivial; to analyze instantiations of said code.; 6. Most large C++ programs throw few exceptions. Most well designed; programs only throw exceptions in specific planned portions of the; code. Given our _planned_ model of handling exceptions, all of this would be; pretty trivial to eliminate through some pretty simplistic interprocedural; analysis. The DCE factor alone could probably be pretty significant. The; extra code motion opportunities could also be exploited though... Additionally, this optimization can be implemented in a straight forward; conservative manner, allowing libraries to be optimized or individual; files even (if there are leaf functions visible in the translation unit; that are called). I think it's a reasonable optimization that hasn't really been addressed; (because assembly is way too low level for this), and could have decent; payoffs... without being a overly complex optimization. After I wrote all of that, I found this page that is talking about; basically the same thing I just wrote, except that it is translation unit; at a time, tree based approach:; http://www.ocston.org/~jls/ehopt.html. but is very useful from ""expected gain"" and references perspective. Note; that their compiler is apparently unable to inline functions t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-09-18-OptimizeExceptions.txt:1469,simpl,simplistic,1469,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-09-18-OptimizeExceptions.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-09-18-OptimizeExceptions.txt,1,['simpl'],['simplistic']
Usability,"towards native vector predication in LLVM,; specifically for vector instructions with a mask and/or an explicit vector; length. LLVM currently has no target-independent means to model predicated; vector instructions for modern SIMD ISAs such as AVX512, ARM SVE, the RISC-V V; extension and NEC SX-Aurora. Only some predicated vector operations, such as; masked loads and stores, are available through intrinsics [MaskedIR]_. The Vector Predication (VP) extensions is a concrete RFC and prototype; implementation to achieve native vector predication in LLVM. The VP prototype; and all related discussions can be found in the VP patch on Phabricator; [VPRFC]_. Roadmap; =======. 1. IR-level VP intrinsics; -------------------------. - There is a consensus on the semantics/instruction set of VP.; - VP intrinsics and attributes are available on IR level.; - TTI has capability flags for VP (``supportsVP()``?,; ``haveActiveVectorLength()``?). Result: VP usable for IR-level vectorizers (LV, VPlan, RegionVectorizer),; potential integration in Clang with builtins. 2. CodeGen support; ------------------. - VP intrinsics translate to first-class SDNodes; (eg ``llvm.vp.fdiv.* -> vp_fdiv``).; - VP legalization (legalize explicit vector length to mask (AVX512), legalize VP; SDNodes to pre-existing ones (SSE, NEON)). Result: Backend development based on VP SDNodes. 3. Lift InstSimplify/InstCombine/DAGCombiner to VP; --------------------------------------------------. - Introduce PredicatedInstruction, PredicatedBinaryOperator, .. helper classes; that match standard vector IR and VP intrinsics.; - Add a matcher context to PatternMatch and context-aware IR Builder APIs.; - Incrementally lift DAGCombiner to work on VP SDNodes as well as on regular; vector instructions.; - Incrementally lift InstCombine/InstSimplify to operate on VP as well as; regular IR instructions. Result: Optimization of VP intrinsics on par with standard vector instructions. 4. Deprecate llvm.masked.* / llvm.experimental.r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VectorPredication.rst:1145,usab,usable,1145,interpreter/llvm-project/llvm/docs/Proposals/VectorPredication.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VectorPredication.rst,1,['usab'],['usable']
Usability,tps://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-initialization of class members when; default initializing a base class in a constant expression context. Fixes:; (`#69890 <https://github.com/llvm/llvm-project/issues/69890>`_). - Fix crash when template class static member imported to other translation unit.; Fixes:; (`#68769 <https://github.com/llvm/llvm-project/issues/68769>`_). - Clang now rejects incomplete types for ``__builtin_dump_struct``. Fixes:; (`#63506 <https://github.com/llvm/llvm-project/issues/63506>`_). - Fixed a crash for C++98/03 while checking an ill-formed ``_Static_assert`` expression.; Fixes: (`#72025 <https://github.com/llvm/llvm-project/issues/72025>`_). - Clang now defers the instantiation of explicit specifier until constraint checking; completes (except deduction guides). Fixes:; (`#59827 <https://github.com/llvm/llvm-project/issues/59827>`_). - Fix crash when parsing nested requirement. Fixes:; (`#73112 <https://github.com/llvm/llvm-project/issues/73112>`_). - Fixed a crash caused by using return type requirement in a lambda. Fixes:; (`#63808 <https://github.com/llvm/llvm-project/issues/63808>`_); (`#64607 <https://github.com/llvm/llvm-project/issues/64607>`_); (`#64086 <https://github.com/llvm/llvm-project/issues/64086>`_). - Fixed a crash where we lost uninstantiated constraints on placeholder NTTP packs. Fixes:; (`#63837 <https://github.com/llvm/llvm-project/issues/63837>`_). - Fixed a regression where clang forgets how to substitute into constraints on template-template; parameters. Fixes:; (`#57410 <https://github.com/llvm/llvm-project/issues/57410>`_) and; (`#76604 <https://github.com/llvm/llvm-project/issues/57410>`_). - Fix a bug where clang would produce inconsistent values when; ``,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:53213,guid,guides,53213,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['guid'],['guides']
Usability,"tr, ptr, ptr)`.; Lowering will replace this intrinsic with its coroutine function argument. .. _coro.suspend.retcon:. 'llvm.coro.suspend.retcon' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i1 @llvm.coro.suspend.retcon(...). Overview:; """""""""""""""""". The '``llvm.coro.suspend.retcon``' intrinsic marks the point where; execution of a returned-continuation coroutine is suspended and control; is returned back to the caller. `llvm.coro.suspend.retcon`` does not support separate save points;; they are not useful when the continuation function is not locally; accessible. That would be a more appropriate feature for a ``passcon``; lowering that is not yet implemented. Arguments:; """""""""""""""""""". The types of the arguments must exactly match the yielded-types sequence; of the coroutine. They will be turned into return values from the ramp; and continuation functions, along with the next continuation function. Semantics:; """""""""""""""""""". The result of the intrinsic indicates whether the coroutine should resume; abnormally (non-zero). In a normal coroutine, it is undefined behavior if the coroutine executes; a call to ``llvm.coro.suspend.retcon`` after resuming abnormally. In a yield-once coroutine, it is undefined behavior if the coroutine; executes a call to ``llvm.coro.suspend.retcon`` after resuming in any way. Coroutine Transformation Passes; ===============================; CoroEarly; ---------; The pass CoroEarly lowers coroutine intrinsics that hide the details of the; structure of the coroutine frame, but, otherwise not needed to be preserved to; help later coroutine passes. This pass lowers `coro.frame`_, `coro.done`_,; and `coro.promise`_ intrinsics. .. _CoroSplit:. CoroSplit; ---------; The pass CoroSplit builds coroutine frame and outlines resume and destroy parts; into separate functions. CoroElide; ---------; The pass CoroElide examines if the inlined coroutine is eligible for heap; allocation elision optimization. If so, it replaces; `coro.begin` intr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:55909,resume,resume,55909,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"trace_LIBFILE}); set(system_libs ${system_libs} ${Backtrace_LIBFILE}); endif(); if( LLVM_ENABLE_TERMINFO ); set(imported_libs ${imported_libs} Terminfo::terminfo); endif(); set(system_libs ${system_libs} ${LLVM_ATOMIC_LIB}); set(system_libs ${system_libs} ${LLVM_PTHREAD_LIB}); if( UNIX AND NOT (BEOS OR HAIKU) ); set(system_libs ${system_libs} m); endif(); if( UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES ""SunOS"" ); set(system_libs ${system_libs} kstat socket); endif(); if( FUCHSIA ); set(system_libs ${system_libs} zircon); endif(); if ( HAIKU ); add_compile_definitions(_BSD_SOURCE); set(system_libs ${system_libs} bsd network); endif(); endif( MSVC OR MINGW ). # Delay load shell32.dll if possible to speed up process startup.; set (delayload_flags); if (MSVC); # When linking with Swift, `swiftc.exe` is used as the linker drive rather; # than invoking `link.exe` directly. In such a case, the flags should be; # marked as `-Xlinker` to pass them directly to the linker. As a temporary; # workaround simply elide the delay loading.; set (delayload_flags $<$<NOT:$<LINK_LANGUAGE:Swift>>:delayimp -delayload:shell32.dll -delayload:ole32.dll>); endif(). # Link Z3 if the user wants to build it.; if(LLVM_WITH_Z3); set(system_libs ${system_libs} ${Z3_LIBRARIES}); endif(). # Override the C runtime allocator on Windows and embed it into LLVM tools & libraries; if(LLVM_INTEGRATED_CRT_ALLOC); if (NOT CMAKE_MSVC_RUNTIME_LIBRARY OR CMAKE_MSVC_RUNTIME_LIBRARY MATCHES ""DLL$""); message(FATAL_ERROR ""LLVM_INTEGRATED_CRT_ALLOC only works with CMAKE_MSVC_RUNTIME_LIBRARY set to MultiThreaded or MultiThreadedDebug.""); endif(). string(REGEX REPLACE ""(/|\\\\)$"" """" LLVM_INTEGRATED_CRT_ALLOC ""${LLVM_INTEGRATED_CRT_ALLOC}""). if(NOT EXISTS ""${LLVM_INTEGRATED_CRT_ALLOC}""); message(FATAL_ERROR ""Cannot find the path to `git clone` for the CRT allocator! (${LLVM_INTEGRATED_CRT_ALLOC}). Currently, rpmalloc, snmalloc and mimalloc are supported.""); endif(). if(LLVM_INTEGRATED_CRT_ALLOC MATCHES ""rpmalloc$""); add_compil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt:3246,simpl,simply,3246,interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,1,['simpl'],['simply']
Usability,"truct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no match",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10228,simpl,simple,10228,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['simpl'],['simple']
Usability,"truction is designed to operate as a standard '``call``'; instruction in most regards. The primary difference is that it; establishes an association with additional labels to define where control; flow goes after the call. The output values of a '``callbr``' instruction are available only to; the '``fallthrough``' block, not to any '``indirect``' blocks(s). The only use of this today is to implement the ""goto"" feature of gcc inline; assembly where additional labels can be provided as locations for the inline; assembly to jump to. Example:; """""""""""""""". .. code-block:: llvm. ; ""asm goto"" without output constraints.; callbr void asm """", ""r,!i""(i32 %x); to label %fallthrough [label %indirect]. ; ""asm goto"" with output constraints.; <result> = callbr i32 asm """", ""=r,r,!i""(i32 %x); to label %fallthrough [label %indirect]. .. _i_resume:. '``resume``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. resume <type> <value>. Overview:; """""""""""""""""". The '``resume``' instruction is a terminator instruction that has no; successors. Arguments:; """""""""""""""""""". The '``resume``' instruction requires one argument, which must have the; same type as the result of any '``landingpad``' instruction in the same; function. Semantics:; """""""""""""""""""". The '``resume``' instruction resumes propagation of an existing; (in-flight) exception whose unwinding was interrupted with a; :ref:`landingpad <i_landingpad>` instruction. Example:; """""""""""""""". .. code-block:: llvm. resume { ptr, i32 } %exn. .. _i_catchswitch:. '``catchswitch``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind to caller; <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind label <default>. Overview:; """""""""""""""""". The '``catchswitch``' instruction is used by `LLVM's exception handling system; <ExceptionHandling.html#overview>`_ to describe the set of possible catch handlers; that may ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:369831,resume,resume,369831,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability,"tructions may have the same `DIAssignID`; instruction. In this case, the assignment is considered to take place in; multiple positions in the program. **Moving** a non-debug instruction: nothing new to do. Instructions linked to an; `llvm.dbg.assign` have their initial IR position marked by the position of the; `llvm.dbg.assign`. **Deleting** a non-debug instruction: nothing new to do. Simple DSE does not; require any change; it’s safe to delete an instruction with a `DIAssignID`; attachment. An `llvm.dbg.assign` that uses a `DIAssignID` that is not attached; to any instruction indicates that the memory location isn’t valid. **Merging** stores: In many cases no change is required as `DIAssignID`; attachments are automatically merged if `combineMetadata` is called. One way or; another, the `DIAssignID` attachments must be merged such that new store; becomes linked to all the `llvm.dbg.assign` intrinsics that the merged stores; were linked to. This can be achieved simply by calling a helper function; `Instruction::mergeDIAssignID`. **Inlining** stores: As stores are inlined we generate `llvm.dbg.assign`; intrinsics and `DIAssignID` attachments as if the stores represent source; assignments, just like the in frontend. This isn’t perfect, as stores may have; been moved, modified or deleted before inlining, but it does at least keep the; information about the variable correct within the non-inlined scope. **Splitting** stores: SROA and passes that split stores treat `llvm.dbg.assign`; intrinsics similarly to `llvm.dbg.declare` intrinsics. Clone the; `llvm.dbg.assign` intrinsics linked to the store, update the FragmentInfo in; the `ValueExpression`, and give the split stores (and cloned intrinsics) new; `DIAssignID` attachments each. In other words, treat the split stores as; separate assignments. For partial DSE (e.g. shortening a memset), we do the; same except that `llvm.dbg.assign` for the dead fragment gets an `Undef`; `Address`. **Promoting** allocas and store/loads",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:6837,simpl,simply,6837,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['simpl'],['simply']
Usability,"tructions. This pass does not; modify the CFG. This pass is where algebraic simplification happens. This pass combines things like:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. into:. .. code-block:: llvm. %Z = add i32 %X, 2. This is a simple worklist driven algorithm. This pass guarantees that the following canonicalizations are performed on the; program:. #. If a binary operator has a constant operand, it is moved to the right-hand; side.; #. Bitwise operators with constant operands are always grouped so that shifts; are performed first, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant power-of-two argument are transformed into; shifts.; #. … etc. This pass can also simplify calls to specific well-known function calls (e.g.; runtime library functions). For example, a call ``exit(3)`` that occurs within; the ``main()`` function can be transformed into simply ``return 3``. Whether or; not library calls are simplified is controlled by the; :ref:`-function-attrs <passes-function-attrs>` pass and LLVM's knowledge of; library calls on different targets. .. _passes-aggressive-instcombine:. ``aggressive-instcombine``: Combine expression patterns; --------------------------------------------------------. Combine expression patterns to form expressions with fewer, simple instructions. For example, this pass reduce width of expressions post-dominated by TruncInst; into smaller width when applicable. It differs from instcombine pass in that it can modify CFG and contains pattern; optimization that requires higher complexity than the O(1), thus, it should run fewer; times than instcombine pass. ``internalize``: Internalize Global Symbols; ---------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:20418,simpl,simplify,20418,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplify']
Usability,"tructure is slower than using a stack map; compiled into the executable as constant data, but has a significant portability; advantage because it requires no special support from the target code generator,; and does not require tricky platform-specific code to crawl the machine stack. The tradeoff for this simplicity and portability is:. * High overhead per function call. * Not thread-safe. Still, it's an easy way to get started. After your compiler and runtime are up; and running, writing a :ref:`plugin <plugin>` will allow you to take advantage; of :ref:`more advanced GC features <collector-algos>` of LLVM in order to; improve performance. The shadow stack doesn't imply a memory allocation algorithm. A semispace; collector or building atop ``malloc`` are great places to start, and can be; implemented with very little code. When it comes time to collect, however, your runtime needs to traverse the stack; roots, and for this it needs to integrate with the shadow stack. Luckily, doing; so is very simple. (This code is heavily commented to help you understand the; data structure, but there are only 20 lines of meaningful code.). .. code-block:: c++. /// The map for a single function's stack frame. One of these is; /// compiled as constant data into the executable for each function.; ///; /// Storage of metadata values is elided if the %metadata parameter to; /// @llvm.gcroot is null.; struct FrameMap {; int32_t NumRoots; //< Number of roots in stack frame.; int32_t NumMeta; //< Number of metadata entries. May be < NumRoots.; const void *Meta[0]; //< Metadata for each root.; };. /// A link in the dynamic shadow stack. One of these is embedded in; /// the stack frame of each function on the call stack.; struct StackEntry {; StackEntry *Next; //< Link to next stack entry (the caller's).; const FrameMap *Map; //< Pointer to constant FrameMap.; void *Roots[0]; //< Stack roots (in-place array).; };. /// The head of the singly-linked list of StackEntries. Functions push; /// ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:17411,simpl,simple,17411,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['simpl'],['simple']
Usability,"true) { int x = 42; } }; void g() { for (;;) { int x = 43; } }; expr(integerLiteral(hasAncestor(ifStmt()))) matches 42, but not 43. Usable as: Any Matcher. Matcher<*>hasDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, Y, Z; (matcher = cxxRecordDecl(hasDescendant(cxxRecordDecl(hasName(""X""))))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; };. DescendantT must be an AST base type. Usable as: Any Matcher. Matcher<*>hasMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y; (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName(""X""))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. Usable as: Any Matcher; Note that has is direct matcher, so it also matches things like implicit; casts and paren casts. If you are matching with expr then you should; probably consider using ignoringParenImpCasts like:; has(ignoringParenImpCasts(expr())). Matcher<*>hasParentMatcher<*>; Matches AST nodes that have a parent that matches the provided; matcher. Given; void f() { for (;;) { int x = 42; if (true) { int x = 43; } } }; compoundStmt(hasParent(ifStmt())) matches ""{ int x = 43; }"". Usable as: Any Matcher. Matcher<*>invocationMatcher<*>...Matcher<*>; Matches function calls and constructor calls. Because CallExpr and CXXConstructExpr do not share a common; base class with API accessing arguments etc, AST Matchers for code; which should match both are typically duplicated. This matcher; removes the need for duplication. Given code; struct ConstructorTakesInt; {; ConstructorTakesInt(int i) {}; };. void callTakesInt(int i); {; }. void doCall(); {; callTakesInt(42);; }. void doConstruct(); {; ConstructorTakesInt cti(42);; }. The matcher; invoc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:134574,Usab,Usable,134574,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"true.i.i.i.i; call void @_ZSt17__throw_bad_allocv() noreturn nounwind; unreachable. _ZNSt12_Vector_baseIiSaIiEEC2EmRKS0_.exit.i.i: ; preds = %cond.true.i.i.i.i; %mul.i.i.i.i.i = shl i64 %conv, 2; %call3.i.i.i.i.i = call noalias i8* @_Znwm(i64 %mul.i.i.i.i.i) nounwind; %0 = bitcast i8* %call3.i.i.i.i.i to i32*; store i32* %0, i32** %v2.sub, align 8, !tbaa !0; store i32* %0, i32** %tmp3.i.i.i.i.i, align 8, !tbaa !0; %add.ptr.i.i.i = getelementptr inbounds i32* %0, i64 %conv; store i32* %add.ptr.i.i.i, i32** %tmp4.i.i.i.i.i, align 8, !tbaa !0; call void @llvm.memset.p0i8.i64(i8* %call3.i.i.i.i.i, i8 0, i64 %mul.i.i.i.i.i, i32 4, i1 false); br label %_ZNSt6vectorIiSaIiEEC1EmRKiRKS0_.exit. This is just the handling the construction of the vector. Most surprising here; is the fact that all three null stores in %entry are dead (because we do no; cross-block DSE). Also surprising is that %conv isn't simplified to 0 in %....exit.thread.i.i.; This is a because the client of LazyValueInfo doesn't simplify all instruction; operands, just selected ones. //===---------------------------------------------------------------------===//. clang -O3 -fno-exceptions currently compiles this code:. void f(char* a, int n) {; __builtin_memset(a, 0, n);; for (int i = 0; i < n; ++i); a[i] = 0;; }. into:. define void @_Z1fPci(i8* nocapture %a, i32 %n) nounwind {; entry:; %conv = sext i32 %n to i64; tail call void @llvm.memset.p0i8.i64(i8* %a, i8 0, i64 %conv, i32 1, i1 false); %cmp8 = icmp sgt i32 %n, 0; br i1 %cmp8, label %for.body.lr.ph, label %for.end. for.body.lr.ph: ; preds = %entry; %tmp10 = add i32 %n, -1; %tmp11 = zext i32 %tmp10 to i64; %tmp12 = add i64 %tmp11, 1; call void @llvm.memset.p0i8.i64(i8* %a, i8 0, i64 %tmp12, i32 1, i1 false); ret void. for.end: ; preds = %entry; ret void; }. This shouldn't need the ((zext (%n - 1)) + 1) game, and it should ideally fold; the two memset's together. The issue with the addition only occurs in 64-bit mode, and appears to be at; least partially ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:58323,simpl,simplify,58323,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplify']
Usability,"try to understand why.** Disagreements, both social and; technical, happen all the time and LLVM is no exception. It is important that; we resolve disagreements and differing views constructively. Remember that; we're different. The strength of LLVM comes from its varied community, people; from a wide range of backgrounds. Different people have different; perspectives on issues. Being unable to understand why someone holds; a viewpoint doesn't mean that they're wrong. Don't forget that it is human to; err and blaming each other doesn't get us anywhere. Instead, focus on helping; to resolve issues and learning from mistakes. Reporting; =========. If you believe someone is violating the code of conduct you can always report; it to the LLVM Foundation Code of Conduct Committee by emailing; conduct@llvm.org. All reports will be kept confidential. This isn't a public; list and only members of the advisory committee will receive the report. For; details on what to include in the report, please see the :doc:`Reporting Guide; <ReportingGuide>`. If you believe anyone is in physical danger, please notify appropriate law; enforcement first. If you are unsure what law enforcement agency is; appropriate, please include this in your report and we will attempt to notify; them. If the violation occurs at an event such as a Developer Meeting and requires; immediate attention, you can also reach out to any of the event organizers or; staff. Event organizers and staff will be prepared to handle the incident and; able to help. If you cannot find one of the organizers, the venue staff can; locate one for you. We will also post detailed contact information for specific; events as part of each events' information. In person reports will still be; kept confidential exactly as above, but also feel free to (anonymously if; needed) email conduct@llvm.org. Code of Conduct Committee; =========================. The committee will consist of a minimum of 5 members and members are asked to; serve ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:5821,Guid,Guide,5821,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['Guid'],['Guide']
Usability,"try_2E_ce:; mov r2, #1; lsl r2, r0; cmp r0, #9; bhi LBB1_4 @bb12.exitStub; LBB1_1: @newFuncRoot; mov r1, #13; tst r2, r1; bne LBB1_5 @bb4.exitStub; LBB1_2: @newFuncRoot; ldr r1, LCPI1_0; tst r2, r1; bne LBB1_6 @bb9.exitStub; LBB1_3: @newFuncRoot; mov r1, #1; lsl r1, r1, #8; tst r2, r1; bne LBB1_7 @bb.exitStub; LBB1_4: @bb12.exitStub; mov r0, #0; bx lr; LBB1_5: @bb4.exitStub; mov r0, #1; bx lr; LBB1_6: @bb9.exitStub; mov r0, #2; bx lr; LBB1_7: @bb.exitStub; mov r0, #3; bx lr; LBB1_8:; .align 2; LCPI1_0:; .long 642. gcc compiles to:. 	cmp	r0, #9; 	@ lr needed for prologue; 	bhi	L2; 	ldr	r3, L11; 	mov	r2, #1; 	mov	r1, r2, asl r0; 	ands	r0, r3, r2, asl r0; 	movne	r0, #2; 	bxne	lr; 	tst	r1, #13; 	beq	L9; L3:; 	mov	r0, r2; 	bx	lr; L9:; 	tst	r1, #256; 	movne	r0, #3; 	bxne	lr; L2:; 	mov	r0, #0; 	bx	lr; L12:; 	.align 2; L11:; 	.long	642; . GCC is doing a couple of clever things here:; 1. It is predicating one of the returns. This isn't a clear win though: in; cases where that return isn't taken, it is replacing one condbranch with; two 'ne' predicated instructions.; 2. It is sinking the shift of ""1 << i"" into the tst, and using ands instead of; tst. This will probably require whole function isel.; 3. GCC emits:; 	tst	r1, #256; we emit:; mov r1, #1; lsl r1, r1, #8; tst r2, r1. //===---------------------------------------------------------------------===//. When spilling in thumb mode and the sp offset is too large to fit in the ldr /; str offset field, we load the offset from a constpool entry and add it to sp:. ldr r2, LCPI; add r2, sp; ldr r2, [r2]. These instructions preserve the condition code which is important if the spill; is between a cmp and a bcc instruction. However, we can use the (potentially); cheaper sequence if we know it's ok to clobber the condition register. add r2, sp, #255 * 4; add r2, #132; ldr r2, [r2, #7 * 4]. This is especially bad when dynamic alloca is used. The all fixed size stack; objects are referenced off the frame pointer with negative offsets.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README-Thumb.txt:3573,clear,clear,3573,interpreter/llvm-project/llvm/lib/Target/ARM/README-Thumb.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README-Thumb.txt,1,['clear'],['clear']
Usability,"ts *must* adhere to the guidelines specified below to ensure; proper operation in multithreaded mode. Note that, on Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capable LLVM on a platform without a suitably modern system; compiler, consider compiling LLVM and LLVM-GCC in single-threaded mode, and; using the resultant compiler to build a copy of LLVM with multithreading; support. .. _shutdown:. Ending Execution with ``llvm_shutdown()``; -----------------------------------------. When you are done using the LLVM APIs, you should call ``llvm_shutdown()`` to; deallocate memory used for internal structures. .. _managedstatic:. Lazy Initialization with ``ManagedStatic``; ------------------------------------------. ``ManagedStatic`` is a utility class in LLVM used to implement static; initialization of static resources, such as the global type tables. In a; single-threaded environment, it implements a simple lazy initialization scheme.; When LLVM is compiled with support for multi-threading, however, it uses; double-checked locking to implement thread-safe lazy initialization. .. _llvmcontext:. Achieving Isolation with ``LLVMContext``; ----------------------------------------. ``LLVMContext`` is an opaque class in the LLVM API which clients can use to; operate multiple, isolated instances of LLVM concurrently within the same; address space. For instance, in a hypothetical compile-server, the compilation; of an individual translation unit is conceptually independent from all the; others, and it would be desirable to be able to compile incoming translation; units concurrently on independent server threads. Fortunately, ``LLVMContext``; exists to enable just this kind of scenario!. Conceptually, ``LLVMContext`` provides isolation. Every LLVM entity; (``Module``\ s, ``Value``\ s, ``Type``\ s, ``Constant``\ s, etc.) in LLVM's; in-memory IR belongs to an ``LLVMContext``. Entities",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:122305,simpl,simple,122305,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"ts an error message if it is not. .. productionlist::; Assert: ""assert"" `condition` "","" `message` "";"". If the boolean condition is true, the statement does nothing. If the; condition is false, it prints a nonfatal error message. The **message**, which; can be an arbitrary string expression, is included in the error message as a; note. The exact behavior of the ``assert`` statement depends on its; placement. * At top level, the assertion is checked immediately. * In a record definition, the statement is saved and all assertions are; checked after the record is completely built. * In a class definition, the assertions are saved and inherited by all; the subclasses and records that inherit from the class. The assertions are; then checked when the records are completely built. * In a multiclass definition, the assertions are saved with the other; components of the multiclass and then checked each time the multiclass; is instantiated with ``defm``. Using assertions in TableGen files can simplify record checking in TableGen; backends. Here is an example of an ``assert`` in two class definitions. .. code-block:: text. class PersonName<string name> {; assert !le(!size(name), 32), ""person name is too long: "" # name;; string Name = name;; }. class Person<string name, int age> : PersonName<name> {; assert !and(!ge(age, 1), !le(age, 120)), ""person age is invalid: "" # age;; int Age = age;; }. def Rec20 : Person<""Donald Knuth"", 60> {; ...; }. Additional Details; ==================. Directed acyclic graphs (DAGs); ------------------------------. A directed acyclic graph can be represented directly in TableGen using the; ``dag`` datatype. A DAG node consists of an operator and zero or more; arguments (or operands). Each argument can be of any desired type. By using; another DAG node as an argument, an arbitrary graph of DAG nodes can be; built. The syntax of a ``dag`` instance is:. ``(`` *operator* *argument1*\ ``,`` *argument2*\ ``,`` ... ``)``. The operator must be present and mus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:50021,simpl,simplify,50021,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simplify']
Usability,"ts should be accurate and very close to those you would have got; without limits. In other cases (which should be more common, since; otherwise you wouldn't need limits), the very meaning of parameter; errors becomes problematic. Mathematically, since the limit is an; absolute constraint on the parameter, a parameter at its limit has no; error, at least in one direction. The error matrix, which can assign; only symmetric errors, then becomes essentially meaningless. On the; other hand, the $\mbox{MINOS}$ analysis is still meaningful, at; least in principle, as long as $\mbox{MIGRAD}$ (which is called; internally by $\mbox{MINOS}$) does not get blocked at a limit.; Unfortunately, the user has no control over this aspect of the; $\mbox{MINOS}$ calculation, although it is possible to get enough; printout from the $\mbox{MINOS}$ result to be able to determine; whether the results are reliable or not. ## Fixing and releasing parameters ##. When M needs to be guided to the ""right"" minimum, often the best way to; do this is with the methods e.g. MnMigrad::fix(...) and; MnMigrad::release(...). That is, suppose you have a problem with ten; free parameters, and when you minimize with respect to all at once, M; goes to an unphysical solution characterized by an unphysical or; unwanted value of parameter number four. One way to avoid this is to fix; parameter four at a ""good"" value (not necessarily the best, since you; presumably don't know that yet), and minimize with respect to the; others. Then release parameter four and minimize again. If the problem; admits a ""good"" physical solution, you will normally find it this way.; If it doesn't work, you may see what is wrong by the following sequence; (where $\mbox{xxx}$ is the expected physical value for parameter; four):. MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);. where $\mbox{SC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:66534,guid,guided,66534,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['guid'],['guided']
Usability,"ts the optimizer; from performing unsound optimizations.; #. recording a mapping of live pointers (and the allocation they're; associated with) for each statepoint. At the most abstract level, inserting a safepoint can be thought of as; replacing a call instruction with a call to a multiple return value; function which both calls the original target of the call, returns; its result, and returns updated values for any live pointers to; garbage collected objects. Note that the task of identifying all live pointers to garbage; collected values, transforming the IR to expose a pointer giving the; base object for every such live pointer, and inserting all the; intrinsics correctly is explicitly out of scope for this document.; The recommended approach is to use the :ref:`utility passes; <statepoint-utilities>` described below. This abstract function call is concretely represented by a sequence of; intrinsic calls known collectively as a ""statepoint relocation sequence"". Let's consider a simple call in LLVM IR:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; call void ()* @foo(); ret i8 addrspace(1)* %obj; }. Depending on our language we may need to allow a safepoint during the execution; of ``foo``. If so, we need to let the collector update local values in the; current frame. If we don't, we'll be accessing a potential invalid reference; once we eventually return from the call. In this example, we need to relocate the SSA value ``%obj``. Since we can't; actually change the value in the SSA value ``%obj``, we need to introduce a new; SSA value ``%obj.relocated`` which represents the potentially changed value of; ``%obj`` after the safepoint and update any following uses appropriately. The; resulting relocation sequence is:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; %0 = call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:7983,simpl,simple,7983,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['simpl'],['simple']
Usability,"ts) can be produced from a TTree using the; “candle” option in TTree::Draw(). ``` {.cpp}; tree->Draw(“px:cos(py):sin(pz)”,””,”candle”);; ```. ### Using TTree::Scan; \index{tree!scan}. `TTree::Scan` can be used to print the content of the tree's entries; optional passing a selection. ``` {.cpp}; root[] MyTree->Scan();; ```. will print the first 8 variables of the tree. ``` {.cpp}; root[] MyTree->Scan(""*"");; ```. will print all the variable of the tree. Specific variables of the tree can be explicit selected by list them in; column separated list:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"");; ```. will print the values of `var1`, `var2` and `var3`. A selection can be; applied in the second argument:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; ```. will print the values of `var1`, `var2` and `var3` for the entries where; var1 is exactly 0. `TTree::Scan` returns the number of entries passing the selection. By; default 50 rows are shown before `TTree::Scan` pauses and ask you to; press the Enter key to see the next 50 rows. You can change the default; number of rows to be shown before \<CR\> via; `mytree->SetScanfield(maxrows)` where maxrows is 50 by default. If; maxrows is set to 0 all rows of the **`Tree`** are shown. This option is; interesting when dumping the contents of a Tree to an ascii file, eg; from the command line:. ``` {.cpp}; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; ```. will create a file `tree.log`. Arrays (within an entry) are printed in their linear forms. If several; arrays with multiple dimensions are printed together, they will NOT be; synchronized. For example, with a tree containing `arr1[4][2] `and; `arr2[2][3]`,. ``` {.cpp}; root[] MyTree(""arr1:arr2"");; ```. will results in a printing similar to:. ``` {.cpp}; ************************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:105498,pause,pauses,105498,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['pause'],['pauses']
Usability,"ts<8> Opcode = { 0, 0, 0, 0, 0, 0, 0, 1 };; Format Form = MRMDestReg;; bits<7> FormBits = { 0, 1, 0, 1, 0, 0, 0 };; ImmType ImmT = NoImm;; bit ForceDisassemble = 0;; OperandSize OpSize = OpSize32;; bits<2> OpSizeBits = { 1, 0 };; AddressSize AdSize = AdSizeX;; bits<2> AdSizeBits = { 0, 0 };; Prefix OpPrefix = NoPrfx;; bits<3> OpPrefixBits = { 0, 0, 0 };; Map OpMap = OB;; bits<3> OpMapBits = { 0, 0, 0 };; bit hasREX_WPrefix = 0;; FPFormat FPForm = NotFP;; bit hasLockPrefix = 0;; Domain ExeDomain = GenericDomain;; bit hasREPPrefix = 0;; Encoding OpEnc = EncNormal;; bits<2> OpEncBits = { 0, 0 };; bit HasVEX_W = 0;; bit IgnoresVEX_W = 0;; bit EVEX_W1_VEX_W0 = 0;; bit hasVEX_4V = 0;; bit hasVEX_L = 0;; bit ignoresVEX_L = 0;; bit hasEVEX_K = 0;; bit hasEVEX_Z = 0;; bit hasEVEX_L2 = 0;; bit hasEVEX_B = 0;; bits<3> CD8_Form = { 0, 0, 0 };; int CD8_EltSize = 0;; bit hasEVEX_RC = 0;; bit hasNoTrackPrefix = 0;; bits<7> VectSize = { 0, 0, 1, 0, 0, 0, 0 };; bits<7> CD8_Scale = { 0, 0, 0, 0, 0, 0, 0 };; string FoldGenRegForm = ?;; string EVEX2VEXOverride = ?;; bit isMemoryFoldable = 1;; bit notEVEX2VEXConvertible = 0;; }. On the first line of the record, you can see that the ``ADD32rr`` record; inherited from eight classes. Although the inheritance hierarchy is complex,; using parent classes is much simpler than specifying the 109 individual; fields for each instruction. Here is the code fragment used to define ``ADD32rr`` and multiple other; ``ADD`` instructions:. .. code-block:: text. defm ADD : ArithBinOp_RF<0x00, 0x02, 0x04, ""add"", MRM0r, MRM0m,; X86add_flag, add, 1, 1, 1>;. The ``defm`` statement tells TableGen that ``ArithBinOp_RF`` is a; multiclass, which contains multiple concrete record definitions that inherit; from ``BinOpRR_RF``. That class, in turn, inherits from ``BinOpRR``, which; inherits from ``ITy`` and ``Sched``, and so forth. The fields are inherited; from all the parent classes; for example, ``IsIndirectBranch`` is inherited; from the ``Instruction`` class.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:78831,simpl,simpler,78831,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simpler']
Usability,"tself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does `make map` in root folder. ``` {.cpp}; root[] gSystem->Load(""libGeom"");; ```. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; ***`gGeoManager`***:. ``` {.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ```. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ```. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ``` {.cpp}; root[] gGeoManager->SetTopVolume(top);; ```. This should be enough",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:2673,simpl,simplest,2673,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simplest']
Usability,"ttern matches,; and ``CHECK-NOT:`` patterns that do not have matches. Implies ``-v``.; However, if ``-dump-input=fail`` or ``-dump-input=always``, just add that; information as input annotations instead. .. option:: --allow-deprecated-dag-overlap. Enable overlapping among matches in a group of consecutive ``CHECK-DAG:``; directives. This option is deprecated and is only provided for convenience; as old tests are migrated to the new non-overlapping ``CHECK-DAG:``; implementation. .. option:: --allow-empty. Allow checking empty input. By default, empty input is rejected. .. option:: --color. Use colors in output (autodetected by default). EXIT STATUS; -----------. If :program:`FileCheck` verifies that the file matches the expected contents,; it exits with 0. Otherwise, if not, or if an error occurs, it will exit with a; non-zero value. TUTORIAL; --------. FileCheck is typically used from LLVM regression tests, being invoked on the RUN; line of the test. A simple example of using FileCheck from a RUN line looks; like this:. .. code-block:: llvm. ; RUN: llvm-as < %s | llc -march=x86-64 | FileCheck %s. This syntax says to pipe the current file (""``%s``"") into ``llvm-as``, pipe; that into ``llc``, then pipe the output of ``llc`` into ``FileCheck``. This; means that FileCheck will be verifying its standard input (the llc output); against the filename argument specified (the original ``.ll`` file specified by; ""``%s``""). To see how this works, let's look at the rest of the ``.ll`` file; (after the RUN line):. .. code-block:: llvm. define void @sub1(i32* %p, i32 %v) {; entry:; ; CHECK: sub1:; ; CHECK: subl; %0 = tail call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %p, i32 %v); ret void; }. define void @inc4(i64* %p) {; entry:; ; CHECK: inc4:; ; CHECK: incq; %0 = tail call i64 @llvm.atomic.load.add.i64.p0i64(i64* %p, i64 1); ret void; }. Here you can see some ""``CHECK:``"" lines specified in comments. Now you can; see how the file is piped into ``llvm-as``, then ``llc``, and the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:7907,simpl,simple,7907,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['simpl'],['simple']
Usability,"tting it into another is not necessarily easier than re-doing it.; > Optimization code is usually heavily tied in to the specific IR they use. Understood. The only reason that I brought this up is because SGI's IR is; more similar to LLVM than it is different in many respects (SSA based,; relatively low level, etc), and could be easily adapted. Also their; optimizations are written in C++ and are actually somewhat; structured... of course it would be no walk in the park, but it would be; much less time consuming to adapt, say, SSA-PRE than to rewrite it. > But your larger point is valid that adding SSA based optimizations is; > feasible and should be fun. (Again, link time cost is the issue.). Assuming linktime cost wasn't an issue, the question is: ; Does using GCC's backend buy us anything?. > It also occurs to me that GCC is probably doing quite a bit of back-end; > optimization (step 16 in your list). Do you have a breakdown of that?. Not really. The irritating part of GCC is that it mixes it all up and; doesn't have a clean separation of concerns. A lot of the ""back end; optimization"" happens right along with other data optimizations (ie, CSE; of machine specific things). As far as REAL back end optimizations go, it looks something like this:. 1. Instruction combination: try to make CISCy instructions, if available; 2. Register movement: try to get registers in the right places for the; architecture to avoid register to register moves. For example, try to get; the first argument of a function to naturally land in %o0 for sparc.; 3. Instruction scheduling: 'nuff said :); 4. Register class preferencing: ??; 5. Local register allocation; 6. global register allocation; 7. Spilling; 8. Local regalloc; 9. Jump optimization; 10. Delay slot scheduling; 11. Branch shorting for CISC machines; 12. Instruction selection & peephole optimization; 13. Debug info output. But none of this would be usable for LLVM anyways, unless we were using; GCC as a static compiler. -Chris. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt:2914,usab,usable,2914,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt,1,['usab'],['usable']
Usability,ttps://groups.google.com/d/forum/civetweb](https://groups.google.com/d/forum/civetweb). Formerly some support question and discussion threads have been at [Google groups](https://groups.google.com/d/forum/civetweb).; Recent questions and discussions use [GitHub issues](https://github.com/civetweb/civetweb/issues). Source releases can be found on GitHub; [https://github.com/civetweb/civetweb/releases](https://github.com/civetweb/civetweb/releases). A very brief overview can be found on GitHub Pages; [http://civetweb.github.io/civetweb/](http://civetweb.github.io/civetweb/). Getting The Source; ------------------; Download the source code by running the following code in your command prompt:. $ git clone https://github.com/civetweb/civetweb.git; or simply grab a copy of the source code as a ZIP or TGZ file. Quick start documentation; --------------------------. - [docs/Installing.md](https://github.com/civetweb/civetweb/blob/master/docs/Installing.md) - Install Guide (for end users using pre-built binaries); - [docs/UserManual.md](https://github.com/civetweb/civetweb/blob/master/docs/UserManual.md) - End User Guide; - [docs/Building.md](https://github.com/civetweb/civetweb/blob/master/docs/Building.md) - Building the Server (quick start guide); - [docs/Embedding.md](https://github.com/civetweb/civetweb/blob/master/docs/Embedding.md) - Embedding (how to add HTTP support to an existing application); - [docs/OpenSSL.md](https://github.com/civetweb/civetweb/blob/master/docs/OpenSSL.md) - Adding HTTPS (SSL/TLS) support using OpenSSL.; - [API documentation](https://github.com/civetweb/civetweb/tree/master/docs/api) - Additional documentation on the civetweb application programming interface ([civetweb.h](https://github.com/civetweb/civetweb/blob/master/include/civetweb.h)).; - [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md) - Release Notes; - [SECURITY.md](https://github.com/civetweb/civetweb/blob/master/SECURITY.md) - Security Policy; -,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:4025,Guid,Guide,4025,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['Guid'],['Guide']
Usability,"ture were; required:; TEveProjectable::ProjectedClass() takes an argument:; virtual TClass* ProjectedClass(const TEveProjection* p) const = 0;; thus allowing different projected classes for different projections.; All TEveProjection::ProjectPoint/Vector(...) functions have an; additional ""depth"" argument thus allowing the projected classes to; skip explicit setting of depth after the point has been projected; -- this could damage the 3rd component. Pre-scaling now supports 3 dimensions.; Abstract TEveProjected::SetDepth() has been split into two parts:; ; It has been implemented in the base class where it checks for; the projection type (2d) before calling the local function;; Abstract SetDepthLocal() has been added to provide the same; functionality. This allows for the 2d/3d check to be done in place only.; New projection class has been introduced: TEve3DProjection.; It performs pre-scaling and offsets the center.; To simplify the projection of lists TEveElementList has been made; projectable and corresponding TEveElementListProjected class; introduced. This also fixed the problem with render-state not being; propagated to projected classes. The check whether to project a sub-tree of elements is still performed.; TEveGeoShapeProjected has been introduced to represent the 3D; projection of a TEveGeoShape (2D projection is handled by; TEvePolygonSetProjected). Points, lines and tracks use the same projected class for both 2D; and 3D projections. An example showing this functionality has been added as a new tab in; projection_prescale.C.; TEveManager now allows simultaneous usage of several objects; editors. Simply click on the top name-button in object editor to; create a standalone editor for this object in a separate window. This; facilitates operation when several objects need to be modifed in; parallel.; New tutorial alice_vsd.C has been added. It shows; how to read Visualization Summary Data files (VSD).; Code for operating three view configuration (3D / RPhi /",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html:2578,simpl,simplify,2578,graf3d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html,1,['simpl'],['simplify']
Usability,"turn std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_counter_1 = {__int_8 = 0 '\000'}, class_await_counter_2 = {__int_8 = 0 '\000'}, struct_std__suspend_always_3 = {__int_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:7160,resume,resume,7160,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability,"ty cannot be determined statically at compile time. For our; example, the coroutine frame will be:. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32 }. After resume and destroy parts are outlined, function `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i32 0, i32 2; store i32 %inc, ptr %inc.spill.addr; call void @print(i32 %n). ret ptr %frame; }. Outlined resume part of the coroutine will reside in function `f.resume`:. .. code-block:: llvm. define internal fastcc void @f.resume(ptr %frame.ptr.resume) {; entry:; %inc.spill.addr = getelementptr %f.frame, ptr %frame.ptr.resume, i64 0, i32 2; %inc.spill = load i32, ptr %inc.spill.addr, align 4; %inc = add i32 %inc.spill, 1; store i32 %inc, ptr %inc.spill.addr, align 4; tail call void @print(i32 %inc); ret void; }. Whereas function `f.destroy` will contain the cleanup code for the coroutine:. .. code-block:: llvm. define internal fastcc void @f.destroy(ptr %frame.ptr.destroy) {; entry:; tail call void @free(ptr %frame.ptr.destroy); ret void; }. Avoiding Heap Allocations; -------------------------. A particular coroutine usage pattern, which is illustrated by the `main`; function in the overview section, where a coroutine is created, manipulated and; destroyed by the same calling function, is common for coroutines implementing; RAII idiom and is suitable for allocation elision optimization which avoid; dynamic all",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:15493,resume,resume,15493,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,ty/StringExtractorTest.cpp; lldb/unittests/Utility/StringLexerTest.cpp; lldb/unittests/Utility/StringListTest.cpp; lldb/unittests/Utility/StructuredDataTest.cpp; lldb/unittests/Utility/SubsystemRAIITest.cpp; lldb/unittests/Utility/TildeExpressionResolverTest.cpp; lldb/unittests/Utility/TimeoutTest.cpp; lldb/unittests/Utility/UriParserTest.cpp; lldb/unittests/Utility/UserIDResolverTest.cpp; lldb/unittests/Utility/UUIDTest.cpp; lldb/unittests/Utility/VMRangeTest.cpp; lldb/utils/TableGen/LLDBOptionDefEmitter.cpp; lldb/utils/TableGen/LLDBPropertyDefEmitter.cpp; lldb/utils/TableGen/LLDBTableGen.cpp; lldb/utils/TableGen/LLDBTableGenBackends.h; lldb/utils/TableGen/LLDBTableGenUtils.cpp; lldb/utils/TableGen/LLDBTableGenUtils.h; llvm/bindings/ocaml/llvm/llvm_ocaml.h; llvm/cmake/dummy.cpp; llvm/cmake/unwind.h; llvm/examples/Bye/Bye.cpp; llvm/examples/HowToUseLLJIT/HowToUseLLJIT.cpp; llvm/examples/IRTransforms/InitializePasses.cpp; llvm/examples/IRTransforms/InitializePasses.h; llvm/examples/IRTransforms/SimplifyCFG.cpp; llvm/examples/IRTransforms/SimplifyCFG.h; llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/KaleidoscopeJIT.h; llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h; llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/KaleidoscopeJIT.h; llvm/examples/Kaleidoscope/Chapter2/toy.cpp; llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h; llvm/examples/OrcV2Examples/ExampleModules.h; llvm/examples/OrcV2Examples/LLJITDumpObjects/LLJITDumpObjects.cpp; llvm/examples/OrcV2Examples/LLJITWithCustomObjectLinkingLayer/LLJITWithCustomObjectLinkingLayer.cpp; llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp; llvm/examples/OrcV2Examples/LLJITWithGDBRegistrationListener/LLJITWithGDBRegistrationListener.cpp; llvm/examples/OrcV2Examples/LLJITWithInitializers/LLJITWithInitializers.cpp; llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp; llvm/examples/OrcV2Examples/LLJITWithObjectCache/LLJITWithObjec,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:234760,Simpl,SimplifyCFG,234760,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimplifyCFG']
Usability,"types of stack walking that may be used by various; language runtime libraries. We imagine that it would be typical to ; represent a frame with a PC and frame pointer pair, although that is not ; required. %frame getStackCurrentFrame();; Get a frame object for the current function. Note that if the current; function was inlined into its caller, the ""current"" frame will belong to; the ""caller"". bool isFirstFrame(%frame f);; Returns true if the specified frame is the top level (first activated) frame; for this thread. For the main thread, this corresponds to the main() ; function, for a spawned thread, it corresponds to the thread function. %frame getNextFrame(%frame f);; Return the previous frame on the stack. This function is undefined if f; satisfies the predicate isFirstFrame(f). Label *getFrameLabel(%frame f);; If a label was associated with f (as discussed below), this function returns; it. Otherwise, it returns a null pointer. doNonLocalBranch(Label *L);; At this point, it is not clear whether this should be a function or ; intrinsic. It should probably be an intrinsic in LLVM, but we'll deal with; this issue later. Here is a motivating example that illustrates how these facilities could be; used to implement the C++ exception model:. void TestFunction(...) {; A a; B b;; foo(); // Any function call may throw; bar();; C c;. try {; D d;; baz();; } catch (int) {; ...int Stuff...; // execution continues after the try block: the exception is consumed; } catch (double) {; ...double stuff...; throw; // Exception is propogated; }; }. This function would compile to approximately the following code (heavy ; pseudo code follows):. Func:; %a = alloca A; A::A(%a) // These ctors & dtors could throw, but we ignore this ; %b = alloca B // minor detail for this example; B::B(%b). call foo() with fooCleanup // An exception in foo is propogated to fooCleanup; call bar() with barCleanup // An exception in bar is propogated to barCleanup. %c = alloca C; C::C(c); %d = alloca D; D::D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt:2145,clear,clear,2145,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt,1,['clear'],['clear']
Usability,"typo: the programmer; meant init() but wrote innit() instead. template <class T> class Processor {; ...; void init();; ...; };; ...; template <class T> void process() {; Processor<T> processor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Default initialization of const variable of a class type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:19629,clear,clearer,19629,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['clear'],['clearer']
Usability,"u must specify the; directory cycle:. ``` {.cpp}; root[] f->Delete(""Wed011003;1""); ```. Some other examples of `namecycle` format are:. - `foo`:delete the object named `foo` from memory. - `foo;1`: delete the cycle 1 of the object named `foo` from the file. - `foo;*`: delete all cycles of `foo` from the file and also from; memory. - `*;2`: delete all objects with cycle number 2 from the file. - `*;*: delete` all objects from memory and from the file. - `T*;*`: delete all objects from memory and from the file including; all subdirectories. ## Streamers. To follow the discussion on `Streamers`, you need to know what a; *simple* data type is. A variable is of a simple data type if it cannot; be decomposed into other types. Examples of simple data types are longs,; shorts, floats, and chars. In contrast, a variable is of a *composite*; data type if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data memb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:42251,Simpl,Simple,42251,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['Simpl'],['Simple']
Usability,"u need for ARM are: ``libtinfo``, ``zlib1g``,; ``libxml2`` and ``liblzma``. In the Debian repository you'll; find downloads for all architectures. After you download and unpack all ``.deb`` packages, copy all; ``.so`` and ``.a`` to a directory, make the appropriate; symbolic links (if necessary), and add the relevant ``-L``; and ``-I`` paths to ``-DCMAKE_CXX_FLAGS`` above. Running CMake and Building; --------------------------. Finally, if you're using your platform compiler, run:. .. code-block:: bash. $ cmake -G Ninja <source-dir> -DCMAKE_BUILD_TYPE=<type> <options above>. If you're using Clang as the cross-compiler, run:. .. code-block:: bash. $ CC='clang' CXX='clang++' cmake -G Ninja <source-dir> -DCMAKE_BUILD_TYPE=<type> <options above>. If you have ``clang``/``clang++`` on the path, it should just work, and special; Ninja files will be created in the build directory. I strongly suggest; you to run ``cmake`` on a separate build directory, *not* inside the; source tree. To build, simply type:. .. code-block:: bash. $ ninja. It should automatically find out how many cores you have, what are; the rules that needs building and will build the whole thing. You can't run ``ninja check-all`` on this tree because the created; binaries are targeted to ARM, not x86_64. Installing and Using; --------------------. After the LLVM/Clang has built successfully, you should install it; via:. .. code-block:: bash. $ ninja install. which will create a sysroot on the install-dir. You can then tar; that directory into a binary with the full triple name (for easy; identification), like:. .. code-block:: bash. $ ln -sf <install-dir> arm-linux-gnueabihf-clang; $ tar zchf arm-linux-gnueabihf-clang.tar.gz arm-linux-gnueabihf-clang. If you copy that tarball to your target board, you'll be able to use; it for running the test-suite, for example. Follow the guidelines at; https://llvm.org/docs/lnt/quickstart.html, unpack the tarball in the; test directory, and use options:. .. code-block:: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst:6733,simpl,simply,6733,interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,1,['simpl'],['simply']
Usability,"u the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerful class `TGraphErrors` with different types of constructors. In; the example here, we use data from the file `ExampleData.txt` in text; format:. ``` {.cpp}; root [0] TGraphErrors gr(""ExampleData.txt"");; root [1] gr.Draw(""AP"");; ```. You should see the output shown in Figure [2.2](#f22). [f22]: figures/TGraphErrors_Example.png ""f22""; <a name=""f22""></a>. ![Visualisation of data points with errors using the class TGraphErrors. \label{f22}][f22]. Make sure the file `ExampleData.txt` is available in the directory from; which you started ROOT. Inspect this file now with your favourite; editor, or use the command `less ExampleData.txt` to inspect the file,; you will see that the format is very simple and easy to understand.; Lines beginning with `#` are ignored. It is very convenient to add some; comments about the type of data. The data itself consist of lines with; four real numbers each, representing the x- and y- coordinates and their; errors of each data point. The argument of the method `Draw(""AP"")` is important here. Behind the scenes,; it tells the `TGraphPainter` class to show the axes and to plot markers at the; *x* and *y* positions of the specified data points. Note that this simple; example relies on the default settings of ROOT, concerning the size of; the canvas holding the plot, the marker type and the line colours and; thickness used and so on. In a well-written, complete example, all this; would need to be specified explicitly in order to obtain nice and well; readable results. A full chapter on graphs will explain many; more of the features of the class `TGraphErrors` and its relation to; other ROOT classes in much more detail. ## Histogra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:9591,simpl,simple,9591,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['simpl'],['simple']
Usability,"uage features supported by LLVM; worked under MCJIT, and objects to be loaded under the JIT had to be compiled to; target it (precluding the use of precompiled code from other sources under the; JIT). RuntimeDyld also provided very limited visibility into the linking process; itself: Clients could access conservative estimates of section size; (RuntimeDyld bundled stub size and padding estimates into the section size; value) and the final relocated bytes, but could not access RuntimeDyld's; internal object representations. Eliminating these restrictions and limitations was one of the primary motivations; for the development of JITLink. The llvm-jitlink tool; =====================. The ``llvm-jitlink`` tool is a command line wrapper for the JITLink library.; It loads some set of relocatable object files and then links them using; JITLink. Depending on the options used it will then execute them, or validate; the linked memory. The ``llvm-jitlink`` tool was originally designed to aid JITLink development by; providing a simple environment for testing. Basic usage; -----------. By default, ``llvm-jitlink`` will link the set of objects passed on the command; line, then search for a ""main"" function and execute it:. .. code-block:: sh. % cat hello-world.c; #include <stdio.h>. int main(int argc, char *argv[]) {; printf(""hello, world!\n"");; return 0;; }. % clang -c -o hello-world.o hello-world.c; % llvm-jitlink hello-world.o; Hello, World!. Multiple objects may be specified, and arguments may be provided to the JIT'd; main function using the -args option:. .. code-block:: sh. % cat print-args.c; #include <stdio.h>. void print_args(int argc, char *argv[]) {; for (int i = 0; i != argc; ++i); printf(""arg %i is \""%s\""\n"", i, argv[i]);; }. % cat print-args-main.c; void print_args(int argc, char *argv[]);. int main(int argc, char *argv[]) {; print_args(argc, argv);; return 0;; }. % clang -c -o print-args.o print-args.c; % clang -c -o print-args-main.o print-args-main.c; % llvm-jitli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:37323,simpl,simple,37323,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['simpl'],['simple']
Usability,"uaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; ```. ## How to Find More Information. website The ROOT web site has up to date documentation. The ROOT; source code automatically generates this documentation, so each class; is explicitly documented on its own web page, which is always up to; date with the latest official release of ROOT. The ROOT Reference Guide web pages can be found at class index; reference guide <https://root.cern/doc/master/classes.html>. Each; page contains a class description, and an explanation of each method.; It shows the class inheritance tree and lets you jump to the parent; class page by clicking on the class name. If you want more details,; you can even see the source. There is a help page available in the; little box on the upper right hand side of each class documentation; page. You can see on the next page what a typical class documentation; web page looks like. The ROOT web site also contains in addition to; this Reference Guide, ""How To's"", a list of publications and example; applications. ### Class Reference Guide. The top of any class reference page lets you jump to different parts; of the documentation. The first line links to the class index and the; index for the current module (a group of classes, often a library).; The second line links to the ROOT homepage and the class overviews.; The third line links the source information - a HTML version of the; source and header file as well as the CVS (the source management; system used for the ROOT development) information of the files. The; last line links the different parts of the current pages. ![](pictures/03000006.png). ![Example of function documentation, with automatically generated LaTeX-like graphics](pictures/03000007.png). ![Inheritance tree, showing what the current class derives from, and which classes inherit from it](pictures/03000008.png). ![HTML version of the source file linking all types and most functions](pictures/03000009.png); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:25045,Guid,Guide,25045,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,2,['Guid'],['Guide']
Usability,uationRecordBuilder.h; llvm/include/llvm/DebugInfo/CodeView/CVRecord.h; llvm/include/llvm/DebugInfo/CodeView/CVSymbolVisitor.h; llvm/include/llvm/DebugInfo/CodeView/CVTypeVisitor.h; llvm/include/llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h; llvm/include/llvm/DebugInfo/CodeView/DebugCrossExSubsection.h; llvm/include/llvm/DebugInfo/CodeView/DebugCrossImpSubsection.h; llvm/include/llvm/DebugInfo/CodeView/DebugInlineeLinesSubsection.h; llvm/include/llvm/DebugInfo/CodeView/DebugLinesSubsection.h; llvm/include/llvm/DebugInfo/CodeView/DebugStringTableSubsection.h; llvm/include/llvm/DebugInfo/CodeView/DebugSubsection.h; llvm/include/llvm/DebugInfo/CodeView/DebugSubsectionRecord.h; llvm/include/llvm/DebugInfo/CodeView/DebugSubsectionVisitor.h; llvm/include/llvm/DebugInfo/CodeView/DebugSymbolRVASubsection.h; llvm/include/llvm/DebugInfo/CodeView/EnumTables.h; llvm/include/llvm/DebugInfo/CodeView/Formatters.h; llvm/include/llvm/DebugInfo/CodeView/GlobalTypeTableBuilder.h; llvm/include/llvm/DebugInfo/CodeView/GUID.h; llvm/include/llvm/DebugInfo/CodeView/LazyRandomTypeCollection.h; llvm/include/llvm/DebugInfo/CodeView/Line.h; llvm/include/llvm/DebugInfo/CodeView/MergingTypeTableBuilder.h; llvm/include/llvm/DebugInfo/CodeView/RecordName.h; llvm/include/llvm/DebugInfo/CodeView/SimpleTypeSerializer.h; llvm/include/llvm/DebugInfo/CodeView/StringsAndChecksums.h; llvm/include/llvm/DebugInfo/CodeView/SymbolDumpDelegate.h; llvm/include/llvm/DebugInfo/CodeView/SymbolDumper.h; llvm/include/llvm/DebugInfo/CodeView/SymbolRecordHelpers.h; llvm/include/llvm/DebugInfo/CodeView/SymbolSerializer.h; llvm/include/llvm/DebugInfo/CodeView/SymbolVisitorCallbackPipeline.h; llvm/include/llvm/DebugInfo/CodeView/SymbolVisitorCallbacks.h; llvm/include/llvm/DebugInfo/CodeView/SymbolVisitorDelegate.h; llvm/include/llvm/DebugInfo/CodeView/TypeDeserializer.h; llvm/include/llvm/DebugInfo/CodeView/TypeDumpVisitor.h; llvm/include/llvm/DebugInfo/CodeView/TypeRecordHelpers.h; llvm/include/llvm/DebugInfo/CodeVi,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:244067,GUID,GUID,244067,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['GUID'],['GUID']
Usability,"uations -- noise. The algorithm is based on smoothed; second differences that are compared to its standard deviations.; Therefore it is necessary to pass a parameter of sigma to the peak; searching function. The algorithm is selective to the peaks with a; given sigma. The form of the basic peak searching function is. ```{.cpp}; Int_t Search1(const float *spectrum,; int size,; double sigma);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into structure pointed by; `one_dim_peak` structure pointer. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`p`**: pointer to the `one_dim_peak` structure pointer; - **`size`**: length of the source spectrum; - **`sigma`**: sigma of searched peaks. The `one_dim_peak` structure has the form of. ```{.cpp}; struct one_dim_peak{; int number_of_peaks;; double position[MAX_NUMBER_OF_PEAKS1];; };; ```. An example of simple one-dimensional spectrum with identified peaks is; given in Figure 3.1. ![Simple one-dimensional spectrum with identified peaks](figures/image058.png). An example of 1-dimensional experimental spectrum with many identified; peaks is given in Figure 3.2. ![1-dimensional experimental spectrum with many identified peaks](figures/image060.png). However, when we have noisy data, the number of peaks can be enormous. One; such an example is given in Figure 3.3. ![With noisy data the number of peaks can be enormous](figures/image062.png). Therefore it can be useful to have a possibility to set a threshold value and to consider only the peaks higher than this threshold (see Figure 3.4, only three peaks were identified, threshold=50). The value in the center of the peak (`value[i]`) minus the average value in two symmetrically positioned channels (channels `i-3*sigma`, `i+3*sigma`) must be greater than threshold.; Otherwise the peak is ignored. ![Iwth threshold=50, only three peaks were identified](figures/image064.png",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:17647,simpl,simple,17647,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,"uch as; Intel's Sandylake), we do so now. To see which features and CPUs that LLVM knows about, we can use; ``llc``. For example, let's look at x86:. ::. $ llvm-as < /dev/null | llc -march=x86 -mattr=help; Available CPUs for this target:. amdfam10 - Select the amdfam10 processor.; athlon - Select the athlon processor.; athlon-4 - Select the athlon-4 processor.; ... Available features for this target:. 16bit-mode - 16-bit mode (i8086).; 32bit-mode - 32-bit mode (80386).; 3dnow - Enable 3DNow! instructions.; 3dnowa - Enable 3DNow! Athlon instructions.; ... For our example, we'll use the generic CPU without any additional feature or; target option. .. code-block:: c++. auto CPU = ""generic"";; auto Features = """";. TargetOptions opt;; auto TargetMachine = Target->createTargetMachine(TargetTriple, CPU, Features, opt, Reloc::PIC_);. Configuring the Module; ======================. We're now ready to configure our module, to specify the target and; data layout. This isn't strictly necessary, but the `frontend; performance guide <../../Frontend/PerformanceTips.html>`_ recommends; this. Optimizations benefit from knowing about the target and data; layout. .. code-block:: c++. TheModule->setDataLayout(TargetMachine->createDataLayout());; TheModule->setTargetTriple(TargetTriple);. Emit Object Code; ================. We're ready to emit object code! Let's define where we want to write; our file to:. .. code-block:: c++. auto Filename = ""output.o"";; std::error_code EC;; raw_fd_ostream dest(Filename, EC, sys::fs::OF_None);. if (EC) {; errs() << ""Could not open file: "" << EC.message();; return 1;; }. Finally, we define a pass that emits object code, then we run that; pass:. .. code-block:: c++. legacy::PassManager pass;; auto FileType = CodeGenFileType::ObjectFile;. if (TargetMachine->addPassesToEmitFile(pass, dest, nullptr, FileType)) {; errs() << ""TargetMachine can't emit a file of this type"";; return 1;; }. pass.run(*TheModule);; dest.flush();. Putting It All Together; ============",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst:3584,guid,guide,3584,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst,1,['guid'],['guide']
Usability,"uction; ----------------------------------------. This pass performs a strength reduction on array references inside loops that; have as one or more of their components the loop induction variable. This is; accomplished by creating a new value to hold the initial value of the array; access for the first iteration, and then creating a new GEP instruction in the; loop to increment the value by the appropriate amount. .. _passes-loop-rotate:. ``loop-rotate``: Rotate Loops; -----------------------------. A simple loop rotation transformation. A summary of it can be found in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. This pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize generated code. This pass obviously modifies the CFG, but updates loop information and; dominator information. ``loop-unroll``: Unroll loops; ----",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:26929,Simpl,Simplify,26929,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,2,"['Simpl', 'simpl']","['Simplify', 'simplify']"
Usability,"ude <stdio.h>; #include <sanitizer/coverage_interface.h>. // This callback is inserted by the compiler as a module constructor; // into every DSO. 'start' and 'stop' correspond to the; // beginning and end of the section with the guards for the entire; // binary (executable or DSO). The callback will be called at least; // once per DSO and may be called multiple times with the same parameters.; extern ""C"" void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,; uint32_t *stop) {; static uint64_t N; // Counter for the guards.; if (start == stop || *start) return; // Initialize only once.; printf(""INIT: %p %p\n"", start, stop);; for (uint32_t *x = start; x < stop; x++); *x = ++N; // Guards should start from 1.; }. // This callback is inserted by the compiler on every edge in the; // control flow (some optimizations apply).; // Typically, the compiler will emit the code like this:; // if(*guard); // __sanitizer_cov_trace_pc_guard(guard);; // But for large functions it will emit a simple call:; // __sanitizer_cov_trace_pc_guard(guard);; extern ""C"" void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {; if (!*guard) return; // Duplicate the guard check.; // If you set *guard to 0 this code will not be called again for this edge.; // Now you can get the PC and do whatever you want:; // store it somewhere or symbolize it and print right away.; // The values of `*guard` are as you set them in; // __sanitizer_cov_trace_pc_guard_init and so you can make them consecutive; // and use them to dereference an array or a bit vector.; void *PC = __builtin_return_address(0);; char PcDescr[1024];; // This function is a part of the sanitizer run-time.; // To use it, link with AddressSanitizer or other sanitizer.; __sanitizer_symbolize_pc(PC, ""%p %F %L"", PcDescr, sizeof(PcDescr));; printf(""guard: %p %x PC %s\n"", guard, *guard, PcDescr);; }. .. code-block:: c++. // trace-pc-guard-example.cc; void foo() { }; int main(int argc, char **argv) {; if (argc > 1) foo();; }. .. code-block:: cons",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:2431,simpl,simple,2431,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['simpl'],['simple']
Usability,"ude talks, organizers should end talks early if the; violations include harassment or violent threats. There may be talks where; other types of code of conduct violations occur and organizers should do ; their best to determine if a talk should be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2. :ref:`Acknowledge the report<Receiving a report>` within 24 hours. 3. :ref:`Discuss the incident report<Incident Response Assessment>`, gather; more information, and determine a :ref:`resolution<Resolutions>`. 4. During this process, the :ref:`reporter will be informed of the; resolution<Following Up With the Reportee>` and feedback is requested. This; feedback may or may not be used to re-evaluate the resolution. 5. Inform the reportee of the resolution. The reportee is provided options to; :ref:`appeal<Appeal Process>`. . 6. The :ref:`resolution<Resolutions>` is implemented. 7. All reports, data, notes, and resolutions are logged in a private location; (e.g., Google Drive or other database). The committee will never make public statements about a resolution and will; only publish :ref:`transparency reports<Transparency Reports>`. If a public; statement is necessary and requested by the committee, it will be given by the; LLVM Foundation Board of Directors. Report Acknowledgement; ======================. When a report is received, the committee will reply to the reporter to confirm; receipt within 24 hours of the incident being reported. . This acknowledgement will contain:. * Acknowledgement of the incident report; * Next steps of the committee for responding to the incident; * Reminder of confidentiality policy regarding the report and parties involved. All ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:3666,feedback,feedback,3666,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['feedback'],['feedback']
Usability,"uding the input ll/bc file), they are; given via the following flag:; `--test_args=<test_arguments>`; If unspecified, the test is run as given. It’s worth noting that the input file; would be passed as a parameter to the test, similar how `-compile-custom`; currently operates. ### Implementation; The tool would behave similar to CReduce’s functionality in that it would have a; list of passes that try to minimize the given test-case. We should be able to; modularize the tool’s behavior, as well as making it easier to maintain and; expand. The first version of this redesign would try to:. * Discard functions, instructions and metadata that don’t influence the; interesting-ness test; * Remove unused parameters from functions; * Eliminate unvisited conditional paths; * Rename variables to more regular ones (such as “a”, “b”, “c”, etc.). Once these passes are implemented, more meaningful reductions (such as type; reduction) would be added to the tool, to even further reduce IR. ## Background on historical bugpoint issues. ### Root Cause Analysis; Presently, bugpoint takes a long time to find the source problem in a given IR; file, mainly due to the fact that it tries to debug the input by running; various strategies to classify the bug, which in turn run multiple optimizer; and compilation passes over the input, taking up a lot of time. Furthermore,; when the IR crashes, it tries to reduce it by performing some sub-optimal; passes (e.g. a lot of unreachable blocks), and sometimes even fails to minimize; at all. ### ""Quirky"" Interface; Bugpoint’s current interface overwhelms and confuses the user, the help screen; alone ends up confusing rather providing guidance. And, not only are there; numerous features and options, but some of them also work in unexpected ways; and most of the time the user ends up using a custom script. Pruning and; simplifying the interface will be worth considering in order to make the tool; more useful in the general case and easier to maintain.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugpointRedesign.md:3674,guid,guidance,3674,interpreter/llvm-project/llvm/docs/BugpointRedesign.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugpointRedesign.md,2,"['guid', 'simpl']","['guidance', 'simplifying']"
Usability,"ue of the; pointer is set equal to. ``` {.cpp}; new Quad(1.,2.,-3.);; ```. `new`, despite its looks, is an operator and creates an object or; variable of the type that comes next, `Quad` in this case, on the; heap. Just as with stack objects it has to be initialized by calling; its constructor. The syntax requires that the argument list follows the; type. This one statement has brought two items into existence, one on; the heap and one on the stack. The heap object will live until the; delete operator is applied to it. There is no FORTRAN parallel to a heap object; variables either come; or go as control passes in and out of a function or subroutine, or,; like a COMMON block variables, live for the lifetime of the program.; However, most people in HEP who use FORTRAN will have experience of a; memory manager and the act of creating a bank is a good equivalent of; a heap object. For those who know systems like ZEBRA, it will come as; a relief to learn that objects do not move, C++ does not garbage; collect, so there is never a danger that a pointer to an object; becomes invalid for that reason. However, having created an object,; it is the user's responsibility to ensure that it is deleted when no; longer needed, or to pass that responsibility onto to some other; object. Failing to do that will result in a memory leak, one of the; most common and most hard-to-find C++ bugs. To send a message to an object via a pointer to it, you need to use; the ""`->`"" operator e.g.:. ``` {.cpp}; root[] my_objptr->Solve();; ```. Although we chose to call our pointer `my_objptr`, to emphasize that; it is a pointer, heap objects are so common in an object-oriented; program that pointer names rarely reflect the fact - you have to be; careful that you know if you are dealing with an object or its; pointer! Fortunately, the compiler won't tolerate an attempt to do; something like:. ``` {.cpp}; root[] my_objptr.Solve();; ```. As we have seen, heap objects; have to be accessed via pointers,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:10560,learn,learn,10560,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['learn'],['learn']
Usability,"ue.html>`_ and `User Class; <https://llvm.org/doxygen/classllvm_1_1User.html>`_, respectively, for more; information. .. _schanges_deletingGV:. Deleting GlobalVariables; ^^^^^^^^^^^^^^^^^^^^^^^^. Deleting a global variable from a module is just as easy as deleting an; Instruction. First, you must have a pointer to the global variable that you; wish to delete. You use this pointer to erase it from its parent, the module.; For example:. .. code-block:: c++. GlobalVariable *GV = .. ;. GV->eraseFromParent();. .. _threading:. Threads and LLVM; ================. This section describes the interaction of the LLVM APIs with multithreading,; both on the part of client applications, and in the JIT, in the hosted; application. Note that LLVM's support for multithreading is still relatively young. Up; through version 2.5, the execution of threaded hosted applications was; supported, but not threaded client access to the APIs. While this use case is; now supported, clients *must* adhere to the guidelines specified below to ensure; proper operation in multithreaded mode. Note that, on Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capable LLVM on a platform without a suitably modern system; compiler, consider compiling LLVM and LLVM-GCC in single-threaded mode, and; using the resultant compiler to build a copy of LLVM with multithreading; support. .. _shutdown:. Ending Execution with ``llvm_shutdown()``; -----------------------------------------. When you are done using the LLVM APIs, you should call ``llvm_shutdown()`` to; deallocate memory used for internal structures. .. _managedstatic:. Lazy Initialization with ``ManagedStatic``; ------------------------------------------. ``ManagedStatic`` is a utility class in LLVM used to implement static; initialization of static resources, such as the global type tables. In a; single-threaded environment, it implements a simple lazy initial",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:121320,guid,guidelines,121320,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['guid'],['guidelines']
Usability,"uffer into a string very easily with as_string():; print(""struct.char_buffer.as_string(): "", char_buffer.as_string()); ```; The output of this script with ROOT 6.32:; ```; struct.char_buffer : <cppyy.LowLevelView object at 0x74c7a2682fb0>; struct.char_buffer.as_string(): foo; ```. ### Deprecate the attribute pythonization of `TDirectory` in favor of item-getting syntax. The new recommended way to get objects from a `TFile` or any `TDirectory` in general is now via `__getitem__`:. ```python; tree = my_file[""my_tree""] # instead of my_file.my_tree; ```. This is more consistent with other Python collections (like dictionaries), makes sure that member functions can't be confused with branch names, and easily allows you to use string variables as keys. With the new dictionary-like syntax, you can also get objects with names that don't qualify as a Python variable. Here is a short demo:; ```python; import ROOT. with ROOT.TFile.Open(""my_file.root"", ""RECREATE"") as my_file:. # Populate the TFile with simple objects.; my_file.WriteObject(ROOT.std.string(""hello world""), ""my_string""); my_file.WriteObject(ROOT.vector[""int""]([1, 2, 3]), ""my vector""). print(my_file[""my_string""]) # new syntax; print(my_file.my_string) # old deprecated syntax. # With the dictionary syntax, you can also use names that don't qualify as; # a Python variable:; print(my_file[""my vector""]); # print(my_file.my vector) # the old syntax would not work here!; ```. The old pythonization with the `__getattr__` syntax still works, but emits a deprecation warning and will be removed from ROOT 6.34. ### Removal of Python 2 support. ROOT does no longer support Python 2. The minimum Python version necessary to use ROOT in a Python application is 3.8.; As a consequence, any reference to Python 2 in ROOT code was removed and certain configuration options are no longer; usable, e.g. * `root-config --python2-version`; * cmake -Dpyroot-python2. The cmake build system now looks for the standard `Python3` package and previo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:21840,simpl,simple,21840,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['simpl'],['simple']
Usability,"ughter. Of course, the gas has some container also, but let; us keeps it like that for the sake of simplicity. Since we did not; supply the third argument, the wire will be positioned with an identity; transformation inside the chamber. #### Overlapping Volumes. Positioning volumes that does not overlap their neighbors nor extrude; their container is sometimes quite strong constraint. Having a limited; set of geometric shapes might force sometimes overlaps. Since; overlapping is contradictory to containment, a point belonging to an; overlapping region will naturally belong to all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite shapes. What we have to do is to define as shapes the; inner and outer parts of the tubes (tubes having; `Rmin=0`,` Rmax=`inner/outer radius), then to make a composite:; - `C = (Tub1out+Tub2out)-(Tub1in+Tub2in)`; - On the other hand, if we have an EM calorimeter having a honeycomb; structure, Boolean combinations do not help anymore. Here the; problem is that we usually have a very large number of cells that; are naturally belonging to the same container. This result in a very; flat and slow structure for that particular container, which we; would very much want to avoid by introducing additional levels in; depth. We can describe the basic cell as a hexahedron that we can; represent by using a polygon primitive shape. Instead of putting one; by one all cells in the same container, we can define rows of such; elements, fitting in box-shaped containers. Then we can put; row-beside-row inside the container, making life much easier for its; navigatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:75804,simpl,simple,75804,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"uilds coroutine frame and outlines resume and destroy parts; into separate functions. CoroElide; ---------; The pass CoroElide examines if the inlined coroutine is eligible for heap; allocation elision optimization. If so, it replaces; `coro.begin` intrinsic with an address of a coroutine frame placed on its caller; and replaces `coro.alloc` and `coro.free` intrinsics with `false` and `null`; respectively to remove the deallocation code.; This pass also replaces `coro.resume` and `coro.destroy` intrinsics with direct; calls to resume and destroy functions for a particular coroutine where possible. CoroCleanup; -----------; This pass runs late to lower all coroutine related intrinsics not replaced by; earlier passes. Attributes; ==========. coro_only_destroy_when_complete; -------------------------------. When the coroutine are marked with coro_only_destroy_when_complete, it indicates; the coroutine must reach the final suspend point when it get destroyed. This attribute only works for switched-resume coroutines now. Metadata; ========. '``coro.outside.frame``' Metadata; ---------------------------------. ``coro.outside.frame`` metadata may be attached to an alloca instruction to; to signify that it shouldn't be promoted to the coroutine frame, useful for; filtering allocas out by the frontend when emitting internal control mechanisms.; Additionally, this metadata is only used as a flag, so the associated; node must be empty. .. code-block:: text. %__coro_gro = alloca %struct.GroType, align 1, !coro.outside.frame !0. ...; !0 = !{}. Areas Requiring Attention; =========================; #. When coro.suspend returns -1, the coroutine is suspended, and it's possible; that the coroutine has already been destroyed (hence the frame has been freed).; We cannot access anything on the frame on the suspend path.; However there is nothing that prevents the compiler from moving instructions; along that path (e.g. LICM), which can lead to use-after-free. At the moment; we disabled",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:57646,resume,resume,57646,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"uired by EVE).; Switched the icon and checkbox position in TGListTreeItem.; Added custom user control flags, with their getters and setters and three new signal methods (required by EVE). All these were implemented for better control of the TGListTree behavior.; ; fUserControlled is a flag to take over the control; fEventHandled is a flag to tell TGListTree that the current event has been processed by user.; ; MouseOver(TGListTreeItem *entry); MouseOver(TGListTreeItem *entry, UInt_t mask); Clicked(TGListTreeItem *entry, Int_t btn, UInt_t mask, Int_t x, Int_t y). The new DrawOutline() method draws a colored outline around a list tree item following the mouse position.; Implemented correct keyboard navigation.; Improvements for list trees containing a large number of items (i.e. one million). TGTab. Added a new signal method Removed(Int_t id) to notify when a tab was removed. TGListBox. Fixed flickering problem on Windows. TGDockableFrame. Introduced the fFixedSize option, to let user choose if the undocked frame may; be resized or not. Keep the (fixed) original docked frame size when undocked; (i.e. for menus and toolbars). TGShutter. Two helper methods added:; ; SetSelectedItem(const char *name) - switch to the shutter section 'name'.; EnableItem(const char *name, Bool_t on) - enable/disable the shutter section 'name' according to the value of the second parameter 'on'.; . TGFileDialog; The File Open/Close dialogs show the list of all available (mounted) drives on Windows. Modal Dialogs; On Windows, any modal dialog now stays on top of its parent (true modal mode). Context Menus; The context menu of ROOT classes can be created with hierarchical sub-menus, which are more convenient and offer better organization. This makes possible to access more class methods from the context menu (without having the menu becoming larger than the screen). The next is an example of the hierarchihal submenu structure shown below. void SetLevelOne(EPaletteType palette = pal3); // *MENU=",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v520/index.html:1856,undo,undocked,1856,gui/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v520/index.html,1,['undo'],['undocked']
Usability,"ular, this means that the code used for read rules (\#pragma read); can no longer access private member unless they have been mentioned as a; target of the rule.; - rootcling no longer considers a friend declaration to be a; declaration for the friended function. In particular this means that; rootcling may now issue:. ``` {.cpp}; Error: in this version of ROOT, the option '!' used in a linkdef file; implies the actual existence of customized operators.; The following declaration is now required:; TBuffer &operator<<(TBuffer &,const THit *);; ```. if the operator `<<` declaration is missing. To steer the parsing done during the execution of rootcling, a new; macro: *\_\_ROOTCLING\_\_* is now defined during the parsing. The macros; *\_\_CINT\_\_* and *\_\_MAKECINT\_\_* are defined only when looking for; `#pragma` statement. The genreflex executable is still available, it preserves the same command; line options as in version 5 and provides new ones. Old selection XML files; are transparently usable by the new implementation. On the other hand some; of the new functionalities can be hardly backported to version 5. See; genreflex help for all the details about commandline switches and selection; files. It is important to note that it is not anymore a python script; interfaced to GCCXML but rather a wrapper around rootcling. In order to specify the classes selection, three methods are available:. 1) Selection XML file. This file can be read by both genreflex and rootcling.; 2) LinkDef file. This file can be read by rootcling.; 3) Selection namespace (also called *dictselection*). Available both for; rootcling and genreflex. See the documentation of the; `ROOT::Meta::Selection` namespace for all the details. *Warning*. It is important to note that during the parsing of the header files,; rootcint no longer defines *\_\_CINT\_\_* and genreflex no longer defines; *\_\_GCCXML\_\_*. This means in particular that data members that were; made transient by hiding them from rootc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:7526,usab,usable,7526,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,1,['usab'],['usable']
Usability,"uld be able to express facts like ""when this region escapes, that metadata; symbol attached to it should also escape"". This sounds like an ultimate freedom,; with maximum stress on the checkers - still not too much stress when we have; smart data maps. I'm personally liking the approach (2) - it should be possible to avoid; performance overhead, and clarity seems nice. **Gabor:**. At this point, I am a bit wondering about two questions. * When should something belong to a checker and when should something belong to the engine?; Sometimes we model library aspects in the engine and model language constructs in checkers. * What is the checker programming model that we are aiming for? Maximum freedom or more easy checker development?. I think if we aim for maximum freedom, we do not need to worry about the; potential stress on checkers, and we can introduce abstractions to mitigate that; later on.; If we want to simplify the API, then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:5182,simpl,simplify,5182,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['simpl'],['simplify']
Usability,"uld be the same as the one passed to; ``--sysroot`` in the ""build-c-flags"". The ""test-c-flags"" need to include the target, architecture, gcc-toolchain,; sysroot and arm/thumb state. The additional cmake defines such as; ``CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN`` do not apply when building the tests. If; you have put all of these in ""build-c-flags"" then these can be repeated. If you; wish to use lld to link the tests then add ``""-fuse-ld=lld``. Once cmake has completed the tests can be built and run using; ``ninja check-builtins``. Troubleshooting; ===============. The cmake try compile stage fails; ---------------------------------; At an early stage cmake will attempt to compile and link a simple C program to; test if the toolchain is working. This stage can often fail at link time if the ``--sysroot=`` and; ``--gcc-toolchain=`` options are not passed to the compiler. Check the; ``CMAKE_C_FLAGS`` and ``CMAKE_C_COMPILER_TARGET`` flags. It can be useful to build a simple example outside of cmake with your toolchain; to make sure it is working. For example: ``clang --target=arm-linux-gnueabi -march=armv7a --gcc-toolchain=/path/to/gcc-toolchain --sysroot=/path/to/gcc-toolchain/arm-linux-gnueabihf/libc helloworld.c``. Clang uses the host header files; --------------------------------; On debian based systems it is possible to install multiarch support for; arm-linux-gnueabi and arm-linux-gnueabihf. In many cases clang can successfully; use this multiarch support when ``--gcc-toolchain=`` and ``--sysroot=`` are not supplied.; Unfortunately clang adds ``/usr/local/include`` before; ``/usr/include/arm-linux-gnueabihf`` leading to errors when compiling the hosts; header files. The multiarch support is not sufficient to build the builtins you will need to; use a separate arm-linux-gnueabihf toolchain. No target passed to clang; -------------------------; If clang is not given a target it will typically use the host target, this will; not understand the Arm assembly language file",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:6177,simpl,simple,6177,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['simpl'],['simple']
Usability,"ults. `std::map`; ----------. C++'s ``map`` is an associative container similar to Python's ``dict``,; albeit one that has stronger type constraints.; A ``map`` can be instantiated from a ``dict`` (and types can be inferred) or; from a collection of ``pair`` mappings. .. code-block:: python. >>> from cppyy.gbl.std import map; >>> m = map[str, int](*(""one"", 1), (""two"", 2))) # type explicit, from pairs; >>> print(m); { ""one"" => 1, ""two"" => 2 }; >>> m = map({1: ""one"", 2: ""two""}) # type implicit, from dict; >>> type(m); <class cppyy.gbl.std.map<int,std::string> at 0x12d068d60>; >>> print(m); { 1 => ""one"", 2 => ""two"" }; >>>. `std::string`; -------------. Python's `str` is a unicode type since Python3, whereas ``std::string`` is; single-byte char-based.; Having the two correctly interact therefore deserves it's own; :doc:`chapter <strings>`. `std::tuple`; ------------. C++ ``tuple`` is supported but it should be noted that its use, and in; particular instantiating (heavily overloaded) ``get<>`` functions for member; access is inefficient.; They are really only meant for use when you have to pass a ``tuple`` to C++; code; and if returned from a C++ function, it is easier to simply unpack them.; In all other cases, prefer Python's builtin ``tuple``.; Example usage:. .. code-block:: python. >>> from cppyy.gbl.std import make_tuple, get; >>> t = make_tuple(1, '2', 5.); >>> print(t); <cppyy.gbl.std.tuple<int,std::string,double> object at 0x12033ee70>; >>> len(t); 3; >>> get[0](t) # access with templated std::get<>; 1; >>> get[1](t); b'2'; >>> get[2](t); 5.0; >>> a, b, c = t # unpack through iteration; >>> print(a, b, c); 1 2 5.0; >>>. .. rubric:: Footnotes. .. [#f1] The meaning of ""temporary"" differs between Python and C++: in a statement such as ``func(std.vector[int]((1, 2, 3)))``, there is no temporary as far as Python is concerned, even as there clearly is in the case of a similar statement in C++. Thus that call will succeed even if ``func`` takes a non-const reference.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst:8710,simpl,simply,8710,bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,2,"['clear', 'simpl']","['clearly', 'simply']"
Usability,"ume families are; used is when we want that a volume positioned inside a container to; match one ore more container limits. Suppose we want to position the; same box inside 2 different volumes and we want the Z size to match the; one of each container:. ``` {.cpp}; TGeoVolume *container1 = gGeoManager->MakeBox(""C1"",imed,10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"",imed,10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"",jmed,3,3,-1);; container1->AddNode(pvol,1);; container2->AddNode(pvol,1);; ```. Note that the third parameter of `PVOL` is negative, which does not make; sense as half-length on Z. This is interpreted as: when positioned,; create a box replacing all invalid parameters with the corresponding; dimensions of the container. This is also internally handled by the; **`TGeoVolumeMulti`** class, which does not need to be instantiated by; users. #### Dividing Volumes. Volumes can be divided according a pattern. The simplest division can be; done along one axis that can be: `X,Y,Z,Phi,Rxy or Rxyz`. Let's take a; simple case: we would like to divide a box in N equal slices along X; coordinate, representing a new volume family. Supposing we already have; created the initial box, this can be done like:. ``` {.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; ```. Here `SLICEX` is the name of the new family representing all slices and; 1 is the slicing axis. The meaning of the axis index is the following:; for all volumes having shapes like `box`, `trd1`, `trd2`, `trap`,; `gtra `or` para - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:83858,simpl,simplest,83858,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simplest']
Usability,"ume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; loop:; %inc = add nsw i32 %n, 1; store i32 %inc, ptr %n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code needs to get executed for different suspend points,; a similar switch will be in the `f.destroy` function. .. note ::. Using suspend index in a coroutine state and having a switch in `f.resume` and; `f.destroy` is one of the possible implementation strategies. We explored; another option where a distinct `f.resume1`, `f.resume2`, etc. are created for; every suspend point, and instead of storing an index, the resume and destroy; function pointers are updated at every suspend. Early testing showed that the; current approach is easier on the optimizer than the latter so it is a; lowering strategy implemented at the moment. Distinct Save and Suspend; -------------------------. In the previous example, sett",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:19503,resume,resume,19503,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"un through the implementation of a simple language, showing; how fun and easy it can be. This tutorial will get you up and running; fast and show a concrete example of something that uses LLVM to generate; code. This tutorial introduces the simple ""Kaleidoscope"" language, building it; iteratively over the course of several chapters, showing how it is built; over time. This lets us cover a range of language design and LLVM-specific; ideas, showing and explaining the code for it all along the way,; and reduces the overwhelming amount of details up front. We strongly; encourage that you *work with this code* - make a copy and hack it up and; experiment. **Warning**: In order to focus on teaching compiler techniques and LLVM; specifically,; this tutorial does *not* show best practices in software engineering; principles. For example, the code uses global variables; pervasively, doesn't use; `visitors <http://en.wikipedia.org/wiki/Visitor_pattern>`_, etc... but; instead keeps things simple and focuses on the topics at hand. This tutorial is structured into chapters covering individual topics,; allowing you to skip ahead as you wish:. - `Chapter #1: Kaleidoscope language and Lexer <LangImpl01.html>`_ -; This shows where we are; going and the basic functionality that we want to build. A lexer; is also the first part of building a parser for a language, and we; use a simple C++ lexer which is easy to understand.; - `Chapter #2: Implementing a Parser and AST <LangImpl02.html>`_ -; With the lexer in place, we can talk about parsing techniques and; basic AST construction. This tutorial describes recursive descent; parsing and operator precedence parsing.; - `Chapter #3: Code generation to LLVM IR <LangImpl03.html>`_ - with; the AST ready, we show how easy it is to generate LLVM IR, and show; a simple way to incorporate LLVM into your project.; - `Chapter #4: Adding JIT and Optimizer Support <LangImpl04.html>`_ -; One great thing about LLVM is its support for JIT compilation, s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst:1457,simpl,simple,1457,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,1,['simpl'],['simple']
Usability,"un-mangled name, we just re-produce this mangling ourselves using our; ``Mangle`` member function object. This brings us to the end of Chapter 1 of Building a JIT. You now have a basic; but fully functioning JIT stack that you can use to take LLVM IR and make it; executable within the context of your JIT process. In the next chapter we'll; look at how to extend this JIT to produce better quality code, and in the; process take a deeper look at the ORC layer concept. `Next: Extending the KaleidoscopeJIT <BuildingAJIT2.html>`_. Full Code Listing; =================. Here is the complete code listing for our running example. To build this; example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../examples/Kaleidoscope/BuildingAJIT/Chapter1/KaleidoscopeJIT.h; :language: c++. .. [1] Actually we use a cut-down version of KaleidoscopeJIT that makes a; simplifying assumption: symbols cannot be re-defined. This will make it; impossible to re-define symbols in the REPL, but will make our symbol; lookup logic simpler. Re-introducing support for symbol redefinition is; left as an exercise for the reader. (The KaleidoscopeJIT.h used in the; original tutorials will be a helpful reference). .. [2] +-----------------------------+-----------------------------------------------+; | File | Reason for inclusion |; +=============================+===============================================+; | CompileUtils.h | Provides the SimpleCompiler class. |; +-----------------------------+-----------------------------------------------+; | Core.h | Core utilities such as ExecutionSession and |; | | JITDylib. |; +-----------------------------+-----------------------------------------------+; | ExecutionUtils.h | Provides the DynamicLibrarySearchGenerator |; | | class. |; +-----------------------------+--------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:13333,simpl,simplifying,13333,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['simpl'],['simplifying']
Usability,"unction that maps a ``MatchResult`` to a set; of edits, or fails. This signature supports a very general form of computation; over match results. Transformer provides a number of functions for working with; ``EditGenerator``\ s, most notably; `flatten <https://github.com/llvm/llvm-project/blob/1fabe6e51917bcd7a1242294069c682fe6dffa45/clang/include/clang/Tooling/Transformer/RewriteRule.h#L165-L167>`_; ``EditGenerator``\ s, like list flattening. For the full list, see the header file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. Rules; ^^^^^. We can also compose multiple *rules*, rather than just edits within a rule,; using ``applyFirst``: it composes a list of rules as an ordered choice, where; Transformer applies the first rule whose pattern matches, ignoring others in the; list that follow. If the matchers are independent then order doesn't matter. In; that case, ``applyFirst`` is simply joining the set of rules into one. The benefit of ``applyFirst`` is that, for some problems, it allows the user to; more concisely formulate later rules in the list, since their patterns need not; explicitly exclude the earlier patterns of the list. For example, consider a set; of rules that rewrite compound statements, where one rule handles the case of an; empty compound statement and the other handles non-empty compound statements.; With ``applyFirst``, these rules can be expressed compactly as:. .. code-block:: c++. applyFirst({; makeRule(compoundStmt(statementCountIs(0)).bind(""empty""), ...),; makeRule(compoundStmt().bind(""non-empty""),...); }). The second rule does not need to explicitly specify that the compound statement; is non-empty -- it follows from the rules position in ``applyFirst``. For more; complicated examples, this can lead to substantially more readable code. Sometimes, a modification to the code might require the inclusion of a; particular header file. To this en",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:15000,simpl,simply,15000,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['simpl'],['simply']
Usability,"unction writes to a readonly pointer argument, the behavior is; undefined. ``writeonly``; This attribute indicates that the function may write to, but does not read; through this pointer argument (even though it may read from the memory that; the pointer points to). If a function reads from a writeonly pointer argument, the behavior is; undefined. ``writable``; This attribute is only meaningful in conjunction with ``dereferenceable(N)``; or another attribute that implies the first ``N`` bytes of the pointer; argument are dereferenceable. In that case, the attribute indicates that the first ``N`` bytes will be; (non-atomically) loaded and stored back on entry to the function. This implies that it's possible to introduce spurious stores on entry to; the function without introducing traps or data races. This does not; necessarily hold throughout the whole function, as the pointer may escape; to a different thread during the execution of the function. See also the; :ref:`atomic optimization guide <Optimization outside atomic>`. The ""other attributes"" that imply dereferenceability are; ``dereferenceable_or_null`` (if the pointer is non-null) and the; ``sret``, ``byval``, ``byref``, ``inalloca``, ``preallocated`` family of; attributes. Note that not all of these combinations are useful, e.g.; ``byval`` arguments are known to be writable even without this attribute. The ``writable`` attribute cannot be combined with ``readnone``,; ``readonly`` or a ``memory`` attribute that does not contain; ``argmem: write``. ``dead_on_unwind``; At a high level, this attribute indicates that the pointer argument is dead; if the call unwinds, in the sense that the caller will not depend on the; contents of the memory. Stores that would only be visible on the unwind; path can be elided. More precisely, the behavior is as-if any memory written through the; pointer during the execution of the function is overwritten with a poison; value on unwind. This includes memory written by the implicit ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:70516,guid,guide,70516,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['guid'],['guide']
Usability,"unction);. return TheFunction;; }. Once the insertion point has been set up and the NamedValues map populated,; we call the ``codegen()`` method for the root expression of the function. If no; error happens, this emits code to compute the expression into the entry block; and returns the value that was computed. Assuming no error, we then create an; LLVM `ret instruction <../../LangRef.html#ret-instruction>`_, which completes the function.; Once the function is built, we call ``verifyFunction``, which is; provided by LLVM. This function does a variety of consistency checks on; the generated code, to determine if our compiler is doing everything; right. Using this is important: it can catch a lot of bugs. Once the; function is finished and validated, we return it. .. code-block:: c++. // Error reading body, remove function.; TheFunction->eraseFromParent();; return nullptr;; }. The only piece left here is handling of the error case. For simplicity,; we handle this by merely deleting the function we produced with the; ``eraseFromParent`` method. This allows the user to redefine a function; that they incorrectly typed in before: if we didn't delete it, it would; live in the symbol table, with a body, preventing future redefinition. This code does have a bug, though: If the ``FunctionAST::codegen()`` method; finds an existing IR Function, it does not validate its signature against the; definition's own prototype. This means that an earlier 'extern' declaration will; take precedence over the function definition's signature, which can cause; codegen to fail, for instance if the function arguments are named differently.; There are a number of ways to fix this bug, see what you can come up with! Here; is a testcase:. ::. extern foo(a); # ok, defines foo.; def foo(b) b; # Error: Unknown variable name. (decl using 'a' takes precedence). Driver Changes and Closing Thoughts; ===================================. For now, code generation to LLVM doesn't really get us much, except t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:16550,simpl,simplicity,16550,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simplicity']
Usability,"unctions()->FindObject(""palette"");; Int_t ci = palette->GetBinColor(20,15);; ; Then it is possible to retrieve the RGB components in the following way:; ; TColor *c = gROOT->GetColor(ci);; float x,y,z;; c->GetRGB(x,y,z);; . TFormula. Fixed a bug in TFormula::GetExprFormula. Now the correct formula is returned for expressions based on CINT type functions. TF1. Fixed a bug in the calculation of the integral of multi-dimensional interpreted functions. The method TF1::operator() (const double *x, const double *p) calls now TF1::InitArgs in the case of CINT functions.; Fixed a bug in using the TF1::GetMinimum(), TF1::GetMaximum(), TF1::GetMinimumX, TF1::GetMaximumX, TF1::GetX with default arguments. ; Fixed a bug when copying functions obtained from member functions of interpreted classes; . THStack. In THStack::Paint() replace; fHistogram->Paint(""axissame""); by; gPad->RedrawAxis(); in order to fix the bug described here:; https://savannah.cern.ch/bugs/?41423 .; The simple following macro was enough to show the problem:. {; TH1D h(""h"", ""h"", 10., 0., 1.); h.Fill(.5);; THStack s(""s"", ""s""); s.Add(&h);; TCanvas canvas(""canvas"");; frame = canvas.DrawFrame(-1., 0., 2., 2.);; frame.SetLabelSize(0.05, ""XY"");; frame.Draw(); s.Draw(""same"");; }. Make the data member fHistogram persistent in order to save the; axis attributes which may have been changed during a root session (like,; for instance, the axis titles).; When a THStack is drawn with the option ""pads"", the number of lines is; now optimized to make sure there is no empty line. . TUnfold. Introduces this new class for solving inverse problems:. data histograms with Gaussian errors are decomposed into; several template distributions (""generator level"" bins). The result are new normalisation constants for the template; distributions (the unfolded ""generator level"" distribution). The solution can be tuned by properly adjusting the; regularisation parameter tau. A standard method, the L-curve scan is; implemented to help finding ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:6778,simpl,simple,6778,hist/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html,1,['simpl'],['simple']
Usability,"unds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit properties from the parameter-declaration-clause of a constructor; Not resolved. 2715; DRWP; ""calling function"" for parameter initialization may not exist; Unknown. 2716; DRWP; Rule about self-or-base conversion is normatively redundant; Unknown. 2717; DRWP; Pack expansion for alignment-specifier; Unknown. 2718; DRWP; Type completeness for derived-to-base conversions; Unknown. 2719; DRWP; Creating objects in misaligned storage; Unknown. 2720; DRWP; Template validity rules for templated entities and alias templates; Unknown. 2721; DRWP; When exactly is storage reused?; Unknown. 2722; DRWP; Temporary materialization conversion for noexcept operator; Unknown. 2723; DRWP; Range of representable values for floating-point types; Unknown. 2724; DRWP; Clarify rounding for arithmetic right shift; Unknown. 2725; DR; Overload resolution for non-call of class member access; Unknown. 2726; review; Alternative tokens appearing as attribute-tokens; Not resolved. 2727; open; Importing header units synthesized from sour",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:187548,guid,guides,187548,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['guid'],['guides']
Usability,"unger_struct`` type, for; either the ``f1`` or ``f2`` field. So, in LLVM assembly the ``munge`` function; looks like:. .. code-block:: llvm. define void @munge(ptr %P) {; entry:; %tmp = getelementptr %struct.munger_struct, ptr %P, i32 1, i32 0; %tmp1 = load i32, ptr %tmp; %tmp2 = getelementptr %struct.munger_struct, ptr %P, i32 2, i32 1; %tmp3 = load i32, ptr %tmp2; %tmp4 = add i32 %tmp3, %tmp1; %tmp5 = getelementptr %struct.munger_struct, ptr %P, i32 0, i32 0; store i32 %tmp4, ptr %tmp5; ret void; }. In each case the second operand is the pointer through which the GEP instruction; starts. The same is true whether the second operand is an argument, allocated; memory, or a global variable. To make this clear, let's consider a more obtuse example:. .. code-block:: text. @MyVar = external global i32; ...; %idx1 = getelementptr i32, ptr @MyVar, i64 0; %idx2 = getelementptr i32, ptr @MyVar, i64 1; %idx3 = getelementptr i32, ptr @MyVar, i64 2. These GEP instructions are simply making address computations from the base; address of ``MyVar``. They compute, as follows (using C syntax):. .. code-block:: c++. idx1 = (char*) &MyVar + 0; idx2 = (char*) &MyVar + 4; idx3 = (char*) &MyVar + 8. Since the type ``i32`` is known to be four bytes long, the indices 0, 1 and 2; translate into memory offsets of 0, 4, and 8, respectively. No memory is; accessed to make these computations because the address of ``@MyVar`` is passed; directly to the GEP instructions. The obtuse part of this example is in the cases of ``%idx2`` and ``%idx3``. They; result in the computation of addresses that point to memory past the end of the; ``@MyVar`` global, which is only one ``i32`` long, not three ``i32``\s long.; While this is legal in LLVM, it is inadvisable because any load or store with; the pointer that results from these GEP instructions would trigger undefined; behavior (UB). Why is the extra 0 index required?; ----------------------------------. Quick answer: there are no superfluous indices. Thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:3974,simpl,simply,3974,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['simpl'],['simply']
Usability,"unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface of a function, and should thus be placed on the function definition; (in the ``.cc`` or ``.cpp`` file) rather than on the function declaration; (in the header). RETURN_CAPABILITY(c); --------------------. *Previously*: ``LOCK_RETURNED``. ``RETURN_CAPABILITY`` is an attribute on functions or methods, which declares; that the function returns a reference to the given capability. It is used to; annotate getter methods that return mutexes. .. code-block:: c++. class MyClass {; private:; Mutex mu;; int a GUARDED_BY(mu);. public:; Mutex* getMu() RETURN_CAPABILITY(mu) { return &mu; }. // analysis knows that getMu() == mu; void clear() REQUIRES(getMu()) { a = 0; }; };. ACQUIRED_BEFORE(...), ACQUIRED_AFTER(...); -----------------------------------------. ``ACQUIRED_BEFORE`` and ``ACQUIRED_AFTER`` are attributes on member; declarations, specifically declarations of mutexes or other capabilities.; These declarations enforce a particular order in which the mutexes must be; acquired, in order to prevent deadlock. .. code-block:: c++. Mutex m1;; Mutex m2 ACQUIRED_AFTER(m1);. // Alternative declaration; // Mutex m2;; // Mutex m1 ACQUIRED_BEFORE(m2);. void foo() {; m2.Lock();; m1.Lock(); // Warning! m2 must be acquired after m1.; m1.Unlock();; m2.Unlock();; }. CAPABILITY(<string>); --------------------. *Previously*: ``LOCKABLE``. ``CAPABILITY`` is an attribute on classes, which specifies that objects of the; class can be used as a capability. The string argument specifies the kind of; capability in error messages, e.g. ``""mutex""``. See the ``Container`` example; given above, or the ``Mutex`` class in :ref:`mutexhea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:12131,clear,clear,12131,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['clear'],['clear']
Usability,"unter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` in `coro_task`. Note that the; first initial suspend point is the compiler generated; `co_await promise_type::initial_suspend()`. However, when optimizations are enabled, the printed result changes drastically:. .. parsed-literal::. {__resume_fn = 0x401280 <coro_task(int)>, __destroy_fn = 0x401390 <coro_task(int)>, __promise = {count = 1}, __int_32_0 = 43, __coro_index = 1 '\001'}. Unused values are optimized out, as well as the name of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty clear that `__int_32_0` represents `a`. However, it; is not true. An important note with optimization is that the value of a variable may not; properly express the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-bl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:8710,simpl,simple,8710,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"untime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable interface so you don't need to change your code when the AST API; changes; * want high level abstractions like cursors and code completion out of the box; * do not want to write your tools in C++. :doc:`Clang tools <ClangTools>` are a collection of specific developer tools; built on top of the LibTooling infrastructure as part of the Clang project.; They are targeted at automating and improving core development activities of; C/C++ developers. Examples of tools we are building or planning as part of the Clang project:. * Syntax checking (:program:`clang-check`); * Automatic fixing of compile errors (:program:`clang-fixit`); * Auto",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:2298,simpl,simple,2298,interpreter/llvm-project/clang/docs/Tooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst,1,['simpl'],['simple']
Usability,"uperclasses were visited while copying their fields into the; record. Each pair consists of a pointer to the ``Record`` instance for a; superclass record and an instance of the ``SMRange`` class. The range; indicates the source file locations of the beginning and end of the class; definition. This example obtains the superclasses of the ``Prototype`` record and then; iterates over the pairs in the returned array. .. code-block:: text. ArrayRef<std::pair<Record *, SMRange>>; Superclasses = Prototype->getSuperClasses();; for (const auto &SuperPair : Superclasses) {; ...; }. The ``Record`` class also provides a function, ``getDirectSuperClasses``, to; append the *direct* superclasses of a record to a given vector of type; ``SmallVectorImpl<Record *>``. Emitting Text to the Output Stream; ==================================. The ``run`` function is passed a ``raw_ostream`` to which it prints the; output file. By convention, this stream is saved in the emitter class member; named ``OS``, although some ``run`` functions are simple and just use the; stream without saving it. The output can be produced by writing values; directly to the output stream, or by using the ``std::format()`` or; ``llvm::formatv()`` functions. .. code-block:: text. OS << ""#ifndef "" << NodeName << ""\n"";. OS << format(""0x%0*x, "", Digits, Value);. Instances of the following classes can be printed using the ``<<`` operator:; ``RecordKeeper``,; ``Record``,; ``RecTy``,; ``RecordVal``, and; ``Init``. The helper function ``emitSourceFileHeader()`` prints the header comment; that should be included at the top of every output file. A call to it is; included in the skeleton backend file ``TableGenBackendSkeleton.cpp``. Printing Error Messages; =======================. TableGen records are often derived from multiple classes and also often; defined through a sequence of multiclasses. Because of this, it can be; difficult for backends to report clear error messages with accurate source; file locations. To make e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:22839,simpl,simple,22839,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['simpl'],['simple']
Usability,"ur tension about; inserting such blatant inefficiencies :). After the rest of the optimizers run, we get:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %cmptmp = fcmp ult double %x, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp ueq double %booltmp, 0.000000e+00; br i1 %ifcond, label %else, label %ifcont. else:; %subtmp = fsub double %x, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %subtmp5 = fsub double %x, 2.000000e+00; %calltmp6 = call double @fib(double %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; ret double %addtmp. ifcont:; ret double 1.000000e+00; }. Here we see that the simplifycfg pass decided to clone the return; instruction into the end of the 'else' block. This allowed it to; eliminate some branches and the PHI node. Now that all symbol table references are updated to use stack variables,; we'll add the assignment operator. New Assignment Operator; =======================. With our current framework, adding a new assignment operator is really; simple. We will parse it just like any other binary operator, but handle; it internally (instead of allowing the user to define it). The first; step is to set a precedence:. .. code-block:: c++. int main() {; // Install standard binary operators.; // 1 is lowest precedence.; BinopPrecedence['='] = 2;; BinopPrecedence['<'] = 10;; BinopPrecedence['+'] = 20;; BinopPrecedence['-'] = 20;. Now that the parser knows the precedence of the binary operator, it; takes care of all the parsing and AST generation. We just need to; implement codegen for the assignment operator. This looks like:. .. code-block:: c++. Value *BinaryExprAST::codegen() {; // Special case '=' because we don't want to emit the LHS as an expression.; if (Op == '=') {; // This assume we're building without RTTI because LLVM builds that way by; // default. If you build LLVM with RTTI this can be changed to a; // dynamic_cast for automatic error checking.; VariableExprAST *LHSE = static_cast<Var",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:20194,simpl,simple,20194,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simple']
Usability,"urce file that ``#include``\s the header, creating; maintenance issues. In implementation files (e.g. ``.cpp`` files), the rule is more of a stylistic; rule, but is still important. Basically, using explicit namespace prefixes; makes the code **clearer**, because it is immediately obvious what facilities; are being used and where they are coming from. And **more portable**, because; namespace clashes cannot occur between LLVM code and other namespaces. The; portability rule is important because different standard library implementations; expose different symbols (potentially ones they shouldn't), and future revisions; to the C++ standard will add more symbols to the ``std`` namespace. As such, we; never use ``'using namespace std;'`` in LLVM. The exception to the general rule (i.e. it's not an exception for the ``std``; namespace) is for implementation files. For example, all of the code in the; LLVM project implements code that lives in the 'llvm' namespace. As such, it is; ok, and actually clearer, for the ``.cpp`` files to have a ``'using namespace; llvm;'`` directive at the top, after the ``#include``\s. This reduces; indentation in the body of the file for source editors that indent based on; braces, and keeps the conceptual context cleaner. The general form of this rule; is that any ``.cpp`` file that implements code in any namespace may use that; namespace (and its parents'), but should not use any others. Provide a Virtual Method Anchor for Classes in Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If a class is defined in a header file and has a vtable (either it has virtual; methods or it derives from classes with virtual methods), it must always have at; least one out-of-line virtual method in the class. Without this, the compiler; will copy the vtable and RTTI into every ``.o`` file that ``#include``\s the; header, bloating ``.o`` file sizes and increasing link times. Don't use default labels in fully covered switches over enumerations; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:50094,clear,clearer,50094,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['clear'],['clearer']
Usability,"urce ranges, and the caret.; However, this behavior isn't required. Another implementation of the ``DiagnosticConsumer`` interface is the; ``TextDiagnosticBuffer`` class, which is used when Clang is in ``-verify``; mode. Instead of formatting and printing out the diagnostics, this; implementation just captures and remembers the diagnostics as they fly by.; Then ``-verify`` compares the list of produced diagnostics to the list of; expected ones. If they disagree, it prints out its own output. Full; documentation for the ``-verify`` mode can be found at; :ref:`verifying-diagnostics`. There are many other possible implementations of this interface, and this is; why we prefer diagnostics to pass down rich structured information in; arguments. For example, an HTML output might want declaration names be; linkified to where they come from in the source. Another example is that a GUI; might let you click on typedefs to expand them. This application would want to; pass significantly more information about types through to the GUI than a; simple flat string. The interface allows this to happen. .. _internals-diag-translation:. Adding Translations to Clang; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Not possible yet! Diagnostic strings should be written in UTF-8, the client can; translate to the relevant code page if needed. Each translation completely; replaces the format string for the diagnostic. .. _SourceLocation:; .. _SourceManager:. The ``SourceLocation`` and ``SourceManager`` classes; ----------------------------------------------------. Strangely enough, the ``SourceLocation`` class represents a location within the; source code of the program. Important design points include:. #. ``sizeof(SourceLocation)`` must be extremely small, as these are embedded; into many AST nodes and are passed around often. Currently it is 32 bits.; #. ``SourceLocation`` must be a simple value object that can be efficiently; copied.; #. We should be able to represent a source location for any byte of any",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:22675,simpl,simple,22675,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"ure tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because users are then forced to test; what compiler version is in use to get a more accurate answer. The status reported by the feature test macro should always be reflected in the; language support page for the corresponding feature (`C++; <https://clang.llvm.org/cxx_status.html>`_, `C; <https://clang.llvm.org/c_status.html>`_) if applicable. This page can give; more nuanced information to the user as well, such as claiming partial support; for a feature and specifying details as to what remains to be done.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:164088,feedback,feedback,164088,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['feedback'],['feedback']
Usability,"ure. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:34843,Simpl,Simple,34843,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['Simpl'],['Simple']
Usability,"urn 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no idea how to support them! It works; as follows:. - To create a **`TIter`** object its constructor must be passed an; object that inherits from **`TCollection`**. The **`TIter`**; constructor calls the `MakeIterator()` method of this collection to; get the appropriate iterator object that inherits from; **`TIterator`**. - The `Next()` and `Reset()` methods of **`TIter`** simply call the; `Next()` and `Reset()` methods of the iterator object. Therefore, **`TIter`** simply acts as a wrapper for an object of a; concrete class inheriting from **`TIterator`**. To see this working in practice, consider the **`TObjArray`**; collection. Its associated iterator is **`TObjArrayIter`**. Suppose; `myarray` is a pointer to a **`TObjArray`** that contains `MyClass`; objects, i.e. ``` {.cpp}; TObjArray *myarray;; ```. To create a **`TIter`** object called `myiter`:. ``` {.cpp}; TIter myiter(myarray);; ```. ![](pictures/020001A4.jpg). As shown in the diagram, this results in several methods being called:. - The **`TIter`** constructor is passed a **`TObjArray`**. - **`TIter`** asks embedded **`TCollection`** to make an iterator. - **`TCollection`** asks **`TObjArray`** to make an iterator. - **`TObjArray`** returns a **`TObjArrayIter`**. Now define a pointer for `MyClass` objects and set it to each member of; the **`TObjArray`**:. ``` {.cpp}; MyClass *myobject;; while ((myobject = (MyClass *)myiter.Next())) {; // process myobject; }; ```. The heart of this is the `myiter.Next()` expression whic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:11210,simpl,simply,11210,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['simpl'],['simply']
Usability,"urpose of these; groups is to give vendors early notice that potentially disruptive changes; are being considered but have not yet been accepted. Vendors can give early; testing feedback on the changes to alert us to unacceptable breakages. The; current list of vendor groups is:. * `Clang vendors <https://reviews.llvm.org/project/members/113/>`_; * `libc++ vendors <https://reviews.llvm.org/project/members/109/>`_. People interested in joining the vendors group can do so by clicking the; ""Join Project"" link on the vendor's ""Members"" page in Phabricator. * When committing the change to the repository, add appropriate information; about the potentially breaking changes to the ``Potentially Breaking Changes``; section of the project's release notes. The release note should have; information about what the change is, what is potentially disruptive about; it, as well as any code examples, links, and motivation that is appropriate; to share with users. This helps users to learn about potential issues with; upgrading to that release. * After the change has been committed to the repository, the potentially; disruptive changes described in the release notes should be posted to the; `Announcements <https://discourse.llvm.org/c/announce/>`_ channel on; Discourse. The post should be tagged with the ``potentially-breaking`` label; and a label specific to the project (such as ``clang``, ``llvm``, etc). This; is another mechanism by which we can give pre-release notice to users about; potentially disruptive changes. It is a lower-traffic alternative to the; joining ""vendors"" group. To automatically be notified of new announcements; with the ``potentially-breaking`` label, go to your user preferences page in; Discourse, and add the label to one of the watch categories under; ``Notifications->Tags``. .. _code owners:. Code Owners; -----------. The LLVM Project relies on two features of its process to maintain rapid; development in addition to the high quality of its source base: the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:6837,learn,learn,6837,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['learn'],['learn']
Usability,"use ICM, STCM, or CLM. --. We don't use ADD (LOGICAL) HIGH, SUBTRACT (LOGICAL) HIGH,; or COMPARE (LOGICAL) HIGH yet. --. DAGCombiner doesn't yet fold truncations of extended loads. Functions like:. unsigned long f (unsigned long x, unsigned short *y); {; return (x << 32) | *y;; }. therefore end up as:. sllg %r2, %r2, 32; llgh %r0, 0(%r3); lr %r2, %r0; br %r14. but truncating the load would give:. sllg %r2, %r2, 32; lh %r2, 0(%r3); br %r14. --. Functions like:. define i64 @f1(i64 %a) {; %and = and i64 %a, 1; ret i64 %and; }. ought to be implemented as:. lhi %r0, 1; ngr %r2, %r0; br %r14. but two-address optimizations reverse the order of the AND and force:. lhi %r0, 1; ngr %r0, %r2; lgr %r2, %r0; br %r14. CodeGen/SystemZ/and-04.ll has several examples of this. --. Out-of-range displacements are usually handled by loading the full; address into a register. In many cases it would be better to create; an anchor point instead. E.g. for:. define void @f4a(i128 *%aptr, i64 %base) {; %addr = add i64 %base, 524288; %bptr = inttoptr i64 %addr to i128 *; %a = load volatile i128 *%aptr; %b = load i128 *%bptr; %add = add i128 %a, %b; store i128 %add, i128 *%aptr; ret void; }. (from CodeGen/SystemZ/int-add-08.ll) we load %base+524288 and %base+524296; into separate registers, rather than using %base+524288 as a base for both. --. Dynamic stack allocations round the size to 8 bytes and then allocate; that rounded amount. It would be simpler to subtract the unrounded; size from the copy of the stack pointer and then align the result.; See CodeGen/SystemZ/alloca-01.ll for an example. --. If needed, we can support 16-byte atomics using LPQ, STPQ and CSDG. --. We might want to model all access registers and use them to spill; 32-bit values. --. We might want to use the 'overflow' condition of eg. AR to support; llvm.sadd.with.overflow.i32 and related instructions - the generated code; for signed overflow check is currently quite bad. This would improve; the results of using -ftrapv.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt:3297,simpl,simpler,3297,interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt,1,['simpl'],['simpler']
Usability,"use button near to the; left/right (top/bottom) edges of the slider. To change both values; simultaneously press the mouse button near to the slider center. To; change pointer value press the mouse on the pointer and drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHProgressBar`**, and; **`TGHProgressBar`**. ``` {.cpp}; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:88206,progress bar,progress bar,88206,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['progress bar'],['progress bar']
Usability,"using ``fork-exec``, not just ``fork``). The top libFuzzer process will not do any fuzzing itself, but will; spawn up to ``N`` concurrent child processes providing them; small random subsets of the corpus. After a child exits, the top process; merges the corpus generated by the child back to the main corpus. Related flags:. ``-ignore_ooms``; True by default. If an OOM happens during fuzzing in one of the child processes,; the reproducer is saved on disk, and fuzzing continues.; ``-ignore_timeouts``; True by default, same as ``-ignore_ooms``, but for timeouts.; ``-ignore_crashes``; False by default, same as ``-ignore_ooms``, but for all other crashes. The plan is to eventually replace ``-jobs=N`` and ``-workers=N`` with ``-fork=N``. Resuming merge; --------------. Merging large corpora may be time consuming, and it is often desirable to do it; on preemptable VMs, where the process may be killed at any time.; In order to seamlessly resume the merge, use the ``-merge_control_file`` flag; and use ``killall -SIGUSR1 /path/to/fuzzer/binary`` to stop the merge gracefully. Example:. .. code-block:: console. % rm -f SomeLocalPath; % ./my_fuzzer CORPUS1 CORPUS2 -merge=1 -merge_control_file=SomeLocalPath; ...; MERGE-INNER: using the control file 'SomeLocalPath'; ...; # While this is running, do `killall -SIGUSR1 my_fuzzer` in another console; ==9015== INFO: libFuzzer: exiting as requested. # This will leave the file SomeLocalPath with the partial state of the merge.; # Now, you can continue the merge by executing the same command. The merge; # will continue from where it has been interrupted.; % ./my_fuzzer CORPUS1 CORPUS2 -merge=1 -merge_control_file=SomeLocalPath; ...; MERGE-OUTER: non-empty control file provided: 'SomeLocalPath'; MERGE-OUTER: control file ok, 32 files total, first not processed file 20; ... Options; =======. To run the fuzzer, pass zero or more corpus directories as command line; arguments. The fuzzer will read test inputs from each of these corpus; directo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:8496,resume,resume,8496,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['resume'],['resume']
Usability,"using a different coordinate; system, or even an object from a different package as long as it implements the required signatures.; One such vector type is CLHEP's `Hep3Vector`:. ~~~{.cpp}; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::Hep3Vector q(1,2,3);; XYZVector v3(q); ~~~. ### Arithmetic Operations. The following operations are possible between vector classes, even of different; coordinate system types:. ~~~{.cpp}; v1 += v2;; v1 -= v2;; v1 = - v2;; v1 *= a;; v1 /= a;; v2 = a * v1;; v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; ~~~. Note that the multiplication between two vectors using the `operator *` is not supported; because it is ambiguous. ### Other Methods. The vector classes support methods for:. - computation of the dot product via Dot(),; - computation of the cross product via Cross(),; - construction of a unit vector via Unit(). \anchor GenVectorTransformations; ## Transformations. The transformations are modeled using simple (non-template) classes, using `double` as; the scalar type to avoid too large numerical errors. The transformations are grouped; in Rotations (in 3 dimensions), Lorentz transformations. Each group has several members which may; model physically equivalent transformations but with different internal representations.; Transformation classes can operate on all type of vectors using the `operator()`; or the `operator *` and the transformations can also be combined via the `operator *`.; In more detail the transformations available are:. ### 3D Rotations. * ROOT::Math::Rotation3D, rotation described by a 3x3 matrix of doubles; * ROOT::Math::EulerAngles rotation described by the three Euler angles (phi, theta and psi) following the GoldStein [definition](http://mathworld.wolfram.com/EulerAngles.html).; * ROOT::Math::RotationZYX rotation described by three angles defining a rotation first along the Z axis, then along the rotated Y' axis and then along the rotated X'' axis.; * ROOT::Math::AxisAngle, rotation described",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/doc/index.md:7471,simpl,simple,7471,math/genvector/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/doc/index.md,1,['simpl'],['simple']
Usability,"usion with the first index usually arises from thinking about the; GetElementPtr instruction as if it was a C index operator. They aren't the; same. For example, when we write, in ""C"":. .. code-block:: c++. AType *Foo;; ...; X = &Foo->F;. it is natural to think that there is only one index, the selection of the field; ``F``. However, in this example, ``Foo`` is a pointer. That pointer; must be indexed explicitly in LLVM. C, on the other hand, indices through it; transparently. To arrive at the same address location as the C code, you would; provide the GEP instruction with two index operands. The first operand indexes; through the pointer; the second operand indexes the field ``F`` of the; structure, just as if you wrote:. .. code-block:: c++. X = &Foo[0].F;. Sometimes this question gets rephrased as:. .. _GEP index through first pointer:. *Why is it okay to index through the first pointer, but subsequent pointers; won't be dereferenced?*. The answer is simply because memory does not have to be accessed to perform the; computation. The second operand to the GEP instruction must be a value of a; pointer type. The value of the pointer is provided directly to the GEP; instruction as an operand without any need for accessing memory. It must,; therefore be indexed and requires an index operand. Consider this example:. .. code-block:: c++. struct munger_struct {; int f1;; int f2;; };; void munge(struct munger_struct *P) {; P[0].f1 = P[1].f1 + P[2].f2;; }; ...; struct munger_struct Array[3];; ...; munge(Array);. In this ""C"" example, the front end compiler (Clang) will generate three GEP; instructions for the three indices through ""P"" in the assignment statement. The; function argument ``P`` will be the second operand of each of these GEP; instructions. The third operand indexes through that pointer. The fourth; operand will be the field offset into the ``struct munger_struct`` type, for; either the ``f1`` or ``f2`` field. So, in LLVM assembly the ``munge`` function; looks ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:2075,simpl,simply,2075,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['simpl'],['simply']
Usability,"uspend index in a coroutine state and having a switch in `f.resume` and; `f.destroy` is one of the possible implementation strategies. We explored; another option where a distinct `f.resume1`, `f.resume2`, etc. are created for; every suspend point, and instead of storing an index, the resume and destroy; function pointers are updated at every suspend. Early testing showed that the; current approach is easier on the optimizer than the latter so it is a; lowering strategy implemented at the moment. Distinct Save and Suspend; -------------------------. In the previous example, setting a resume index (or some other state change that; needs to happen to prepare a coroutine for resumption) happens at the same time as; a suspension of a coroutine. However, in certain cases, it is necessary to control; when coroutine is prepared for resumption and when it is suspended. In the following example, a coroutine represents some activity that is driven; by completions of asynchronous operations `async_op1` and `async_op2` which get; a coroutine handle as a parameter and resume the coroutine once async; operation is finished. .. code-block:: text. void g() {; for (;;); if (cond()) {; async_op1(<coroutine-handle>); // will resume once async_op1 completes; <suspend>; do_one();; }; else {; async_op2(<coroutine-handle>); // will resume once async_op2 completes; <suspend>; do_two();; }; }; }. In this case, coroutine should be ready for resumption prior to a call to; `async_op1` and `async_op2`. The `coro.save`_ intrinsic is used to indicate a; point when coroutine should be ready for resumption (namely, when a resume index; should be stored in the coroutine frame, so that it can be resumed at the; correct resume point):. .. code-block:: llvm. if.true:; %save1 = call token @llvm.coro.save(ptr %hdl); call void @async_op1(ptr %hdl); %suspend1 = call i1 @llvm.coro.suspend(token %save1, i1 false); switch i8 %suspend1, label %suspend [i8 0, label %resume1; i8 1, label %cleanup]; if.false:; %s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:21059,resume,resume,21059,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"uspended. LLVM currently supports two styles of coroutine lowering. These styles; support substantially different sets of features, have substantially; different ABIs, and expect substantially different patterns of frontend; code generation. However, the styles also have a great deal in common. In all cases, an LLVM coroutine is initially represented as an ordinary LLVM; function that has calls to `coroutine intrinsics`_ defining the structure of; the coroutine. The coroutine function is then, in the most general case,; rewritten by the coroutine lowering passes to become the ""ramp function"",; the initial entrypoint of the coroutine, which executes until a suspend point; is first reached. The remainder of the original coroutine function is split; out into some number of ""resume functions"". Any state which must persist; across suspensions is stored in the coroutine frame. The resume functions; must somehow be able to handle either a ""normal"" resumption, which continues; the normal execution of the coroutine, or an ""abnormal"" resumption, which; must unwind the coroutine without attempting to suspend it. Switched-Resume Lowering; ------------------------. In LLVM's standard switched-resume lowering, signaled by the use of; `llvm.coro.id`, the coroutine frame is stored as part of a ""coroutine; object"" which represents a handle to a particular invocation of the; coroutine. All coroutine objects support a common ABI allowing certain; features to be used without knowing anything about the coroutine's; implementation:. - A coroutine object can be queried to see if it has reached completion; with `llvm.coro.done`. - A coroutine object can be resumed normally if it has not already reached; completion with `llvm.coro.resume`. - A coroutine object can be destroyed, invalidating the coroutine object,; with `llvm.coro.destroy`. This must be done separately even if the; coroutine has reached completion normally. - ""Promise"" storage, which is known to have a certain size and alignme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:2309,resume,resume,2309,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ussian function and; attaches the copy to the histogram. When the histogram is deleted, the; copy is deleted also. When a pad is deleted or cleared, all objects in the pad with the; `kCanDelete` bit set are deleted automatically. Currently the objects; created by the `DrawCopy` methods, have the `kCanDelete` bit set and; are therefore owned by the pad. ## Ownership by the User. The user owns all objects not described in one of the above cases.; **`TObject`** has two bits, `kCanDelete` and `kMustCleanup`, that; influence how an object is managed (in `TObject::fBits)`. These are in; an enumeration in `TObject.h.` To set these bits do:. ``` {.cpp}; MyObject->SetBit(kCanDelete); MyObject->SetBit(kMustCleanup); ```. The bits can be reset and tested with the `TObject::ResetBit` and; **`TObject::TestBit` methods.**. ### The kCanDelete Bit. The ***`gROOT`*** collections (see above) own their members and will; delete them regardless of the `kCanDelete` bit. In all other; collections, when the collection `Clear` method is called (i.e.; **`TList::Clear())`**, members with the `kCanDelete` bit set, are; deleted and removed from the collection. If the `kCanDelete` bit is; not set, the object is only removed from the collection but not; deleted. If a collection `Delete` (`TList::Delete()`) method is called, all; objects in the collection are deleted without considering the; `kCanDelete` bit. It is important to realize that deleting the; collection (i.e. delete `MyCollection`), DOES NOT delete the members; of the collection. If the user specified `MyCollection->SetOwner()` the collection owns; the objects and delete `MyCollection` will delete all its members.; Otherwise, you need to:. ``` {.cpp}; // delete all member objects in the collection; MyCollection->Delete();. // and delete the collection object; delete MyCollection;; ```. Note that `kCanDelete` is automatically set by the `DrawCopy` method; and the user can set it for any object. For example, the user must; manage all gra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md:5814,Clear,Clear,5814,documentation/users-guide/ObjectOwnership.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md,1,['Clear'],['Clear']
Usability,"ut INFINITY macro; N2848; Unknown. Require exact-width integer type interfaces; N2872; Yes. @, $, and ‘ in the source/execution character set; N2701; Yes. Quantum exponent of NaN (version 2); N2754; Unknown. The noreturn attribute; N2764; Clang 15. *_HAS_SUBNORM==0 implies what?; N2797; Yes. Disambiguate the storage class of some compound literals; N2819; Unknown. Add annotations for unreachable control flow v2; N2826; Clang 17. Unicode Sequences More Than 21 Bits are a Constraint Violation r0; N2828; Clang 3.6. Identifier Syntax using Unicode Standard Annex 31; N2836; Clang 15. No function declarators without prototypes; N2841; Clang 15. Remove default argument promotions for _FloatN types; N2844; No. Revised Suggestions of Change for Numerically Equal/Equivalent; N2847; Yes. 5.2.4.2.2 Cleanup, Again Again (N2806 update); N2879; Yes. char8_t: A type for UTF-8 characters and strings; N2653; No. Clarification for max exponent macros-update; N2882; Unknown. Consistent, Warningless, and Intuitive Initialization with {}. ; N2900; Clang 17. ; N3011; Clang 17. Not-so-magic: typeof. ; N2927; Clang 16. ; N2930; Clang 16. Type annex tgmath narrowing macros with integer args v2; N2931; Unknown. Revise spelling of keywords v7; N2934; Clang 17. Make false and true first-class language features v8; N2935; Clang 15. Properly define blocks as part of the grammar v3; N2937; Yes. Annex X (replacing Annex H) for IEC 60559 interchange; N2601; No. Indeterminate Values and Trap Representations; N2861; Yes. Remove ATOMIC_VAR_INIT v2; N2886; Clang 17. Require exact-width integer type interfaces v2; N2888; Yes. Wording Change for Variably-Modified Types; N2992; Yes. Identifier syntax fixes; N2939; Clang 15. Remove trigraphs??!; N2940; Clang 18. Improved normal enumerations; N3029; Unknown. Relax requirements for va_start; N2975; Clang 16. Enhanced enumerations; N3030; Unknown. Freestanding C and IEC 60559 conformance scope reduction; N2951; Unknown. Unsequenced functions; N2956; No. Comma o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:11906,Intuit,Intuitive,11906,interpreter/llvm-project/clang/www/c_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html,1,['Intuit'],['Intuitive']
Usability,"ut function type. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). TrainingMethod No BP BP, GA, BFGS Train with Back-Propagation (BP), BFGS Algorithm (BFGS), or Genetic Algorithm (GA - slower and worse). LearningRate No 0.02 − ANN learning rate parameter. DecayRate No 0.01 − Decay rate for learning parameter. TestRate No 10 − Test for overtraining performed at each #th epochs. EpochMonitoring No False − Provide epoch-wise monitoring plots according to TestRate (caution: causes big ROOT output file!). Sampling No 1 − Only 'Sampling' (randomly selected) events are trained each epoch. SamplingEpoch No 1 − Sampling is used for the first 'SamplingEpoch' epochs, afterwards, all events are taken for training. SamplingImportance No 1 − The sampling weights of events in epochs which successful (worse estimator than before) are multiplied with SamplingImportance, else they are divided. SamplingTraining No True − The training sample is sampled. SamplingTesting No False − The testing sample is sampled. ResetStep No 50 − How often BFGS should reset history. Tau No 3 − LineSearch size step. BPMode No sequential sequential, batch Back-propagation learning mode: sequential or batch. BatchSize No -1 − Batch size: number of events/batch,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:22420,learn,learning,22420,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['learn'],['learning']
Usability,"ut), then the ""``&``""; modifier must be used (e.g. ""``=&r``"") to specify that the output is an; ""early-clobber"" output. Marking an output as ""early-clobber"" ensures that LLVM; will not use the same register for any inputs (other than an input tied to this; output). Input constraints; """""""""""""""""""""""""""""""""". Input constraints do not have a prefix -- just the constraint codes. Each input; constraint will consume one argument from the call instruction. It is not; permitted for the asm to write to any input register or memory location (unless; that input is tied to an output). Note also that multiple inputs may all be; assigned to the same register, if LLVM can determine that they necessarily all; contain the same value. Instead of providing a Constraint Code, input constraints may also ""tie""; themselves to an output constraint, by providing an integer as the constraint; string. Tied inputs still consume an argument from the call instruction, and; take up a position in the asm template numbering as is usual -- they will simply; be constrained to always use the same register as the output they've been tied; to. For example, a constraint string of ""``=r,0``"" says to assign a register for; output, and use that register as an input as well (it being the 0'th; constraint). It is permitted to tie an input to an ""early-clobber"" output. In that case, no; *other* input may share the same register as the input tied to the early-clobber; (even when the other input has the same value). You may only tie an input to an output which has a register constraint, not a; memory constraint. Only a single input may be tied to an output. There is also an ""interesting"" feature which deserves a bit of explanation: if a; register class constraint allocates a register which is too small for the value; type operand provided as input, the input value will be split into multiple; registers, and all of them passed to the inline asm. However, this feature is often not as useful as you might think. Firstly,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:213556,simpl,simply,213556,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"ut; some strictures on the Python side, requiring careful use of types.; However, an easily fixable error is preferable over an implicitly wrong; result.; Note the type of the init argument in the call resulting in an (attempted); implicit instantiation in the following example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... template<class T>; ... T sumit_T(const std::vector<T>& data, T init) {; ... return std::accumulate(data.begin(), data.end(), init);; ... }""""""); ...; True; >>> cppyy.gbl.sumit_T(vector['double'](range(7)), 0); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; TypeError: Template method resolution failed:; Failed to instantiate ""sumit_T(std::vector<double>&,int)""; Failed to instantiate ""sumit_T(std::vector<double>*,int)""; Failed to instantiate ""sumit_T(std::vector<double>,int)""; >>> cppyy.gbl.sumit_T(vector['double'](range(7)), 0.); 21.0; >>>. To be sure, the code is `too` strict in the simplistic example above, and; with a future version of Cling it should be possible to lift some of these; restrictions without causing incorrect results. `std::map`; ----------. C++'s ``map`` is an associative container similar to Python's ``dict``,; albeit one that has stronger type constraints.; A ``map`` can be instantiated from a ``dict`` (and types can be inferred) or; from a collection of ``pair`` mappings. .. code-block:: python. >>> from cppyy.gbl.std import map; >>> m = map[str, int](*(""one"", 1), (""two"", 2))) # type explicit, from pairs; >>> print(m); { ""one"" => 1, ""two"" => 2 }; >>> m = map({1: ""one"", 2: ""two""}) # type implicit, from dict; >>> type(m); <class cppyy.gbl.std.map<int,std::string> at 0x12d068d60>; >>> print(m); { 1 => ""one"", 2 => ""two"" }; >>>. `std::string`; -------------. Python's `str` is a unicode type since Python3, whereas ``std::string`` is; single-byte char-based.; Having the two correctly interact therefore deserves it's own; :doc:`chapter <strings>`. `std::tuple`; ------------. C++ ``tuple`` is supported but",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst:7375,simpl,simplistic,7375,bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,1,['simpl'],['simplistic']
Usability,"ute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); $$. The parameters for this method are `Eta`, `EtaDecay`, `Delta` and; `Epsilon`. #### Steepest Descent With Fixed Step Size (Batch Learning). It is the same as the stochastic minimization, but the weights are; updated after considering all the examples, with the total derivative; `dEdw`. The parameters for this method are `Eta`, `EtaDecay`, `Delta`; and `Epsilon`. #### Steepest Descent Algorithm. Weights are set to the minimum along the line defined by the gradient.; The only parameter for this method is `Tau`. Lower `Tau` = higher; precision = slower search. A value `Tau=3` seems reasonable. #### Conjugate Gradients With the Polak-Ribiere Updating Formula. Weights are set to the minimum along the line defined by the conjugate; gradient. Parameters are `Tau` and `Reset`, which defines the epochs; where the direction is reset to the steepest descent (estimated by; using the Polak-Ribiere formula). #### Conjugate Gradients With the Fletcher-Reeves Updating Formula. Weights are set to the minimum along the line defined by the conjugate; gradient. Parameters are `Tau` and `Reset`, which defines the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:72689,Learn,Learning,72689,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['Learn'],['Learning']
Usability,"ution results of an expression are stored in the object 'V' of; type Value. This value is then printed, effectively helping the interpreter; use a value from the compiled code. .. code-block:: console. int Global = 42;; void setGlobal(int val) { Global = val; }; int getGlobal() { return Global; }; Interp.ParseAndExecute(“void setGlobal(int val);”);; Interp.ParseAndExecute(“int getGlobal();”);; Value V;; Interp.ParseAndExecute(“getGlobal()”, &V);; std::cout << V.getAs<int>() << “\n”; // Prints 42. **Note:** Above is an example of interoperability between the compiled code and; the interpreted code. Interoperability between languages (e.g., C++ and Python); works similarly. 2. Dump Captured Execution Results; ==================================. This feature helps create a temporary dump to display the value and type; (pretty print) of the desired data. This is a good way to interact with the; interpreter during interactive programming. How value printing is simplified (Automatic Printf); ---------------------------------------------------. The ``Automatic Printf`` feature makes it easy to display variable values during; program execution. Using the ``printf`` function repeatedly is not required.; This is achieved using an extension in the ``libclangInterpreter`` library. To automatically print the value of an expression, simply write the expression; in the global scope **without a semicolon**. .. graphviz::; :name: automaticprintf; :caption: Automatic PrintF; :alt: Shows how Automatic PrintF can be used; :align: center. digraph ""AutomaticPrintF"" {; size=""6,4"";; rankdir=""LR"";; graph [fontname=""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Sans"", fontsize=""9""];. manual [label="" Manual PrintF "", shape=""box""];; int1 [label="" int ( &) 42 "", shape=""box""]; auto [label="" Automatic PrintF "", shape=""box""];; int2 [label="" int ( &) 42 "", shape=""box""]. auto -> int2 [label=""int x = 42; \n x""];; manual -> int1 [label=""int x = 42; \n printf(&qu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:13941,simpl,simplified,13941,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['simpl'],['simplified']
Usability,"utputFile. Fix a problem with the determination of the fDir member; affecting mostly PROOF-Lite; Fix a serious issue whose net effect was to delete the; outputfile just after having open it. XrdProofd plugin. Make sure that the limit on the number of old; sessions is applied whenever a new session is started and not only when; the daemon is started.; Fix the behaviour of the xpd.allowedusers directive: if; at least one of these directives is present, users in the password file; are not allowed by default but must be explicitly appear in one; xpd.allowedusers directive  ; Fix a source for memory leak in; XrdProofdProtocol::SendMsg; Optimize the usage of strings in a few places. DataSet manager. Correctly classify as TTree all TTree derived classes; (e.g. TNtuple's); Fix a problem in saving the end-point URL for local; files; Improve realtime notification during 'verify'. TProofDraw. Fix a problem with the axis ranges of the underlying; histogram in PolyMarker3D; Allow to use the default pad instead of forcing; creation of one pad per object; Add wrapper to handle the feedback default canvas. TEventIter. Fix a problem with changing the tree cache size: the; size was reset to the default value after the first file. TDataSetManagerFile. Solve a consistency problem in checking URLs for; duplication when adding them to the relevant TFileInfo; During dataset validation, do not fail on duplications; but notify and add them to the bad file list. TPacketizerAdaptive, TPacketizer. Improve data node / worker matching by always using the; host FQDN. TPacketizerUnit, TEventIter. Make sure that the entry; number passed to TSelector::Process is unique and in increasing order; for non-data driven processing (packetizer TPacketizerUnit). This; allows to give a meaning to this variable, for example to related it to; one dimension of an integration. Fixes in PROOF-Lite:. Make sure that with envs settings via TProof::AddEnvVar; are effective; this enables, for example, the automatic valg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:8328,feedback,feedback,8328,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,1,['feedback'],['feedback']
Usability,"utton near to the slider center. To; change pointer value press the mouse on the pointer and drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHProgressBar`**, and; **`TGHProgressBar`**. ``` {.cpp}; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:88267,progress bar,progress bar,88267,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['progress bar'],['progress bar']
Usability,"uture version may integrate Cling-generated IR directly into Numba IR (or; vice versa), e.g. if the C++ code is exposed from (precompiled) headers.; This would allow inlining of C++ code into Numba traces, for further; expected speedups. Why Numba?; ----------. The advertised premise of Numba is that it ""makes Python code fast.""; However, there is a much more compelling reason: Numba allows developers to; stay in their chosen ecosystem, be it Python or C++, in mixed environments,; without paying for their choice in lost performance.; For example, a Python developer using Numba does not need to rewrite a kernel; into C++ just to run performantly in a C++ framework.; Similarly, a C++ developer can use Numba to compile and create function; pointers to Python code for easy, performant, access.; This becomes even more compelling if the deployment target is a GPU, which; would otherwise certainly require a rewrite of the Python code.; Add that Numba, as a JIT-compiler, is fully run-time just like ``cppyy``,; and the use case for integration is clear.; (Numba does not currently provide support for C++.). Usage; -------. ``cppyy`` does not use Numba extension hooks to minimize accidental; dependencies.; Instead, it requires that the extensions are loaded explicitly by any code; that uses it::. import cppyy.numba_ext. After that, Numba is able to trace ``cppyy`` bound code when applying the; usual ``numba.njit`` decorator. Numba type declarations are done lazily, with the ``numba_ext`` module only; initially registering hooks on proxy base classes, to keep overheads in; Numba's type-resolution to a minimum.; On use in a JITed trace, each C++ type or function call is refined to the; actual, concrete types and type-specific overloads, with templates; instantiated as-needed.; Where possible, lowering is kept generic to reduce the number of callbacks; in Numba's compilation chain. Examples; --------. The following, non-exhaustive, set of examples gives an idea of the; current lev",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:2173,clear,clear,2173,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['clear'],['clear']
Usability,"v/null | llc -march=xyz -mattr=help. .. option:: --frame-pointer. Specify effect of frame pointer elimination optimization (all,non-leaf,none). .. option:: --disable-excess-fp-precision. Disable optimizations that may produce excess precision for floating point.; Note that this option can dramatically slow down code on some systems; (e.g. X86). .. option:: --enable-no-infs-fp-math. Enable optimizations that assume no Inf values. .. option:: --enable-no-nans-fp-math. Enable optimizations that assume no NAN values. .. option:: --enable-no-signed-zeros-fp-math. Enable FP math optimizations that assume the sign of 0 is insignificant. .. option:: --enable-no-trapping-fp-math. Enable setting the FP exceptions build attribute not to use exceptions. .. option:: --enable-unsafe-fp-math. Enable optimizations that make unsafe assumptions about IEEE math (e.g. that; addition is associative) or may not work for all input ranges. These; optimizations allow the code generator to make use of some instructions which; would otherwise not be usable (such as ``fsin`` on X86). .. option:: --stats. Print statistics recorded by code-generation passes. .. option:: --time-passes. Record the amount of time needed for each pass and print a report to standard; error. .. option:: --load=<dso_path>. Dynamically load ``dso_path`` (a path to a dynamically shared object) that; implements an LLVM target. This will permit the target name to be used with; the :option:`-march` option so that code can be generated for that target. .. option:: -meabi=[default|gnu|4|5]. Specify which EABI version should conform to. Valid EABI versions are *gnu*,; *4* and *5*. Default value (*default*) depends on the triple. .. option:: -stack-size-section. Emit the .stack_sizes section which contains stack size metadata. The section; contains an array of pairs of function symbol values (pointer size) and stack; sizes (unsigned LEB128). The stack size values only include the space allocated; in the function prologue. Functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst:4083,usab,usable,4083,interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,1,['usab'],['usable']
Usability,"valid orderings of dependencies; - since linking resolution is linear, it's possible that some implicit; dependencies can sneak through: A depends on B and C, so valid orderings are; ""C B A"" or ""B C A"", in both cases the explicit dependencies come before their; use. But in the first case, B could still link successfully if it implicitly; depended on C, or the opposite in the second case). .. _minimal list of #includes:. ``#include`` as Little as Possible; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``#include`` hurts compile time performance. Don't do it unless you have to,; especially in header files. But wait! Sometimes you need to have the definition of a class to use it, or to; inherit from it. In these cases go ahead and ``#include`` that header file. Be; aware however that there are many cases where you don't need to have the full; definition of a class. If you are using a pointer or reference to a class, you; don't need the header file. If you are simply returning a class instance from a; prototyped function or method, you don't need it. In fact, for most cases, you; simply don't need the definition of a class. And not ``#include``\ing speeds up; compilation. It is easy to try to go too overboard on this recommendation, however. You; **must** include all of the header files that you are using --- you can include; them either directly or indirectly through another header file. To make sure; that you don't accidentally forget to include a header file in your module; header, make sure to include your module header **first** in the implementation; file (as mentioned above). This way there won't be any hidden dependencies that; you'll find out about later. Keep ""Internal"" Headers Private; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Many modules have a complex implementation that causes them to use more than one; implementation (``.cpp``) file. It is often tempting to put the internal; communication interface (helper classes, extra functions, etc) in the public; module header file. Do",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:32328,simpl,simply,32328,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['simpl'],['simply']
Usability,"value.; - Due to some planned major improvements to `RVec`, the layout of `RVec` objects will change in a backward-incompatible way between v6.24 and v6.26.; Because of this, we now print a warning if an application is reading or writing a `ROOT::RVec` object from/to a ROOT file. We assume this is an; exceedingly rare case, as the ROOT interface typically used to manipulate `RVec`s is `RDataFrame`, and `RDataFrame` performs an on-the-fly; `RVec <-> std::vector` conversion rather than writing `RVec`s to disk. Note that, currently, `RVecs` written e.g. in a `TTree` cannot be read back; using certain ROOT interfaces (e.g. `TTreeReaderArray`, `RDataFrame` and the experimental `RNTuple`). All these limitations will be lifted in v6.26.; - Portable implementation of the RANLUX++ generator, see [RanluxppEngine](https://root.cern/doc/master/classROOT_1_1Math_1_1RanluxppEngine.html) and [our blog post](https://root.cern/blog/ranluxpp/). ## TMVA. - Introducing TMVA PyTorch Interface, a method to use PyTorch internally with TMVA for deep learning. This can be used as an alternative to PyKeras Interface for complex models providing more flexibility and power. ## RooFit Libraries. - Extension / updates of the doxygen reference guide.; - Allow for removing RooPlot from global directory management, see [RooPlot::AddDirectory](https://root.cern/doc/v624/classRooPlot.html#a47f7ba71dcaca30ad9ee295dee89c9b8); and [RooPlot::SetDirectory](https://root.cern/doc/v624/classRooPlot.html#a5938bc6d5c47d94c2f04fdcc10c1c026); - Hash-assisted finding of elements in RooWorkspace. Large RooWorkspace objects were slow in finding elements.; This was improved using a hash map.; - Stabilise RooStats::HypoTestInverter. It can now tolerate a few failed fits when conducting hypothesis tests.; This is relevant when a few points in a parameter scan don't converge due to numerical or model instabilities.; These points will be skipped, and HypoTestInverter can continue.; - Tweak pull / residual plots. ROOT au",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:13718,learn,learning,13718,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['learn'],['learning']
Usability,"vas,; when whole canvas cannot be drawn.; 13. Correct usage of colors map, provided with TCanvas.; 14. Introduce JSROOT.redraw() function which is capable to create or update object drawing.; 15. In main index.htm page browser can be disabled (nobrowser parameter) and; page can be used to display only specified items from the file; 16. Add support of TPolyMarker3D in binary I/O. ### September 2014; 1. First try to handle resize of the browser,; for the moment works only with collapsible layout; 2. Also first try to interactively move separation line between; browser and drawing field.; 3. Small fix of minor ticks drawing on the axis; 4. Introduce display class for MDI drawing. Provide two implementations -; 'collapsible' for old kind and 'tabs' for new kinds.; 5. Adjust size of color palette drawing when labels would take more place as provided.; 6. Add correct filling of statistic for TProfile,; fix small problem with underflow/overflow bins.; 7. Provide way to select display kind ('collapsible', 'tabs') in the simple GUI.; 8. Implement 'grid' display, one could specify any number of division like; 'grid 3x3' or 'grid 4x2'.; 9. MDI display object created at the moment when first draw is performed.; 10. Introduce painter class for TCanvas, support resize and update of canvas drawing; 11. Resize almost works for all layouts and all objects kinds.; 12. Implement JSROOT.GetUrlOption to extract options from document URL.; 13. Provide example fileitem.htm how read and display item from ROOT file.; 14. In default index.htm page one could specify 'file', 'layout',; 'item' and 'items' parameters like:; <http://root.cern.ch/js/3.0/index.htm?file=../files/hsimple.root&layout=grid3x2&item=hpx;1>; 15. Support direct reading of objects from sub-sub-directories.; 16. Introduce demo.htm, which demonstrates online usage of JSROOT.; 17. One could use demo.htm directly with THttpServer providing address like:; <http://localhost:8080/jsrootsys/demo/demo.htm?addr=../../Files/job1.root/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:72579,simpl,simple,72579,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,"vative.; The resulting fit parameters will be identical to those obtained with the non-parallelized gradients minimizer in most cases (see the usage notes linked below for exceptions). In upcoming releases, further developments are planned:. - Benchmark/profile and optimize performance further; - Add a `RooAbsPdf::fitTo` interface around these new classes; - Achieve feature parity with existing `RooNLLVar` functionality, e.g. ranges are not yet supported. For more details, consult the usage notes in the [TestStatistics README.md](https://github.com/root-project/root/tree/master/roofit/roofitcore/src/TestStatistics/README.md).; For benchmarking results on the prototype version of the parallelized gradient calculator, see the corresponding [CHEP19 proceedings paper](https://doi.org/10.1051/epjconf/202024506027). ### New pythonizations. Various new pythonizations are introduced to streamline your RooFit code in Python. For a complete list of all pythonized classes and functions, please see the [RooFit pythonizations page in the reference guide](https://root.cern/doc/v626/group__RoofitPythonizations.html).; All RooFit Python tutorials have been updated to profit from all available pythonizations. Some notable highlights are listed in the following. #### Keyword argument pythonizations. All functions that take RooFit command arguments as parameters now accept equivalent Python keyword arguments, for example simplifying calls to [RooAbsPdf::fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5) such as:; ```Python; model.fitTo(data, ROOT.RooFit.Range(""left,right""), ROOT.RooFit.Save()); ```; which becomes:; ```Python; model.fitTo(data, Range=""left,right"", Save=True); ```. #### String to enum pythonizations. Many functions that take an enum as a parameter now accept also a string with the enum label. Take for example this expression:; ```Python; data.plotOn(frame, ROOT.RooFit.DataError(ROOT.RooAbsData.SumW2); ```; Combining the enum pytho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:19011,guid,guide,19011,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['guid'],['guide']
Usability,"ved to the ""bottom"" of the loop, i.e.; the latch. This is something that LoopRotate does by copying the header; of the loop to the latch.; * The compiler in this case can't deduce that the loop will; definitely execute at least once so the above transformation; is not valid. As mentioned above, a guard has to be inserted,; which is something that LoopRotate will do. This is how LoopRotate transforms this loop:. .. code-block:: none. define void @test(i32 %n) {; entry:; %guard_cond = icmp slt i32 0, %n; br i1 %guard_cond, label %loop.preheader, label %exit. loop.preheader:; br label %body. body:; %i2 = phi i32 [ 0, %loop.preheader ], [ %i.next, %latch ]; br label %latch. latch:; %i.next = add nsw i32 %i2, 1; %cond = icmp slt i32 %i.next, %n; br i1 %cond, label %body, label %loop.exit. loop.exit:; br label %exit. exit:; ret void; }. .. image:: ./loop-terminology-guarded-loop.png; :width: 500 px. The result is a little bit more complicated than we may expect; because LoopRotate ensures that the loop is in; :ref:`Loop Simplify Form <loop-terminology-loop-simplify>`; after rotation.; In this case, it inserted the %loop.preheader basic block so; that the loop has a preheader and it introduced the %loop.exit; basic block so that the loop has dedicated exits; (otherwise, %exit would be jumped from both %latch and %entry,; but %entry is not contained in the loop).; Note that a loop has to be in Loop Simplify Form beforehand; too for LoopRotate to be applied successfully. The main advantage of this form is that it allows hoisting; invariant instructions, especially loads, into the preheader.; That could be done in non-rotated loops as well but with; some disadvantages. Let's illustrate them with an example:. .. code-block:: C. for (int i = 0; i < n; ++i) {; auto v = *p;; use(v);; }. We assume that loading from p is invariant and use(v) is some; statement that uses v.; If we wanted to execute the load only once we could move it; ""out"" of the loop body, resulting in this:. .. c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:21705,Simpl,Simplify,21705,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,2,"['Simpl', 'simpl']","['Simplify', 'simplify']"
Usability,"vents, magenta bar) or a; session freeze.; Fix problem with packet re-assignment in case of a worker death (some packets were processed twice or more times).; Fix problem with the transmission of non-default file; attributes (e.g. the number of entries) from TChainElement to; TDSetElement during TChain processing in PROOF; Fix problem in the default packetizer with validating the; exact number of needed files when the information about the entries is; already available.; Fix problem with 'xpd.putenv' and 'xpd.putrc' occuring when the variables themselves contain commas.; Avoid resolving the workers FQDN when running in PROOF-Lite,; creating unnecessary delays when running PROOF-Lite within virtual; machines.; Fix problem with the permissions of the user data directory.; Add files to the list of files to process only when finally validated.; Fix; problem with canvases when the feedback canvas and the final canvas are; the same (do not delete the feedback canvas at the end of processing); Make sure that TProof::Load, TProofPlayer::SendSelector and; TSelector::GetSelector treat consistently the extensions of the; implementation files.; Unlock the cache after failure to load a selector; prevents session freezing; Correctly update the number of submergers when workers die; Add missing protection causing a crash in submergers when the output list contained TProofOutputFile objects.; Move the creation and start of the idle timeout from the end; of SetupCommon to the end of CreateServer, so that the timeout is not; active during worker setup.; Make sure that the TProof instance on the client is invalidated after an idle timeout.; Fix an old issue with DeactivateWorker(""*"") (the session is; was terminated because no worker was active; this call coudl not be; used as intermediate step to select a small number of workers).; Consistently check both Proof.Sandbox and ProofLite.Sandbox for sandbox non-default location as done in TProofLite; Fix a problem with the registration of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:12218,feedback,feedback,12218,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,2,['feedback'],['feedback']
Usability,"ver.org/data/file.root"",""new""); root[] TFile *f3 = TFile::Open(""http://root.cern.ch/files/hsimple.root""); root[] f3.ls(); TDavixFile** http://root.cern.ch/files/hsimple.root; TDavixFile* http://root.cern.ch/files/hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; root[] hpx.Draw(); ```. ## XML Interface. A new module `xml` as implemented by Sergey Linev (GSI). It is an; optional package that can be used to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; compared to the normal ROOT files, except that the information in these; files can be edited via a normal editor. The main motivation for this; new format is to facilitate the communication with other non ROOT; applications. Currently writing and reading XML files is limited to ROOT; applications. It is our intention to develop a simple reader independent; of the ROOT libraries that could be used as an example for real; applications. The XML format should be used only for small data volumes, typically; histogram files, pictures, geometries, calibrations. The XML file is; built in memory before being dumped to disk. Like for normal ROOT files,; XML files use the same I/O mechanism exploiting the ROOT/Cling; dictionary. Any class having a dictionary can be saved in XML format.; This first implementation does not support subdirectories or trees. The shared library `libRXML.so` may be loaded dynamically via; `gSystem->Load(""libRXML"")`. This library is also automatically loaded by; the plug-in manager as soon a XML file is created. To create an XTM; file, simply specify a filename with an .xml extension when calling; **`TFile`**`::Open`. **`TFile`**`::Open` will recognize that you are trying to; open an XML file and return a **`TXMLFile`** object. When a XML file is; open in write mode, one can use the normal `TObject::Write` to write an; object in th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:97532,simpl,simple,97532,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"ver; binding using `root --notebook --ip=<hostaddr>` arguments; - Now Jupyter Notebooks will use JSROOT provided with ROOT installation. This allows to use notebooks; without internet connection (offline). ## JavaScript ROOT; - Provide monitoring capabilities for TGeoManager object. Now geomtry with some tracks can be displayed and; updated in web browser, using THttpServer monitoring capability like histogram objects. ## Tutorials; - Add the ""Legacy"" category collecting the old tutorials which do not represent any more best practices. ## Class Reference Guide; - Images in tutorials can now be displayed à JavaScript thanks to the (js) option; added next to the directive `\macro_image`; - As the tutorial `palettes.C` is often hit when searching the keyword `palette`; in the reference guide, a direct link from this example to the full list of; predefined palettes given in `TColor` has been added.; - Revisited the TSpectrum2 documentation. All the static images have been replaced; by macros generating images at reference guide build time. These macros have; been added in the tutorial section of the reference guide.; - The Reference Guide can now be accessed directly from the ROOT prompt thanks to; a great extension (implemented by Desislava Kalaydjieva) of the `.help` command.; For example to access the Reference Guide for `TTree` it is enough to type:; ~~~ {.cpp}; root[0] .help TTree; ~~~; To open the reference guide for a function/member:; ~~~ {.cpp}; root[0] .help TTree::Draw; ~~~. ## Build, Configuration and Testing Infrastructure. - Make MLP optional via the `-Dmlp={OFF,ON}` switch for CMake; - Make Spectrum optional via the `-Dspectrum={OFF,ON}` switch for CMake; - ROOT now fails to configure when any package is missing; when `-Dfail-on-missing=ON` is passed to CMake; - The `-Dall=ON` now switches the default value of all optional packages to `ON`; - The options `astiff`, `cling`, `pch`, `thread`, and `explicitlink` have been; removed and are now ignored. They eit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:7333,guid,guide,7333,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['guid'],['guide']
Usability,"verflow problems; N/A. 438; C11; ungetc / ungetwc and file position after discarding push back problems; N/A. 439; C11; Issues with the definition of ""full expression""; Unknown. 440; NAD; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 1; Unknown. 441; C11; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 2; N/A. 442; NAD; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 3; Unknown. 443; NAD; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 4; Unknown. 444; C11; Issues with alignment in C11, part 1. Partial; Clang rejects use of an alignment specifier in a compound literal expression.; . 445; C11; Issues with alignment in C11, part 2; Unknown. 446; NAD; Use byte instead of character for memcmp, memcpy; N/A. 447; C11; Boolean from complex; Yes. 448; C11; What are the semantics of a # non-directive?; Yes. 449; NAD; What is the value of TSS_DTOR_ITERATIONS for implementations with no maximum?; N/A. 450; C11; tmpnam_s clears s[0] when maxsize > RSIZE_MAX; N/A. 451; NAD; Instability of uninitialized automatic variables; Unknown. 452; C11; Effective Type in Loop Invariant; Unknown. 453; C11; Atomic flag type and operations; N/A. 454; NAD; ATOMIC_VAR_INIT (issues 3 and 4); Yes. 455; NAD; ATOMIC_VAR_INIT issue 5; Yes. 456; Dup; Compile time definition of UINTN_C(value); Duplicate of 209. 457; C11; The ctime_s function in Annex K defined incorrectly; N/A. 458; C11; ATOMIC_XXX_LOCK_FREE macros not constant expressions; N/A. 459; C11; atomic_load missing const qualifier; Yes. 460; C11; aligned_alloc underspecified; N/A. 461; NAD; Problems with references to objects in signal handlers; N/A. 462; C11; Clarifying objects accessed in signal handlers; N/A. 463; NAD; Left-shifting into the sign bit; Yes. 464; C11; Clarifying the Behavior of the #line Directive; Yes. 465; C11; Fixing an inconsistency in atomic_is_lock_free; Unknown. 466; NAD; Scope of a for loop control declaration; Yes. 467; C11; Maximum representable fini",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:24618,clear,clears,24618,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,1,['clear'],['clears']
Usability,"verflow; 	ud2. it would be nice to produce ""into"" someday. //===---------------------------------------------------------------------===//. Test instructions can be eliminated by using EFLAGS values from arithmetic; instructions. This is currently not done for mul, and, or, xor, neg, shl,; sra, srl, shld, shrd, atomic ops, and others. It is also currently not done; for read-modify-write instructions. It is also current not done if the; OF or CF flags are needed. The shift operators have the complication that when the shift count is; zero, EFLAGS is not set, so they can only subsume a test instruction if; the shift count is known to be non-zero. Also, using the EFLAGS value; from a shift is apparently very slow on some x86 implementations. In read-modify-write instructions, the root node in the isel match is; the store, and isel has no way for the use of the EFLAGS result of the; arithmetic to be remapped to the new node. Add and subtract instructions set OF on signed overflow and CF on unsiged; overflow, while test instructions always clear OF and CF. In order to; replace a test with an add or subtract in a situation where OF or CF is; needed, codegen must be able to prove that the operation cannot see; signed or unsigned overflow, respectively. //===---------------------------------------------------------------------===//. memcpy/memmove do not lower to SSE copies when possible. A silly example is:; define <16 x float> @foo(<16 x float> %A) nounwind {; 	%tmp = alloca <16 x float>, align 16; 	%tmp2 = alloca <16 x float>, align 16; 	store <16 x float> %A, <16 x float>* %tmp; 	%s = bitcast <16 x float>* %tmp to i8*; 	%s2 = bitcast <16 x float>* %tmp2 to i8*; 	call void @llvm.memcpy.i64(i8* %s, i8* %s2, i64 64, i32 16); 	%R = load <16 x float>* %tmp2; 	ret <16 x float> %R; }. declare void @llvm.memcpy.i64(i8* nocapture, i8* nocapture, i64, i32) nounwind. which compiles to:. _foo:; 	subl	$140, %esp; 	movaps	%xmm3, 112(%esp); 	movaps	%xmm2, 96(%esp); 	movaps	%xmm1, 80(%e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:31289,clear,clear,31289,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['clear'],['clear']
Usability,"very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities behind the macro. Note that the variable `pull` in line; *61* is different from the definition above: instead of the parameter; error on `mean`, the fitted standard deviation of the distribution",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:4263,simpl,simple,4263,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,1,['simpl'],['simple']
Usability,"vided as a note.; ``fn_ret_thunk_extern``; This attribute tells the code generator that returns from functions should; be replaced with jumps to externally-defined architecture-specific symbols.; For X86, this symbol's identifier is ``__x86_return_thunk``.; ``""frame-pointer""``; This attribute tells the code generator whether the function; should keep the frame pointer. The code generator may emit the frame pointer; even if this attribute says the frame pointer can be eliminated.; The allowed string values are:. * ``""none""`` (default) - the frame pointer can be eliminated.; * ``""non-leaf""`` - the frame pointer should be kept if the function calls; other functions.; * ``""all""`` - the frame pointer should be kept.; ``hot``; This attribute indicates that this function is a hot spot of the program; execution. The function will be optimized more aggressively and will be; placed into special subsection of the text section to improving locality. When profile feedback is enabled, this attribute has the precedence over; the profile information. By marking a function ``hot``, users can work; around the cases where the training input does not have good coverage; on all the hot functions.; ``inlinehint``; This attribute indicates that the source code contained a hint that; inlining this function is desirable (such as the ""inline"" keyword in; C/C++). It is just a hint; it imposes no requirements on the; inliner.; ``jumptable``; This attribute indicates that the function should be added to a; jump-instruction table at code-generation time, and that all address-taken; references to this function should be replaced with a reference to the; appropriate jump-instruction-table function pointer. Note that this creates; a new pointer for the original function, which means that code that depends; on function-pointer identity can break. So, any function annotated with; ``jumptable`` must also be ``unnamed_addr``.; ``memory(...)``; This attribute specifies the possible memory effects of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:83708,feedback,feedback,83708,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['feedback'],['feedback']
Usability,"views>` documentation. When Is an RFC Required?; ------------------------. Some changes are too significant for just a code review. Changes that should; change the LLVM Language Reference (e.g., adding new target-independent; intrinsics), adding language extensions in Clang, and so on, require an RFC; (Request for Comment) email on the project's ``*-dev`` mailing list first. For; changes that promise significant impact on users and/or downstream code bases,; reviewers can request an RFC achieving consensus before proceeding with code; review. That having been said, posting initial patches can help with; discussions on an RFC. Code-Review Workflow; ====================. Code review can be an iterative process, which continues until the patch is; ready to be committed. Specifically, once a patch is sent out for review, it; needs an explicit approval before it is committed. Do not assume silent; approval, or solicit objections to a patch with a deadline. Acknowledge All Reviewer Feedback; ---------------------------------. All comments by reviewers should be acknowledged by the patch author. It is; generally expected that suggested changes will be incorporated into a future; revision of the patch unless the author and/or other reviewers can articulate a; good reason to do otherwise (and then the reviewers must agree). If a new patch; does not address all outstanding feedback, the author should explicitly state; that when providing the updated patch. When using the web-based code-review; tool, such notes can be provided in the ""Diff"" description (which is different; from the description of the ""Differential Revision"" as a whole used for the; commit message). If you suggest changes in a code review, but don't wish the suggestion to be; interpreted this strongly, please state so explicitly. Aim to Make Efficient Use of Everyone's Time; --------------------------------------------. Aim to limit the number of iterations in the review process. For example, when; suggesting a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:4915,Feedback,Feedback,4915,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['Feedback'],['Feedback']
Usability,"vironment or other; installation location.; Adjust other options (esp. ``CMAKE_CXX_STANDARD``) as needed.; For the build command, adjust the ``cmake`` command as appropriate for your; favorite, or platform-specific, build system and/or use ``cmake --build``; instead of ``make`` directly.; See the `cmake documentation`_ for details. Next up is ``cppyy-backend`` (cppyy-backend, subdirectory ""clingwrapper""; omit; the first step if you already cloned the repo for ``cppyy-cling``)::. $ git clone https://github.com/wlav/cppyy-backend.git; $ cd cppyy-backend/clingwrapper; $ python -m pip install . --upgrade --no-use-pep517 --no-deps. Note the use of ``--no-use-pep517``, which prevents ``pip`` from needlessly; going out to pypi.org and creating a local ""clean"" build environment from the; cached or remote wheels.; Instead, by skipping PEP 517, the local installation will be used.; This is imperative if there was a change in public headers or if the version; of ``cppyy-cling`` was locally updated and is thus not available on PyPI. Upgrading ``CPyCppyy`` (if on CPython; it's not needed for PyPy) and ``cppyy``; is very similar::. $ git clone https://github.com/wlav/CPyCppyy.git; $ cd CPyCppyy; $ python -m pip install . --upgrade --no-use-pep517 --no-deps. Just like ``cppyy-cling``, ``CPyCppyy`` has ``cmake`` scripts which are the; recommended way for development, as incremental builds are faster::. $ mkdir build; $ cmake ../CPyCppyy; $ make -j <N>. then simply point the ``PYTHONPATH`` envar to the `build` directory above to; pick up the local `cppyy.so` module. Finally, the top-level package ``cppyy``::. $ git clone https://github.com/wlav/cppyy.git; $ cd cppyy; $ python -m pip install . --upgrade --no-deps. Please see the `pip documentation`_ for more options, such as developer mode. .. _`setuptools`: https://setuptools.readthedocs.io/; .. _`upstream`: https://root.cern.ch/download/; .. _`cmake documentation`: https://cmake.org/; .. _`pip documentation`: https://pip.pypa.io/; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst:6399,simpl,simply,6399,bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,1,['simpl'],['simply']
Usability,"vm.nvvm.barrier0``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". .. code-block:: llvm. declare void @llvm.nvvm.barrier0(). Overview:; """""""""""""""""". The '``@llvm.nvvm.barrier0()``' intrinsic emits a PTX ``bar.sync 0``; instruction, equivalent to the ``__syncthreads()`` call in CUDA. Other Intrinsics; ----------------. For the full set of NVPTX intrinsics, please see the; ``include/llvm/IR/IntrinsicsNVVM.td`` file in the LLVM source tree. .. _libdevice:. Linking with Libdevice; ======================. The CUDA Toolkit comes with an LLVM bitcode library called ``libdevice`` that; implements many common mathematical functions. This library can be used as a; high-performance math library for any compilers using the LLVM NVPTX target.; The library can be found under ``nvvm/libdevice/`` in the CUDA Toolkit and; there is a separate version for each compute architecture. For a list of all math functions implemented in libdevice, see; `libdevice Users Guide <http://docs.nvidia.com/cuda/libdevice-users-guide/index.html>`_. To accommodate various math-related compiler flags that can affect code; generation of libdevice code, the library code depends on a special LLVM IR; pass (``NVVMReflect``) to handle conditional compilation within LLVM IR. This; pass looks for calls to the ``@__nvvm_reflect`` function and replaces them; with constants based on the defined reflection parameters. Such conditional; code often follows a pattern:. .. code-block:: c++. float my_function(float a) {; if (__nvvm_reflect(""FASTMATH"")); return my_function_fast(a);; else; return my_function_precise(a);; }. The default value for all unspecified reflection parameters is zero. The ``NVVMReflect`` pass should be executed early in the optimization; pipeline, immediately after the link stage. The ``internalize`` pass is also; recommended to remove unused math functions from the resulting PTX. For an; input IR module ``module.bc``, the following compilation flow is recommended:. 1. Save list of external function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:8080,guid,guide,8080,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['guid'],['guide']
Usability,"vm.org/doxygen/structclang_1_1format_1_1FormatStyle.html>`_; structure. Configurable Format Style Options; =================================. This section lists the supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5651,guid,guide,5651,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['guid'],['guide']
Usability,"vmtg/2013-04/klimek-slides.pdf>`_. Introduction; ============. Clang's AST is different from ASTs produced by some other compilers in; that it closely resembles both the written C++ code and the C++; standard. For example, parenthesis expressions and compile time; constants are available in an unreduced form in the AST. This makes; Clang's AST a good fit for refactoring tools. Documentation for all Clang AST nodes is available via the generated; `Doxygen <https://clang.llvm.org/doxygen>`_. The doxygen online; documentation is also indexed by your favorite search engine, which will; make a search for clang and the AST node's class name usually turn up; the doxygen of the class you're looking for (for example, search for:; clang ParenExpr). Examining the AST; =================. A good way to familiarize yourself with the Clang AST is to actually look; at it on some simple example code. Clang has a builtin AST-dump mode,; which can be enabled with the flag ``-ast-dump``. Let's look at a simple example AST:. ::. $ cat test.cc; int f(int x) {; int result = (x / 42);; return result;; }. # Clang by default is a frontend for many tools; -Xclang is used to pass; # options directly to the C++ frontend.; $ clang -Xclang -ast-dump -fsyntax-only test.cc; TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>; ... cutting out internal declarations of clang ...; `-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'; |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'; `-CompoundStmt 0x5aead88 <col:14, line:4:1>; |-DeclStmt 0x5aead10 <line:2:3, col:24>; | `-VarDecl 0x5aeac10 <col:3, col:23> result 'int'; | `-ParenExpr 0x5aeacf0 <col:16, col:23> 'int'; | `-BinaryOperator 0x5aeacc8 <col:17, col:21> 'int' '/'; | |-ImplicitCastExpr 0x5aeacb0 <col:17> 'int' <LValueToRValue>; | | `-DeclRefExpr 0x5aeac68 <col:17> 'int' lvalue ParmVar 0x5aeaa90 'x' 'int'; | `-IntegerLiteral 0x5aeac90 <col:21> 'int' 42; `-ReturnStmt 0x5aead68 <line:3:3, col:10>; `-ImplicitCastExpr 0x5aead50 <col:10> 'int' <L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:1502,simpl,simple,1502,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,1,['simpl'],['simple']
Usability,"void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misuses of stream APIs:; fopen; fclose(demo checker, the subject of the demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:14447,clear,clearerr,14447,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['clear'],['clearerr']
Usability,"w minimum is found, the best parameter values; are retained as start values for future scans or minimizations. The; curve resulting from each scan can be plotted on the output terminal; using MnPlot [api:plot] in order to show the approximate behaviour of; the function. ### ScanMinimizer ###. Although the $\mbox{SCAN}$ method is not intended for minimization; it can be used as a minimizer in its most primitive form. ## MnSimplex and SimplexMinimizer ##. [api:simplex]. $\mbox{SIMPLEX}$ is a function minimization method using the simplex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; parameters interaction. It also retains the result from the last; minimization in case the user may want to do subsequent minimization; steps with parameter interactions in between the minimization requests.; The minimization is done by the SimplexMinimizer. Minimization of the; function can be done by directly using the SimplexMinimizer if no; parameters interaction is required. As $\mbox{SIMPLEX}$ is a; stepping method it does not produce a covariance matrix. ### MnSimplex(const FCNBase&, const std::vector$<$double$>$&,\; const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameters&,\; unsigned int) ###. Constructor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameterState&,\; const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes; minimization of the $\mbox{FCN}$ and returns the result in form of a; FunctionMinimum. Minimization ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:48946,Simpl,SimplexMinimizer,48946,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['Simpl'],['SimplexMinimizer']
Usability,"w option, *ValidationSize* has been added to the global options for `MethodDL`.; The same option is also available in the `PyKeras` method of `PyMVA`; - The fast tanh implementation from VDT is now used as activation function when training the network on CPU.; - Using `Cblas` from the GSL library is supported for CPU training when no other Blas libraries are found. However, it is strongly recommended, to use an optimized Blas implementation such as `libopenblas`, that is; available in cvmfs.; - Add several performance optimizations for both CPU and GPU versions of `MethodDL`. . ### Other New TMVA Features. - Add a new option to the `DataLoader` to switch off computation of correlation matrix. The new option is called *CalcCorrelations* and it should be used when a large number of input variables are; provided, otherwise TMVA will spend a long time in setting up the data set before training. ; ; - Build configuration:; - Add new cmake flags, `tmva-cpu` and `tmva-gpu`, which can be used to swicth on/off the CPU and GPU (based on CUDA) implementations of the TMVA Deep Learning module. `tmva-cpu` is enabled by; default if a Blas or CBlas library is found in the system. `tmva-gpu` is enabled when the cmake flag `cuda` is enabled and a compatible Cuda library is found. ; enabled if the corre; - Add possibility to independently configure building of optional pymva part of tmva with flag `-Dpymva=ON|OFF`. - New Cross Validation features:; - Add stratified splitting for cross validation.; - New plotting option in cross validation, average ROC curve. - Bugfixes:; - Fix bug in BDT training with imt=on; - Improved handling of large event numbers in cross validation using deterministic splitting. - Documentation:; - Update TMVA Users' guide. ## 2D Graphics Libraries. - Highlight mode is implemented for `TH1` and for `TGraph` classes. When; highlight mode is on, mouse movement over the bin will be represented; graphically. Histograms bins or graph points will be highlighted. Moreo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:15614,Learn,Learning,15614,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['Learn'],['Learning']
Usability,"w; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no assumptions should be made on how; ``CFGBlocks`` are numbered other than their numbers are unique and that they; are numbered from 0..N-1 (where N is the number of basic blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (accessible via ``CFG::getEntry()``), which has no incoming edges, and an; *exit* block (accessible via ``CFG::getExit()``), which has no outgoing edges.; Neither block contains any statements, and they serve the role of providing a; clear entrance and exit for a body of code such as a function body. The; presence of these empty blocks greatly simplifies the implementation of many; analyses built on top of CFGs. .. _ConditionalControlFlow:. Conditional Control-Flow; ^^^^^^^^^^^^^^^^^^^^^^^^. Conditional control-flow (such as those induced by if-statements and loops) is; represented as edges between ``CFGBlocks``. Because different C language; constructs can induce control-flow, each ``CFGBlock`` also records an extra; ``Stmt*`` that represents the *terminator* of the block. A terminator is; simply the statement that caused the control-flow, and is used to identify the; nature of the conditional control-flow between blocks. For example, in the; case of an if-statement, the terminator refers to the ``IfStmt`` object in the; AST that represented the given branch. To illustrate, consider the following code example:. .. code-block:: c++. int foo(int x) {; x = x + 1;; if (x > 2); x++;; else {; x += 2;; x *= 2;; }.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:113822,clear,clear,113822,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['clear'],['clear']
Usability,"w_ostream`` instances. Avoid ``std::endl``; ^^^^^^^^^^^^^^^^^^^. The ``std::endl`` modifier, when used with ``iostreams`` outputs a newline to; the output stream specified. In addition to doing this, however, it also; flushes the output stream. In other words, these are equivalent:. .. code-block:: c++. std::cout << std::endl;; std::cout << '\n' << std::flush;. Most of the time, you probably have no reason to flush the output stream, so; it's better to use a literal ``'\n'``. Don't use ``inline`` when defining a function in a class definition; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A member function defined in a class definition is implicitly inline, so don't; put the ``inline`` keyword in this case. Don't:. .. code-block:: c++. class Foo {; public:; inline void bar() {; // ...; }; };. Do:. .. code-block:: c++. class Foo {; public:; void bar() {; // ...; }; };. Microscopic Details; -------------------. This section describes preferred low-level formatting guidelines along with; reasoning on why we prefer them. Spaces Before Parentheses; ^^^^^^^^^^^^^^^^^^^^^^^^^. Put a space before an open parenthesis only in control flow statements, but not; in normal function call expressions and function-like macros. For example:. .. code-block:: c++. if (X) ...; for (I = 0; I != 100; ++I) ...; while (LLVMRocks) ... somefunc(42);; assert(3 != 4 && ""laws of math are failing me"");. A = foo(42, 92) + bar(X);. The reason for doing this is not completely arbitrary. This style makes control; flow operators stand out more, and makes expressions flow better. Prefer Preincrement; ^^^^^^^^^^^^^^^^^^^. Hard fast rule: Preincrement (``++X``) may be no slower than postincrement; (``X++``) and could very well be a lot faster than it. Use preincrementation; whenever possible. The semantics of postincrement include making a copy of the value being; incremented, returning it, and then preincrementing the ""work value"". For; primitive types, this isn't a big deal. But ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:57167,guid,guidelines,57167,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['guid'],['guidelines']
Usability,"wed very; thin white lines between the bins as well as in the color palette.; This made very ugly the final output.; This problem is due to bad implementation of anti-aliasing in these previewers.; A way to bypass this issue was to turn off the anti-aliasing in the previewer; but then the rest of the document does not look nice. This problem is now bypassed; with a fix in both PDF and PostScript output.; - Offer 0 as line width option. Useful to make a line invisible. ### TSVG. - Use float numbers instead of integer to describe graphics paths to avoid; rounding problems.; - Implement missing math symbols.; - Offer 0 as line width option. Useful to make a line invisible. ### TASImage. - In the animated gif it is now possible to specify the delay between the last; image and the fist image in case of infinite loop. (Fernando Hueso González; <f.gonzalez@hzdr.de>). ### TPadPainter; - Offer 0 as line width option. Useful to make a line invisible. ### TPad. - In `TPad::ShowGuidelines` the number of guide lines is limited to 15. Above; that they become useless.; - Print a warning if one of the pad limit is a NaN.; - Fix https://sft.its.cern.ch/jira/browse/ROOT-6703. ### TCanvas. - Make sure that ""/"" and ""."" are not part of the method name when a canvas is; saved as a .C file. ### TLatex. - With the Cocoa backend the PDF and PS output produced miss-aligned exponents; because the `GetTextExtend` method behaved differently in batch mode and ""screen""; mode. This is now fixed. See http://root.cern.ch/phpBB3/viewtopic.php?f=3&t=18883; - Improve the square-root drawing in case it is small.; - Better adjustment of the tilde accent position in case of Cocoa backend. ### TMathText. - `\mu` is now working for Postscript output.; - `\splitline` is now implemented. ### Cocoa backend. - Line width and line style were not applied on boxes. ## 3D Graphics Libraries. ### GL Viewer; - New option ""Rotate scene"" in the ""Extras"" tab of the GL Viewer. It allows to; do a real rotation instead of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:23372,guid,guide,23372,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['guid'],['guide']
Usability,"which are then processed by TableGen. ```; class Hello <string _msg> {; string msg = !strconcat(""Hello "", _msg);; }. def HelloWorld: Hello<""world!""> {}; ```; ```; ------------- Classes -----------------; class Hello<string Hello:_msg = ?> {; string msg = !strconcat(""Hello "", Hello:_msg);; }; ------------- Defs -----------------; def HelloWorld { // Hello; string msg = ""Hello world!"";; }; ```; [Try this example on Compiler Explorer.](https://godbolt.org/z/13xo1P5oz). The internalized records are passed on to various backends, which extract; information from a subset of the records and generate one or more output files. These output files are typically .inc files for C++, but may be any type of file; that the backend developer needs. Resources for learning the language:; * [TableGen Overview](https://llvm.org/docs/TableGen/index.html); * [Programmer's reference guide](https://llvm.org/docs/TableGen/ProgRef.html); * [Tutorial](jupyter/tablegen_tutorial_part_1.ipynb); * [Tools for Learning LLVM TableGen](https://blog.llvm.org/posts/2023-12-07-tools-for-learning-llvm-tablegen/); * [Lessons in TableGen](https://www.youtube.com/watch?v=45gmF77JFBY) (video),; [slides](https://archive.fosdem.org/2019/schedule/event/llvm_tablegen/attachments/slides/3304/export/events/attachments/llvm_tablegen/slides/3304/tablegen.pdf); * [Improving Your TableGen Descriptions](https://www.youtube.com/watch?v=dIEVUlsiktQ); (video), [slides](https://llvm.org/devmtg/2019-10/slides/Absar-ImprovingYourTableGenDescription.pdf). Writing TableGen backends:; * [TableGen Backend Developer's Guide](https://llvm.org/docs/TableGen/BackGuide.html); * [How to write a TableGen backend](https://www.youtube.com/watch?v=UP-LBRbvI_U); (video), [slides](https://llvm.org/devmtg/2021-11/slides/2021-how-to-write-a-tablegen-backend.pdf), also available as a; 	[notebook](jupyter/sql_query_backend.ipynb). TableGen in MLIR:; * [Operation Definition Specification](https://mlir.llvm.org/docs/DefiningDialects/Operations/); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/README.md:1309,Learn,Learning,1309,interpreter/llvm-project/llvm/utils/TableGen/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/README.md,1,['Learn'],['Learning']
Usability,"width/baroffset parameters in lego plots; * Bug fixes:; - use same number of points to draw lines and markers on the TGraph; - correctly draw filled TArrow endings; - let combine ""L"" or ""C"" TGraph draw option with others; - correct positioning of custom axis labels; - correctly toggle lin/log axes in lego plot; - let correctly change marker attributes interactively ; - monitoring mode in draw.htm page; - zooming in colz palette; - support both 9.x and 10.x jsdom version in Node.js (#149); - draw axis main line with appropriate attributes (#150); - use axis color when drawing grids lines (#150); - when set pad logx/logy, reset existing user ranges in pad; - avoid too deep calling stack when drawing many graphs or histos (#154); - correctly (re)draw tooltips on canvas with many subpads. ## Code Examples. - New graphics tutorial AtlasExample.C illustrating the ATLAS style.; - New TLazyDS tutorial added tdf015_LazyDataSource.C.; - Show how to inspect a `TCutFlowReport` object. ## Class Reference Guide. - Replace low resolution images with bigger ones more suited for modern screens. ## Build System and Configuration. - ROOT can now be built against an externally built llvm and clang (llvm can be used unpatched, clang still require ROOT specific patches). The options are builtin_llvm and builtin_clang both defaulting to ON.; - Update RConfigure.h with R__HAS__VDT if the package is found/builtin; - CMake exported targets now have the `INTERFACE_INCLUDE_DIRECTORIES` property set ([ROOT-8062](https://sft.its.cern.ch/jira/browse/ROOT-8062)).; - The `-fPIC` compile flag is no longer propagated to dependent projects via `CMAKE_CXX_FLAGS` ([ROOT-9212](https://sft.its.cern.ch/jira/browse/ROOT-9212)).; - Several builtins have updated versions:; - OpenSSL was updated from 1.0.2d to 1.0.2.o (latest lts release, [ROOT-9359](https://sft.its.cern.ch/jira/browse/ROOT-9359)); - Davix was updated from 0.6.4 to 0.6.7 (support for OpenSSL 1.1, [ROOT-9353](https://sft.its.cern.ch/jira/browse",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:17533,Guid,Guide,17533,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['Guid'],['Guide']
Usability,"will not conflict; during assembly. This is used to implement `GCC's %= special format; string <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html>`_.; - ``${:comment}``: Expands to the comment character of the current target's; assembly dialect. This is usually ``#``, but many targets use other strings,; such as ``;``, ``//``, or ``!``.; - ``${:private}``: Expands to the assembler private label prefix. Labels with; this prefix will not appear in the symbol table of the assembled object.; Typically the prefix is ``L``, but targets may use other strings. ``.L`` is; relatively popular. LLVM's support for inline asm is modeled closely on the requirements of Clang's; GCC-compatible inline-asm support. Thus, the feature-set and the constraint and; modifier codes listed here are similar or identical to those in GCC's inline asm; support. However, to be clear, the syntax of the template and constraint strings; described here is *not* the same as the syntax accepted by GCC and Clang, and,; while most constraint letters are passed through as-is by Clang, some get; translated to other codes when converting from the C source to the LLVM; assembly. An example inline assembler expression is:. .. code-block:: llvm. i32 (i32) asm ""bswap $0"", ""=r,r"". Inline assembler expressions may **only** be used as the callee operand; of a :ref:`call <i_call>` or an :ref:`invoke <i_invoke>` instruction.; Thus, typically we have:. .. code-block:: llvm. %X = call i32 asm ""bswap $0"", ""=r,r""(i32 %Y). Inline asms with side effects not visible in the constraint list must be; marked as having side effects. This is done through the use of the; '``sideeffect``' keyword, like so:. .. code-block:: llvm. call void asm sideeffect ""eieio"", """"(). In some cases inline asms will contain code that will not work unless; the stack is aligned in some way, such as calls or SSE instructions on; x86, yet will not contain code that does that alignment within the asm.; The compiler should make conservative assumptions ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:208159,clear,clear,208159,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['clear'],['clear']
Usability,"wing z axis in lego plot; 6. Fix - error in TGeoCtub shape creation; 7. Fix - error in pcon/pgon shapes when Rmin===0. ## Changes in 4.5.1; 1. Fix - correctly handle ^2..^9 in TFormula equations; 2. Fix - support TMath::Gaus in TFormula; 3. Fix - correctly display ^2 and ^3 in SVG text output; 4. Fix - do not show tooltips for empty TProfile bins; 5. Fix - statbox toggling was not working on subpads; 6. Fix - positioning of 3D objects in Webkit browsers in complex layouts; 7. Fix - difference in TF1 between ROOT5/6 (#54). ## Changes in 4.5.0; 1. Zooming with mouse wheel; 2. Context menus for many different objects attributes are provided; 3. Context menu for every drawn object can be activated via toolbar button; 4. Support browsing of TTask and derived classes (#40); 5. Apply user range for drawing TH1/TH2 histograms, also when superimposed (#44); 6. Implement scaling factor like x10^3 on the vertical axes; 7. Provide shortcut buttons for each subpad; 8. Implement simple drawing for TBox, TWbox, TSliderBox classes. ## Changes in 4.4.4; 1. Fix - toggling of statbox was not working in all situations; 2. Fix - for mouse rect zooming use only left mouse button; 3. Fix - correctly draw TH2 with lego option, when histogram has negative bin content; 4. Fix - log axis drawing with no visible ticks. ## Changes in 4.4.3; 1. Fix - wrong selection of TH1 Y axis range when errors are displayed (#44); 2. Fix - apply user range for TH1 X-axis zooming (#44); 3. Fix - protect against pathological case of 1-bin histogram; 4. Fix - use error plot by default in TH1 only when positive sumw2 entry exists; 5. Fix - for TH2 box draw option draw at least 1px rect for non-empty bin; 6. Fix - support transparency (alpha) in TColor (#45); 7. Fix - correct tooltip handling for graphs with lines and markers; 8. Fix - interactive zooming in TH2 when doing histogram update. ## Changes in 4.4.2; 1. Fix - statistic collection for TH2; 2. Fix - correct handling of empty TList in browser/inspector; 3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:54928,simpl,simple,54928,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,"with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax {State1;State2} where State1; and State2 are the state names of the two spitting categories. Additional; functionality exists to work with multiple prototype p.d.f.s simultaneously. ; Improved infrastructure for caching p.d.f and functions. The infrastructure that exists for caching p.d.f.s, i.e. p.d.f that precalculate their value; for all observable values at one and cache those in a histogram that is returned as p.d.f shape; (with optional interpolation), has been expanded. This infrastructure comprises RooAbsCached; the base class for all caching p.d.fs, RooAbsSelfCachedPdf a base class for end-user; caching p.d.f implementations that simply cache the result of evaluate() and RooCachedPdf; that can wrap and cache any input p.d.f specified in its constructor. . By default a p.d.f is sampled and cached in all observables in any; given use context, with no need to specify what those are in advance.; The internal code has also been changed such that all cache; histograms now store pre-normalized p.d.f, which is more efficient; than 'raw' p.d.f histograms that are explicitly post-normalized; through integration. Multiple different use cases (e.g. definitions; of what are observables vs parameters) can be cached; simultaneously. Now it is also possible to specify that p.d.f.s; should be sampled and cached in one or more parameter dimensions; in addition to the automatically determined set of observables.; as well. Also a complete new line of classes with similar functionality has been added inheriting from RooAbsReal.; These are RooAbsCachedReal,RooAbsSelfCachedReal and RooCachedReal. A newly; added class RooHistFunc presents these shapes and is capable of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:13917,simpl,simply,13917,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['simpl'],['simply']
Usability,"wn change?. * Any time you learn of a serious problem with a change, you should revert it.; We strongly encourage ""revert to green"" as opposed to ""fixing forward"". We; encourage reverting first, investigating offline, and then reapplying the; fixed patch - possibly after another round of review if warranted.; * If you break a buildbot in a way which can't be quickly fixed, please revert.; * If a test case that demonstrates a problem is reported in the commit thread,; please revert and investigate offline.; * If you receive substantial :ref:`post-commit review <post_commit_review>`; feedback, please revert and address said feedback before recommitting.; (Possibly after another round of review.); * If you are asked to revert by another contributor, please revert and discuss; the merits of the request offline (unless doing so would further destabilize; tip of tree). When should you revert someone else's change?. * In general, if the author themselves would revert the change per these; guidelines, we encourage other contributors to do so as a courtesy to the; author. This is one of the major cases where our norms differ from others;; we generally consider reverting a normal part of development. We don't; expect contributors to be always available, and the assurance that a; problematic patch will be reverted and we can return to it at our next; opportunity enables this. What are the expectations around a revert?. * Use your best judgment. If you're uncertain, please start an email on; the commit thread asking for assistance. We aren't trying to enumerate; every case, but rather give a set of guidelines.; * You should be sure that reverting the change improves the stability of tip; of tree. Sometimes reverting one change in a series can worsen things; instead of improving them. We expect reasonable judgment to ensure that; the proper patch or set of patches is being reverted.; * The commit message for the reverting commit should explain why patch; is being reverted.; * It ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:20250,guid,guidelines,20250,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guidelines']
Usability,"workers at startup.;  E.g.;        1. To; start max 5 workers;             ; TProof::Open(""<master>"",""workers=5"");        2. To; start max 2 workers per physical machine;             ; TProof::Open(""<master>"",""workers=2x"");      This is useful in general when; running tests (equivalent but quicker then full startup;      followed by; TProof::SetParallel(n) or TProof::DeactivateWorker(...)).; Add support for the worker SysInfo_t in TSlaveInfo; (obtained via TProof::GetListOfSlaveInfos()); Add new submerger functionality to speed up the merging; phase. At the end of the query, a set of workers are promoted; submergers and assigned a sub-set of workers to merge. Once each; sub-merger has merged its sub-set of workers, it sends its result to; the master, which merges the partial results into the final; set of results.; The determination of the sub-mergers is always done dynamically, based; on the recent performance of workers. An optimal (i.e. giving the; highest speed-up) number can be calculated analytically under simple; assumptions.; Merging via submergers is by default disabled. To enable it, with the; optimal number of sub-mergers, one should set the integer parameter; 'PROOF_UseMergers' to 0, i.e.                     ; proof->SetParameter(""PROOF_UseMergers"", 0). To force S sub-mergers (regardless of the optimal number) do.                     ; proof->SetParameter(""PROOF_UseMergers"", S). The new functionality can be tested in tutorials by adding the argument; 'submergers' to runProof, e.g. .        ;        ;      root [0] .L; tutorials/proof/runProof.C+ ;        ;        ;      root [1]; runProof(""simple(nhist=10000,submergers)"") . (see the top of tutorials/proof/runProof.C for additional options). A test for the submerger functionality has also been added to; test/stressProof.cxx .; In PROOF-Lite, add the possibility for the administrator; to control the number of workers. This is done using; the rootrc variable ProofLite.MaxWorkers, which is read out of; /etc/s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:2464,simpl,simple,2464,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,1,['simpl'],['simple']
Usability,"works amazingly well in many cases; and falls down in others. Please consult the information on this page on making; the best use of scan-build, which includes getting it to work when the; aforementioned hack fails to work. Viewing static analyzer results in a web browser. Contents. Getting Started. Basic Usage; For Windows Users; Other Options; Output of scan-build. Recommended Usage Guidelines. Always Analyze a Project in its ""Debug"" Configuration; Use Verbose Output when Debugging scan-build; Run './configure' through scan-build. Analyzing iPhone Projects. Getting Started; The scan-build command can be used to analyze an entire project by; essentially interposing on a project's build process. This means that to run the; analyzer using scan-build, you will use scan-build to analyze; the source files compiled by gcc/clang during a project build.; This means that any files that are not compiled will also not be analyzed.; Basic Usage; Basic usage of scan-build is designed to be simple: just place the; word ""scan-build"" in front of your build command:. $ scan-build make; $ scan-build xcodebuild. In the first case scan-build analyzes the code of a project built; with make and in the second case scan-build analyzes a project; built using xcodebuild.; Here is the general format for invoking scan-build:. $ scan-build [scan-build options] <command> [command options]. Operationally, scan-build literally runs <command> with all of the; subsequent options passed to it. For example, one can pass -j4 to; make get a parallel build over 4 cores:. $ scan-build make -j4. In almost all cases, scan-build makes no effort to interpret the; options after the build command; it simply passes them through. In general,; scan-build should support parallel builds, but not distributed; builds.; It is also possible to use scan-build to analyze specific; files:. $ scan-build gcc -c t1.c t2.c. This example causes the files t1.c and t2.c to be analyzed. For Windows Users; Windows users must have P",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:1992,simpl,simple,1992,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['simpl'],['simple']
Usability,"ws how we use the LogError routines. When called, this function; expects that the current token is a '(' token, but after parsing the; subexpression, it is possible that there is no ')' waiting. For example,; if the user types in ""(4 x"" instead of ""(4)"", the parser should emit an; error. Because errors can occur, the parser needs a way to indicate that; they happened: in our parser, we return null on an error. 2) Another interesting aspect of this function is that it uses recursion; by calling ``ParseExpression`` (we will soon see that; ``ParseExpression`` can call ``ParseParenExpr``). This is powerful; because it allows us to handle recursive grammars, and keeps each; production very simple. Note that parentheses do not cause construction; of AST nodes themselves. While we could do it this way, the most; important role of parentheses are to guide the parser and provide; grouping. Once the parser constructs the AST, parentheses are not; needed. The next simple production is for handling variable references and; function calls:. .. code-block:: c++. /// identifierexpr; /// ::= identifier; /// ::= identifier '(' expression* ')'; static std::unique_ptr<ExprAST> ParseIdentifierExpr() {; std::string IdName = IdentifierStr;. getNextToken(); // eat identifier. if (CurTok != '(') // Simple variable ref.; return std::make_unique<VariableExprAST>(IdName);. // Call.; getNextToken(); // eat (; std::vector<std::unique_ptr<ExprAST>> Args;; if (CurTok != ')') {; while (true) {; if (auto Arg = ParseExpression()); Args.push_back(std::move(Arg));; else; return nullptr;. if (CurTok == ')'); break;. if (CurTok != ','); return LogError(""Expected ')' or ',' in argument list"");; getNextToken();; }; }. // Eat the ')'.; getNextToken();. return std::make_unique<CallExprAST>(IdName, std::move(Args));; }. This routine follows the same style as the other routines. (It expects; to be called if the current token is a ``tok_identifier`` token). It; also has recursion and error handling. One interes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:9513,simpl,simple,9513,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability,"www.hpc.nec/documents/guide/pdfs/Aurora_ISA_guide.pdf>`_; * `NEC SX-Aurora TSUBASA manuals and documentation <https://www.hpc.nec/documentation>`_. X86; ---. * `AMD processor manuals <http://developer.amd.com/resources/developer-guides-manuals/>`_; * `Intel 64 and IA-32 manuals <http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html>`_; * `Intel Itanium documentation <http://www.intel.com/design/itanium/documentation.htm?iid=ipp_srvr_proc_itanium2+techdocs>`_; * `X86 and X86-64 SysV psABI <https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI>`_; * `Calling conventions for different C++ compilers and operating systems <http://www.agner.org/optimize/calling_conventions.pdf>`_. XCore; -----. * `The XMOS XS1 Architecture (ISA) <https://www.xmos.ai/download/The-XMOS-XS1-Architecture%281.0%29.pdf>`_; * `The XMOS XS2 Architecture (ISA) <https://www.xmos.ai/download/xCORE-200:-The-XMOS-XS2-Architecture-%28ISA%29%281.1%29.pdf>`_; * `Tools Development Guide (includes ABI) <https://www.xmos.ai/download/Tools-Development-Guide%282.1%29.pdf>`_. Hexagon; -------. * `Hexagon Programmer's Reference Manuals and Hexagon ABI Specification (registration required, free sign-up) <https://developer.qualcomm.com/software/hexagon-dsp-sdk/tools>`_. Other relevant lists; --------------------. * `GCC reading list <http://gcc.gnu.org/readings.html>`_. ABI; ===. * `System V Application Binary Interface <http://www.sco.com/developers/gabi/latest/contents.html>`_; * `Itanium C++ ABI <http://itanium-cxx-abi.github.io/cxx-abi/>`_ (This is used for all non-Windows targets.). Linux; -----. * `Linux extensions to gabi <https://github.com/hjl-tools/linux-abi/wiki/Linux-Extensions-to-gABI>`_; * `64-Bit ELF V2 ABI Specification: Power Architecture <https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture>`_. * `OpenPOWER ELFv2 Errata: ELFv2 ABI Version 1.4 <https://openpowerfoundation.org/?resource_lib=openpower-elfv2-errata-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst:6641,Guid,Guide,6641,interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,1,['Guid'],['Guide']
Usability,"x::InvertChol() and SMatrix & SMatrix::InverseChol(ifail) for the inversion of a symmetric positive defined matrix. New specialized implementation exists up to matrices with sizes 6x6. The speed is comparable to the Cramer method (SMatrix::InvertFast), but with much better accuracy. The new InvertChol method is in any case faster than the general inverter method for all symmetric matrices (SMatrix::Invert), which uses the Bunch-Kaufman decomposition.; Add also a new free function, ROOT::Math::SolveChol for solving a symmetric linear system. For users who need the solution, using this functions avoid for them performing the inversion and then a matrix multiplication. Add support in the SMatrix class for operator m[i][j]; Add in the dictionary the typedefs for some square and symmetrix matrices based on double and floats (up to size 7) defined in the file Math/SMatrixDfwd and Math/SMatrixFfwd; . Minuit. Apply various improvements in the TMInuitMInimizer class thanks to the feedback of Alfio Lazzaro:; ; implement Hess() and CovMatrixStatus();; add new method based on SEEK. The Tolerance() value can be used to specify the volume (in unit of sigma) for searching for the global minimum; fix some of the methods, like NCalls() and GlobalCC(); . Minuit2. Apply some fixes in MnHesse and MnPosDef classes to check correctly variables to not be zero.; (use same checks as in F77Minuit); ; Fix a bug introduced in DavidonErrorCalculator when checking for delgam. Negative values are allowed. This fixes a test problem given privately by A. Suter.; ; Uses also a tighter condition on edm when exiting the iterations (factor of 5 smaller). This is more consistent with conditions used by F77Minuit.; ; Fix a bug in MnCross in the standalone version of Minuit (when WARNINGMSG was not defined).; ; Fix a bug in the sign of the derivative for sine transformation which are used with double bound parameters. The bug could affect the minimization of function with user provided gradient and bound ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:5065,feedback,feedback,5065,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,1,['feedback'],['feedback']
Usability,"xTrack-1);; ntrack = nt;; sumstat = 0;; // set the values in each track; for (Int_t n=0;n<nt;n++) {; stat[n] = n%3;; sign[n] = i%2;; px[n] = gRandom->Gaus(0,1);; py[n] = gRandom->Gaus(0,2);; pz[n] = gRandom->Gaus(10,5);; zv[n] = gRandom->Gaus(100,2);; chi2[n] = gRandom->Gaus(0,.01);; sumstat += chi2[n];; pt[n] = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);; }; t3->Fill();; t3f->Fill();; }; // Write the two files; t3->Print();; f.cd();; t3->Write();; fr.cd();; t3f->Write();; }. // Function to read the two files and add the friend; void tree3r() {; TFile *f = new TFile(""tree3.root"");; TTree *t3 = (TTree*)f->Get(""t3"");; // Add the second tree to the first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Belo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58014,simpl,simplified,58014,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simplified']
Usability,"xample of TSelector implementation to do generic; processing with the test 'Event' structure.; See tutorials/proof/runProof.C, option ""event"", for an; example of how to run this selector. \defgroup tutorial_ProofEventProc ProofEventProc; \ingroup tutorial_proof; \brief Selector to process trees containing Event structures. Example of TSelector implementation to process trees; containing 'Event' structures, e.g. the files under; http://root.cern/files/data .; See tutorials/proof/runProof.C, option ""eventproc"", for; an example of how to run this selector. \defgroup tutorial_ProofFriends ProofFriends; \ingroup tutorial_proof; \brief Selector to process tree friends. Example of TSelector implementation to process tree friends in PROOF.; See tutorials/proof/runProof.C, option ""eventproc"", for; an example of how to run this selector. \defgroup tutorial_ProofNtuple ProofNtuple; \ingroup tutorial_proof; \brief Selector to fill a simple ntuple. Example of TSelector implementation to do generic processing; (filling a simple ntuple, in this case).; See tutorials/proof/runProof.C, option ""ntuple"", for an; example of how to run this selector. \defgroup tutorial_ProofPythia ProofPythia; \ingroup tutorial_proof; \brief Selector to generate Monte Carlo events with Pythia8. Example of TSelector implementation to do a Monte Carlo; generation using Pythia8.; See tutorials/proof/runProof.C, option ""pythia8"", for an; example of how to run this selector. \defgroup tutorial_ProofSimple ProofSimple; \ingroup tutorial_proof; \brief Selector to fill a set of histograms. Example of TSelector implementation to do generic processing (filling a; set of histograms in this case).; See tutorials/proof/runProof.C, option ""simple"", for an; example of how to run this selector. \defgroup tutorial_ProofSimpleFile ProofSimpleFile; \ingroup tutorial_proof; \brief Selector to fill a set of histograms and merging via file. Example of TSelector implementation to do generic processing; (filling a set of histog",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/index.md:1442,simpl,simple,1442,tutorials/proof/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/index.md,1,['simpl'],['simple']
Usability,"xible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin, this implies that the Clang driver also subsumes the gcc; driver-driver, which is used to implement support for building universal; images (binaries and object files). This also implies that the driver; should be able to call the language specific compiler",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:2167,Simpl,Simple,2167,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['Simpl'],['Simple']
Usability,"xplain to reviewers and future readers of the code why; the change was made. .. code:: console. $ git checkout -b myfirstpatch; $ git commit -am ""[Diagnostic] Clarify -Winfinite-recursion message"". Now we're ready to send this change out into the world! By the way,; There is an unwritten convention of using tag for your commit. Tags; usually represent modules that you intend to modify. If you don't know; the tags for your modules, you can look at the commit history :; https://github.com/llvm/llvm-project/commits/main. Code review; ===========. Finding a reviewer; ------------------. Changes can be reviewed by anyone in the LLVM community who has commit; access.For larger and more complicated changes, it's important that the; reviewer has experience with the area of LLVM and knows the design goals; well. The author of a change will often assign a specific reviewer (git; blame and git log can be useful to find one). As our change is fairly simple, we'll add the cfe-commits mailing list; as a subscriber; anyone who works on clang can likely pick up the; review. (For changes outside clang, llvm-commits is the usual list. See; `http://lists.llvm.org/ <http://lists.llvm.org/mailman/listinfo>`__ for; all the \*-commits mailing lists). Uploading a change for review; -----------------------------. LLVM code reviews happen through pull-request on GitHub, see; :ref:`GitHub <github-reviews>` documentation for how to open; a pull-request on GitHub. Review process; --------------. When you open a pull-request, some automation will add a comment and; notify different member of the projects depending on the component you; changed.; Within a few days, someone should start the review. They may add; themselves as a reviewer, or simply start leaving comments. You'll get; another email any time the review is updated. The details are in the; `https://llvm.org/docs/CodeReview/ <https://llvm.org/docs/CodeReview.html>`__. Comments; ~~~~~~~~. The reviewer can leave comments on the change, and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:9311,simpl,simple,9311,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['simpl'],['simple']
Usability,"xpression. Because we don't have anything better; to return, we'll just define the loop as always returning 0.0. In the; future when we have mutable variables, it will get more useful. As before, let's talk about the changes that we need to Kaleidoscope to; support this. Lexer Extensions for the 'for' Loop; -----------------------------------. The lexer extensions are the same sort of thing as for if/then/else:. .. code-block:: c++. ... in enum Token ...; // control; tok_if = -6, tok_then = -7, tok_else = -8,; tok_for = -9, tok_in = -10. ... in gettok ...; if (IdentifierStr == ""def""); return tok_def;; if (IdentifierStr == ""extern""); return tok_extern;; if (IdentifierStr == ""if""); return tok_if;; if (IdentifierStr == ""then""); return tok_then;; if (IdentifierStr == ""else""); return tok_else;; if (IdentifierStr == ""for""); return tok_for;; if (IdentifierStr == ""in""); return tok_in;; return tok_identifier;. AST Extensions for the 'for' Loop; ---------------------------------. The AST node is just as simple. It basically boils down to capturing the; variable name and the constituent expressions in the node. .. code-block:: c++. /// ForExprAST - Expression class for for/in.; class ForExprAST : public ExprAST {; std::string VarName;; std::unique_ptr<ExprAST> Start, End, Step, Body;. public:; ForExprAST(const std::string &VarName, std::unique_ptr<ExprAST> Start,; std::unique_ptr<ExprAST> End, std::unique_ptr<ExprAST> Step,; std::unique_ptr<ExprAST> Body); : VarName(VarName), Start(std::move(Start)), End(std::move(End)),; Step(std::move(Step)), Body(std::move(Body)) {}. Value *codegen() override;; };. Parser Extensions for the 'for' Loop; ------------------------------------. The parser code is also fairly standard. The only interesting thing here; is handling of the optional step value. The parser code handles it by; checking to see if the second comma is present. If not, it sets the step; value to null in the AST node:. .. code-block:: c++. /// forexpr ::= 'for' identifier '",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:16825,simpl,simple,16825,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['simpl'],['simple']
Usability,"xpressions to retain their same meaning,; while enabling the ability to explicitly create memory location descriptions in; non-default address spaces and generalizing the power of composite location; descriptions to any kind of location description. For those familiar with the definition of location descriptions in DWARF Version; 5, the definitions in these extensions are presented differently, but does in; fact define the same concept with the same fundamental semantics. However, it; does so in a way that allows the concept to extend to support address spaces,; bit addressing, the ability for composite location descriptions to be composed; of any kind of location description, and the ability to support objects located; at multiple places. Collectively these changes expand the set of architectures; that can be supported and improves support for optimized code. Several approaches were considered, and the one presented, together with the; extensions it enables, appears to be the simplest and cleanest one that offers; the greatest improvement of DWARF's ability to support debugging optimized GPU; and non-GPU code. Examining the GDB debugger and LLVM compiler, it appears only; to require modest changes as they both already have to support general use of; location descriptions. It is anticipated that will also be the case for other; debuggers and compilers. GDB has been modified to evaluate DWARF Version 5 expressions with location; descriptions as stack entries and with implicit conversions. All GDB tests have; passed, except one that turned out to be an invalid test case by DWARF Version 5; rules. The code in GDB actually became simpler as all evaluation is done on a; single stack and there was no longer a need to maintain a separate structure for; the location description results. This gives confidence in backwards; compatibility. See :ref:`amdgpu-dwarf-expressions` and nested sections. This extension is separately described at *Allow Location Descriptions on the; DWA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:7046,simpl,simplest,7046,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simplest']
Usability,"xtract) # now empty (or invalid); 0; >>> extract = boost.any_cast[std.vector[int]](val); >>> list(extract); [0, 1, 2, 3, 4, 5, 6, ..., 97, 98, 99]; >>>. Of course, there is no reason to use Boost from Python (in fact, this example; calls out for :doc:`pythonizations <pythonizations>`), but it shows that; cppyy seamlessly supports many advanced C++ features. cppyy is available for both `CPython`_ (v2 and v3) and `PyPy`_, reaching; C++-like performance with the latter.; It makes judicious use of precompiled headers, dynamic loading, and lazy; instantiation, to support C++ programs consisting of millions of lines of; code and many thousands of classes.; cppyy minimizes dependencies to allow its use in distributed, heterogeneous,; development environments. .. _Cling: https://github.com/vgvassilev/cling; .. _tutorial: https://github.com/wlav/cppyy/blob/master/doc/tutorial/CppyyTutorial.ipynb; .. _`PyHPC'16 paper`: http://wlav.web.cern.ch/wlav/Cppyy_LavrijsenDutta_PyHPC16.pdf; .. _`CAAS presentation`: https://www.youtube.com/watch?v=stMD7VDWlVU; .. _`Jason Turner's`: https://www.youtube.com/watch?v=TL83P77vZ1k; .. _`Boost`: http://www.boost.org/; .. _`CPython`: http://python.org; .. _`PyPy`: http://pypy.org. .. only: not latex. Contents:. .. toctree::; :maxdepth: 1. changelog; license. .. toctree::; :caption: Getting Started; :maxdepth: 1. installation; starting; examples; bugs. .. toctree::; :caption: Features; :maxdepth: 1. toplevel; basic_types; strings; classes; functions; type_conversions; stl; exceptions; python; numba; cuda; lowlevel; misc; debugging. .. toctree::; :caption: Redistribution; :maxdepth: 1. pythonizations; utilities; cmake_interface. .. toctree::; :caption: Developers; :maxdepth: 1. packages; repositories; testing. .. toctree::; :caption: Background; :maxdepth: 1. history; philosophy. Bugs and feedback; -----------------. Please report bugs or requests for improvement on the `issue tracker`_. .. _`issue tracker`: https://github.com/wlav/cppyy/issues; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/index.rst:5728,feedback,feedback,5728,bindings/pyroot/cppyy/cppyy/doc/source/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/index.rst,1,['feedback'],['feedback']
Usability,"y be specified; ---------------------------------. All of the `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ virtual methods; default to providing :ref:`chaining <aliasanalysis-chaining>` to another alias; analysis implementation, which ends up returning conservatively correct; information (returning ""May"" Alias and ""Mod/Ref"" for alias and mod/ref queries; respectively). Depending on the capabilities of the analysis you are; implementing, you just override the interfaces you can improve. .. _aliasanalysis-chaining:. ``AliasAnalysis`` chaining behavior; -----------------------------------. Every alias analysis pass chains to another alias analysis implementation (for; example, the user can specify ""``-basic-aa -ds-aa -licm``"" to get the maximum; benefit from both alias analyses). The alias analysis class automatically; takes care of most of this for methods that you don't override. For methods; that you do override, in code paths that return a conservative MayAlias or; Mod/Ref result, simply return whatever the superclass computes. For example:. .. code-block:: c++. AliasResult alias(const Value *V1, unsigned V1Size,; const Value *V2, unsigned V2Size) {; if (...); return NoAlias;; ... // Couldn't determine a must or no-alias result.; return AliasAnalysis::alias(V1, V1Size, V2, V2Size);; }. In addition to analysis queries, you must make sure to unconditionally pass LLVM; `update notification`_ methods to the superclass as well if you override them,; which allows all alias analyses in a change to be updated. .. _update notification:. Updating analysis results for transformations; ---------------------------------------------. Alias analysis information is initially computed for a static snapshot of the; program, but clients will use this information to make transformations to the; code. All but the most trivial forms of alias analysis will need to have their; analysis results updated to reflect the changes made by these transformations. Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:13092,simpl,simply,13092,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['simpl'],['simply']
Usability,"y building the project ""check-all"".; For more information about testing, see the :doc:`TestingGuide`. Cross compiling; ===============. See `this wiki page <https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/CrossCompiling>`_ for; generic instructions on how to cross-compile with CMake. It goes into detailed; explanations and may seem daunting, but it is not. On the wiki page there are; several examples including toolchain files. Go directly to the; ``Information how to set up various cross compiling toolchains`` section; for a quick solution. Also see the `LLVM-related variables`_ section for variables used when; cross-compiling. Embedding LLVM in your project; ==============================. From LLVM 3.5 onwards the CMake build system exports LLVM libraries as; importable CMake targets. This means that clients of LLVM can now reliably use; CMake to develop their own LLVM-based projects against an installed version of; LLVM regardless of how it was built. Here is a simple example of a CMakeLists.txt file that imports the LLVM libraries; and uses them to build a simple application ``simple-tool``. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(SimpleProject). find_package(LLVM REQUIRED CONFIG). message(STATUS ""Found LLVM ${LLVM_PACKAGE_VERSION}""); message(STATUS ""Using LLVMConfig.cmake in: ${LLVM_DIR}""). # Set your project compile flags.; # E.g. if using the C++ header files; # you will need to enable C++11 support; # for your compiler. include_directories(${LLVM_INCLUDE_DIRS}); separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_definitions(${LLVM_DEFINITIONS_LIST}). # Now build our tools; add_executable(simple-tool tool.cpp). # Find the libraries that correspond to the LLVM components; # that we wish to use; llvm_map_components_to_libnames(llvm_libs support core irreader). # Link against LLVM libraries; target_link_libraries(simple-tool ${llvm_libs}). The ``find_package(...)`` directive when used in CO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:41132,simpl,simple,41132,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['simpl'],['simple']
Usability,"y condition; * [[#14910](https://github.com/root-project/root/issues/14910)] - hadd issue when using parallelization together with indirect file; * [[#14902](https://github.com/root-project/root/issues/14902)] - compilation error; * [[#14863](https://github.com/root-project/root/issues/14863)] - [hist] TH1::SaveAs missing default option argument causes compilation errors; * [[#14855](https://github.com/root-project/root/issues/14855)] - TRatioPlot crashes if loaded from the file; * [[#14842](https://github.com/root-project/root/issues/14842)] - TRatioplot gives ""different"" results with Web Graphics; * [[#14838](https://github.com/root-project/root/issues/14838)] - Problems with Confidence Band of TRatioPlot; * [[#14801](https://github.com/root-project/root/issues/14801)] - TEfficiency drawing to .C is broken; * [[#14793](https://github.com/root-project/root/issues/14793)] - 6.26 cannot read file written with 6.30.4; * [[#14772](https://github.com/root-project/root/issues/14772)] - [cling] Undocumented behaviour of root macro_C.so; * [[#14767](https://github.com/root-project/root/issues/14767)] - rootn.exe instant crash on startup; * [[#14765](https://github.com/root-project/root/issues/14765)] - TGenPhaseSpace weight normalization; * [[#14748](https://github.com/root-project/root/issues/14748)] - [ntuple] `Show` and `PrintInfo` does not work for friend RNTuples; * [[#14601](https://github.com/root-project/root/issues/14601)] - std::source_location not found when running with c++20 enabled; * [[#14599](https://github.com/root-project/root/issues/14599)] - The example th2polyUSA.C needs re-labelling; * [[#14598](https://github.com/root-project/root/issues/14598)] - A ""printf"" change the behaviour of a macro ... ; * [[#14595](https://github.com/root-project/root/issues/14595)] - Problem when creating dictionary in Osx 12.7, Xcode 14.2; * [[#14594](https://github.com/root-project/root/issues/14594)] - Provide `file.root` request in THttpServer; * [[#14593](https://githu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:29145,Undo,Undocumented,29145,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['Undo'],['Undocumented']
Usability,"y directives like the following to redefine the parameter substitutions as; desired before each use of ``%{check}`` in a ``RUN:`` line:. .. code-block:: llvm. ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd; ; REDEFINE: %{fcflags} = -check-prefix=SIMD; ; RUN: %{check}. ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu -fopenmp-simd; ; REDEFINE: %{fcflags} = -check-prefix=SIMD; ; RUN: %{check}. ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0; ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD; ; RUN: %{check}. ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu; ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD; ; RUN: %{check}. Besides providing initial values, the initial ``DEFINE:`` directives for the; parameter substitutions in the above example serve a second purpose: they; establish the substitution order so that both ``%{check}`` and its parameters; expand as desired. There's a simple way to remember the required definition; order in a test file: define a substitution before any substitution that might; refer to it. In general, substitution expansion behaves as follows:. - Upon arriving at each ``RUN:`` line, lit expands all substitutions in that; ``RUN:`` line using their current values from the substitution list. No; substitution expansion is performed immediately at ``DEFINE:`` and; ``REDEFINE:`` directives except ``%(line)``, ``%(line+<number>)``, and; ``%(line-<number>)``.; - When expanding substitutions in a ``RUN:`` line, lit makes only one pass; through the substitution list by default. In this case, a substitution must; have been inserted earlier in the substitution list than any substitution; appearing in its value in order for the latter to expand. (For greater; flexibility, you can enable multiple passes through the substitution list by; setting `recursiveExpansionLimit`_ in a lit configuration file.); - While lit configuration files can insert anywhere in the substitution list,; the insertion behavior of the `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:30833,simpl,simple,30833,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['simpl'],['simple']
Usability,"y for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int shadow; // determines whether shadow will be drawn (no shadow, shadow),; // for rainbowed display modes with shading according to light; int shading; // determines whether the picture will shaded, smoothed (no shading,; // shading), for rainbowed display modes only; int bezier; // determines Bezier interpolation (applies only for simple display; // modes group for grid, x_lines, y",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:78374,simpl,simple,78374,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,"y showing you how to use ROOT interactively. There are two; examples to click through and learn how to use the GUI. We continue by; using the command line, and explaining the coding conventions, global; variables and the environment setup. If you have not installed ROOT,; you can do so by following the instructions in the appendix, or on the; ROOT web site: <http://root.cern.ch/root/Availability.html>. ## Setting the Environment Variables. Before you can run ROOT you need to set the environment variable; `ROOTSYS` and change your path to include `root/bin` and library path; variables to include `root/lib`. Please note: the syntax is for; `bash`, if you are running `tcsh` you will have to use `setenv`; instead of `export`. 1. Define the variable \$ROOTSYS to the directory where you unpacked; the ROOT:. ```; $ export ROOTSYS=$HOME/root; ```. 2. Add ROOTSYS/bin to your PATH:. ```; $ export PATH=$PATH:$ROOTSYS/bin; ```. 3. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the; library path:. ```; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; ```. On AIX, before executing the interactive module, you must set the; library path:. ```; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; ```. On Linux, Solaris, Alpha OSF and SGI, before executing the interactive; module, you must set the library path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/thisroot.[c]sh` scripts will set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:994,UX,UX,994,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['UX'],['UX']
Usability,"y those; of Clang itself. They are entirely within the Clang *project*,; regardless of the version control scheme. Core Clang Tools; ================. The core set of Clang tools that are within the main repository are; tools that very specifically complement, and allow use and testing of; *Clang* specific functionality. ``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by syntax checking specific files; in a fast, command line interface. It can also accept flags to re-display the; diagnostics in different formats with different flags, suitable for use driving; an IDE or editor. Furthermore, it can be used in fixit-mode to directly apply; fixit-hints offered by clang. See :doc:`HowToSetupToolingForLLVM` for; instructions on how to setup and used `clang-check`. ``clang-format``; ----------------. Clang-format is both a :doc:`library <LibFormat>` and a :doc:`stand-alone tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:3440,guid,guides,3440,interpreter/llvm-project/clang/docs/ClangTools.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst,1,['guid'],['guides']
Usability,"y time, but you must; set the clip current to see the effect. #### Manipulators. *Manipulators* are GUI ‘widgets' or controls attached to a 3D object in; the viewer, allowing a direct manipulation of the object's geometry.; There are three manipulators for the three basic geometries; transformations. In each case, the *manipulator* consists of three; components, one for each local axis of the object, shown in standard; colors: red (X), green (Y) and blue (Z). ![GL Viewer object manipulators](pictures/030000DE.png). Activate the *manipulator* by moving the mouse over one of these; components (which turns yellow to indicate active state). Click with; left mouse and drag this active component to perform the manipulation.; Toggle between the *manipulator* types using the ‘x', ‘c', ‘v' keys; while the mouse cursor is above the manipulator. Note: Manipulators; cannot be controlled via the API at present. #### Guides. Guides are visual aids drawn into the viewer world. Controls for these; are under the ""Guides"" tab:. Viewer Controls Pane Guides Tab. Axes show the world (global) frame *coordinate*directions: X (red), Y; (green) and Z (blue). The negative portion of the *axis* line is shown; in dark color, the positive in bright. The *axis* name and minimum /; maximum values are labeled in the same color. There are three options; for *axes* drawing - selected by radio buttons:. - None - not drawn (default). - Edge - draw axes on the (minimum) edge of the scene extents box. - Origin - drawn axes through the origin. For *edge axes*, the zero value for each axis is marked on the axis line; with a colored sphere. For *origin axes,* a single white sphere is shown; at the origin. *Edge axes* are depth clipped - i.e. are obscured by 3D objects in front; of them. *Origin axes* (which generally pass through the middle of the; 3D scene) are not depth clipped - so always visible. A single orange sphere of fixed view port (window) size can be shown at; any arbitrary position. Enable / di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:117062,Guid,Guides,117062,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['Guid'],['Guides']
Usability,"y to:. - have a system-wide, sysadmin-provided experiment configuration. - execute user actions either *before* or *after* the execution of the; system-wide script (for instance, choosing the preferred version of; the experiment's software). - transfer a custom user **payload** on each PROOF worker (for instance,; user's client-generated Grid credentials to make PROOF workers; capable of accessing a remote authenticated storage). Configuration files are searched for in two different locations:. - a system-wide directory: `<client_install_dir>/etc`. - user's home directory: `~/.vaf`. > A system-wide configuration file always has precedence over user's; > configuration. It is thus possible for the sysadmin to enforce a; > policy where some scripts cannot ever be overridden. Thanks to this separation, users can maintain an uncluttered directory; with very simple configuration files that contain only what really needs; or is allowed to be customized: for instance, user might specify a single line; containing the needed ROOT version, while all the technicalities to set; up the environment are taken care of inside system-installed scripts,; leaving the user's configuration directory clean and uncluttered. ### Local environment configuration. All the local environment files are loaded at the time of the; client's startup following a certain order. - `common.before`. - `local.before`. - `local.conf`. - `$VafConf_LocalPodLocation/PoD_env.sh`. - `common.after`. - `local.after`. The `common.*` files are sourced both for the local and the remote; environment. This might be convenient to avoid repeating the same; configuration in different places. Each file is looked for first in the system-wide directory and then in; the user's directory. If a configuration file does not exist, it is; silently skipped. The `$VafConf_LocalPodLocation/PoD_env.sh` environment script, provided; with each PROOF on Demand installation, *must exist*: without this file,; the VAF client won't start. ###",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:2150,simpl,simple,2150,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['simpl'],['simple']
Usability,"y will stop to perform cleanups. For example, the GNU C++ unwinder; doesn't do so unless the exception is actually caught somewhere further up the; stack. In order for inlining to behave correctly, landing pads must be prepared to; handle selector results that they did not originally advertise. Suppose that a; function catches exceptions of type ``A``, and it's inlined into a function that; catches exceptions of type ``B``. The inliner will update the ``landingpad``; instruction for the inlined landing pad to include the fact that ``B`` is also; caught. If that landing pad assumes that it will only be entered to catch an; ``A``, it's in for a rude awakening. Consequently, landing pads must test for; the selector results they understand and then resume exception propagation with; the `resume instruction <LangRef.html#i_resume>`_ if none of the conditions; match. Exception Handling Intrinsics; =============================. In addition to the ``landingpad`` and ``resume`` instructions, LLVM uses several; intrinsic functions (name prefixed with ``llvm.eh``) to provide exception; handling information at various points in generated code. .. _llvm.eh.typeid.for:. ``llvm.eh.typeid.for``; ----------------------. .. code-block:: llvm. i32 @llvm.eh.typeid.for(i8* %type_info). This intrinsic returns the type info index in the exception table of the current; function. This value can be used to compare against the result of; ``landingpad`` instruction. The single argument is a reference to a type info. Uses of this intrinsic are generated by the C++ front-end. .. _llvm.eh.exceptionpointer:. ``llvm.eh.exceptionpointer``; ----------------------------. .. code-block:: text. i8 addrspace(N)* @llvm.eh.padparam.pNi8(token %catchpad). This intrinsic retrieves a pointer to the exception caught by the given; ``catchpad``. SJLJ Intrinsics; ---------------. The ``llvm.eh.sjlj`` intrinsics are used internally within LLVM's; backend. Uses of them are generated by the backend's; ``SjLjEHPrepa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:15180,resume,resume,15180,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['resume'],['resume']
Usability,"y; - `ics <./_static/LoopOptWG_invite.ics>`__; - `Minutes/docs <https://docs.google.com/document/d/1sdzoyB11s0ccTZ3fobqctDpgJmRoFcz0sviKxqczs4g/edit>`__; * - RISC-V; - Every 2 weeks on Thursday; - `ics <https://calendar.google.com/calendar/ical/lowrisc.org_0n5pkesfjcnp0bh5hps1p0bd80%40group.calendar.google.com/public/basic.ics>`__; `gcal <https://calendar.google.com/calendar/b/1?cid=bG93cmlzYy5vcmdfMG41cGtlc2ZqY25wMGJoNWhwczFwMGJkODBAZ3JvdXAuY2FsZW5kYXIuZ29vZ2xlLmNvbQ>`__; - `Minutes/docs <https://docs.google.com/document/d/1G3ocHm2zE6AYTS2N3_3w2UxFnSEyKkcF57siLWe-NVs>`__; * - Scalable Vectors and Arm SVE; - Monthly, every 3rd Tuesday; - `ics <https://calendar.google.com/calendar/ical/bjms39pe6k6bo5egtsp7don414%40group.calendar.google.com/public/basic.ics>`__; `gcal <https://calendar.google.com/calendar/u/0/embed?src=bjms39pe6k6bo5egtsp7don414@group.calendar.google.com>`__; - `Minutes/docs <https://docs.google.com/document/d/1UPH2Hzou5RgGT8XfO39OmVXKEibWPfdYLELSaHr3xzo/edit>`__; * - ML Guided Compiler Optimizations; - Monthly; -; - `Minutes/docs <https://docs.google.com/document/d/1JecbplF09l3swTjze-UVeLh4L48svJxGVy4mz_e9Rhs/edit?usp=gmail#heading=h.ts9cmcjbir1j>`__; * - `LLVM security group <https://llvm.org/docs/Security.html>`__; - Monthly, every 3rd Tuesday; - `ics <https://calendar.google.com/calendar/ical/eoh3m9k1l6vqbd1fkp94fv5q74%40group.calendar.google.com/public/basic.ics>`__; `gcal <https://calendar.google.com/calendar/embed?src=eoh3m9k1l6vqbd1fkp94fv5q74%40group.calendar.google.com>`__; - `Minutes/docs <https://discourse.llvm.org/t/llvm-security-group-public-sync-ups/62735>`__; * - `CIRCT <https://github.com/llvm/circt>`__; - Weekly, on Wednesday; -; - `Minutes/docs <https://docs.google.com/document/d/1fOSRdyZR2w75D87yU2Ma9h2-_lEPL4NxvhJGJd-s5pk/edit#heading=h.mulvhjtr8dk9>`__; * - `MLIR <https://mlir.llvm.org>`__ design meetings; - Weekly, on Thursdays; -; - `Minutes/docs <https://docs.google.com/document/d/1y_9f1AbfgcoVdJh4_aM6-BaSHvrHl8zuA5G4jv_94K8/e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:5603,Guid,Guided,5603,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['Guid'],['Guided']
Usability,"ybe you just want to follow; the development of the project to see it progress. Contribute. See the hacking document for information on how; to author patches. Follow what's going on; Clang is a subproject of the LLVM Project; and has a Discourse forum and mailing list:. Clang Frontend Discourse forum -; This forum is for discussions related to Clang (questions and answers, design; discussions, RFCs, etc).; Discord chat - Real-time chat for; discussions related to Clang (primarily for questions and answers).; Regular meetings are held on the. first and third Wednesday of each month to discuss C and C++; standards-related activities happening within the Clang community. These; meetings are a way to coordinate efforts between implementers and provide; updates on how standards activities are going. Meeting agendas and minutes are; available. here. Clang office hours -; People within the community hold dedicated office hours at different points; during the month, which is a great way opportunity for getting questions; answered, having more in-depth design discussions, or learning about what's; going on in the community in general.; cfe-commits; - Historical record of commits to Clang and contains early community patch; review commentary. The most common way to talk with other developers on the project is through; the Clang Frontend Discourse forum; . The clang forum is a very friendly place and we welcome newcomers. The; forum is archived so you can browse through previous discussions or follow; development on the web if you prefer.; If you're looking for something to work on, check out our Open Projects page or look through the LLVM bug tracker.; Contributing Extensions to Clang; Clang is designed to support experimentation,; allowing programmers to easily extend the compiler to support great; new language features and tools. At some point, the authors of these; extensions may propose that the extensions become a part of Clang; itself, to benefit the whole Clang commun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:1329,learn,learning,1329,interpreter/llvm-project/clang/www/get_involved.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html,1,['learn'],['learning']
Usability,"ylibs and set up linkage relationships; --------------------------------------------------------. In ORC, all symbol definitions reside in JITDylibs. JITDylibs are created by; calling the ``ExecutionSession::createJITDylib`` method with a unique name:. .. code-block:: c++. ExecutionSession ES;; auto &JD = ES.createJITDylib(""libFoo.dylib"");. The JITDylib is owned by the ``ExecutionEngine`` instance and will be freed; when it is destroyed. How to remove code; ------------------. To remove an individual module from a JITDylib it must first be added using an; explicit ``ResourceTracker``. The module can then be removed by calling; ``ResourceTracker::remove``:. .. code-block:: c++. auto &JD = ... ;; auto M = ... ;. auto RT = JD.createResourceTracker();; Layer.add(RT, std::move(M)); // Add M to JD, tracking resources with RT. RT.remove(); // Remove M from JD. Modules added directly to a JITDylib will be tracked by that JITDylib's default; resource tracker. All code can be removed from a JITDylib by calling ``JITDylib::clear``. This; leaves the cleared JITDylib in an empty but usable state. JITDylibs can be removed by calling ``ExecutionSession::removeJITDylib``. This; clears the JITDylib and then puts it into a defunct state. No further operations; can be performed on the JITDylib, and it will be destroyed as soon as the last; handle to it is released. An example of how to use the resource management APIs can be found at; ``llvm/examples/OrcV2Examples/LLJITRemovableCode``. How to add the support for custom program representation; --------------------------------------------------------; In order to add the support for a custom program representation, a custom ``MaterializationUnit``; for the program representation, and a custom ``Layer`` are needed. The Layer will have two; operations: ``add`` and ``emit``. The ``add`` operation takes an instance of your program; representation, builds one of your custom ``MaterializationUnits`` to hold it, then adds it; to a ``JITDylib``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:24105,clear,clear,24105,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['clear'],['clear']
Usability,"yline); - TGaxis : [dflt](https://root.cern/js/latest/examples.htm#misc_axis); - TEllipse : [dflt](https://root.cern/js/latest/examples.htm#misc_ellipse); - TArrow : [dflt](https://root.cern/js/latest/examples.htm#misc_arrow); - TPolyMarker3D: [dflt](https://root.cern/js/latest/examples.htm#misc_3dmark). More examples of supported classes can be found on: <https://root.cern/js/latest/examples.htm>. There are special JSROOT draw options which only can be used with for `TCanvas` or `TPad` objects:. - logx - enable log10 scale for X axis; - logy - enable log10 scale for Y axis; - logz - enable log10 scale for Z axis; - log - enable log10 scale for X,Y,Z axes; - log2x - enable log2 scale for X axis; - log2y - enable log2 scale for Y axis; - log2z - enable log2 scale for Z axis; - log2 - enable log2 scale for X,Y,Z axes; - gridx - enable grid for X axis; - gridy - enable grid for X axis; - grid - enable grid for X and Y axes; - tickx - enable ticks for X axis; - ticky - enable ticks for X axis; - tick - enable ticks for X and Y axes; - rx - reverse X axis; - ry - reverse Y axis; - rotate - rotate frame; - fixframe - disable interactive moving of the frame; - nozoomx - disable zooming on X axis; - nozoomy - disable zooming on Y axis; - cpXY - create palette XY for the canvas like cp50; - nopalette - ignore palette stored with TCanvas; - nocolors - ignore colors list stored with TCanvas; - lcolors - use only locally colors list stored with TCanvas; - nomargins - clear frame margins. ## Superimposing draw objects. In the URL string one could use ""+"" sign to specify objects superposition:. - [item=hpx+hprof](https://root.cern/js/latest/?file=../files/hsimple.root&item=hpx+hprof). With similar syntax one could specify individual draw options for superimposed objects. - [item=hpx+hprof&opt=logy+hist](https://root.cern/js/latest/?file=../files/hsimple.root&item=hpx+hprof&opt=logy+hist). Here ""logy"" option will be used for ""hpx1"" item and ""hist"" option for ""hprof;1"" item. While d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:13811,clear,clear,13811,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['clear'],['clear']
Usability,"yms are; valuable [ParzyszekAcronym]_ [LattnerAcronym]_. The most commonly cited acronym; is ``TLI`` however that is used to refer to both ``TargetLowering`` and; ``TargetLibraryInfo`` [GreeneDistinguish]_. The following is a list of acronyms considered sufficiently useful that the; benefit of using them outweighs the cost of learning them. Acronyms that are; either not on the list or are used to refer to a different type should be; expanded. ============================ =============; Class name Variable name; ============================ =============; DeterministicFiniteAutomaton dfa; DominatorTree dt; LoopInfo li; MachineFunction mf; MachineInstr mi; MachineRegisterInfo mri; ScalarEvolution se; TargetInstrInfo tii; TargetLibraryInfo tli; TargetRegisterInfo tri; ============================ =============. In some cases renaming acronyms to the full type name will result in overly; verbose code. Unlike most classes, a variable's scope is limited and therefore; some of its purpose can implied from that scope, meaning that fewer words are; necessary to give it a clear name. For example, in an optimization pass the reader; can assume that a variable's purpose relates to optimization and therefore an; ``OptimizationRemarkEmitter`` variable could be given the name ``remarkEmitter``; or even ``remarker``. The following is a list of longer class names and the associated shorter; variable name. ========================= =============; Class name Variable name; ========================= =============; BasicBlock block; ConstantExpr expr; ExecutionEngine engine; MachineOperand operand; OptimizationRemarkEmitter remarker; PreservedAnalyses analyses; PreservedAnalysesChecker checker; TargetLowering lowering; TargetMachine machine; ========================= =============. Transition Options; ==================. There are three main options for transitioning:. 1. Keep the current coding standard; 2. Laissez faire; 3. Big bang. Keep the current coding standard; -----------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:6595,clear,clear,6595,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['clear'],['clear']
Usability,"ynamic allocation of the coroutine frame; when possible. Example:; """""""""""""""". .. code-block:: llvm. entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %dyn.alloc.required = call i1 @llvm.coro.alloc(token %id); br i1 %dyn.alloc.required, label %coro.alloc, label %coro.begin. coro.alloc:; %frame.size = call i32 @llvm.coro.size(); %alloc = call ptr @MyAlloc(i32 %frame.size); br label %coro.begin. coro.begin:; %phi = phi ptr [ null, %entry ], [ %alloc, %coro.alloc ]; %frame = call ptr @llvm.coro.begin(token %id, ptr %phi). .. _coro.noop:. 'llvm.coro.noop' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.noop(). Overview:; """""""""""""""""". The '``llvm.coro.noop``' intrinsic returns an address of the coroutine frame of; a coroutine that does nothing when resumed or destroyed. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to refer to a private constant coroutine frame. The; resume and destroy handlers for this frame are empty functions that do nothing.; Note that in different translation units llvm.coro.noop may return different pointers. .. _coro.frame:. 'llvm.coro.frame' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.frame(). Overview:; """""""""""""""""". The '``llvm.coro.frame``' intrinsic returns an address of the coroutine frame of; the enclosing coroutine. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to refer to the `coro.begin`_ instruction. This is; a frontend convenience intrinsic that makes it easier to refer to the; coroutine frame. .. _coro.id:. 'llvm.coro.id' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.id(i32 <align>, ptr <promise>, ptr <coroaddr>,; ptr <fnaddrs>). Overview:; """""""""""""""""". The '``llvm.coro.id``' intrinsic returns a token identifying a; switched-resume coroutine. Arguments:; """""""""""""""""""". The first argument provides information on the alignment of the memory returned; by ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:36176,resume,resume,36176,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ynamicValueRelocTableSection: {type: int}; GuardRFVerifyStackPointerFunctionPointer: {type: int}; HotPatchTableOffset: {type: int}; EnclaveConfigurationPointer: {type: int}; VolatileMetadataPointer: {type: int}; GuardEHContinuationTable: {type: int}; GuardEHContinuationCount: {type: int}; GuardXFGCheckFunctionPointer: {type: int}; GuardXFGDispatchFunctionPointer: {type: int}; GuardXFGTableDispatchFunctionPointer: {type: int}; CastGuardOsDeterminedFailureMode: {type: int}. symbols:; - Name: .text; Value: 0; SectionNumber: 1; SimpleType: IMAGE_SYM_TYPE_NULL # (0); ComplexType: IMAGE_SYM_DTYPE_NULL # (0); StorageClass: IMAGE_SYM_CLASS_STATIC # (3); NumberOfAuxSymbols: 1; AuxiliaryData:; ""\x24\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00"" # |$.................|. - Name: _main; Value: 0; SectionNumber: 1; SimpleType: IMAGE_SYM_TYPE_NULL # (0); ComplexType: IMAGE_SYM_DTYPE_NULL # (0); StorageClass: IMAGE_SYM_CLASS_EXTERNAL # (2). Here's a simplified Kwalify_ schema with an extension to allow alternate types. .. _Kwalify: http://www.kuwata-lab.com/kwalify/ruby/users-guide.html. .. code-block:: yaml. type: map; mapping:; header:; type: map; mapping:; Machine: [ {type: str, enum:; [ IMAGE_FILE_MACHINE_UNKNOWN; , IMAGE_FILE_MACHINE_AM33; , IMAGE_FILE_MACHINE_AMD64; , IMAGE_FILE_MACHINE_ARM; , IMAGE_FILE_MACHINE_ARMNT; , IMAGE_FILE_MACHINE_ARM64; , IMAGE_FILE_MACHINE_EBC; , IMAGE_FILE_MACHINE_I386; , IMAGE_FILE_MACHINE_IA64; , IMAGE_FILE_MACHINE_M32R; , IMAGE_FILE_MACHINE_MIPS16; , IMAGE_FILE_MACHINE_MIPSFPU; , IMAGE_FILE_MACHINE_MIPSFPU16; , IMAGE_FILE_MACHINE_POWERPC; , IMAGE_FILE_MACHINE_POWERPCFP; , IMAGE_FILE_MACHINE_R4000; , IMAGE_FILE_MACHINE_SH3; , IMAGE_FILE_MACHINE_SH3DSP; , IMAGE_FILE_MACHINE_SH4; , IMAGE_FILE_MACHINE_SH5; , IMAGE_FILE_MACHINE_THUMB; , IMAGE_FILE_MACHINE_WCEMIPSV2; ]}; , {type: int}; ]; Characteristics:; - type: seq; sequence:; - type: str; enum: [ IMAGE_FILE_RELOCS_STRIPPED; , IMAGE_FILE_EXECUTABLE_IMAGE; , IMAGE_FILE_LINE_NU",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/yaml2obj.rst:3050,simpl,simplified,3050,interpreter/llvm-project/llvm/docs/yaml2obj.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/yaml2obj.rst,1,['simpl'],['simplified']
Usability,"yntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ``expected-<type> <n> {{diag text}}``, where ``<type>`` is one of; ``error``, ``warning``, ``remark``, or ``note``, and ``<n>`` is a positive; integer. This allows the diagnostic to appear as many times as specified. For; example:. .. code-block:: c++. void f(); // expected-note 2 {{previous declaration is here}}. Where the diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``+``. For example:. .. code-block:: c++. void g(); // expected-note + {{previous declaration is here}}. A range can also be specified by ``<n>-<m>``. For example:. .. code-block:: c++. void f(); // expected-note 0-1 {{previous declaration is here}}. In this example, the diagnostic may appear only once, if at all. .. _DiagnosticMatching:. Matching Modes; ~~~~~~~~~~~~~~. The default matching mode is simple string, which looks for the expected text; that appears between the first `{{` and `}}` pair of the comment. The string is; interpreted just as-is, with one exception: the sequence `\n` is converted to a; single newline character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:160469,simpl,simply,160469,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability,"you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18130,guid,guide,18130,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['guid'],['guide']
Usability,"you; can choose the form most appropriate for your application. .. _lists:. Parsing a list of options; -------------------------. Now that we have the standard run-of-the-mill argument types out of the way,; lets get a little wild and crazy. Lets say that we want our optimizer to accept; a **list** of optimizations to perform, allowing duplicates. For example, we; might want to run: ""``compiler -dce -instsimplify -inline -dce -strip``"". In this; case, the order of the arguments and the number of appearances is very; important. This is what the ""``cl::list``"" template is for. First, start by; defining an enum of the optimizations that you would like to perform:. .. code-block:: c++. enum Opts {; // 'inline' is a C++ keyword, so name it 'inlining'; dce, instsimplify, inlining, strip; };. Then define your ""``cl::list``"" variable:. .. code-block:: c++. cl::list<Opts> OptimizationList(cl::desc(""Available Optimizations:""),; cl::values(; clEnumVal(dce , ""Dead Code Elimination""),; clEnumVal(instsimplify , ""Instruction Simplification""),; clEnumValN(inlining, ""inline"", ""Procedure Integration""),; clEnumVal(strip , ""Strip Symbols"")));. This defines a variable that is conceptually of the type; ""``std::vector<enum Opts>``"". Thus, you can access it with standard vector; methods:. .. code-block:: c++. for (unsigned i = 0; i != OptimizationList.size(); ++i); switch (OptimizationList[i]); ... ... to iterate through the list of options specified. Note that the ""``cl::list``"" template is completely general and may be used with; any data types or other arguments that you can use with the ""``cl::opt``""; template. One especially useful way to use a list is to capture all of the; positional arguments together if there may be more than one specified. In the; case of a linker, for example, the linker takes several '``.o``' files, and; needs to capture them into a list. This is naturally specified as:. .. code-block:: c++. ...; cl::list<std::string> InputFilenames(cl::Positional, cl::desc(""<In",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:20017,Simpl,Simplification,20017,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['Simpl'],['Simplification']
Usability,"ype of the continuation function is ``void`` there must be no; arguments. - if the return type of the continuation function is a ``struct``, the arguments; will be of element types of that ``struct`` in order;. - otherwise, it is just the return value of the continuation function. .. code-block:: llvm. define {ptr, ptr} @g(ptr %buffer, ptr %ptr, i8 %val) presplitcoroutine {; entry:; %id = call token @llvm.coro.id.retcon.once(i32 8, i32 8, ptr %buffer,; ptr @prototype,; ptr @allocate, ptr @deallocate); %hdl = call ptr @llvm.coro.begin(token %id, ptr null). ... cleanup:; %tok = call token (...) @llvm.coro.end.results(i8 %val); call i1 @llvm.coro.end(ptr %hdl, i1 0, token %tok); unreachable. ... declare i8 @prototype(ptr, i1 zeroext); . 'llvm.coro.end.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i1 @llvm.coro.end.async(ptr <handle>, i1 <unwind>, ...). Overview:; """""""""""""""""". The '``llvm.coro.end.async``' marks the point where execution of the resume part; of the coroutine should end and control should return to the caller. As part of; its variable tail arguments this instruction allows to specify a function and; the function's arguments that are to be tail called as the last action before; returning. Arguments:; """""""""""""""""""". The first argument should refer to the coroutine handle of the enclosing; coroutine. A frontend is allowed to supply null as the first parameter, in this; case `coro-early` pass will replace the null with an appropriate coroutine; handle value. The second argument should be `true` if this coro.end is in the block that is; part of the unwind sequence leaving the coroutine body due to an exception and; `false` otherwise. The third argument if present should specify a function to be called. If the third argument is present, the remaining arguments are the arguments to; the function call. .. code-block:: llvm. call i1 (ptr, i1, ...) @llvm.coro.end.async(; ptr %hdl, i1 0,; ptr @must_tail_call_return,; ptr %ctxt, ptr %task, pt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:48552,resume,resume,48552,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ype>` attribute specifying; the function type of the target. The target can be specified as either; a symbolic LLVM function, or as an arbitrary Value of pointer type. Note; that the function type must match the signature of the callee and the; types of the 'call parameters' arguments. The '#call args' operand is the number of arguments to the actual; call. It must exactly match the number of arguments passed in the; 'call parameters' variable length section. The 'flags' operand is used to specify extra information about the; statepoint. This is currently only used to mark certain statepoints; as GC transitions. This operand is a 64-bit integer with the following; layout, where bit 0 is the least significant bit:. +-------+---------------------------------------------------+; | Bit # | Usage |; +=======+===================================================+; | 0 | Set if the statepoint is a GC transition, cleared |; | | otherwise. |; +-------+---------------------------------------------------+; | 1-63 | Reserved for future use; must be cleared. |; +-------+---------------------------------------------------+. The 'call parameters' arguments are simply the arguments which need to; be passed to the call target. They will be lowered according to the; specified calling convention and otherwise handled like a normal call; instruction. The number of arguments must exactly match what is; specified in '# call args'. The types must match the signature of; 'target'. The 'call parameter' attributes must be followed by two 'i64 0' constants.; These were originally the length prefixes for 'gc transition parameter' and; 'deopt parameter' arguments, but the role of these parameter sets have been; entirely replaced with the corresponding operand bundles. In a future; revision, these now redundant arguments will be removed. Semantics:; """""""""""""""""""". A statepoint is assumed to read and write all memory. As a result,; memory operations can not be reordered past a statepoint. It is; illega",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:502434,clear,cleared,502434,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['clear'],['cleared']
Usability,"ys appears to be; ``V70``, and it is not clear what the other values are for. - **Age** - The number of times the PDB has been written. Equal to the same; field from the :ref:`PDB Stream header <pdb_stream_header>`. - **GlobalStreamIndex** - The index of the :doc:`Global Symbol Stream <GlobalStream>`,; which contains CodeView symbol records for all global symbols. Actual records; are stored in the symbol record stream, and are referenced from this stream. - **BuildNumber** - A bitfield containing values representing the major and minor; version number of the toolchain (e.g. 12.0 for MSVC 2013) used to build the; program, with the following layout:. .. code-block:: c++. uint16_t MinorVersion : 8;; uint16_t MajorVersion : 7;; uint16_t NewVersionFormat : 1;. For the purposes of LLVM, we assume ``NewVersionFormat`` to be always ``true``.; If it is ``false``, the layout above does not apply and the reader should consult; the `Microsoft Source Code <https://github.com/Microsoft/microsoft-pdb>`__ for; further guidance. - **PublicStreamIndex** - The index of the :doc:`Public Symbol Stream <PublicStream>`,; which contains CodeView symbol records for all public symbols. Actual records; are stored in the symbol record stream, and are referenced from this stream. - **PdbDllVersion** - The version number of ``mspdbXXXX.dll`` used to produce this; PDB. Note this obviously does not apply for LLVM as LLVM does not use ``mspdb.dll``. - **SymRecordStream** - The stream containing all CodeView symbol records used; by the program. This is used for deduplication, so that many different; compilands can refer to the same symbols without having to include the full record; content inside of each module stream. - **PdbDllRbld** - Unknown. - **MFCTypeServerIndex** - The index of the MFC type server in the; :ref:`dbi_type_server_map_substream`. - **Flags** - A bitfield with the following layout, containing various; information about how the program was built:. .. code-block:: c++. uint16_t Was",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst:2787,guid,guidance,2787,interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,1,['guid'],['guidance']
Usability,"ysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3651,guid,guide,3651,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['guid'],['guide']
Usability,"ytes>K|<megabytes>M|<gigabytes>G}.  indicating the max number of bytes. The number can be followed by; a {K,M,G} to indicate KBytes, MBytes or GBytes, respectively.; Add new derivation of TList (TProofOutputList) to be used on the; PROOF client to filter out PROOF internal objects when displaying or; printing the list. By default objects was names start with 'PROOF_' are; not shown. The presence of a non empty missing file list is; notified.; In the PROOF monitoring to: send additional information about memory; usage during the query, the name and size (# of files) of the dataset; processed (if any); add possibility to send the information to multiple; monitoring collectors.; Add support for block activation/deactivation of workers.; Add possibility to start the proofserv with 'system()' instead of; 'fork()' as done in PROOF-Lite. A new switch 'usefrk' has been added to; 'xpd.proofservmgr' to control that. Default is still fork(). Improvements; ; In TProof::ClearPackages, use the manager to execute the command on; all known worker machines. Improves the consistency when re-istalling; packages. In TProof::GetDataSets, add support for option ':lite:'; this allows; to fill the map with only the summary information about the datasets; (the header of TFileCollections), significantly increasing the speed; and the memory footprint when the number of datasets is very large.; Accept '.' in user names.; Add switch to control caching of the files read on MacOsX. A call to; fcntl(fd, F_NOCACHE, 1) is done after opening the file.; Add export of the envs ROOTPROOFCLIENT and ROOTPROOFLITE when; appropriate. These allow to steer building and/or enabling of PAR files; in PROOF-INF/BUILD.sh and/or PROOF-INF/SETUP.C, improving transparency; between normal ROOT and PROOF. The example PAR; 'tutorials/proof/event.par' has been modified to check the two; variables.; Fix a few issues in SQL PROOF monitoring: in; TSQLMonitoringWriter::SendParameters, drop ''' around field names in; the INSE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:2784,Clear,ClearPackages,2784,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,1,['Clear'],['ClearPackages']
Usability,"ze one-dimensional function.; An interval containing the function minimum must be provided.; Here is an example where we define the function to minimize as a *lambda* function; (requires C++11). The function to minimize must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object. ```{.cpp}; ROOT::Math::Functor1D func( [](double x){ return 1 + -4*x + 1*x*x; } );. ROOT::Math::BrentMinimizer1D bm;; bm.SetFunction(func, -10,10);; bm.Minimize(10,0,0);; cout << ""Minimum: f("" << bm.XMinimum() << "") = "" <<bm.FValMinimum() << endl;; ```. Note that when setting the function to minimize, one needs to provide the interval range to find the minimum.; In the `Minimize` call, the maximum number of function calls, the relative and absolute tolerance must be provided. #### `ROOT::Math::GSLMInimizer1D`. This class wraps two different methods from the GSL.; The algorithms which can be chosen at construction time are *GOLDENSECTION*, which is the simplest method; but the slowest and *BRENT* (the default one) which combines the golden section with a parabolic interpolation.; The algorithm can be chosen as a different enumeration in the constructor:; * `ROOT::Math::Minim1D::kBRENT` for the Brent algorithm (default); * `ROOT::Math::Minim1D::kGOLDENSECTION` for the golden section algorithm. ```{.cpp}; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; ```. The interface to set the function and to minimize is the same as in the case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The minmization is implemented in `TF1` using the BrentMInimizer1D and available with the class member functions; * `TF1::GetMinimum`/`TF1:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:65111,simpl,simplest,65111,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['simpl'],['simplest']
Usability,{# This template defines sidebar which can be used to provide common links on; all documentation pages. #}. Documentation. Getting Started/Tutorials; User Guides; Reference. Getting Involved. Contributing to LLVM; Submitting Bug Reports; Mailing Lists; IRC; Meetups and Social Events. Additional Links. FAQ; Glossary; Publications; Github Repository; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/_templates/indexsidebar.html:155,Guid,Guides,155,interpreter/llvm-project/llvm/docs/_templates/indexsidebar.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/_templates/indexsidebar.html,1,['Guid'],['Guides']
Usability,"{; public:; OurFunctionPass(): callCounter(0) { }. virtual runOnFunction(Function& F) {; for (BasicBlock &B : F) {; for (Instruction &I: B) {; if (auto *CB = dyn_cast<CallBase>(&I)) {; // We know we've encountered some kind of call instruction (call,; // invoke, or callbr), so we need to determine if it's a call to; // the function pointed to by m_func or not.; if (CB->getCalledFunction() == targetFunc); ++callCounter;; }; }; }; }. private:; unsigned callCounter;; };. .. _iterate_chains:. Iterating over def-use & use-def chains; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Frequently, we might have an instance of the ``Value`` class (`doxygen; <https://llvm.org/doxygen/classllvm_1_1Value.html>`__) and we want to determine; which ``User``\ s use the ``Value``. The list of all ``User``\ s of a particular; ``Value`` is called a *def-use* chain. For example, let's say we have a; ``Function*`` named ``F`` to a particular function ``foo``. Finding all of the; instructions that *use* ``foo`` is as simple as iterating over the *def-use*; chain of ``F``:. .. code-block:: c++. Function *F = ...;. for (User *U : F->users()) {; if (Instruction *Inst = dyn_cast<Instruction>(U)) {; errs() << ""F is used in instruction:\n"";; errs() << *Inst << ""\n"";; }. Alternatively, it's common to have an instance of the ``User`` Class (`doxygen; <https://llvm.org/doxygen/classllvm_1_1User.html>`__) and need to know what; ``Value``\ s are used by it. The list of all ``Value``\ s used by a ``User`` is; known as a *use-def* chain. Instances of class ``Instruction`` are common; ``User`` s, so we might want to iterate over all of the values that a particular; instruction uses (that is, the operands of the particular ``Instruction``):. .. code-block:: c++. Instruction *pi = ...;. for (Use &U : pi->operands()) {; Value *v = U.get();; // ...; }. Declaring objects as ``const`` is an important tool of enforcing mutation free; algorithms (such as analyses, etc.). For this purpose above iterators come in; consta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:111375,simpl,simple,111375,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"{; task get_return_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_counter_1 = {__int_8 = 0 '\000'}, class_await_counter_2 = {__int_8 = 0 '\000'}, struct_std__suspend_always_3 = {__int_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the fir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:7134,resume,resume,7134,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability,"| Load Hardening | Mitigated Speedup |; | -------------------------------------- | -------: | -------------: | ----------------: |; | Google microbenchmark suite | -74.8% | -36.4% | **2.5x** |; | Large server QPS (using ThinLTO & PGO) | -62% | -29% | **1.8x** |. Below is a visualization of the microbenchmark suite results which helps show; the distribution of results that is somewhat lost in the summary. The y-axis is; a log-scale speedup ratio of load hardening relative to `lfence` (up -> faster; -> better). Each box-and-whiskers represents one microbenchmark which may have; many different metrics measured. The red line marks the median, the box marks; the first and third quartiles, and the whiskers mark the min and max. ![Microbenchmark result visualization](speculative_load_hardening_microbenchmarks.png). We don't yet have benchmark data on SPEC or the LLVM test suite, but we can; work on getting that. Still, the above should give a pretty clear; characterization of the performance, and specific benchmarks are unlikely to; reveal especially interesting properties. ### Future Work: Fine Grained Control and API-Integration. The performance overhead of this technique is likely to be very significant and; something users wish to control or reduce. There are interesting options here; that impact the implementation strategy used. One particularly appealing option is to allow both opt-in and opt-out of this; mitigation at reasonably fine granularity such as on a per-function basis,; including intelligent handling of inlining decisions -- protected code can be; prevented from inlining into unprotected code, and unprotected code will become; protected when inlined into protected code. For systems where only a limited; set of code is reachable by externally controlled inputs, it may be possible to; limit the scope of mitigation through such mechanisms without compromising the; application's overall security. The performance impact may also be focused in a; few key functions",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:48689,clear,clear,48689,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['clear'],['clear']
Usability,"| Q3 | S3 | | | Exit |; +---------+-------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+------+; | Thread2 | Entry | | | | R2 | S2 | P2 | Q2 | S2 | P4 | ... | Exit |; +---------+-------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+------+. |. Thus, when diverged paths reach different entries of an irreducible; cycle from outside the cycle, the static analysis conservatively; reports every node in the cycle as not m-converged. .. _convergence-reducible-cycle:. Reducible Cycle; ---------------. If ``C`` is a reducible cycle with header ``H``, then in any DFS,; ``H`` :ref:`must be the header of some cycle<cycle-reducible-headers>`; ``C'`` that contains ``C``. Independent of the DFS, there is no entry; to the subgraph ``C`` other than ``H`` itself. Thus, we have the; following:. 1. The diverged entry criterion is trivially satisfied for a divergent; branch and its join, where both are inside subgraph ``C``.; 2. When diverged paths reach the subgraph ``C`` from outside, their; convergence is always determined by the same header ``H``. Clearly, this can be determined only in a cycle hierarchy ``T`` where; ``C`` is detected as a reducible cycle. No such conclusion can be made; in a different cycle hierarchy ``T'`` where ``C`` is part of a larger; cycle ``C'`` with the same header, but this does not contradict the; conclusion in ``T``. Controlled Convergence; ======================. :ref:`Convergence control tokens <dynamic_instances_and_convergence_tokens>`; provide an explicit semantics for determining which threads are converged at a; given point in the program. The impact of this is incorporated in a; :ref:`controlled maximal converged-with <controlled_maximal_converged_with>`; relation over dynamic instances and a :ref:`controlled m-converged; <controlled_m_converged>` property of static instances. The :ref:`uniformity; analysis <uniformity-analysis>` implemented in LLVM includes this for targets; that support convergence control tokens.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:28880,Clear,Clearly,28880,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['Clear'],['Clearly']
Usability,"|; +---------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+; | ``{i32, i32} (i32)`` | A function taking an ``i32``, returning a :ref:`structure <t_struct>` containing two ``i32`` values |; +---------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+. .. _t_firstclass:. First Class Types; -----------------. The :ref:`first class <t_firstclass>` types are perhaps the most important.; Values of these types are the only ones which can be produced by; instructions. .. _t_single_value:. Single Value Types; ^^^^^^^^^^^^^^^^^^. These are the types that are valid in registers from CodeGen's perspective. .. _t_integer:. Integer Type; """""""""""""""""""""""". :Overview:. The integer type is a very simple type that simply specifies an; arbitrary bit width for the integer type desired. Any bit width from 1; bit to 2\ :sup:`23`\ (about 8 million) can be specified. :Syntax:. ::. iN. The number of bits the integer will occupy is specified by the ``N``; value. Examples:; *********. +----------------+------------------------------------------------+; | ``i1`` | a single-bit integer. |; +----------------+------------------------------------------------+; | ``i32`` | a 32-bit integer. |; +----------------+------------------------------------------------+; | ``i1942652`` | a really big integer of over 1 million bits. |; +----------------+------------------------------------------------+. .. _t_floating:. Floating-Point Types; """""""""""""""""""""""""""""""""""""""". .. list-table::; :header-rows: 1. * - Type; - Description. * - ``half``; - 16-bit floating-point value. * - ``bfloat``; - 16-bit ""brain"" floating-point value (7-bit significand). Provides the; same number of exponent bits as ``float``, so that it matches its dynamic; range, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:168276,simpl,simple,168276,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['simpl'],"['simple', 'simply']"
Usability,"}; {; TCanvas *c1 = new TCanvas(""c1"", ""c1"",0,0,1200,700);; int n = 100;; Float_t d = 0.5;; TH1F *h1 = new TH1F(""h1"", ""x_min = - d"", n, -d, 100-d);; h1->Fill(1, 1); h1->Fill(3, 3); h1->Fill(5, 5); h1->Fill(7, 7);. TH1F *h2 = new TH1F(""h2"", ""x_min = +d"", n, d, 100+d);; h2->Fill(1, 1); h2->Fill(3, 3); h2->Fill(5, 5); h2->Fill(7, 7);. c1->Divide(1, 2);; c1->cd(1); gPad->SetLogx(); h1->Draw(); // upper picture; c1->cd(2); gPad->SetLogx(); h2->Draw(); // lower picture; h1->GetXaxis()->SetMoreLogLabels();; h2->GetXaxis()->SetMoreLogLabels();; c1_1->SetGridx();; c1_2->SetGridx();; }; ```; - In `PaintStat2` the temporary string used to paint the fit parameters; was too small and in some cases the errors where truncated. The size; of the string is now the same as in `PaintStat`.; - Display the bin error for 2D histograms in the status bar.; - New option `CANDLE` to draw 2D histograms as Candle-PLot (Box-PLot).; A Candle plot (also known as a ""box-and whisker plot"" or simply ""box plot""); is a convenient way to describe graphically a data distribution (D) with; only the five numbers. It was invented in 1977 by John Tukey. With the option CANDLEX five numbers are:. 1. The minimum value of the distribution D (bottom dashed line).; 2. The lower quartile (Q1): 25% of the data points in D are less than; Q1 (bottom of the box).; 3. The median (M): 50% of the data points in D are less than M; (thick line segment inside the box).; 4. The upper quartile (Q3): 75% of the data points in D are less; than Q3 (top of the box).; 5. The maximum value of the distribution D (top dashed line). The mean value of the distribution D is also represented as a circle. In this implementation a TH2 is considered as a collection of TH1 along; X (option `CANDLE` or `CANDLEX`) or Y (option `CANDLEY`).; Each TH1 is represented as a candle plot. Example:. ``` {.cpp}; {; TH2F *hcandle = new TH2F(""hcandle"",""Option CANDLE example "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:3877,simpl,simply,3877,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['simpl'],['simply']
Usability,"}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities behind the macro. Note that the variable `pull` in line; *61* is different from the definition above: instead of the parameter; error on `mean`, the fitted standard deviation of the distribution; divided by the square root of the number of entries,; `sig/sqrt(n_tot_entries)`, is used. - What method exhibits the better performance with the default; parameters ?. - What happens if you increase the number of entries per histogram by; a factor of ten ? Why ?. The answers to these questions are well beyond the scope of this guide.; Basically all books about statistical methods provide a complete; treatment of the aforementioned topics. [^5]: ""Monte Carlo"" simulation means that random numbers play a role here; which is as crucial as in games of pure chance in the Casino of Monte Carlo.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:5737,guid,guide,5737,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,1,['guid'],['guide']
Usability,"~~~~~~~~~~~~~~~~~~. Of course, this alignment scheme works best if the address points are; in fact aligned correctly. To make this more likely to happen, we insert; padding between virtual tables that in many cases aligns address points to; a power of 2. Specifically, our padding aligns virtual tables to the next; highest power of 2 bytes; because address points for specific base classes; normally appear at fixed offsets within the virtual table, this normally; has the effect of aligning the address points as well. This scheme introduces tradeoffs between decreased space overhead for; instructions and bit vectors and increased overhead in the form of padding. We; therefore limit the amount of padding so that we align to no more than 128; bytes. This number was found experimentally to provide a good tradeoff. Eliminating Bit Vector Checks for All-Ones Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If the bit vector is all ones, the bit vector check is redundant; we simply; need to check that the address is in range and well aligned. This is more; likely to occur if the virtual tables are padded. Forward-Edge CFI for Virtual Calls by Interleaving Virtual Tables; -----------------------------------------------------------------. Dimitar et. al. proposed a novel approach that interleaves virtual tables in [1]_.; This approach is more efficient in terms of space because padding and bit vectors are no longer needed.; At the same time, it is also more efficient in terms of performance because in the interleaved layout; address points of the virtual tables are consecutive, thus the validity check of a virtual; vtable pointer is always a range check. At a high level, the interleaving scheme consists of three steps: 1) split virtual table groups into; separate virtual tables, 2) order virtual tables by a pre-order traversal of the class hierarchy; and 3) interleave virtual tables. The interleaving scheme implemented in LLVM is inspired by [1]_ but has it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:9404,simpl,simply,9404,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['simpl'],['simply']
Usability,"﻿=====================================; CodeView Type Records; =====================================. .. contents::; :local:. .. _types_intro:. Introduction; ============. This document describes the usage and serialization format of the various; CodeView type records that LLVM understands. This document does not describe; every single CodeView type record that is defined. In some cases, this is; because the records are clearly deprecated and can only appear in very old; software (e.g. the 16-bit types). On other cases, it is because the records; have never been observed in practice. This could be because they are only; generated for non-C++ code (e.g. Visual Basic, C#), or because they have been; made obsolete by newer records, or any number of other reasons. However, the; records we describe here should cover 99% of type records that one can expect; to encounter when dealing with modern C++ toolchains. Record Categories; =================. We can think of a sequence of CodeView type records as an array of variable length; `leaf records`. Each such record describes its own length as part of a fixed-size; header, as well as the kind of record it is. Leaf records are either padded to 4; bytes (if this type stream appears in a TPI/IPI stream of a PDB) or not padded at; all (if this type stream appears in the ``.debug$T`` section of an object file).; Padding is implemented by inserting a decreasing sequence of `<_padding_records>`; that terminates with ``LF_PAD0``. The final category of record is a ``member record``. One particular leaf type --; ``LF_FIELDLIST`` -- contains a series of embedded records. While the outer; ``LF_FIELDLIST`` describes its length (like any other leaf record), the embedded; records -- called ``member records`` do not. .. _leaf_types:. Leaf Records; ------------. All leaf records begin with the following 4 byte prefix:. .. code-block:: c++. struct RecordHeader {; uint16_t RecordLen; // Record length, not including this 2 byte field.; uint16_t R",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewTypes.rst:424,clear,clearly,424,interpreter/llvm-project/llvm/docs/PDB/CodeViewTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewTypes.rst,1,['clear'],['clearly']
